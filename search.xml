<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>汇编语言概要学习</title>
    <url>/2024/10/16/Assembly/</url>
    <content><![CDATA[<h3 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h3><h4 id="1-1-这门课学什么"><a href="#1-1-这门课学什么" class="headerlink" title="1.1 这门课学什么"></a>1.1 这门课学什么</h4><ul>
<li>定位：理解硬件结构，掌握指令集，理解程序的运行过程。</li>
<li>内容：选取8088、8086指令集进行汇编语言程序设计的学习。</li>
</ul>
<h4 id="1-2-机器语言与汇编语言"><a href="#1-2-机器语言与汇编语言" class="headerlink" title="1.2 机器语言与汇编语言"></a>1.2 机器语言与汇编语言</h4><p>机器语言是机器指令的集合。<br>机器指令是一台机器可以正确执行的命令。<br>机器指令由一串二进制数表示，例 01010000。</p>
<p>汇编语言的主体是汇编指令。<br>汇编指令和机器指令的差别在于指令的表示方法上：① 汇编指令是机器指令便于记忆的书写格式； ② 汇编指令是机器指令的助记符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>机器指令</th>
<th>汇编指令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>1000100111011000</td>
<td>MOV AX, BX</td>
<td>将寄存器BX的内容送到AX中</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://pic.imgdb.cn/item/670f217bd29ded1a8cc2f8f0.png"></p>
<p>用汇编语言编写程序的工作过程：程序员编写汇编指令→编译器编译为二进制机器码→计算机执行程序。</p>
<h4 id="1-3-计算机的组成"><a href="#1-3-计算机的组成" class="headerlink" title="1.3 计算机的组成"></a>1.3 计算机的组成</h4><p><img src="https://pic.imgdb.cn/item/670f2352d29ded1a8cc44843.png" style="zoom:60%"></p>
<p>CPU是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在<strong>存储器(内存，不是外存)</strong>中存放。离开了内存，性能再好的CPU也无法工作。</p>
<ul>
<li><strong>指令和数据的表示</strong></li>
</ul>
<p>计算机中的数据和指令，存储在内存或磁盘(外存)上。数据和指令都是二进制信息。</p>
<p>问题是如何判断一串二进制数字表示的是数据还是指令呢？由CPU决定。</p>
<ul>
<li><strong>计算机中的存储单元</strong></li>
</ul>
<p>存储器被划分为多个存储单元，存储单元从0开始编号。例如：8086有20条数据线，寻址空间为$2^{20} = 1\text{MB}$。</p>
<p><img src="https://pic.imgdb.cn/item/670f2914d29ded1a8cc81537.png" alt="存储单元编号"></p>
<blockquote>
<p><strong>简单补充：寄存器、缓存、内存、硬盘、存储器的理解</strong></p>
<p><strong>寄存器内置于CPU内部</strong>，是CPU内部的小型存储区域。它们通常由多个触发器构成，可以分为内部寄存器和外部接口寄存器。而<strong>内存则位于处理器外部是独立的硬件设备</strong>。它由内存芯片、电路板、金手指等部分组成，通过数据线与CPU相连。 </p>
<p>存取速度的比较：CPU(包含寄存器，缓存)&gt;内存 &gt; 硬盘<br>内存和硬盘之间的速度，差 3~4 个数量级；寄存器和内存之间的速度也差了 3~4 个数量级。由于寄存器和内存的速度差异很大，所以现代的 CPU 往往还提供了“缓存”模块。</p>
<p><a href="https://www.elecfans.com/d/2805654.html">寄存器和内存的区别 - 电子发烧友</a><br><a href="https://blog.csdn.net/zunguitiancheng/article/details/134870059">寄存器、缓存、内存、硬盘、存储器的理解 - CSDN</a><br><a href="https://blog.csdn.net/linsc_05/article/details/136913090">硬盘、内存、缓存（CPU）和寄存器 空间大小与存取速度的区别及设计原理 - CSDN</a></p>
</blockquote>
<ul>
<li><strong>计算机中的总线(BUS)</strong></li>
</ul>
<p>在计算机中专门有连接CPU和其他芯片的导线，通常称为总线。物理上：一根根导线的集合。逻辑上课划分为：<strong>地址总线、数据总线、控制总线</strong>。</p>
<p><strong>地址总线</strong>：CPU是通过地址总线来指定存储单元的。地址总线宽度决定了可寻址的存储单元大小，即$N$根地址总线(宽度为$N$)对应寻址空间$2^N$。</p>
<p><strong>数据总线</strong>：CPU与内存或其它器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。例：向内存中写入数据89D8H时的数据传送。</p>
<p><strong>控制总线</strong>：CPU通过控制总线对外部器件进行控制。控制总线是一些不同控制线的集合控制总线宽度决定了CPU对外部器件的控制能力。</p>
<h4 id="1-4-内存的读写与地址空间"><a href="#1-4-内存的读写与地址空间" class="headerlink" title="1.4 内存的读写与地址空间"></a>1.4 内存的读写与地址空间</h4><h5 id="1-4-1-CPU对存储器的读写"><a href="#1-4-1-CPU对存储器的读写" class="headerlink" title="1.4.1 CPU对存储器的读写"></a>1.4.1 CPU对存储器的读写</h5><ul>
<li>CPU要想进行数据的读写，必须和外部器件进行三类信息的交互<ul>
<li>存储单元的地址(地址信息 )；</li>
<li>器件的选择，读或写命令(控制信息 )；</li>
<li>读或写的数据(数据信息 )；</li>
</ul>
</li>
</ul>
<p>例如：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>机器指令</th>
<th>汇编指令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>101000000000001100000000</td>
<td>MOV AL, [3]</td>
<td>从3号内存存储单元读取数据送入寄存器AL</td>
</tr>
</tbody>
</table>
</div>
<h5 id="1-4-2-内存地址空间"><a href="#1-4-2-内存地址空间" class="headerlink" title="1.4.2 内存地址空间"></a>1.4.2 内存地址空间</h5><ul>
<li>什么是内存地址空间</li>
</ul>
<p>CPU地址总线宽度为$N$，寻址空间为$2^N$个字节。8086CPU的地址总线宽度为20，那么可以寻址$1\text{MB}$个内存单元，其内<strong>存地址空间</strong>为$1\text{MB}$。</p>
<ul>
<li>从CPU角度看地址空间分配</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/670f2e7ad29ded1a8cccfcc3.png"></p>
<p><strong><font color="blue">将各类存储器看作一个逻辑存储器——进行统一编址</font></strong>，即所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。</p>
<p><img src="https://pic.imgdb.cn/item/670f2facd29ded1a8cce26b4.png" style="zoom:60%"></p>
<p>内存地址空间的分配方案——以8086PC机为例(640+128+256=1024KB = 20根地址总线)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>00000H~9FFFFH(RAM)</th>
<th>A0000H~BFFFFH(RAM)</th>
<th>C0000H~FFFFFH(ROM)</th>
</tr>
</thead>
<tbody>
<tr>
<td>主存储器地址空间 640KB</td>
<td>显存地址空间 128KB</td>
<td>各类ROM地址空间 256KB</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>RAM指的是随机存取存储器，ROM指的是只读存储器。</strong></p>
<p><strong>1、RAM：</strong></p>
<p>随机存取存储器，缩写：RAM，也叫主存，是与CPU直接交换数据的内部存储器。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。</p>
<p><strong>2、ROM：</strong></p>
<p>只读存储器以非破坏性读出方式工作，只能读出无法写入信息。其中保存的数据是在制造计算机的时候就写好的，信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器。ROM所存数据通常是装入整机前写入的，整机工作过程中只能读出，不像随机存储器能快速方便地改写存储内容。</p>
</blockquote>
<h3 id="2-访问寄存器和内存"><a href="#2-访问寄存器和内存" class="headerlink" title="2 访问寄存器和内存"></a>2 访问寄存器和内存</h3><h4 id="2-1-寄存器以及数据存储"><a href="#2-1-寄存器以及数据存储" class="headerlink" title="2.1 寄存器以及数据存储"></a>2.1 寄存器以及数据存储</h4><p><img src="https://pic.imgdb.cn/item/670f6315d29ded1a8cf56703.png"></p>
<ul>
<li>寄存器是CPU内部的信息存储单元，以8086CPU为例，8086CPU有14个寄存器：<ul>
<li>通用寄存器：AX(AH + AL)、BX(BH + BL)、CX(CH + CL)、DX(DH + DL)</li>
<li>变址寄存器：SI、DI</li>
<li>指针寄存器：SP、BP</li>
<li>指令指针寄存器：IP</li>
<li>段寄存器：CS、SS、DS、ES</li>
<li>标志寄存器：PSW</li>
</ul>
</li>
<li>8086CPU所有的寄存器都是<strong>16位的</strong>，可以存放两个字节。</li>
</ul>
<p><strong>“字”在寄存器中的存储</strong></p>
<p>8086 CPU是16位微处理器，数据总线为16位，地址总线为20位。表明<strong>8086的字长为16bit</strong>。</p>
<p>一个字(word)可以存在一个16位寄存器中，这个字的高位字节存在这个寄存器的高8位寄存器，这个字的低位字节存在这个寄存器的低8位寄存器。</p>
<h4 id="2-2-mov和add指令"><a href="#2-2-mov和add指令" class="headerlink" title="2.2 mov和add指令"></a>2.2 mov和add指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>对应操作</th>
<th>人为描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov ax, 18</td>
<td>将18送入AX</td>
<td>AX = 18</td>
</tr>
<tr>
<td>mov ah, 78</td>
<td>将78送入AH</td>
<td>AH = 78</td>
</tr>
<tr>
<td>add ax, 8</td>
<td>将寄存器AX中的数值加上8</td>
<td>AX = AX + 8</td>
</tr>
<tr>
<td>mov ax, bx</td>
<td>将寄存器BX中的数据送入寄存器AX</td>
<td>AX = BX</td>
</tr>
<tr>
<td>add ax, bx</td>
<td>将AX,BX中的内容相加，结果存在AX中</td>
<td>AX = AX + BX</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-3-确定物理地址的方法"><a href="#2-3-确定物理地址的方法" class="headerlink" title="2.3 确定物理地址的方法"></a>2.3 确定物理地址的方法</h4><p>CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。每一个内存单元在这入空间中都有唯一的地址，这个唯一的地址称为物理地址</p>
<p>8086有20位地址总线，可传送20位地址，寻址能力为<strong><font = color="green">1M</font></strong>。但是，8086是16位结构的CPU，运算器一次最多可以处理16位的数据，寄存器的最大宽度为16位。在8086内部处理的、传输、暂存的地址也是16位，寻址能力也只有<strong>64KB</strong>。</p>
<p>问题：8086如何处理在寻址空间上的这个矛盾？<br>解决：用两个16位地址(段地址、偏移地址)合成一个20位的物理地址。</p>
<p>地址加法器合成物理地址的方法：</p>
<script type="math/tex; mode=display">
物理地址=段地址 × 16+偏移地址</script><p>段地址乘以16就相当于向右移动4位，空出的位置补0。</p>
<h4 id="2-4-内存的分段表示法"><a href="#2-4-内存的分段表示法" class="headerlink" title="2.4 内存的分段表示法"></a>2.4 内存的分段表示法</h4><p>用<strong>分段</strong>的方式管理内存，8086CPU用“(段地址x16)+偏移地址=物理地址”的方式给出内存单元的物理地址。<br>内存并没有分段，段的划分来自于CPU！！！。</p>
<ul>
<li>段地址 ×16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数。</li>
<li>偏移地址为16位，16位地址的寻址能力为64K，所以一个段的长度最大为64K。</li>
<li>同一物理地址，可以由不同的段地址和偏移地址组成。</li>
</ul>
<p>在8086PC机中存储单元地址的表示方法：例：数据在21F60H内存单元中，段地址是2000H，说法：</p>
<p>(a) 数据存在内存$\text{ 2000 : 1F60 }$单元中；<br>(b) 数据存在内存的$\text{2000H}$段中的$\text{1F60H}$单元中；</p>
<p><strong>段地址很重要 —— 用专门的寄存器存放段地址</strong>：4个段寄存器<br>CS：代码段寄存器；SS：栈段寄存器；DS：数据段寄存器；ES：附加段寄存器。</p>
<p>偏移地址可以用多种方法提供——8086丰富的取址方式。</p>
<h4 id="2-5-CS、IP与代码段"><a href="#2-5-CS、IP与代码段" class="headerlink" title="2.5 CS、IP与代码段"></a>2.5 CS、IP与代码段</h4><p>CS：代码段寄存器，IP：指令指针寄存器，<code>CS:IP</code>：CPU将内存中<code>CS:IP</code>指向的内容当作指令执行（也即CS相当于段地址，IP相当于偏移地址）。</p>
<p>执行何处的指令，取决于<code>CS:IP</code>，可以通过改变CS、IP中的内容，来控制CPU要执行的目标指令，那么如何改变CS、IP的值呢？由于<strong>8086CPU不提供对CS和IP修改的指令</strong>，因此需要使用<code>jmp</code>指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>转移指令jmp</th>
</tr>
</thead>
<tbody>
<tr>
<td>jmp 段地址:偏移地址 —— 这是同时修改CS和IP的内容</td>
</tr>
<tr>
<td>jmp 某一寄存器 —— 仅仅改变偏移地址IP中的内容</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-6-内存中字的存储"><a href="#2-6-内存中字的存储" class="headerlink" title="2.6 内存中字的存储"></a>2.6 内存中字的存储</h4><p>事实：对8086CPU而言，16位作为一个字。<br>问题：16位的字存储在一个16位的寄存器中，如何存储？<br>回答：高8位放高字节，低8位放低字节。<br>问题：16位的字在内存中需要2个连续字节存储，怎么存放？<br>回答：低位字节存在低地址单元，高位字节存在高地址单元，例：20000D(4E20H)存放在0、1两个单元，18D(0012H)存放在2、3两个单元，这两个单元怎么存储可分为：<strong>大端存储</strong> VS <strong>小端存储</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/67106c78d29ded1a8cbdf3d4.png"></p>
<ul>
<li><strong>字单元</strong></li>
</ul>
<p>由两个地址连续的内存单元组成，存放一个字型数据(16位)</p>
<ul>
<li>用DS和[address]实现字的传送</li>
</ul>
<p>要解决的问题：CPU从内存单元中要读取数据<br>要求：CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址<br>原理：在8086PC中，内存地址曲段地址和偏移地址组成(段地址:偏移地址)<br>解决方案：DS和[address]配合 —— 用DS寄存器存放要访问的数据的段地址，偏移地址用[…]形式直接给出。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>汇编程序示例</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov bx, 1000H<br>mov ds, bx<br>mov al, [0]</td>
<td>将10000H(1000:0)中的数据读到al寄存器中</td>
</tr>
</tbody>
</table>
</div>
<p>8086CPU不支持将数据直接送入段寄存器（这是硬件设计的问题）。<br>套路：数据→ 通用寄存器 → 段寄存器</p>
<h4 id="2-7-DS与数据段"><a href="#2-7-DS与数据段" class="headerlink" title="2.7 DS与数据段"></a>2.7 DS与数据段</h4><p>用DS存放数据段的段地址用相关指令访问数据段中的具体单元，单元地址由[address]指出。</p>
<h4 id="2-8-栈及栈操作的实现"><a href="#2-8-栈及栈操作的实现" class="headerlink" title="2.8 栈及栈操作的实现"></a>2.8 栈及栈操作的实现</h4><p>栈是一种只能在一端进行插入或删除操作的数据结构。</p>
<p>栈有两个基本的操作：① 入栈 ② 出栈。</p>
<p>入栈：将一个新的元素放到栈顶；出栈：从栈顶取出一个元素。</p>
<p>栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。</p>
<p>栈的操作规则：<strong>LIFO(LastIn First out，后进先出)</strong>。</p>
<p>CPU提供的栈机制：现今的CPU中都有栈的设计，8086CPU提供相关的指令，支持用栈的方式访问内存空间。基于8086CPU的编程，可以将一段内存当作栈来使用。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>push ax</td>
<td>将ax中的数据送入栈中【以字(16位=2字节)为单位对栈进行操作】</td>
</tr>
<tr>
<td>pop ax</td>
<td>从栈顶取出数据送入ax【以字(16位=2字节)为单位对栈进行操作】</td>
</tr>
</tbody>
</table>
</div>
<p>问题<br>1、CPU如何知道一段内存空间被当作栈使用?<br>2、执行push和pop的时候，如何知道哪个单元是栈顶单元 ?</p>
<p>回答：<br>8086CPU中，有两个与栈相关的寄存器 —— 栈段寄存器SS存放栈顶的段地址，栈顶指针寄存器SP存放栈顶的偏移地址。</p>
<p>在汇编语言中使用栈要特别注意<strong>溢出</strong>问题：</p>
<p>8086CPU不保证对栈的操作不会超界。<br>8086CPU 只知道栈顶在何处(由SS:SP指示)，不知道程序安排的栈空间有多大。<br>程序员在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界；防止出栈时栈空了仍然继续出栈而导致的超界。</p>
<h4 id="2-9-“段”的小结"><a href="#2-9-“段”的小结" class="headerlink" title="2.9 “段”的小结"></a>2.9 “段”的小结</h4><ul>
<li><p>三种段</p>
<ul>
<li><p>数据段<br>将段地址放在DS中<br>用mov、add、sub等访问内存单元的指令时，CPU将我们定义的数据段中的内容当作数据段来访问；</p>
</li>
<li><p>代码段</p>
<p>将段地址放在CS中，将段中第一条指令的偏移地址放在IP中<br>CPU将执行我们定义的代码段中的指令;</p>
</li>
<li><p>栈段</p>
<p>将段地址放在SS中，将栈顶单元的偏移地置放在SP中<br>CPU在需要进行栈操作(push、pop)时，就将我们定义的栈段当作栈空间来用。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>CS 是代码段寄存器，DS 是数据段寄存器，ES 是附加段(Extra Segment)寄存器。附加段的意思是，它是额外赠送的礼物，当需要在程序中同时使用两个数据段时，DS 指向一个，ES 指向另一个。可以在指令中指定使用 DS 和 ES 中的哪-个，如果没有指定，则默认是使用 DS。</p>
<p>SS 是栈段寄存器。IP 是指令指针(Instruction Pointer)寄存器，它只和 CS 一起使用，而且只有处理器才能直接改变它的内容。当一段代码开始执行时，CS 指向代码段的起始地址，IP则指向段内偏移。这样，由 CS 和 IP 共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令。然后处理器会自动根据当前指令的长度来改变 IP 的值，使它指向下一条指令。</p>
</blockquote>
<h3 id="3-汇编语言程序"><a href="#3-汇编语言程序" class="headerlink" title="3 汇编语言程序"></a>3 汇编语言程序</h3><h4 id="3-1-汇编程序概况"><a href="#3-1-汇编程序概况" class="headerlink" title="3.1 汇编程序概况"></a>3.1 汇编程序概况</h4><p>汇编程序：包含汇编指冷和伪指令的文本。</p>
<p><img src="https://pic.imgdb.cn/item/67107aebd29ded1a8ccc8935.png" alt="汇编程序的组成"></p>
<p><img src="https://pic.imgdb.cn/item/67107b69d29ded1a8ccce7e1.png" alt="汇编程序中包含的三种伪指令"></p>
<p><img src="https://pic.imgdb.cn/item/67107ee8d29ded1a8ccfe440.png"></p>
<h4 id="3-2-Loop指令"><a href="#3-2-Loop指令" class="headerlink" title="3.2 Loop指令"></a>3.2 Loop指令</h4><p>功能：实现循环(计数型循环)</p>
<p>指令的格式：loop 标号</p>
<p>CPU执行loop指令时要进行的操作：① (cx)=(cx)-1； ② 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;loop指令示例程序</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,2</span><br><span class="line">	mov cx,11	; 存放循环次数</span><br><span class="line">s:	add ax ax	; s为标号，循环跳转到此处</span><br><span class="line">	1oop s</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="3-3-段前缀的使用"><a href="#3-3-段前缀的使用" class="headerlink" title="3.3 段前缀的使用"></a>3.3 段前缀的使用</h4><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov ax, 2000<br>mov ds, ax<br>mov bx, 0<br>mov al, ds:[bx]</td>
<td>这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址<br>的“ds:” “cs:” “ss:” 或 “es:”，在汇编语言中称为段前缀</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-4-在代码段中使用数据"><a href="#3-4-在代码段中使用数据" class="headerlink" title="3.4 在代码段中使用数据"></a>3.4 在代码段中使用数据</h4><p>数据不能随意地在内存中存放，这是很危险的，容易导致重要内存存放的内容被修改。</p>
<p>应用案例：编程计算以下8个数据的和，结果存在ax存器中<br>0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H<br>只要求数据本身，并未指定在哪些内存单元中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0fedH, 0cbaH, 0987H	</span><br><span class="line">		; 在代码段中定义数据</span><br><span class="line">		; dw: define word, 表示定义字型数据</span><br><span class="line">		; dw 定义一个字</span><br><span class="line">		; db 定义一个字节</span><br><span class="line">		; dd 定义一个双字</span><br><span class="line">; 前面是人为定义在代码段中的数据，因此前面这部分肯定是不能被翻译为指令，而IP默认是为0的，怎么办呢？</span><br><span class="line">; 解决方法：定义一个标号start,指示代码开始的位置。</span><br><span class="line">start:	mov bx, 0</span><br><span class="line">	mov ax, 0</span><br><span class="line">	mov cx, 8</span><br><span class="line">s: 	add ax,cs:[bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start	; end的作用:除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。</span><br></pre></td></tr></table></figure>
<h4 id="3-5-在代码段中使用栈"><a href="#3-5-在代码段中使用栈" class="headerlink" title="3.5 在代码段中使用栈"></a>3.5 在代码段中使用栈</h4><p>问题：利用栈，将程序中定义的数据逆序存放。</p>
<p>程序的思路大致如下：<br>程序运行时，定义的数据存放在cs:0-cs:8单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆序存放。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0.0,0,0,0</span><br><span class="line">	</span><br><span class="line">start:	</span><br><span class="line">	; 设置栈地址和指针 </span><br><span class="line">	mov ax,cs</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,30h</span><br><span class="line">	;入栈</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,8</span><br><span class="line">s0:	push cs:[bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s0</span><br><span class="line">	;出栈</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,8</span><br><span class="line">s1: pop cs:[bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s1</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h4 id="3-6-将数据、代码、栈放入不同段"><a href="#3-6-将数据、代码、栈放入不同段" class="headerlink" title="3.6 将数据、代码、栈放入不同段"></a>3.6 将数据、代码、栈放入不同段</h4><ul>
<li><p>上面这个将数据逆序存放的程序有如下特点和缺陷：</p>
<ul>
<li><p>特点：数据、栈和代码都在一个段。</p>
</li>
<li><p>问题：程序显得混乱，编程和阅读时都要注意何处是数据，何处是栈，何处是代码。</p>
<p>只适合应用于要处理的数据很少，用到的栈空间也小，加上没有多长的代码。</p>
</li>
</ul>
</li>
</ul>
<p>处理方法：数据段、代码段、栈端分开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line">; 数据段</span><br><span class="line">data segment</span><br><span class="line">	dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">data ends</span><br><span class="line">; 栈段</span><br><span class="line">stack segment</span><br><span class="line">	dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">stack ends</span><br><span class="line">; 代码段</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	; 初始化各段寄存器</span><br><span class="line">	; 注意：cs代码段不用手动初始化，编译器自动完成代码段的初始化</span><br><span class="line">	mov ax, stack</span><br><span class="line">	mov ss, ax</span><br><span class="line">	mov sp, 20h</span><br><span class="line">	mov ax, data</span><br><span class="line">	mov ds, ax</span><br><span class="line">	;入栈</span><br><span class="line">	mov bx, 0</span><br><span class="line">	mov cx, 8</span><br><span class="line">s0:	push cs:[bx]</span><br><span class="line">	add bx, 2</span><br><span class="line">	loop s0</span><br><span class="line">	;出栈</span><br><span class="line">	mov bx, 0</span><br><span class="line">	mov cx, 8</span><br><span class="line">s1: pop cs:[bx]</span><br><span class="line">	add bx, 2</span><br><span class="line">	loop s1</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>程序段前缀PSP</strong></li>
</ul>
<p>程序段前缀PSP(Pogram segment Prefix)是DOS 加载一个外部命令或应用程序(EXE、COM类型)时，在该程序段之前自动设置的一个具有256(100H)个字节的信息区域。</p>
<p><strong>当 DOS 把控制权转交给外部命令或应用程序时，数据段寄存器DS和附加段寄存器ES首先被设置为指向程序段前缀，即与PSP含有相同的段值，而不是一开始就指向程序的数据段和附加段。堆栈段寄存器SS和代码段寄存器CS的段地址要比 DS 和 ES 高/大0100H。</strong></p>
<p>PSP 含有许多的可用信息，其中偏移地址000H~007FH 范围为格式化区域，即加载程序时自动设置的各种信息区域；0080H~00FFH 区域为PSP的非格式化区域，即用来存储被加载程序的输入参数(DOS 加载一个外部命令或应用程序时，允许在被加载的程序名之后输入包括回车符在内的最多127个字符参数)。其中偏移地址0000H~0001H 内容为程序终止退出命令INT20H，0080H单元存储命令行参数的长度(字节数)，由0081H地址开始存储命令行参数，如无命令行参数则为0。</p>
<blockquote>
<p>当一个<code>.EXE</code>可执行文件加载到内存时，内存会被划分为几个区域：程序段前缀（PSP）、用户数据区、用户堆栈区以及用户代码段。PSP区域包含了关于可执行文件的控制信息，其开头的<code>INT 20H</code>指令用于结束程序。程序的执行通常始于将<code>DS</code>和<code>ES</code>段寄存器设置为PSP的地址，并在程序结束时使用<code>RET</code>指令将控制权转回DOS。   <a href="https://download.csdn.net/download/qq_37174420/29651038?utm_medium=distribute.pc_relevant_download.none-task-download-2~default~OPENSEARCH~Rate-8-29651038-download-4203060.257%5Ev16%5Epc_dl_relevant_base1_b&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-download-2~default~OPENSEARCH~Rate-8-29651038-download-4203060.257%5Ev16%5Epc_dl_relevant_base1_b&amp;spm=1003.2020.3001.6616.10">链接</a></p>
</blockquote>
<h3 id="4-内存寻址方式"><a href="#4-内存寻址方式" class="headerlink" title="4. 内存寻址方式"></a>4. 内存寻址方式</h3><h4 id="4-1-处理字符问题"><a href="#4-1-处理字符问题" class="headerlink" title="4.1 处理字符问题"></a>4.1 处理字符问题</h4><p>汇编程序中，用<code>&#39;...&#39;</code>的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的ASCII码.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line">; 数据段</span><br><span class="line">data segment</span><br><span class="line">	db &#x27;unIx&#x27;</span><br><span class="line">	db &#x27;foRk&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov al, &#x27;a&#x27;</span><br><span class="line">	mov bl, &#x27;b&#x27;</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h4 id="4-2-bx-idata-方式寻址"><a href="#4-2-bx-idata-方式寻址" class="headerlink" title="4.2 [bx+idata]方式寻址"></a>4.2 [bx+idata]方式寻址</h4><p><code>[bx+idata]</code>表示一个内存单元，它的偏移地址为<code>(bx)+idata</code>（即bx中的数值加上idata）。</p>
<p>mov ax, [bx+200] / mov ax, [200+bx]的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，内存单元的段地址在ds中，偏移地址为200加上bx中的数值。</p>
<h4 id="4-3-SI和DI寄存器"><a href="#4-3-SI和DI寄存器" class="headerlink" title="4.3 SI和DI寄存器"></a>4.3 SI和DI寄存器</h4><p>首先，简单回顾一下CPU内部的寄存器</p>
<ul>
<li>8086CPU有14个寄存器<ul>
<li>通用寄存器：AX、BX、CX、DX</li>
<li>变址寄存器：SI、DI</li>
<li>指针寄存器：SP、BP</li>
<li>指令指针寄存器：IP</li>
<li>段寄存器：CS、SS、DS、ES</li>
<li>标志寄存器：PSW</li>
</ul>
</li>
</ul>
<p><strong>Sl和DI常执行与地址有关的操作</strong>：SI和DI是8086CPU中和Bx功能相近的寄存器；区别在于SI和DI不能够分成两个8位寄存器来使用。</p>
<blockquote>
<p>BX：通用寄存器，在计算存储器地址时，常作为基址寄存器用。<br>Sl(source index)：源变址寄存器。<br>Dl(destination index)：目标变址寄存器。</p>
</blockquote>
<p>下面的三组指令实现了相同的功能</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令1</th>
<th>指令2</th>
<th>指令3</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov bx, 0<br>mov ax, [bx]</td>
<td>mov si, 0<br>mov ax, [si]</td>
<td>mov di, 0<br>mov ax, [di]</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>[bx+si]和[bx+di]方式寻址</strong></li>
</ul>
<p>指令<code>mov [bx+si]</code>的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中。</p>
<ul>
<li><strong>[bx+si+idata]和[bx+di+idata]方式寻址</strong></li>
</ul>
<p>指令<code>mov [bx+si+idata]</code>的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中。</p>
<p><img src="https://pic.imgdb.cn/item/6711ce83d29ded1a8c18899f.png" alt="对内存的寻址方式小结"></p>
<h4 id="4-4-用于内存寻址的寄存器"><a href="#4-4-用于内存寻址的寄存器" class="headerlink" title="4.4 用于内存寻址的寄存器"></a>4.4 用于内存寻址的寄存器</h4><p>只有bx、bp、si、di可以用在[…]对内存单元寻址，通用寄存器除了bx，其他(ax、cx、dx)都不可用于寻址。</p>
<p><strong>bx、bp区别：</strong>bx默认指ds段，bp默认指ss段。</p>
<h4 id="4-5-汇编语言中数据位置的表达"><a href="#4-5-汇编语言中数据位置的表达" class="headerlink" title="4.5 汇编语言中数据位置的表达"></a>4.5 汇编语言中数据位置的表达</h4><p><img src="https://pic.imgdb.cn/item/6711f7aed29ded1a8c53fc0f.png" alt="汇编语言中数据位置的表达"></p>
<p><img src="https://pic.imgdb.cn/item/6711f874d29ded1a8c54a5ab.png" alt="指令要处理的数据有多长"></p>
<h4 id="4-6-用div指令实现除法"><a href="#4-6-用div指令实现除法" class="headerlink" title="4.6 用div指令实现除法"></a>4.6 用div指令实现除法</h4><ul>
<li><code>div</code>是除法指令，使用div作除法的时候<ul>
<li>被除数：默认放在AX 或 DX和AX中</li>
<li>除数：8位或16位，在寄存器或内存单元中</li>
<li>结果：……</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>被除数</th>
<th>除数</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody>
<tr>
<td>AX</td>
<td>8位内存或寄存器</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr>
<td>AX和DX</td>
<td>16位内存或寄存器</td>
<td>AX</td>
<td>DX</td>
</tr>
</tbody>
</table>
</div>
<p>切记提前在默认的寄存器中设置好被除数，且默认寄存器不作别的用处。</p>
<h4 id="4-7-用dup设置内存空间"><a href="#4-7-用dup设置内存空间" class="headerlink" title="4.7 用dup设置内存空间"></a>4.7 用dup设置内存空间</h4><p>功能：dup和db、dw、dd 等数据定义伪指令配合使用，用来进行数据的重复。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
<th>相当于</th>
</tr>
</thead>
<tbody>
<tr>
<td>db 3 dup (0)</td>
<td>定义了3个字节，它们的值都是0</td>
<td>db 0,0,0</td>
</tr>
<tr>
<td>db 3 dup (0,1,2)</td>
<td>定义了9个字节，由0、1、2重复3次构成</td>
<td>db 0,1,2,0,1,2,0,1,2</td>
</tr>
<tr>
<td>db 3 dup (‘abc’,ABC’)</td>
<td>定义了18个字节，构成’abcABCabcABCabcABC</td>
<td>db ‘abcABCabcABCabcABC’</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-流程转移与子程序"><a href="#5-流程转移与子程序" class="headerlink" title="5. 流程转移与子程序"></a>5. 流程转移与子程序</h3><h4 id="5-1-转移综述"><a href="#5-1-转移综述" class="headerlink" title="5.1 转移综述"></a>5.1 转移综述</h4><ul>
<li>背景：一般情况下指令是顺序地逐条执行的，而在实际中，常需要改变程序的执行流程</li>
<li>转移指令<ul>
<li>可以控制CPU执行内存中某处代码的指令</li>
<li>可以修改IP，或同时修改CS和IP的指令</li>
</ul>
</li>
</ul>
<p><strong>转移指令的分类</strong></p>
<p><img src="https://pic.imgdb.cn/item/671203ded29ded1a8c65f09c.png" alt="转移指令的分类"></p>
<h4 id="5-2-操作符offset"><a href="#5-2-操作符offset" class="headerlink" title="5.2 操作符offset"></a>5.2 操作符offset</h4><p>用操作符offset取得标号的<strong>偏移地址</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; offset的使用：offset 标号</span><br><span class="line">assume cs:codeseg</span><br><span class="line"></span><br><span class="line">codeseg segment</span><br><span class="line">start:	mov ax,offset start	; 相当于mov ax,0</span><br><span class="line">    s:	mov ax,offset s	; 相当于mov ax,3</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h4 id="5-3-jmp指令——无条件转移"><a href="#5-3-jmp指令——无条件转移" class="headerlink" title="5.3 jmp指令——无条件转移"></a>5.3 jmp指令——无条件转移</h4><p>jmp指令的功能：无条件转移，可以只修改IP，也可以同时修改CS和IP。</p>
<ul>
<li>jmp指令要给出两种信息<ul>
<li>① 转移的目的地址；</li>
<li>② 转移的距离<ul>
<li>段间转移(远转移)：<code>jmp 2000:1000</code></li>
<li>段内短转移：<code>jmp short 标号</code>，IP的修改范围为 -128到127，8位的位移</li>
<li>段内近转移：<code>jmp near ptr 标号</code>，IP的修改范围为-32768到32767，16位的位移</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/67120bd4d29ded1a8c73d25d.png" alt="image.png"></p>
<ul>
<li><p><strong>转移地址在寄存器中的jmp指令</strong></p>
<ul>
<li>指令格式：jmp 16位寄存器</li>
<li>功能：IP=(16位寄存器)</li>
<li>举例：jmp ax；jmp bx</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/67121ce2d29ded1a8c8eb5ab.png"></p>
<h4 id="5-4-其他转移指令"><a href="#5-4-其他转移指令" class="headerlink" title="5.4 其他转移指令"></a>5.4 其他转移指令</h4><h5 id="5-4-1-jcxz指令"><a href="#5-4-1-jcxz指令" class="headerlink" title="5.4.1 jcxz指令"></a>5.4.1 jcxz指令</h5><p>指令格式：<code>jcxz 标号</code><br>功能：如果(cx)=0，则转移到标号处执行；若(cx)≠0，什么也不做(程序向下执行 )</p>
<p>jcxz是有<strong>条件转移指令</strong>，所有的有条件转移指令都是短转移，即对IP的修改范围都为-128~127。在对应的机器码中包含转移的位移，而不是目的地址。</p>
<h5 id="5-4-2-loop指令"><a href="#5-4-2-loop指令" class="headerlink" title="5.4.2 loop指令"></a>5.4.2 loop指令</h5><p>指令格式：<code>loop 标号</code><br>功能：循环，如果(cx)=0，跳出循环，；若(cx)≠0，则cx = cx-1，则转移到标号处执行。</p>
<h4 id="5-5-call指令和ret指令"><a href="#5-5-call指令和ret指令" class="headerlink" title="5.5 call指令和ret指令"></a>5.5 call指令和ret指令</h4><p>调用子程序：cal指令<br>返回：ret指令<br>实质：流程转移指令，它们都修改P，或同时修改CS和IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 0</span><br><span class="line">call s</span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">s:	add ax, 0</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p><strong>（一）call指令介绍</strong></p>
<ul>
<li>CPU执行cal指令，进行两步操作<ul>
<li>(1) 将当前的IP或 CS和IP 压入栈中；</li>
<li>(2) 转移到标号处执行指令。</li>
</ul>
</li>
<li><code>call 标号</code><ul>
<li>16位位移 = “标号”处的地址-cal指令后的第一个字节的地址</li>
<li>16位位移的范围为-32768~32767，用补码表示</li>
<li>16位位移由编译程序在编译时算出。</li>
</ul>
</li>
<li>指令<code>call far ptr 标号</code>实现的是<strong>段间转移</strong><ul>
<li>(CS)=标号所在的段地址</li>
<li>(IP)=标号所在的偏移地址</li>
<li>该条指令相当于<ul>
<li>push CS → push lP → jmp far ptr 标号</li>
</ul>
</li>
</ul>
</li>
<li>转移地址在<strong>寄存器</strong>中的call指令<ul>
<li>显指令格式：<code>call 16位寄存器</code></li>
</ul>
</li>
<li>转移地址在<strong>内存</strong>中的call指令<ul>
<li><code>call word ptr 内存单元地址</code><ul>
<li>相当于：push IP → jmp word ptr 内存单元地址</li>
</ul>
</li>
<li><code>call dword ptr 内存单元地址</code><ul>
<li>相当于：push CS → push lP → jmp dword ptr 内存单元地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>（二）ret指令介绍</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>ret指令</th>
<th>retf指令</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>功能</strong></td>
<td>用栈中的数据修改IP的内容，从而实现近转移</td>
<td>用栈中的数据，修改CS和IP的内容，从而实现远转移</td>
</tr>
<tr>
<td><strong>相当于</strong></td>
<td>pop IP</td>
<td>pop IP; pop CS</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://pic.imgdb.cn/item/67131884d29ded1a8ce11dc3.png" style="zoom:60%"></p>
<p>此外，<code>ret</code>指令后面还可以<strong>直接跟数字</strong>，其作用相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ret n ⇿ pop IP</span><br><span class="line">		add sp, n</span><br></pre></td></tr></table></figure>
<h4 id="5-6-mul乘法指令"><a href="#5-6-mul乘法指令" class="headerlink" title="5.6 mul乘法指令"></a>5.6 mul乘法指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>8位乘法</strong></th>
<th><strong>16位乘法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>被乘数(默认)</strong></td>
<td>AL</td>
<td>AX</td>
</tr>
<tr>
<td><strong>乘数</strong></td>
<td>8位寄存器或内存字节单元</td>
<td>16位寄存器或内存字单元</td>
</tr>
<tr>
<td><strong>结果</strong></td>
<td>AX</td>
<td>DX(高位)和AX(低位)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="5-7-标志寄存器PSW-FLAGS"><a href="#5-7-标志寄存器PSW-FLAGS" class="headerlink" title="5.7 标志寄存器PSW/FLAGS"></a>5.7 标志寄存器PSW/FLAGS</h4><h5 id="5-7-1-认识标志寄存器的特殊之处"><a href="#5-7-1-认识标志寄存器的特殊之处" class="headerlink" title="5.7.1 认识标志寄存器的特殊之处"></a>5.7.1 认识标志寄存器的特殊之处</h5><p>标志寄存器flag的结构：</p>
<p>flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p>
<p>8086CPU中标志寄存器flag是16位的，其中没有使用flag的1、3、5、12、13、14、15位，这些位不具有任何含义。</p>
<p><img src="https://pic.imgdb.cn/item/67134d48d29ded1a8c2cbdcc.png" style="zoom:50%"></p>
<h5 id="5-7-2-直接访问标志寄存器的方法"><a href="#5-7-2-直接访问标志寄存器的方法" class="headerlink" title="5.7.2 直接访问标志寄存器的方法"></a>5.7.2 直接访问标志寄存器的方法</h5><p><code>pushf</code>：将标志寄存器的值压栈；</p>
<p><code>popf</code>：从栈中弹出数据，送入标志寄存器中。</p>
<h5 id="5-7-3-ZF-零标志-Zero-Flag"><a href="#5-7-3-ZF-零标志-Zero-Flag" class="headerlink" title="5.7.3 ZF-零标志(Zero Flag)"></a>5.7.3 ZF-零标志(Zero Flag)</h5><ul>
<li>ZF标记相关指令的计算结果是否为0<ul>
<li>ZF=1，表示“结果是0”，1表示“逻辑真”</li>
<li>ZF=0，表示“结果不是0”，0表示“逻辑假“</li>
</ul>
</li>
</ul>
<p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：add、sub、mul、div、inc、or、and等，它们大都是运算指令，进行逻辑或算术运算；</p>
<p>有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，它们大都是传送指令。</p>
<p>使用一条指令的时候，要注意这条指令的全部功能其中包括执行结果对标记寄存器的哪些标志位造成影响。</p>
<h5 id="5-7-4-PF-奇偶标志-Parity-Flag"><a href="#5-7-4-PF-奇偶标志-Parity-Flag" class="headerlink" title="5.7.4 PF-奇偶标志(Parity Flag)"></a>5.7.4 PF-奇偶标志(Parity Flag)</h5><ul>
<li>PF记录指令执行后，结果的所有二进制位中1的个数：<ul>
<li>1的个数为偶数，PF=1</li>
<li>1的个数为奇数，PF=0。</li>
</ul>
</li>
</ul>
<h5 id="5-7-5-SF-符号标志-Sign-Flag"><a href="#5-7-5-SF-符号标志-Sign-Flag" class="headerlink" title="5.7.5 SF-符号标志(Sign Flag)"></a>5.7.5 SF-符号标志(Sign Flag)</h5><ul>
<li>SF记录指令执行后，将结果视为有符号数<ul>
<li>结果为负，SF=1</li>
<li>结果为非负，SF=0</li>
</ul>
</li>
</ul>
<h5 id="5-7-6-CF-进位标志-Carry-Flag"><a href="#5-7-6-CF-进位标志-Carry-Flag" class="headerlink" title="5.7.6 CF-进位标志(Carry Flag)"></a>5.7.6 CF-进位标志(Carry Flag)</h5><p>在进行<strong>无符号数运算</strong>的时候，CF记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p>
<ul>
<li>CF记录指令执行后<ul>
<li>有进位或借位，CF = 1</li>
<li>无进位或借位，CF = 0</li>
</ul>
</li>
</ul>
<h5 id="5-7-7-OF-溢出标志-Overflow-Flag"><a href="#5-7-7-OF-溢出标志-Overflow-Flag" class="headerlink" title="5.7.7 OF-溢出标志(Overflow Flag)"></a>5.7.7 OF-溢出标志(Overflow Flag)</h5><p>在进行<strong>有符号数运算</strong>的时候，如结果超过了机器所能表示的范围称为溢出</p>
<ul>
<li>OF记录有符号数操作指令执行后<ul>
<li>有溢出，OF=1</li>
<li>无溢出，OF=0</li>
</ul>
</li>
</ul>
<h4 id="5-8-带进-借-位的加减法"><a href="#5-8-带进-借-位的加减法" class="headerlink" title="5.8 带进(借)位的加减法"></a>5.8 带进(借)位的加减法</h4><h5 id="5-8-1-adc带进位加法指令"><a href="#5-8-1-adc带进位加法指令" class="headerlink" title="5.8.1 adc带进位加法指令"></a>5.8.1 adc带进位加法指令</h5><ul>
<li>adc是带进位加法指令，它利用了CF位上记录的进位值。<ul>
<li>格式：adc 操作对象1, 操作对象2</li>
<li>功能：操作对象1= 操作对象1+操作对象2+CF</li>
</ul>
</li>
</ul>
<h5 id="5-8-2-sbb带借位减法指令"><a href="#5-8-2-sbb带借位减法指令" class="headerlink" title="5.8.2 sbb带借位减法指令"></a>5.8.2 sbb带借位减法指令</h5><ul>
<li>格式：sbb 操作对象1, 操作对象2<ul>
<li>功能：操作对象1=操作对象1-操作对象2-CF</li>
<li>与sub区别：利用CF位上记录的借位值 </li>
</ul>
</li>
</ul>
<h4 id="5-9-cmp与条件转移指令"><a href="#5-9-cmp与条件转移指令" class="headerlink" title="5.9 cmp与条件转移指令"></a>5.9 cmp与条件转移指令</h4><h5 id="5-9-1-cmp指令"><a href="#5-9-1-cmp指令" class="headerlink" title="5.9.1 cmp指令"></a>5.9.1 cmp指令</h5><ul>
<li>cmp是比较指令，功能相当于减法指令，但不保存结果。cmp指令执行后，将<strong>对标志寄存器产生影响</strong>。<ul>
<li>格式：cmp 操作对象1,操作对象2</li>
<li>功能：计算 操作对象1-操作对象2</li>
</ul>
</li>
</ul>
<h5 id="5-9-2-条件转移指令jxxx"><a href="#5-9-2-条件转移指令jxxx" class="headerlink" title="5.9.2 条件转移指令jxxx"></a>5.9.2 条件转移指令jxxx</h5><p>格式：<code>jxxx 标号</code></p>
<p><img src="https://pic.imgdb.cn/item/67135b0dd29ded1a8c3f3a55.png" alt="根据单个标志位转移的指令" style="zoom:60%"></p>
<p><img src="https://pic.imgdb.cn/item/67135bd5d29ded1a8c411805.png" alt="根据无符号数比较结果进行转移的指令" style="zoom:60%"></p>
<p><img src="https://pic.imgdb.cn/item/67135c3fd29ded1a8c420f98.png" alt="根据有符号数比较结果进行转移的指令" style="zoom:60%"></p>
<p><strong>条件转移指令通常都和cmp相配合使用，cmp指令改变标志位，jxxx根据相应的标志寄存器判断是否跳转。</strong></p>
<h4 id="5-10-DF标志和串传送指令"><a href="#5-10-DF标志和串传送指令" class="headerlink" title="5.10 DF标志和串传送指令"></a>5.10 DF标志和串传送指令</h4><h5 id="5-10-1-DF-方向标志位-Direction-Flag"><a href="#5-10-1-DF-方向标志位-Direction-Flag" class="headerlink" title="5.10.1 DF-方向标志位(Direction Flag)"></a>5.10.1 DF-方向标志位(Direction Flag)</h5><ul>
<li>功能：在串处理指令中，控制每次操作后si，di的增减。<ul>
<li>DF=0：每次操作后si，di递增；</li>
<li>DF=1：每次操作后si，di递减。</li>
</ul>
</li>
<li>对DF位进行设置的指令<ul>
<li><code>cld指令</code>：将标志寄存器的DF位设为0(clear)</li>
<li><code>std指令</code>：将标志寄存器的DF位设为1(setup)</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/671369dbd29ded1a8c58d454.png" style="zoom:50%"></p>
<h5 id="5-10-2-rep指令"><a href="#5-10-2-rep指令" class="headerlink" title="5.10.2 rep指令"></a>5.10.2 rep指令</h5><ul>
<li>rep指令常和串传送指令搭配使用<ul>
<li>功能：根据cx的值，重复执行后面的指令</li>
<li>例如：<code>rep movsb</code></li>
<li>等价于：<br>wjh：movsb<br>loop wjh </li>
</ul>
</li>
</ul>
<p>补充：<code>movsb</code>字节传送指令</p>
<p>格式：movsb<br>功能：执行movsb指令相当于进行下面几步操作:<br>（1）((es)×16+(di))=((ds)×16+(si))</p>
<p>（2） 如果<code>df=0</code>则：(si)=(si)+1，(di)=(di)+1；如果<code>df=1</code>则：(si)=(si)-1，(di)=(di)-1</p>
<h3 id="6-中断及外部设备操作"><a href="#6-中断及外部设备操作" class="headerlink" title="6. 中断及外部设备操作"></a>6. 中断及外部设备操作</h3><h4 id="6-1-移位指令"><a href="#6-1-移位指令" class="headerlink" title="6.1 移位指令"></a>6.1 移位指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>移位指令</th>
<th>示例代码</th>
<th>释义</th>
<th>是否影响CF位</th>
</tr>
</thead>
<tbody>
<tr>
<td>逻辑左移<br>SHL OPR,CNT</td>
<td>mov al,01001000b<br>shl al,1</td>
<td>二进制数字向左移动一位，<br>末尾补0，移出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>循环左移<br>ROL OPR, CNT</td>
<td>mov al,01001000b<br>rol al,1</td>
<td>二进制数字向左移动一位，<br>然后补到末尾，移出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>逻辑右移<br>SHR OPR,CNT</td>
<td>mov al,01001000b<br>shr al,1</td>
<td>二进制数字向右移动一位，<br>开头补0，移出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>循环右移<br>ROR OPR,CNT</td>
<td>mov al,01001000b<br>ror al,1</td>
<td>二进制数字向右移动一位，<br>然后补到开头，移出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>算术左移<br>SAL OPR,CNT</td>
<td>mov al,01001000b<br>sal al,1</td>
<td>二进制数字向左移动一位，<br>末尾补0，移出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>算术右移<br>SAR OPR,CNT</td>
<td>mov al,01001000b<br>sar al,1</td>
<td>二进制数字向右移动一位，<br>但是开头一位保持不变，移<br>出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>带进位循环左移<br>RCL OPR,CNT</td>
<td>mov al,01001000b<br>rcl al,1</td>
<td>二进制数字向左移动一位，<br>原CF中的数值回到末尾，移<br>出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>带进位循环右移<br>RCR OPR,CNT</td>
<td>mov al,01001000b<br>rcr al,1</td>
<td>二进制数字向右移动一位，<br>原CF中的数值回到开头，移<br>出的一位进到CF中</td>
<td>是</td>
</tr>
</tbody>
</table>
</div>
<p>注意①：当移动的位数大于1时，必须使用cl寄存器中转移动的位数。</p>
<p>注意②：逻辑左移相当于乘以2，逻辑右移相当于除以2。</p>
<h4 id="6-2-操作显存数据"><a href="#6-2-操作显存数据" class="headerlink" title="6.2 操作显存数据"></a>6.2 操作显存数据</h4><p><strong>屏慕上的内容=显存中的数据</strong></p>
<p>根据前面的图可知，8086CPU的显存地址空间位于：A0000到BFFFF区间。其中B8000h~BFFFFh共32K的空间，是8*25 彩色字符模式第0页的显示缓冲区。</p>
<blockquote>
<p>B8000h~BFFFFh共32K的空间的简单解释</p>
<p><code>BFFFFh-B8000h = 7FFFH = 8000H → 2^3*2^12 = 2^3*2^2*2^10 = 32*1Kb</code></p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/6715ae36d29ded1a8c32e3ab.png" alt="显示缓冲区结构"></p>
<blockquote>
<p>‌<strong>在显存中，一个字符确实占两个字节。</strong>‌ 在80*25彩色字符模式下，每个字符由两个字节组成，一个字节存储字符的ASCII码，另一个字节存储字符的属性（如背景色、前景色等）‌。</p>
<p>在显存中，每个字符占用两个字节的原因是因为：</p>
<ul>
<li>‌<strong>字符的ASCII码</strong>‌：一个字节(低位)用于存储字符的ASCII码，表示字符本身。</li>
<li>‌<strong>字符的属性</strong>‌：另一个字节(高位)用于存储字符的属性，如背景色、前景色、闪烁、高亮等。</li>
</ul>
<p>这种设计使得每个字符不仅可以显示出来，还可以通过属性字节来控制其显示效果。</p>
</blockquote>
<p>例：编程序，在屏幕的中间，自底蓝字，显示Welcome to masm!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codeseg, ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;welcome to masm!&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codeseg segment</span><br><span class="line">start:</span><br><span class="line">	; 初始化寄存器</span><br><span class="line">	mov ax, datasg</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov ax, 0B800H</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov si, 0</span><br><span class="line">	mov di, 160*12+80-16</span><br><span class="line">	; 显示字符串</span><br><span class="line">	mov cx,16</span><br><span class="line">w:  mov al, [si]</span><br><span class="line">	mov es:[di], al</span><br><span class="line">	inc di</span><br><span class="line">	mov al, 71H</span><br><span class="line">	mov es:[di], al</span><br><span class="line">	inc si</span><br><span class="line">	inc di</span><br><span class="line">	loop w</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h4 id="6-3-描述内存单元的标号"><a href="#6-3-描述内存单元的标号" class="headerlink" title="6.3 描述内存单元的标号"></a>6.3 描述内存单元的标号</h4><h5 id="6-3-1-关于标号"><a href="#6-3-1-关于标号" class="headerlink" title="6.3.1 关于标号"></a>6.3.1 关于标号</h5><p>代码段中的标号可以用来标记指令、段的起始地址。</p>
<p>代码段中的数据也可以用标号。</p>
<h5 id="6-3-2-数据标号——去了冒号的数据标号"><a href="#6-3-2-数据标号——去了冒号的数据标号" class="headerlink" title="6.3.2 数据标号——去了冒号的数据标号"></a>6.3.2 数据标号——去了冒号的数据标号</h5><p>数据标号标记了存储数据的单元的地址和长度<br>数据标号不同于仅仅表示地址的地址标号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	;数据标号a、b前面不加:，注意这段数据定义在数据段也是可以这样用的</span><br><span class="line">	a db 1 2,3,4 5,6,7,8	</span><br><span class="line">	b dw 0</span><br><span class="line">start : mov si,0</span><br><span class="line">	mov cx,8</span><br><span class="line">s: 	mov al,a[si]	;相当于[si+a]</span><br><span class="line">	mov ah,0</span><br><span class="line">	add b,ax</span><br><span class="line">	inc si</span><br><span class="line">	loop s</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h5 id="6-3-3-扩展用法：二级指针：将标号当作数据来定义"><a href="#6-3-3-扩展用法：二级指针：将标号当作数据来定义" class="headerlink" title="6.3.3 扩展用法：二级指针：将标号当作数据来定义"></a>6.3.3 扩展用法：二级指针：将标号当作数据来定义</h5><p><img src="https://pic.imgdb.cn/item/6715b66dd29ded1a8c43abce.png"></p>
<h4 id="6-4-直接定址表"><a href="#6-4-直接定址表" class="headerlink" title="6.4 直接定址表"></a>6.4 直接定址表</h4><h5 id="6-4-1-数据的直接定址表"><a href="#6-4-1-数据的直接定址表" class="headerlink" title="6.4.1 数据的直接定址表"></a>6.4.1 数据的直接定址表</h5><p>直接定址表：用查表的方法解决问题。</p>
<p>有如下问题：以十六进制的形式在屏幕中间显示给定的byte型数据。</p>
<p>新方按：建立一张表，表中依次存储字符“0” ~ “F”，我们可以通过数值0~15直接查找到对应的字符<br><code>table db &#39;0123456789ABCDEF&#39; ;字符表</code></p>
<h5 id="6-4-2-代码的直接定址表"><a href="#6-4-2-代码的直接定址表" class="headerlink" title="6.4.2 代码的直接定址表"></a>6.4.2 代码的直接定址表</h5><p><strong><font color="red">函数指针数组</font></strong>，示例如下</p>
<p><img src="https://pic.imgdb.cn/item/6715c067d29ded1a8c5b45ec.png"></p>
<h4 id="6-5-中断及其处理"><a href="#6-5-中断及其处理" class="headerlink" title="6.5 中断及其处理"></a>6.5 中断及其处理</h4><h5 id="6-5-1-中断的概念"><a href="#6-5-1-中断的概念" class="headerlink" title="6.5.1 中断的概念"></a>6.5.1 中断的概念</h5><p>中断：CPU不再接着(刚执行完的指令)向下执行，而是转去处理中断信息</p>
<p>内中断：由CPU内部发生的事件而引起的中断</p>
<p>外中断：由外部设备发生的事件引起的中断</p>
<p><img src="https://pic.imgdb.cn/item/6715c75bd29ded1a8c6a63ec.png"></p>
<h5 id="6-5-2-8086的内中断"><a href="#6-5-2-8086的内中断" class="headerlink" title="6.5.2 8086的内中断"></a>6.5.2 8086的内中断</h5><ul>
<li>CPU内部产生的中断信息<ul>
<li>(1) 除法错误，比如:执行div指令产生的除法溢出</li>
<li>(2) 单步执行</li>
<li>(3) 执行<code>into 指令</code></li>
<li>(4) 执行<code>int 指令</code></li>
</ul>
</li>
<li>8086的中断类型码<ul>
<li>(1) 除法错误：0</li>
<li>(2) 单步执行：1</li>
<li>(3) 执行into指令：4</li>
<li>(4) 执行 int n指令，立即数n为中断类型码</li>
</ul>
</li>
<li>中断处理程序<ul>
<li>CPU接到中断信息怎么办?<ul>
<li>执行中断处理程序</li>
</ul>
</li>
<li>中断处理程序在哪里 ?<ul>
<li>中断信息和其处理程序的入口地址之间有某种联系，CPU根据中断信息可以找到要执行的处理程序。</li>
</ul>
</li>
<li>中断向量表<ul>
<li>由中断类型码查表得到中断处理程序的入口地址，从而定位中断处理程序。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6715c9bbd29ded1a8c6fce83.png" style="zoom:50%"></p>
<ul>
<li>中断过程<ul>
<li>中断过程由CPU的硬件自动完成</li>
<li>用中断类型码找到中断向量，并用它设置CS和IP</li>
</ul>
</li>
<li>8086CPU的中断过程<ul>
<li>(1) 从中断信息中取得中断类型码</li>
<li>(2) 标志寄存器的值入栈——中断过程中要改变标志寄存器的值，需要先行保护</li>
<li>(3) 设置标志寄存器的第8位TF和第9位IF的值为0</li>
<li>(4) CS寄存器的内容入栈</li>
<li>(5) IP寄存器的内容入栈</li>
<li>(6) 从中断向量表读取中断处理程序的入口地址，设置IP和CS。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6715f000d29ded1a8cb9b64d.png" style="zoom:60%"></p>
<h4 id="6-6-中断处理程序及其结构"><a href="#6-6-中断处理程序及其结构" class="headerlink" title="6.6 中断处理程序及其结构"></a>6.6 中断处理程序及其结构</h4><p>CPU随时都可能检测到中断信息，所以中断处理程序必须常驻内存(一直存储在内存某段空间之中)。<br>中断处理程序的入口地址，即<strong>中断向量</strong>，必须存储在对应的中断向量表表项中(<code>0000:0000-0000:03FF</code>)。</p>
<h5 id="6-6-1-编制中断处理程序—以除法错误中断为例"><a href="#6-6-1-编制中断处理程序—以除法错误中断为例" class="headerlink" title="6.6.1 编制中断处理程序—以除法错误中断为例"></a>6.6.1 编制中断处理程序—以除法错误中断为例</h5><p>问题：如何编制中断处理程序?<br>方案：通过对 0号中断，即除法错误的中断处理，体会中断处理程序处理的技术问题<br>预期效果：编写一个0号中断处理程序，它的功能是在屏幕中间显示“overflow!”后，然后返回到操作系统。</p>
<ul>
<li><strong>问题1：中断处理子程序应该放在哪里？</strong></li>
</ul>
<p>中断处理子程序应该存放在内存的确定位置，但这里我们是模拟中断处理，要重新找个地方，不破坏系统的中断处理函数。</p>
<p>在操作系统之上使用计算机，所有的硬件资源都在操作系统的管理之下，应该向操作系统申请获得存放中断处理子程序的内存。</p>
<p>使用汇编语言可以<strong>绕过操作系统</strong>，直接在找到一块别的程序不会用到的内存区，将中断处理子程序传送到其中即可。（注意：不是工程化的方法，但也体现实用技巧）</p>
<p>内存<code>0000:0000~0000:03FFF</code>大小为1KB的空间是系统存放中断向量表，DOS系统和其他应用程序都不会随便使用这段空间。8086支持256个中断，但实际上系统中要处理的中断事件远没有达到256个。利用中断向量表中的空闲单元来存放我们的程序。估计出，中断处理子程序的长度不可能超过256个字节，就选用从0000:0200至0000:02FF的256个字节的空间。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000：0000</td>
<td>IP 0200</td>
</tr>
<tr>
<td>0000：0002</td>
<td>CS 0000</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>问题2：怎么写安装程序?</strong></li>
</ul>
<p>(1) 编写可以显示“overflow!”的中断处理程序，命名为：do0<br>(2) 安装程序：将do0送入内存0000:0200处<br>(3) 将do0中断处理程序的入口地址0000:0200存储在中断向量表0号表项中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 程序框架</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	do0安装程序</span><br><span class="line">	设置中断向量表</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">do0: 显示字符串 &quot;overflow !&quot;</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">do0end: nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; do0安装程序</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0	; 设置ds:si指向源地址cs:do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax	</span><br><span class="line">mov di,200h	; 设置es:di指向目的地址0000:0200h</span><br><span class="line">mov cx, offset do0end - offset do0	; 设置cx为传输长度为do0部分代码的长度</span><br><span class="line">cld	; 设置传输方向为正</span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>问题3：中断处理函数do0怎么写？</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;; do0中断处理子函数体</span><br><span class="line">do0: jmp short do0start</span><br><span class="line">	db &#x27;overflow!&#x27;</span><br><span class="line">do0start:</span><br><span class="line">	mov ax, cs</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov si, 202h	; jmp short do0start这个语句占2字节，故是200+2=202h</span><br><span class="line">	</span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov di,12*160+36*2</span><br><span class="line">	mov cx,9</span><br><span class="line">s:	mov al,[si]</span><br><span class="line">	mov es:[di],al</span><br><span class="line">	inc si</span><br><span class="line">	add di,2</span><br><span class="line">	loop s</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>问题4：如何设置中断向量表？</strong></li>
</ul>
<p>设置中断向量表任务：将do0的入口地址0:200h，写到中断向量表的0号表项中即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200h</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br></pre></td></tr></table></figure>
<h5 id="6-6-2-单步中断"><a href="#6-6-2-单步中断" class="headerlink" title="6.6.2 单步中断"></a>6.6.2 单步中断</h5><p>由Debug中的t命令说起…</p>
<p>程序的正常执行：取指令、改变CS:IP、执行指令、取指令……</p>
<p>Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。</p>
<ul>
<li>是什么，让CPU能执行一条指令就停下来？<ul>
<li>Debug利用了CPU提供的单步中断的功能</li>
<li>使用t命令时，Debug将TF标志设为1，使CPU工作在单步中断方式下…</li>
<li>自定义单步中断处理程序，还可以实现特殊的功能。</li>
</ul>
</li>
</ul>
<p><strong>单步中断过程与处理</strong></p>
<ul>
<li>两个和中断相关的寄存器标志位<ul>
<li>TF-陷阱标志(Trap flag)：用于调试时的单步方式操作。<ul>
<li>当TF=1时，每条指令执行完后产生陷阱，由系统控制计算机</li>
<li>当TF=0时，CPU正常工作，不产生陷阱。</li>
</ul>
</li>
<li>IF-中断标志(Iinterrupt flag)<ul>
<li>当IF=1时，允许CPU响应可屏蔽中断请求;</li>
<li>当IF=0时，关闭中断</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断(中断类型码为1)，引发中断过程，执行中断处理程序。</p>
<ul>
<li>中断过程<ul>
<li>(1)取得中断类型码1;</li>
<li>(2) 标志寄存器入栈，TF、IF设置为0;<ul>
<li>中断处理程序也由一条条指令组成的。如果在执行中断处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，转去执行单步中断的中断处理程序的第一条指令……<br>上面的过程将陷入一个永远不能结束的循环CPU永远执行单步中断处理程序的第一条指令所以，在进入中断处理程序之前，设置TF=0。</li>
</ul>
</li>
<li>(3) CS、IP入栈;</li>
<li>(4) (IP)=(1×4), (CS)=(1×4+2)</li>
</ul>
</li>
</ul>
<p><strong>应用：中断不响应的情况</strong></p>
<p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应。</p>
<p>例如：在执行完向 ss寄存器传送数据的指令后，即便是发生中断，CPU 也不会响应。<br>原因：<code>ss:sp</code>联合指向栈顶，而对它们的设置应该<strong>连续完成，不能被中断打断</strong>。</p>
<h4 id="6-7-由int指令引发的中断"><a href="#6-7-由int指令引发的中断" class="headerlink" title="6.7 由int指令引发的中断"></a>6.7 由int指令引发的中断</h4><p>int格式：<code>int n</code>，n为<strong>立即数</strong>，表示中断类型码</p>
<p>功能：引发中断过程</p>
<ul>
<li>CPU执行intn指令，相当于引发一个n号中断的中断过程，执行过程如下<ul>
<li>(1) 取中断类型码n；</li>
<li>(2) 标志寄存器入栈，IF=0，TF=0；</li>
<li>(3) CS、IP入栈；</li>
<li>(4) (IP)=(n×4)，(CS)=(n×4+2)。</li>
</ul>
</li>
</ul>
<p>小小结：<br><code>int</code>指令的最终功能和<code>call</code>指令相似，都是调用一段程序。一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。</p>
<p>编写供应用程序调用的中断例程<br>技术手段：编程时，可以用<code>int</code>指令调用子程序；此子程序即中断处理程序，简称为中断例程。可以自定义中断例程实现特定功能。</p>
<ul>
<li><strong>中断处理程序的常规的步骤</strong><ul>
<li>(1) 保存用到的寄存器。</li>
<li>(2) 处理中断。</li>
<li>(3) 恢复用到的寄存器。</li>
<li>(4) 用 iret指令返回。</li>
</ul>
</li>
</ul>
<h4 id="6-8-BIOS和DOS中断处理"><a href="#6-8-BIOS和DOS中断处理" class="headerlink" title="6.8 BIOS和DOS中断处理"></a>6.8 BIOS和DOS中断处理</h4><h5 id="6-8-1-BIOS-——-基本输入输出系统"><a href="#6-8-1-BIOS-——-基本输入输出系统" class="headerlink" title="6.8.1 BIOS —— 基本输入输出系统"></a>6.8.1 BIOS —— 基本输入输出系统</h5><p><img src="https://pic.imgdb.cn/item/671611ffd29ded1a8cf80eca.png" style="zoom:60%"></p>
<p><strong>（一）BIOS，是在系统板的ROM中存放着一套程序</strong></p>
<p>容量：8KB，地址：从FE000H开始</p>
<blockquote>
<p>BIOS是一个芯片，焊在主板上的，计算机(主板)一通电，BIOS芯片就开始工作，也即开始检查各个硬件是否正常。</p>
</blockquote>
<ul>
<li>BIOS中的主要内容<ul>
<li>(1) 硬件系统的检测和初始化程序</li>
<li>(2) 外部中断和内部中断的中断例程</li>
<li>(3) 用于对硬件设备进行I/0操作的中断例程</li>
<li>(4) 其他和硬件系统相关的中断例程</li>
</ul>
</li>
<li>BIOS的意义<ul>
<li>使用BIOS功能调用，程序员不用了解硬件操作细节，直接使用指令设置参数，并中断调用BIOS例程，即可完成相关工作!</li>
<li>使用BIOS功能调用：(1) 方便编程；(2) 能写出简洁、可读性好、易于移植的程序。</li>
</ul>
</li>
</ul>
<p><strong>（二）BIOS中断调用示例</strong></p>
<p>任务：在屏幕的5行12列显示3个红底高亮闪烁绿色的a。</p>
<p>方案：<strong>用BIOS的10h中断</strong>。</p>
<p>当<code>ah=2</code>时，调用第10h中断例程的2号子程序，设置光标位置；<br>当<code>ah=9</code>时，调用第10h中断例程的9号子程序，在光标位置显示字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ah,2	;置光标功能</span><br><span class="line">	mov bh,0	;第0页</span><br><span class="line">	mov dh,5	;dh中放行号</span><br><span class="line">	mov dl,12	;dl中放列号</span><br><span class="line">	int 10h		;调用BIOS的10h中断</span><br><span class="line"></span><br><span class="line">	mov ah,9	;显示字符功能</span><br><span class="line">	mov al,&#x27;a&#x27;	;字符a</span><br><span class="line">	mov bl,11001010b	;颜色属性</span><br><span class="line">	mov bh,0	;第o页</span><br><span class="line">	mov cx,3	;字符重复个数</span><br><span class="line">	int 10h		;调用BIOS的10h中断</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>（三）有哪些BIOS中断，怎么用</strong></p>
<p><img src="https://pic.imgdb.cn/item/671616ebd29ded1a8c02bba0.png"></p>
<h5 id="6-8-2-DOS中断"><a href="#6-8-2-DOS中断" class="headerlink" title="6.8.2 DOS中断"></a>6.8.2 DOS中断</h5><p>常见的DOS中断：</p>
<p><img src="https://pic.imgdb.cn/item/67161a4ed29ded1a8c0a3965.png"></p>
<p>BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时常用到的功能。<br>和硬件设备相关的DOS中断例程中，一般都调用BIOS的中断例程。</p>
<h5 id="6-8-3-BIOS和DOS中断例程的安装过程"><a href="#6-8-3-BIOS和DOS中断例程的安装过程" class="headerlink" title="6.8.3 BIOS和DOS中断例程的安装过程"></a>6.8.3 BIOS和DOS中断例程的安装过程</h5><p>(1) CPU一加电，初始化<code>(CS)=0FFFFH，(IP)=0</code>，自动从<code>FFFF:0</code>单元开始执行程序。<code>FFFF:0</code>处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</p>
<p>(2) 初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。</p>
<p>(3) 硬件系统检测和初始化完成后，调用<code>int 19h</code>进行操作系统的引导。从此将计算机交由操作系统控制。</p>
<p>(4) DOS启动后，除完成其它工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</p>
<h4 id="6-9-端口的读写"><a href="#6-9-端口的读写" class="headerlink" title="6.9 端口的读写"></a>6.9 端口的读写</h4><h5 id="6-9-1-引入——用端口访问外设：以发声为例"><a href="#6-9-1-引入——用端口访问外设：以发声为例" class="headerlink" title="6.9.1 引入——用端口访问外设：以发声为例"></a>6.9.1 引入——用端口访问外设：以发声为例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codeseg</span><br><span class="line">codeseg segment</span><br><span class="line"></span><br><span class="line">start: mov al, 08h	;设置声音的频率</span><br><span class="line">	out 42h, al</span><br><span class="line">	out 42h, al</span><br><span class="line">	in al, 61h	;读设备控制器端口原值</span><br><span class="line"></span><br><span class="line">	mov ah, al	;保存原值</span><br><span class="line">	or al, 3	;打开扬声器和定时器</span><br><span class="line">	out 61h, al	;接通扬声器，发声</span><br><span class="line">	</span><br><span class="line">	mov cx,60000 ;延时</span><br><span class="line">delay:	nop</span><br><span class="line">	loop delay</span><br><span class="line">	</span><br><span class="line">	mov al, ah	;恢复端口原值</span><br><span class="line">	out 61h, al</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>补充：CPU的邻居</strong>——CPU可以直接读写3个地方的数据<ul>
<li>(1) CPU 内部的寄存器；</li>
<li>(2) 内存单元；</li>
<li>(3) (物理外设)端口<ul>
<li>各种接口卡，网卡、显龙等</li>
<li>主板上的接口芯片</li>
<li>其他芯片</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/67161f83d29ded1a8c1564ce.png" style="zoom:50%"></p>
<p><img src="https://pic.imgdb.cn/item/671620f3d29ded1a8c189a25.png" style="zoom:60%"></p>
<h5 id="6-9-2-端口的读写指令"><a href="#6-9-2-端口的读写指令" class="headerlink" title="6.9.2 端口的读写指令"></a>6.9.2 端口的读写指令</h5><ul>
<li>读写内存与寄存器的指令<ul>
<li><code>mov, add, push...</code></li>
</ul>
</li>
<li>读写端口的指令<ul>
<li><code>in</code>： CPU从端口读取数据</li>
<li><code>out</code>：CPU往端口写入数据</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6716226cd29ded1a8c1c00a0.png"></p>
<ul>
<li><p>端口的读写指令示例</p>
<ul>
<li><p>对0~255以内的端口进行读写，端口号用立即数给出</p>
<ul>
<li>```assembly<br>in al, 20h    ;从20h端口读入一个字节<br>out 21h, al    ;往21h端口写入一个字节<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 显对256~65535的端口进行读写时，端口号放在dx中</span><br><span class="line"></span><br><span class="line">  - ```assembly</span><br><span class="line">    mov dx,3f8h	;将端口号3f8送入dx</span><br><span class="line">    in al,dx	;从3f8h端口读入一个字节</span><br><span class="line">    out dx,al	;向3f8h端口写入一个字节</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意：在in和out指令中，只能使用<code>ax</code>或<code>al</code>来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用<code>al</code>，访问16位端口时用<code>ax</code>。</p>
<h4 id="6-10-操作CMOS-RAM芯片"><a href="#6-10-操作CMOS-RAM芯片" class="headerlink" title="6.10 操作CMOS RAM芯片"></a>6.10 操作CMOS RAM芯片</h4><h5 id="6-10-1-CMOS-RAM-芯片"><a href="#6-10-1-CMOS-RAM-芯片" class="headerlink" title="6.10.1 CMOS RAM 芯片"></a>6.10.1 CMOS RAM 芯片</h5><p><img src="https://pic.imgdb.cn/item/6716376ad29ded1a8c44e4cb.png" alt="系统开机BIOS界面" style="zoom:70%"></p>
<p>我们在操作计算机的时候，电脑一开始的时候呢，我们按f8可以进入一个叫做bios设置当中，在设置里边包含了一些时间呀包括其他的一些整个系统的信息，如果没有这些信息的话呢，计算机是不能够启动起来的。</p>
<p>那么其实做出这些工作，它得益于在整个的主板上有这么一个所谓的<strong>cmos ram芯片</strong>，它包含着一个实时的时钟和一个有128个存储单元的ram存储器。</p>
<ul>
<li>CMOS RAM 芯片<ul>
<li>(1) 包含一个实时钟和一个有128个存储单元的RAM存储器</li>
<li>(2) 128 个字节的 RAM 中存储：内部实时钟、系统配置信息，相关的程序(用于开机时配置系统信息，引导系统启动)。</li>
<li>(3) CMOS RAM 芯片靠电池供电，关机后其内部的实时钟仍可正常工作 ，特别的是，此块RAM中的信息不丢失（一般RAM掉电丢失信息，这个其实是因为在这里边有一块纽扣电池为其供电）。</li>
<li>(4) 该芯片内部有两个端口，端口地址为70h和71h，CPU通过这两个端口读写CMOS RAM。<ul>
<li>70h地址端口，存放要访问的CMOS RAM单元的地址</li>
<li>71h数据端口，存放从选定的单元中读取的数据，或要写入到其中的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/67163932d29ded1a8c46ac79.png" style="zoom:70%"></p>
<h5 id="6-10-2-端口操作示例：提取CMOSRAM中存储的时间信息"><a href="#6-10-2-端口操作示例：提取CMOSRAM中存储的时间信息" class="headerlink" title="6.10.2 端口操作示例：提取CMOSRAM中存储的时间信息"></a>6.10.2 端口操作示例：提取CMOSRAM中存储的时间信息</h5><p>问题描述：在屏幕中间显示当前的月份</p>
<p><img src="https://pic.imgdb.cn/item/67163d3bd29ded1a8c4fc97b.png"></p>
<h4 id="6-11-外设连接与中断"><a href="#6-11-外设连接与中断" class="headerlink" title="6.11 外设连接与中断"></a>6.11 外设连接与中断</h4><p>CPU通过端口与外部设备“连接”，CPU 在执行指令过程中，可以检测到发送过来的中断信息，引发<strong>中断</strong>过程，处理外设的输入。</p>
<h5 id="6-11-1-外中断：由外部设备发生的事件引起的中断"><a href="#6-11-1-外中断：由外部设备发生的事件引起的中断" class="headerlink" title="6.11.1 外中断：由外部设备发生的事件引起的中断"></a>6.11.1 外中断：由外部设备发生的事件引起的中断</h5><ul>
<li>可屏蔽中断<ul>
<li>可屏蔽中断是CPU 可以不响应的外中断。</li>
<li>CPU 是否响应可屏蔽中断，要看标志寄存器的IF 位的设置。</li>
<li>当CPU检测到可屏蔽中断信息时：<ul>
<li>如果<code>IF=1</code>，则CPU在执行完当前指令后响闻应中断，引发中断过程;</li>
<li>如果<code>IF=0</code>，则不响应可屏蔽中断。</li>
</ul>
</li>
<li>几乎所有由外设引发的外中断，都是可屏蔽中断，比如键盘输入、打印机请求。</li>
</ul>
</li>
<li>不可屏蔽中断<ul>
<li>CPU 必须响应的外中断，当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。</li>
<li>对于8086CPU不可屏蔽中断的中断类型码固定为2。</li>
<li>不可屏蔽中断在系统中有必须处理的紧急情况发生时用来通知CPU 的中断信息。</li>
</ul>
</li>
</ul>
<h5 id="6-11-2-外中断处理过程"><a href="#6-11-2-外中断处理过程" class="headerlink" title="6.11.2 外中断处理过程"></a>6.11.2 外中断处理过程</h5><ul>
<li><p>可屏蔽中断所引发的中断过程</p>
<ul>
<li>(1) 取中断类型码n；<ul>
<li>可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU（对比内中断:中断类型码是在CPU内部产生的）。</li>
</ul>
</li>
<li>(2) 标志寄存器入栈，<code>IF=0，TF=0</code>;<ul>
<li>将IF置0的原因：进入中断处理程序后，禁止其他的可屏蔽中断。如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF 置1 。</li>
</ul>
</li>
<li>(3) CS、IP入栈;</li>
<li>(4) (IP)=(n×4)，(CS)=(n×4+2)</li>
</ul>
</li>
</ul>
<ul>
<li><p>不可屏蔽中断的中断过程(中断值固定为2，不必取中断码)</p>
<ul>
<li>(1) 标志寄存器入栈，<code>IF=0，TF=0</code>;</li>
<li>(2) CS、IP入栈;</li>
<li>(3) (IP)=(8),(CS)=(0AH)。</li>
</ul>
</li>
</ul>
<blockquote>
<p>8086CPU提供的设置IF的指令：</p>
<p><code>sti</code>——用于设置<code>IF=1</code>;</p>
<p><code>cli</code>——用于设置<code>IF=0</code>。</p>
</blockquote>
<h5 id="6-11-3-PC机键盘的处理过程"><a href="#6-11-3-PC机键盘的处理过程" class="headerlink" title="6.11.3 PC机键盘的处理过程"></a>6.11.3 PC机键盘的处理过程</h5><p>键盘输入的处理过程：① 键盘输入；② 引发9号中断；③ 执行<code>int 9</code>中断例程</p>
<p><strong>（一）键盘输入</strong></p>
<ul>
<li>键盘上的每一个键相当于一个开关，键盘中有一芯片对键盘上的每一个键的开关状态进行扫描。</li>
<li>按下一个键时的操作<ul>
<li>开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。</li>
<li>扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为<code>60H</code>。</li>
</ul>
</li>
<li>松开按下的键时的操作<ul>
<li>产生一个扫描码，扫描码说明了松开的键在键盘上的位置。</li>
<li>松开按键时产生的扫描码也被送入<code>60H</code>端口中。</li>
</ul>
</li>
<li>扫描码——长度为一个字节的编码<ul>
<li>按下一个键时产生的扫描码——<strong>通码</strong>，通码的第7位为0</li>
<li>松开一个键时产生的扫描码——<strong>断码</strong>，断码的第7位为1</li>
<li><strong>断码 = 通码+80H</strong></li>
<li>例：g键的通码为22H，断码为a2H</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/671643e4d29ded1a8c5eb818.png"></p>
<p><strong>（二）引发9号中断</strong></p>
<p>键盘的输入到达60H端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。</p>
<p>CPU检测到该中断信息后，如果<code>IF=1</code>，则响应中断，引发中断过程，转去执行<code>int 9</code>中断例程。</p>
<ul>
<li><p><strong>输入的字符键值如何保存?</strong></p>
<ul>
<li>有BIOS键盘缓冲区!<ul>
<li>BIOS键盘缓冲区：是系统启动后，BIOS用于存放<code>int9</code>中断例程所接收的键盘输入的内存区。</li>
<li>BIOS键盘缓冲区：可以存储15个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码(ASCII)。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>输入了控制键和切换键，如何处理 ?</strong></p>
<ul>
<li><p>0040:17对应的内存单元存放：<strong>键盘状态字节</strong></p>
<p>| 7      | 6        | 5       | 4          | 3    | 2    | 1       | 0       |<br>| ——— | ———— | ———- | ————— | —— | —— | ———- | ———- |<br>| Insert | CapsLock | NumLock | ScrollLock | alt  | ctrl | 左shift | 右shift |</p>
</li>
</ul>
</li>
</ul>
<p><strong>（三）执行<code>int 9</code>中断例程</strong></p>
<ul>
<li>BIOS 中提供的处理键盘输入的<code>int 9</code>中断例程的工作<ul>
<li>(1) 读出60H 端口中的扫描码</li>
<li>(2) 根据扫描码分情况对待<ul>
<li>如果是字符键的扫描码，将该扫描码和它所对应的字符码(即 ASCI码)送入内存中的BIOS键盘缓冲区</li>
<li>如果是控制键(比如 Ctrl)和切换键(比如 CapsLock)的扫描码，则将其转变为状态字节(用二进制位记录控制键和切换键状态的字节 )写入内存中存储状态字节的单元。 </li>
</ul>
</li>
<li>(3) 对键盘系统进行相关的控制，如向相关芯片发出应答信息。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/67164990d29ded1a8c637dd9.png"></p>
<h5 id="6-11-4-定制键盘输入处理"><a href="#6-11-4-定制键盘输入处理" class="headerlink" title="6.11.4 定制键盘输入处理"></a>6.11.4 定制键盘输入处理</h5><p><strong>（一）PC机键盘的处理过程(int9中断例程)</strong></p>
<p><img src="https://pic.imgdb.cn/item/67164a11d29ded1a8c63fec7.png"></p>
<p><strong>（二）编程任务</strong></p>
<p>在屏幕中间依次显示’a’~’z’，并可以让人看清，在显示的过程中，按下Esc键后，改变显示的颜色。</p>
<p>方案：尽可能忽略硬件处理细节，充分利用BIOS提供的<code>int9</code>中断例程对这些硬件细节进行处理；在改写后的中断例程中满足特定要求，并能调用BIOS的原<code>int9</code>中断例程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;依次显示&#x27;a&#x27;~&#x27;z&#x27;</span><br><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">	db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: mov ax,stack</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,128</span><br><span class="line">	</span><br><span class="line">	;显示字符</span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ah,&#x27;a&#x27;</span><br><span class="line">s:   mov es:[160*12+40*2],ah</span><br><span class="line">	call delay</span><br><span class="line">	inc ah</span><br><span class="line">	cmp ah,&#x27;z&#x27;</span><br><span class="line">	jna s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	;定义延时函数</span><br><span class="line">delay: push ax</span><br><span class="line">	push dx</span><br><span class="line">	mov dx,10h</span><br><span class="line">	mov ax,0</span><br><span class="line">s1: sub ax, 1</span><br><span class="line">	sbb dx, 0</span><br><span class="line">	cmp ax,0</span><br><span class="line">	jne s1</span><br><span class="line">	cmp dx,0</span><br><span class="line">	jne s1</span><br><span class="line">	pop dx</span><br><span class="line">	pop ax</span><br><span class="line">	ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>接下来的工作：按下 ESc键后，改变显示的颜色!<br>原理：键盘输入到达60h端口后，就会引发 9号中断，CPU 则转去执行int 9中断例程。</p>
<ul>
<li>按下 Esc键后改变显示的颜色<ul>
<li>编写int 9中断例程改变显示的颜色<ul>
<li>(1) 从60h端口读出键盘的输入<ul>
<li><code>in al 60h</code></li>
</ul>
</li>
<li>(2) 调用BlOS的int9中断例程，处理硬件细节<ul>
<li>① 关于中断处理程序入口地址面对的问题<ul>
<li>要将中断向量表中的<code>int 9</code>中断例程的入口地址改为自编的中断处理程序的入口地址。</li>
<li>在新中断处理程序中调用原来的<code>int 9</code>中断例程，还需要是原来的<code>int9</code>中断例程的地址。</li>
<li>解决方法：保存原中断例程入口地址</li>
<li>将原来<code>int 9</code>中断例程的偏移地址和段地址保存在<code>ds:[0]</code>和<code>ds:[2]</code>单元中，在需要调用原来的<code>int 9</code>中断例程时候，到<code>ds:[0]、ds:[2]</code>找到</li>
</ul>
</li>
<li>② 如何调用原<code>int 9</code>指令的中断例程口<ul>
<li><code>int 9</code>己改，但仍然需要调用原<code>int 9</code>指令功能</li>
<li>解决方法：模拟对原中断例程的调用<br>(1) 标志寄存器入栈<br>(2) IF=0，TF=0<br>(3) CS、IP入栈<br>(4) (IP)=((ds)×16+0)，(CS)=((ds)×16+2)</li>
</ul>
</li>
</ul>
</li>
<li>(3) 判断是否为Esc的扫描码，如果是，改变显示的颜色后返回；如果不是，则直接返回。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: mov ax, stack</span><br><span class="line">	mov ss,aX</span><br><span class="line">	mov sp,128</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	;改变中断例程入口地址</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov es,ax</span><br><span class="line">	push es:[9*4]</span><br><span class="line">	pop ds:[0]</span><br><span class="line">	push es:[9*4+2]</span><br><span class="line">	pop ds:[2]</span><br><span class="line">	mov word ptr es:[9*4], offset int9</span><br><span class="line">	mov es:[9*4+2],cs</span><br><span class="line">	</span><br><span class="line">	;显示&#x27;a&#x27;~&#x27;z</span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ah,&#x27;a&#x27;</span><br><span class="line">s:	mov es:[160*12+40*2],ah</span><br><span class="line">	call delay</span><br><span class="line">	inc ah</span><br><span class="line">	cmp ah,&#x27;z&#x27;</span><br><span class="line">	jna s</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov es,ax</span><br><span class="line"></span><br><span class="line">	; 恢复原来的地址</span><br><span class="line">	push ds:[0]</span><br><span class="line">	pop es:[9*4]</span><br><span class="line">	push ds:[2]</span><br><span class="line">	pop es:[9*4+2]</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">	;定义延迟程序</span><br><span class="line">	delay: push ax</span><br><span class="line">	push dx</span><br><span class="line">	mov dx,10h</span><br><span class="line">	mov ax,0</span><br><span class="line">s1: sub ax, 1</span><br><span class="line">	sbb dx, 0</span><br><span class="line">	cmp ax,0</span><br><span class="line">	jne s1</span><br><span class="line">	cmp dx,0</span><br><span class="line">	jne s1</span><br><span class="line">	pop dx</span><br><span class="line">	pop ax</span><br><span class="line">	ret</span><br><span class="line">	</span><br><span class="line">	;定义中断例程</span><br><span class="line">int9: push ax</span><br><span class="line">	push bx</span><br><span class="line">	push es</span><br><span class="line">	in al,60h</span><br><span class="line">	pushf</span><br><span class="line">	;pushf</span><br><span class="line">	pop bx</span><br><span class="line">	and bh,11111100b</span><br><span class="line">	push bx</span><br><span class="line">	popf</span><br><span class="line">	call dword ptr ds:[0]	;call的存在说明只是给esc增加了一个功能，并没有替换原有功能</span><br><span class="line">	</span><br><span class="line">	cmp al,1	;ESC扫描码1</span><br><span class="line">	jne int9ret</span><br><span class="line">	;改变颜色</span><br><span class="line">	mov ax,0bg00h</span><br><span class="line">	mov es,ax</span><br><span class="line">	inc byte ptr es:[160*12+40*2+1]</span><br><span class="line">	</span><br><span class="line">int9ret:pop es</span><br><span class="line">	pop bx</span><br><span class="line">	pop ax</span><br><span class="line">	iret</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h5 id="6-11-5-改写中断例程的方法"><a href="#6-11-5-改写中断例程的方法" class="headerlink" title="6.11.5 改写中断例程的方法"></a>6.11.5 改写中断例程的方法</h5><h5 id="6-11-6-用中断响应外设"><a href="#6-11-6-用中断响应外设" class="headerlink" title="6.11.6 用中断响应外设"></a>6.11.6 用中断响应外设</h5><p><strong>（一）如何操作外部设备</strong></p>
<p>以典型输入设计——键盘操作为例</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>硬件中断 int 9h</th>
<th>BIOS中断 int 16h</th>
<th>DOS中断 int 21h</th>
</tr>
</thead>
<tbody>
<tr>
<td>由键盘上按下或松开一个键<br>时，如果中断是允许的，就<br>会产生int 9h中断，并转到<br>BIOS的键盘中断处理程序。</td>
<td>BIOS中断提供基本的键盘操作<br>功能号(AH)=<br>00H、10H 一从键盘读入字符<br>01H、11H 一读取键盘状态<br>02H、12H 一读取键盘标志<br>03H 一设置重复率<br>04H一设置键盘点击<br>05H 一字符及其扫描码进栈<br>在使用功能键和变换键的程序中很重要。</td>
<td>Dos中断提供丰富、便捷的功能调用<br>功能号(AH)=<br>01H 一 从键盘输入一个字符并回显<br>06H 一 读键盘字符<br>07H 一 从键盘输入一个字符不回显<br>08H 一 从键盘输入一个字符，不回显，检测CTRL-Break<br>0AH 一 输入字符到指定地址的缓冲<br>0BH - 读键盘状态<br>0CH -清除键盘缓冲区，并调用一种键盘功能</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>键盘缓冲区的实现<br>① 共16字<br>② 用<strong>环形队列</strong>，先进先出<br>③ 可存储15个按键扫描码</p>
</blockquote>
<p>对键盘输入的处理的<code>int 9h</code>中断和<code>int 16h</code>中断：</p>
<p>（1）<code>int 9h</code>将键盘输入存入缓冲或改变状态字，键盘输入将引发9号中断，BIOS提供了int 9中断例程。</p>
<p>int 9中断例程从60h端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。</p>
<p>键盘缓冲区中有16 个字单元，可以存储15个按键的扫描码和对应的入ASCII 码。</p>
<p>（2）BIOS提供了<code>int 16h</code>中断例程供程序员调用，以完成键盘的各种操作。</p>
<p>例：当<code>(AH)=0</code>时，读取键盘缓冲区功能：从键盘缓冲区中读取一个键盘输入，并且将其从缓冲区中删除。</p>
<p>（3）BIOS的<code>int 9h</code>中断例程和<code>int 16h</code>中断例程是一对相互配合的程序，<code>int 9h</code>中断例程向键盘缓冲区中写入，<code>int 16h</code>中断例程从缓冲区中读出。它们写入和读出的时机不同，<code>int 9h</code>中断例程在有键按下的时候向键盘缓冲区中写入数据而<code>int 16h</code>中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。</p>
<blockquote>
<p>补充解释：</p>
<p><code>int 9h</code>是<strong>硬件中断</strong>，这个中断历程呢是在有键摁下去的时候，向键盘缓冲区里边呢去写入数据，这个过程<strong>不受CPU控制</strong>，是单纯的外设键盘触发的外部硬件中断；</p>
<p><code>int 16h</code>是<strong>软件中断</strong>，它是在应用程序里边对它进行调用的时候，才将数据从键盘缓冲区中读出。</p>
<p>从cpu角度来讲，我不管你键盘什么时候去产生这样的呃动作，我需要的时候，我就通过<code>int 16h</code>去调用它，而对于<code>int 9h</code>号中断来讲，它和cpu没有关系，只要说有键摁下去了，就把它记下来。当这两个中断在应用程序里边我们合理的去设置的时候呢，他们相互配合呢帮助我们去读取这样一些数据。</p>
</blockquote>
<p><strong>（二）应用示例：更改屏幕颜色</strong></p>
<p>要求：接收用户的键盘输入<br>输入“r”，将屏幕上的字符设置为红色；输入“g”，将屏幕上的字符设置为绿色；输入“b”，将屏幕上的字符设置为蓝色。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	;调用中断，等待输入</span><br><span class="line">	mov ah,0</span><br><span class="line">	int 16h</span><br><span class="line">	</span><br><span class="line">	;识别按键</span><br><span class="line">	mov ah,1</span><br><span class="line">	cmp al,&#x27;r&#x27;</span><br><span class="line">	je red</span><br><span class="line">	cmp al,&#x27;g&#x27;</span><br><span class="line">	je green</span><br><span class="line">	cmp al,&#x27;b&#x27;</span><br><span class="line">	je blue</span><br><span class="line">	jmp short sret</span><br><span class="line">	</span><br><span class="line">	;设置屏幕颜色</span><br><span class="line">red:	shl ah,1</span><br><span class="line">green:	shl ah,1</span><br><span class="line">blue:	mov bx,0b800h</span><br><span class="line">	mov es,bx</span><br><span class="line">	mov bx,1</span><br><span class="line">	mov cx,2000</span><br><span class="line">	and byte ptr es:[bx],11111000b</span><br><span class="line">	or es:[bxl,ah</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">sret: mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><strong>（三）应用：字符串的输入</strong></p>
<p>问题：设计一个最基本的字符串输入程序，需要具备下面的功能：</p>
<p>(1) 在输入的同时需要显示这个字符串<br>(2) 一般在输入回车符后，字符串输入结束<br>(3) 能够删除已经输入的字符——用退格键。</p>
<p>程序的处理过程</p>
<p>(1) 调用<code>int 16h</code>读取键盘输入；<br>(2) 如果不是字符：①如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符，继续执行(1)；②如果是Enter键，向字符栈中压入0，返回；<br>(3) 如果是字符键：字符入栈，显示字符栈中的所有字符，继续执行(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 该程序未完成</span><br><span class="line">assume cs:code, ds:data</span><br><span class="line">data segment	;“栈”空间</span><br><span class="line">	db 32 dup (?)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax, data</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov si, 0</span><br><span class="line">	mov dh, 12</span><br><span class="line">	mov dl, 20</span><br><span class="line">	call getstr</span><br><span class="line">	</span><br><span class="line">return: mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">;完整的接收字符串输入的子程序</span><br><span class="line">getstr:	push ax</span><br><span class="line">getstrs:</span><br><span class="line">	;调用int 16h读取键盘输入</span><br><span class="line">	mov ah,0</span><br><span class="line">	int 16h</span><br><span class="line">	</span><br><span class="line">	cmp al,20h</span><br><span class="line">	jb nochar ;小于20h为非字符</span><br><span class="line">	;字符入栈</span><br><span class="line">	;显示栈中的字符</span><br><span class="line">	jmp getstrs</span><br><span class="line">	</span><br><span class="line">;处理非字符</span><br><span class="line">nochar:	</span><br><span class="line">	cmpah,oeh	;退格键的扫描码</span><br><span class="line">	je backspace</span><br><span class="line">	cmp ah,1ch	;回车键的扫描码</span><br><span class="line">	je enter</span><br><span class="line">	jmp getstrs</span><br><span class="line"></span><br><span class="line">;对退格键、回车键的处理</span><br><span class="line">;退格</span><br><span class="line">backspace:</span><br><span class="line">	;字符出栈</span><br><span class="line">	;显示栈中的字符</span><br><span class="line">	jmp getstrs</span><br><span class="line">;回车</span><br><span class="line">enter:	mov al,0</span><br><span class="line">	;0字符入栈</span><br><span class="line">	;显示栈中的字符</span><br><span class="line">	</span><br><span class="line">	pop ax</span><br><span class="line">	ret	;getstr结束</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h4 id="6-12-读写磁盘"><a href="#6-12-读写磁盘" class="headerlink" title="6.12 读写磁盘"></a>6.12 读写磁盘</h4><p>磁盘，包括“软盘”、“硬盘”（不过软盘已经退出历史舞台了）</p>
<p><img src="https://pic.imgdb.cn/item/67175f8cd29ded1a8c1f079d.png"></p>
<p><strong>（一）BIOS对磁盘的操作</strong></p>
<ul>
<li>用BlOS <code>int 13h</code>对磁盘进行读操作<ul>
<li>入口参数：<ul>
<li>(ah) = 2(2表示读扇区)</li>
<li>(al)=读取的扇区数</li>
<li>(ch)=磁道号 ，(cl)=扇区号</li>
<li>(dh)=磁头号(对于软盘即面号，一个面用一个磁头来读写)</li>
<li>(dl)=驱动器号:软驱从0开始，0:软驱A，1:软驱B，硬盘从80h开始，80h:硬盘C，81h:硬盘D</li>
<li>es:bx指向接收从扇区读入数据的内存区</li>
</ul>
</li>
<li>返回参数：<ul>
<li>操作成功：(ah)=0，(al)=读入的扇区数</li>
<li>操作失败：(ah)=出错代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例子：读取c盘0面0道1扇区的内容到内存单元0:200</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h	;读入0:200h</span><br><span class="line">mov al,1	;1个扇区</span><br><span class="line">mov ch,0	;0磁道</span><br><span class="line">mov cl,1	;1扇区</span><br><span class="line">mov dl,80h	;C盘</span><br><span class="line">mov dh,0	;0面</span><br><span class="line">mov ah,2	;读扇区</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure>
<ul>
<li>用BlOS <code>int 13h</code>对磁盘进行写操作</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/67176239d29ded1a8c2140f6.png" style="zoom:60%"></p>
<p>例子：将0:200中的内容写入C盘0面0道1扇区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h	;写0:200h</span><br><span class="line">mov al,1	;写1个扇区</span><br><span class="line">mov ch,0	;0磁道</span><br><span class="line">mov cl,1	;1扇区</span><br><span class="line">mov dl,80h	;C盘</span><br><span class="line">mov dh,0	;0面</span><br><span class="line">mov ah,3	;3号写入功能</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure>
<p><strong>（二）DOS中断对磁盘文件的支持—<code>int 21H</code></strong></p>
<p><img src="https://pic.imgdb.cn/item/6717635dd29ded1a8c233b61.png"></p>
<ul>
<li>功能39H<ul>
<li>功能描述：用指定的驱动器和路径创建一个新目录</li>
<li>入口参数：<ul>
<li>AH = 39H</li>
<li>DS:DX=指定路径的字符串地址(以0为字符串的结束标志)</li>
</ul>
</li>
<li>出口参数：<ul>
<li>CF=0——创建成功</li>
<li>CF=1——创建失败，AX=错误号(03H或05H)，其含义见错误代码表</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学1</title>
    <url>/2022/06/26/Advanced-mathematics1/</url>
    <content><![CDATA[<h3 id="1-极限"><a href="#1-极限" class="headerlink" title="1 极限"></a>1 极限</h3><p>微积分，既是一种工具也思想。方法虽看似繁多其实背后蕴含的道理浅显而直观莫要迷失于众多的题目中，关键在于体会方法背后的想。</p>
<h4 id="1-1-认识极限"><a href="#1-1-认识极限" class="headerlink" title="1.1 认识极限"></a>1.1 认识极限</h4><center><img src="https://pic.imgdb.cn/item/62b6d79a0947543129609682.jpg" style="zoom:50%"></center>

<p>极限式如$\lim\limits_{x \to a}f(x)$、$\lim\limits_{x \to \infty}f(x)$的含义是：当$x$向某个值(或无穷远)处靠近时，$f(x)$向那个值靠近。例如：$\lim\limits_{x \to 2}(x+3) = 5$。</p>
<h4 id="1-2-理解极限"><a href="#1-2-理解极限" class="headerlink" title="1.2 理解极限"></a>1.2 理解极限</h4><p>极限过程是一个动态的过程，不是一个“死”的数字。而至于“$\lim$”符号，是解算出接近的目标。要体会“$x \to a$”和“$x = a$”之间的区别。当$x \to a$时，$(x - a)$是无穷小的，所以我们研究极限时，大部分时候都是在和“无穷小”以及“无穷大”打交道。</p>
<h4 id="1-3-求函数极限"><a href="#1-3-求函数极限" class="headerlink" title="1.3 求函数极限"></a>1.3 求函数极限</h4><h5 id="1-3-1-求解函数极限"><a href="#1-3-1-求解函数极限" class="headerlink" title="1.3.1 求解函数极限"></a>1.3.1 求解函数极限</h5><ul>
<li>第一步，代入：将自变量极限值代入极限表达式，如果不能得到结果，继续下一步；<ul>
<li>代入时，需要注意三点问题：① 无穷大与无穷小之间呈倒数关系；② 无穷小×有界函数=无穷小；③ 需要注意极限的方向性问题，区分“$x \to +\infty$”和“$x \to -\infty$”</li>
</ul>
</li>
<li>第二步，分类：判断极限类型属于“$\dfrac{0}{0}$”、“$\dfrac{\infty}{\infty}$”、“$1^{\infty}$”、“${\infty} - {\infty}$”、“$0 \cdot \infty$”、“$\infty^0$”中的哪一种，重点是识别出式中的无穷小和无穷大成分；</li>
<li>第三步，求解：根据极限类型，选择分别适用的求解方法，进行化简或者变形。</li>
</ul>
<h5 id="1-3-2-无穷小相关的极限问题"><a href="#1-3-2-无穷小相关的极限问题" class="headerlink" title="1.3.2 无穷小相关的极限问题"></a>1.3.2 无穷小相关的极限问题</h5><p>对于无穷小相关的极限，可采用的方法有：</p>
<ul>
<li>1° 化简：消除“致0 因子”；</li>
<li>2° 等价无穷小代换；</li>
<li>3° 洛必达法则。</li>
</ul>
<p>常用的等价无穷小代换：当$x \to 0$时，下列表格中左侧的无穷小量可以用右侧的替换：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">原函数</th>
<th style="text-align:center">等价无穷小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\sin x$</td>
<td style="text-align:center">$x$</td>
</tr>
<tr>
<td style="text-align:center">$\tan x$</td>
<td style="text-align:center">$x$</td>
</tr>
<tr>
<td style="text-align:center">$\arcsin x$</td>
<td style="text-align:center">$x$</td>
</tr>
<tr>
<td style="text-align:center">$\arctan x$</td>
<td style="text-align:center">$x$</td>
</tr>
<tr>
<td style="text-align:center">$\ln(1 + x)$</td>
<td style="text-align:center">$x$</td>
</tr>
<tr>
<td style="text-align:center">$e^x - 1$</td>
<td style="text-align:center">$x$</td>
</tr>
<tr>
<td style="text-align:center">$[(1+x)^a - 1]$</td>
<td style="text-align:center">$ax$</td>
</tr>
<tr>
<td style="text-align:center">$1-\cos x$</td>
<td style="text-align:center">$\dfrac{1}{2}x^2$</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Tips：函数$f(x)$如果过原点，即$f(0)=0$，而且导数有$f’(0) = a$，则在$x \to a$时， 可以和$ax$等价无穷小代换(<strong>泰勒展开</strong>)。</p>
</blockquote>
<p>使用等价无穷小代换时，需要关注以下2个细节：</p>
<ul>
<li>要学会“抓住”无穷小，如果$x \to 0$，则相应的$ax$也是无穷小。如果$x \to a(a \neq 0)$，此时就要从式子中凑出$(x - a)$这个量；</li>
<li>两个无穷小量相加减时，不可将其中任意一个部分进行代换。</li>
</ul>
<h5 id="1-3-3-无穷大相关的极限问题"><a href="#1-3-3-无穷大相关的极限问题" class="headerlink" title="1.3.3 无穷大相关的极限问题"></a>1.3.3 无穷大相关的极限问题</h5><p>解决无穷大类型问题的方法：“抓大头”的思想理念，抓住主要矛盾，忽略次要成分：</p>
<script type="math/tex; mode=display">
\ln x \ll x^{a} \ll x^{b} \ll c^{x} \ll d^{x} \ll x ! \ll x^{x} \quad(x \rightarrow \infty, 0<a<b, 1<c<d)</script><p>当两个相差无穷倍的量相进行加减时，这时候我们眼里可以忽略相对较小的一个量。在具体操作上，应该将最大的成分提括号外，分子分母同时除掉即可。</p>
<h5 id="1-3-4-极限运算法则"><a href="#1-3-4-极限运算法则" class="headerlink" title="1.3.4 极限运算法则"></a>1.3.4 极限运算法则</h5><p>如果函数$u, v$极限存在，则：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\lim (u \pm v)=\lim u \pm \lim v \\
&\lim u \cdot v=\lim u \cdot \lim v \\
&\lim \frac{u}{v}=\frac{\lim u}{\lim v}(v \neq 0)
\end{aligned}</script><p>在处理极限的时候，我们可以选择将极限进行部分地运算。但要尤其注意前提条件！</p>
<h3 id="2-函数的连续性与间断点"><a href="#2-函数的连续性与间断点" class="headerlink" title="2 函数的连续性与间断点"></a>2 函数的连续性与间断点</h3><p>函数连续性应满足条件：$\lim\limits_{x \to a}f(x) = f(a)$(着重体会$x \to a$和$x = a$的区别)该条件意味着函数图像应该是一条连续的线条，不会有断点。我们接触到的函数，断点往往会出现在这两种地方：分段函数的分界点、函数定义域的边界。比如下面这种情况：</p>
<center><img src="https://pic.imgdb.cn/item/62b6e1bd09475431296ebdcb.jpg" style="zoom:50%"></center>

<p>通过计算$\lim\limits_{x \to a}f(x)$后与$f(a)$作比较，就可以得到函数在$x = a$处的连续或间断情况。函数间断点有以下四种情形：</p>
<center><img src="https://pic.imgdb.cn/item/62b6e25b09475431296f8932.jpg" style="zoom:50%"></center>

<center><img src="https://pic.imgdb.cn/item/648c16f31ddac507cc36c237.png" style="zoom:100%"></center>

<p><strong>总结：</strong></p>
<center><img src="https://pic.imgdb.cn/item/648c176f1ddac507cc382514.jpg"></center>

<h3 id="3-微分"><a href="#3-微分" class="headerlink" title="3 微分"></a>3 微分</h3><h4 id="3-1-导数的定义"><a href="#3-1-导数的定义" class="headerlink" title="3.1 导数的定义"></a>3.1 导数的定义</h4><p>直线的斜率$k$：</p>
<p>(1) $y$随$x$变化的方向与快慢：$x$每增加一个单位，$y$的变化量为$k$；<br>(2) 反映出直线的坡度：直线与$x$轴正方向夹角为$\alpha$，$k = \tan \alpha$。</p>
<center><img src="https://pic.imgdb.cn/item/648c17be1ddac507cc38fd4a.jpg"></center>

<p>如何研究曲线中$y$随$x$变化的快慢？</p>
<center><img src="https://pic.imgdb.cn/item/648c17de1ddac507cc3967e0.jpg"></center>

<p>导数反映出因变量随着自变量增长而变化的快慢。导数定义如下：</p>
<center><img src="https://pic.imgdb.cn/item/648c18001ddac507cc39dbc8.jpg"></center>

<p>导数也被叫做“微商”，可以理解为两个无穷小量之间的比值。</p>
<h4 id="3-2-导数的基本运算"><a href="#3-2-导数的基本运算" class="headerlink" title="3.2 导数的基本运算"></a>3.2 导数的基本运算</h4><h5 id="3-2-1-常用函数的导数"><a href="#3-2-1-常用函数的导数" class="headerlink" title="3.2.1 常用函数的导数"></a>3.2.1 常用函数的导数</h5><script type="math/tex; mode=display">
\begin{array}{ll}
(c)^{\prime}=0 \quad(c \text { 为常数 }) & \left(x^{\alpha}\right)^{\prime}=\alpha x^{\alpha-1} \\
(\sin x)^{\prime}=\cos x & (\cos x)^{\prime}=-\sin x \\
(\tan x)^{\prime}=\sec ^{2} x & (\cot x)^{\prime}=-\csc ^{2} x \\
(\ln x)^{\prime}=\frac{1}{x} & \left(\log _{a} x\right)^{\prime}=\frac{1}{x \ln a} \quad(a>0, a \neq 1) \\
\left(\mathrm{e}^{x}\right)^{\prime}=\mathrm{e}^{x} & \left(a^{x}\right)^{\prime}=a^{x} \ln a \quad(a>0) \\
(\arcsin x)^{\prime}=\frac{1}{\sqrt{1-x^{2}}} & (\arctan x)^{\prime}=\frac{1}{1+x^{2}}
\end{array}</script><h5 id="3-2-2-导数四则运算法则"><a href="#3-2-2-导数四则运算法则" class="headerlink" title="3.2.2 导数四则运算法则"></a>3.2.2 导数四则运算法则</h5><script type="math/tex; mode=display">
\begin{aligned}
&{[f(x) \pm g(x)]^{\prime}=f^{\prime}(x) \pm g^{\prime}(x)} \\
&{[f(x) \cdot g(x)]^{\prime}=f^{\prime}(x) \cdot g(x)+f(x) \cdot g^{\prime}(x)} \\
&{\left[\frac{f(x)}{g(x)}\right]^{\prime}=\frac{f^{\prime}(x) g(x)-f(x) g^{\prime}(x)}{g^{2}(x)} \quad(g(x) \neq 0)}
\end{aligned}</script><h5 id="3-2-3-复合函数求导"><a href="#3-2-3-复合函数求导" class="headerlink" title="3.2.3 复合函数求导"></a>3.2.3 复合函数求导</h5><script type="math/tex; mode=display">
[ f(g(x))]' = f'(g(x)) \cdot g'(x)</script><h5 id="3-2-4-求导链式法则"><a href="#3-2-4-求导链式法则" class="headerlink" title="3.2.4 求导链式法则"></a>3.2.4 求导链式法则</h5><p>即设置中间变量：</p>
<script type="math/tex; mode=display">
\dfrac{\text{d}y}{\text{d}x} = \dfrac{\text{d}y}{\text{d}u} \cdot \dfrac{\text{d}u}{\text{d}x}</script><h5 id="3-2-5-莱布尼茨公式"><a href="#3-2-5-莱布尼茨公式" class="headerlink" title="3.2.5 莱布尼茨公式"></a>3.2.5 莱布尼茨公式</h5><p>设$u = u(x)$、$v = v(x)$分别是关于$x$的函数，那么：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& (uv)' = u'v + uv' \\
& (uv)'' = (u'v + uv')' = (u'v)' + (uv')' = u''v + 2u'v' + uv''
\end{aligned}</script><p>如果函数$u = u(x)$、$v = v(x)$分别具有$n$阶导数，那么两者乘积的$n$阶导数为如下形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
{[u(x) \cdot v(x)]^{(n)} } &=C_{n}^{0} u^{(n)} v+C_{n}^{1} u^{(n-1)} v^{\prime}+C_{n}^{2} u^{(n-2)} v^{\prime \prime}+\cdots+C_{n}^{n-1} u^{\prime} v^{(n-1)}+C_{n}^{n} v^{(n)} u \\
&=\sum_{k=0}^{n} C_{n}^{k} u^{(k)} \cdot v^{(n-k)}
\end{aligned}</script><p>掌握莱布尼茨公式并不难，它类似于我们高中的“二项式定理”。</p>
<h5 id="3-2-6-隐函数求导"><a href="#3-2-6-隐函数求导" class="headerlink" title="3.2.6 隐函数求导"></a>3.2.6 隐函数求导</h5><p>隐函数，例如：$y - xe^y = 1$，可以写为$y - xe^y - 1 = 0$，但是无法改写为$y = f(x)$的形式。这时求$y’$，左右两侧同时对$x$求导。注意，有时候我们遇到需要求导的问题，给出的函数并非隐函数的形式，但是转化成隐函数求导反而更简单。</p>
<h5 id="3-2-7-参数方程求导"><a href="#3-2-7-参数方程求导" class="headerlink" title="3.2.7 参数方程求导"></a>3.2.7 参数方程求导</h5><p>形如$\left\{\begin{array}{l}y=f(t) \\ x=g(t)\end{array}\right.$，如果求$\dfrac{\text{d}y}{\text{d}x}$，则就等于$\dfrac{\text{d}y}{\text{d}x} = \dfrac{\dfrac{\text{d}y}{\text{d}t}}{\dfrac{\text{d}x}{\text{d}t}}$，也就是分别求出$\dfrac{\text{d}f}{\text{d}t}$、$\dfrac{\text{d}g}{\text{d}t}$再相除。</p>
<h4 id="3-3-泰勒公式"><a href="#3-3-泰勒公式" class="headerlink" title="3.3 泰勒公式"></a>3.3 泰勒公式</h4><h5 id="3-3-1-什么是泰勒公式"><a href="#3-3-1-什么是泰勒公式" class="headerlink" title="3.3.1 什么是泰勒公式"></a>3.3.1 什么是泰勒公式</h5><p>$x$的多项式函数：$y = a_0 + a_1 x + a_2 x^2 + \cdots + a_n x^n$，$x$的多项式次数越高，对应的曲线形状就越多变。于是我们可以用高次多项式来逼近其他函数，比如三角函数、对数函数、指数函数等等，如下图所示：</p>
<center><img src="https://pic.imgdb.cn/item/648c18251ddac507cc3a4292.jpg"></center>

<p>泰勒公式就是把$(n + 1)$阶可导的函数写成下列格式：</p>
<script type="math/tex; mode=display">
f(x)=f\left(x_{0}\right)+\frac{f^{\prime}\left(x_{0}\right)}{1 !}\left(x-x_{0}\right)+\frac{f^{\prime \prime}\left(x_{0}\right)}{2 !}\left(x-x_{0}\right)^{2}+\cdots+\frac{f^{(n)}\left(x_{0}\right)}{n !}\left(x-x_{0}\right)^{n}+R_{n}(x)</script><p>我们需要把握下列常见函数的泰勒展开(麦克劳林展开，佩亚诺余项)形式：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
\sin x=x-\frac{1}{3 !} x^{3}+\frac{1}{5 !} x^{5}+o\left(x^{5}\right) & \mathrm{e}^{x}=1+\frac{1}{1 !} x+\frac{1}{2 !} x^{2}+\frac{1}{3 !} x^{3}+o\left(x^{3}\right) \\
\cos x=1-\frac{1}{2 !} x^{2}+\frac{1}{4 !} x^{4}+o\left(x^{4}\right) & \frac{1}{1-x}=1+x+x^{2}+x^{3}+o\left(x^{3}\right) \\
\tan x=x+\frac{1}{3} x^{3}+\frac{2}{15} x^{5}+o\left(x^{5}\right) & \ln (1+x)=x-\frac{1}{2} x^{2}+\frac{1}{3} x^{3}+o\left(x^{3}\right)
\end{array}</script><ul>
<li>泰勒公式的要点：<br>(1) 上述是在$x = 0$附近进行的近似，当$x \to 0$时，余项可以近似舍弃；<br>(2) $\dfrac{1}{1-x}=1+x+x^{2}+x^{3}+o(x^3)$可以用等比数列从右向左推导。<br>(3) 利用导数、原函数的关系，就可以辅助记忆，例如$\ln(1+x)$泰勒公式可以用$\dfrac{1}{1-x}$来获得；<br>(4) 泰勒公式可以将复杂的函数计算化简成为加减乘除；<br>(5) 泰勒公式具有拓展性，当$x \to 0$时：$\sin x$、$\ln(1+x)$、$5x$也是无穷小量，在泰勒公式左右两侧<br>对进行替换，例如：<script type="math/tex; mode=display">
\dfrac{1}{1-5 x}=1+5 x+25 x^{2}+125 x^{3}+\cdots</script></li>
</ul>
<h5 id="3-3-2-泰勒公式的应用"><a href="#3-3-2-泰勒公式的应用" class="headerlink" title="3.3.2 泰勒公式的应用"></a>3.3.2 泰勒公式的应用</h5><p>(1) 利用泰勒公式求极限</p>
<p>泰勒公式可以看作是超级版本的无穷小代换，它不会受到加减法不能换的限制。</p>
<script type="math/tex; mode=display">
\lim _{x \rightarrow 0} \frac{\tan x-\sin x}{x^{3}}=\lim _{x \rightarrow 0} \frac{\left(x+\frac{1}{3} x^{3}\right)-\left(x-\frac{1}{6} x^{3}\right)}{x^{3}}=\lim _{x \rightarrow 0} \frac{\frac{1}{2} x^{3}}{x^{3}}=\frac{1}{2}</script><p>(2) 判断无穷小的阶数</p>
<p>$x \to 0$时，判断下式的无穷小阶数(答案是3阶)：</p>
<script type="math/tex; mode=display">
\frac{1}{1-x}-\mathrm{e}^{x}+\cos x-1=\left(1+x+x^{2}+x^{3}\right)-\left(1+x+\frac{1}{2} x^{2}+\frac{1}{6} x^{3}\right)+\left(1-\frac{x^{2}}{2}+\frac{x^{4}}{24}\right)-1=\frac{5}{6} x^{3}</script><p>(3) 求高阶导数</p>
<h3 id="4-积分部分"><a href="#4-积分部分" class="headerlink" title="4 积分部分"></a>4 积分部分</h3><h4 id="4-1-积分的基本概念：定积分和不定积分"><a href="#4-1-积分的基本概念：定积分和不定积分" class="headerlink" title="4.1 积分的基本概念：定积分和不定积分"></a>4.1 积分的基本概念：定积分和不定积分</h4><center><img src="https://pic.imgdb.cn/item/648c18501ddac507cc3aad00.jpg"></center>

<p>例如求$y = e^x$在$x \in [0, 1]$区间内的函数区域面积，则有：</p>
<center><img src="https://pic.imgdb.cn/item/648c18691ddac507cc3af312.jpg" style="zoom:60%"></center>

<p>假设把$0 \sim 1$区间切割为$n$份，每个小矩形的宽度为$\dfrac{1}{n}$，则总面积有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
S &=\lim _{n \rightarrow \infty} \frac{1}{n} \mathrm{e}^{\frac{1}{n}}+\frac{1}{n} \mathrm{e}^{\frac{2}{n}}+\frac{1}{n} \mathrm{e}^{\frac{3}{n}}+\cdots+\frac{1}{n} \mathrm{e}^{\frac{n}{n}} \\
&=\lim _{n \rightarrow \infty} \frac{1}{n}\left(\mathrm{e}^{\frac{1}{n}}+\mathrm{e}^{\frac{2}{n}}+\mathrm{e}^{\frac{3}{n}}+\cdots+\mathrm{e}^{\frac{n}{n}}\right) \\
&=\lim _{n \rightarrow \infty} \frac{1}{n} \frac{\mathrm{e}^{\frac{1}{n}}\left[1-\left(\mathrm{e}^{\frac{1}{n}}\right)^{n}\right]}{1-\mathrm{e}^{\frac{1}{n}}}=\mathrm{e}-1
\end{aligned}</script><p>微积分最为核心的公式 —— <strong><font color="red">牛顿-莱布尼茨公式</font></strong>：</p>
<script type="math/tex; mode=display">
\int_a^b f(x) \text{d}x = F(b) - F(a)</script><p>其中函数$F(x)$与函数$f(x)$之间存在关系：$f(x) = F’(x)$，则称函数$F(x)$为函数$f(x)$的“原函数”，记<br>为$\int f(x) \text{d}x = F(x)$，求函数$f(x)$的不定积分就是求函数的原函数$F(x)$。</p>
<h4 id="4-2-常见函数积分"><a href="#4-2-常见函数积分" class="headerlink" title="4.2 常见函数积分"></a>4.2 常见函数积分</h4><script type="math/tex; mode=display">
\begin{array}{ll}
\int k \mathrm{~d} x=k x+C & \int \cos x \mathrm{~d} x=\sin x+C \\
\int x^{a} \mathrm{~d} x=\frac{x^{a+1}}{a+1}+C & \int \sin x \mathrm{~d} x=-\cos x+C \\
\int \frac{1}{x} \mathrm{~d} x=\ln |x|+C & \int \frac{1}{\cos ^{2} x} \mathrm{~d} x=\int \sec ^{2} x \mathrm{~d} x=\tan x+C \\
\int \frac{1}{1+x^{2}} \mathrm{~d} x=\arctan x+C & \int \frac{1}{\sin ^{2} x} \mathrm{~d} x=\int \csc ^{2} x \mathrm{~d} x=-\cot x+C \\
\int \frac{1}{\sqrt{1-x^{2}}} \mathrm{~d} x=\arcsin x+C & \int \mathrm{e}^{x} \mathrm{~d} x=\mathrm{e}^{x}+C \\
& \int a^{x} \mathrm{~d} x=\frac{a^{x}}{\ln a}+C
\end{array}</script><p>需要注意的是，求不定积分一定要在表达式结尾“$+C$”，因为同一个函数的原函数不仅有一个，它们之间相差一个常数。</p>
<h4 id="4-3-积分运算法则"><a href="#4-3-积分运算法则" class="headerlink" title="4.3 积分运算法则"></a>4.3 积分运算法则</h4><script type="math/tex; mode=display">
\int[f(x) \pm g(x)]\text{d}x = \int f(x)\text{d}x \pm \int  g(x)\text{d}x</script><script type="math/tex; mode=display">
\int kf(x) \text{d}x = k\int f(x)\text{d}x</script><h4 id="4-4-常见求积分类型"><a href="#4-4-常见求积分类型" class="headerlink" title="4.4 常见求积分类型"></a>4.4 常见求积分类型</h4><h5 id="4-4-1-积分的线性变换"><a href="#4-4-1-积分的线性变换" class="headerlink" title="4.4.1 积分的线性变换"></a>4.4.1 积分的线性变换</h5><p>被积函数是$(ax+b)$的形式时，可以采用令$(ax+b=t)$的形式，将其换成简单的函数形式。</p>
<h5 id="4-4-2-凑微分法：要求熟练掌握各类导数"><a href="#4-4-2-凑微分法：要求熟练掌握各类导数" class="headerlink" title="4.4.2 凑微分法：要求熟练掌握各类导数"></a>4.4.2 凑微分法：要求熟练掌握各类导数</h5><p>三角积分函数中的凑微分法小技巧，若积分式$R(\sin x, \cos x)$存在下列条件：</p>
<ul>
<li>$R(-\sin x, \cos x) = -R(\sin x, \cos x)$，则要凑$\sin x\text{d}x = -\text{d} \cos x$</li>
<li>$R(\sin x, -\cos x) = -R(\sin x, \cos x)$，则要凑$\cos x\text{d}x = \text{d} \sin x$</li>
<li>$R(-\sin x, -\cos x) = R(\sin x, \cos x)$，则要凑$\sec^2 x\text{d}x = \text{d} \tan x$</li>
</ul>
<h5 id="4-4-3-根式-三角变换"><a href="#4-4-3-根式-三角变换" class="headerlink" title="4.4.3 根式/三角变换"></a>4.4.3 根式/三角变换</h5><p><strong>换元目标：消除根号。</strong></p>
<ul>
<li>第一类：根号内为$x$的一次多项式$\sqrt{ax+b}$，令$\sqrt{ax+b} = t$；</li>
<li>第二类：根号内为$x$的二次多项式：</li>
</ul>
<center><img src="https://pic.imgdb.cn/item/648c18901ddac507cc3b69cf.jpg"></center>

<h5 id="4-4-4-分部积分法"><a href="#4-4-4-分部积分法" class="headerlink" title="4.4.4 分部积分法"></a>4.4.4 分部积分法</h5><p>引入例题：求下面图示阴影区域的面积：</p>
<center><img src="https://pic.imgdb.cn/item/648c19131ddac507cc3d0c80.jpg" style="zoom:30%"></center>

<p>由于$y = \ln x, x = e^y$，所以面积有：</p>
<script type="math/tex; mode=display">
\int_{\frac{1}{2}}^2 x \text{d}y = \int_{\frac{1}{2}}^2 e^y \text{d}y = e^2 - e^{\frac{1}{2}}</script><p>由此可以推导得到分部积分的原理与公式：</p>
<script type="math/tex; mode=display">
\int u \cdot v' \text{d}x = \int u \text{d}v = uv - \int v \text{d}u = uv - \int v u' \text{d}x</script><center><img src="https://pic.imgdb.cn/item/648c19551ddac507cc3de466.png"></center>

<p>被积函数为两种不同类型函数相乘时，一般用分部积分法。<br>记住<strong>口诀</strong>：反对幂指三(反三角函数、对数函数、幂函数、指数函数、三角函数)。<br>口诀中，越是靠后类型的函数，越优先与“$\text{d}x$”结合。</p>
<h5 id="4-4-5-变限积分"><a href="#4-4-5-变限积分" class="headerlink" title="4.4.5 变限积分"></a>4.4.5 变限积分</h5><p>对于变上限积分函数，我们常用到的是它的导数：</p>
<script type="math/tex; mode=display">
(\int_0^x f(t) \text{d}t)' = f(x)</script><p>而这种题目有相应的变体，我们也需要掌握：</p>
<ul>
<li>$(\int_0^{g(x)} f(t) \text{d}t)’ = f(g(x)) \cdot g’(x)$，变化的上限是$g(x)$，利用复合函数求导；</li>
<li>$(\int_{a(x)}^{b(x)} f(t) \text{d}t)’ = (\int_{0}^{b(x)} f(t) \text{d}t - \int_{0}^{a(x)} f(t) \text{d}t)’$，上下限中均含有变量；</li>
<li>$(\int_{0}^{x} x f(t) \mathrm{d} t)^{\prime}=(x \int_{0}^{x} f(t) \mathrm{d} t)^{\prime}=x f(x)+\int_{0}^{x} f(t) \mathrm{d} t$，被积表达式中有可提取的$x$；</li>
<li>$(\int_{0}^{x} f(x t) \mathrm{d} t)^{\prime}=(\int_{0}^{x^{2}} \frac{f(u)}{x} \mathrm{~d} u)^{\prime}=(\frac{1}{x} \int_{0}^{x^{2}} f(u) \mathrm{d} u)$，被积函数中$x$和$t$结合。</li>
</ul>
<h4 id="4-5-定积分运算"><a href="#4-5-定积分运算" class="headerlink" title="4.5 定积分运算"></a>4.5 定积分运算</h4><p>定积分与不定积分类似，也需要求函数的原函数。但是不同的是定积分指定了上、下限，在求得原函数后需要代入、作差，例如$\int_{a}^{b} f(x) \text{d}x = F(b) - F(a) $。</p>
<p>相比于不定积分，定积分还需要格外注意在引用新字母进行换元方法时，<strong>上下限也需要更换</strong>。</p>
<h3 id="5-中值定理"><a href="#5-中值定理" class="headerlink" title="5 中值定理"></a>5 中值定理</h3><center><img src="https://pic.imgdb.cn/item/648c19721ddac507cc3e4672.png"></center>

<h4 id="5-1-罗尔中值定理证明等式"><a href="#5-1-罗尔中值定理证明等式" class="headerlink" title="5.1 罗尔中值定理证明等式"></a>5.1 罗尔中值定理证明等式</h4><p>从图像上理解罗尔/拉格朗日中值定理：</p>
<center><img src="https://pic.imgdb.cn/item/648c19c31ddac507cc3f3722.png"></center>

<p><strong>第一步</strong>：将需要证明的等式中的“$\xi$”换为“x”，将右侧项移至左侧，设左侧的内容为$g(x)$，则原题需要证明的结论转化为：需要证明$g(x) = 0$在$(0,a)$内有实根；<br><strong>第二步</strong>：需要构造辅助函数$G(x)$，满足$G’(x) = g(x)$，或者$G’(x)$中含有$g(x)$；<br><strong>第三步</strong>：结合题目给出的其他条件，在区间$[0, a]$上找到两点，使辅助函数$G(x)$在这两点处函数值相等，结合罗尔定理，证明结论。</p>
<p>此类题目的难点无非两点：构造辅助函数，证明两处值相等。</p>
<h4 id="5-2-数列极限"><a href="#5-2-数列极限" class="headerlink" title="5.2 数列极限"></a>5.2 数列极限</h4><h5 id="5-2-1-直接化简法"><a href="#5-2-1-直接化简法" class="headerlink" title="5.2.1 直接化简法"></a>5.2.1 直接化简法</h5><h5 id="5-2-2-利用夹逼准则-缩放"><a href="#5-2-2-利用夹逼准则-缩放" class="headerlink" title="5.2.2 利用夹逼准则(缩放)"></a>5.2.2 利用夹逼准则(缩放)</h5><h5 id="5-2-3-转化为定积分"><a href="#5-2-3-转化为定积分" class="headerlink" title="5.2.3 转化为定积分"></a>5.2.3 转化为定积分</h5><p>导数dy/dx理解(除法？)<br>泰勒展开<br>高阶无穷小削去</p>
<hr>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>课程链接1：<a href="https://www.bilibili.com/video/BV1j44y1E7ot">【高等数学（上）】6小时从0基础直追满绩！- 李天意 - bilibili</a></p>
<p>课程链接2：<a href="https://www.bilibili.com/video/BV1ZK4y1u7WU">【高等数学（下）】概念理解+解题方法 7小时 精讲速学！- 李天意 - bilibili</a></p>
<p>PDF资料链接：<a href="https://pan.baidu.com/s/1ZD6Qj9R0VycOF4S0SMYY1w">https://pan.baidu.com/s/1ZD6Qj9R0VycOF4S0SMYY1w</a> 提取码：gb6s</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>数学基础</category>
        <category>高等数学</category>
      </categories>
      <tags>
        <tag>高数</tag>
        <tag>本质问题</tag>
      </tags>
  </entry>
  <entry>
    <title>概率基础概念本质的辨析理解</title>
    <url>/2022/01/24/Basic-concept-of-probability/</url>
    <content><![CDATA[<h3 id="〇、如何学好概率论与数理统计"><a href="#〇、如何学好概率论与数理统计" class="headerlink" title="〇、如何学好概率论与数理统计"></a>〇、如何学好概率论与数理统计</h3><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h4><p>参考链接0.1：<a href="http://www.hanhai.org/xuexijiaoliu/26.htm">如何学好概率论与数理统计 - 邹群 - 浙大个人博客</a></p>
<p>参考链接0.2：<a href="https://www.zhihu.com/question/36833473/answer/862307409">怎样学习大学概率论与数理统计？ - 石溪的回答 - 知乎</a></p>
<h3 id="一、什么是概率"><a href="#一、什么是概率" class="headerlink" title="一、什么是概率"></a>一、什么是概率</h3><p><strong><font color="red">用两个字来表述概率的本质——函数</font></strong></p>
<p><strong><font color="red">用四个字来表述概率的本质——集合函数，集合到$[0, 1]$区间的映射</font></strong></p>
<h4 id="1-概率公理化定义"><a href="#1-概率公理化定义" class="headerlink" title="1. 概率公理化定义"></a>1. 概率公理化定义</h4><p>定义在事件域$ \mathscr{F} $上的集合函数$P$称为概率，它需要满足下面这三个要求：</p>
<p>​    (1) 非负性：$P(A) \geq 0, ~ \forall A \subset   \mathscr{F}$</p>
<p>​    (2) 规范性/正则性：$P(\Omega) = 1$</p>
<p>​    (3) 可列可加性：若$ A_i \subset  \mathscr{F}, ~ i = 1,2,…$，且两两互不相容，则</p>
<script type="math/tex; mode=display">
P(\sum_{i=1}^{\infty}A_i) = \sum_{i=1}^{\infty}P(A_i)</script><p>​        或者写作</p>
<script type="math/tex; mode=display">
P(\mathop{\bigcup}\limits_{i=1}^{\infty}A_i) = \sum_{i=1}^{\infty}P(A_i)</script><h4 id="2-名词解释"><a href="#2-名词解释" class="headerlink" title="2. 名词解释"></a>2. 名词解释</h4><h5 id="2-1-样本空间"><a href="#2-1-样本空间" class="headerlink" title="2.1 样本空间"></a>2.1 样本空间</h5><p>$\Omega = $ { $  \omega_1, \omega_2,…, \omega_n $ }，其中$\omega_n$称为样本点，比如掷硬币则$\Omega =$ { $  “正面”, “反面” $}，掷骰子则$\Omega =${ $  “1点”, “2点”, “3点”, “4点”, “5点”, “6点” $} </p>
<h5 id="2-2-事件"><a href="#2-2-事件" class="headerlink" title="2.2 事件"></a>2.2 事件</h5><p>样本点的某个集合，比如掷骰子中{$1$}、{$2$} 或者{$2, 3, 5$}等所有可能的组合，事件可以看成$\Omega$的某个子集。</p>
<p>根据以上，我们可以称$\Omega$为必然事件，$\varnothing $是不可能事件。</p>
<h5 id="2-3-事件域"><a href="#2-3-事件域" class="headerlink" title="2.3 事件域"></a>2.3 事件域</h5><p>为了方便展示例子，我们这里将掷骰子的正六面体改为正四面体，也就是此时$\Omega =$ { $1, 2, 3, 4 $}，此时它所有的子集(可能的事件)为：</p>
<center>$A_1 = \varnothing$, $ A_2 = $ { $1$ }, $A_3 = $ { $2$ }, $A_4 = $ {$3$}, $A_5 =$ {$4$}, $ A_6 = ${$1, 2$}</center>

<center>$A_7 = ${$1, 3$}, $A_8 = ${$1,4$}, $ A_9 = ${$2, 3$}, $A _ {10} =$ {$2, 4$}, $A _ {11} =$ {$3, 4$}</center>

<center>$A _ {12} = ${$1, 2, 3$}, $A _ {13} = ${$1, 2, 4$}, $A _ {14} = ${$2, 3, 4$}, $A _ {15} = ${$1, 3, 4$}, $ A _ {16} = \Omega = ${$1, 2, 3 ,4$} </center>

<p>事件域就是<script type="math/tex">\mathscr{F} = \begin{Bmatrix} A_1, A_2, ..., A _ {16} \end{Bmatrix}</script>是由样本空间<script type="math/tex">\Omega</script>的一些子集构成的一个<script type="math/tex">\sigma</script>域。<script type="math/tex">\mathscr{F}</script>中的元素被称为事件。</p>
<h5 id="2-4-σ域"><a href="#2-4-σ域" class="headerlink" title="2.4 σ域"></a>2.4 σ域</h5><p>事件域$\mathscr{F}$必须是$\sigma$域，那么什么样的$\mathscr{F}$在$\sigma$域中呢：</p>
<ul>
<li>(1) <script type="math/tex">\Omega \subset \mathscr{F}</script>；</li>
<li>(2) 若<script type="math/tex">A \subset \mathscr{F}</script>，则<script type="math/tex">\bar A \in \mathscr{F}</script>；</li>
<li>(3) 若<script type="math/tex">A_i \subset \mathscr{F},(i = 1,2,...)</script> ，则<script type="math/tex">\mathop{\bigcup}\limits_{i=1}^{\infty}A_i \subset \mathscr{F}</script>。</li>
</ul>
<p>由上面3条我们可以进一步推导得到：</p>
<p>​    1° <script type="math/tex">\varnothing \subset \mathscr{F}</script></p>
<p>​    2° 交集属于事件域——<script type="math/tex">\mathop{\bigcap}\limits_{i=1}^{\infty}A_i = \overline {\mathop{\bigcup}\limits_{i = 1}^{\infty}\bar{A_i}}</script></p>
<p>​    3° 有限并属于事件域</p>
<p>​    4° 有限交属于事件域</p>
<p>例如<script type="math/tex">\mathscr{F}_1 = \begin{Bmatrix} A_1, A_2, ..., A _ {16} \end{Bmatrix}</script>，<script type="math/tex">\mathscr{F}_2 = \begin{Bmatrix} A_1, A _ {16}, A_2, A _ {14} \end{Bmatrix}</script>，<script type="math/tex">\mathscr{F}_3 = \begin{Bmatrix} A_1,  A _ {16} \end{Bmatrix}</script>等都是事件域(都满足上面3条)，其中<script type="math/tex">\mathscr{F}_3</script>是最简单的事件域(一个事件域最少由空集和样本空间这两个集合组成)，又称平凡事件域。</p>
<h5 id="2-5-事件域和样本空间辨析"><a href="#2-5-事件域和样本空间辨析" class="headerlink" title="2.5 事件域和样本空间辨析"></a>2.5 事件域和样本空间辨析</h5><p><strong>事件域是样本空间幂集的子集。也就是说，事件域中的每个元素是样本空间的一个子集。</strong>例如，掷骰子，样本空间取<script type="math/tex">A = \begin{Bmatrix}1,2,3,4,5,6 \end{Bmatrix}</script>，事件域可以取上述集合的全部子集，即$F=2^A$。此时F中的元素称为事件。例如，“掷出偶数”指的是F中的{2,4,6}这一元素。顺便一提：</p>
<p><strong><font color="red">概率本质是定义在事件域上的函数，而随机变量本质是定义在样本空间上的函数。</font></strong> </p>
<h4 id="3-重新梳理逻辑"><a href="#3-重新梳理逻辑" class="headerlink" title="3. 重新梳理逻辑"></a>3. 重新梳理逻辑</h4><p>上面我们先是给出了定义，再进一步解释的定义中各部分的意义，有点”由果寻因“的意味，逻辑上逆推。现在我们简单通过逻辑正推梳理一下：</p>
<p>样本点 { $\omega_1, \omega_2,…, \omega_n$}   $\Rightarrow$   样本空间$\Omega =$ {$ \omega_1, \omega_2,…, \omega_n $ }   $\Rightarrow$   某个事件$A_i =$ { $\omega_1, \omega_2$ }, $(A \subset \Omega)$   $\Rightarrow$   事件域$\mathscr{F} =$ { $A_1,A_2,…$}(事件域里面的事件$A_i$不是随意的，必须满足$\sigma$域条件)，那么概率就是一个函数，将事件域映射到$[0,1]$，计算概率的示例如下：</p>
<p>对于之前的<script type="math/tex">\mathscr{F}_1</script>，有：<script type="math/tex">P(A_1) = 0, P(A_2) = \frac{1}{4}, P(A _ {10}) = \frac{1}{2}</script></p>
<p>对于之前的<script type="math/tex">\mathscr{F}_2</script>，有：<script type="math/tex">P(A_1) = 0, P(A _ {16}) = 1, P(A_2) = \frac{1}{4}, P(A _ {14}) = \frac{1}{4}</script></p>
<p>对于之前的<script type="math/tex">\mathscr{F}_3</script>，有：<script type="math/tex">P(A_1) = 0, P(A _ {16}) = 1</script></p>
<h4 id="参考链接：-1"><a href="#参考链接：-1" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h4><p>参考链接1.1：<a href="https://www.bilibili.com/video/BV1fE411M7ra">到底什么是概率？- 概率统计小迷哥 - 哔哩哔哩</a>  </p>
<p>参考链接1.2：<a href="https://zhuanlan.zhihu.com/p/58995841">什么是概率？ - 马同学的文章 - 知乎</a></p>
<p>参考链接1.3：<a href="https://blog.csdn.net/zhoujunr1/article/details/77466826?spm=1001.2101.3001.6650.18&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-18.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-18.pc_relevant_aa&amp;utm_relevant_index=21">sigma代数、Borel 集、测度概念borel集 - zhoujunr1的博客 - CSDN</a> </p>
<p>参考链接1.4：<a href="https://blog.csdn.net/kac0c440/article/details/54928122?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EHighlightScore-2.queryctrv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EHighlightScore-2.queryctrv2&amp;utm_relevant_index=4">【初等概率论】 01 - kac0c440的专栏 - CSDN</a> </p>
<p>参考链接1.5：<a href="https://zhuanlan.zhihu.com/p/61729415">概率论复习笔记(3)——概率的公理化定义 - Fiddie的文章 - 知乎</a></p>
<p>参考链接1.6：<a href="https://www.enmsb.com/article/%E4%BA%8B%E4%BB%B6%E5%9F%9F%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%A9%BA%E9%97%B4.html">事件域和样本空间有什么区别？- 恩牛网</a> </p>
<h3 id="二、什么是随机变量"><a href="#二、什么是随机变量" class="headerlink" title="二、什么是随机变量"></a>二、什么是随机变量</h3><h4 id="1-随机变量的本质"><a href="#1-随机变量的本质" class="headerlink" title="1. 随机变量的本质"></a>1. 随机变量的本质</h4><p><strong><font color="red">随机变量的本质是函数——样本点的函数</font></strong></p>
<p>定义：设$X(w)$是定义在概率空间$(\Omega, \mathscr{F}, P)$上的单值实函数(也就是说它的自变量就是一个个的样本点，因变量是实函数)，如果对直线上任意一博雷尔点集$B$，有$\begin{Bmatrix} \omega, X(\omega) \in B \end{Bmatrix} \subset \mathscr{F}$则称$X(\omega)$为随机变量(r.v.)。</p>
<blockquote>
<p>思考题目(某年北京考研题目)：</p>
<p>已知：$\Omega =$ { $\omega_1, \omega_2, \omega_3$ }, $P(\omega_1) = \frac{1}{3}, P(\omega_2) = \frac{1}{6}, P(\omega_3) = \frac{1}{2},  X(\omega_1) = 2, X(\omega_2) = X(\omega_3) = 0$</p>
<p>求：(1) $X$的分布；(2) 已知$E[Y] = 2$，$P(Y=X|X&gt;0) = 1,P(Y = X|X = 0)=\frac{3}{4}$，求$Y$的概率分布。</p>
<p>答案参考链接[2-1]</p>
</blockquote>
<h4 id="2-多维随机变量的本质"><a href="#2-多维随机变量的本质" class="headerlink" title="2. 多维随机变量的本质"></a>2. 多维随机变量的本质</h4><p><strong><font color="red">多维随机变量的本质是参数方程</font></strong></p>
<p>二维随机变量定义：设$E$是一个随机试验，它的样本空间是$\Omega$，设$X=X(e)$和$Y=Y(e)$是定义在$\Omega$上的随机变量，由它们构成的一个向量$(X, Y)$，叫做二维随机变量。</p>
<p>多为随机变量定义：一般，设$E$是一个随机试验，它的样本空间是$\Omega = $ {$e$}，设$X_1=X_1(e),…,X_n=X_n(e)$是定义在$\Omega$上的随机变量，由它们构成的一个$n$维向量$(X_1,X_2,…,X_n)$叫做$n$维随机向量或$n$维随机变量 </p>
<p><strong>特别要主要两个随机变量的自变量是来自一个样本空间。</strong></p>
<p>例子：假设要了解一下学生的身体指标，这个班里有3个人，我们做一次实验，随机抽出一个人测一下身高$X$，体重$Y$。则我们想一下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>张三</th>
<th>李四</th>
<th>王五</th>
</tr>
</thead>
<tbody>
<tr>
<td>身高</td>
<td>180</td>
<td>175</td>
<td>168</td>
</tr>
<tr>
<td>体重</td>
<td>71</td>
<td>65</td>
<td>60</td>
</tr>
</tbody>
</table>
</div>
<p>二维随机变量$(X,Y)$的样本空间是$\Omega$等于什么，这时如果我们回答$X$的样本空间是{$180, 175, 168$}，$Y$的样本空间是{$71, 65, 60$}就错了，时刻要记得多维随机变量的自变量是来自一个样本空间，所以正确的结果是：</p>
<center>$\Omega =$ {$"抽到张三", "抽到李四", "抽到王五"$}</center>

<h4 id="3-随机变量的大小写表示"><a href="#3-随机变量的大小写表示" class="headerlink" title="3. 随机变量的大小写表示"></a>3. 随机变量的大小写表示</h4><p>大写字母表示随机变量，是概率论里面特有的变量，如$X, Y, Z, …$，但这其实是随机变量的简化形式，实际完整的形式如上文提及应该是$X(\omega), Y(\omega), Z(\omega)$，当拓展到$N$维随机变量时，一般使用$X_1, X_2,…,X_n$。</p>
<p>小写的表示函数的自变量，与高等数学里面的函数自变量意义相同。 在概率论里可以代指随机变量的具体取值，例如：$X(\omega) = x$。</p>
<p>表示随机变量之间的关系时，应该用大写，表示随机变量具体的分布函数或者概率密度时，应该用小写。 </p>
<blockquote>
<p><strong>我的疑问——对于多维随机变量定义的理解还不是很清楚：</strong></p>
<p>第一种情况：例如上面表格的情况，我们做一次随机实验$E$，抽出一名同学，则根据人的两个属性/指标可以得到二位随机变量：$X$—身高(属性)，$Y$—体重(属性)，这种情况我明白是正确的。</p>
<p>第二种情况：再例如我们测量某一电路的电流，我们测量了$N$次(相当于做了$N$次实验)，那么$N$次实验的随机变量是否可以组合起来变成$N$维随机变量呢？也就是$(X_1, X_2,…,X_n)$是否可以算是$N$维随机变量吗？？？</p>
</blockquote>
<h4 id="参考链接：-2"><a href="#参考链接：-2" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h4><p>参考链接2.1：<a href="https://www.bilibili.com/video/BV1AE411u7Et">什么是随机变量？- 概率统计小迷哥 - 哔哩哔哩</a>  </p>
<p>参考链接2.2：<a href="https://www.bilibili.com/video/BV1KJ411C7Pa">随机变量究竟是什么 - 数学救火队长马丁 - 哔哩哔哩</a></p>
<p>参考链接2.3：<a href="https://www.bilibili.com/video/BV1rJ411C7rJ">多维随机变量究竟是什么 - 数学救火队长马丁 - 哔哩哔哩</a> </p>
<p>参考链接2.4：<a href="https://zhuanlan.zhihu.com/p/47113623">随机变量和随机过程的个人理解 - UPPER的文章 - 知乎</a></p>
<p>参考链接2.5：<a href="https://zhidao.baidu.com/question/501709573263510124.html">概率统计中，小x和大X有什么区别 - 百度知道</a> </p>
<p>参考链接2.6：<a href="https://www.zhihu.com/question/404719167/answer/1344528800">请问在概率论中的随机变量X，与统计学中总体随机变量X，极其样本X_1，X_2，X_3有怎么样的关系？ - 顾念一人的回答 - 知乎</a></p>
<h3 id="三、概率函数P-x-、概率分布函数F-x-、概率密度函数f-x"><a href="#三、概率函数P-x-、概率分布函数F-x-、概率密度函数f-x" class="headerlink" title="三、概率函数P(x)、概率分布函数F(x)、概率密度函数f(x)"></a>三、概率函数P(x)、概率分布函数F(x)、概率密度函数f(x)</h3><h4 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h4><p>进入主题前，先明确几个概念：<br><strong>离散型变量（或取值个数有限的变量）</strong>：取值可一一列举，且总数是确定的，如投骰子出现的点数（1点、2点、3点、4点、5点、6点）。<br><strong>连续型变量（或取值个数无限的变量）</strong>：取值无法一一列举，且总数是不确定的，如所有的自然数（0、1、2、3……）。</p>
<p><strong>离散型变量取某个值$x_i$的概率$P(x_i)$是个确定的值（虽然很多时候我们不知道这个值是多少），即$P(x_i)≠0$</strong>：例如，投一次骰子出现2点的概率是$P(2)=\dfrac{1}{6}$。</p>
<p><strong><font color="red">连续型变量取某个值$x_i$的概率$P(x_i)=0$</font></strong>：对于连续型变量而言，<strong><font color="blue">“取某个具体值的概率”的说法是无意义的</font>，因为取任何单个值的概率都等于0</strong>，只能说<strong>“取值落在某个区间内的概率”</strong>，或<strong>“取值落在某个值邻域内的概率”</strong>，即<strong>只能说$P(a&lt;xi≤b)$，而不能说$P(x_i)$。</strong>  为什么是这样？且看下例：</p>
<ul>
<li>例如，从所有自然数中任取一个数，问这个数等于5的概率是多少？从所有的自然数中取一个，当然是有可能取到5的，但是自然数有无穷多个，因此取到5的概率是$\dfrac{1}{\infty}$，也就是0。</li>
<li>又如扔飞镖，虽然是有可能落在靶心的，但其概率也是0（不考虑熟练程度等其他因素），因为靶盘上有无数个点，每个点的概率是一样的，因此落在某一个具体的点上的概率为$\dfrac{1}{\infty} = 0$。</li>
</ul>
<p>根据前面的例子可知：<strong><font color="red">在连续型变量中：概率为0的事件是有可能发生的，概率为1的事件不一定必然发生。</font> </strong></p>
<h4 id="2-概率分布和概率函数P-X"><a href="#2-概率分布和概率函数P-X" class="headerlink" title="2. 概率分布和概率函数P(X)"></a>2. 概率分布和概率函数P(X)</h4><p><strong>概率分布</strong>：给出了所有取值及其对应的概率（少一个也不行），<strong>只对离散型变量有意义</strong>。例如： </p>
<p><img src="https://pic.imgdb.cn/item/621457fd2ab3f51d913ee894.jpg" style="zoom:40%"></p>
<p><strong>概率函数</strong>：用函数形式给出每个取值发生的概率，<script type="math/tex">P(x)(x = x_1, x_2, x_3, \cdots)</script>，<strong>只对离散型变量有意义</strong>，实际上是对概率分布的数学描述。</p>
<p><strong>概率分布和概率函数只对离散型变量有意义，那如何描述连续型变量呢？</strong></p>
<p>答案就是<strong><font color="red">“概率分布函数F(x)”和“概率密度函数f(x)”</font></strong>， 当然这两者也是可以描述离散型变量的。</p>
<h4 id="3-概率分布函数F-X-与概率密度函数f-x"><a href="#3-概率分布函数F-X-与概率密度函数f-x" class="headerlink" title="3. 概率分布函数F(X)与概率密度函数f(x)"></a>3. 概率分布函数F(X)与概率密度函数f(x)</h4><p>1、<strong>概率分布函数$F(x)$：给出取值小于某个值的概率，是概率的累加形式</strong>，即：</p>
<script type="math/tex; mode=display">
F(x_i)=P(x<x_i)= \sum(P(x_1),P(x_2), \cdots ,P(x_i))</script><p>对于离散型变量是求和，对于连续型变量是求积分，见后图。</p>
<p>2、<strong>概率分布函数F(x)的性质</strong></p>
<ul>
<li>单调非减性：$\forall a&lt;b$，总有$F(a) \leq F(b)$；</li>
<li>$F(x)$是一个右连续函数；</li>
<li>有界性：<script type="math/tex">\forall x \in \rm R</script>，总有<script type="math/tex">0 \leq F(x) \leq 1</script>，且<script type="math/tex">\lim\limits_{x \to -\infty} F(x) = 0, \lim\limits_{x \to \infty} F(x) = 1</script>；</li>
</ul>
<p>3、<strong>概率分布函数$F(x)$的作用</strong></p>
<p> （1）<strong>给出$x$落在某区间$(a,b]$内的概率</strong>：$P(a&lt;x≤b)=F(b)-F(a)$</p>
<p>（2）<strong>根据$F(x)$的斜率判断“区间概率”$P(A&lt;x≤B)$的变化（实际上就是后面要说的概率密度函数$f(x)$）（特别注意：是判断“区间概率”，即$x$落在$(A,B]$中的概率，而不是$x$取某个确定值的概率，这是连续型变量和离散型变量的本质区别）</strong></p>
<p>   <strong>某区间$(A,B]$内，$F(x)$越倾斜，表示$x$落在该区间内的概率$P(A&lt;x≤B)$ 越大</strong>。如图中$(a,b]$区间内$F(x)$的斜率最大，如果将整个取值区间以$δ_x=b-a$的间隔等距分开，则$x$落在$(a,b]$内的概率最大。这是因为：</p>
<script type="math/tex; mode=display">
P(A<x≤B) )=F(B)-F(A)</script><p>所有区间中只有在$(a,b]$这个区间上（即$A=a$，$B=b$）$F(B)-F(A)$达到最大值，也就是图中竖向红色线段最长。</p>
<p><img src="https://pic.imgdb.cn/item/62148eb52ab3f51d91b44170.jpg" style="zoom:40%"></p>
<p>4、<strong>概率密度函数$f(x)$</strong></p>
<p>给出了变量落在某值$x_i$邻域内（或者某个区间内）的<strong><font color="red">概率变化快慢，概率密度函数的值不是概率，而是概率的变化率，概率密度函数下面的面积才是概率</font></strong>。   </p>
<p>定义1：若存在非负可积函数$f(x)$，使随机变量X取值于任一区间$(a,b]$的概率可表示成</p>
<script type="math/tex; mode=display">
P(a \leq X \leq b) = \int_a^b f(x)dx</script><p>则称X为连续型随机变量，$f(x)$为X的概率密度函数，简称概率密度或密度。</p>
<p> 5、概率分布函数和概率密度函数之间的关系</p>
<script type="math/tex; mode=display">
F(x) = \int_{-\infty}^{x}f(t)dt \\
f(x) = \frac{d}{dx}F(x)</script><blockquote>
<p>注意：概率密度函数$f(x)$在点a处取值，不是事件${X=a}$的概率。但是，该值越大，$X$在$a$点附近取值的概率越大。</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/62148ee92ab3f51d91b4c173.jpg" style="zoom:50%"></p>
<p><strong>连续型变量的概率、概率分布函数、概率密度函数之间的关系（以正态分布为例）</strong></p>
<p>如下图：<strong>对于正态分布而言，$x$落在$u$附近的概率最大，而$F(x)$是概率的累加和，因此在$u$附近$F(x)$的递增变化最快，即$F(x)$曲线在$(u，F(u))$这一点的切线的斜率最大，这个斜率就等于$f(u)$。</strong>$x$落在$a$和$b$之间的概率为$F(b)-F(a)$（图中的红色小线段），而在概率密度曲线中则是$f(x)$与$ab$围成的面积$S$。如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/62148f2e2ab3f51d91b58251.jpg" style="zoom:60%"></p>
<h4 id="4-概率密度函数在某点-a-的值-f-a-的物理意义到底是什么？"><a href="#4-概率密度函数在某点-a-的值-f-a-的物理意义到底是什么？" class="headerlink" title="4. 概率密度函数在某点$a$的值$f(a)$的物理意义到底是什么？"></a>4. 概率密度函数在某点$a$的值$f(a)$的物理意义到底是什么？</h4><p><strong>我们知道$f(a)$表示，概率分布函数$F(x)$在$a$点的变化率(或导数)；其物理意义实际上就是$x$落在$a$点附近的无穷小邻域内的概率，但不是落在$a$点的概率（前已述及，连续变量单点概率=0），用数学语言描述就是：</strong></p>
<script type="math/tex; mode=display">
f(a) = F'(a) = \lim_{\delta x >0 且\delta x \to 0} P(a-\delta x < x \leq a+\delta x) ≠ P(a)</script><h4 id="参考链接：-3"><a href="#参考链接：-3" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h4><p>参考链接3.1：<a href="https://www.zhihu.com/question/25367654">概率分布就很好，为什么还要提出概率密度的概念？ - 知乎</a></p>
<p>参考链接3.2：<a href="https://zhuanlan.zhihu.com/p/413360980">概率基础：概率密度函数并不是概率 - coasxu的文章 - 知乎</a></p>
<p>参考链接3.3：<a href="https://www.zhihu.com/question/23237834">概率密度函数在某一点的值有什么意义？ - 知乎</a></p>
<p>参考链接3.4：<a href="https://www.zhihu.com/question/263467674">如何通俗的理解概率密度函数？ - 知乎</a></p>
<p>参考链接3.5：<a href="https://www.jianshu.com/p/0cfc3204af77">概率函数P(x)、概率分布函数F(x)、概率密度函数f(x)</a></p>
<p>参考链接3.6：<a href="https://zhuanlan.zhihu.com/p/119453101">一文读懂什么是联合概率，条件概率，贝叶斯 - 知乎</a></p>
<p>参考链接3.7：<a href="https://blog.csdn.net/SIGAI_CSDN/article/details/83586458?utm_source=app&amp;app_version=5.0.0">理解概率密度函数 - CSDN</a></p>
<h3 id="四、概率中的矩的理解"><a href="#四、概率中的矩的理解" class="headerlink" title="四、概率中的矩的理解"></a>四、概率中的矩的理解</h3><h4 id="参考链接：-4"><a href="#参考链接：-4" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h4><p>参考链接4.1：<a href="https://www.zhihu.com/question/19915565">统计学中「矩」这个概念是怎么引入的？它为什么被称为矩？它与物理意义上的矩有什么相同与不同？ - 知乎</a></p>
<p>参考链接4.2：<a href="https://www.zhihu.com/question/23236070">概率论中「矩」（moment）的实际含义是什么，高阶矩表示数据的哪些状态？ - 知乎</a></p>
<p>参考链接4.3：<a href="https://zhuanlan.zhihu.com/p/57802400">概率论中的“矩”是什么意思 - Mr.看海的文章 - 知乎</a></p>
<p>参考链接4.4：<a href="https://zhuanlan.zhihu.com/p/78067348">矩（moment）、鞅（martingale）、似然（Likelihood）的「奇葩翻译」是怎么想的 - 范函子Skyline的文章 - 知乎</a></p>
<h3 id="五、随机变量的特征函数"><a href="#五、随机变量的特征函数" class="headerlink" title="五、随机变量的特征函数"></a>五、随机变量的特征函数</h3><h4 id="参考链接：-5"><a href="#参考链接：-5" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h4><p>参考链接5.1：<a href="https://blog.csdn.net/ccnt_2012/article/details/109776736">如何理解统计中的特征函数？- CSDN</a></p>
<p>参考链接5.2：<a href="https://blog.csdn.net/JaneandDaria/article/details/83722395">随机变量的特征函数 - CSDN</a></p>
<p>参考链接5.3：<a href="https://blog.csdn.net/The_Time_Runner/article/details/90107979">特征函数解释了世界的哪个环节？- CSDN</a></p>
<p>参考链接5.4：<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0_(%E6%A6%82%E7%8E%87%E8%AE%BA">特征函数 (概率论) - 维基百科</a>) </p>
<p>参考链接5.5：<a href="https://www.zhihu.com/question/23686709">如何理解统计中的特征函数？ - 知乎</a></p>
<p>参考链接5.6：<a href="http://zhidao.baidu.com/question/922864273710991979?sharesource=weibo">随机函数的“特征函数”，是什么意思 - 百度知道</a></p>
<p>参考链接5.7：<a href="https://zhuanlan.zhihu.com/p/358618882">随机变量的特征函数及应用 - Sunsnow的文章 - 知乎</a></p>
<hr>
<h3 id="总参考链接："><a href="#总参考链接：" class="headerlink" title="总参考链接："></a>总参考链接：</h3><p>参考链接1：<a href="https://zhangzhenhu.github.io/blog/glm/source/index.html">广义线性模型 - 张振虎 - 个人博客</a></p>
<p>参考链接2：<a href="https://codeantenna.com/a/T0ryFFnuIZ">概率论的基本概念 - CodeAntenna</a></p>
<p>参考链接3：<a href="http://www.360doc.com/content/18/0118/23/33209086_723218111.shtml">零基础概率论入门:基本概念</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>数学基础</category>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>概率基础</tag>
        <tag>概念辨析</tag>
      </tags>
  </entry>
  <entry>
    <title>编程软件基础知识——杂记</title>
    <url>/2022/04/26/Basic-knowledge-of-programming-software/</url>
    <content><![CDATA[<h3 id="1-电脑知识"><a href="#1-电脑知识" class="headerlink" title="1 电脑知识"></a>1 电脑知识</h3><h3 id="2-编程语言——编译型和解释型"><a href="#2-编程语言——编译型和解释型" class="headerlink" title="2 编程语言——编译型和解释型"></a>2 编程语言——编译型和解释型</h3><h4 id="2-1-编译型语言"><a href="#2-1-编译型语言" class="headerlink" title="2.1 编译型语言"></a>2.1 编译型语言</h4><p>C和C++这两种语言是编译型语言，编译型语言的特点是执行速度快，缺点是什么呢？编译型语言需要编译器处理，主要工作流程如下：</p>
<p><strong>源代码 (source code) → 预处理器 (preprocessor) → 编译器 (compiler) → 目标代码 (object code) → 链接器 (Linker) → 可执行程序 (executables)</strong></p>
<p>编译器调用预处理器进行相关处理，将源代码进行优化转换（包括清除注释、宏定义、包含文件和条件编译），然后，通过将经过预处理的源代码编译成目标代码（二进制机器语言），再通过调用链接器外加库文件（例如操作系统提供的API），从而形成可执行程序，让机器能够执行。在这个工作流程中，目标代码要和机器的CPU架构相匹配，库文件要和操作系统相匹配。如果想在不同CPU的机器或者系统上运行C语言的源代码，就需要针对不同的CPU架构和操作系统进行编译，这样才能够在机器上运行程序。所以，编译型语言的缺点我们就看到了，它不适合跨平台。而且，到这里大家应该能知道，为什么CPU一样，但是exe程序只能Windows中运行，而不能在Mac中运行了。 </p>
<p><img src="https://pic.imgdb.cn/item/6267dfd1239250f7c578ce42.png"></p>
<h4 id="2-2-解释型语言"><a href="#2-2-解释型语言" class="headerlink" title="2.2 解释型语言"></a>2.2 解释型语言</h4><p>解释型语言源代码无需预先编译成可执行程序，在程序执行时，解释器读取一句源代码之后，先进行词法分析和语法分析，再将源代码转换为解释器能够执行的中间代码（字节码），最后，由解释器将中间代码解释为可执行的机器指令。所以，编译型语言的可执行程序产生的是直接执行机器指令，而解释型语言的每一句源代码都要经过解释器解释为可以执行的机器指令，相比之下解释型语言的执行效率会低一些。 </p>
<p><img src="https://pic.imgdb.cn/item/6267e0ba239250f7c57ac7d8.png"></p>
<p>例如：Python程序运行时，先将源代码完整的进行转换，编译成更有效率的字节码，保存成后缀为“.pyc”的字节码文件，然后，翻译器再通过这个文件一句一句的翻译为机器语言去执行。 </p>
<p><img src="https://pic.imgdb.cn/item/6267e0e4239250f7c57b2434.png"></p>
<h5 id="2-2-1-JIT即时编译器（Just-In-Time-Compiler）"><a href="#2-2-1-JIT即时编译器（Just-In-Time-Compiler）" class="headerlink" title="2.2.1 JIT即时编译器（Just-In-Time Compiler）"></a>2.2.1 JIT即时编译器（Just-In-Time Compiler）</h5><p>无论是使用解释器进行解释执行，还是使用编译器进行编译后执行，最终源代码都需要被转换为对应平台的本地机器指令。那么，一些重复出现的代码，就可以将其编译为本地机器指令，重复使用，从而提高效率。这些重复出现的代码包括多次调用的方法和多次执行的循环体。 </p>
<p>JIT即时编译器比较典型的例子是在JVM（Java虚拟机）中。Java程序最初是通过解释器进行解释执行的，当Java虚拟机发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。JIT即时编译器会将这些“热点代码”编译成与本地机器相关的机器指令，进行各个层次的优化。 </p>
<p><img src="https://pic.imgdb.cn/item/6267e128239250f7c57bc2ab.png"></p>
<h3 id="3-操作系统、环境变量、服务器"><a href="#3-操作系统、环境变量、服务器" class="headerlink" title="3 操作系统、环境变量、服务器"></a>3 操作系统、环境变量、服务器</h3><h4 id="3-1-为什么你需要操作系统"><a href="#3-1-为什么你需要操作系统" class="headerlink" title="3.1 为什么你需要操作系统"></a>3.1 为什么你需要操作系统</h4><p>假设你是一个程序员, 你写了一个C程序，如下所示： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(%d, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你的程序经过编译大概变成了这样的CPU指令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始化a和b , mov指令把前一个操作数的值赋值给后一个操作数</span><br><span class="line">Mov 1, a</span><br><span class="line">Mov 2, b</span><br><span class="line"># %开头的是CPU寄存器, 你可能还记得它是最快最小的存储设备, 我们要把a和b从内存里拿出来, 放进寄存器里</span><br><span class="line"># 接下来Add指令才能工作 </span><br><span class="line">Mov a, %eax</span><br><span class="line">Mov b, %ecx</span><br><span class="line"># 加两个寄存器的值, 和写入后一个寄存器中, 在这里是写入eax寄存器</span><br><span class="line">Add %ecx, %eax</span><br><span class="line"># 把这个值写回内存</span><br><span class="line">Mov %eax, c</span><br><span class="line">#打印, 即把内存里的值送到显示器,这里涉及一系列系统调用，现在先不管</span><br></pre></td></tr></table></figure>
<p>指令送进内存，CPU从内存里读取指令(读取指令和执行指令是CPU硬件实现的)，执行访问内存，执行计算。 一起看起来都很美好，看起来我们不需要一个操作系统。</p>
<p>没错！恭喜你发现一个惊天大秘密！我们就是不需要操作系统！</p>
<p>如果我们的程序就一直这么简单的运行，那可能的确不需要。可这不符合我们对现代计算机的认知。浏览器和音乐播放器是两个不同的程序，为什么你能一边刷网页一边听歌？一定是这两个程序一起运行了，可是按说你只有一个CPU， 一套内存，只能跑一个程序，为什么你能同时运行好几个程序呢？是的, 这就是操作系统最基本的功能，<strong>操作系统负责管理CPU和内存，让每一个程序都觉得自己是独立运行的。</strong></p>
<p><img src="https://pic.imgdb.cn/item/6267e209239250f7c57dba4d.png" style="zoom:70%"></p>
<h4 id="3-2-环境变量"><a href="#3-2-环境变量" class="headerlink" title="3.2 环境变量"></a>3.2 环境变量</h4><p>环境变量的作用就是指明操作系统的重要具录在哪里 </p>
<p>参考链接：<a href="https://www.bilibili.com/video/BV1w741147G9?from=search&amp;seid=17903121616999271166&amp;spm_id_from=333.337.0.0">『教程』什么是环境变量 哔哩哔哩 bilibili</a>  </p>
<h4 id="3-3-服务器"><a href="#3-3-服务器" class="headerlink" title="3.3 服务器"></a>3.3 服务器</h4><h5 id="3-3-1-什么是服务器"><a href="#3-3-1-什么是服务器" class="headerlink" title="3.3.1 什么是服务器"></a>3.3.1 什么是服务器</h5><div class="bvideo">
    <a href="//www.bilibili.com/video/BV1bk4y1m79S" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/0a16f645b008f3e5654185407ef3b135d778dcc7.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:07:03</span>
            </div>
            <div class="bvideo-info">
                <p class="title">【白话科普】服务器是什么 ｜能做什么  | 和电脑有什么区别 | 什么是云服务器 | 网站上线系列分享</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>10.7万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>184</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">好奇代码的三木</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<p>首先可以很明确地说服务器也是电脑，<strong>服务器是为电脑提供服务的电脑</strong>，既然是电脑，那么它也一样是由CPU，主板，内存条，硬盘，机箱，电源等硬件组成。 </p>
<blockquote>
<p>还是拿人类来举例子，如果说电脑是人类的话，那么，服务器就是人类中的医生或者公务员或者其他不同的角色，也就是说，都是人类，只是不同人通过学习一些专业技能然后赋予了不同的角色。</p>
<p>现在理解一些了么？也就是说一台电脑，如果它安装某些特殊的软件用于某种专业的用途，那么它就可以叫做是某种服务器。这是软件层面的，硬件层面的后面再说。  </p>
</blockquote>
<p>比如最常见的网站服务器，当你在浏览器里敲入<a href="https://link.zhihu.com/?target=http%3A//www.baidu.com">http://www.baidu.com</a>的时候，最终你的电脑是访问到的另外一台电脑，这台电脑会被安装网站服务的软件，并且会有网站方面的网站程序，最终起作用的是这些软件跟程序，这台电脑啥事情都不干，专门用来响应大家的访问请求，于是乎，他就叫做网站服务器，也叫web服务器，现实中并不是一台电脑，而是很多很多台电脑专门干这个事情，因为全球这么大的用户量，如果都访问一台电脑，不光是网络带宽问题，就这一台电脑早就累死掉了，这背后有很深层次的技术问题。 </p>
<p>再说两种服务器，一种是文件服务器，一种是数据库服务器，直观一些的你可以把百度网盘理解为文件服务器，虽然背后其实更加的综合，但是这种专门用来做文件存储的电脑就可以称为文件服务器了。 </p>
<p>跟另外两种服务器一样，数据库服务器也是专门只干一件事情，就是存储数据，数据库服务器一般不对外，它再为网站服务器或者其他的程序来提供服务，而且它会安装专门的数据库管理软件，来进行数据管理，这些数据的组织形式有点像excel表格里面的数据，其他电脑对他进行操作的时候，就好像跟他吼一声： “hey，帮我查查那个谁的什么什么信息。”，数据库服务器的软件就会把需要的数据给它返回回去。 </p>
<p>所以当你访问百度搜素某个关键词的时候，首先你访问到的是百度的某台网站服务器，网站服务器只是负责请求的处理跟结果的反馈，具体的数据它得更数据库服务器要去，数据库服务器把数据反馈给网站服务器，网站服务器再把结果组织输出成为你看到的模样。 </p>
<h5 id="3-3-2-为什么要为深度学习配置专门的服务器"><a href="#3-3-2-为什么要为深度学习配置专门的服务器" class="headerlink" title="3.3.2 为什么要为深度学习配置专门的服务器"></a>3.3.2 为什么要为深度学习配置专门的服务器</h5><p>首先解释一下深度学习为什么需要显卡计算，GPU是为大规模的并行运算而优化，GPU上则更多的是运算单元，GPU往往拥有更大宽带的显存，因此在大吞吐量的应用中也会有很好的性能，所以显卡选择最重要。专门的深度学习服务器可以方便实现实验室计算资源共享，多用户可以在个人电脑编写程序，远程访问到深度学习服务器上排队使用计算资源，减少购买设备的开支。因此准备基于CUDA计算是NVIDIA开发的GPU并行计算环境，英伟达产品系列是个不错的选择，或者选择英伟达国内代理商。</p>
<ul>
<li>深度学习需要大量的并行计算资源，而且动辄计算几天甚至数周，而显卡（GPU)恰好适合这种工作，提供几十上百倍的加速，性能强劲的GPU能在几个小时内完成原本CPU需要数月完成的任务，所以目前深度学习乃至于机器学习领域已经全面转向GPU架构，使用GPU完成训练任务。</li>
<li>如今即使使用GPU的深度学习任务也要持续数天乃至数月（取决于数据规模和深度学习网络模型），需要使用单独的设备保障保证训练任务能够7x24小时长期稳定运行。 </li>
<li>独立的深度学习工作站(服务器)可以方便实现实验室计算资源共享，多用户可以在个人电脑写程序，远程访问到深度学习服务器上排队使用计算资源，减少购买设备的开支且避免了在本地计算机配置复杂的软件环境。 </li>
</ul>
<h5 id="3-3-3-如何免费使用Google-colab服务器训练网络"><a href="#3-3-3-如何免费使用Google-colab服务器训练网络" class="headerlink" title="3.3.3 如何免费使用Google colab服务器训练网络"></a>3.3.3 如何免费使用Google colab服务器训练网络</h5><div class="bvideo">
    <a href="//www.bilibili.com/video/BV13K4y1P7dx" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/84653d2d5e398cda5317954a991dc2d0d2bd0149.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:10:09</span>
            </div>
            <div class="bvideo-info">
                <p class="title">Google colab使用分享/小白上手Google colab</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>6.9万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>66</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">一只乌龟大王</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<h3 id="4-Pycharm的基本使用"><a href="#4-Pycharm的基本使用" class="headerlink" title="4 Pycharm的基本使用"></a>4 Pycharm的基本使用</h3><h4 id="4-1-Python安装前必须知道的三个概念"><a href="#4-1-Python安装前必须知道的三个概念" class="headerlink" title="4.1 Python安装前必须知道的三个概念"></a>4.1 Python安装前必须知道的三个概念</h4><h5 id="4-1-1-Python解释器"><a href="#4-1-1-Python解释器" class="headerlink" title="4.1.1 Python解释器"></a>4.1.1 Python解释器</h5><p>Python解释器是将Python源码高级语言解析(<strong>翻译</strong>)为二进制机器语言的工具。通常说安装Python就是指安装Python解释器。目前最新的Python解释器版本是Python 3.8x。另外，Python 2.x和Python 3.x<strong>不兼容</strong>。 </p>
<p><img src="https://pic.imgdb.cn/item/6267e304239250f7c57fcec3.png" style="zoom:60%"></p>
<h5 id="4-1-2-Python编辑器"><a href="#4-1-2-Python编辑器" class="headerlink" title="4.1.2 Python编辑器"></a>4.1.2 Python编辑器</h5><p>正如在电脑上编辑文档需要用Word、处理数据需要用Excel、做演示文稿需要用PPT、修图需要用PS一样，<strong>编写代码也需要特定的工具，而这个用来编写代码的工具就叫做编辑器</strong>。Python的编辑器有很多，有Python解释器自带的<strong>IDLE</strong>、基于iPython的<strong>Jupyter Notebook</strong>、也有如<strong>PyCharm</strong>、<strong>Spyder</strong>、<strong>WinglDE</strong>等主要针对Python代码编辑的编辑器；还有很多编辑器，如Sublime Text、Vim、<strong>VSCode等适合各种编程语言的编辑器</strong>。 </p>
<h5 id="4-1-3-包管理工具"><a href="#4-1-3-包管理工具" class="headerlink" title="4.1.3 包管理工具"></a>4.1.3 包管理工具</h5><p>Python最大的优点之一就在于其丰富的库，<strong>pip ( package installer for Python)</strong>就是库管理工具，通过pip就可以安装、卸载、更新众多的库。 </p>
<p>Python3.4以后的版本的解释器自带pip功能 </p>
<h5 id="4-1-4-小结"><a href="#4-1-4-小结" class="headerlink" title="4.1.4 小结"></a>4.1.4 小结</h5><ul>
<li>一般说的安装python就是指安装python解释器，因此python解释器必须安装。</li>
<li>出于编写代码效率的考虑，有必要安装专业的代码编辑工具，最常用的包括Python解释器自带的IDLE、Anaconda中的Jupyter Notebook以及专门针对Python的PyCharm。</li>
<li>Python 3.4以后版本的解释器自带pip工具，因此不用自行安装。 </li>
</ul>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
        <category>编程语言学习</category>
      </categories>
      <tags>
        <tag>编程软件基础</tag>
      </tags>
  </entry>
  <entry>
    <title>压缩感知和稀疏恢复基础</title>
    <url>/2023/08/08/Compressed-Perception-Foundation/</url>
    <content><![CDATA[<h4 id="0-文献研读中知识点补充"><a href="#0-文献研读中知识点补充" class="headerlink" title="0. 文献研读中知识点补充"></a>0. 文献研读中知识点补充</h4><h5 id="0-1-托普利兹-toeplitz-矩阵"><a href="#0-1-托普利兹-toeplitz-矩阵" class="headerlink" title="0.1 托普利兹(toeplitz)矩阵"></a>0.1 托普利兹(toeplitz)矩阵</h5><p><strong>(一) 基本定义</strong></p>
<p>Toeplitz矩阵又叫做常对角矩阵(diagonal-constant matrix)，指矩阵中每条自左上至右下的斜线上之元素都为同一常数的矩阵。例如下面就是一个Toeplitz矩阵的例子： </p>
<script type="math/tex; mode=display">
\left[\begin{array}{ccccc}
a & b & c & d & e \\
f & a & b & c & d  \\
g & f & a & b & c  \\
h & g & f & a & b \\
i & h & g & f & a\\
\end{array}\right]</script><p>其正式定义<a href="https://baike.baidu.com/item/%E6%89%98%E6%99%AE%E5%88%A9%E5%85%B9%E7%9F%A9%E9%98%B5/5735426?fr=ge_ala">托普利兹矩阵_百度百科 (baidu.com)</a> 为 —— 设$\boldsymbol T = [t_{ij}] \in \mathbb C^{n \times n}$，如果满足$t_{ij} = t_{j-i}$，即：</p>
<script type="math/tex; mode=display">
\boldsymbol T = \left[\begin{array}{ccccc}
t_0 & t_1 & t_2 & \cdots & t_{n-1} \\
t_{-1} & t_0 & t_1 & \cdots & t_{n-2} \\
t_{-2} & t_{-1} & t_0 & \cdots & t_{n-3} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
t_{-n+1} & t_{-n+2} & t_{-n+3} & \cdots & t_{0} 
\end{array}\right]</script><p>则称$\boldsymbol T$为托普利兹矩阵(Toeplitz matrix)。</p>
<p><strong>(二) 对称Toeplitz和Hermitian Toeplitz矩阵</strong></p>
<p>在信号处理领域中经常遇到一种特殊的T型矩阵，它除了具有一般T型矩阵的特点外，还是一个对称矩阵，即满足$t_{-i} = t_i$，形式如下：</p>
<script type="math/tex; mode=display">
\boldsymbol T = \left[\begin{array}{ccccc}
t_0 & t_1 & t_2 & \cdots & t_{n-1} \\
t_{1} & t_0 & t_1 & \cdots & t_{n-2} \\
t_{2} & t_{1} & t_0 & \cdots & t_{n-3} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
t_{n-1} & t_{n-2} & t_{n-3} & \cdots & t_{0} 
\end{array}\right]</script><p>在复数域上，若一个复Toeplitz矩阵的元素满足复共轭对称关系，即$t_{-i} = t_i^*$，形式如下：</p>
<script type="math/tex; mode=display">
\boldsymbol T = \left[\begin{array}{ccccc}
t_0 & t_1 & t_2 & \cdots & t_{n-1} \\
t_{1}^* & t_0 & t_1 & \cdots & t_{n-2} \\
t_{2}^* & t_{1}^* & t_0 & \cdots & t_{n-3} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
t_{n-1}^* & t_{n-2}^* & t_{n-3}^* & \cdots & t_{0} 
\end{array}\right]</script><p>则称之为Hermitian Toeplitz矩阵。</p>
<p>这种特殊的对称Toeplitz矩阵可仅由矩阵的第一行元素完全确定，因此常简记为$\boldsymbol T = \boldsymbol T(\boldsymbol t) = \mathrm{Toep}[t_0, t_1, \cdots, t_{n-1}]$。</p>
<p><strong>相关参考链接</strong></p>
<p>参考链接1：<a href="https://blog.csdn.net/baimafujinji/article/details/74169484">各种矩阵总结-常见矩阵十种类型-白马负金羁-CSDN博客</a><br>参考链接2：<a href="https://www.docin.com/p-294882010.html?docfrom=rrela">关于TOEPLITZ矩阵的计算 - 豆丁网 (docin.com)</a></p>
<h5 id="0-2-封闭解、解析解、数值解释义"><a href="#0-2-封闭解、解析解、数值解释义" class="headerlink" title="0.2  封闭解、解析解、数值解释义"></a>0.2  封闭解、解析解、数值解释义</h5><p><strong>(一) 封闭解</strong></p>
<p>首先，封闭解(closed-form expression)就是一个数学表达式；这种数学表达式包含<strong><font color="red">有限</font>个<font color="blue">标准运算</font></strong>。</p>
<p><strong>什么是有限？</strong> 比如$x+y$就是一个有限表达式(只有两个变量、一个加法运算)；二次方程的根$\dfrac{-b \pm \sqrt{b^2-4ac}}{2a}$也是一个有限表达式；$\sum\limits_{i=1}^5 2^i$也是有限表达式(这里包含了5次求和运算)。但是$\sum\limits_{i=1}^{+\infty} 2^i$就<strong>不是</strong>一个有限表达式，因为他是无穷求和。</p>
<p>什么是<strong>标准运算</strong>？根据上面的定义，<strong>标准运算</strong>包含常量、变量、常见运算(如加、减、乘、除)以及一些函数(如$N$次根、指数、对数、三角函数、双曲函数)；但是<strong>极限、差分、积分都不能算作标准运算</strong>。</p>
<p>有了这两条标准，我们就能很容易地判断出一个解是不是闭合解了，如下示例：</p>
<ul>
<li>$x+y$是一个闭合解，它仅包含变量和加法运算；</li>
<li>$\dfrac{-b \pm \sqrt{b^2-4ac}}{2a}$是一个闭合解，它包含变量、加、减、乘、除以及根号运算；</li>
<li>$\sum\limits_{i=1}^5 2^i$是一个闭合解，它包含变量、加法、除法以及指数运算；</li>
<li>$\sum\limits_{i=1}^{+\infty} 2^i$不是一个闭合解，因为它包含了<strong>无限次</strong>加法运算；</li>
<li>$\Phi(x) = \displaystyle\int_{-\infty}^x \dfrac{1}{2\pi} \exp\left(\dfrac{t^2}{2}\right) \text{ d}t$表示标准正态分布的累积分布函数，如果一个解中包含$\Phi(\cdot)$运算符，那么这个解就不是闭合解(积分运算不能算作标准运算)。</li>
</ul>
<p>两点说明：</p>
<ul>
<li><p>有些情况下，非闭合解可以转化为闭合解。比如无穷级数$\sum\limits_{i=1}^{+\infty} \dfrac{x}{2^i}$本身不是一个闭合解，但是利用等比数列的求和公式我们可以得到$\sum\limits_{i=1}^{+\infty} \dfrac{x}{2^i} = 2x$。因此，可以将非闭合解  转化为闭合解 。 </p>
</li>
<li><p>维基百科上关于Closed-form  expression的定义的最后一句提到：“The set of operations and functions may vary with  author and  context”。换句话说，关于标准运算的定义并不是非常的严格，也是因人而异的。如果在闭合解的范畴以外，再加上一些特别函数(比如Bessel函数、Gamma函数、无限级数、连续分数)等，就是所谓的<strong>解析解</strong>(Analytical solution)。解析解中不包含极限和积分运算。</p>
</li>
</ul>
<p><strong>(二) 3个概念的整体辨析</strong></p>
<ul>
<li><p><strong>解析解</strong></p>
<p>解析解(Analytical solution)  就是根据严格的公式推导，给出任意的自变量就可以求出其因变量，也就是问题的解，然后可以利用这些公式计算相应的问题。所谓的解析解是一种包含分式、三角函数、指数、对数甚至无限级数等基本函数的解的形式。用来求得解析解的方法称为<strong>解析法(Analytical techniques)</strong>，解析法即是常见的微积分技巧，例如分离变量法等。</p>
</li>
<li><p><strong>封闭解</strong></p>
<p>解析解是一个封闭形式(Closed-form) 的函数，因此对任一自变量，我们皆可将其带入解析函数求得正确的因变量。因此，解析解也被称为封闭解(Closed-form solution)。</p>
</li>
<li><p><strong>数值解</strong></p>
<p>数值解(Numerical solution) 是采用某种计算方法，如有限元法， 数值逼近法，插值法等得到的解。别人只能利用数值计算的结果，而不能随意给出自变量并求出计算值。</p>
</li>
</ul>
<blockquote>
<p>当无法藉由微积分技巧求得解析解时，这时便只能利用数值分析的方式来求得其数值解了。在数值分析的过程中，首先会将原方程加以简化，以利于后来的数值分析。例如，会先将微分符号改为差分(微分的离散形式)符号等，然后再用传统的代数方法将原方程改写成另一种方便求解的形式。这时的求解步骤就是将一自变量带入，求得因变量的近似解，因此利用此方法所求得的因变量为一个个离散的数值，不像解析解为一连续的分布，而且因为经过上述简化的操作，其正确性也不如解析法可靠。</p>
</blockquote>
<p>简而言之：（1）解析解就是给出解的具体函数形式，从解的表达式中就可以算出任何对应值；（2）数值解就是用数值方法求出近似解，给出一系列对应的自变量和解。</p>
<p><strong>相关参考链接</strong></p>
<p>参考链接1：<a href="https://zhuanlan.zhihu.com/p/574867835">到底什么是“闭合解（Closed-form Solution）” - EricG的文章 - 知乎</a><br>参考链接2：<a href="https://www.cnblogs.com/vive/p/5006552.html">封闭解(Closed-form solution)、解析解(Analytical solution)、数值解(Numerical solution) 释义 - 博客园</a></p>
<h5 id="0-3-启发式算法的概念"><a href="#0-3-启发式算法的概念" class="headerlink" title="0.3 启发式算法的概念"></a>0.3 启发式算法的概念</h5><p>启发式算法(heuristic algorithm)可以这样定义：一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化(NP-Hard)问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。现阶段，启发式算法以仿自然体算法为主，主要有蚁群算法、模拟退火法、神经网络等。 </p>
<p>在数学优化和计算机科学中，启发式算法用于在经典方法效果不佳时更快地解决问题或找到近似解。这是通过牺牲最优性、完整性、准确性或精度换取速度来实现的。它是一个与最优化算法相对的概念。</p>
<p>在某种程度上，它可以被认为是一条捷径。因此启发式算法给出的答案是具有偶然性的，或者说时好时坏，因为启发式方法仅仅告诉我们该如何去找答案，而不直接告诉我们答案是什么。</p>
<p>某些启发式算法具有强大的基础理论，它们要么是从理论中以自上而下的方式推导出来的，要么是基于实验或现实世界的数据得出的。<strong>其他的只是基于现实世界观察或经验的经验法则，甚至连理论都没有，这些启发式算法的难点是建立符合实际问题的一系列启发式规则</strong>。</p>
<p>关于启发式算法更多更详细内容请参考：<a href="https://it.cha138.com/python/show-6057226.html">启发式算法(cha138.com)</a> </p>
<h5 id="0-4-最优化涉及的一些基本概念"><a href="#0-4-最优化涉及的一些基本概念" class="headerlink" title="0.4 最优化涉及的一些基本概念"></a>0.4 最优化涉及的一些基本概念</h5><p><strong>(一) 线性规划中几个概念辨析</strong></p>
<p>最优化线性规划问题中的常见概念辨析：可行解，最优解，基，基向量，非基向量，基变量，非基变量等等</p>
<p>线性规划里面有很多基本的概念容易弄混</p>
<p>已知标准型为：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min & \boldsymbol z = \boldsymbol{C}^{\mathrm T} \boldsymbol x \\ 
\text { s.t. } & \boldsymbol{Ax} = \boldsymbol b \\
& \boldsymbol x \geq \boldsymbol 0
\end{cases}</script><p>其中，$\boldsymbol C \in \mathbb R^n, \boldsymbol x \in \mathbb R^n, \boldsymbol b \in \mathbb R^m, \boldsymbol A \in \mathbb R^{m \times n}(m &lt;n)$，且$\boldsymbol A$的行向量线性无关。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>概念</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>可行解</td>
<td>只要满足约束条件，$ \boldsymbol{Ax} = \boldsymbol b , \boldsymbol x \geq \boldsymbol 0$的解$\boldsymbol x$称为线性规划问题的可行解。</td>
</tr>
<tr>
<td>最优解</td>
<td>不仅要满足约束条件，而且要使目标函数$\boldsymbol z = \boldsymbol{Cx}$达到最小值的可行解称为最优解。</td>
</tr>
<tr>
<td>基</td>
<td>$\boldsymbol A_{m\times n}$是约束系数矩阵，秩为$m$，若$\boldsymbol B_{m \times m}$是$\boldsymbol A$的子阵且可逆(即$\boldsymbol B$是$\boldsymbol A$中$m$个线性无关向量组)，称$\boldsymbol B$为LP的一个基，不失一般性，可设$\boldsymbol B$是$\boldsymbol A$的前$m$列，即$\boldsymbol B = (\boldsymbol a_1, \boldsymbol a_2, \cdots, \boldsymbol a_m)$，其相对应的变量$\boldsymbol x_B = (x_1, x_2, \cdots, x_m)^{\mathrm T}$为基变量，基变量有$m$个。其余变量$\boldsymbol x_N = (x_{m+1}, x_{m+2}, \cdots, x_n)^{\mathrm T}$称为非基变量，非基变量有$n-m$个。</td>
</tr>
<tr>
<td>基向量</td>
<td>基$\boldsymbol B$的一列就称为一个基向量。</td>
</tr>
<tr>
<td>非基向量</td>
<td>在$\boldsymbol A$中除了基$\boldsymbol B$之外的一列就称为基$\boldsymbol B$的非基向量。</td>
</tr>
<tr>
<td>基本解(<br>基解<br>基础解)</td>
<td>若在约束方程组系数矩阵中找到一个基，令其非基变量为零，再求解该$m$元线性方程组可得到唯一解，该解称之为线性规划的基本解，其形式为$\boldsymbol x = (x_1, x_2, \cdots, x_m, 0, 0, \cdots, 0)^{\mathrm T}$ 。</td>
</tr>
<tr>
<td>基可行解</td>
<td>基解可正可负，负则不可行(违背非负性约束条件)，称满足所有约束条件的基解为基可行解。</td>
</tr>
<tr>
<td>退化的基可行解</td>
<td>若某个基变量取值为零，则称之为退化的基可行解。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>所以需要注意的是基本解不一定是可行解，非负的基解才是可行解。</p>
</blockquote>
<p>说了半天没有一个直观的理解，下面一张图展示了什么是基本解，什么是基本可行解。</p>
<center><img src="https://pic.imgdb.cn/item/64f2e241661c6c8e54bee524.jpg" alt="各种解的示意图" style="zoom:70%"></center>

<blockquote>
<p>基本解：各个等式约束直线的交点，外加与坐标轴的交点；<br>基本可行解：基本解里面在可行域范围的那些基本解，可行域的顶点；<br>最优解：基本可行解里面使目标函数最大(最小)的基本可行解</p>
</blockquote>
<p><strong>相关参考链接</strong></p>
<p>参考链接1：<a href="https://blog.csdn.net/shulianghan/article/details/114480211">【运筹学】线性规划数学模型 ( 线性规划三要素 | 一般形式 | 标准形式 | 标准形式转化 | 可行解 | 最优解 | 基 | 基向量 | 基变量 | 非基变量 ) ★★-运筹学三要素-韩曙亮的博客-CSDN博客</a><br>参考链接2：<a href="https://hanshuliang.blog.csdn.net/article/details/102737266">【运筹学】线性规划数学模型标准形式 ( 标准形式 | 目标函数转化 | 决策变量转化 | 约束方程转化 | 固定转化顺序 | 标准形式转化实例 ) ★★-线性规划模型的标准形式-韩曙亮的博客-CSDN博客</a><br>参考链接3：<a href="https://hanshuliang.blog.csdn.net/article/details/102853181">【运筹学】线性规划问题的解 ( 可行解 | 可行域 | 最优解 | 秩的概念 | 极大线性无关组 | 向量秩 | 矩阵秩 | 基 | 基变量 | 非基变量 | 基解 | 基可行解 | 可行基 )_线性规划问题的可行解如为最优解_韩曙亮的博客-CSDN博客</a> 机器学习中加正交约参考链接4：<a href="https://www.zhihu.com/question/395786225">机器学习中加正交约束避免平凡解怎么理解呢？ - 知乎</a></p>
<p><strong>(二) 数学中的「平凡」「非平凡」「退化」等概念</strong></p>
<p>首先，<strong>平凡解就是显而易见、没有讨论的必要但为了结果的完整性仍要考虑的解。</strong></p>
<ol>
<li>比如$\boldsymbol{Ax} = \boldsymbol 0$中的一个显而易见的解——$\boldsymbol x = \boldsymbol 0$，即为平凡解。</li>
<li>比如求一个数的因子，正负的1和它本身是这个数最显而易见的解，所以这两个因子就是平凡解，其他的是不平凡的。</li>
</ol>
<p>其次，<strong>「退化」在数学里面有“不可逆”、“不满秩”这样的含义</strong>。一个复杂的东西在某种条件下变成一个简单的东西，就叫「退化」 。它一般跟“某个量等于0”有关。① 比如行列式等于0可以叫退化情形(不可逆矩阵)；② 比如三大二阶线性偏微分方程分类里面，抛物型方程一般被称为退化情形，因为它对应的二次型是退化的——实际上也就是说对应的系数矩阵是不可逆的；③ 比如在某一点处的概率为1而在其他点的概率都为0的概率分布，它就比其他一般的分布都更简单，因此叫做退化分布； ④ 比如一个一元二次方程，在二次项系数为零时，就退化成一元一次方程；⑤ 比如椭圆在离心率为零时退化成圆；⑥ 比如向量的内积，在向量只有一维的时候就退化成标量乘法。</p>
<blockquote>
<p> <a href="https://www.zhihu.com/question/21872524/answer/303550906">退化</a>另一释义一般指是某种特殊，极限的情形。比如说欧式几何里两条平行的直线，比如零乘一个多项式变成零，比如一个环里有两个非零的元素乘积是零，比如坐标变换在一点上雅可比行列式为零，比如原本线性无关的基变换后线性相关了……</p>
</blockquote>
<p>补充，机器学习中加正交约束避免平凡解怎么理解呢？</p>
<p>机器学习中很多参数的求解是迭代解法，根据奥卡姆剃刀原理，在结果相同的情况下，模型倾向于选择一个最简单的解。比如：$\boldsymbol{Ax} + \boldsymbol{By} = \boldsymbol 0$，待求参数为$\boldsymbol x$和$\boldsymbol y$，不得不承认$\boldsymbol{x=y=0}$是该方程的解(其实就是上面说的平凡解)，但是这并不是我们想要的结果，因此可以通过增加一个约束项，例如：$|\boldsymbol x|^2&gt;ε$来限制解的范围。平凡解的确也是一种解，但是并不是我们所期望的解，为了避免在迭代过程中模型收敛到平凡解，因此通过增加适当的约束项，来约束解的范围。 </p>
<p><strong>(三) 小概念之凸包</strong></p>
<p>平面上给定若干点，则它们的<strong>凸包</strong>被定义为所有能包含所有点的<strong>凸多边形</strong>的<strong>交集</strong>。 </p>
<p>在一切包含所有点的凸多边形中，凸包的<strong>面积</strong>是最小的<em>(显然)</em>，<strong>周长</strong>也是最小的<em>(因为每个包含所有点的凸多边形，总可以通过下面这样的过程，不断缩小周长，最终得到凸包，完整证明可参见</em><a href="https://link.zhihu.com/?target=https%3A//math.stackexchange.com/questions/13148/convex-hull-has-the-smallest-perimeter">此网页</a><em>)</em>。类似地可以证明，凸包的每个顶点都是<strong>原有的点</strong>。 </p>
<p>凸包的严格定义为：设集合$S ⊂ \mathbb R^n$是由$\mathbb R^n$中的$k$个点所组成的集合，即$S = (\boldsymbol x_1,\boldsymbol x_2, \cdots, \boldsymbol x_k)$。定义$S$的凸包为：</p>
<script type="math/tex; mode=display">
\mathrm{conv}(S) = \left\{\boldsymbol x = \sum_{i=1}^k \lambda_i \boldsymbol x_i \left|  \sum_{i=1}^k \lambda_i=1, \lambda_i \geq 0 \right.\right\}</script><p>详细内容请参考如下链接：</p>
<p>参考链接1：<a href="https://zhuanlan.zhihu.com/p/584937054">对凸包定义的可视化理解 - Zewbie的文章 - 知乎</a><br>参考链接2：<a href="https://zh.wikipedia.org/zh-hans/%E5%87%B8%E5%8C%85">凸包 - 维基百科，自由的百科全书 (wikipedia.org)</a><br>参考链接3：<a href="https://zhuanlan.zhihu.com/p/340442313">算法学习笔记(65): 凸包 - Pecco的文章 - 知乎</a></p>
<p>优化理论的系统笔记内容：<a href="https://blog.csdn.net/qq_39183034/category_12029281.html">最优化理论与方法 - 快乐江湖的专栏 - CSDN</a>：强推！！！</p>
<h5 id="0-5-DOA估计之确定性VS随机性最大似然法"><a href="#0-5-DOA估计之确定性VS随机性最大似然法" class="headerlink" title="0.5 DOA估计之确定性VS随机性最大似然法"></a>0.5 DOA估计之确定性VS随机性最大似然法</h5><p><strong>(一) 概述</strong></p>
<p>在空间谱估计中，根据入射信号的模型，最大似然算法基本上分为两类：确定性最大似然(DML)和随机性最大似然(SML)，具体为：</p>
<ul>
<li><p>当信号模型是未知的确定模型时导出的最大似然算法称为DML算法；</p>
</li>
<li><p>当入射信号服从高斯随机分布模型时导出的最大似然算法是SML算法；</p>
</li>
</ul>
<p>窄带远场信号的 DOA数学模型为：</p>
<script type="math/tex; mode=display">
\boldsymbol X(t) = \boldsymbol A(\boldsymbol \theta) \boldsymbol s(t) + \boldsymbol N(t), \quad t=1,2,\cdots,L</script><p>不同的快拍数之间的噪声协方差矩阵为$\boldsymbol O$，也就是不相关，且各阵元接收的噪声是正态分布的，噪声功率为$\sigma^2$。</p>
<p><strong>(二) DML模型</strong></p>
<p>根据以上的假设可知，对于DML由于模型未知，所以观察数据的一阶和二阶矩满足如下条件：</p>
<script type="math/tex; mode=display">
\begin{aligned}
均值:  \quad & \mathbb E[\boldsymbol x(t_i)] = \boldsymbol A(\boldsymbol \theta) \boldsymbol s(t_i) = \bar{\boldsymbol x}(t_i) \\
协方差:  \quad & \mathbb E[(\boldsymbol x(t_i) - \bar{\boldsymbol x}(t_i)) \cdot (\boldsymbol x(t_i) - \bar{\boldsymbol x}(t_i))^{\mathrm H}] = \sigma^2 \boldsymbol I \delta_{ij}\\
伪协方差:  \quad & \mathbb E[(\boldsymbol x(t_i) - \bar{\boldsymbol x}(t_i)) \cdot (\boldsymbol x(t_i) - \bar{\boldsymbol x}(t_i))^{\mathrm T}] = \boldsymbol O
\end{aligned}</script><p>其中，<strong>伪协方差</strong>的概念请参考<a href="https://www.cnblogs.com/junhengwang/p/17675109.html">复随机过程概念补充 - 博客侦探 - 博客园</a>。根据上式可以得到DML的联合概率密度函数，显然有观测矢量$L$次快拍联合(条件)概率密度函数(PDF)：</p>
<script type="math/tex; mode=display">
\boldsymbol f_{\mathrm{DML}}(\boldsymbol x_1, \cdots, \boldsymbol x_L) = \prod_{i=1}^L \dfrac{1}{\mathrm{det}(\pi \sigma^2 \boldsymbol I)} \exp\left(-\dfrac{1}{\sigma^2} |\boldsymbol x_i - \boldsymbol{As}_i|^2\right)</script><p><strong>(三) SML模型</strong></p>
<p>对于SML，由于其信号的模型为高斯随机分布，所以观察数据是零均值，其二阶矩满足：</p>
<script type="math/tex; mode=display">
\begin{aligned}
均值:  \quad & \mathbb E[\boldsymbol x(t_i)] = \boldsymbol 0 \\
协方差:  \quad & \mathbb E[\boldsymbol x(t_i) \cdot \boldsymbol x^{\mathrm H}(t_i)] = [\boldsymbol A(\boldsymbol \theta) \boldsymbol R_{\boldsymbol s} \boldsymbol A^{\mathrm H}(\boldsymbol \theta) + \sigma^2 \boldsymbol I] \delta_{ij}\\
伪协方差:  \quad & \mathbb E[\boldsymbol x(t_i) \cdot \boldsymbol x^{\mathrm T}(t_i)] = \boldsymbol O
\end{aligned}</script><p>所以单次观察数据的似然函数为：</p>
<script type="math/tex; mode=display">
f_{i}(\boldsymbol x) =\dfrac{1}{\pi^M \mathrm{det}(\boldsymbol R)} \exp\left(\boldsymbol x^{\mathrm H}_i \boldsymbol{R_s}^{-1} \boldsymbol x_i\right)</script><p>于是很容易得出观测矢量$L$次快拍联合(条件)概率密度函数PDF：</p>
<script type="math/tex; mode=display">
\boldsymbol f_{\mathrm{SML}}(\boldsymbol x_1, \cdots, \boldsymbol x_L) = \prod_{i=1}^L \dfrac{1}{\pi^M \mathrm{det}(\boldsymbol R)} \exp\left(\boldsymbol x^{\mathrm H}_i \boldsymbol{R_s}^{-1} \boldsymbol x_i\right)</script><p><strong>相关参考链接</strong></p>
<p>参考链接1：<a href="https://blog.csdn.net/qq_43332450/article/details/121381903">DOA估计 确定性VS随机性最大似然法）-guolideyu的博客-CSDN</a><br>参考链接2：<a href="https://zhuanlan.zhihu.com/p/621005482">DoA 估计 | 确定性最大似然算法 基于牛顿法 附 MATLAB 源码 - 知乎 </a> </p>
<h5 id="0-6-待定"><a href="#0-6-待定" class="headerlink" title="0.6 待定"></a>0.6 待定</h5><p><a href="https://www.zhihu.com/question/26471536">为什么核范数能凸近似矩阵的秩？为什么核范数是凸的？ - 知乎</a><br><a href="https://hyper.ai/wiki/2687">核范数 Nuclear Norm - 人工智能百科 - 超神经 (hyper.ai)</a> </p>
<h4 id="1-压缩感知基础"><a href="#1-压缩感知基础" class="headerlink" title="1. 压缩感知基础"></a>1. 压缩感知基础</h4><p>压缩感知(Compressed Sensing, CS)是由陶哲轩等人提出的一种用于信息获取的突破性理论。该理论指出：<strong>对于稀疏信号或可压缩信号，可采用低于奈奎斯特采样频率的方式对数据采样，降低数据传输量，并能以高概率精确地重建该信号</strong>。其原始文献为：<em>D. L. Donoh, Compressed sensing, IEEE Transactions on Information Theory, 2006, 52(4): 1289-1306.</em>  </p>
<h5 id="1-1-压缩感知的流程"><a href="#1-1-压缩感知的流程" class="headerlink" title="1.1 压缩感知的流程"></a>1.1 压缩感知的流程</h5><p>压缩感知主要分为三步：</p>
<ul>
<li>1、信号的稀疏化表示，实现信号的压缩；</li>
<li>2、观测矩阵的设计，得到观测数值；</li>
<li>3、信号的重构，得到恢复信号。</li>
</ul>
<h5 id="1-2-信号稀疏化表示"><a href="#1-2-信号稀疏化表示" class="headerlink" title="1.2 信号稀疏化表示"></a>1.2 信号稀疏化表示</h5><p>稀疏信号定义：设一维离散信号$\boldsymbol x$，长度为$N$，可看作为$N$维空间$N\times1$的列向量，若此列向量中含有$K$个不为0元素，且$K \ll N$，则称该信号$\boldsymbol x$是$K$-稀疏信号，具有稀疏性。$K$称为信号$\boldsymbol x$的稀疏度。<font color="red">牢记，信号具有稀疏性（在本域或其他变换域皆可）是可以使用压缩感知的前提</font>！</p>
<p>如果信号稀疏，则信号$\boldsymbol x$可以表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol x = \sum_{k=0}^{N-1} \boldsymbol \psi_k s_k = \boldsymbol {\Psi s}</script><p>其中，$\boldsymbol s$为稀疏系数，也是我们使用算法恢复出来的重建新号，其尺寸与信号$\boldsymbol x$相同；$\boldsymbol \Psi$是我们所熟知的稀疏矩阵，其尺寸为$N\times N$，这就是信号的稀疏过程。</p>
<h5 id="1-3-观测矩阵设计"><a href="#1-3-观测矩阵设计" class="headerlink" title="1.3 观测矩阵设计"></a>1.3 观测矩阵设计</h5><p>观测矩阵的作用主要是使人们可以看到由仪器所获得的观测值$ \boldsymbol y$，其中，你想要看到多少，这就是我们所熟知的采样率了。对观测矩阵的要求是，可从观测值$\boldsymbol y$中高精度的重构出长度为$N$的原始信号$\boldsymbol s$，或者重构出在稀疏矩阵下的等价信号。其具体表达式为：</p>
<script type="math/tex; mode=display">
\boldsymbol y = \boldsymbol{\Phi x}</script><p>式中，$\boldsymbol \Phi$为观测矩阵(也称测量矩阵)，其维度为$M\times N$，$\boldsymbol x$为原始信号，其维度为$N\times 1$；$\boldsymbol y$为观测信号，其维度为$M\times 1$。从原始信号中可以观察到多少信号，就是由测量矩阵决定的，因此其会涉及到采样率的概念。通常的采样率概念定义为测量矩阵的行数/列数，即$\dfrac{M}{N}$。</p>
<p>将这个式子带入1.2节中的式子，则可以得到大家经常看到的式子了：</p>
<script type="math/tex; mode=display">
\boldsymbol y = \boldsymbol{\Phi x} =  \boldsymbol{\Phi \Psi s} = \boldsymbol{\Theta s}</script><p>其中，$\boldsymbol {\Theta=\Phi \Psi}$为$M\times N$阶矩阵，又称为传感矩阵。</p>
<p>在此步中，最重要的是构造出合适的观测矩阵，使得可通过仪器采集到从稀疏信号中获得的观测值，并在反向求解时，由观测值重构稀疏信号，即构造出有解的$M \times K$线性方程组。牢记，在进行上述过程时，<strong>一定要对观测矩阵进行RIP性质分析</strong>，说白了就是观测矩阵和稀疏矩阵的相关性很小很小很小！</p>
<h5 id="1-4-信号重构"><a href="#1-4-信号重构" class="headerlink" title="1.4 信号重构"></a>1.4 信号重构</h5><p>信号重构是对$\boldsymbol{y =\Phi x = \Phi \Psi s = \Theta s}$式求最优解，是压缩感知理论中的求解问题，如何得到最优解是研究的主要内容，也是最后一个关键的步骤。压缩感知目前的重构算法主要分为两类：<strong>贪婪算法与凸优化算法</strong>。</p>
<ul>
<li>贪婪算法主要是选择合适的列向量经过多次的逐步加和以实现信号的逼近，其中匹配追踪算法、正交匹配追踪等算法均属于贪婪算法；</li>
<li>凸优化算法则是将范数的求解置于范数进行线性规划求解，此算法包括基追踪算法、梯度投影算法等。</li>
</ul>
<p>最后总结一下：<strong>对信号进行压缩感知恢复重建时，信号要映射到稀疏域，即信号在一定的变换域中是稀疏的。在进行测量矩阵压缩采样时，测量矩阵需满足RIP条件，或者应满足观测矩阵与稀疏基不相关的条件。在两个条件的基础上，可运用压缩感知算法进行恢复重建。</strong> </p>
<h4 id="2-压缩感知的常用稀疏基"><a href="#2-压缩感知的常用稀疏基" class="headerlink" title="2 压缩感知的常用稀疏基"></a>2 压缩感知的常用稀疏基</h4><h5 id="2-1-稀疏基的概念"><a href="#2-1-稀疏基的概念" class="headerlink" title="2.1 稀疏基的概念"></a>2.1 稀疏基的概念</h5><p>稀疏基是将可以信号进行稀疏表示的一个矩阵。设一维离散信号$\boldsymbol x$，长度为$N$，可看作为$N$维空间$N \times1$的列向量，若此列向量中含有$K$个不为0元素，且$K \ll N$，则称该信号$\boldsymbol x$是$K$-稀疏信号，具有稀疏性。</p>
<p>如果信号稀疏，则信号$\boldsymbol x$可以表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol x = \boldsymbol{\Psi s}</script><p>其中，$\boldsymbol \Psi$就是稀疏基(稀疏矩阵)。 </p>
<h5 id="2-2-一些常用的稀疏基"><a href="#2-2-一些常用的稀疏基" class="headerlink" title="2.2 一些常用的稀疏基"></a>2.2 一些常用的稀疏基</h5><ul>
<li>DFT稀疏基</li>
<li>DCT(离散余弦)稀疏基</li>
<li>DWT稀疏基</li>
<li>0-1随机稀疏基</li>
</ul>
<h4 id="3-贪婪算法"><a href="#3-贪婪算法" class="headerlink" title="3 贪婪算法"></a>3 贪婪算法</h4><p>压缩感知第三步是进行信号的重构，需要用到恢复重构算法。前面的文章提到过，压缩感知的恢复算法主要分为贪婪算法和凸优化算法两种，这里主要介绍贪婪算法的两种基础算法：MP算法和OMP算法 </p>
<h5 id="3-1-匹配追踪算法-MP"><a href="#3-1-匹配追踪算法-MP" class="headerlink" title="3.1 匹配追踪算法(MP)"></a>3.1 匹配追踪算法(MP)</h5><p>算法假定输入信号与字典库中的原子在结构上具有一定的相关性，这种相关性通过信号与原子库中原子的内积表示，即内积越大，表示信号与字典库中的这个原子的相关性越大，因此可以使用这个原子来近似表示这个信号。</p>
<p>当然这种表示会有误差，将表示误差称为信号残差，用原信号减去这个原子，得到残差，再通过计算相关性的方式从字典库中选出一个原子表示这个残差。迭代进行上述步骤，随着迭代次数的增加，信号残差将越来越小，当满足停止条件时终止迭代，得到一组原子，及残差，将这组原子进行线性组合就能重构输入信号。</p>
<h5 id="3-2-正交匹配追踪算法-OMP"><a href="#3-2-正交匹配追踪算法-OMP" class="headerlink" title="3.2 正交匹配追踪算法(OMP)"></a>3.2 正交匹配追踪算法(OMP)</h5><p>正交匹配追踪算法迭代的基本思想就是每次迭代过程中从全息矩阵$\boldsymbol T$中选出与测量信号$\boldsymbol s$相关度(内积)最大的那一列，然后从$\boldsymbol T$中去掉该列并加入到扩充矩阵$\boldsymbol {\mathrm{Aug}}_t$中，然后利用最小二乘法原理求出使残差$\boldsymbol r_n =\boldsymbol s-\boldsymbol {\mathrm{Aug}}_t*\boldsymbol {\mathrm{Aug}}_y$最小的一个估计$\boldsymbol {\mathrm{Aug}}_y$，然后不断的从$\boldsymbol T$中减去相关列重复以上过程，直到达到迭代次数结束。</p>
<h4 id="4-凸优化算法"><a href="#4-凸优化算法" class="headerlink" title="4 凸优化算法"></a>4 凸优化算法</h4><p>除了贪婪算法以外，压缩感知重构算法的另一大类就是凸优化算法，这类方法通过将非凸问题转化为凸问题求解找到信号的逼近。</p>
<h5 id="4-1-基追踪算法（BP）"><a href="#4-1-基追踪算法（BP）" class="headerlink" title="4.1 基追踪算法（BP）"></a>4.1 基追踪算法（BP）</h5><p>该算法全称为Basis Pursuit，其提出使用$l_1$范数替代$l_0$范数来解决最优化问题，以便使用线性规划方法来求解。即将求解 $\min \limits_{\boldsymbol \alpha} ||\boldsymbol \alpha||_{l_{0}}$ 的问题转化为求解 $\min\limits_{\boldsymbol \alpha} ||\boldsymbol \alpha||_{l_{1}}$ 的问题，其中$\boldsymbol \alpha$是需要构建出来的原始信号(重构信号)。</p>
<p>参考链接4.1.1：<a href="https://www.zhihu.com/question/290679001/answer/954062882">如何理解“L1范数是L0范数的最优凸近似”？ - 牛狮的回答 - 知乎</a><br>参考链接4.1.2：<a href="https://zhuanlan.zhihu.com/p/390844225">Basis Pursuit, LASSO, TV三种压缩感知优化求解算法 - SINK IN的文章 - 知乎</a><br>参考链接4.1.3：<a href="https://jz.docin.com/p-2310356158.html">压缩感知中l1正则化最小二乘问题的算法研究 - 豆丁建筑</a> </p>
<h5 id="4-2-梯度投影法"><a href="#4-2-梯度投影法" class="headerlink" title="4.2 梯度投影法"></a>4.2 梯度投影法</h5><p>梯度投影法(gradient projection method)利用梯度的投影技巧求约束非线性规划问题最优解的一种方法，求带线性约束的非线性规划问题更为有效。它是从一个基本可行解开始，由约束条件确定出凸约束集边界上梯度的投影，以便求出下次的搜索方向和步长。每次搜索后，都要进行检验，直到满足精度要求为止。具体原理可参考<a href="https://baike.baidu.com/item/%E6%A2%AF%E5%BA%A6%E6%8A%95%E5%BD%B1%E6%B3%95/19134105?fr=aladdin">梯度投影法 - 百度百科</a>。</p>
<table width="50px"><td style="word-wrap:break-word;word-break:break-all;" ; bgcolor="lightgrey"><font size="3">
本文转自： <br>

版权声明：本文为CSDN博主「爱学习的一一」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处<br>及本声明。<br>

原文链接：https://blog.csdn.net/weixin_42105848/article/details/124280903

</font></td></table>

<p>参考链接1：<a href="https://zhuanlan.zhihu.com/p/22445302">形象易懂讲解算法II——压缩感知 - 咚懂咚懂咚的文章 - 知乎</a>：压缩感知的简要概述。<br>参考链接2：<a href="https://www.zhihu.com/question/28552876">如何理解压缩感知(compressive sensing)？ - 知乎</a>：压缩感知的简要概述。<br>参考链接3：<a href="https://blog.csdn.net/FDS99999/article/details/129784658">压缩感知基本理论-飞大圣的博客-CSDN</a>：压缩感知的简要概述。<br>参考链接4：<a href="https://www.cnblogs.com/AndyJee/category/579870.html">随笔分类 - 压缩感知compressive sensing-AndyJee的博客-博客园</a>：<strong>强推！！！</strong>博客园博主AndyJee关于压缩感知的31篇文章。<br>参考链接5：<a href="https://www.docin.com/p-777226899.html">Bessel序列与框架的若干刻画 - 豆丁网 (docin.com)</a><br>参考链接6：<a href="https://zhuanlan.zhihu.com/p/507765573">最优化理论——线性规划的标准形式 - 不喝牛奶的文章 - 知乎</a>、<a href="https://zhuanlan.zhihu.com/p/375526356">优化理论——线性规划 - 星空爱好者的文章 - 知乎</a><br>参考链接7：<a href="https://academic-accelerator.com/encyclopedia/zh-cn/compressed-sensing">压缩感知 Compressed Sensing - 百科全书、科学新闻和研究评论</a></p>
<h4 id="5-原子范数最小化-Atomic-Norm-Minimization"><a href="#5-原子范数最小化-Atomic-Norm-Minimization" class="headerlink" title="5. 原子范数最小化(Atomic Norm Minimization)"></a>5. 原子范数最小化(Atomic Norm Minimization)</h4><p>原子范数最小化算法能在一众算法中登顶的原因也很简单：它既是拥有优良凸优化性质的算法，又没有精度的限制。简单而言，如果说OMP等在有限码本上选取码字的算法为On-grid类型。 那么原子范数最小化算法就是在无穷精度的范围内进行搜索，即Gridless类型。</p>
<h5 id="5-1问题建模"><a href="#5-1问题建模" class="headerlink" title="5.1问题建模"></a>5.1问题建模</h5><p>考虑通信中常见的DOA问题。 对于$M$根接收天线而言，接收数据可表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol Y = \boldsymbol A(f) \boldsymbol S + \boldsymbol E</script><p>其中，$\boldsymbol Y \in \mathbb C^{M \times L}$，$L$代表接收时隙数(可理解为观测次数)，$\boldsymbol S \in \mathbb C^{K \times L}$代表了这$K$个源在$L$个时隙的发射信号，$\boldsymbol E \in \mathbb C^{M \times L}$为噪声，$\boldsymbol A(f)$为：</p>
<script type="math/tex; mode=display">
\boldsymbol A(f) = [\boldsymbol a(f_1), \cdots, \boldsymbol a(f_K)] \in \mathbb C^{M \times K}</script><p>其每一列对应第$k$个源(source)的DOA对应的天线响应矢量，式中：</p>
<script type="math/tex; mode=display">
\boldsymbol a(f_i) = \left[1 \quad \mathrm e^{\mathrm j 2 \pi f_i} \quad \cdots \quad \mathrm e^{\mathrm j 2 \pi(M-1) f_i}\right]^{\mathrm T}</script><p>其中，$f_i = \cos \theta_i / 2$。</p>
<table><td style="word-wrap:break-word;word-break:break-all;" width="100px" ; bgcolor="HoneyDew"><font size="3">
<strong>Toeplitz矩阵的范德蒙德分解</strong> ：<br>

对于任意的秩满足$r \leq N$的半正定Toeplitz矩阵$\boldsymbol T(\boldsymbol u) \in \mathbb{C}^{N \times N}$，则有如下的$r-$原子范德蒙德分解：
$$
\boldsymbol T(\boldsymbol u) = \sum_{k=1}^{r} p_k \boldsymbol a(f_k) \boldsymbol a^{\mathrm H}(f_k) = \boldsymbol A(f) \mathrm{diag}(\boldsymbol p) \boldsymbol A^{\mathrm H}(f)
$$

其中，$\boldsymbol A(f) = [\boldsymbol a(f_1), \boldsymbol a(f_2), \cdots, \boldsymbol a(f_r)]$。当$r < N$时，此分解是唯一的。<br>

此定律十分重要，原子范数的理论推导直接建立在这个分解之上！！！

</font></td></table>

<h5 id="5-2-DOA估计的一般框架"><a href="#5-2-DOA估计的一般框架" class="headerlink" title="5.2 DOA估计的一般框架"></a>5.2 DOA估计的一般框架</h5><p>考虑$L = 1$即一次观测的简单场景，表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol y = \boldsymbol z + \boldsymbol e = \boldsymbol A(f) \boldsymbol s + \boldsymbol e</script><p>那么一般可以以如下的优化问题为目标： </p>
<script type="math/tex; mode=display">
\begin{cases}
\min & \mathcal{M}(\boldsymbol{z}) \\ 
\text { s.t. } & ||\boldsymbol{y - z}||_2 \leq \varepsilon
\end{cases}</script><p>其中，$\mathcal{M}(\boldsymbol z)$是选择的一种度量metric。 进一步地，通过引入惩罚系数$\lambda$，可将其改写为：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol z} \lambda \mathcal{M}(\boldsymbol z) + \dfrac{1}{2} ||\boldsymbol{y - z}||_2</script><p>下面要重点介绍的，就是以原子范数$||\boldsymbol z||_{\mathcal A}$作为$\mathcal{M}(\boldsymbol z)$的方法。</p>
<h5 id="5-3-原子范数的概念"><a href="#5-3-原子范数的概念" class="headerlink" title="5.3 原子范数的概念"></a>5.3 原子范数的概念</h5><p><strong>(一) $l_0$原子范数</strong></p>
<p>首先，<strong><font color="blue">原子集</font></strong>的定义如下：</p>
<script type="math/tex; mode=display">
\mathcal A = \left\{\boldsymbol a(f, \phi) = \boldsymbol a(f) \phi \mid f \in \mathbb T, \phi \in \mathbb C, |\phi| = 1 \right\}</script><p>这个集合可以理解为是类似于OMP方法中的字典，但它是无限精度的，因为$f$可以是任意实数。$\phi$是允许了一个初始相位的不同。 而根据$\boldsymbol z = \boldsymbol A(f) \boldsymbol s$，显然$\boldsymbol z$是该原子集中$k$个原子的线性组合。 而$\ell_0$-原子范数，就是指能组成$\boldsymbol z$的最少所需原子数， 即：</p>
<script type="math/tex; mode=display">
\begin{aligned}
||\boldsymbol z||_{\mathcal A, 0} =& \inf_{c_k, f_k, \phi_k} \left\{ \mathcal K \left| \boldsymbol z = \sum_{k=1}^{\mathcal K} c_k \boldsymbol a(f_k, \phi_k),  \quad c_k >0, f_k \in \mathbb T, |\phi_k| = 1 \right.\right\} \\
= & \inf_{s_k, f_k} \left\{ \mathcal K \left| \boldsymbol z = \sum_{k=1}^{\mathcal K} s_k \boldsymbol a(f_k),  \quad f_k \in \mathbb T \right. \right\}
\end{aligned}</script><p>因为我们的目的就是为了恢复出$\boldsymbol A(f)$，而$\boldsymbol z$可以写成无数种$\mathcal{A}$ 中原子线性组合的形式。 但只有对应所用原子数最少即对应最小$\ell_0$-原子范数时，此时组成$\boldsymbol z$的原子才恰好对应待恢复的$\boldsymbol A(f)$。因此，下面的任务就是最小化$\boldsymbol z$的$\ell_0$-原子范数$||\boldsymbol z||_{\mathcal A, 0}$。</p>
<p><strong>(二) $\ell_0$-原子范数与范德蒙德分解</strong></p>
<p>虽然模型建立出来了，但是容易看到，如何对$||\boldsymbol z||_{\mathcal A, 0}$进行最小化，可以说是完全摸不着头脑。这似乎比$\ell_0$范数最小化更为抽象。此时就是见证数学魅力的时刻，考虑如下形式的矩阵：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cc}
x & \boldsymbol z^{\mathrm H} \\
\boldsymbol z & \boldsymbol T(\boldsymbol u) 
\end{array}\right] \succeq 0</script><p>$\boldsymbol T(\boldsymbol u)$的定义如之前，是一个由$\boldsymbol u$得到的Teoplitz矩阵。$x$则是一个待优化的变量。 这个约束隐含了如下的结论：</p>
<ul>
<li>① $\boldsymbol T(\boldsymbol u) \succeq 0$，否则无法保证对于任何向量$\boldsymbol y$，都有$\boldsymbol y^{\mathrm H} \left[\begin{array}{cc} x &amp; \boldsymbol z^{\mathrm H} \\ \boldsymbol z &amp; \boldsymbol T(\boldsymbol u) \end{array}\right]\boldsymbol y \geq 0$</li>
<li>② $\boldsymbol z$ 一定位于$\boldsymbol T(\boldsymbol u)$的列空间中。 这个证明也在后面的证明章节中给出了。</li>
</ul>
<p>由于$\boldsymbol T(u) \succeq 0​$， 因此$\boldsymbol T(u)​$是一个半正定矩阵， 即存在范德蒙德分解：</p>
<script type="math/tex; mode=display">
\boldsymbol T(u) = \sum_{k=1}^r p_k \boldsymbol a(f_k) \boldsymbol a^{\mathrm H}(f_k) = \boldsymbol A(f) \mathrm{diag}(\boldsymbol p) \boldsymbol A^{\mathrm H}(f)</script><p>其中，$r = \mathrm{rank}(\boldsymbol T(u))$。由于$\boldsymbol z$一定位于$\boldsymbol T(u)$的列空间中，那么$\boldsymbol z$必能写为$\boldsymbol a(f_k)$的线性组合！ 这一点至关重要，因为这引出了如下的结论：</p>
<p><strong><font color="red">最小化$\ell_0$-原子范数等价于求解如下问题</font>：</strong></p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{x, u} & r = \mathrm{rank}(\boldsymbol T(u)) \\ 
\text { s.t. } & \left[\begin{array}{cc}
x & \boldsymbol z^{\mathrm H} \\
\boldsymbol z & \boldsymbol T(u) 
\end{array}\right] \succeq 0
\end{cases}</script><p>由于$\boldsymbol z$是$\boldsymbol T(u)$范德蒙德分解所得的$r$个原子的线性组合。当找到秩最小的$r$时，也就找到了组成$\boldsymbol z$所需的最少原子数。也就对应$\boldsymbol z$的$\ell_0$-原子范数最小化。 而对于这个转化后的问题，如果$u$被解出，那么$\boldsymbol T(u)$也能得到，那么对$\boldsymbol T(u)$进行范德蒙德分解，也就获得了$\boldsymbol A(f)$。但是美中不足的是，该目标函数并非凸函数，无法轻易求解。</p>
<p><strong>(三) $\ell_1$-原子范数</strong></p>
<p>将$\ell_0$-原子范数进行凸松弛， 得到的就是$\ell_1$-原子范数。 其定义如下：</p>
<script type="math/tex; mode=display">
||\boldsymbol  z||_{\mathcal A, 1} = \inf_{f_k, s_k} \left\{ {\sum_k ∣s_k∣ \left|  \boldsymbol z = \sum_k \boldsymbol a(f_k) s_k , \quad f_k \in \mathbb T \right.} \right\}</script><p>与$\ell_0$-原子范数的定义进行比较，发现这和将传统的$\ell_0$-范数松弛为$\ell_1$-范数如出一辙。然而如何最小化$||\boldsymbol  z||_{\mathcal A, 1}$看上去也非常困难。此时再度利用范德蒙德分解，有如下精彩的结论。</p>
<p><strong><font color="red">最小化$\ell_1$-原子范数等价于求解如下问题：</font></strong></p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{x, u} & \dfrac{1}{2}x + \dfrac{1}{2}u \\ 
\text { s.t. } & \left[\begin{array}{cc}
x & \boldsymbol z^{\mathrm H} \\
\boldsymbol z & \boldsymbol T(u) 
\end{array}\right] \succeq 0
\end{cases}</script><blockquote>
<p>注意到，这是一个凸问题。首先目标函数显然是变量的仿射函数，因此为凸(既凸且凹)。限制条件也可以写为变量的仿射函数形式。 因此也满足凸问题的限制条件($f(x) \leq 0$，$f(x)$为凸函数)。($\boldsymbol X \succeq 0$可以等价为$\boldsymbol y^{\mathrm H} \boldsymbol X \boldsymbol y \geq 0, \quad \forall \boldsymbol y$，而对于每个$\boldsymbol y$， 都是关于$\boldsymbol X$的仿射变换）</p>
<p>$\boldsymbol T(u)$的对角元素都是$u$， 那么事实上$u$就是$\mathrm{tr}(\boldsymbol T(u))$！而后者又被称为<strong>核函数</strong>， 也是$\mathrm{rank}(\boldsymbol T(u))$的经典凸松弛。 这从另一个角度解释了$\ell_1$原子范数最小化是$\ell_0$原子范数最小化的凸松弛。</p>
</blockquote>
<p>至此，压缩感知问题被转化为了一个可以由CVX进行直接求解的凸问题！还剩的最后一块拼图：即为何$\ell_1$-原子范数可以等效为这个凸问题，仍照例，放在下面的证明章节中。</p>
<p><strong>(四) 多维原子范数</strong></p>
<p>将原子范数拓展到多维是十分必要的，因为通信中DOA估计大多是多次观测。然而其结论大体相似。此时，变量变为二维矩阵$\boldsymbol Z$，而其$\ell_0$-原子范数被定义为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
||\boldsymbol Z||_{\mathcal A, 0} =& \inf_{c_k, f_k, \boldsymbol \phi_k} \left\{ \mathcal K  \left| \boldsymbol Z = \sum_{k=1}^{\mathcal K} c_k \boldsymbol a(f_k, \boldsymbol \phi_k),  \quad c_k >0, f_k \in \mathbb T, ||\boldsymbol \phi_k||_2 = 1 \right. \right\} \\
= & \inf_{\boldsymbol s_k, f_k} \left\{ \mathcal K \left| \boldsymbol Z = \sum_{k=1}^{\mathcal K} \boldsymbol s_k \boldsymbol a(f_k),  \quad f_k \in \mathbb T\right.\right\}
\end{aligned}</script><p>其中，$\boldsymbol a(f_k, \boldsymbol \phi_k)$为(注意加粗)：</p>
<script type="math/tex; mode=display">
\boldsymbol a(f_k, \boldsymbol \phi_k) = \boldsymbol a(f_k) \boldsymbol \phi_k, \quad f_k \in \mathbb T,  \boldsymbol \phi_k \in \mathbb C^{1 \times L}, || \boldsymbol \phi_k||_2 = 1</script><p>注意到，这和向量$\boldsymbol z$的原子范数的最大区别在于标量$\phi_k$变为了行向量$\boldsymbol \phi_k$。类似的，对其凸松弛为$\ell_1$原子范数，定义为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
||\boldsymbol Z||_{\mathcal A, 1} =& \inf \left\{ t>0  \left| \boldsymbol Z \in t\mathrm{conv}(\mathcal A)\right. \right\} \\
=& \inf_{c_k, f_k, \boldsymbol\phi_k} \left\{ \sum_k c_k  \left| \boldsymbol Z = \sum_{k=1}^{\mathcal K} c_k \boldsymbol a(f_k, \boldsymbol \phi_k),  \quad c_k >0, f_k \in \mathbb T, ||\boldsymbol \phi_k||_2 = 1 \right. \right\} \\
= & \inf_{\boldsymbol s_k, f_k} \left\{ \sum_k ||\boldsymbol s_k||_2 \left| \boldsymbol Z = \sum_{k=1}^{\mathcal K} \boldsymbol s_k \boldsymbol a(f_k),  \quad f_k \in \mathbb T\right.\right\}
\end{aligned}</script><p>其中，$\mathrm{conv}(\mathcal A)$表示原子集合的凸包。而对其的最小化，仍可以等价为如下SDP问题： </p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol X, u} & \dfrac{1}{2\sqrt{N}} \left[\mathrm{tr}({\boldsymbol X}) + \mathrm{tr}({\boldsymbol T}(u)) \right] \\ 
\text { s.t. } & \left[\begin{array}{cc}
\boldsymbol X & \boldsymbol Z^{\mathrm H} \\
\boldsymbol Z & \boldsymbol T(u) 
\end{array}\right] \succeq 0
\end{cases}</script><p>证明见5.4。</p>
<h5 id="5-4-相关证明"><a href="#5-4-相关证明" class="headerlink" title="5.4 相关证明"></a>5.4 相关证明</h5><p><strong>(一) 范德蒙德分解的证明</strong></p>
<p><strong>() $\boldsymbol z$存在于列空间的证明</strong></p>
<p>当$\boldsymbol T(\boldsymbol u)$满秩时，直接成立。当$\boldsymbol T(\boldsymbol u)$不满秩时，此时，可以看到：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cc}
x & \boldsymbol z^{\mathrm H} \\
\boldsymbol z & \boldsymbol T(\boldsymbol u) 
\end{array}\right] \succeq 0 
\Longleftrightarrow 
[ t \quad \boldsymbol y]^{\mathrm H} \left[\begin{array}{cc}
x & \boldsymbol z^{\mathrm H} \\
\boldsymbol z & \boldsymbol T(\boldsymbol u) 
\end{array}\right] \left[\begin{array}{c}
\boldsymbol t \\
\boldsymbol y
\end{array}\right] \geq 0, \forall t,\boldsymbol y \\
\Downarrow\\
 t^*x t + \boldsymbol y^{\mathrm H} \boldsymbol{z} t +  t^*\boldsymbol z^{\mathrm H}\boldsymbol y + \boldsymbol y^{\mathrm H} \boldsymbol T(\boldsymbol u) \boldsymbol y \geq 0</script><p>此时，取$\boldsymbol y$位于$\boldsymbol T(\boldsymbol u)$的零空间中，则上式进一步变为：</p>
<script type="math/tex; mode=display">
t^*x t + \boldsymbol y^{\mathrm H} \boldsymbol{z} t +  t^*\boldsymbol z^{\mathrm H}\boldsymbol y \geq 0</script><p>若$\boldsymbol z$不位于$\boldsymbol T(\boldsymbol u)$的列空间中，即$a = \boldsymbol y^{\mathrm H} \boldsymbol z \neq 0$，则：</p>
<script type="math/tex; mode=display">
t^*x t + a t +  t^*a^* \geq 0</script><p>此时，取$t = -\dfrac{a^*}{x}$，则有：</p>
<script type="math/tex; mode=display">
\dfrac{aa^*}{x^*} - \dfrac{aa^*}{x^*} - \dfrac{aa^*}{x^*} \geq 0</script><p>由于$x$必为非负实数(取$t = 1, y = 0$)，所以上式显然不成立，矛盾。得证。</p>
<p><strong>() 原子范数最小化的等价性证明</strong></p>
<p>记等价凸问题的目标函数为：</p>
<script type="math/tex; mode=display">
F=\dfrac{1}{2} x+\dfrac{1}{2} u_{1}</script><p>先证明：$F \leq ||\boldsymbol z||_{\mathcal A}$。</p>
<p>取$\boldsymbol z = \sum\limits_{k}c_k \boldsymbol a(f_k, \phi_k) = \sum\limits_{k}s_k \boldsymbol a(f_k)$，令$\boldsymbol T(\boldsymbol u) = \sum\limits_{k} c_k \boldsymbol a(f_k) \boldsymbol a^{\mathrm H}(f_k)$、$x = \sum\limits_k c_k$，则有：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cc}
x & \boldsymbol{z}^{\mathrm{H}} \\
\boldsymbol{z} & \boldsymbol{T}
\end{array}\right]=\sum_{k} c_{k}\left[\begin{array}{c}
\phi_{k}^* \\
\boldsymbol{a}\left(f_{k}\right)
\end{array}\right]\left[\begin{array}{c}
\phi_{k}^* \\
\boldsymbol{a}\left(f_{k}\right)
\end{array}\right]^{\mathrm{H}} \succeq 0</script><p>因此$\boldsymbol T$和$x$是一组可行解。那么其必然不小于最优解。而这组可行解对应的目标函数为：</p>
<script type="math/tex; mode=display">
\dfrac{1}{2} x+\dfrac{1}{2} u_{1} = \sum_k c_k</script><p>因此$F \leq ||\boldsymbol z||_{\mathcal A}$。</p>
<p>再证明：$F \geq ||\boldsymbol z||_{\mathcal A}$</p>
<p>设凸问题的最优解为$(\hat x , \hat u)$，对$\boldsymbol T (\hat u)$进行范德蒙德分解，得到参数 $(\hat r, \hat p_k, \hat f_k)$。根据之前的分析，$\boldsymbol z$必然在$\boldsymbol T(\hat u)$的列空间中，即：</p>
<script type="math/tex; mode=display">
\boldsymbol z = \sum_{k=1}^{\hat r} \hat c_k \boldsymbol a(\hat f_k, \hat\phi_k) = \sum_{k=1}^{\hat r} \hat s_k \boldsymbol a(\hat f_k)</script><p>进一步地，根据<a href="https://zhuyulab.blog.csdn.net/article/details/121942523">Schur补条件</a>：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cc}
x & \boldsymbol z^{\mathrm H} \\
\boldsymbol z & \boldsymbol T(u) 
\end{array}\right] \succeq 0 
\quad \Longleftrightarrow \quad
\hat x \geq \boldsymbol z^{\mathrm H}[\boldsymbol T(\boldsymbol{\hat u})]^{\dagger} \boldsymbol z = \sum_{k=1}^{\hat r}\dfrac{\hat c^2_k}{\hat p_k}</script><p>而$\hat{u}_{1}=\sum\limits_{k=1}^{\hat{r}} \hat{p}_{k}$，因此</p>
<script type="math/tex; mode=display">
\begin{aligned}
F & =\dfrac{1}{2} \hat{x}+\dfrac{1}{2} \hat{u}_1 \\
& \geq \dfrac{1}{2} \sum_{k} \dfrac{\hat{c}_{k}^2}{\hat{p}_{k}}+\dfrac{1}{2} \sum_k \hat{p}_{k} \\
& \geq \sum_{k} \hat{c}_{k} \\
& \geq\|\boldsymbol{z}\|_{\mathcal{A}} .
\end{aligned}</script><p>第一个不等号来自于Schur补条件。 第二个不等号来自于$\dfrac{1}{x}+x$的最大化问题。第三个不等式来自于$|| \boldsymbol z||_{\mathcal{A}}$的定义，即所有线性分解中，$\sum\limits_k c_k$的最小值。<br>至此， 得证：$F =|z|_{\mathcal{A}}$。</p>
<p><strong>()多维原子范数最小化的等价性证明</strong></p>
<p><strong>相关参考链接</strong></p>
<p>参考链接1：<a href="https://zhuyulab.blog.csdn.net/article/details/121867153">压缩感知的尽头: 原子范数最小化 - B417科研笔记 - CSDN</a><br>参考链接2：<a href="https://blog.csdn.net/qq_43553032/article/details/123857173">原子范数最小化(Atomic Norm Minimization) - 大灰煜 - CSDN</a><br>参考链接3：<a href="https://blog.csdn.net/qq_43553032/article/details/124083906">解耦原子范数最小化(Decoupled Atomic Norm Minimization) - 大灰煜 - CSDN</a><br>参考链接4：<a href="https://arxiv.org/pdf/1609.09596.pdf">Sparse Methods for Direction-of-Arrival Estimation - 杨在 - pdf</a>、<a href="https://sites.google.com/site/zaiyang0248">Zai Yang’s website</a><br>参考链接5：<a href="https://it.cha138.com/python/show-4698676.html">基于原子范数的深度展开网络实现</a><br>参考链接6：<a href="https://www.cnblogs.com/connorzx/p/4897207.html">原子范数及线谱估计</a><br>参考链接7：<a href="https://blog.csdn.net/weixin_43413559/article/details/128140473">原子范数初探：以到达角估计为例 - Turbo-shengsong的博客 - CSDN博客</a><br>参考链接8：<a href="https://blog.csdn.net/FDS99999/article/details/129861193">原子范数去噪及其在线谱估计中的应用 - 飞大圣的博客-CSDN博客</a> </p>
<h4 id="6-稀疏贝叶斯学习-SBL"><a href="#6-稀疏贝叶斯学习-SBL" class="headerlink" title="6. 稀疏贝叶斯学习(SBL)"></a>6. 稀疏贝叶斯学习(SBL)</h4><p><a href="https://blog.csdn.net/qq_23947237/article/details/90314230">稀疏贝叶斯学习 1 - 本帅哥屏蔽了凡人 - CSDN</a></p>
<p><a href="https://blog.csdn.net/code_Joe123/article/details/124125992">压缩感知学习总结及Matlab代码实现 - WinrenJoe - CSDN</a></p>
<p><a href="https://blog.csdn.net/qq_49277759/article/details/116999384">压缩感知、一阶范数、Lasso - CSDN</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/390844225">Basis Pursuit, LASSO, TV - SINK IN的文章 - 知乎</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>信号处理与雷达</category>
        <category>信号与系统</category>
      </categories>
      <tags>
        <tag>数字信号</tag>
        <tag>压缩感知</tag>
        <tag>稀疏恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>性格与为人处事</title>
    <url>/2022/05/06/Character-and-conduct/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="792c533be91d17f35d9da6a79d77d3f02a9b918a406570514f34ccbe69fdbe96">270cb3bbed971930ec4ebcba9f8cc1380ece294f8f2a7e7ee3a18ece7aac93473c0ee2b0c4c1f4481ca275ad6eb739682c3ac37a8376afcaac5b162a9ed31c612bc0397ee6e502e6743dbe0e27c9caaf30e999230722fa2ff71a7cfd86f5c0a80b93cb30eb847792a9c9dadfdc253366b6f3e11b70997ad1021e723690b3268f39f93371de53b37b329541f1ab5a15f8bd9634c92f9b4afc0633a1b5994c760b3576959970ccbcdc42e3745c53428eeb0ce17c72c00c89bdf8617ec12a6025571dce63ba5da60a555a749ffa7c3d915083f890c73722b0833130acba3c635295dab301248f25d7575ca523db53569a730641751a887077ad4bf351ea77b67c71b2b70c919d1801b7a9924ae38b60f573</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>生活休闲</category>
        <category>心性与改善</category>
      </categories>
      <tags>
        <tag>性格</tag>
        <tag>做事</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学速成课</title>
    <url>/2024/07/29/Crash-Course-Computer-Science/</url>
    <content><![CDATA[<h3 id="1-计算机早期历史"><a href="#1-计算机早期历史" class="headerlink" title="1 计算机早期历史"></a>1 计算机早期历史</h3><h4 id="1-1-计算机的重要性"><a href="#1-1-计算机的重要性" class="headerlink" title="1.1 计算机的重要性"></a>1.1 计算机的重要性</h4><p>计算机是当今世界的命脉，如果突然关掉所有计算机，那么世界将会直接乱套。我们生活中很多产品也都是依靠计算机生产出来的。所以说，<strong>计算机改变了我们生活几乎所有方面，计算机对我们社会的重要性不言而喻。</strong></p>
<h4 id="1-2-计算机的发展"><a href="#1-2-计算机的发展" class="headerlink" title="1.2 计算机的发展"></a>1.2 计算机的发展</h4><p>略。。。</p>
<h3 id="2-电子计算机"><a href="#2-电子计算机" class="headerlink" title="2 电子计算机"></a>2 电子计算机</h3><p>上节提到，用于特定场景的计算设备，如制表机，大大提高了企业和政府的工作效率。但是随着社会的发展，交通运输、科学研究甚至航空航天等发展，人民需要计算能力更强的机器。这种计算能力更强的机器，往往体积巨大，耗电量巨大，这为后面的创新埋下伏笔。</p>
<h4 id="2-1-传统大型计算机的缺点"><a href="#2-1-传统大型计算机的缺点" class="headerlink" title="2.1 传统大型计算机的缺点"></a>2.1 传统大型计算机的缺点</h4><p>传统计算机主要有<strong>两个缺点</strong></p>
<ul>
<li>运算速度慢，进行普通的加减乘除的耗时都很长；</li>
<li>齿轮等计算机机械组件磨损，导致早期计算机容易出现Bug。</li>
</ul>
<p>最大的机电计算机是<strong>哈佛马克一号</strong>，由IBM公司完成，它由着数十万组件、上百万连接点和几百英里的导线，这台机器最早是用于给“曼哈顿计划”跑模拟。这台机器的大脑是<strong>继电器。</strong></p>
<p><strong>什么是继电器</strong></p>
<p>继电器是用电控制的机械开关。继电器有根“控制线路”，控制电路是开还是关。当螺线圈通过电时，其会产生磁场，吸引上面的线闭合，达到连通的目的。这个继电器可以用于机器进行控制。</p>
<p><img src="https://pic.imgdb.cn/item/66a75235d9c307b7e9f96b38.png"></p>
<p>糟糕的是，继电器开关有一定质量，这会影响其闭合。其一秒能够闭合50次，<strong>导致计算机的运算非常慢（完成一次加减乘除需要几秒钟）</strong>。</p>
<p><strong>除了速度慢，另一个限制是齿轮磨损。</strong>随着机器的不断运行，器件的磨损不可避免。哈佛马克一号有上千的继电器，任何一个发生故障，就会导致计算出错。</p>
<p>此外，黑色的温暖的环境，也会使虫子滋生。虫子，英文命Bug。<strong>虫子附着在大型计算机的组件上，会导致其运行出错。那么，机器故障（Bug）的来源也是此。</strong></p>
<h4 id="2-2-电子管"><a href="#2-2-电子管" class="headerlink" title="2.2 电子管"></a>2.2 电子管</h4><p>显然，未来要想继续制造出更强大的计算机，就必须用其他东西代替继电器。幸运的是，一个新的电子组件出现了——“<strong>热电子管</strong>”。这种电子管只能运行电流单向运动，当电流反向时，电子管不能发光。这种管叫“<strong>二极管</strong>”。</p>
<p>但是，要怎么利用电子管进行开关控制呢？答案就是——<strong>真空三极管</strong></p>
<p>聪明的人民在二极管中添加了一根导线。利用这跟导线，可以控制向电子添加正电荷或者负电荷，来控制电流的流通。</p>
<p><img src="https://pic.imgdb.cn/item/66a75337d9c307b7e9fa5127.png" alt="三极管" style="zoom:50%"></p>
<p>三极管和继电器有着相同的功能，但是由于没有部件的物理移动，所以它的磨损很少，开闭速度可以达到上千次每秒。这种真空三极管，在电子设备中大量运用，持续了近半个世纪。</p>
<p>刚开始时，这种三极管造价昂贵，而且一个计算机需要上千个电气开关。不过随着时间推移，一些政府部门可以承担这种价格，这种三极管开始应用计算机。标志着<strong>计算机从机电转向电子。</strong></p>
<h4 id="2-3-电子计算机"><a href="#2-3-电子计算机" class="headerlink" title="2.3 电子计算机"></a>2.3 电子计算机</h4><p>世界上第一台电子计算机造成于英国，名叫<strong>“巨人一号”</strong>，它有1600个真空管。最初是英国政府用来破解纳粹的通信加密密码的。<strong>巨人，被认为是第一个可编程的计算机。</strong></p>
<p><strong>世界上第一个真正的通用的可编程计算机，是ENIAC。</strong>不过由于真空管很多，它几乎半天就会出现一次故障。</p>
<h4 id="2-4-晶体管"><a href="#2-4-晶体管" class="headerlink" title="2.4 晶体管"></a>2.4 晶体管</h4><p>为了降低成本和大小，同时提高可靠性和速度，我们需要一种新的电子开关。<strong>1947年，贝尔实验室发明了晶体管（晶体三极管）。</strong>一个全新的计算机时代来临了。</p>
<p><img src="https://pic.imgdb.cn/item/66a764fdd9c307b7e90b4dd4.png" alt="晶体管" style="zoom:50%"></p>
<p>晶体管的物理性特别复杂，涉及到量子力学。简单地来说，晶体管的制造需要半导体材料，通过控制基极电荷，控于控制半导体材料的导电性，来是否允许电流的流动。</p>
<p>晶体管具有很好的开关速度，且其为固态的，比起易碎的玻璃电子管。其体积也远小于继电器或者真空管。<strong>这样我们就能制造出更小更便宜的计算机</strong>。</p>
<p>如今，晶体管小至几十纳米，运算次数达到几十上百万，并且有几十年的寿命。</p>
<h3 id="3-布尔逻辑和逻辑门"><a href="#3-布尔逻辑和逻辑门" class="headerlink" title="3 布尔逻辑和逻辑门"></a>3 布尔逻辑和逻辑门</h3><h4 id="3-1-什么是二进制"><a href="#3-1-什么是二进制" class="headerlink" title="3.1 什么是二进制"></a>3.1 什么是二进制</h4><p>前文我们提到，计算机最早是机电设备，一般用十进制计数，比如用齿轮数代表十进制，再到晶体管计算机。</p>
<p>幸运的是，只用开关两种状态也可以代表信息。这种叫做<strong>二进制，意思是用两种状态表示</strong>。</p>
<p>你可能认为只用两种状态能表示的信息不多，不过这对计算机来说有很多好处。对于电子元件：电路闭合，有电流通过，代表真；电路断开，无电流通过，代表假。二进制也可以写成0和1。</p>
<h4 id="3-2-为什么使用二进制？"><a href="#3-2-为什么使用二进制？" class="headerlink" title="3.2 为什么使用二进制？"></a>3.2 为什么使用二进制？</h4><ul>
<li>二进制表示的状态相对于其他进制更容易区分。</li>
<li>二进制已经有一个专门研究的数学分支——<strong>布尔代数</strong>，在此方面已经有较大的发展了。</li>
</ul>
<p>当初，一些早期的计算机是三进制的，甚至是五进制的。问题是状态越多，越难区分不同的状态，信号可能会发生交叠。所以，<strong>我们用信号的开和闭，尽可能地减少这种问题</strong>。</p>
<p><strong>另一个使用二进制的原因，就是有一整个数学分支，专门处理“真”和“假”</strong>。它已经解决了所有法则和符号问题，这个数学分支叫“<strong>布尔代数</strong>”。</p>
<h4 id="3-3-布尔代数及基本逻辑门单元"><a href="#3-3-布尔代数及基本逻辑门单元" class="headerlink" title="3.3 布尔代数及基本逻辑门单元"></a>3.3 布尔代数及基本逻辑门单元</h4><p>布尔代数的基本单元不是数学中的数字，而是<strong>非（NOT）</strong>，<strong>与（AND）</strong>、<strong>或（OR）</strong>和<strong>异或（XOR）</strong>等。那么这几种符号的作用，学数字电路中已经接触很多了。下面简单这几种逻辑门介绍：</p>
<p><strong>非（NOT）</strong>：输出与输入相反，输入真，输出假，反之亦然。<br><strong>与（AND）</strong>：两个输入仅同真输出真，若有一假则为假。<br><strong>或（OR）</strong>：两个输入只要有一个是真，则输入为真。<br><strong>异或（XOR）</strong>：两输入相异则输出真，两输入相同则输出假。 </p>
<p>不过，设计师在设计电路和芯片时，不需要考虑这些晶体管是如何设计或电子是怎么流过半导体的。他们需要考虑的是抽象层次的东西，很少在晶体管层次考虑，而是考虑逻辑门或者更大的组件。 </p>
<h3 id="4-二进制"><a href="#4-二进制" class="headerlink" title="4 二进制"></a>4 二进制</h3><h4 id="4-1-二进制的数字表示"><a href="#4-1-二进制的数字表示" class="headerlink" title="4.1 二进制的数字表示"></a>4.1 二进制的数字表示</h4><p>要想表示更多的信息，就要增加数字表示的位数，类似十进制那样。多位数字，如“263”，就能表示比10更大的数。这种逢十进一的数字表示方法，就是十进制（基于十的表示法）。</p>
<p><strong>二进制也一样，它是基于2的表示法，其只有两个数字，0和1。</strong>多位二进制表示法，应该按权值展开，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/66a769b9d9c307b7e91029b0.png" style="zoom:50%"></p>
<h4 id="4-2-二进制的加法"><a href="#4-2-二进制的加法" class="headerlink" title="4.2 二进制的加法"></a>4.2 二进制的加法</h4><p>二进制的加法和十进制一样，满足条件则进一。如下图的二进制加法。</p>
<p><img src="https://pic.imgdb.cn/item/66a76a20d9c307b7e910750f.png" style="zoom:50%"></p>
<h4 id="4-3-字节"><a href="#4-3-字节" class="headerlink" title="4.3 字节"></a>4.3 字节</h4><p>二进制中，一个1或0叫做一位，即一个位(bit)有两个不同状态0和1，<strong>8位叫做一个字节</strong>。即1字节=8位。我们的32为或64位电脑，指的是一次能进行32位的或64位的同时计算。</p>
<p>除了字节外，还有KB、MB和TB等，转化关系如下表所示。</p>
<script type="math/tex; mode=display">
1 \text{ Byte} = 8 \text{ bit} \\
1 \text{ KB} = 2^{10} \text{ Byte} \\
1 \text{ MB} = 2^{10} \text{ KB} \\
1 \text{ GB} = 2^{10} \text{ MB} \\
1 \text{ TB} = 2^{10} \text{ GB}</script><h4 id="4-4-计算机中的正负表示"><a href="#4-4-计算机中的正负表示" class="headerlink" title="4.4 计算机中的正负表示"></a>4.4 计算机中的正负表示</h4><p>计算机中，大多<u>用第一位表示正负，1是负，0是正</u>。</p>
<p>后面，我们还会讲到，计算机会给内存中的每一个位置，做一个标记，这个标记叫位址，目的是为了方便存取数据。因为现在的数据量越来越大，内存地址也有64位。</p>
<h4 id="4-5-计算机中的浮点数"><a href="#4-5-计算机中的浮点数" class="headerlink" title="4.5 计算机中的浮点数"></a>4.5 计算机中的浮点数</h4><p>我们有几种方法表示浮点数，最常用的是<strong><font color="red">IEEE 754标准</font></strong>。它用类似科学计数法的方法，来存十进制数。对于32位浮点数，第一位表示正负，后面8位表示指数，最后23位表示有效数。</p>
<p>例如，$625.9 = 0.6259*10^3$，其中，$6259$为有效位数，$3$是指数，其在计算机中的表示如下图。</p>
<p><img src="https://pic.imgdb.cn/item/66a76dafd9c307b7e9131b3f.png" style="zoom:50%"></p>
<h4 id="4-6-ASCII-计算机中的文字表示"><a href="#4-6-ASCII-计算机中的文字表示" class="headerlink" title="4.6 ASCII-计算机中的文字表示"></a>4.6 ASCII-计算机中的文字表示</h4><p>不同于书面用符号来表示文字信息，计算机中用数字表示文字。一种方法是，用1表示A，2表示B，3表示C，以此类推。美国科学家曾用5位来表示字母，因为$2^5$为32，这对26个字母来说够了，但这不能表示标点符号、数字和大小写字母。</p>
<p><strong>ASCII，美国信息交换标准代码</strong>，发明于1963年，ASCII码是7位代码，足够存储128个不同的值。扩展范围后，足够表示大小写字母、数字和标点符号等。</p>
<p>因为ASCII码值发明地较早，所以被广泛使用，这样，可以让不同公司制作的计算机，能够交换数据。这种交换信息的能力叫互用性。我们知道一个字节有8位，在值为128以后的数字，可以由各国自己根据情况使用。在美国，这些额外的数字主要用于编码附加符号，比如数字符号，图形元素和常用的重音字符，而在希腊，则用于表示希腊字母等。 </p>
<h4 id="4-7-Unicode-解决不同标准编码下的乱码问题"><a href="#4-7-Unicode-解决不同标准编码下的乱码问题" class="headerlink" title="4.7 Unicode-解决不同标准编码下的乱码问题"></a>4.7 Unicode-解决不同标准编码下的乱码问题</h4><p>不过虽然ASCII码已经能很好地应用于计算机了，但是对于亚洲一些国家（如中国和日本），他们有着上千的文字，ASCII码显然不够用。此外，各个国家设置了相应的字符编码表，但是互不兼容。<strong>字码不兼容的问题经常出现，以致于出现一个专门形容这种情况的名词，“mojibake”，意为“乱码”。</strong></p>
<p>所以，<strong>Unicode</strong>诞生了，统一了所有的编码标准，设计于1992年，解决了不同国家不同标准的问题，Unicode用一个统一的编码。最常见的Unicode是16位的，有超过一百万个位置，这对所有语言的字符都够用了，能很好地<strong>解决字符不兼容导致乱码的问题</strong>。</p>
<p>对于其他格式的信息如MP3或GIF，就像ASCII用二进制表示字母一样，我们用二进制编码声音/颜色，表示照片，电影和音乐。</p>
<p>最后，我们要知道，对于计算机，网页、短信、视频甚至操作系统，都是一长串01字符。</p>
<h3 id="5-算术逻辑单元"><a href="#5-算术逻辑单元" class="headerlink" title="5 算术逻辑单元"></a>5 算术逻辑单元</h3><h4 id="5-1-什么是ALU"><a href="#5-1-什么是ALU" class="headerlink" title="5.1 什么是ALU"></a>5.1 什么是ALU</h4><p>上一节课我们提到如何用二进制表示数据，如010表示2等。我们知道，<strong>表示和存储数据</strong>是计算机的重要功能。但真正的目标是计算处理有意义的数据，这些操作由计算机的“<strong>算术逻辑单元</strong>”处理，简称<strong>ALU</strong>。</p>
<p>ALU是计算机的数学大脑，理解了ALU的设计和功能后，你就理解了现代计算机的基石。ALU就是计算机中负责运算的组件，基本上其他组件都需要用到它。</p>
<p>最著名的ALU，就是<strong>英特尔的74181</strong>，1970年发布，是第一个封装在单个芯片内的完整ALU。</p>
<p><img src="https://pic.imgdb.cn/item/66a773cad9c307b7e917a162.png" alt="英特尔的74181芯片" style="zoom:40%"></p>
<p>接下来，我们将利用我们之前学过的逻辑门，设计一个功能与74181相同的组件，然后甚至用此设计CPU。 </p>
<h4 id="5-2-ALU单元之一：算术单元"><a href="#5-2-ALU单元之一：算术单元" class="headerlink" title="5.2 ALU单元之一：算术单元"></a>5.2 ALU单元之一：算术单元</h4><p>ALU有两个单元，1个算术单元，1个逻辑单元。</p>
<h5 id="5-2-1-什么是算术单元"><a href="#5-2-1-什么是算术单元" class="headerlink" title="5.2.1 什么是算术单元"></a>5.2.1 什么是算术单元</h5><p><strong>算术单元负责计算机里的所有数字操作</strong>，比如加减法，或者给某个数+1（这个叫增量运算），不过今天我们重点要理解的是加法运算。</p>
<p>设计时，我们不在晶体管层次出发，而是用更高层的抽象——逻辑门。我们需要用到<strong>AND，OR，NOT和XOR</strong>逻辑门。</p>
<h5 id="5-2-2-半加器"><a href="#5-2-2-半加器" class="headerlink" title="5.2.2 半加器"></a>5.2.2 半加器</h5><p>对于二进制加法，1+0=1，0+1=1，0+0=0，1+1=10。如下图：</p>
<p><img src="https://pic.imgdb.cn/item/66a77525d9c307b7e918a958.png" style="zoom:50%"></p>
<p>我们只看前三个和第四个的第一位，发现它和异或（XOR）操作一样。不过对于1+1，我们还需要一个进位，这里就用到了与操作（AND）。设计如下： </p>
<p><img src="https://pic.imgdb.cn/item/66a775c4d9c307b7e9191ae8.png" style="zoom:50%"></p>
<p>它只能处理一位计算，我们称为半加器。我们也可以将其封装起来，变成只有输入和输出的“黑盒操作”，如下图： </p>
<p><img src="https://pic.imgdb.cn/item/66a77602d9c307b7e9194c2c.png" style="zoom:50%"></p>
<h5 id="5-2-3-全加器"><a href="#5-2-3-全加器" class="headerlink" title="5.2.3 全加器"></a>5.2.3 全加器</h5><p>如果想要处理超过1+1的运算，我们需要“全加器”。半加器输出了进位，着意味着，我们处理时，还需要将进位考虑进去，才能设计全加器。</p>
<p>全加器要考虑三位数字的和，如下图所示。全加器有三输入（这里是ABC），两输出（进位和总和）。</p>
<p><img src="https://pic.imgdb.cn/item/66a7769fd9c307b7e91af540.png" style="zoom:50%"></p>
<p>我们可以用半加器进行A+B，再把C输入到第二个半加器上，然后用一个或门（OR）计算进位，最终我们得到<strong>全加器</strong>。设计如下： </p>
<p><img src="https://pic.imgdb.cn/item/66a776ced9c307b7e91b19f8.png" style="zoom:50%"></p>
<p>我们一样可以将全加器封装起来，这样只能看到输入（ABC）和输出（SUM总和，CARRY进位），方便我们进行更高层次的设计。 </p>
<p><img src="https://pic.imgdb.cn/item/66a7771cd9c307b7e91b52c1.png" alt="全加器" style="zoom:50%"></p>
<h5 id="5-2-4-8位加法器设计"><a href="#5-2-4-8位加法器设计" class="headerlink" title="5.2.4 8位加法器设计"></a>5.2.4 8位加法器设计</h5><p>有了全加器，我们可以进行多位加法器设计。这主要是利用半加器和全加器进行，刚开始因为没有高位的进位，我们使用半加器，接下来我们全部使用全加器，因为需要考虑进位。如下图：</p>
<p><img src="https://pic.imgdb.cn/item/66a777b1d9c307b7e91bcab4.png" alt="8位加法器(行波进位加法器)" style="zoom:40%"></p>
<p>因为是一个进位一个进位地往下输入的，所以叫“8位行波进位加法器”，当然，最后一位可能会发生进位，<strong>表示相加的两个数字和太大了，超过了8位，这叫做“溢出”</strong>。这会导致错误和不可预测的结果。</p>
<p>我们可以用更多的全加器，可以操作16位或32位数字，让溢出更难发生。不过代价是更多的逻辑门和更多的耗时。所以，现代电路用的加法器不同，叫“<strong><font color="blue">超前进位加法器</font></strong>”。</p>
<p>简单的ALU单元可以进行多种加减操作，如半加、全加、减法、增1等，但是没有乘除操作。这是因为，简单的ALU没有专门的电路来处理，而是<strong>把乘法用多次加法来实现</strong>。不过对于强大的手机和电脑，有专门的乘法处理电路。没有多困难，只是逻辑门更多，造价更昂贵而已。</p>
<h4 id="5-3-ALU单元之二：逻辑单元"><a href="#5-3-ALU单元之二：逻辑单元" class="headerlink" title="5.3 ALU单元之二：逻辑单元"></a>5.3 ALU单元之二：逻辑单元</h4><p>现在，我们讲ALU的另一部分，逻辑单元。逻辑单元执行逻辑操作，比如之前的AND，OR和NOT等操作。它也能做一些简单的判断，比如结果是不是0，是否为负数等。</p>
<p>例如下图就是检查ALU输出是不是0的电路，很简单，多个或操作，然后最后取反便可，因为只有输出位数全为0，结果才为0。</p>
<p><img src="https://pic.imgdb.cn/item/66a779b3d9c307b7e91d53b3.png" alt="判断输入是否为0" style="zoom:40%"></p>
<p>前面我们讲的英特尔公司发明的74181，不过只能处理4位输入，也就是说，我们做了一个比英特尔74181还好的ALU！！ </p>
<p><img src="https://pic.imgdb.cn/item/66a77a51d9c307b7e91dc287.png" alt="英特尔74181内部结构" style="zoom:60%"></p>
<h4 id="5-4-ALU"><a href="#5-4-ALU" class="headerlink" title="5.4 ALU"></a>5.4 ALU</h4><p>74181用了大概70个逻辑门，但不能执行乘法操作。但它向小型化迈出了一大步，可以让计算机更强大更便宜。ALU需要大量的逻辑，我们用一个符号来代替，它看起来像一个大“V”，如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/66a77b3dd9c307b7e91e661c.png" style="zoom:30%"></p>
<p>ALU有两个8位的输入，然后用一个操作代码来控制其是加法还是减法操作，操作代码告诉ALU进行什么操作。</p>
<p>ALU的输出是8位的，ALU还输出一堆标志（Flag）。一些操作介绍如下：</p>
<ul>
<li><strong>ZERO</strong>：若ALU输出是0，那么ZERO标志就变成1。</li>
<li><strong>NEGATIVE</strong>：我们可以用ALU做减法，然后用NEGATIVE判断其是不是小于0，从而进行比较大小。</li>
<li><strong>OVERFLOW：</strong>ALU还有溢出单元，判断有没有进位。</li>
</ul>
<p>ALU有很多Flag，这三个是最常用的。</p>
<h3 id="6-寄存器与内存"><a href="#6-寄存器与内存" class="headerlink" title="6 寄存器与内存"></a>6 寄存器与内存</h3><p>上节课，我们用逻辑门做了一个简单的ALU，它能执行算术运算（Arithmetic）和逻辑运算（Logic），ALU里的A和L因此得名。当然，算出来后将结果扔掉的话那就没什么意义了，得找个办法存起来，这就需要用到计算机的内存了。</p>
<h4 id="6-1-计算机中的存储器"><a href="#6-1-计算机中的存储器" class="headerlink" title="6.1 计算机中的存储器"></a>6.1 计算机中的存储器</h4><p>当我们正在使用电脑时，比如打游戏、看视频，如果突然断开电源，进度将会中断且不难复原。我们会损失数据的原因是，电脑使用的是“随机存取存储器”，简称“RAM”。它只能在有电的情况下存储东西。</p>
<p>另一种存储叫持久存储，关掉电脑数据也不好丢失。</p>
<p>本节课，我们将从简单开始，做出存储1的器件，之后再扩大，做出我们的内存模块。下次再和ALU结合，做出CPU。</p>
<h4 id="6-2-存储器的原理与制作"><a href="#6-2-存储器的原理与制作" class="headerlink" title="6.2 存储器的原理与制作"></a>6.2 存储器的原理与制作</h4><h5 id="6-2-1-存0电路与存1电路"><a href="#6-2-1-存0电路与存1电路" class="headerlink" title="6.2.1 存0电路与存1电路"></a>6.2.1 存0电路与存1电路</h5><p><strong>(1) 存1电路</strong></p>
<p>至今，我们所说的电路都是单向的，总是向前流动，但是我们也可以把输出连回输入。如下图所示的连法，当输出是1后，无论输入是0还是1，因为将输出连回了输入，最终的输出都是1。那么，<strong>这个电路元件就可以存储1</strong>。<em><u>然而问题是，无论怎么试，都没法将1变回0</u></em>。</p>
<p><img src="https://pic.imgdb.cn/item/66a77dfcd9c307b7e9205c36.png" alt="存1电路"></p>
<p><strong>(2) 存0电路</strong></p>
<p>那么，我们来看看将这个电路里的OR门换成AND门会怎么样，如图。当输出是0后，无论再对A输入0还是1，输出都是0，就是说，<strong>这个电路了可以存储0</strong>。这里就不绘制动态分析过程了，可参照存0电路。</p>
<p><img src="https://pic.imgdb.cn/item/66a77e93d9c307b7e920c18b.png" alt="存0电路" style="zoom:30%"></p>
<h5 id="6-2-2-锁存器与门所"><a href="#6-2-2-锁存器与门所" class="headerlink" title="6.2.2 锁存器与门所"></a>6.2.2 锁存器与门所</h5><p><strong>(1) 锁存器</strong></p>
<p>现在，我们用了存1存储器和存0存储器了，我们将其都利用起来，如下图，这个叫做“<strong>AND-OR锁存器</strong>”。它有两个输入，“设置”输入，把输出变成1，“复位”输入把输出变成“0”。如果“设置”和“复位”都是0，电路会输出最后放入的内容。这就是说它存住了一位的信息，这叫“锁存”，因为他锁住了一个值。</p>
<p><img src="https://pic.imgdb.cn/item/66a77f3fd9c307b7e9212f7e.png" alt="锁存器示意图" style="zoom:40%"></p>
<ul>
<li>若<code>SET=1,RESET=0</code>，则输出为1；</li>
<li>若<code>SET=0,RESET=1</code>，则输出为0；</li>
<li>若<code>SET=0,RESET=0</code>，则输出不变，也即会保存上一个状态的输出，也即它锁住了1位的信息（<strong>存储</strong>）；</li>
<li>若<code>SET=1,RESET=1</code>，则输出为0，个人认为这种操作没有什么太大的意义；</li>
</ul>
<p><strong>放入数据的操作叫“写入”，拿出数据的操作叫读取。</strong> </p>
<p><strong>(2) 门锁</strong></p>
<p>麻烦的是，用两条线“设置”和 “复位”来输入，有点难理解。为了更容易用，我们希望只有一条输入线，进行输入数据。然后设置另一条线，叫允许写入线，用来启用内存，启用时允许写入，没启用时就锁定。外加一些逻辑门，就可以做出这个电路。这个叫<strong>门锁，因为门可以打开和关上。</strong></p>
<p><img src="https://pic.imgdb.cn/item/66a7818fd9c307b7e922d709.png" alt="门锁示意图" style="zoom:50%"></p>
<p>其中，DATA INPUT表示输入要保存的数据；WRITE ENABLE表示允许写入线，此线输入1时为启用(允许写入数据)，此线输入为0时为锁定(存储数据，此时不论DATA INPUT如何变输出都不变)。</p>
<p>但是，我们不想直接面对这个电路，我们想用一个“黑盒”将其框住，这就成为了一个组件。这个门锁只有当“允许写入线”为1时才可以写入和输出数据。 </p>
<p><img src="https://pic.imgdb.cn/item/66a782b2d9c307b7e923c022.png" style="zoom:40%"></p>
<h5 id="6-2-3-寄存器"><a href="#6-2-3-寄存器" class="headerlink" title="6.2.3 寄存器"></a>6.2.3 寄存器</h5><p>虽然一个门锁只能存储一位数字，但是我们并排放8个锁存器，就可以存8位信息。</p>
<p>一组这样的锁存器叫“<strong><font color="green">寄存器</font></strong>”，寄存器能存储一个数字，这个数字有多少位，叫位宽。</p>
<p>早期计算机用8位寄存器，后来到16位、32位和如今的64位。</p>
<p>写入寄存器时，我们需要先将所有的“允许写入线”设为1，这里我们可以引一条总线统一控制。然后我们将数据输入，完成输入后再将所有的“允许写入线”设为0。</p>
<p><img src="https://pic.imgdb.cn/item/66a78464d9c307b7e9251a30.png" alt="8位寄存器" style="zoom:40%"></p>
<h5 id="6-2-4-矩阵网络优化门锁放置"><a href="#6-2-4-矩阵网络优化门锁放置" class="headerlink" title="6.2.4 矩阵网络优化门锁放置"></a>6.2.4 矩阵网络优化门锁放置</h5><p>如果只有很少的位(bits)，把锁存器并排放置，也勉强够用了。64 位寄存器要 64 根数据线，64 根连到输出端，幸运的是，我们只要1根线(“总线”)启用所有锁存器，但加起来也有 129 条线了。如果存 256 位要 513 条线！非常耗材。</p>
<p>解决方法就是<strong>矩阵</strong>，在计算机中，<strong>寄存器并不并排放，而是成矩阵网络</strong>。存256位的寄存器，就将门锁摆成16*16形式，要用某个寄存器，就打开想应的行线和列线。</p>
<p><img src="https://pic.imgdb.cn/item/66a785c9d9c307b7e92629c4.png" alt="门锁矩阵网络" style="zoom:40%"></p>
<p>要启用某个锁存器，就打开相应的行线和列线，放大看看怎么做的。</p>
<p>我们只想打开交叉处锁存器的”允许写入线”，所有其他锁存器，保持关闭。我们可以用 AND 门！只有行线和列线均为1，AND门才输出 1。所以可以用选择单个锁存器，这种行/列排列法，用一根“允许写入线(总线)”连所有锁存器。</p>
<p><img src="https://pic.imgdb.cn/item/66a787cfd9c307b7e9279e4b.png" alt="放大示意图" style="zoom:50%"></p>
<p>为了让锁存器变成“允许写入”，行线，列线和“允许写入线”都必须是 1，每次只有行列号对应的那1个锁存器会这样。同时，有了这种电路连接结构，使得我们可以只用一根”数据线”(类似于允许写入线的总线)连所有锁存器来传数据，因为只有一个锁存器会启用，只有那个会存数据。其他锁存器会忽略数据线上的值，因为没有“允许写入”。</p>
<p>我们可以用类似的技巧，做<strong>“允许读取线(READ ENABLE)”</strong>来读数据。</p>
<p>所以对于 256 位的存储只要 35 条线，具体计算如下：</p>
<script type="math/tex; mode=display">
1条数据线 + 1条允许写入线 + 1条允许读取线 + 16条行线 + 16条列线 = 35条线</script><p>不过，我们怎么将计算机的二进制数据传给这个“矩阵”呢？因此，我们需要用到<strong>多路复用器</strong>，它能够连通所给输入对应的线，比如若输入“1010”，那么多路复用器就会将第10路连通，达到选线路的目标。 </p>
<p><img src="https://pic.imgdb.cn/item/66a78ac5d9c307b7e929d0e7.png" alt="多路复用器" style="zoom:60%"></p>
<p>那么，更高的一层抽象来了，256位内存，如下。其分别有上文提到的8位地址线、数据线、允许写入线和允许读取线： </p>
<p><img src="https://pic.imgdb.cn/item/66a78b91d9c307b7e92a7601.png" alt="256位寄存器的抽象" style="zoom:50%"></p>
<p>这样，我们就做成了一个内存了。</p>
<h4 id="6-3-如何利用多个内存完成数据存取"><a href="#6-3-如何利用多个内存完成数据存取" class="headerlink" title="6.3 如何利用多个内存完成数据存取"></a>6.3 如何利用多个内存完成数据存取</h4><p>利用这个256位的内存，我们可以存许多数据。具体的存法如下：</p>
<p><img src="https://pic.imgdb.cn/item/66a78cb4d9c307b7e92b5b80.png" style="zoom:60%"></p>
<p>我们将8个256位的内存并排在一起，用同样地址线将其连接。那么，一个内存可以存一位（<strong>单独</strong>），8个并在一起就可以<em><u>同时存8位（1Byte）</u></em>。<strong>为了存8位的数据，我们给8个内存同样的地址，也就是一个8位数据，分给8个内存分别存储</strong>。因为是256位的内存，所以可以存256个八位，也就是<strong>256 Byte</strong>的数据。 </p>
<p>我们将其抽象，也就是说，这8给内存，可以有256有地址，每个地址可以读写一个8位数据。 </p>
<p><img src="https://pic.imgdb.cn/item/66a78d5ad9c307b7e92be137.png" style="zoom:60%"></p>
<p>内存的一个重要特征是可以随时访问任何位置，因此叫“<strong>随机存取存储器</strong>”（RAM），RAM就像人类的短期记忆，记录计算机当时正在干嘛。 </p>
<p><img src="https://pic.imgdb.cn/item/66a7901dd9c307b7e92e37aa.png" style="zoom:70%"></p>
<p>上面真实的内存条中，有8颗芯片，每个芯片有32个内存方块，每个内存方块4个矩阵，所以1个方格有8192×4=32768位，总之，总位数约为：</p>
<script type="math/tex; mode=display">
32768 \times 32 \times 8 = 8388608 ≈ 800 \text{万位} ≈ 1 \text{兆字节}</script><p>所以，这节课，我们做了一个SRAM（<strong>静态随机存取存储器</strong>），还有其他比如DRAM、闪存等等，他们在功能上与SRAM相似，但用不同的电路存单个位，比如用不同的逻辑门、电容器、电荷捕获或忆阻器等等。但根本上，这些技术都是矩阵层次嵌套，来存储大量信息。</p>
<p>就像计算机中的很多事情，底层其实都很简单。让人难以理解的是一层层精妙的抽象，像一个越来越小的俄罗斯套娃。</p>
<h3 id="7-中央处理器CPU"><a href="#7-中央处理器CPU" class="headerlink" title="7 中央处理器CPU"></a>7 中央处理器CPU</h3><h4 id="7-1-CPU与指令"><a href="#7-1-CPU与指令" class="headerlink" title="7.1 CPU与指令"></a>7.1 CPU与指令</h4><p>前面课程已经提到，我们已经做了一个算术逻辑单元（ALU），输入二进制，它会执行计算。我们还做了两种内存：寄存器，很小的内存，能存一个值；RAM，能在不同地址存大量数字。现在，我们是时候把他们放在一起，组建计算机的“心脏”了，<strong>这个“心脏”叫“中央处理单元”，简称CPU。</strong></p>
<p>CPU负责执行程序，这些程序可能是浏览器、社交软件和音乐等等。这些程序是由一个个操作组成的，这种“操作”叫“指令”，因为它“指示”计算机要做什么。如果是计算指令如加或者减，CPU会让ALU进行数学运算。也可能是内存指令，CPU会和内存通信，然后读/写值。</p>
<p>当我们用一条线连接两个组件时，这条线只是所有必须线路的一个抽象，这种高层次视角叫”微体系架构“。意思就是，我们从微观部件考虑整体同类型部件，以更高抽象层次去看代问题。</p>
<h4 id="7-2-CPU指令体系"><a href="#7-2-CPU指令体系" class="headerlink" title="7.2 CPU指令体系"></a>7.2 CPU指令体系</h4><p>我们已经知道数据是以二进制值存在内存里，程序也可以存在内存里。我们可以给CPU 支持的所有指令，分配一个 ID，下图为计算机指令表。下表中，我们看到，前四位存储指令的”操作代码“，如0010、0001等，后面四位代表数据来源于哪里（地址或者寄存器）</p>
<p><img src="https://pic.imgdb.cn/item/66a793ecd9c307b7e931919c.png" alt="CPU指令表" style="zoom:40%"></p>
<p>我们还需要两个寄存器来完成CPU指令<strong>，一个寄存器追踪程序运行到哪了</strong>，我们叫它”指令地址寄存器“，顾名思义，存当前指令的内存地址。<strong>另一个寄存器存当前指令</strong>，叫”指令寄存器“。指令体系如下： </p>
<p><img src="https://pic.imgdb.cn/item/66a796a2d9c307b7e933d695.png" alt="指令系统示意图" style="zoom:60%"></p>
<h4 id="7-3-指令的运行流程"><a href="#7-3-指令的运行流程" class="headerlink" title="7.3 指令的运行流程"></a>7.3 指令的运行流程</h4><p>一条指令的运行，有三个阶段，分别是<strong>取指令阶段、解码和执行</strong>。这里，我们会在RAM里放一个程序，过一遍流程。</p>
<p>CPU的第一个阶段叫”<strong>取指令阶段</strong>“。指令地址寄存器连接到RAM，RAM得到指令地址寄存器的内容，将对应地址的数据传到指令寄存器中，下图中显示的是”0010 1110“。</p>
<p>然后是<strong>解码</strong>，根据前文的指令表，知道0010是LOAD_A指令。后四位是RAM的地址（如表），1110是14，那么我们就取得RAM中地址是14的值3。这是一个LOAD_A指令，会将这个值放入A寄存器中，而其他寄存器不受影响。</p>
<p>最后是<strong>执行</strong>，通过检验电路和输入运行线开关，就将3写入了寄存器A中。执行完后，指令地址寄存器地址+1，进行下一个指令。</p>
<p>当然，每一个指令都会有对应的逻辑电路来判断其是否要进行。这些控制单元可能非常复杂，我们将其抽象一层，以一个整体部件（控制单元Control Unit）代替。</p>
<p><img src="https://pic.imgdb.cn/item/66a797ead9c307b7e934f7e5.png" style="zoom:70%"></p>
<p>这个控制单元就行交响乐的指挥使，控制CPU的所有组件。”取指令-解码-执行“完成后，我们可以再来一次其他指令，从”取指令开始“。上面介绍的指令只涉及到寄存器的存取，其他指令如ADD，会用到<strong>ALU部件</strong>。利用ALU将值计算出来后，再传回对应的寄存器中。<strong>也就是说，寄存器加ALU，就可以做成CPU。</strong> </p>
<h4 id="7-4-CPU的节奏把控者——时钟"><a href="#7-4-CPU的节奏把控者——时钟" class="headerlink" title="7.4 CPU的节奏把控者——时钟"></a>7.4 CPU的节奏把控者——时钟</h4><p>我们刚才走的是一个人工的流程，但是计算机中没有”人工“，所以<strong>计算机中靠的是时钟来负责管理CPU的节奏</strong>。时钟以精确的时间间隔，触发电信号。控制单元会用这个信号，推进CPU的内部操作，确保一切按节奏进行。</p>
<p>时间间隔不能太短，因为电信号的传输也需要一定的时间。<strong><font color="red">CPU进行“取指令-解码-执行”的速度叫“时钟速度”，单位是Hz，1Hz表示一秒一个周期</font></strong>。</p>
<p><img src="https://pic.imgdb.cn/item/66a79d37d9c307b7e939973a.png" style="zoom:60%"></p>
<p>第一个单芯片CPU是“英特尔4004”，1971年发布的4位CPU，它的微架构很像我们之前所说的CPU。虽然是第一个小型CPU，但他的时钟速度达到740千赫兹——每秒740万个周期。</p>
<p><img src="https://pic.imgdb.cn/item/66a79b79d9c307b7e937f9e7.png" style="zoom:70%"></p>
<ul>
<li><p><strong>超频</strong><br>你可能听过有人会把计算机超频，意思是<strong>修改时钟速度</strong>，加快CPU的速度，就像罗马帆船要撞另一艘船时，鼓手会加快敲鼓速度。芯片制造商经常给CPU留一点余地，可以接受一点超频！但超频大多会让CPU过热或产生乱码，因为信号跟不上时钟。</p>
</li>
<li><p><strong>降频</strong><br>你可能很少听说降频，但降频其实很有用，有时没必要让处理器全速运行(例如，可能用户走开了，或者在跑一个性能要求较低的程序)。把 CPU 的速度降下来，可以省很多电，省电对用电池的设备很重要，比如笔记本和手机</p>
</li>
<li><strong>动态调频</strong><br>很多现代处理器可以按需求，加快或者减慢时钟速度，这叫“<strong>动态调整频率</strong>”，加上时钟后，CPU才完整，这样我们又提升了一层抽象。<strong>CPU和RAM独立，两者用地址线、数据线和允许读写线进行通信。</strong> </li>
</ul>
<h4 id="7-5-小小结"><a href="#7-5-小小结" class="headerlink" title="7.5 小小结"></a>7.5 小小结</h4><p>加上时钟后，CPU才是完整的，现在可以放到盒子里，抽象成一个独立组件。</p>
<p><img src="https://pic.imgdb.cn/item/66a79d8fd9c307b7e939ea7d.png" style="zoom:60%"></p>
<h3 id="8-指令和程序"><a href="#8-指令和程序" class="headerlink" title="8 指令和程序"></a>8 指令和程序</h3><h4 id="8-1-更加丰富的指令系统"><a href="#8-1-更加丰富的指令系统" class="headerlink" title="8.1 更加丰富的指令系统"></a>8.1 更加丰富的指令系统</h4><p>上节课中，我们把ALU，控制单元，RAM和时钟结合在一起，做了一个基本但可用的“中央处理单元”，简称CPU，它是计算机的核心。这次，我们给CPU一些指令来运行。</p>
<p>CPU之所以强大，是因为它是可编程的，如果写入不同指令，就会执行不同任务。所以，CPU是一块硬件，可以被软件控制。在上节课的指令系统中，我们只有4条语句，这节课我们会增加几条指令，如下</p>
<ol>
<li><strong>SUB</strong>：与ADD一样，操作两个寄存器相减，放在第二个寄存器上。</li>
<li><strong>JUMP</strong>：让程序跳转到新位置，如果想改变一些指令或者跳过一下指令，这个很有用。JUMP的底层实现方式是，把需要的指令后四位代表的内存地址的值覆盖掉“指令地址寄存器”里的值。</li>
<li><strong>JUMP_NEG</strong>：它只在ALU的“负数标志”为真时（即此时计算结果为负数），进行JUMP。</li>
<li><strong>HALT</strong>：计算机和程序停下来。</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/66a82c68d9c307b7e9979f4f.png" alt="更加丰富的指令集" style="zoom:70%"></p>
<p>值得一提的是，指令和数据都是存在同一个内存里面的，他们在根本上毫无区别，都是二进制数。</p>
<p><strong>利用更多的指令，我们可以使CPU的程序更加丰富。</strong></p>
<h4 id="8-2-无限循环与条件指令"><a href="#8-2-无限循环与条件指令" class="headerlink" title="8.2 无限循环与条件指令"></a>8.2 无限循环与条件指令</h4><p>当指令顺序出现问题时，程序可能进入<strong>无限循环</strong>，这个程序会永远跑下去。所以，我们需要更多<strong>其它类型的JUMP</strong>以满足我们的需要，这样只在特定条件下才会发生，程序不会出现无限循环。前面提到的<code>JUMP_NEG</code>就是，此外还有 <code>JUMP_IF_EQUAL</code>（如果相等）、<code>JUMP_IF_GREATER</code>（如果更大）等等。这些指令，同样使我们的CPU程序更加丰富。</p>
<p>软件还可以让我们做到硬件做不到的事，ALU没有除法功能，是程序给了这个功能。别的程序也可以用我们的除法程序，来做其他事情。</p>
<h4 id="8-3-指令长度"><a href="#8-3-指令长度" class="headerlink" title="8.3 指令长度"></a>8.3 指令长度</h4><p>我们这里假设的CPU很基础，所有指令都是8位，操作码只占了前四位，即便用尽4位，也只能代表16个指令。同时，因为4位最大为16，说明我们最多可以操纵16个地址，这非常少。</p>
<p>因此现代计算机用两种办法来解释此，① 最直接的方法是用更多位来代表指令，比如32位或者64位，这叫做<strong>指令长度</strong>。② 第二个策略是“可变指令长度”，举例，比如某个CPU用8位长度的操作码，看到HALT指令，HALT不需要额外的数据，那么会立马执行。如何看到JUMP，它得知道位置值，这个值在JUMP后面，这叫做“立即值”。这样设计，指令可以是任意长度。</p>
<h4 id="8-4-现代计算机的指令系统"><a href="#8-4-现代计算机的指令系统" class="headerlink" title="8.4 现代计算机的指令系统"></a>8.4 现代计算机的指令系统</h4><p>上面都是假设的例子，现在讲一个真实的例子。1971年，英特尔发明的4004处理器，这是第一次把CPU做成芯片，它支持46个指令，包括JUMP、ADD等。CPU发展到现在，功能越来越强大。比如，英特尔的酷睿i7，有上千个指令和指令变种，长度从1到15字节。</p>
<p><img src="https://pic.imgdb.cn/item/66a830c2d9c307b7e99a8d82.png" alt="第一个CPU4004的指令集 "></p>
<h3 id="9-高级CPU设计"><a href="#9-高级CPU设计" class="headerlink" title="9 高级CPU设计"></a>9 高级CPU设计</h3><h4 id="9-1-早期CPU提速方式"><a href="#9-1-早期CPU提速方式" class="headerlink" title="9.1 早期CPU提速方式"></a>9.1 早期CPU提速方式</h4><p>随着本系列的进展，我们知道计算机进步巨大，从1秒一次运算，到现在有千hz甚至兆hz的CPU。</p>
<h5 id="9-1-1-减少晶体管切换时间"><a href="#9-1-1-减少晶体管切换时间" class="headerlink" title="9.1.1 减少晶体管切换时间"></a>9.1.1 减少晶体管切换时间</h5><p>早期计算机的提速方式是，减少晶体管的切换时间。晶体管组成了逻辑门，ALU以及前几集的其他组件，但这种提速方式终究会遇到困难。所以厂商和科学家们发明各种新的技术来提高性能。</p>
<h5 id="9-1-2-利用复杂电路设计除法"><a href="#9-1-2-利用复杂电路设计除法" class="headerlink" title="9.1.2 利用复杂电路设计除法"></a>9.1.2 利用复杂电路设计除法</h5><p>上节课我们做了一个CPU除法器，不断减去同一个数，直到小于等于0才停下。但这种方法需要多个时钟，很低效。所以<strong>现代CPU直接在硬件层面上设计了除法，可以直接给ALU除法指令。虽然这让CPU更大更复杂，但也让运行速度更快。</strong></p>
<h4 id="9-2-缓存——解决CPU与RAM传输问题"><a href="#9-2-缓存——解决CPU与RAM传输问题" class="headerlink" title="9.2 缓存——解决CPU与RAM传输问题"></a>9.2 缓存——解决CPU与RAM传输问题</h4><p>现代计算机几千兆的时钟速度，带来了另一个问题，<u>如何传递数据给CPU</u>？这时，RAM成了一大阻力，RAM是CPU之外的独立组件，意味着数据要用线来传递，叫<strong>总线(BUS)</strong>。虽然电信号可以以光速快速快速传输，但是很小的延迟也会造成问题，RAM还需要时间找地址、取数据、配置和输出数据，这样会占用太多时间。</p>
<p>解决延迟的方法之一是，给CPU加一点RAM，叫<strong><font color="red">缓存(CACHE)</font></strong>。</p>
<p><img src="https://pic.imgdb.cn/item/66a835d8d9c307b7e99dfb4a.png" alt="CPU与RAM之间添加“缓存”" style="zoom:60%"></p>
<p>因为处理器空间不大，所以缓存一般只有几KB或MB。缓存提高了运行速度，CPU从RAM拿数据时，RAM不用传一个，可以传一批。这很实用，<strong>因为数据常常是一个一个按顺序处理的，将要处理的数据提前传入缓存，可以大大提升CPU运行速度</strong>。<em><u>因为缓存离CPU近</u></em>，传输时间大大降低，这比直接反复去RAM拿数据快得多。</p>
<blockquote>
<p>注意：这里的近就是指物理上的近，RAM与CPU通信的总线BUS物理长度可能1cm，但是CACHE与CPU通信的物理距离可能只有0.01cm。</p>
</blockquote>
<p>如果想要的数据已经在缓存中，叫“<strong>缓存命中</strong>”，否则叫缓存未命中。缓存可以当临时空间，存一些中间值，适合长\复杂的运算。</p>
<p>计算完后的值要想存储，不会直接存入RAM，而是存入缓存中。因此，缓存里的数据要对RAM里的数据进行更新，缓存里每块空间，有一个特殊标记，叫“<strong>脏位</strong>”。</p>
<p>同步缓存与RAM的数据一般是当缓存满了，而又需要存更多的数据时发生。这时会检查缓存中的“脏位”，如果是脏的，就会把数据写回RAM中。</p>
<h4 id="9-3-指令流水线"><a href="#9-3-指令流水线" class="headerlink" title="9.3 指令流水线"></a>9.3 指令流水线</h4><p>CPU在处理指令时，不一定要完全按照串行流程，可以按照并行方式进行。意思是，当此条指令正在“执行”时，可以处理下一个指令的“解码”，下下条指令的“读取”，这样可以同时利用上CPU里的所有部分。这样进行执行，吞吐量*3。如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/66a8393cd9c307b7e9a05e10.png" alt="指令流水线"></p>
<p>当然，这样也可能出现问题，首先是因为<strong>上一条指令可能会改变下一条指令的运行方式</strong>，所以CPU在运行前需要解析这些指令，必要时还需要停下来等待上一条指令完成后在继续。</p>
<p>高端CPU，比如笔记本和手机那种，会进一步，动态排序有依赖关系的指令，最小化流水线停工时间，这叫“乱序执行”。这种电路非常复杂，但因为高效，几乎所有现代处理器都有流水线。</p>
<p>第二个问题是<strong>条件跳转</strong>，比如JUMP Negative这些，这些指令会改变程序的执行流。简单的流水线处理器，看到JUMP指令会停一会，等待条件值确定下来，一旦JUMP的结果出了，处理器就继续流水线。因为等待会消耗很多时间，<strong>高级的流水线处理器会提前猜测哪个条件可能性大，然后提前把指令放在流水线上，这叫“推测执行”</strong>。如果猜测正确，则立即执行，错误则会清空刚才加载的指令，重新加载。为了减少清空次数，CPU开发了高级方法来猜测哪条分支更有可能，叫“分支预测”。现代计算机的猜测正确率高达90%。</p>
<ul>
<li><strong>超标量处理器</strong></li>
</ul>
<p>理想情况下，流水线一个时钟周期完成1条指令，然后“超标量处理器”出现了，一个时钟周期可以完成多条指令。即便有流水线涉及，在指令执行阶段，处理器里有些区域还是可能会空闲，例如：有一条指令是“从内存中取出某地址存放的数据”，执行这条指令期间ALU会闲置，所以一次性处理多条指令(取指令+解码)会更好（此句子也可翻译为：那么，为什么不一次获取和解码多个指令，并尽可能地执行指令呢）。也就是说，如果多条指令要 CPU 的不同部分，就多条同时执行。我们可以再进一步，加多几个相同的电路执行出现频次很高的指令——<strong>举例，很多 CPU 有4个、8个甚至更多完全相同的ALU结构，可以同时执行多个数学运算</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/66a83ecbd9c307b7e9a45e3c.png" alt="超标量流水线处理器" style="zoom:40%"></p>
<p><a href="https://blog.csdn.net/youzhangjing_/article/details/132278054">参考连接1：一文解析超标量处理器 - CSDN</a><br><a href="https://blog.csdn.net/zhizhengguan/article/details/121271156">参考连接2：计算机组成原理：超标量，让CPU的吞吐率超过1 - CSDN</a><br><a href="https://blog.csdn.net/a201577F0546/article/details/84726912">参考连接3：一个时钟周期执行一条指令的过程理解（单周期CPU） - CSDN</a><br><a href="https://blog.csdn.net/weixin_69884785/article/details/136208031">参考连接4：计算机组成原理（6）——-指令执行过程 - CSDN</a></p>
<h4 id="9-4-多核处理器"><a href="#9-4-多核处理器" class="headerlink" title="9.4 多核处理器"></a>9.4 多核处理器</h4><p>以上的指令流水线工作都是对于一个流水线来说的。另一个方法是<strong>同时运行多个指令流，叫多核处理器</strong>。多核意思是，CPU芯片有多个独立处理单元，就像有多个CPU。多个CPU之间可以合作运算。</p>
<p><img src="https://pic.imgdb.cn/item/66a8417ad9c307b7e9a61ce8.png" alt="多核处理器" style="zoom:70%"></p>
<p>你应该听过双核或四核处理器，意思是一个 CPU 芯片里，有多个独立处理单元，很像是有多个独立’CPU，但因为它们整合紧密，可以共享一些资源，比如缓存，使得多核可以合作运算</p>
<p><img src="https://pic.imgdb.cn/item/66a841d4d9c307b7e9a6582f.png" style="zoom:30%"></p>
<p>当多核不够时，可以用多个CPU，比如视频网站的服务器。</p>
<p>2个和4个核的计算机是最常用的（现在可能有8核了），但人们还需要更多的，所以有了<strong>超级计算机。目前世界上最快的计算机位于中国超算中心，神威·太湖之光</strong>，有40960个CPU，每个CPU有256个核心，总共超过1千万个核心，可以进行超级运算或者宇宙大模拟。</p>
<h3 id="10-早期的编程方式"><a href="#10-早期的编程方式" class="headerlink" title="10 早期的编程方式"></a>10 早期的编程方式</h3><p>前几集我们把重点放在计算机的原理，怎么从内存读写数据，执行操作。还讲了指令的执行。但是，我们还没讲程序如何“进入”计算机。</p>
<h4 id="10-1-最早的编程——可编程纺织机"><a href="#10-1-最早的编程——可编程纺织机" class="headerlink" title="10.1 最早的编程——可编程纺织机"></a>10.1 最早的编程——可编程纺织机</h4><p>给计算机编程这个需求，早在计算机出现之前就有了，最著名的来自于纺织行业。如果想要织一件红色衣服，我们只需要将红线放入纺织机中，但是如果想要图案怎么办？开始时，工人要经常改变纺织方向以作图案，所以早期有团案的衣服较为贵。后来发明了可编程纺织机，用孔板进行控制。这个纺织机叫“雅卡尔织布机”，被认为是最早的编程。</p>
<h4 id="10-2-穿孔卡片编程"><a href="#10-2-穿孔卡片编程" class="headerlink" title="10.2 穿孔卡片编程"></a>10.2 穿孔卡片编程</h4><p>近1个世纪后，穿孔纸用于1890年美国人口普查。每张纸都可以存个人信息，用孔来表示信息，比如种族、婚姻等。穿孔纸存的是数据，不是程序。</p>
<h4 id="10-3-插线编程"><a href="#10-3-插线编程" class="headerlink" title="10.3 插线编程"></a>10.3 插线编程</h4><p>为了用计算机正确执行不同计算，程序员需要某种控制面板。面板有很多小插孔，程序员可以插电线，控制让机器的不同部分，互相穿数据和信号，因此也叫“插线板”。不幸的是，这意味着，运行不同程序要重新接线。所以到1920年，控制面板变成了可拔插，让编程更方便，可以给计算机插入不同程序。但是插线板编程很复杂，不过它在大多机电计算机很常见，世界上第一台电子计算机也是用插线板编程。</p>
<h4 id="10-4-冯诺依曼结构"><a href="#10-4-冯诺依曼结构" class="headerlink" title="10.4 冯诺依曼结构"></a>10.4 冯诺依曼结构</h4><p>插线编程非常复杂，也非常耗时，这对计算机设计程序很麻烦。后来，内存的出现与发展，出现了“<u>存储程序计算机</u>”，能在内存里存储程序。如果内存足够，不仅可以存程序，还可以存数据。<strong>程序和数据都存在一个地方，叫“冯诺伊曼结构”</strong>。冯诺依曼计算机的标志是：</p>
<script type="math/tex; mode=display">
一个处理器+数据寄存器+指令寄存器+指令地址寄存器+内存(负责存数据和指令)</script><p>第一台冯诺依曼结构计算机叫“宝宝”，由曼彻斯特大学于1948年建成。直到1980年代，人们还是主要用穿孔卡片进行程序写入，计算机可以吸入一张卡片，把卡片内容写进内存。卡片输入非常麻烦，要是不小心弄乱了，要花几小时甚至几天来整理。数据由计算机输出，依然是需要用到卡片，方式是打孔。</p>
<h4 id="10-5-面板编程"><a href="#10-5-面板编程" class="headerlink" title="10.5 面板编程"></a>10.5 面板编程</h4><p>到了1980年代，还有一种常见的编程方式，面板编程。面板编程，用一大堆开关进行控制。通过开关控制进行二进制代码的编写，然后就可以运行程序。</p>
<p>不管是插线、穿孔纸片还是面板，早期编程都是专家活，需要非常了解底层硬件，比如操作码和寄存器等等。所以当时编程很难。下节课，讲到编程语言，是一种更简单的编程方法。 </p>
<h3 id="11-编程语言发展历史"><a href="#11-编程语言发展历史" class="headerlink" title="11 编程语言发展历史"></a>11 编程语言发展历史</h3><p>之前，我们把重点放在硬件——组成计算机的物理组件上，比如电、电路、寄存器、RAM、ALU和CPU，但是在硬件层面上编程非常麻烦。所以程序员想要一种更加通用的方法编程，一种更软的媒介。所以，这节课，我们将要讲<strong>软件和高级语言</strong>。</p>
<h4 id="11-1-机器语言、汇编语言和编译器"><a href="#11-1-机器语言、汇编语言和编译器" class="headerlink" title="11.1 机器语言、汇编语言和编译器"></a>11.1 机器语言、汇编语言和编译器</h4><p>第8节课，我们一步步讲了一个简单程序。前面我们讲到用二进制代码表示不同的操作和地址，其实这只是一种数据的表现方式。就像英语和摩斯密码，虽然二者的符号和表达不同，但是可以传达相同的信息，计算机语言也类似。</p>
<h5 id="11-1-1-机器语言"><a href="#11-1-1-机器语言" class="headerlink" title="11.1.1 机器语言"></a>11.1.1 机器语言</h5><p>计算机能处理二进制，二进制是处理器的“母语”。这叫“<strong>机器语言”或者“机器码”</strong>。在计算机早期阶段，必须用机器码写程序。具体地来讲，会先在纸上用英语写一个高层次版本，<strong>这种对程序的高层次描述，叫伪代码</strong>，然后，用“<strong>操作码表</strong>”把伪代码转成二进制机器码，翻译完成后，程序就可以喂入计算机并运行。</p>
<h5 id="11-1-2-汇编语言"><a href="#11-1-2-汇编语言" class="headerlink" title="11.1.2 汇编语言"></a>11.1.2 汇编语言</h5><p>但这种方法太麻烦了，所以在1940-1950年代，程序员开发一种新语言，更可读更高层次。它为每个操作码分配一个简单名字，叫“<strong>助记符</strong>”，助记符后面紧跟数据，形成完整指令。程序员可以用“LOAD_A 14”写代码，而不是用01二进制写代码了。</p>
<p><img src="https://pic.imgdb.cn/item/66a8486ad9c307b7e9aaacf1.png" alt="部分汇编语言表" style="zoom:60%"></p>
<h5 id="11-1-3-汇编器"><a href="#11-1-3-汇编器" class="headerlink" title="11.1.3 汇编器"></a>11.1.3 汇编器</h5><p>当然，计算机并不认识助记符，它只认得二进制码，所以程序员写了一个二进制程序来帮忙。<strong>它可以读懂文字指令，自动转换成二进制指令，这种程序叫“汇编器”</strong>。汇编器读取用汇编语言写的程序，然后转成“机器码”。随着时间推移，汇编器能够帮助人类完成的事情越来越多。其中一个就是自动分析JUMP地址，程序员写程序时，只需写入可跳转的标签，汇编器就会自己跳转分析。</p>
<p>因此，程序员可以专心编程，不用管底层细节。</p>
<p>汇编语言直接对应机器码，虽然已经很方便了。但是，汇编器仍然强迫程序员思考，用什么寄存器和内存地址，如果我们突然要用额外一个数，可能要改很多代码。这时候，需要更加高级的语言出现。</p>
<h4 id="11-2-A-0语言"><a href="#11-2-A-0语言" class="headerlink" title="11.2 A-0语言"></a>11.2 A-0语言</h4><p>为了更加方便编程，历史上有计算机科学家发明了A-0语言。这种语言相对汇编语言更加高级(一般一条汇编指令对应一条机器指令)，一行高级编程语言，可能会转成几十条二进制指令。同时，这名科学家还做了<strong>编译器</strong>，可以专门把高级语言转成低级语言，比如汇编或者机器码（CPU可以直接执行机器码）。虽然这个想法很先进，但是在当时并没有被大众所广泛使用。</p>
<h4 id="11-3-高级语言的思想"><a href="#11-3-高级语言的思想" class="headerlink" title="11.3 高级语言的思想"></a>11.3 高级语言的思想</h4><p>幸运的是，这种思想开始流行，很多人尝试创建新的编程语言。比如我们用高级语言Python为例，计算两个值的和，如果用汇编语言，我们得从内存取值，和寄存器打交道以及其他底层细节。但同样的程序用Python可以这样写，不用管内存和寄存器位置。</p>
<p>程序员只需要创建<strong>“代表内存地址的抽象”，叫变量。</strong>上图，我们把变量存在A和B中，然后相加两个数，把结果存在C中。在底层操作时，编译器可能把变量A存在寄存器A中，但这些，程序员已经不需要自己思考放在哪了。</p>
<h4 id="11-4-Fortran语言"><a href="#11-4-Fortran语言" class="headerlink" title="11.4 Fortran语言"></a>11.4 Fortran语言</h4><p>Fortran语言，名字来源于“公式翻译”，IBM发布于1957年，其主宰了早期计算机编程。平均来说，Fortran语言写的代码，比同等的手写汇编代码短20倍，然后Fortran编译器会把代码转成机器码。语言更加高级，所以运行速度会慢一点，但是代码编写速度会大大提高。Fortran语言开始时只能运行在IBM计算机上。</p>
<h4 id="11-5-通用编程高级语言"><a href="#11-5-通用编程高级语言" class="headerlink" title="11.5 通用编程高级语言"></a>11.5 通用编程高级语言</h4><p>50年代的大部分编程语言和编译器只能运行在一种计算机上。如果升级电脑，所有的代码都可能要重写。因此，工业界、学术界和政府计算机专家，在1959年组成一个联盟——<strong>数据系统语言委员会</strong>。开发了一种通用编程语言，可以在不同机器上通用。最后，诞生一门通用商业语言，Cobol。为了兼容不同硬件，每个计算机都需要对应的编译器，但是这些编译器可以接收相同的Cobol代码。这种叫<strong>一次编写，多处运行</strong>。</p>
<p>由于高级语言的出现，原来只有计算机科学家才能的编程，到后来各个专业的人们都可以学会编程。下面是不同年代出现的主要重要语言，可以以此来瞧瞧编程语言的发展。</p>
<ol>
<li>从1959年开始，编程语言的时代开始了。</li>
<li>在1960年代，有Algol、Lisp、Basic等语言。</li>
<li>70年代有Pascal、C和Smalltalk语言等。</li>
<li>80年代有C++、Objective-C（扩充C的面向对象语言）等。</li>
<li>90年代有Python、Java和Ruby等语言。</li>
<li>在新千年，Swift、C#和Go在崛起。</li>
</ol>
<p>新语言使用更加聪明的抽象，使得其在某些方面更容易和强大。</p>
<h3 id="12-编程原理-语句和函数"><a href="#12-编程原理-语句和函数" class="headerlink" title="12 编程原理-语句和函数"></a>12 编程原理-语句和函数</h3><p>上节课讲到机器码写程序需要处理底层细节，写大型程序非常麻烦。为了脱离底层细节，开发了编程语言以让程序员专心解决问题，不用管硬件细节。这节课，我们讨论大部分编程语言都有的<strong>语法和函数</strong>。</p>
<h4 id="12-1-语句与语法"><a href="#12-1-语句与语法" class="headerlink" title="12.1 语句与语法"></a>12.1 语句与语法</h4><p><strong>语法，是用来规定句子结构的一系列规则。</strong>英语有语法，所有的编程语言也都有语法。a=5是一句语言，意思是，创建一个变量a，把数字5放进去。这叫赋值语句，把一个值赋给一个变量。注意，变量名称可以随便取（不重名即可），当然取名最好有点意义，这样可以方便别人读懂。程序和做菜一样，会一步步运行到程序尾部。</p>
<p>为了不只是顺序执行程序，我们需要流程控制语句。最常见的流程控制语句是if语句，if语句需要判断语句，因此这些表达式又叫“<strong>条件语句</strong>”，下面是一些流行语言的if语句。if语句是指，如果if里的条件为真，那么就执行if下面的代码；否则执行else下面的代码。</p>
<p><img src="https://pic.imgdb.cn/item/66a85205d9c307b7e9b2349b.png" alt="常见编程语言的if-else语法"></p>
<p>if语句只执行一次，如果要执行多次，则要用<strong>while语句</strong>。当while条件为真时，就会重复执行代码。另一个常用的循环结构是<strong>for结构</strong>。for结构不判断条件，会判断次数，会循环特定次数。 </p>
<h4 id="12-2-函数"><a href="#12-2-函数" class="headerlink" title="12.2 函数"></a>12.2 函数</h4><p><strong>为了隐藏程序的复杂度，我们可以把代码打包成函数，有些编程语言也叫“方法”或“子程序”</strong>。若其他地方想用这个函数，直接写函数名即可。当然，我们可以在函数里面加其他函数，这样可以设计更加简洁的代码。所以现代软件，是由上千个函数组成的，每个负责不同的事情。</p>
<p>这种模块化编程，不仅可以让单个程序员独立制作APP，也可以让团队协作写更大型的程序。不同程序员写不同的函数，只需要保证自己的代码正确，把所有人的拼起来，整个程序应该就能正常运行。</p>
<p>现在，我们不需要写指数函数这些普遍的函数。现代编程语言，有很多预先写好的函数集合，叫“<strong>库</strong>”，由专业人员编写，不仅效率高，而且经过了仔细检查。这样可以方便我们开发程序。本节结束，下节讲函数。 </p>
<h3 id="13-算法入门"><a href="#13-算法入门" class="headerlink" title="13 算法入门"></a>13 算法入门</h3><p>前面两集尝试了高级编程语言，我们讨论了几种语句，赋值语句、if语句、循环语句等，以及打包的函数。算法，是解决某种问题的具体方法，一般而言所需时间越少越好，有时我们也关注其他方面，比如所占空间等。</p>
<h4 id="13-1-排序算法"><a href="#13-1-排序算法" class="headerlink" title="13.1 排序算法"></a>13.1 排序算法</h4><p>最常见的算法就是排序，比如给数字排序。排序也是应用非常广泛，非常常见的算法。排序算法有很多，为的是更快地进行排序。视频讲了选择排序。<strong>选择排序</strong>是指，对于每一次范围（这个范围逐渐减少）从中选择最小的放在最首。</p>
<p>算法的输入大小与运行步骤之间的关系，叫算法复杂度，代表运c行速度的量级。算法复杂度叫大O表示法。选择排序的复杂度是O(n^2)。此外，更低的排序有<strong>归并排序，时间复杂度是O(n*logn)。</strong></p>
<h4 id="13-2-迪杰斯特拉算法"><a href="#13-2-迪杰斯特拉算法" class="headerlink" title="13.2 迪杰斯特拉算法"></a>13.2 迪杰斯特拉算法</h4><p>用于图搜索的算法，对于一个有权图，要找最短路径，如果全部穷举，那么会是O(n!)的复杂度，这是一个非常糟糕的复杂度。所以，迪杰斯特拉发明了一种求最短路的算法，叫迪杰斯特拉算法。其算法复杂度是O（n^2）。</p>
<p>算法无处不在，并广泛应用于生活中各个地方，算法设计，也是计算机科学中一个很重要的方向。本节完，这节内容比较少，是因为这些知识数据结构中基本都学过了，就不需要着重记笔记。 </p>
<h3 id="14-数据结构"><a href="#14-数据结构" class="headerlink" title="14 数据结构"></a>14 数据结构</h3><p>本集高能，基本上一分钟一个数据结构。</p>
<p>上节课讲了一写算法，比如数组排序、最短路径。不过，上节没讲的是，算法处理的数据，存在内存里的格式是什么。我们希望数据是结构化的，方便读取。所以，科学家发明了<strong>数据结构。</strong></p>
<h4 id="14-1-数组"><a href="#14-1-数组" class="headerlink" title="14.1 数组"></a>14.1 数组</h4><p><strong>数组的值一个个连续存在内存里面</strong>，所以不像之前，一个变量里只存一个值，我们可以把多个值存在数组变量里。我们用下标<code>[i]</code>取值，下标一般从0开始。<strong>数组变量表示的是首元素地址</strong>，后面通过偏移得到其他元素坐标。</p>
<p><img src="https://pic.imgdb.cn/item/66a86421d9c307b7e9c0ddf0.png" alt="数组"></p>
<p>现在很多语言自带了数组的一些算法，比如排序算法等，不需要我们直接写。</p>
<h4 id="14-2-字符串"><a href="#14-2-字符串" class="headerlink" title="14.2 字符串"></a>14.2 字符串</h4><p>和数组相似的就是字符串，它是<strong>由字母、数字和标点等组成的数组</strong>。写代码时，用括号括起来就可以了，<code>j=&quot;START&quot;</code>。在字符串末尾，有<code>NULL</code>项，这一项表示字符串到此结束。</p>
<p>因为计算机经常处理字符串，所以会有很多字符串函数，比如连接字符串strcat（接收两个字符串，把第二个放在第一个末尾）。</p>
<h4 id="14-3-矩阵"><a href="#14-3-矩阵" class="headerlink" title="14.3 矩阵"></a>14.3 矩阵</h4><p>有时，我们需要处理图像或者表格，此时我们需要矩阵。我们<strong>可以把矩阵看做是数组的数组</strong>。多维数组里的元素，其实也是像一维数组那样顺序排列的，只不过提取数组方式不一样。</p>
<p><img src="https://pic.imgdb.cn/item/66a86560d9c307b7e9c20aa8.png"></p>
<h4 id="14-4-结构体"><a href="#14-4-结构体" class="headerlink" title="14.4 结构体"></a>14.4 结构体</h4><p><strong>把多种不同类型的数据打包放在一起，就叫结构体</strong>。甚至我们可以做一个结构体数组。结构体数组和普通数组一样，创建时便有固定的空间，不能动态增加容量。</p>
<h4 id="14-5-链表"><a href="#14-5-链表" class="headerlink" title="14.5 链表"></a>14.5 链表</h4><p>我们将值和指针放在一个节点（结构体）里面，就可以实现动态添加元素。指针是一种特殊变量，指向一个内存地址。<strong>多个连成的节点，就叫链表</strong>。有多种链表，比如循环链表和单向链表等等。</p>
<p><img src="https://pic.imgdb.cn/item/66a8663fd9c307b7e9c2ba99.png" alt="链表"></p>
<p>不同于数组的长度固定，链表可以通过改变指针指向动态添加元素。 </p>
<ul>
<li><strong>队列和栈</strong></li>
</ul>
<p>队列和栈都是基于链表的（好像有数组类型的不过不常用）。</p>
<p>队列就像排队一样，谁先来谁先上，这叫<strong>先进先出（FIFO）</strong>。有<strong>入队和出队</strong>操作，入队在队尾进行，出队在队首进行。</p>
<p>栈是<strong>先进后出</strong>的结构。栈元素的出入叫<strong>入栈和出栈</strong>。入栈和出栈在栈顶进行。</p>
<h4 id="14-6-树"><a href="#14-6-树" class="headerlink" title="14.6 树"></a>14.6 树</h4><p>如果节点有两个指针，分别指向左树和右树。最高的叫<strong>根节点</strong>，其余都叫子节点。没有任何子节点的节点，叫叶节点。若每个节点最多两个子节点，那么就叫<strong>二叉树</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/66a86712d9c307b7e9c35a99.png" alt="二叉树" style="zoom:60%"></p>
<p>树的一个重要特性是，从根到叶是单向的。</p>
<h4 id="14-7-图"><a href="#14-7-图" class="headerlink" title="14.7 图"></a>14.7 图</h4><p>不同于树，如果数据可以随意相连，包括循环，就叫<strong>图</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/66a8678ed9c307b7e9c3bbe2.png" alt="图" style="zoom:60%"></p>
<p>上面就是主要的数据结构，此外还有堆和红黑树等等。最后，利用好数据结构，可以帮助我们更加高效地完成一些任务开发。 </p>
<h3 id="15-阿兰·图灵"><a href="#15-阿兰·图灵" class="headerlink" title="15 阿兰·图灵"></a>15 阿兰·图灵</h3><h4 id="15-1-图灵机"><a href="#15-1-图灵机" class="headerlink" title="15.1 图灵机"></a>15.1 图灵机</h4><p>前几集我们讲了基础，比如函数、算法和数据结构。今天，我们来看一个对计算机理论贡献巨大的人，计算机科学之父——阿兰·图灵。</p>
<p>图灵于1912年出生在伦敦。当时一个很著名的问题是“<strong>可判定性问题</strong>”：是否存在一种算法，输入正确逻辑语句，输出准确的“是”或“否”。美国数学家阿隆佐·丘奇于1913年首先提出解决办法，他开发了一个叫“<strong>lambda算子</strong>”的系统，证明了这样的算法不存在。</p>
<p>但是lambda算子系统过于复杂，大洋彼岸的图灵提出一种假想计算机——后来被称为图灵计算机。图灵机的原理更加简单，更容易被人接受。图灵是一台理论计算设备。</p>
<p><img src="https://pic.imgdb.cn/item/66a86990d9c307b7e9c52364.png" alt="图灵机" style="zoom:30%"></p>
<p>图灵机有无限长的纸带，纸带可以存储符号。图灵机可以读入和写入纸带上的符号，还有一个状态变量，保存当前状态，还有规则。<strong>图灵证明只要有足够多的规则、状态和纸带，可以创造任何东西。</strong>没有计算机能比图灵机更强大。现在的计算机、手表和手机啥的，都是<strong>图灵完备的。</strong></p>
<ul>
<li><strong>停机问题</strong></li>
</ul>
<p>图灵利用图灵机完成了可判定性问题的证明。</p>
<p>有没有办法在不执行的情况，弄清会不会停机？</p>
<p>图灵通过一个巧妙逻辑矛盾证明了停机问题是无法解决的，我们来看看他的推理。想象有一个假想图灵机，输入:问题的描述+纸带的数据，输出 Yes 代表会”停机”，输出 No 代表不会停机。不用担心它具体怎么工作，假设这样的机器存在就好，毕竟重点是推论。</p>
<p>图灵推理说：如果有个程序，此图灵机无法判断是否会”停机”，意味着”停机问题”无法解决。为了找到这样的程序，图灵用这台图灵机设计了另一个图灵机。如果一开始的图灵机说程序会”停机”(YES)，那么新设计机器会永远运行(即不会停机)；如果一开始的图灵机的结果为 No，代表不会停机，那么让新机器输出 No，然后”停机”。也就是说新设计的图灵机和一开始的图灵机的输出正好相反。如果程序不停机，就停机，如果程序停机，就永远运行下去。</p>
<p>…………剩下的内容看视频吧。</p>
<p>总之，长话短说，丘奇和图灵证明了计算机的能力有极限，无论有多少时间或内存，有些问题是计算机无法解决的。</p>
<h3 id="16-软件工程"><a href="#16-软件工程" class="headerlink" title="16 软件工程"></a>16 软件工程</h3><p>大型软件，代码往往很多。开发软件需要很强的科学性，由此，一个关于软件的学问出现了，软件工程。</p>
<h4 id="16-1-面向对象"><a href="#16-1-面向对象" class="headerlink" title="16.1 面向对象"></a>16.1 面向对象</h4><p>前文我们提到了，把大项目分解成小函数，可以让很多人同时工作。每个人不需要关心整个工程，只需要关心自己的部分即可。</p>
<p>但是仅仅把打包成函数还不够，就像office有上千万行代码，就算打包成函数也有几十万个。解决办法是：<strong>把函数打包成层级，把相关代码都放在一起，打包成对象。这就是面向对象的由来。</strong></p>
<p><strong>一个对象可以包含其他对象、函数和变量。</strong>我们要访问某个函数时，要通过对象不断向内索引。这样通过封装组件，可以<strong>隐藏复杂度</strong>。</p>
<h4 id="16-2-开发文档"><a href="#16-2-开发文档" class="headerlink" title="16.2 开发文档"></a>16.2 开发文档</h4><p>开发完成项目后，团队需要完成解释文档，帮助理解代码都在做什么，以及定义好<strong><font color="red">”程序编程接口”，简称API</font></strong>。</p>
<p><u>API帮助不同程序员合作，不用知道具体细节，只知道怎么使用就行了。API还控制哪些函数和数据让外部访问，哪些仅供内部访问。“面向对象”的编程语言，可以指定函数是public或private来设置权限</u>。</p>
<p>“面向对象”的核心是，<strong>隐藏复杂度和选择性的公布功能</strong>。现在大部分软件或者游戏都是面向对象编程语言写的，比如C++，C#等。</p>
<h4 id="16-3-IDE"><a href="#16-3-IDE" class="headerlink" title="16.3 IDE"></a>16.3 IDE</h4><p>现代软件的开发，一般需要借助开发器。<strong>开发器集成了编译、调试、整理代码等功能，因为集成了所有的东西，因此叫集成开发环境，简称IDE</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/66a871d8d9c307b7e9cbc775.png" alt="Pycharm：较流行的Python的IDE" style="zoom:50%"></p>
<p>IDE还可以直接编译和运行代码。如果代码错误，IDE会定位到错误代码并给出提示来解决问题，这叫调试debug。</p>
<p>程序员工作的另一个重要部分是给代码写文档，这个文档写在readme里面。文档也可以直接注释在程序里面。<strong>注释很重要</strong>。</p>
<h4 id="16-4-源代码管理"><a href="#16-4-源代码管理" class="headerlink" title="16.4 源代码管理"></a>16.4 源代码管理</h4><p>IDE还有另一个功能，叫<strong>源代码管理</strong>，也叫<strong>版本控制</strong>。大型程序有源代码管理，他们还会将代码放到一个中心服务器上，叫代码仓库。</p>
<p>要修改代码时，就从代码仓库里取出来，修改完成后再放入。</p>
<p>当代码出现错误时，源代码管理也可以帮助程序员恢复到未修改的版本，并定位是谁修改了代码。</p>
<h4 id="16-5-测试"><a href="#16-5-测试" class="headerlink" title="16.5 测试"></a>16.5 测试</h4><p>测试代码和写代码一样重要，测试一般有个人或者小团队完成。测试统称为“质量保存测试”，简称QA。它严格测试软件的方方面面，模拟各种情况，看看软件会不会出错，就是找Bug。</p>
<h4 id="16-6-alpha版本和beta版本"><a href="#16-6-alpha版本和beta版本" class="headerlink" title="16.6 alpha版本和beta版本"></a>16.6 alpha版本和beta版本</h4><p>beta版本是接近完成的版本，此版本可以向大众开放，进行免费测试。alpha版本的粗糙的版本。</p>
<h3 id="17-集成电路与摩尔定律"><a href="#17-集成电路与摩尔定律" class="headerlink" title="17 集成电路与摩尔定律"></a>17 集成电路与摩尔定律</h3><p>过去几集我们学了软件、编程语言等，软件科学有着巨大的发展，但是如果没有硬件的大幅度进步，软件是不可能做到这些的。</p>
<h4 id="17-1-集成电路IC的出现"><a href="#17-1-集成电路IC的出现" class="headerlink" title="17.1 集成电路IC的出现"></a>17.1 集成电路IC的出现</h4><p>电子计算机时代，计算机有独立部件组成，叫”分立元件“，然后不同组件再用线连在一起。这时候计算机非常大而且很昂贵。在1950年中期，<strong>晶体管</strong>开始商业化，开始用于计算机。晶体管比真空管更小，但是元件依然是分立的。</p>
<p>晶体管的到来，标志着”计算2.0时代“的到来。但是晶体管的出现并没有完全解决电脑元件多线路复杂的问题。解决办法就是，讲计算机所有元件集成。<strong>简单地来说，把多个组件包在一起，变成一个新的独立组件，这就是集成电路。</strong></p>
<p>1959年的仙童半导体，让集成电路变成现实。仙童半导体用硅作为材料，其更稳定更可靠，价格也更低。<strong>Noyce因为发明了仙童半导体，被公认为现代集成电路之父</strong>。电子时代出现。</p>
<p><img src="https://pic.imgdb.cn/item/66a874b8d9c307b7e9cf050d.png" alt="IC的早期样品：只有几个晶体管" style="zoom:60%"></p>
<p>IC 就像电脑工程师的乐高积木，可以组合出无数种设计，但最终还是需要连起来，创造更大更复杂的电路，比如整个计算机。所以，PCB被创造出来了。</p>
<h4 id="17-2-印刷电路板——PCB"><a href="#17-2-印刷电路板——PCB" class="headerlink" title="17.2 印刷电路板——PCB"></a>17.2 印刷电路板——PCB</h4><p>集成电路可以把多个电路元件集成在一块芯片上，但是依然要将电路连接起来以制造计算机。所以工程师再度创新：印刷电路板，简称PCB。PCB可以大规模生产，<strong>无需焊接或用一大堆线。它通过蚀刻金属线的方式，把零件连接到一起。</strong>PCB和IC结合使用，可以大幅度减少独立组件和线路，但做到同样的功能。而且更小、更便宜更可靠。</p>
<h4 id="17-3-光刻"><a href="#17-3-光刻" class="headerlink" title="17.3 光刻"></a>17.3 光刻</h4><p>早期的元件，无法集成大量晶体管。所以需要全新的制造工艺——光刻。简单来说，就是用光把复杂图案印到材料上，比如半导体。它只有几个基础操作，但可以制作出复杂电路。</p>
<p><img src="https://pic.imgdb.cn/item/66a8766cd9c307b7e9d067a7.png" style="zoom:30%"></p>
<p>光刻机光刻电路的流程是，对于一块硅（晶圆），上面加氧化层，光刻胶，和光掩膜，然后用强光照射，强光能照射的地方光刻胶消失，然后把露出部分的氧化层清洗掉，最后再清洗掉光刻胶，就可以进行材料<strong>掺杂</strong>了。 </p>
<p><img src="https://pic.imgdb.cn/item/66a8770ed9c307b7e9d0f996.png" style="zoom:30%"></p>
<blockquote>
<p>我们想修改硅露出来的区域让它导电性更好，所以用一种化学过程来改变它，称为“掺杂”。</p>
</blockquote>
<p>由于光刻机和集成电路的出现，一片IC由原来的5个晶体管增加到1960年中期的上百个。</p>
<h4 id="17-4-摩尔定律"><a href="#17-4-摩尔定律" class="headerlink" title="17.4 摩尔定律"></a>17.4 摩尔定律</h4><p>1965年，摩尔看到了趋势：<strong>每两年左右，得益于材料和制造技术的发展，同样大小的空间，能塞进两倍数量的晶体管。这叫摩尔定律</strong>。芯片的价格也不断下降。</p>
<p>芯片集成地小，可以减少电的损耗，信号延迟更低，时钟速度加快。仅仅1950年左右，用分立元件会占满整个屋子，到集成电路出现，元件越来越小。尤其是集成电路用于微处理器，开启了计算3.0时代。到2010年，10亿个晶体管集成在一片芯片。光刻机分辨率也从几毫米到15纳米。</p>
<p>如今的处理器，比如iPhone7的A10CPU，有33亿个晶体管。</p>
<p>集成芯片的设计当然不是手工的，从1970年开始，<strong><font color="blue">超大规模集成（VLSI）</font></strong>软件来自动生产芯片设计。</p>
<h4 id="17-5-未来集成电路面临的挑战"><a href="#17-5-未来集成电路面临的挑战" class="headerlink" title="17.5 未来集成电路面临的挑战"></a>17.5 未来集成电路面临的挑战</h4><p>不幸的是，摩尔定律受到越来越多的挑战，现在已经达到极限。进一步做小，会<strong>面临两个问题。</strong></p>
<ol>
<li>用光掩膜把图案加到晶圆上，因为光的波长，精度已经达到极限。</li>
<li>当晶体管非常小，电极之间可能只距离几个原子，电子会跳过间隙，叫<strong>量子隧道贯穿效应</strong>。</li>
</ol>
<h3 id="18-操作系统"><a href="#18-操作系统" class="headerlink" title="18 操作系统"></a>18 操作系统</h3><h4 id="18-1-操作系统简介"><a href="#18-1-操作系统简介" class="headerlink" title="18.1 操作系统简介"></a>18.1 操作系统简介</h4><p>1940、1950年代的电脑，每次只能运行一个程序，程序员通过在打孔纸板上写程序来进行。打好孔后，再放入计算机中运行程序。但是，这种方法较慢。我们需要一种方法，让计算机自动运行程序，”<strong>操作系统</strong>“因此而生。</p>
<p><strong>操作系统，也叫OS，其实也是一种程序</strong>。但是它有操作硬件和特殊权限，可以运行和管理其他程序。操作系统一般是开机第一个启动的程序。其他程序，都由操作系统启动。</p>
<h4 id="18-2-操作系统的作用"><a href="#18-2-操作系统的作用" class="headerlink" title="18.2 操作系统的作用"></a>18.2 操作系统的作用</h4><p>早期的操作系统，一次只能运行一个程序，现在可以运行多个。<strong>系统运行完一个程序后，会自动运行下一个程序，不会浪费时间在更换程序上，这叫”批处理“</strong>。</p>
<p>当时，不同的CPU甚至相同的，可能配备着不同的打印机。程序员不仅需要考虑如何写程序，还有考虑如何和打印机和键盘等”<strong>外部设备</strong>“的交互。程序员需要考虑外部设备如何使用，以进行写代码。如今，操作系统充当软件和硬件之间的媒介。更具体地说，操作系统提供API来抽象硬件，叫”<strong><font color="blue">设备驱动程序</font></strong>”。程序员可以用标准化机制和输入输出硬件(I/O)交互。比如，程序员只需要调用<code>print(highscore)</code>，然后操作系统会处理输出到纸上的具体细节。</p>
<h4 id="18-2-多任务处理"><a href="#18-2-多任务处理" class="headerlink" title="18.2 多任务处理"></a>18.2 多任务处理</h4><p>如果一个系统只能运行一个程序的话，那么很多设备将会闲置，只能等待其他I/O设备完成后，才用。所以，后来开发了能在单个CPU上<strong>同时运行几个程序的操作系统</strong>。这种能力叫做操作系统的”<strong>多任务处理</strong>“。</p>
<h4 id="18-3-操作系统的内存管理"><a href="#18-3-操作系统的内存管理" class="headerlink" title="18.3 操作系统的内存管理"></a>18.3 操作系统的内存管理</h4><p>不同的程序数据，在计算机中存放于不同的位置，甚至可能同一个程序的数据分别处于计算机中的不同位置。这种存法导致程序员要追踪这些地址很麻烦。<strong>为了隐藏这种复杂性，操作系统会把内存地址进行”虚拟化“，这叫<font color="purple">虚拟内存</font></strong>。程序可以假定内存总是从地址0开始的。而内存实际的物理地址，被操作系统隐藏和抽象了。</p>
<p><img src="https://pic.imgdb.cn/item/66a89026d9c307b7e9e950ba.png" alt="虚拟内存" style="zoom:70%"></p>
<p>操作系统会自动地将程序的物理地址与虚拟地址进行映射（有一个映射表，存储了虚拟内存和真实内存的映射关系）。一个在不同物理地址的程序，可能映射为统一顺序。这种机制可以使程序的内存大小可以灵活增减，叫”<strong>动态内存分配</strong>“。</p>
<p>我们会给一个程序一定的内存范围，如果程序出错开始乱写数据，那么这些错误的数据不会到其他内存下，这叫“<strong><font color="green">内存保护</font></strong>”。这对防止恶意软件(如病毒)也很有用，例如，我们不希望其他程序有能力读或改邮件程序的内存，如果有这种权限，恶意软件可能以你的名义发邮件，甚至窃取个人信息。</p>
<h4 id="18-4-分时操作系统"><a href="#18-4-分时操作系统" class="headerlink" title="18.4 分时操作系统"></a>18.4 分时操作系统</h4><p>在1970年代，计算机开始变得越来越便宜。这时，计算机不仅可以多个程序运行，而且可以多个用户访问。用户通过“<strong>终端</strong>”访问电脑，<em><u>终端只是键盘和屏幕，本身没有处理能力</u></em>。冰箱大小的计算机可能有50个终端，能让50个用户使用，这时操作系统不但要处理多个程序，还要处理多个用户。</p>
<p>为了能够让多用户使用计算机而不会使一个用户占满计算机，开发了<strong>分时操作系统。意思是每个用户只能用一小部分处理器、内存等</strong>，因为电脑很快，即使拿到1/50的资源也足以完成许多任务。</p>
<p>早期分时操作系统中，最有影响力的是<strong>Multics</strong>（多任务信息与计算系统），它是第一个从设计时就考虑到安全的操作系统。开发人员不希望恶意用户访问不该服务的数据。不过由于其系统过度设计了（功能太多），导致其所占内存过多，不能流行起来。</p>
<h4 id="18-5-Unix操作系统"><a href="#18-5-Unix操作系统" class="headerlink" title="18.5 Unix操作系统"></a>18.5 Unix操作系统</h4><p>所以为了简化操作系统的复杂度，设计者开发了<strong>Unix</strong>，Unix把操作系统分成两个部分：</p>
<ol>
<li>首先是操作系统的核心功能，如<u>内存管理、多任务处理和输入/输出处理</u>，这叫“<strong>内核</strong>”；</li>
<li>第二部分是一堆有用的工具，如程序和运行库，但他们不是内核的一部分。紧凑的内核，意味着功能没有那么全面。</li>
</ol>
<p>Unix的简单使得它可以用于很多计算机，越来越多的开发人员用Unix写程序和运行程序。Unix系统也在贝尔实验室大受欢迎。甚至在1970年代，有人还写了在Unix下的不同编程语言的编译器，这些使得Unix成为了1970-80年代最受欢迎的计算机操作系统。</p>
<h4 id="18-6-个人电脑和现代操作系统"><a href="#18-6-个人电脑和现代操作系统" class="headerlink" title="18.6 个人电脑和现代操作系统"></a>18.6 个人电脑和现代操作系统</h4><p>随着计算机水平的发展，出现了个人电脑和家庭电脑。这些电脑的操作系统比较简单，缺乏“多任务“、”内存保护“等功能，若遇到程序错误，就会发生<strong>崩溃（蓝屏）</strong>。幸运的是，1980年代开发的windows系统，有更好的保护，不会经常崩溃。</p>
<h3 id="19-内存和储存介质"><a href="#19-内存和储存介质" class="headerlink" title="19 内存和储存介质"></a>19 内存和储存介质</h3><p>本节重点，存储技术的发展。</p>
<h4 id="19-1-内存和存储器区别"><a href="#19-1-内存和存储器区别" class="headerlink" title="19.1 内存和存储器区别"></a>19.1 内存和存储器区别</h4><p>本系列中，我们多次谈到内存，甚至设计了一个简单内存（锁存器）。一般来说，电脑内存是”非永久性“，如果电源线不小心拔掉了，内存里所有数据都会丢失，所以内存叫”易失性“存储器。</p>
<p>不过，存储器和内存有所不同。任何写入存储器的数据，比如电脑硬盘，数据会一直存着，直到被覆盖删除，断电也不会丢失。存储是”非易失的“。比如一个小小的U盘，能够低成本+可靠+长时间地存储上GB的数据。</p>
<h4 id="19-2-早期的存储器——延迟线存储器"><a href="#19-2-早期的存储器——延迟线存储器" class="headerlink" title="19.2 早期的存储器——延迟线存储器"></a>19.2 早期的存储器——延迟线存储器</h4><p>最早的存储介质是打孔纸片和打孔纸带。纸片用了十几年，因为不用电而且便宜耐用。坏处就是读取慢，只能写入一次，打的孔无法修复，若要存储临时值，纸卡不好用。</p>
<p><img src="https://pic.imgdb.cn/item/66a89931d9c307b7e9f1439e.png" alt="纸卡片存储器" style="zoom:40%"></p>
<p>由于纸片的缺陷，人们发明了延迟线存储器。原理是，拿一个管子装满液体，管子一端放扬声器，另一端放麦克风，扬声器发出的声波，发送到麦克风需要一定时间，麦克风将压力波转换回电信号，我们可以用压力波的传播延迟来存储数据。若有压力则表示1，无则表示0，麦克风受到这些压力波后，把其转换为1010之类的二进制数据。若用线路+放大器将其接回，那么就可以存储这段信号了。 </p>
<p><img src="https://pic.imgdb.cn/item/66a89a4ed9c307b7e9f23ae9.png" alt="延迟线存储器" style="zoom:30%"></p>
<p>但是，延长线存储器的缺点是，每个时刻只能读一位数据。如果你想访问第100位数据，你只能等待第100位数据出现，这种叫做”顺序存储器“或”循环存储器“，而我们想要的是”随机存取存储器“，可以随时访问任何位置。</p>
<h4 id="19-3-磁芯存储器"><a href="#19-3-磁芯存储器" class="headerlink" title="19.3 磁芯存储器"></a>19.3 磁芯存储器</h4><p>后面还出现了如”磁致伸缩延迟存储器“，但是延迟线存储器在1950年代中期就基本过时了，因为出现了性能、可靠性和成本都更好的”<strong>磁芯存储器</strong>“。当磁圈加正电，就可以磁化，加反向电，就可以反向磁化，可以用这个来表示01存储信息。当然，用1位不行，需要用到磁圈网络。</p>
<p><img src="https://pic.imgdb.cn/item/66a89cd8d9c307b7e9f47620.png" alt="磁圈网络"></p>
<p>下图是一个实际的磁芯存储器，每个黄色方格有32行x32列的磁芯，每个磁芯存1位数据，所以能存1024 位(bit)(32x32=1024)。</p>
<p><img src="https://pic.imgdb.cn/item/66a89d17d9c307b7e9f4ac28.png" alt="现实中的磁芯存储器" style="zoom:60%"></p>
<p>最重要的是，磁芯存储器不像延迟线存储器，磁芯存储器能随时访问任何一位，这时非常有用的。磁芯存储器于1950开始，流行了20多年。 </p>
<h4 id="19-4-磁带"><a href="#19-4-磁带" class="headerlink" title="19.4 磁带"></a>19.4 磁带</h4><p>即使如此，磁芯存储器能存储的数据还是太少了。1951年，还发明了一直存储器，叫”<strong>磁带</strong>“。磁带是纤薄柔软的一长条磁性带子，卷在轴上。磁带可以在”磁带驱动器“内前后移动。磁带的存储空间相比之前的几kb大小，大了很多，可达几mb。因为磁带驱动器很贵，但是磁带很便宜，所以磁带一般用于数据存储。磁带的主要缺点是访问速度。</p>
<p><img src="https://pic.imgdb.cn/item/66a89e73d9c307b7e9f76763.png" alt="磁带的简要原理" style="zoom:60%"></p>
<h4 id="19-5-现代存储器——硬盘、软盘、光盘"><a href="#19-5-现代存储器——硬盘、软盘、光盘" class="headerlink" title="19.5 现代存储器——硬盘、软盘、光盘"></a>19.5 现代存储器——硬盘、软盘、光盘</h4><p>1950，60年代，有个类似的“磁鼓存储器”，磁鼓持续旋转，可以读取数据。但到1970年代，磁鼓存储器不再生产。然而磁鼓导致了<strong>硬盘</strong>的发展，因为硬盘和磁鼓很像。磁盘有磁性，其优点就算薄，可以进行堆叠。1970年代，磁盘大幅度改进并变得普遍，如今硬盘可以轻易容纳1TB的数据。</p>
<p><img src="https://pic.imgdb.cn/item/66a89f67d9c307b7e9f85747.png" alt="实际中的硬盘" style="zoom:80%"></p>
<p>软盘，除了磁盘是软的，其他基本一样。软盘是为了便携。你可能对光盘（CD）产品更熟悉，功能和硬盘一样，都是存储数据，不过原理不同，光盘主要用的是光学技术。如今，存储器朝固态前进，如硬盘和U盘，里面都是集成电路。如果机械硬盘被固态硬盘代替，简称SSD。 </p>
<h3 id="20-文件系统"><a href="#20-文件系统" class="headerlink" title="20 文件系统"></a>20 文件系统</h3><p>上集我们讲了数据存储，磁带和硬盘这样的技术。他们可以在断电的情况下存储上万亿个位，非常适合存储一整块相关的文件。我们见过很多文件，比如音乐文件，视频文件。这节课我们要讲，什么是文件，计算机如何管理文件。</p>
<h4 id="20-1-计算机中的文件格式"><a href="#20-1-计算机中的文件格式" class="headerlink" title="20.1 计算机中的文件格式"></a>20.1 计算机中的文件格式</h4><h5 id="20-1-1-数据格式与TXT文本文件"><a href="#20-1-1-数据格式与TXT文本文件" class="headerlink" title="20.1.1 数据格式与TXT文本文件"></a>20.1.1 数据格式与TXT文本文件</h5><p>数据可以随意摆放，但是按照一定规律和格式会更好，这叫数据格式。你可以发明自己的格式，但是最好按照已有的格式更好，比如JPG。</p>
<p>最简单的是文本文件，简称TXT，其本质也是二进制。我们可以把二进制转换为十进制，再由ASCII值转换为字符。</p>
<h5 id="20-1-2-波形文件WAV"><a href="#20-1-2-波形文件WAV" class="headerlink" title="20.1.2 波形文件WAV"></a>20.1.2 波形文件WAV</h5><p>更复杂的文件，比如波形文件（wave），简称wav，它存音频文件。在正确读取数据前，需要知道一些信息，如码率，单声道还是立体声。数据的数据，叫<strong><font color="green">元数据</font></strong>。元数据在文件开头，在实际数据前面，因此也叫文件头。音频数据紧跟在元数据后面，是一长串数字，数字代表每秒捕获多次的声音幅度。</p>
<p><img src="https://pic.imgdb.cn/item/66a8a235d9c307b7e9fafa37.png" alt="wav文件格式"></p>
<p>比如，对于一段声音，我们可以得到其波形如下。通过电脑或者手机，每秒可以对声音进行上千次采样，每次采样可以用一个数字表示，声压越高数字越大，也叫“振幅”，wave文件里存的就是这些数据。在播放声音文件时，扬声器会产生相同的波形，播出声音。</p>
<h5 id="20-1-3-位图文件BMP"><a href="#20-1-3-位图文件BMP" class="headerlink" title="20.1.3 位图文件BMP"></a>20.1.3 位图文件BMP</h5><p>位图（Bitmap），后缀.bmp，它存图片，计算机上，图片由很多个叫”像素“的方块组成，每个像素有三种颜色组成：<strong>红，绿，蓝，叫”加色三原色“</strong>，混在一起可以创造其他颜色。如图wav文件一样，bmp文件开头也是元数据，有图像宽度，图像高等，颜色深度信息。BMP文件是一串二进制代码，每三位分别表示红绿蓝的深度。</p>
<p>不管是文本文件，WAV文件，BMP，或者其他文件，其在底层都是一长串二进制。要想知道文件是什么样的，就得先知道文件格式是什么样的。 </p>
<h4 id="20-2-计算机如何存储文件"><a href="#20-2-计算机如何存储文件" class="headerlink" title="20.2 计算机如何存储文件"></a>20.2 计算机如何存储文件</h4><h5 id="20-2-1-目录文件"><a href="#20-2-1-目录文件" class="headerlink" title="20.2.1 目录文件"></a>20.2.1 目录文件</h5><p>虽然硬件可能是磁盘、磁带或者硬盘等，不过通过抽象后，都可以看成一排能存数据的桶。早期计算机只能存一个文件，它会顺序放置，从头存到尾。但随着计算能力和存储容量的提高，存多个文件变得非常有用。最简单的是，多个文件连续存储。这时，知道不同文件的开头和结尾在哪就变得很重要。<strong>需要记录文件的位置，这里叫”目录文件“</strong>。这个文件通常存储在开头。</p>
<p><img src="https://pic.imgdb.cn/item/66a8a437d9c307b7e9fcbb9f.png"></p>
<p>目录文件中，存所有文件的名称，还有创建时间、能否都写等等，最重要的是，目录文件中写明了文件起始位置和文件大小信息。如果更改了文件信息，就必须更新目录文件。这个例子叫”<strong>平面文件系统</strong>“，因为文件都在同一个层次。</p>
<p><img src="https://pic.imgdb.cn/item/66a8a481d9c307b7e9fcfc10.png" alt="目录文件结构"></p>
<h5 id="20-2-2-文件分块——碎片化存储"><a href="#20-2-2-文件分块——碎片化存储" class="headerlink" title="20.2.2 文件分块——碎片化存储"></a>20.2.2 文件分块——碎片化存储</h5><p>现代文件系统可能会出现问题，比如因为文件连续存储，那么前一个文件存储信息过多，可能会覆盖后一个文件。所以出现了两者解决方案：</p>
<ol>
<li>把空间划分成一块块，导致有一些”<strong>预留空间</strong>“，可以方便移动和管理；</li>
<li>拆分文件在多个块里面，目录文件中会记录拆分后文件所在的块。这听起来很像前面讲的虚拟内存。</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/66a8a52dd9c307b7e9fd998e.png" alt="分块存储"></p>
<p>若要删除某个文件<strong>，</strong>计算机会将”目录文件“里的对应文件的信息删除，<strong>注意这里实际的文件并没有被删除，只是可以被其他新文件覆盖。所以计算机取证团队可以利用这点”恢复数据“。</strong></p>
<p>不过，文件因为这种存储方式会变成多个块，我们称他为<strong>碎片</strong>。碎片化的文件不利于读取，就出现了”<strong>碎片化管理</strong>“技术。<strong>碎片化整理</strong>就是将原来的分散在多个块里的数据，按顺序整理好，方便整理。</p>
<h5 id="20-2-3-分层文件系统"><a href="#20-2-3-分层文件系统" class="headerlink" title="20.2.3 分层文件系统"></a>20.2.3 分层文件系统</h5><p>平面层的数据不利于文件查看，所以出现了”分层文件系统“，所以出现一个根目录。根目录可以索引下面的文件夹，这样就可以做一个无限深度的文件夹。如果想把数据移动，我们只需要把一个目录文件的信息删除，然后添加在另一个目录文件下即可。</p>
<p><img src="https://s3.bmp.ovh/imgs/2024/07/30/e96acd5d7a9ba9ae.png" alt="分层文件结构" style="zoom:70%"></p>
<p>文件系统使我们不必关心文件在磁带或磁盘的具体位置，整理和访问文件更加方便。 </p>
<h3 id="21-压缩"><a href="#21-压缩" class="headerlink" title="21 压缩"></a>21 压缩</h3><p>上集我们讨论了文件格式，如何编码文字、声音和图片，还举例了txt、wav、bmp，这些格式虽然有用，但是其效率并不高。我们希望文件能小一点，这样能存大量文件，传输也会更快。解决办法就是压缩，把数据变小。</p>
<h4 id="21-1-无损压缩技术"><a href="#21-1-无损压缩技术" class="headerlink" title="21.1 无损压缩技术"></a>21.1 无损压缩技术</h4><p>我们以图像为例，每个像素的颜色是三种原色：红绿蓝的组合。每个颜色用一个字节存，数字范围是0到255。如果红绿蓝都是255会得到白色。</p>
<h5 id="21-1-1-游程编码压缩"><a href="#21-1-1-游程编码压缩" class="headerlink" title="21.1.1 游程编码压缩"></a>21.1.1 游程编码压缩</h5><p>为了减少所占内存，<strong>一种方法是减少重复信息</strong>。最简单的方法是<strong>游程编码</strong>，适合经常出现相同值的文件。比如，若有连续多个统一颜色，我们可以在最开始的颜色前加一个数字表示重复次数。为了区分哪个是数字，哪个是颜色，我们将所有颜色前面加数字表示重复次数。</p>
<p><img src="https://pic.imgdb.cn/item/66a979b9d9c307b7e9a6431a.png" alt="游程编码示例" style="zoom:60%"></p>
<p>我们在没有损失的情况下，完成了压缩，这叫<strong>无损压缩</strong>。解压后，数据和没有压缩一模一样。</p>
<h5 id="21-1-2-字典编码压缩"><a href="#21-1-2-字典编码压缩" class="headerlink" title="21.1.2 字典编码压缩"></a>21.1.2 字典编码压缩</h5><p>另一种无损压缩，它用更紧凑的方式表示数据块，叫“字典编码”。我们需要一个字典，存储”代码“和”数据“间的对应关系。</p>
<p>比如，我们有四种不同的色组如下，我们需要为这四对色组，生产紧凑代码。</p>
<p><img src="https://pic.imgdb.cn/item/66a97a4ad9c307b7e9a68bc9.png" alt="颜色对"></p>
<p>1950年，霍夫曼发明了一种高效的编码方式，叫<strong>霍夫曼树</strong>。方法是这样，<strong>列出所有块和出现频率，每轮选两个最低频率，然后将其组成一个树，总频率是2，然后不断重复这个过程</strong>。最后得到如下结果，它有一个属性，按频率排列，然后将每个数分支用01表示，就得到了二进制与颜色块的字典。厉害的是，它们决定不会冲突，因为每条路径是唯一的。这意味在代码是”<strong>无前缀的</strong>”，没有代码是以另一个代码开头的。然后，就可以将原来的颜色二进制码压缩。 </p>
<p><img src="https://pic.imgdb.cn/item/66a97b0ad9c307b7e9a6e9b2.png" alt="哈夫曼树编码" style="zoom:40%"></p>
<p>“消除冗余法”和“用更紧凑的表示方法”，这两种方法通常会组合使用。几乎所有的无损格式都用了它们，比如GIF、PNG、PDF、ZIP。<strong>游程编码和字典编码，都是无损压缩，压缩不会丢失位信息，解压可以完全恢复。</strong></p>
<h4 id="21-2-有损压缩技术"><a href="#21-2-有损压缩技术" class="headerlink" title="21.2 有损压缩技术"></a><strong>21.2</strong> 有损压缩技术</h4><p>但有时候，丢失一些数据也可以，因为人们可能看不出。大多数<strong>有损压缩技术</strong>，都用到了这点。</p>
<h5 id="21-2-1-感知编码"><a href="#21-2-1-感知编码" class="headerlink" title="21.2.1 感知编码"></a>21.2.1 感知编码</h5><p>以声音为例，<strong>我们的耳朵有一些频率的声音不能听到，比如超声波，那么录音乐的时候，超声波数据都可以扔掉，因为人类听不到超声波。</strong>另一方面，人们对人声很敏感，所以应该尽可能保持。有损音频编码就是如此，用不同精度编码不同频段。这种删掉人类无法感知的数据的方法，叫“<strong>感知编码</strong>”。</p>
<h5 id="21-2-2-图像与视频压缩编码"><a href="#21-2-2-图像与视频压缩编码" class="headerlink" title="21.2.2 图像与视频压缩编码"></a>21.2.2 图像与视频压缩编码</h5><ul>
<li><strong>图片压缩</strong></li>
</ul>
<p>最著名的有损压缩图像格式是JPEG，人的视觉也与听觉一样不完美，我们善于发现尖锐对比，比如物体边缘，然后看不出不大的颜色变化。JPEG就是利用这点，将负责的8*8像素块，变成简单的像素块，如下所示…………</p>
<p>（这里就不详细说了，有兴趣直接去搜JPEG图像压缩原理即可）。</p>
<ul>
<li><strong>视频压缩</strong></li>
</ul>
<p>视频也是如此，视频就是一长串的连续图片，所以很多方面，图片的技术也使用于视频。因为视频之间帧与帧之间有时变化很小，比如背景(基本会保持一段时间背景不变或变化很小)，这叫“<strong>时间冗余</strong>”，视频不用每一帧都存这些像素，可以只存变化的部分。还有的通过帧分析，用多个补丁代表物体，然后帧之间直接移动这些补丁。MP4就是一种很流行的视频压缩格式。</p>
<p>不过当压缩太严重时就会出错，没有足够空间更新补丁内的像素。</p>
<p>总而言之，压缩对大部分的数据有用，学习压缩也非常重要，因为可以高效存储图片、音乐、视频，这也帮助一些娱乐的兴起，不然宽带可能太贵。</p>
<h3 id="22-命令行界面"><a href="#22-命令行界面" class="headerlink" title="22 命令行界面"></a>22 命令行界面</h3><p>我们之前讨论过输入输出，但是都是计算机组件相互输入输出，比如RAM输出数据、或输指令进CPU，这节课讲用户如何输入和获得数据。我们有设备用于显示信息，如今有个专门的学科叫“人机交互”。</p>
<h4 id="22-1-早期的输入方式——齿轮旋钮开关、纸带"><a href="#22-1-早期的输入方式——齿轮旋钮开关、纸带" class="headerlink" title="22.1 早期的输入方式——齿轮旋钮开关、纸带"></a>22.1 早期的输入方式——齿轮旋钮开关、纸带</h4><p>早期机械计算设备，用齿轮、旋钮和开关等机械结构来输入输出。这些就是交互界面，甚至一些早期电子计算机，也是用一大堆机械面板和线来操作。其输出是打印在纸上。</p>
<p><img src="https://pic.imgdb.cn/item/66a97e77d9c307b7e9a96d25.png" alt="利用机械齿轮进行输入" style="zoom:30%"></p>
<p>然而，到1950年代，机械输入完全消失，因为出现了打孔纸卡和磁带，但输出依然是打印在纸上。当时的计算机输入，<strong>是以计算机为照顾对象输入的</strong>（尽可能迁就机器，对人类好不好用是其次），因为纸带方便计算机读取信息，但是不适合人类了解纸带里的信息。人类输入程序和信息，但是<strong>计算机不会交互式地回应</strong>。程序开始运行后会一直进行，直到结束。 </p>
<h4 id="22-2-输入设备——键盘"><a href="#22-2-输入设备——键盘" class="headerlink" title="22.2 输入设备——键盘"></a>22.2 输入设备——键盘</h4><p>这种情况一直持续到1950年代末，一方面小型计算机变得足够便宜，另一方面计算机变得更快，能同时支持多个程序和用户，这叫“<strong>多任务”和“分时系统</strong>”。计算机需要人类的数据输入，这时有了键盘。由于“QWERTY”型<strong>打字机</strong>已经流行于市面上了，所以键盘也是“QWERTY”型的。</p>
<p>打字机的流行过程也比较曲折。打字机的发明者刚开始没想到会流行于市场，只不过由于十指打字的出现，才使得打字机开始流行。这种打字方式比一个手指快很多，之后还有人学会了盲打。</p>
<p>不过计算机如何使用打字机呢？早期的计算机使用了一种特殊打字机，是专门用于发电报的，叫电传打字机。利用电传打字机，一方的人打的字，可以在另一方显示，使得两个人可以长距离通信。</p>
<p><img src="https://pic.imgdb.cn/item/66a980ead9c307b7e9ab24d7.png" alt="电传通信" style="zoom:30%"></p>
<p>因为电传打字机有电子接口，稍作修改就能用于计算机。电传交互界面在 1960~1970 很常见。</p>
<p>用起来很简单，利用键盘，输入一个命令，然后按回车，计算机就会输出回来，用户和计算机来回“对话”这叫“<strong><font color="red">命令行界面</font></strong>”。比如，输入ls，计算机就会列出所有文件到打印机上。这就是早期的交互界面。</p>
<p><img src="https://pic.imgdb.cn/item/66a98369d9c307b7e9acc4db.png" alt="ls命令" style="zoom:40%"></p>
<p>它是最主要的人机交互方式，一直到 1980 年代。</p>
<h4 id="22-3-显示设备——屏幕"><a href="#22-3-显示设备——屏幕" class="headerlink" title="22.3 显示设备——屏幕"></a>22.3 显示设备——屏幕</h4><p>随着电视剧开始量产，同时处理器和内存也在发展，到1970年代屏幕代替电传打字机进行交互变得可行。但与其为屏幕专门做全新的标准，工程师直接用现有的电传打字机协议，这样<u>屏幕就像无限长的纸</u>，除了输入输出文字，没有其他东西，协议是一样的，所以计算机分不出是纸张还是电子屏幕（也就相当于用电子屏幕<strong>虚拟</strong>实际的电传打字机纸张）；而输入数据依然使用的是键盘。这些包括了屏幕的“虚拟电传打字机”，叫“<strong><font color="blue">终端(Terminal)</font></strong>”。</p>
<p><img src="https://pic.imgdb.cn/item/66a98553d9c307b7e9ae0722.png" alt="配备“屏幕”和“键盘”的计算机" style="zoom:30%"></p>
<p>到1970年代末，屏幕成了计算机的标配。那时候，还发明了文字交互游戏，如“zork”。</p>
<p>现在，我们计算机中还有命令行交互界面，比如windows系统中的CMD命令行界面就是如此，可见<strong>早期计算机对我们现在的计算机运行方式影响巨大</strong>。</p>
<p>命令行界面虽然简单但十分强大，由于编程大部分是打字活，所以程序员们使用命令行也比较自然，因此，即使是现在大多数程序员工作中依然用命令行界面。而且<strong><font color="orange">用命令行访问远程计算机，是最常见的方式</font></strong>，比如服务器在另一个国家。</p>
<h3 id="23-屏幕和2D图形显示"><a href="#23-屏幕和2D图形显示" class="headerlink" title="23 屏幕和2D图形显示"></a>23 屏幕和2D图形显示</h3><h4 id="23-1-早期的图形屏幕"><a href="#23-1-早期的图形屏幕" class="headerlink" title="23.1 早期的图形屏幕"></a>23.1 早期的图形屏幕</h4><p>早期文本任务与图形任务是分开的，早期的屏幕无法清晰地显示图像，还不如将其打印的纸上。<strong>早期屏幕的典型用途，是跟踪程序的运行情况，比如寄存器的值</strong>。因为屏幕更新很快，这对临时值显示简直完美。但是屏幕很少用于显示结果，结果值还是主要用纸打印出来。</p>
<p>这台 1960 年的 PDP-1是一个早期图形计算机的好例子。</p>
<p><img src="https://pic.imgdb.cn/item/66a98b22d9c307b7e9b1e5bf.png" alt="显示屏幕和打字机分开" style="zoom:30%"></p>
<p>图中三个组件是分开的，因为当时文本任务和图像任务是相互分离的。事实上，早期的屏幕性能太差无法清晰地显示文字，而打印到纸上有更高地对比度和分辨率。早期屏幕的典型用途是跟踪程序的运行情况，例如：寄存器的值。</p>
<h4 id="23-2-CRT显示技术"><a href="#23-2-CRT显示技术" class="headerlink" title="23.2 CRT显示技术"></a>23.2 CRT显示技术</h4><p>最早最有影响力的显示技术是<strong>阴极射线管（CRT）</strong>，原理是把电子发射到有磷光体涂层的屏幕上，当电子撞击涂层时，会发光几分之一秒，由于电子是带电粒子，路径可以用磁场控制，屏幕内用板子或线圈，把电子引导到想要的位置上。</p>
<p>这样，就有两种方法绘制图形：</p>
<ul>
<li>1.<strong>引导电子束描绘出形状，这叫矢量扫描</strong>，如果重复地够快就可以显示出现图形；</li>
<li>2.按照固定路径，<strong>一行行来，从上到下，从左到右</strong>，不断重复，只在特定路径扫描，叫“光栅扫描”。</li>
</ul>
<h4 id="23-3-像素"><a href="#23-3-像素" class="headerlink" title="23.3 像素"></a>23.3 像素</h4><p>随着技术发展，我们终于可以<strong>在屏幕上显示清晰的点，叫“像素”</strong>。</p>
<p>液晶显示技术（LCD）和以前的技术相当不同，但LCD也用光栅扫描，每秒更新多次像素里红绿蓝的颜色。</p>
<p><img src="https://pic.imgdb.cn/item/66a993fdd9c307b7e9b931a9.png" alt="液晶（LCD）像素显示" style="zoom:30%"></p>
<h4 id="23-4-符号显示"><a href="#23-4-符号显示" class="headerlink" title="23.4 符号显示"></a>23.4 符号显示</h4><p>不过，早期计算机显示不用像素，因为就算二值400×400的显示，也有16万bits，这已经超过了电脑当时最大存储空间。所以早期电脑是<strong>存符号</strong>，80×25个符号最典型，每个符号用8位ASCII码表示，也才16000bits，这样才合理。</p>
<p><img src="https://pic.imgdb.cn/item/66a99512d9c307b7e9b9e55b.png" alt="存储的符号" style="zoom:20%"></p>
<p>这样计算机需要额外的硬件从内存读取符号，转换成光栅图像，才能显示图像。<strong><font color="red">这个硬件叫“符号生成器”，基本上算是第一代显卡</font></strong>。它内部只要一小块<strong>只读存储器(ROM)</strong>，存着每个字符的图形，叫“点阵图案”。如果图形卡看到一个 8位二进制，发现是字母 K，那么会把字母 K 的点阵图案光栅扫描显示到屏幕的适当位置。为了显示，“字符生成器”会访问内存中的一块特殊区域，这块区域专为图形保留，叫屏幕缓冲区。程序想显示文字时，修改这快区域的值就行。</p>
<p>但是字符集实在太小了，不能显示很多东西。因此对ASCII进行了各种扩展，加新字符。此外，还可以改变背景颜色。</p>
<h4 id="23-5-矢量扫描法"><a href="#23-5-矢量扫描法" class="headerlink" title="23.5 矢量扫描法"></a>23.5 矢量扫描法</h4><p>但是，上面这种方法不能绘制任意图案。科学家想到了<strong>“矢量扫描法”，若要显示文字，就用线条画出来，而不是存一个像素矩阵那样占用大量内存</strong>。这个方法用命令来画线段，因为可以不断改变命令，所以这图案甚至可以是动态的。</p>
<p><img src="https://pic.imgdb.cn/item/66a99783d9c307b7e9bba995.png" alt="利用画线条显示图形" style="zoom:30%"></p>
<h4 id="23-6-Sketchpad"><a href="#23-6-Sketchpad" class="headerlink" title="23.6 Sketchpad"></a>23.6 Sketchpad</h4><p>1962是一个大里程碑，<strong>Sketchpad</strong>诞生，<strong>一个交互式图形界面，用途是计算机辅助设计（CAD）</strong>。用户可以用光笔，进行画图，程序里面还自带了许多元件，帮助进行设计图案。这个发明有巨大意义，它们代表了人机交互的关键转折点。</p>
<h4 id="23-7-像素与位图显示"><a href="#23-7-像素与位图显示" class="headerlink" title="23.7 像素与位图显示"></a>23.7 像素与位图显示</h4><p>1960年代末，计算机存储技术的发展，可以利用像素矩阵来表示图形。<strong>计算机把像素数据存在一个特殊区域，叫“帧缓冲区”</strong></p>
<p>位图显示（BMP）的灵活性，为交互式开启了全新可能，但它的高昂成本持续了十几年。所幸的是，<strong>Sketchpad</strong>等的诞生为图形化交互界面的发展做出了巨大贡献。</p>
<h3 id="24-冷战和消费主义"><a href="#24-冷战和消费主义" class="headerlink" title="24 冷战和消费主义"></a>24 冷战和消费主义</h3><p>之前讲了很多计算机的知识，比如编译器、语言、操作系统、算法和存储等等，这些全部在1940-70年代出现。本节课注意讲一下这个时代的历史，更好地帮我我们理解计算机和计算机的发展。</p>
<h4 id="24-1-二战后的科技发展"><a href="#24-1-二战后的科技发展" class="headerlink" title="24.1 二战后的科技发展"></a>24.1 二战后的科技发展</h4><p>二战之后，两个超级大国关系越来越紧张，美国和苏联出现了冷战。这时期，国家花了大量资金在科学与工程学上，计算机技术发展迅速。</p>
<p>当时发明的计算机，大部分应用于政府和国家，因为只有国家能够承担巨额经费用于计算。计算机和以前的机器不同，以前的机器如蒸汽机和纺织机等等，他们增强了人民的物理能力，而<u>计算机增强的是人类智力</u>。</p>
<h4 id="24-2-Memax假想计算机"><a href="#24-2-Memax假想计算机" class="headerlink" title="24.2 Memax假想计算机"></a>24.2 Memax假想计算机</h4><p><strong>Memex是一台假想的计算机设备</strong>，由范内瓦·布什发表。Memax可以存储数据，帮助人信息交流。他还预测未来会出现一种新的百科全书，信息之间相互连接（维基百科）。Memax的出现，促进了人民对计算机的未来的思考。</p>
<p>在范内瓦·布什建议下，美国建立了国家科学基金会，负责给科学研究提供政府资金，美国的科技领先全球，主要原因就是这个机构。</p>
<h4 id="24-3-日本的收音机崭露头角"><a href="#24-3-日本的收音机崭露头角" class="headerlink" title="24.3 日本的收音机崭露头角"></a>24.3 日本的收音机崭露头角</h4><p>1950年代，消费者开始买晶体管设备，其中值得注意的是收音机。他小而便携，受到大家欢迎。</p>
<p>日本也想从二战后恢复，他们从贝尔实验室获得了晶体管的授权，帮助振兴日本的半导体和电子行业。1955年，索尼的收音机问世，他们把重心放在质量和价格上。因此，短短5年内，日本公司就占领了美国收音机市场的一半。</p>
<p><img src="https://pic.imgdb.cn/item/66a99bced9c307b7e9bfa1ac.png" alt="索尼第一台收音机——TR-55" style="zoom:40%"></p>
<p>苏联此时在计算机方面的计算落后西方几年，但是苏联的太空技术远超他国。</p>
<h4 id="24-4-太空计划促进集成电路发展"><a href="#24-4-太空计划促进集成电路发展" class="headerlink" title="24.4 太空计划促进集成电路发展"></a>24.4 太空计划促进集成电路发展</h4><p>苏联在1957年把第一个卫星送上轨道，1961年把人类送上了太空。所以，美国为了追赶苏联，开始了登月计划。美国花了大量的资金用于资助太空计划。</p>
<p>太空计划一个重要的问题是，如何给太空船导航，这需要电脑计算复杂度轨道。太空电脑需要小、快、可靠，所以NASA采用全新工艺，集成电路。太空计划的阿波罗导航计算机，首先使用了集成电路。太空计划，促进了世界计算机工艺发展。</p>
<h4 id="24-5-消费级电子发展"><a href="#24-5-消费级电子发展" class="headerlink" title="24.5 消费级电子发展"></a>24.5 消费级电子发展</h4><p>其实，对集成电路发展更促进的是军事，特别是洲际导弹和核弹。超级计算机，就是用于服务美国的政府机构。</p>
<p>最初，美国的半导体行业靠着高利润和政府合作起步，消费市场被忽略了。日本此时抓住机会，大力发展消费级电子设备，提升质量和工作效率。1970年代，太空竞赛和军事渐渐减少，美国半导体企业发现无法在消费领域竞争过日本，因为日本的产品更便宜和质量更高。这时很多美国公司倒闭，英特尔和仙童半导体都面临巨大危机。</p>
<p>美国公司的无力，造就了日本如卡西欧、索尼等快速发展，比如手持计算机等。很快，日本产品开始大量占领市场，计算器、手表等等。这些促进了微处理器的发展。同时，街机游戏也因此发展。70年代，家用计算机和游戏机出现。</p>
<h4 id="24-6-结语"><a href="#24-6-结语" class="headerlink" title="24.6 结语"></a>24.6 结语</h4><p>从大到人类可以随意行走，到手持电子设备，这种巨大的变化由两种力量推动，政府和消费者。政府资金促进了早期发展，消费者促进了行业持续发展。政府和消费者对科技的促进，这种关系直到现在依然存在。</p>
<h3 id="25-个人计算机革命"><a href="#25-个人计算机革命" class="headerlink" title="25 个人计算机革命"></a>25 个人计算机革命</h3><h4 id="25-1-为什么个人计算机时代能到来"><a href="#25-1-为什么个人计算机时代能到来" class="headerlink" title="25.1 为什么个人计算机时代能到来"></a>25.1 为什么个人计算机时代能到来</h4><p>随着集成技术和CPU的发展，把整台计算机做到一张电路板上成为可能，大大降低了制造成本。并且，那时有便宜可靠的存储介质，比如磁带和软盘。还有低成本的显示器，通常是电视剧稍作改装而成。这时候做成的计算机叫“微型处理器”，并且计算机的成本也不断降低，这使得一个人的计算机成为可能。个人计算机时代到来。</p>
<p><img src="https://pic.imgdb.cn/item/66a99f46d9c307b7e9c22284.png" alt="电视机改装的显示器" style="zoom:20%"></p>
<p>综上，计算机成本下降+性能提升，让个人计算机成为可能。</p>
<h4 id="25-2-商业计算机与Basic语言"><a href="#25-2-商业计算机与Basic语言" class="headerlink" title="25.2 商业计算机与Basic语言"></a>25.2 商业计算机与Basic语言</h4><p>1975年出现了第一台可以说是商业计算机。这台计算机需要自己购买配备组件，所以组件买卖在这时候兴起。</p>
<p><img src="https://pic.imgdb.cn/item/66a99fedd9c307b7e9c2a137.png" alt="计算机组件（键盘、打印机等）" style="zoom:30%"></p>
<p>更困难的是，计算机的编程语言依然是机器语言，这对大部分人来说都是非常困难的。比尔盖茨和他的同伴，开发了能运行<strong>basic语言</strong>，为此，他们需要一个机器，把Basic语言转换为机器语言，这叫“<strong>解释器</strong>”。</p>
<blockquote>
<p>“解释器”和”编译器”类似，区别是”解释器”在程序运行的同时转换编码，而””编译器”提前转换好整个程序文件的编码，然后一次性整体运行。</p>
</blockquote>
<p>这时，乔布斯开始出售原型机，用户需要自己加键盘、电源和机箱，这叫Apple1，苹果计算机公司的第一个产品。</p>
<h4 id="25-3-整体机的出现"><a href="#25-3-整体机的出现" class="headerlink" title="25.3 整体机的出现"></a>25.3 整体机的出现</h4><p>不过此时的电脑是要自己组配各个组件的，不过后来出现了整体机，如Apple2。这种集成了电脑、键盘和屏幕的全套整体计算机，吸引了大量的人购买。</p>
<p><img src="https://pic.imgdb.cn/item/66a9a1e9d9c307b7e9c41e2e.png" alt="整体机计算机" style="zoom:20%"></p>
<p>Apple2以及当时出现的其他整体计算机，配备了basic语言，用户可以利用此编写自己的程序。同时，各种各样的软件开始发展。这次计算机革命，最重要的是他们是面向普通消费者的，而不是政府和企业。</p>
<h4 id="25-4-IBM兼容框架"><a href="#25-4-IBM兼容框架" class="headerlink" title="25.4 IBM兼容框架"></a>25.4 IBM兼容框架</h4><p>IBM公司为了抓住市场，也开发了自己的计算机，这台计算机最与众不同的是，它可以添加其他外设设备，比如显卡、声卡和游戏控制杆等等。这种开发架构叫“<strong>IBM兼容</strong>”。大量公司开始使用IBM兼容，IBM兼容体系的计算机越来越多。不使用IBM兼容的计算机大部分都失败了，除了苹果公司。</p>
<h4 id="25-5-苹果公司——封闭框架"><a href="#25-5-苹果公司——封闭框架" class="headerlink" title="25.5 苹果公司——封闭框架"></a>25.5 苹果公司——封闭框架</h4><p>苹果公司最终选择了相反方式，“<strong>封闭架构</strong>”，用户无法加新设备到计算机中。苹果的封闭框架可以使他们做出来的产品更加照顾用户的体验感。</p>
<p><img src="https://pic.imgdb.cn/item/66a9a38dd9c307b7e9c58057.png" alt="具有重要意义的苹果计算机产品——Macintosh" style="zoom:30%"></p>
<p>为了和IBM兼容体系的计算机对抗，苹果公司需要非常具有体验感的产品出现。他们的答案是<strong>Macintosh</strong>，于1984年发布，一台突破性且价格适中的一体式计算机，用的不是命令行界面，而是图形界面。</p>
<h3 id="26-图形用户界面GUI"><a href="#26-图形用户界面GUI" class="headerlink" title="26 图形用户界面GUI"></a>26 图形用户界面GUI</h3><h4 id="26-1-图形用户界面GUI"><a href="#26-1-图形用户界面GUI" class="headerlink" title="26.1 图形用户界面GUI"></a>26.1 图形用户界面GUI</h4><p>上集我们说，苹果在1984年发布的Macintosh，是普通人可以买到的第一台图形用户界面的计算机，还带一个鼠标。<strong>那时的计算机全是命令行的，图形界面是个革命性的进展</strong>。</p>
<p>我们不需要记住指令，只需要在屏幕上点击即可完成想要的功能，计算机突然变直观了，不仅仅是计算机科学家，普通人也能用计算机。这就是图形用户界面GUI。</p>
<p>人们认为是Macintosh把图形用户界面（GUI）变成主流，但实际上图形界面是几十年努力的结果。</p>
<h4 id="26-2-恩格尔巴特"><a href="#26-2-恩格尔巴特" class="headerlink" title="26.2 恩格尔巴特"></a>26.2 恩格尔巴特</h4><p>恩格尔巴特设计了一个现代化的计算机，包括图形界面、鼠标等等。1968年，恩格尔巴特演示了这台计算机，它可以进行视频通话、多人文档操作和多窗口等等。</p>
<p><img src="https://pic.imgdb.cn/item/66a9a4a3d9c307b7e9c66365.png" alt="恩格尔巴特制作的计算机可视频通话" style="zoom:30%"></p>
<p>不过由于这种设计太过超前了，最终还是失败了。但是他对于计算机科学家思维上的启发却是实在的，恩格尔巴特因此于1997年获得图灵奖。</p>
<h4 id="26-3-施乐奥托与WIMP桌面"><a href="#26-3-施乐奥托与WIMP桌面" class="headerlink" title="26.3 施乐奥托与WIMP桌面"></a>26.3 施乐奥托与WIMP桌面</h4><p>第一台真正带GUI的计算机是施乐奥托，于1973年完成。施乐计算机将2D屏幕当作“桌面”，用户可以打开多个程序，<strong>每个程序都在一个框里，叫“<font color="blue">窗口</font>”</strong>。窗口可以重叠，挡住后面的东西。还有桌面组件，比如计算器和时钟。这台计算机的发明者用窗口、图标、菜单和指针来设计界面，因此叫WIMP桌面。</p>
<p>施乐奥托团队大约制造了2000台，有的在施乐公司内部使用，有的给大学实验室，从来没有商业出售过。施乐卖的是印刷机，但在文本和图形制造工具领域也有领先。例如，他们首先使用了“剪切”“复制”“粘贴”这样的术语。施乐公司后来开发的“施乐之星系统”，不过依然过于超前并且价格昂贵，而没有流行。</p>
<h4 id="26-4-苹果和微软"><a href="#26-4-苹果和微软" class="headerlink" title="26.4 苹果和微软"></a>26.4 苹果和微软</h4><p>苹果公司的乔布斯看到了施乐团队作品的闪光之处，于是和施乐团队合作。苹果公司先后发布了Apple Lisa和<strong>Macintosh</strong>（1980年代），前者由于太贵没有太多人购买，后者在市场上火爆，可以说是<strong>第一台商业图形用户界面的计算机</strong>。</p>
<p>不幸的是，苹果公司的产品虽然大受欢迎，但是因为没有人在苹果电脑上制作软件，所以销量逐渐下来了。乔布斯与苹果公司股东关系愈发紧张，不久被苹果公司赶了出来。</p>
<p>在这期间，微软公司的Windows1.0出现了，并且站稳了市场，十年内，95%的个人计算机都有微软的Windows。刚开始的Windows系统还不像苹果一样有GUI，不过后来微软开发了面向消费者的GUI操作系统——<strong>Windows95</strong>，Windows95系统有许多至今还在用的设计，比如开始菜单、任务栏和Windows文件管理器。</p>
<p><img src="https://pic.imgdb.cn/item/66a9a7f8d9c307b7e9c89c25.png" alt="Windows95系统" style="zoom:30%"></p>
<p><mark>现在的系统，无论是Windows、Linux还是Mac，都是施乐奥托WIMP的变化版本</mark>。未来，计算机科学家和界面设计师会设计更强大的GUI。 </p>
<h3 id="27-3D图形"><a href="#27-3D图形" class="headerlink" title="27 3D图形"></a>27 3D图形</h3><p>之前讲的图形界面都是二维的，但我们生活的世界是3维的，本节课我们讲三维图形。</p>
<h4 id="27-1-图像投影"><a href="#27-1-图像投影" class="headerlink" title="27.1 图像投影"></a>27.1 图像投影</h4><p>三维空间用到的是三维坐标，但是计算机无法表示三维坐标，所以要将三维图形投影到二维上来。三维投影有很多，比如<strong>正交投影、透视投射</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/66a9aa81d9c307b7e9cb54c6.png" alt="正交和透视投影"></p>
<blockquote>
<p>PS：透视投影可以类比现实生活中看马路会交于一点的情景。</p>
</blockquote>
<p>如果想画立方体这种简单的几何图形，直线就够了；但更复杂的图形，三角形更好，如下图所示。在3D图形学中<br>我们称三角形为“多边形”(Polygons)，一堆多边形的集合叫 网格。网格越密，表面越光滑，细节越多，但意味着更多计算量。</p>
<p><img src="https://pic.imgdb.cn/item/66a9ab9fd9c307b7e9cc244d.png"></p>
<blockquote>
<p>PS：为什么使用三角形：是因为空间3个点可以确定唯一一个平面，具体请参考本节视频内容。</p>
</blockquote>
<p>设计三维图形时，设计师要考虑细节的程度，如果过于复杂的细节的图形（三角形过多），就会导致帧率下降，画面卡顿。</p>
<h4 id="27-2-图像填充"><a href="#27-2-图像填充" class="headerlink" title="27.2 图像填充"></a>27.2 图像填充</h4><p>填充图形的经典算法叫<strong>扫描线渲染</strong>，就是通过一条线的交点来进行图形填充，当然这样可能导致边缘不精细，边缘出现锯齿形状。一种减轻锯齿的方法叫<strong>抗锯齿</strong>。<strong>也就是如果在三角形内部的方块，直接填充，在交线处，虚化填充。</strong>抗锯齿在计算机文字和图标中大量使用。</p>
<p><img src="https://pic.imgdb.cn/item/66a9adffd9c307b7e9cdf47f.png" alt="抗锯齿原理和例子" style="zoom:50%"></p>
<p>图像里面不同的物体有的会<strong>遮挡</strong>，这很常见。要渲染图片时，类似排序算法，计算机根据由远到近一次渲染覆盖，这叫“<strong><u>画家算法</u></strong>”，因为画家也是先画背景，然后再画更贴近的东西。</p>
<p>此外，还有<strong><u>深度缓存算法</u></strong>，就是根据距离一步步地加载最小的数字到对应的格子中。最后得到的图形，既有哪里需要填充图块，也有哪种颜色是最终需要填充的。</p>
<p><img src="https://pic.imgdb.cn/item/66a9af7ed9c307b7e9cf0bcd.png" alt="深度缓存算法" style="zoom:70%"></p>
<p>3D游戏里面有个优化叫<strong>背景剔除</strong>，也就是三角形的两面，游戏只加载玩家能看到的那一面，另一面不加载，这样若穿到另一面，容易产生透视BUG。比如穿越火线里面的卡BUG进行透视就是这样的。 </p>
<p><img src="https://pic.imgdb.cn/item/66a9b02ad9c307b7e9cfa640.png" alt="背景透视BUG" style="zoom:70%"></p>
<h4 id="27-3-明暗处理"><a href="#27-3-明暗处理" class="headerlink" title="27.3 明暗处理"></a>27.3 明暗处理</h4><p>我们讲灯光，也叫<strong>明暗处理</strong>。我们将图像，经过平面着色，也就是根据光源，给不同的部分设置不同程度的阴影，达到三维的目的。</p>
<p><img src="https://pic.imgdb.cn/item/66a9b16ed9c307b7e9d0894c.png" style="zoom:70%"></p>
<p>此外，还有<strong>高洛德着色和冯氏着色法</strong>，帮助形成更好的三维图像。</p>
<p><img src="https://pic.imgdb.cn/item/66a9b1a8d9c307b7e9d0b103.png" alt="高洛德着色" style="zoom:70%"></p>
<h4 id="27-4-纹理与图像处理单元"><a href="#27-4-纹理与图像处理单元" class="headerlink" title="27.4 纹理与图像处理单元"></a>27.4 纹理与图像处理单元</h4><p>此外，图像的纹理也有多种算法，最简单的是<strong>纹理映射。</strong>以上这些图像算法，我们可以通过硬件加速得到更快的运算。此外，可以将图像分块，然后多块并行渲染。CPU不是为此设计的，因此图形运算不快，所以计算机工程师为图形做了专门的处理器——<strong>GPU“图形处理单元”</strong>，就是专门用于图形渲染和处理的。GPU在显卡上，周围有专用的RAM(显存)，所有网格和纹理都在里面，让 GPU 的多个核心可以高速访问。现代显卡，如 GeForce GTX 1080 TI有3584个处理核心，提供大规模并行处理，每秒处理上亿个多边形！</p>
<p><img src="https://pic.imgdb.cn/item/66a9b28dd9c307b7e9d15efb.png" alt="英伟达GPU" style="zoom:70%"></p>
<h3 id="28-计算机网络"><a href="#28-计算机网络" class="headerlink" title="28 计算机网络"></a>28 计算机网络</h3><p>早期的计算机和网络是分开的，不过随着时间发展，第一个计算机网络出现了。计算机网络的发展，帮助人们有了更快的信息交互方式，极大地改变了人们的生活，这节课我们就来讲计算机网络的发展。</p>
<p>第一个计算机网络出现在1950-60年代，通常在公司或研究室内部使用，为了方便信息交互，这叫“<strong>球鞋网络</strong>”。第二个好处是能共享物理资源，比如与其用多台打印机，不如用一台联网的打印机。<strong><mark>计算机近距离构成的小型网络，叫局域网，简称LAN</mark></strong>。局域网能小到是同一个房间里的两台机器或大到校园里的上千台机器。</p>
<p>尽管开发和部署了很多不同 LAN 技术，其中最著名的局域网是“<strong>以太网</strong>”，开发于1970年代，至今仍被使用。以太网是这样设计的，将要组成网络的计算机用电缆相互连接，如果一台计算机想要发送数据时，就将数据以电信号形式传到电缆，以太网链路上任何一台计算机都可以看见数据。</p>
<p><img src="https://pic.imgdb.cn/item/66a9ba0ed9c307b7e9d79eec.png" style="zoom:30%"></p>
<p>为了解决定向问题，以太网需要为每台计算机设置唯一的媒体访问控制地址，简称<strong>MAC地址</strong>。这个数据放在数据头部作为数据的前缀发送到网络中，所以，计算机只需要监听以太网电缆只有看到自己的 MAC 地址，才处理数据。这运作得很好，现在制造的每合计算机都自带唯一的MAC地址用于以太网和无线网。</p>
<p>多台电脑共享一个传输媒介，这种方法叫“<strong>载波侦听多路访问</strong>”，简称CSMA。载体指运输数据的共享媒介，以太网数据传输的载体是铜线，WiFi的载体是无线空间。很多计算机同时侦听载体，所以叫“侦听”和“多路访问”。载体传输数据的速度叫<strong>“<font color="red">带宽</font>”</strong>。</p>
<p>不过问题是，在同一链路上传输，可能会出现同时发送的情况，造成数据冲突。最明显的解决办法是停止传输，然后等待后再传输。但是这个有一个问题，就是如果冲突过多的话，就会产生麻烦。以太网有个简单有效的解决办法，就是在同一个等待时间下加一个随机时间。此外，还有<strong>指数退避法</strong>，就是当再次检测到冲突的话，就等待原来的双倍的时间。以太网和WiFi都用这种方法，很多其他传输协议也用。</p>
<p>此外，用同一根网线链接整个区域的计算机还是不可能的，我们需要减少同一载体中设备的数量，载体和其中的设备总称“冲突域”。为了减少冲突 我们可以用<strong>交换机(Switch)</strong>把它拆成两个冲突域：</p>
<p><img src="https://pic.imgdb.cn/item/66a9bc99d9c307b7e9d979ee.png" style="zoom:30%"></p>
<p>交换机位于两个更小的网络之间，必要时才在两个网络间传数据。交换机会记录一个列表写着哪个 MAC 地址在哪边网络。大型网络(包括最大的互联网)的底层也是类似的原理。</p>
<p><img src="https://pic.imgdb.cn/item/66a9bd91d9c307b7e9da2ba9.png" style="zoom:30%"></p>
<p>这些大型网络有趣之处是：从一个地点到另一个地点通常有多条路线。这就带出了另一个话题——<strong>路由</strong>。连接两合相隔遥远的计算机或网路，最简单的办法是分配一条专用的通信线路（早期电话系统就是这样运作的），这叫”<strong><mark>电路交换</mark></strong>”，因为是把电路连接到正确目的地，能用倒是能用，但不灵活而且价格昂贵，因为总有闲置的线路，好处是如果有一条专属于自己的线路你可以最大限度地随意使用，无需共享。因此军队，银行和其他一些机构，依然会购买专用线路来连接数据中心。</p>
<blockquote>
<p>交换机是连接若干个主机的机器，用来解决冲突域问题。</p>
<p>路由器是连接主机、路由器或交换机的机器，用来构建数据传输的线路。 </p>
</blockquote>
<p>传输数据的另一个方法是“<strong><mark>报文交换</mark></strong>”。“报文交换”就像邮政系统一样，不像之前A和B有一条专有线路，消息会经过好几个站点，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/66a9bf73d9c307b7e9db936e.png" style="zoom:40%"></p>
<p>每个站点都知道下一站发哪里因为站点有表格，记录到各个目的地，信件该怎么传。报文交换的好处是：可以用不同路由使通信更可靠更能容错，对于上面的例子，若<code>HOP2</code>站点被破坏了，由图容易知道还有很多其他路线可走。在这个例子中，各个<code>城市HOP</code>就像路由器一样，消息沿着路由跳转的次数叫做“跳数”。记录跳数很有用，因为可以分辨出路由问题，如果看到某条消息的跳数很高就知道路由肯定哪里错——这被称为“<strong>跳数限制</strong>”。</p>
<p>报文交换的缺点之一是有时候报文比较大会堵塞网络，因为要把整个报文从一站传到下一站后才能继续传递其他报文。传输一个大文件时，整条路都阻塞了，导致即便你只有一个1KB的电子邮件要传输，也只能等大文件传完，或是选另一条效率稍低的路线。解决方法是 将大报文分成很多小块，叫”<strong>数据包</strong>“。就像报文交换，每个数据包都有目标地址，因此路由器知道发到哪里。<strong><font color="red">报文具体格式由”互联网协议”定义，简称IP</font></strong>，这个标准创建于 1970 年代。每台联网的计算机都需要一个IP地址。数百万台计算机在网络上不断交换数据，瓶颈的出现和消失是毫秒级的，路由器会平衡与其他路由器之间的负载，以确保传输可以快速可靠，这叫”<strong>阻塞控制</strong>“。</p>
<p>有时，同一个报文的多个数据包会经过不同线路，到达顺序可能会不一样，这对一些软件是个问题。幸运的是，在IP 之上还有其他协议，例如：TCP/IP可以解决乱序问题。</p>
<p>将数据拆分成多个小数据包，然后通过灵活的路由传递，非常高效且可容错，如今互联网就是这么运行的，这叫<strong>”分组交换“</strong>。有个好处是：它是去中心化的，没有中心杈威机构，没有单点失败问题。</p>
<p>如今，全球的路由器协同工作，找出最高效的线路，用各种标准协议运输数据，比如“因特网控制消息协议(ICMP)”和”边界网关协议(BGP)“。世界上第一个分组交换网络以及现代互联网的祖先是ARPANET。</p>
<p><img src="https://pic.imgdb.cn/item/66a9c522d9c307b7e9e134eb.png" alt="ARPANET" style="zoom:50%"></p>
<h3 id="29-互联网"><a href="#29-互联网" class="headerlink" title="29 互联网"></a>29 互联网</h3><p>任意计算机都和一个巨大的分布式网络连接在一起，称为<strong>互联网（Internet）</strong>。</p>
<h4 id="29-1-数据在互联网上的传输过程"><a href="#29-1-数据在互联网上的传输过程" class="headerlink" title="29.1 数据在互联网上的传输过程"></a>29.1 数据在互联网上的传输过程</h4><p>当你在家中通过计算机观看网上视频时，你的计算机首先需要连接到局域网LAN，这个局域网是由家里WiFi路由器连接的所有设备组成的。然后家里的局域网再通过路由器连接到<strong>广域网（Wide Area Network，WAN</strong>），广域网的路由器一般属于你的<strong>互联网服务提供商（Internet Service Provider，ISP）</strong>。在广域网里，首先会有一个区域性路由器，比如覆盖你所在街区的一个路由器，然后该路由器会连接到一个更大的广域网中，比如覆盖你所在的城市，可能再跳跃几次，最终会到达互联网主干，一般由一群超大型、带宽超高的路由器组成。</p>
<blockquote>
<p>即首先会连接到你家里的WiFi路由器构建的局域网，然后该路由器再连接到ISP提供的广域网中，该广域网是由很多层层递进的路由器构成的。</p>
<p>比如要从YouTube中获得视频，数据包首先会到达互联网主干，沿着主干到达对应保存该视频文件的YouTube服务器，可能这里会跳4次到达互联网主干，然后跳两次穿过互联网主干，最终再跳4次到达YouTube服务器，所以总共会跳跃10次。</p>
</blockquote>
<p> 我们可以通过<code>traceroute</code>来看跳跃了几次： </p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows上的Traceroute</span><br><span class="line">1.按开始按钮</span><br><span class="line">2.输入“ CMD”，然后按“ Enter”</span><br><span class="line">3.在命令提示符下，键入“ tracert dftba.com”</span><br><span class="line"></span><br><span class="line">在Mac上的Traceroute</span><br><span class="line">1.点击“转到”下拉菜单</span><br><span class="line">2.点击“实用程序”</span><br><span class="line">3.打开终端</span><br><span class="line">4.键入“ traceroute dftba.com”</span><br><span class="line"></span><br><span class="line">Linux上的Traceroute</span><br><span class="line">1.通过键入CTRL + Alt + T打开终端</span><br><span class="line">2.输入：“ traceroute dftba.com”</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/66a9de34d9c307b7e9f7f21a.png" alt="在印第安访问加州的DFTBA服务器，经历11次中转"></p>
<p>但是数据包到底是怎么传递过去的呢？如果传输时数据包丢失了，会发生什么？当我们在浏览器中输入网址时，浏览器怎么知道服务器的地址是什么呢？ </p>
<p>就像上节介绍的，互联网是一个巨大<strong>分布式网络</strong>，如果要发送的数据较大，分组传输就会将数据拆成一个个较小的数据包进行传输。其中数据包要想在互联网上进行传输，就要符合<strong>互联网协议（Internet Protocol，IP）</strong>。</p>
<blockquote>
<p>类似于邮寄手写信一般，每封信都需要一个地址，并且地址必须是唯一的，并且信的大小和重量也是有限制的，否则信件就无法送达。</p>
</blockquote>
<h4 id="29-2-用户数据报协议UDP"><a href="#29-2-用户数据报协议UDP" class="headerlink" title="29.2 用户数据报协议UDP"></a>29.2 用户数据报协议UDP</h4><p>IP数据包也是如此，因为IP是一个非常底层的协议，数据包的头部只包含目标地址（IP地址），意味着当数据包到达对方电脑时，计算机不知道要把数据包交给哪个程序（比如QQ或微信或者浏览器），因此需要在IP之上，开发更高级的协议。</p>
<p><img src="https://pic.imgdb.cn/item/66a9dfa0d9c307b7e9f91b97.png" style="zoom:80%"></p>
<p>最简单常见的协议称为用户数据报协议（User Datagram Protocol，UDP）。UDP也有头部，位于data payload里面，在data之前。UDP头部里面包含了很多有用的信息，其中之一就是<strong>端口号（Port Number）</strong>，<em><u>每个想访问网络的程序都要向操作系统申请一个端口号。所以当数据包到达时，接收方的操作系统会读取UDP头部里的端口号，来确定该数据包是要交给哪个软件的</u></em>。</p>
<blockquote>
<p>示例：每个想访问网络的程序，都要向操作系统申请一个端口，例如QQ会申请端口3478，当一个数据包到达时，接收方的操作系统会读 UDP 头部，读里面的端口号，如果看到端口号为3478，就把数据包交给QQ。</p>
</blockquote>
<p> 简单来说，<strong>IP协议通过IP地址把数据包送到正确的计算机内；UDP通过数据包里的端口号送到正确的程序</strong>。 </p>
<p><img src="https://pic.imgdb.cn/item/66a9e3aad9c307b7e9fdde9e.png" alt="image.png"></p>
<p>同时UDP的头部中还有<strong>校验和（Checksum）</strong>，通过对数据求和来检查数据是否正确。假设UDP数据包里原始数据是<code>89 111 33 32 58 41</code>， 最简单的计算校验和的方式就是，在发送数据包之前，计算机会把所有数据加在一起，计算出校验和364。在UDP中，校验和是以16位形式存储的，如果计算出来的和超过16位能表示的最大值，则高位数会被丢弃，只保留低位。当接收方计算机接收到这个数据包时，也会重复以上过程，如果计算出来的校验和和UDP中保存的校验和相同，代表数据是正常的，否则数据是出错的。</p>
<h4 id="29-3-传输控制协议（Transmission-Control-Protocol，TCP）"><a href="#29-3-传输控制协议（Transmission-Control-Protocol，TCP）" class="headerlink" title="29.3 传输控制协议（Transmission Control Protocol，TCP）"></a>29.3 传输控制协议（Transmission Control Protocol，TCP）</h4><p>但是，UDP不提供数据修复或数据重发机制，当接收方知道数据损坏后，一般只是丢弃这个数据包。并且当发送方使用UDP协议发送数据包时，是无法得知数据包是否到达目的地的。</p>
<p>有些程序并不在意以上问题，因为UDP十分简单且快速。比如视频通常使用UDP协议，当数据包丢失时，也就造成视频卡顿。</p>
<p>但是有些数据不能接受数据包丢失的问题，比如发送电子邮件时，所有数据必须到达，所以就需要<strong>传输控制协议（Transmission Control Protocol，TCP）</strong>。和UDP一样，它的头部也保存在数据之前，人们通常将IP协议和TCP协议统称为<strong>TCP/IP协议</strong>。TCP的头部中也包含端口号和校验和，并且TCP协议还提供更高级的功能(这里只简单介绍几个重要的)：</p>
<ol>
<li>TCP的数据包是有序号的<br>使得接收方可以通过这个序号将数据包排成正确顺序，即使到达时间不同。</li>
<li>TCP要求接收方收到数据包并校验和检查无误后，要给发送方发送一个<strong>确认码（Acknowledgement，ACK）</strong>，代表数据包已经正确接收。<br>当发送方接收到确认码后，就知道上一个数据包成功抵达了，发送方就会发送下一个数据包，如果这次发送方过了一段时间没有接收到确认码，则会重新发送一次。即使这里只是由于确认码延迟了，使得接收方那里有重复的数据包，但是通过序列号，可以直接删除重复的数据包。</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/66a9e6a1d9c307b7e900760e.png" style="zoom:50%"></p>
<p>并且数据包并不会一个个数据包进行传输，而是<strong>同时发送多个</strong>数据包，同时接收多个确认码，这将大大提高效率，不用浪费时间等待确认码。并且通过确认码的成功率和来回时间，我们可以推测网络的拥塞程度，TCP通过这个信息，来调整同时发包数量来解决拥塞问题。 </p>
<p>简而言之，TCP可以处理乱序和丢包问题，并且可以根据拥塞情况自动调整传输率。但是由于确认码数据包的存在，使得TCP需要传输的数据包数量翻了一倍，并且并没有传输更多信息，这对时间要求很高的程序代价太高，所以这类程序就会使用UDP协议。</p>
<h4 id="29-4-域名DNS"><a href="#29-4-域名DNS" class="headerlink" title="29.4 域名DNS"></a>29.4 域名DNS</h4><p>当计算机访问一个网站时，需要两个东西：① IP地址（目标网站的地址）和 ② 端口号（对应于你使用的计算机浏览器）。</p>
<p>但是通过IP地址访问网站十分不方便，所以互联网提供一个特殊服务，来将<strong>域名（Domain Name）</strong>和IP地址一一对应，称为<strong>域名系统（Dimain Name System，DNS）</strong>，一般DNS服务器都是由ISP提供的。当你在浏览器中输入网站域名时，浏览器就会去访问DNS服务器，DNS就会去查表，如果域名存在，则会返回浏览器对应IP地址，然后浏览器就会给这个IP地址发送TCP请求。</p>
<p>因为当前域名特别多，所以DNS不会将其保存成列表形式，而是将其保存成树状结构。最顶层是<strong>顶级域名（Top Level Domain，TLD）</strong>，比如<code>.com</code>和<code>.gov</code>；下一层是<strong>二级域名（Second Level Domain）</strong>， 比如<code>google.com</code>和<code>dftba.com</code>；再下一层是<strong>子域名（Sub-domain）</strong>，比如<code>images.google.com</code>等等。由于这个树结构特别大，因此这些数据分布在很多DNS服务器上，不同服务器负责树的不同部分。</p>
<p><img src="https://pic.imgdb.cn/item/66a9e8b0d9c307b7e90249a2.png" alt="域名的树结构" style="zoom:80%"></p>
<ul>
<li><strong>物理层</strong>：过去两集里，我们讲了线路里的电信号，以及无线网络里的无线信号，这被称为“物理层”。</li>
<li><strong>数据链路层</strong>：负责操控“物理层”，数据链路层有：媒体访问控制地址(MAG)、碰撞检测、指数退避以及其他一些底层协议。</li>
<li><strong>网络层</strong>：负责各种报文交换和路由。</li>
<li><strong>传输层</strong>：负责在计算机之间进行点到点的传输，而且还会检测和修复错误；本小节的UDP和TCP协议都属于本层。</li>
<li><strong>会话层</strong>：会使用TCP和UDP来创建连接，传递信息，然后关掉连接。</li>
</ul>
<p>以上是<strong>开放式系统互联通信参考模型（Open System Interconnection model，OSI）</strong>下的5层，这个框架将网络通信划分成了很多层，每一层处理各自的问题。这种抽象可以使得分工改进多个层，而无需考虑整体复杂性。并且OSI还有额外两层：<strong>表示层（Presentation Layer）</strong>和<strong>应用层（Application Layer）</strong>，在下一节中进行介绍。</p>
<p><img src="https://pic.imgdb.cn/item/66a9eb60d9c307b7e9048afb.png" alt="开放式系统互联通信参考模型" style="zoom:70%"></p>
<h3 id="30-万维网"><a href="#30-万维网" class="headerlink" title="30 万维网"></a>30 万维网</h3><p>前两节深入讨论了电线 信号 交换机 数据包路由器以及协议，它们共同组成了互联网。这一节将向上抽象一层，来讨论<strong>万维网（World Wide Web）</strong>。万维网和互联网的概念完全不同，万维网是运行于互联网之上的，还有其他比如Skype、Instagram等也是运行在互联网之上的。互联网是用来传输数据的管道，各种程序都会使用到，其中传输最多数据的程序就是万维网，我们可以使用特殊的程序——<strong><font color="orange">浏览器（Web Browser）</font></strong>来访问万维网。</p>
<h4 id="30-1-超链接"><a href="#30-1-超链接" class="headerlink" title="30.1 超链接"></a>30.1 超链接</h4><p>万维网的最基本单位是单个页面，页面里面包含内容，也有访问其他页面的链接，这些链接称为<strong>超链接（Hyperlink）</strong>。这些超链接形成巨大的互联网络，这也是万维网名字的由来。</p>
<blockquote>
<p>现在说起来觉得很简单，但在超链接做出来之前，计算机上每次想看另一个信息时，你需要在文件系统中找到它或是把地址输入搜索框，有了超链接，你可以在相关主题间轻松切换。</p>
</blockquote>
<p>并且由于文字超链接的强大，它有一个特殊的名字——<strong>超文本（Hypertext）</strong>。如今超文本最常指向的是另一个页面，这些页面会被获取并由浏览器进行渲染。</p>
<p>为了使网页能够互相连接，每个网页需要一个唯一的地址，这个地址称为<strong>统一资源定位器（Uniform Resource Locator，URL）</strong>，比如<code>thecrashcourse.com/courses</code>就是一个页面URL。</p>
<p>当你访问<code>thecrashcourse.com</code>网址时，计算机首先会进行DNS查询，这里输入一个域名，然后DNS就会返回给浏览器对应的计算机IP地址。然后浏览器就会打开一个TCP连接到这个IP地址对应的计算机上，而这个计算机运行着一个特殊的软件——<strong>网络服务器（Web Server）</strong>，网络服务器的标准端口是80。此时，你的计算机就连接到了<code>thecrashcourse.com</code>对应的服务器了，下一步是向服务器请求<code>courses</code> 页面，这里就会用到<strong>超文本传输协议（Hypertext Transfer Protocol，HTTP）</strong>。</p>
<h4 id="30-2-超文本传输协议-HTTP"><a href="#30-2-超文本传输协议-HTTP" class="headerlink" title="30.2 超文本传输协议 HTTP"></a>30.2 超文本传输协议 HTTP</h4><p>HTTP的第一个标准是1991年创建的HTTP 0.9，只有一个指令<code>GET</code> 。因为这里我们想要获取<code>courses</code>页面， 我们可以直接向服务器发送指令<code>GET/courses</code>， 该指令以ASCII编码发送到服务器，服务器会返回该网址对应的页面，然后浏览器就会将其渲染到屏幕上。如果用户点击了另一个链接，计算机就会重新发送一个GET请求。</p>
<p><img src="https://pic.imgdb.cn/item/66a9ef86d9c307b7e90921b4.png"></p>
<p>在之后的版本中，HTTP添加了新的状态码，会将其放在请求页面的前面，比如状态码200表示网页被正确找到了，状态码400-499代表客户端出错。</p>
<p>因为超文本的存储和发送都是以普通文本形式进行的，编码可能是ASCII或者UTF-8，这样就无法表明什么是链接，什么只是普通的文本了，所以必须开发一种标记方法，因此出现了<strong><font color="green">超文本标记语言（Hypertext Markup Language，HTML）</font></strong>，第一代HTML创建于1990年的0.8版本，有18种指令。</p>
<p><img src="https://pic.imgdb.cn/item/66a9f1c9d9c307b7e90b48be.png" alt="编写一个简单网页"></p>
<p>如果把这些文字存入记事本或文本编辑器，然后文件取名<code>test.html</code>，就可以拖入浏览器打开。当然，如今的网页更复杂一些，最新版的：HTML，HTML5，有100多种标签（图片标签，表格标签，表单标签，按钮标签，等等），还有其他相关技术（比如 层叠样式表CSS、JavaScript）这里就不展开讲了。</p>
<p>综上，网络浏览器可以和网络服务器沟通，不仅获取网页和媒体，并且还负责显示。</p>
<p>随着后期万维网日益繁荣，人们越来越需要搜索。起初人们会维护一个目录，来链接到其他网站，但是随着网络越来越大，人工编辑目录变得很不方便，所以开发了<strong>搜索引擎</strong>。</p>
<p>最早的搜索引擎是JumpStation，它有3个部分：</p>
<ol>
<li>通过爬虫来将新链接添加进自己的列表中。</li>
<li>不断扩张的索引，用来记录访问过的网页上出现了哪些词。</li>
<li>查询索引的搜索算法，比如输入了某个关键字，则包含这个关键字的网页就会显示出来。</li>
</ol>
<p>早期的搜索引擎的排名方式直接取决于搜索词在页面上的出现次数，但是有的网页会通过在页面中重复该关键字来提高排名。Google成名的很大原因就是提出了一种算法来解决这个问题，与其信任页面上的内容，搜索引擎会看其他网页有没有连接到这个网页。</p>
<p>最后提一个概念——<strong>网络中立性（Network Neutrality）</strong>，它指的是要对所有数据包都平等对待，速度和优先级都应该一样。</p>
<h3 id="31-计算机安全"><a href="#31-计算机安全" class="headerlink" title="31 计算机安全"></a>31 计算机安全</h3><h4 id="31-1-保密性、完整性和可用性"><a href="#31-1-保密性、完整性和可用性" class="headerlink" title="31.1 保密性、完整性和可用性"></a>31.1 保密性、完整性和可用性</h4><p>计算机安全的范围和计算能力的发展速度一样快，我们可以把计算机安全，看成是保护系统和数据的<strong>保密性、完整性和可用性</strong>。</p>
<ul>
<li><strong>保密性（Secrecy）：</strong>只有有权限的人才能读取计算机系统和数据，比如黑客泄露别人的信用卡信息，就是攻击保密性。</li>
<li><strong>完整性（Integrity）：</strong>只有有权限的人才能使用和修改系统和数据，比如黑客假冒你发送邮件，就是攻击完整性。</li>
<li><strong>可用性（Availability）：</strong>有权限的人应该随时可以访问系统和数据，<strong>拒绝服务攻击（DDOS</strong>）就是黑客发送大量的假请求到服务器上，使得网站很慢或者直接挂掉，这就是攻击可用性。</li>
</ul>
<p>为了实现这三个目标，安全专家会从抽象层面想想敌人可能是谁，这个称为<strong>威胁模型分析（Threat Model）</strong>。模型会对攻击者有个大致的描述：能力如何、目标是什么、可能使用什么手段。攻击手段又称为<strong>攻击矢量（Attack Vector）</strong>。威胁模型分析能够让你为特定情境做好准备，不被可能的攻击手段所淹没。换句话说，要怎么保护，具体看要对抗谁。</p>
<blockquote>
<p>假设你想确保笔记本计算机的“物理安全”，你的威胁模型是”好管闲事的室友”。</p>
</blockquote>
<p>通常威胁模型分析中，会以能力水平进行区分。在给定的威胁模型下，安全架构师要提供解决方案，来保持系统安全。</p>
<h4 id="31-2-安全保护机制"><a href="#31-2-安全保护机制" class="headerlink" title="31.2 安全保护机制"></a>31.2 安全保护机制</h4><p>有很多保护计算机系统、网络和数据的方法。很多安全问题可以总结成<strong>两个问题</strong>：</p>
<ol>
<li>你是谁？</li>
<li>你能访问什么？</li>
</ol>
<p>权限应该给适合的人而拒绝错误的人，所以为了区分谁是谁，我们使用<strong>身份认证（Authentication）</strong>来让计算机得知使用者是谁。通常身份认证有三种，各有利弊：</p>
<ol>
<li><strong>你知道什么：</strong>这个是基于某种只有用户和计算机知道的秘密，比如用户名和密码。这是如今使用最广最容易实现的方法。但是如果黑客知道了你的密码就惨了，或者可以通过暴力攻击试了密码的所有可能来获取你的密码，有些系统会在你尝试若干次错误后阻止你继续尝试。即使增长密码也很容易破解，所以现在很多网站都要求大小写字母加特殊字符，来增加可能的密码。</li>
<li><strong>你有什么：</strong>这是基于用户特定的物体，比如钥匙和锁。这种方法可以避免被人猜中密码的问题，而且通常需要人在现场，所以远程攻击就更加困难了。</li>
<li><strong>你是什么：</strong>这是基于你，通过你自己的特征展示给计算机来进行验证，比如指纹识别器和红膜扫描仪，这些方法特别的安全，但是最好的识别技术十分昂贵。“你知道什么”和“你有什么”是确定性的，但是来自传感器的数据每次都不相同，所以“你是什么”是概率性的，系统可能认不出你，或者将其他人认成了你。并且这种方法另一个问题就是无法重设，你无法修改自己的指纹或者虹膜。</li>
</ol>
<p>每种方法都有优缺点，一般建议使用两种或两种以上的认证方式。</p>
<h4 id="32-3-访问控制"><a href="#32-3-访问控制" class="headerlink" title="32.3 访问控制"></a>32.3 访问控制</h4><p>当系统知道了你是谁，接下来就需要知道你能访问什么，这个称为<strong>访问控制（Access Control）</strong>，因此需要一个规范，来说明谁能访问什么、修改什么和使用什么。这个可以通过<strong>权限（Permission）</strong>或<strong>访问控制列表（Access Control List，ACL）</strong>来实现，其中描述了用户对每个文件、文件夹和程序的访问权限。</p>
<ol>
<li><strong>读权限</strong>：允许用户查看文件内容。</li>
<li><strong>写权限</strong>：允许用户修改文件内容。</li>
<li><strong>执行权限</strong>：运行用户运行文件，比如程序。</li>
</ol>
<p>有些阻止需要不同层次的权限，则ACL的正确配置就十分重要。假设我们有三个访问级别：<strong>公开、机密和绝密</strong>。有个经典模型称为<strong>Bell-LaPadula模型</strong>，其中包含两条规则：</p>
<ol>
<li>用户不能<strong>read up</strong>，即不能读等级更高的信息。</li>
<li>用户不能<strong>write down</strong>，即用户不能写更低权限的信息，这样能避免高级别的信息不会泄漏到低级别的文件中。</li>
</ol>
<p>通过身份认证和权限控制，可以让计算机知道你是谁和你能访问什么，但是必须先保证做这些事的软硬件必须是可信的。但是仍然无法保证程序或计算机系统的安全，因为安全软件在理论上可能是安全的，但是实现时可能会不小心留下漏洞。但是我们有办法减少漏洞出现的可能性，比如一发现漏洞就马上修补。</p>
<p>大部分漏洞都是具体实现时出错了，所以为了减少执行错误，就要减少执行。系统级安全的圣杯之一是“安全内核”或“可信计算基础”：一组尽可能少的操作系统软件，这个安全性是接近可验证的。</p>
<p>构建安全内核的挑战在于，要决定内核应该有什么（代码越少越好）。当最小化代码数量后，要是能保证代码是安全的，那就很好了。现在最好的验证代码安全性的手段是<strong>独立安全监察和质量验证（Independent Verification and Validation）</strong>，让一群安全行业内的软件开发者来审计代码，这也是为什么安全型代码几乎都是开源的。</p>
<p>但是即使这样，还是有可能被黑客攻破，因此程序开发者需要控制损失的最大程度，这个称为<strong>隔离（Ioslation）</strong>。要实现隔离，可以<strong>“沙盒”（sandbox）</strong>程序，<em><u>操作系统通过给每个程序独立的内存块，使得别的程序是无法触及的，这样就能把程序放到沙盒中，即使沙盒被破坏了，也不会影响别的程序执行</u></em>。并且一台计算机可以运行多个<strong>虚拟机（Virtual Machine）</strong>，使得每个虚拟机都在自己的沙盒中。</p>
<h3 id="32-黑客与攻击"><a href="#32-黑客与攻击" class="headerlink" title="32 黑客与攻击"></a>32 黑客与攻击</h3><p>这里只介绍一些入侵原理，提供一个大概的概念。</p>
<h4 id="32-1-社会工程学"><a href="#32-1-社会工程学" class="headerlink" title="32.1 社会工程学"></a>32.1 社会工程学</h4><p>黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为<strong>社会工程学（Social Engineering）</strong>，通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是<strong>网络钓鱼（Phishing）</strong>，其次还有<strong>假托（Pretexting）</strong>，攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。</p>
<p>邮件里带<strong>木马（trojan horse）</strong>也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。</p>
<h4 id="32-2-暴力破解、NAND镜像、缓冲区溢出"><a href="#32-2-暴力破解、NAND镜像、缓冲区溢出" class="headerlink" title="32.2 暴力破解、NAND镜像、缓冲区溢出"></a>32.2 暴力破解、NAND镜像、缓冲区溢出</h4><p>如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击。现在出现了一种攻破方法称为<strong>NAND镜像</strong>，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，知道设备让你等待，这时只要把复制的内容覆盖掉内存，就无需等待，继续尝试密码。</p>
<h5 id="32-2-1-缓冲区溢出漏洞"><a href="#32-2-1-缓冲区溢出漏洞" class="headerlink" title="32.2.1 缓冲区溢出漏洞"></a>32.2.1 缓冲区溢出漏洞</h5><p>如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为<strong>漏洞利用（Exploit）</strong>。一种常见的漏洞利用叫<strong>缓冲区溢出（Buffer Overflow）</strong>，这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把<code>is_admin</code>标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。</p>
<h5 id="32-2-2-缓冲区溢出的组织方法"><a href="#32-2-2-缓冲区溢出的组织方法" class="headerlink" title="32.2.2 缓冲区溢出的组织方法"></a>32.2.2 缓冲区溢出的组织方法</h5><p>有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为<strong>边界检查（Bounds checking</strong>），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为<strong>金丝雀（Canaries）</strong>。</p>
<h4 id="32-3-代码注入"><a href="#32-3-代码注入" class="headerlink" title="32.3 代码注入"></a>32.3 代码注入</h4><p>另一种经典手段是<strong>代码注入（Code Injection）</strong>，最常用于攻击用数据库的网站。下面是一个很简单的示例，我们会用“结构化查询语言”，也叫SQL（一种流行的数据库API）。</p>
<p>假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT password FROM users WHERE username=&#x27;___&#x27;;</span><br></pre></td></tr></table></figure>
<p>这里语句就是要从<code>users</code>表中查找<code>username</code>为<code>___</code>的密码<code>password</code>。 这里的<code>___</code>就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如<code>whatever&#39;;DROP TABLE users;&#39;</code>，这时上面的查询语句就会变成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT password FROM users WHERE username=&#x27;whatever&#x27;;DROP TABLE users;&#x27;;</span><br></pre></td></tr></table></figure>
<p>如果服务器存在用户名<code>wharever</code>，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名<code>wharever</code>，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码<code>DROP TABLE users;</code>，这个是我们注入的命令，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。</p>
<p>程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。</p>
<p>当软件制造者不知道的新漏洞被发现时，称为<strong>0day漏洞（Zero Day Vulnerability）</strong>，黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。</p>
<p>如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为<strong>蠕虫（Worm）</strong>。如果黑客拿下大量电脑，这些电脑可以组成<strong>僵尸网络（Botnet）</strong>，可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。</p>
<h3 id="33-加密"><a href="#33-加密" class="headerlink" title="33 加密"></a>33 加密</h3><p>这节将介绍计算机安全中最常见的防御形式——密码学。</p>
<h4 id="33-1-加密算法"><a href="#33-1-加密算法" class="headerlink" title="33.1 加密算法"></a>33.1 加密算法</h4><p>为了加密信息，要用<strong>加密算法（Cipher）</strong>将明文转换为密文，除非知道如何解密，否则密文看起来就是一堆乱码，这种将明文专为密文的过程叫做<strong>加密（Encryption）</strong>，而相反过程称为<strong>解密（Decryption）</strong>。</p>
<p>加密算法早在计算机出现之前就存在了，凯撒使用我们如今称为<strong>凯撒加密（Caesar Cipher）</strong>的方法来加密私人信件，他会将信件中的字母向前移动3个位置，所以a变成d，brutus变成euxwxv。为了解密，接受者要知道使用了什么算法，以及偏移的字母位数作为钥匙。</p>
<h5 id="33-1-1-替换加密"><a href="#33-1-1-替换加密" class="headerlink" title="33.1.1 替换加密"></a>33.1.1 替换加密</h5><p>有一大类算法称为<strong>替换加密（Substitution Cipher）</strong>，凯撒密码就是其中一种，算法把每个字母替换成其他字母。但是有一个巨大的缺点是，字母出现的频率是不一样的，比如英语中字母E出现的频率最高，如果将E替换成了X，则密文中X的出现频率就会很高，通过统计字母频率，就有可能破译密码。</p>
<h5 id="33-1-2-移位加密"><a href="#33-1-2-移位加密" class="headerlink" title="33.1.2 移位加密"></a>33.1.2 移位加密</h5><p>另一类加密算法叫<strong>移位加密（Permutation Cipher）</strong>，比如<strong>列移位加密（Columnar Transposition Cipher）</strong>，我们这里将明文填入网格，比如选择5x5大小的网格。为了加密信息，我们换一个顺序来读取，比如从左边开始，从下往上一次读一列，就会变成图2的形式，这样加密后的字母排列是不同的，，但是字母出现的频率没有变化。这里解密的关键是要知道读取方向和网格大小。</p>
<p><img src="https://pic.imgdb.cn/item/66aa0e2ad9c307b7e9259eb9.png" alt="移位加密的例子"></p>
<h4 id="33-2-硬件加密"><a href="#33-2-硬件加密" class="headerlink" title="33.2 硬件加密"></a>33.2 硬件加密</h4><p>到了1900年代，人们用密码学做了加密机器，比如德国的Enigma用来加密通讯信息。Enigma是一台类似打字机的机器，包含键盘和灯板，这两个都有完整的字母表，而且它还有一系列转子，这些是加密的关键。首先我们看一个转子，它一面有26个接触点，代表26个字母，然后线会连接到另一面来替换字母，其实这个就是替换加密。但是Enigma更加复杂，它有更多的转子，一个转子的输出作为下一个转子的输入，并且转子还有26个起始位置，还可以按不同顺序加入转子，来提供更多字母替换映射。转子之后是一个叫反射器的特殊电路，它每个引脚会连接另一个引脚，并把信号发回转子，最后机器前方有一个插板，可以把输入键盘的字母预先进行替换来增加一层复杂度。图中显示的是输入H后，经过加密会输出L，因为线路是双向的，所以输入L也会被加密成H，所以加密和解密步骤是一样的，直接将密文输入机器就能得到对应的明文。</p>
<p> 但是这个机器有个缺点，就是字母加密后，一定会变成另一个字母。</p>
<p>最后，为了让Enigma不只是简单的替换加密，每输入一个字母，转子就会转一格，这样比如你输入<code>AAA</code>，可能会输出<code>BDK</code>，映射会随着每次按键发生改变。 </p>
<h4 id="33-3-软件加密"><a href="#33-3-软件加密" class="headerlink" title="33.3 软件加密"></a>33.3 软件加密</h4><p>随着计算机出现，加密从硬件转向了软件。</p>
<p>早期应用最广的加密算法是IBM和NSA于1977年开发的<strong>数据加密标准（Data Encryption Standard，DES）</strong>，DES最初用56位二进制密钥，但到了1999年，计算机能将DES所有可能密钥都试一遍，所以DES不再安全。所以在2001年出现了<strong>高级加密标准（Advanced Encryption Standard，AES）</strong>，AES使用128/192/256位密钥，使得暴力破解更加困难。</p>
<p>AES将数据切成一块一块，每块16个字节，然后用密钥进行一系列替换加密和移位加密，再加上一些其他操作，进一步加密信息，并且每块数据会重复这个过程10次以上。因为加密是需要时间的，如果使用过长的密钥或者加密次数过多，虽然更加安全，但是加密时间过长。目前AES被广泛应用，比如iPhone上加密文件，用WPA2协议在WiFi中访问HTTPS网站。</p>
<h4 id="33-4-密钥交换"><a href="#33-4-密钥交换" class="headerlink" title="33.4 密钥交换"></a>33.4 密钥交换</h4><p>上面讨论的加密技术，都依赖于发送方和接收方都知道密钥，发送方用密钥进行加密，而接收方使用相同密钥来解密。现在我们需要某种方法，在公开的互联网上传递密钥给对方，但是这种方法不是很安全，密钥可能会被黑客拦截。解决方案就是<strong>密钥交换（Key Exchange）</strong>，这是一种不发送密钥，但依然让两台计算机在密钥上达到共识的算法。我们可以使用<strong>单向函数（One-way Function）</strong>来实现，这是一种数学操作，很容易计算出结果，但是想从结果逆向推算出输入非常困难。</p>
<blockquote>
<p>以颜料为例，我们可以很容易地将多个颜料混合得到最终的颜色，但是想要从最终颜色推算出用了哪些颜料进行混合是非常困难的。在这个例子中，我们的密钥就是一种独特的颜色。首先有一个公开的颜色，所有人都可以看到，然后对方和我自己各自选择一个秘密颜色，为了交换密钥，我先将我的颜色和公开颜色进行混合，然后发送给对方，并且对方也将他的颜色和公开颜色混合后发送给我，当我收到对方发来的颜色后，也将自己的颜色混入，并且对方也这么操作，这样我们就都得到了由3中颜色混合的一样的最终颜色，我们就可以将这个最终颜色当做密钥。</p>
</blockquote>
<p>计算机中，我们可以用<strong><font color="red">Diffie-Hellman密钥交换</font></strong>，在Diffie-Hellman中，单向函数是<strong>模幂运算</strong>，首先将一个数作为基数（Base），再拿另一个数作为指数（Exponent），然后将其结果除以第三个数就得到我们想要的余数：</p>
<script type="math/tex; mode=display">
B^x \text{ mod } M</script><p>这样，如果只给$B$、$M$和余数，很难知道指数$x$是多少，并且如果将数字变得很长，比如几百位，想要找到秘密指数几乎是不可能的。</p>
<p>在Diffie-Hellman中，我们有公开的数——基数$B$和模数$M$。为了安全地给对方发送信息，可按下面的步骤进行：</p>
<ol>
<li>我们选择一个秘密指数$X$，然后将计算结果$B^X \text{ mod } M$发送给对方，对方同样也选择一个秘密指数$Y$，然后也将计算结果$B^Y \text{ mod } M$发送给我。</li>
<li>为了算出双方共用的密钥，我将对方的结果作为新的基数$B_Y$，再取$X$指数并求余，即$(B_Y)^X \text{ mod } M = (B^Y \text{ mod } M)^X  \text{ mod } M = B^{XY} \text{ mod } M$，而对方也用相同方法进行计算，得到的也是相同结果，也即最终都是$ B^{XY} \text{ mod } M$。</li>
<li>这样就可以将这个计算结果当做密钥，使用AES之类的加密技术进行加密通信。</li>
</ol>
<h4 id="33-5-对称加密和非对称加密"><a href="#33-5-对称加密和非对称加密" class="headerlink" title="33.5 对称加密和非对称加密"></a>33.5 对称加密和非对称加密</h4><p>Diffie-Hellman密钥交换是建立共享密钥的一种方法，双方使用一样的密钥加密和解密信息，称为<strong>对称加密（Symmetric Encryption）</strong>，因为加密和解密使用的密钥是一样的，前面的凯撒加密、Enigma和AES都是对称加密。</p>
<p>同样还存在<strong>非对称加密（Asymmetric Encryption）</strong>，这里有两个不同的密钥，一个是公开的，一个是私有的，人们可以用公钥加密消息，而只有有私钥的人才能解密，所以知道公钥只能进行加密不能进行解密，而通过公钥加密后，也只能用私钥进行解密，所以它是不对称的。</p>
<blockquote>
<p>非对称加密的形象化理解：</p>
<p>比如有一个带锁的箱子，我们可以将锁和箱子给别人，他将信息放入箱子并上锁后还给我，我就可以通过自己的钥匙将其打开。</p>
</blockquote>
<p>过程反过来也是可以的，可以用私钥加密再用公钥解密，这个通常用于签名。<em><u>服务器可以用私钥进行加密，任何人都可以用服务器的公钥进行解密来获得信息</u></em>，这使得私钥相当于一个签名，只有有私钥的人才能进行加密，只有当公钥能正确解密，才能证明数据来自正确的服务器或个人(差不多是<strong>数字签名</strong>的原理)。</p>
<p>总之，① 公钥加密只能私钥解密；② 私钥加密只能公钥解密。</p>
<p>目前最流行的非对称加密技术是RSA。现在我们简单了解了现代密码学的所有”关键”部分：对称加密，密钥交换，公钥密码学。</p>
<p>当你访问一个安全的网站，比如银行官网：</p>
<p><img src="https://pic.imgdb.cn/item/66aa248fd9c307b7e93849f6.png" style="zoom:70%"></p>
<p>图中绿色锁图标代表使用了公钥密码学，验证服务器的密钥，然后建立临时密钥，然后用对称加密保证通信安全。</p>
<p> 【原文链接】<br><a href="https://zhuanlan.zhihu.com/p/460879375">计算机科学速成课笔记 - 问夏的文章 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/103664879">读书笔记_计算机科学速成课——计算机网络（28、29、30） - 深度人工dazed的文章 - 知乎</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
        <category>编程语言学习</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习环境配置</title>
    <url>/2024/07/01/DL-Env-Conf/</url>
    <content><![CDATA[<h3 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1 基础概念"></a>1 基础概念</h3><h4 id="1-1-说说-Python"><a href="#1-1-说说-Python" class="headerlink" title="1.1 说说 Python"></a>1.1 说说 Python</h4><p>Python 其实就是一门编程语言，就是程序的一种规范，一种语法。 Python 是计算机世界中比较（语法）简单的语言。</p>
<h4 id="1-2-库-library-包-package"><a href="#1-2-库-library-包-package" class="headerlink" title="1.2 库(library)/包(package)"></a>1.2 库(library)/包(package)</h4><p>包/库，就是别人分享的工具(模板)。打个有点不恰当的例子：Python是我们的手机，那么包/库就是安装的App。</p>
<p>有了这些工具，我们可以高效地完成一些事情。如果安装包，就是使用<code>pip install 包名</code>（pip有点像手机里的应用商店）。</p>
<p>经常用的一些包：① Numpy；② Pandas；③ Matplotlib；④ Opencv；⑤ Pytorch；⑥ Tensorflow等</p>
<h4 id="1-3-Anaconda"><a href="#1-3-Anaconda" class="headerlink" title="1.3 Anaconda"></a>1.3 Anaconda</h4><p>Anaconda是一个开源的Python发行版本，包含了包括<strong><font color="red">Python</font>、<font color="blue">Conda</font>、<font color="green">科学计算库(Numpy、SciPy等等)</font></strong>等180多个科学包及其依赖项。因此，安装了Anaconda就不用再单独安装Python。 简单说，Anaconda是一个集成各类Python工具/包/库的集成平台，它本身不是一个开发工具，它只是将很多第三方的开发环境集成到一起。 </p>
<p>其次，<strong>Anaconda内含Conda</strong>，Anaconda就是基于conda的管理工具集合，它包含了conda、某一个版本的Python、一批第三方库等。Conda是一个通用的包管理系统，也就是说Conda适用于各种编程语言(Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN)； </p>
<ul>
<li>conda将工具、第三方库、Python版本、conda都当作包，同等对待。</li>
<li>conda推荐使用命令行来进行操作，Anaconda提供了图形界面。</li>
<li>在Anaconda中可以创建新的conda环境，并在新的环境中进行相关自定义配置。</li>
</ul>
<p><font color="green">仍然用手机的例子来打比方的话，pip只能用于Python语言的包管理，相当于某一特定品牌手机的应用商店(在其他品牌手机上不能使用)，conda能用于各种语言，相当于通用的应用商店，各种品牌的手机都能使用</font>。</p>
<p>最后，Anaconda还有一个重要的功能——<strong>创建虚拟环境</strong>。</p>
<blockquote>
<p>在开发中常会碰到如下情况：</p>
<p>某一项目要求使用PyThoch 1.10版本，另一个项目要求使用PyTorch 1.4版本。但是我们不能在同一环境下同时安装两个PyTorch版本。</p>
<p>这是，就可以通过Anaconda创建虚拟环境（类似于Windows电脑创建虚拟机，安装Linux系统，或者也类似于手机应用双开？）</p>
</blockquote>
<h4 id="1-4-Python是如何运行起来的"><a href="#1-4-Python是如何运行起来的" class="headerlink" title="1.4 Python是如何运行起来的"></a>1.4 Python是如何运行起来的</h4><p><img src="https://pic.imgdb.cn/item/6684f907d9c307b7e9de19ac.png"></p>
<p>其实简单来说，安装Python就是安装不同版本的Python解释器 <a href="https://zhuanlan.zhihu.com/p/702296063">为什么python需要配置编程环境</a>。</p>
<p>pycharm是Python IDE(集成开发环境)</p>
<h4 id="1-5-显卡、GPU以及相关概念"><a href="#1-5-显卡、GPU以及相关概念" class="headerlink" title="1.5 显卡、GPU以及相关概念"></a>1.5 显卡、GPU以及相关概念</h4><p>显卡是个人计算机（Personal Computer）的组成部分之一，启到控制显示器正确显示的作用，基本功能就是将模拟信号转换为电信号。市场主流的显卡大多都是NVIDIA（英伟达）和AMD（超微半导体）这两个公司设生产的，分别被简称为N卡和A卡（N&amp;A就是取自各自公司英文首字母）。</p>
<p>显卡的结构为：电容、显存、显示芯片、风扇、各类接口等。其中<strong>显存全称为“显示存储器”，和计算机中的存储器相似，负责存储显示芯片需要处理的各种数据</strong>，其容量的大小，性能的高低，直接影响着电脑的显示效果；<strong>显示芯片就是深度学习中经常提到的GPU或者VPU（或被称作图形处理器），负责并行计算工作</strong>，工作时产生的热量由风扇负责排除；各类接口负责输入输出和桥接。</p>
<p>显卡分为三个种类：集成显卡、独立显卡、核芯显卡。 </p>
<p>显卡是一个硬件，可以插到电脑主板上，因此一般情况下，需要装<strong>驱动(能够让计算机识别相应的硬件)</strong>。</p>
<p>对于深度学习而言使用的显卡都是英伟达的显卡，因为NVIDIA公司创建了一个CUDA平台，开发者可以利用CUDA去操作NVIDIA的显卡。</p>
<h4 id="1-6-小结：上述各个软件关系"><a href="#1-6-小结：上述各个软件关系" class="headerlink" title="1.6 小结：上述各个软件关系"></a>1.6 小结：上述各个软件关系</h4><p><img src="https://pic.imgdb.cn/item/66850dc5d9c307b7e90a4199.png"></p>
<h3 id="2-文件路径表示"><a href="#2-文件路径表示" class="headerlink" title="2 文件路径表示"></a>2 文件路径表示</h3><p>一般使用远程登录电脑的时候，由于文件路径发生了变化，所以推荐路径一般使用相对路径：</p>
<h4 id="2-1-OS模块定义"><a href="#2-1-OS模块定义" class="headerlink" title="2.1 OS模块定义"></a>2.1 OS模块定义</h4><p>在自动化过程当中，经常需要<strong>查找操作文件</strong>，比如说查找配置文件(从而读取配置文件的信息)，查找测试报告(从而发送测试报告邮件)，经常要对大量文件和大量路径进行操作，这就依赖于<code>os</code>模块。</p>
<h4 id="2-2-OS模块常用方法"><a href="#2-2-OS模块常用方法" class="headerlink" title="2.2 OS模块常用方法"></a>2.2 OS模块常用方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>当前路径以及路径下的文件</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>os.getcwd()</code></td>
<td>查看当前所在路径</td>
</tr>
<tr>
<td><code>os.pardir</code></td>
<td>获取当前目录的父目录（上一级目录），以字符串形式显示目录名</td>
</tr>
<tr>
<td><code>os.listdir(path)</code></td>
<td>列举目录下的所有文件。返回的是列表类型。</td>
</tr>
<tr>
<td><code>os.path.abspath(path)</code></td>
<td>返回path的绝对路径。</td>
</tr>
<tr>
<td><code>os.path.join(path1, path2)</code></td>
<td>将path进行组合，若其中有绝对路径，则之前的path将被删除。</td>
</tr>
<tr>
<td><code>os.path.exists(path)</code></td>
<td>path：要判断的路径，可用绝对路径，也可用相对路径。<br>返回值：给定的路径存在则返回 True，否则返回 False。</td>
</tr>
<tr>
<td><code>os.path.dirname(path)</code></td>
<td>返回path中的文件夹部分，结果不包含\</td>
</tr>
<tr>
<td><code>os.path.basename(path)</code></td>
<td>返回path中的文件名</td>
</tr>
<tr>
<td><code>os.path.getsize()</code></td>
<td>文件或文件夹的大小</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意：</p>
<p><code>path</code>参数不写，默认当前项目路径，若写，则既可使用绝对路径<code>r&quot;E:\A.毕业设计\前期基础知识学习\deep learning project\MINIST-master\data&quot;</code>，又可使用相对路径<code>r&quot;.\dataset&quot;</code>(当前项目路径下的子文件夹dataset)</p>
<p><code>os.path</code>模块的更多函数参考：<a href="https://www.jb51.net/python/293897rnc.htm">Python常用基础模块之os.path模块详解</a></p>
</blockquote>
<h4 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a>2.3 示例</h4><p>假设你当前所在的路径为<code>D:\Github_Project\UNet_Demo\datasets\cat\SegmentationClass</code>，下面有几个任务：</p>
<ul>
<li>① 统计当前目录下有几个<code>.txt</code>文件：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    # 绝对路径(Windows格式1)</span></span><br><span class="line"><span class="string">    directory_path = R&#x27;D:\Github_Project\UNet_Demo\datasets\cat\SegmentationClass\&#x27;</span></span><br><span class="line"><span class="string">    # 绝对路径(Windows格式2)</span></span><br><span class="line"><span class="string">    directory_path = &#x27;D:\\Github_Project\\UNet_Demo\\datasets\\cat\\SegmentationClass\&#x27;</span></span><br><span class="line"><span class="string">    # 绝对路径(Linux格式)</span></span><br><span class="line"><span class="string">    directory_path = &#x27;D:/Github_Project/UNet_Demo/datasets/cat/SegmentationClass/&#x27;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 相对路径</span></span><br><span class="line">    directory_path = <span class="string">&#x27;./&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> os.scandir(directory_path):</span><br><span class="line">        <span class="keyword">if</span> entry.name.endswith(<span class="string">&#x27;.txt&#x27;</span>) <span class="keyword">and</span> entry.is_file():</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Number of .txt files: <span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>统计<code>D:\Github_Project\UNet_Demo\my_folder</code>目录下有几个<code>.txt</code>文件：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    简单分析，当前路径为D:\Github_Project\UNet_Demo\datasets\cat\SegmentationClass\，则易知D:\Github_Project\UNet_Demo\my_folder相对于当前路径为【上级目录cat的上级目录datasets的上级目录UNet_Demo下的my_folder】，采用Linux的相对路径表示方法为【../../../my_folder/】</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    # 绝对路径(Windows格式1)</span></span><br><span class="line"><span class="string">    directory_path = R&#x27;D:\Github_Project\UNet_Demo\datasets\cat\SegmentationClass\&#x27;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 相对路径</span></span><br><span class="line">    directory_path = <span class="string">&#x27;../../../my_folder/&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> os.scandir(directory_path):</span><br><span class="line">        <span class="keyword">if</span> entry.name.endswith(<span class="string">&#x27;.txt&#x27;</span>) <span class="keyword">and</span> entry.is_file():</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Number of .txt files: <span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="3-使用google-colab"><a href="#3-使用google-colab" class="headerlink" title="3 使用google colab"></a>3 使用google colab</h3><p>官网：<a href="https://colab.research.google.com/">google colab</a></p>
<h4 id="3-1-基本步骤"><a href="#3-1-基本步骤" class="headerlink" title="3.1 基本步骤"></a>3.1 基本步骤</h4><p>请结合链接：[]</p>
<p>首先，在谷歌云盘创建一个文件夹，然后，在该文件夹下创建一个<strong>Google Colaboratory</strong>文件。</p>
<p>进入Google Colaboratory文件后，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!date                   <span class="comment"># 显示当前的日期和时间</span></span><br><span class="line">!<span class="built_in">pwd</span>                    <span class="comment"># 打印当前目录</span></span><br><span class="line">!python --version		<span class="comment"># 查看python版本</span></span><br><span class="line">!nvidia-smi		        <span class="comment"># 查看GPU的信息——型号、显存大小</span></span><br></pre></td></tr></table></figure>
<p>下面，需要将谷歌云盘与服务器挂载起来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 挂载云盘</span></span><br><span class="line">import os</span><br><span class="line">from google.colab import drive</span><br><span class="line">drive.mount(&#x27;/content/drive&#x27;)</span><br></pre></td></tr></table></figure>
<p>完成挂载后，切换目录到我们创建的文件夹下面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash"><span class="built_in">cd</span> /content/drive</span>		</span><br><span class="line"><span class="meta">%</span><span class="bash">ls</span></span><br><span class="line"><span class="meta">%</span><span class="bash"><span class="built_in">cd</span> MyDrive/一开始创建的文件夹/</span></span><br><span class="line"><span class="meta">%</span><span class="bash">ls</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，<code>cd</code>、<code>ls</code>等命令使用<code>%</code></p>
</blockquote>
<p>最后，使用下面的命令开始训练模型：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">!python model_train.py</span><br></pre></td></tr></table></figure>
<h4 id="3-2-T4-GPU的性能"><a href="#3-2-T4-GPU的性能" class="headerlink" title="3.2 T4 GPU的性能"></a>3.2 T4 GPU的性能</h4><p>任务场景就是对bert进行微调。今天比较巧，用了<strong>T4</strong>也用了<strong>RTX 4090</strong>去做bert微调的任务，发现两者速度又很直观的不同，但从我看到的差异4090是T4的<strong><font color+red>3.x倍</font></strong>。T4是<strong>Google Colab</strong>提供的免费的，4090是租的在线，2.8一小时，体验一下。 </p>
<p>又去试了试<strong>RTX 3090</strong>的速度。差不多是T4速度的2.6倍，0.75的4090的速度，不过价格却是4090的0.58，似乎租3090更划算。 </p>
<h4 id="3-3-v2-8-TPU说明"><a href="#3-3-v2-8-TPU说明" class="headerlink" title="3.3 v2-8 TPU说明"></a>3.3 v2-8 TPU说明</h4><p>v2-8 TPU支持<strong>TensorFlow库和PyTorch库(有条件)</strong>。</p>
<p>TPU（Tensor Processing Unit）是谷歌开发的一种专用于深度学习的硬件加速器，旨在提高机器学习任务的计算效率和速度。它通过高度优化的矩阵运算和片上存储，减少数据传输延迟，从而提升性能。</p>
<p>在TensorFlow中，TPU的支持已经非常成熟。TensorFlow/TPU项目提供了与TensorFlow库无缝集成的API，使得开发者能够在现有的TensorFlow代码基础上轻松添加TPU支持。这个项目兼容TensorFlow v1和v2，使得旧版和新版的用户都能享受TPU的加速效果。</p>
<p>尽管PyTorch原生并不直接支持TPU，但可以通过PyTorch XLA（Accelerated Linear Algebra）库来实现对TPU的支持。PyTorch XLA是PyTorch的一个扩展，提供了与TPU的集成支持。使用PyTorch XLA，开发者可以在PyTorch中利用TPU资源进行训练和推理。</p>
<p>参考链接1：<a href="https://www.bilibili.com/video/BV1YK4y1E7zd">在google colab进行yolov5模型训练，免费使用GPU资源 - 哔哩哔哩</a><br>参考链接2：<a href="https://www.bilibili.com/opus/769912341585199175">【sovitsAI语音】在colab部署，新人学习分享 - 哔哩哔哩</a><br>参考链接3：<a href="https://blog.csdn.net/qq_45802280/article/details/144251689">Google Colab TPU 使用方法 - CSDN博客</a><br>参考链接4：<a href="https://baijiahao.baidu.com/s?id=1659754569830715933&amp;wfr=spider&amp;for=pc">一行代码安装，TPU也能运行PyTorch，修改少量代码即可快速移植 - 百度百家号</a><br>参考链接5：<a href="https://zhuanlan.zhihu.com/p/648570557">4090和t4同任务速度对比 - 慢下来不就好了的文章 - 知乎</a></p>
<h3 id="4-使用Kaggle"><a href="#4-使用Kaggle" class="headerlink" title="4 使用Kaggle"></a>4 使用Kaggle</h3><p>kaggle的官网：<a href="https://www.kaggle.com/">Kaggle: Your Machine Learning and Data Science Community</a></p>
<h4 id="4-1-登录注册"><a href="#4-1-登录注册" class="headerlink" title="4.1 登录注册"></a>4.1 登录注册</h4><p>这里有两种注册方式，一种是使用谷歌账号（需要科学上网），另外一种是使用email，我使用的是谷歌账号的方式，过程很顺利，但是据其他帖子中所说使用email的话会比较麻烦，可能没办法通过人机验证，不过别的帖子里也有解决方法，这里不多赘述。 </p>
<h4 id="4-2-进行相关配置"><a href="#4-2-进行相关配置" class="headerlink" title="4.2 进行相关配置"></a>4.2 进行相关配置</h4><p>成功登陆以后，进入以下的界面： </p>
<p><img src="https://pic1.imgdb.cn/item/678b7671d0e0a243d4f57243.png"></p>
<p>点击Notebooks，进入以下页面： </p>
<p><img src="https://pic1.imgdb.cn/item/678b76edd0e0a243d4f57284.png"></p>
<p>红色框里包含了你曾经创建的notebook，点击蓝色框中的create即可创建新的notebook，选择New notebook：</p>
<p><img src="https://pica.zhimg.com/v2-053e7d635c0727e2d8ae5c1c59ea7c44_r.jpg" style="zoom:40%"></p>
<p>进入新的notebook后，界面如下所示： </p>
<p><img src="https://pic1.imgdb.cn/item/678b7779d0e0a243d4f572af.png"></p>
<p>其实这里的<strong>notebook和jupyter_notebook</strong>非常的相似，只要你使用过jupyter_notebook，应该就对这个不会陌生，为了照顾没有用过jupyter_notebook的同学，这里介绍一下notebook的基本使用方法：</p>
<ol>
<li>红框1处为notebook的名字，点击这里可以改名；</li>
<li>点击红框2处可以增加代码单元，在代码块中写代码；</li>
<li>点击红框3处可以运行相应的代码单元；</li>
<li>点击红框4处可以按顺序运行所有的代码单元。</li>
</ol>
<p>在右侧的方框处，找到Session Option模块： </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>图示</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://pic1.imgdb.cn/item/678b77ffd0e0a243d4f572b6.png" style="zoom:70%"></td>
<td>ACCELERATOR，即加速器，可选择是否使用GPU以及GPU型号。<br>LANGUAGE：选择编程语言，这里只有Python和R语言可选。<br>PERSISTENCE：保存文件类型，详细请参见UP的解释<a href="https://www.bilibili.com/video/BV1kU411Z73b?t=488.3">持久化</a><br>ENVIRONMENT：环境配置相关，详细参见UP的解释<a href="https://www.bilibili.com/video/BV1kU411Z73b?t=583.9">版本策略</a><br>INTERNET：是否连接网络，一般选择打开， 否则没办法<code>pip install</code></td>
</tr>
</tbody>
</table>
</div>
<p>然后就可以愉快的使用GPU啦。</p>
<h4 id="4-3-使用示例"><a href="#4-3-使用示例" class="headerlink" title="4.3 使用示例"></a>4.3 使用示例</h4><h5 id="4-3-1-上传自己的数据集"><a href="#4-3-1-上传自己的数据集" class="headerlink" title="4.3.1 上传自己的数据集"></a>4.3.1 上传自己的数据集</h5><p>运行代码有两种方式，<strong>一种是上传已经写好的代码，另外一种就是自己在notebook里写，写好再运行</strong>。我目前一般是现在本地把代码都写好，只是利用平台的免费GPU跑模型进行训练，因此数据集和代码均是通过上传的方式进行。</p>
<p>上传数据集肯定是必不可少的，这里我们可以下载kaggle上的数据集，也可以上传我们自己的数据集，这里介绍一下上传自己数据集的方法。</p>
<p>首先，进入下图右上方的Input界面，其中：<strong>Add Input</strong>：导入 Kaggle 中已有的数据集；<strong>Upload</strong>：上传本地的数据集。点击右上方的upload，选择new dataset，然后选择数据集或者模型代码进行上传。如果<strong>数据集较大的话建议先上传压缩文件</strong>，kaggle上传完成后会自动解压的 。</p>
<p><img src="https://pic1.imgdb.cn/item/678b7afed0e0a243d4f573a7.png"></p>
<p>上传之后就可以在Input里就可以看见，点击红框处，复制文件的路径，就能在代码中使用了 。</p>
<p><img src="https://pic1.imgdb.cn/item/678b7be6d0e0a243d4f573d9.png"></p>
<p>注意，上传文件后，文件保存在<code>/kaggle/input/&lt;上传文件时候的命名&gt;</code>。若上传的数据集，则不需要移动数据集，就在这个目录下应用即可，也就是只需要代码中的数据集路径使用上述路径即可。</p>
<p>但若是上传的模型代码文件，则一般需要把上传的代码文件转移到当前工作环境<code>/kaggle/working</code>，转移代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copyfile</span><br><span class="line">copyfile(src = <span class="string">&quot;../input/model-train/model.py&quot;</span>, dst = <span class="string">&quot;../working/model.py&quot;</span>)</span><br><span class="line">copyfile(src = <span class="string">&quot;../input/model-train/model_train.py&quot;</span>, dst = <span class="string">&quot;../working/model_train.py&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>下面就可以运行代码进行训练了。</p>
<h5 id="3-3-2-给出的一个示例流程"><a href="#3-3-2-给出的一个示例流程" class="headerlink" title="3.3.2 给出的一个示例流程"></a>3.3.2 给出的一个示例流程</h5><p>进入kaggle Notebook后，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!date                   <span class="comment"># 显示当前的日期和时间</span></span><br><span class="line">!<span class="built_in">pwd</span>                    <span class="comment"># 打印当前目录</span></span><br><span class="line">!python --version		<span class="comment"># 查看python版本</span></span><br><span class="line">!nvidia-smi		        <span class="comment"># 查看GPU的信息——型号、显存大小</span></span><br></pre></td></tr></table></figure>
<p>转移代码文件到当前工作目录下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copyfile</span><br><span class="line">copyfile(src = <span class="string">&quot;../input/model-train/model.py&quot;</span>, dst = <span class="string">&quot;../working/model.py&quot;</span>)</span><br><span class="line">copyfile(src = <span class="string">&quot;../input/model-train/model_train.py&quot;</span>, dst = <span class="string">&quot;../working/model_train.py&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>展示当前目录下的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!<span class="built_in">pwd</span></span><br><span class="line">!ls</span><br></pre></td></tr></table></figure>
<p>没问题即可开始训练模型</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!python model_train.py</span><br></pre></td></tr></table></figure>
<h4 id="4-4-下载输出（Output）的文件"><a href="#4-4-下载输出（Output）的文件" class="headerlink" title="4.4 下载输出（Output）的文件"></a>4.4 下载输出（Output）的文件</h4><p>请参考连接4。</p>
<h4 id="4-5-其他说明"><a href="#4-5-其他说明" class="headerlink" title="4.5 其他说明"></a>4.5 其他说明</h4><p>有的时候模型运行比较久，可能会因为存在网络等问题导致训练中断，这时候可以使用后台任务功能，具体情况UP的解释：<a href="https://www.bilibili.com/video/BV1kU411Z73b?t=1067.4">后台任务设置</a></p>
<p>参考连接1：<a href="https://www.bilibili.com/video/BV1kU411Z73b/?share_source=copy_web&amp;vd_source=5cb8e8e385b900f1a132ca50a9d46ab5">【免费GPU系列：kaggle，colab，百度 AI studio 使用方法（上半部分）】- 哔哩哔哩</a><br>参考连接2：<a href="https://blog.csdn.net/qq_42901277/article/details/127277811">免费gpu：kaggle本地项目上传使用说明 - CSDN</a><br>参考连接3：<a href="https://blog.csdn.net/weixin_42426841/article/details/143591586">Kaggle：免费 GPU 使用指南，Colab 的理想替代方案 - CSDN</a><br>参考连接4：<a href="https://zhuanlan.zhihu.com/p/18209757723">kaggle GPU资源使用教程——针对超级小白 - 未雨的文章 - 知乎</a><br>参考连接5：<a href="https://blog.csdn.net/m0_53115174/article/details/144007060?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=144007060&amp;sharerefer=PC&amp;sharesource=m0_46276396&amp;sharefrom=from_link">Kaggle下载输出（Output）的文件 - CSDN</a></p>
<h3 id="5-Linux服务器上安装Anaconda"><a href="#5-Linux服务器上安装Anaconda" class="headerlink" title="5 Linux服务器上安装Anaconda"></a>5 Linux服务器上安装Anaconda</h3><p>参考链接1：<a href="https://cloud.tencent.com/developer/article/2063049">如何在Linux服务器上安装Anaconda（超详细）「建议收藏」 - 腾讯云博客</a><br>参考连接2：</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2024/06/26/Data-Structure-and-Algorithms/</url>
    <content><![CDATA[<h3 id="sect-1-绪论"><a href="#sect-1-绪论" class="headerlink" title="&sect;1 绪论"></a><strong>&sect;</strong>1 绪论</h3><h4 id="1-1-算法和算法分析"><a href="#1-1-算法和算法分析" class="headerlink" title="1.1 算法和算法分析"></a>1.1 算法和算法分析</h4><p>算法效率以下两个方面来考虑：</p>
<ol>
<li>时间效率：指的是算法所耗费的时间；</li>
<li>空间效率：指的是算法执行过程中所耗费的存储空间。</li>
</ol>
<p>时间效率和空间效率有时候是矛盾的。</p>
<h5 id="Ⅰ-算法时间效率的度量"><a href="#Ⅰ-算法时间效率的度量" class="headerlink" title="Ⅰ 算法时间效率的度量"></a>Ⅰ 算法时间效率的度量</h5><p>算法时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量。主要有两种度量方法。</p>
<p><strong>(1) 事后统计</strong></p>
<p>将算法用编程软件进行实现，然后统计其在计算机上运行时间和空间开销。</p>
<p>缺点：① 编写程序实现算花费较多的时间和精力；② 所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣。</p>
<p><strong>(2) 事前分析（常用）</strong></p>
<p>对算法所消耗资源的一种估算方法。</p>
<p>一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的时间与算法中进行的简单操作次数乘积：</p>
<script type="math/tex; mode=display">
算法运行时间 = 一个简单操作所需的时间 \times 简单操作次数</script><p>也即算法中每条语句的执行时间之和：</p>
<script type="math/tex; mode=display">
算法运行时间 = \sum_{语句条数} 每条语句的执行次数 \times 该语句执行一次所需的时间</script><p>每条语句执行一次所需的时间，一般是随机器而异的。取决于机器的指令性能、速度以及编译的代码质量。是由机器本身软硬件环境决定的它与算法无关。</p>
<p>所以，我们可假设执行每条语句所需的时间均为<strong><font color="blue">单位时间</font></strong>。此时对算法的运行时间的讨论就可转化为讨论该算法中所有语句的执行次数，即<strong>频度之和了</strong>：</p>
<script type="math/tex; mode=display">
算法运行时间 = \sum_{语句条数} 每条语句的执行次数 \times 单位时间 = \sum_{语句条数} 每条语句的执行次数</script><p>例如：两个$n \times n$矩阵相乘的算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)							<span class="comment">// 执行：n+1次</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)						<span class="comment">// 执行：n*(n+1)次</span></span><br><span class="line">    &#123;</span><br><span class="line">        c[i][j] = <span class="number">0</span>;							<span class="comment">// 执行：n*n次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)					 <span class="comment">// 执行：(n*n)*(n+1)次</span></span><br><span class="line">        &#123;</span><br><span class="line">            c[i][j] = c[i][j]+a[i][k]*b[k][j];	   <span class="comment">// 执行：(n*n)*n次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把算法所耗费的时间定义为该算法中每条语句的频度之和，则上述算法的时间消耗$T(n)$为：</p>
<script type="math/tex; mode=display">
T(n) = (n+1) + [n*(n+1)] + (n*n) + [(n*n)*(n+1)] + [(n*n)*n] = 2n^3 + 3n^2 + 1</script><p>为了便于比较不同算法的时间效率，我们仅比较它们的<strong><font color="blue">数量级</font></strong>。例如：两个不同的算法，时间消耗分别是 ① $T_1(n) = 10n^2$和 ② $T_2(n) = 5n^3$，$T_2$的数量级大，一般认为复杂度高。</p>
<ul>
<li><strong>算法时间复杂度的渐进表示</strong></li>
</ul>
<p>若有某个辅助函数$f(n)$，使得当$n$趋近于无穷大时，$T(n)/f(n)$的极限值为不等于零的常数，则称$f(n)$是$T(n)$的同数量级函数。记作$T(n)=O(f(n))$，称$O(f(n))$为算法的渐进时间复杂度($O$是数量级的符号)，简称<strong><font color="red">时间复杂度</font></strong>。</p>
<p>因此，对于上述示例中求解矩阵相乘问题，算法耗费时间复杂度为：</p>
<script type="math/tex; mode=display">
T(n) = O(n^3)</script><p>一般情况下，不必计算所有操作的执行次数，而只考虑算法中<strong>基本操作</strong>执行的次数，它是问题规模$n$的某个函数，用$T(n)$表示。</p>
<p>算法中<strong>基本语句（执行次数最多的语句）</strong>重复执行的次数是<strong>问题规模</strong>$n$的某个函数$f(n)$，算法的时间量度记作：$T(n)=O(f(n))$。它表示随着$n$的增大，算法执行的时间的增长率和$f(n)$的增长率相同，称渐近时间复杂度。</p>
<ul>
<li><strong>分析算法时间复杂度的基本方法</strong></li>
</ul>
<ol>
<li>找出语句频度最大的那条语句作为基本语句；</li>
<li>计算基本语句的频度得到问题规模$n$的某个函数$f(n)$；</li>
<li>取其数量级用符号“O”表示。</li>
</ol>
<h5 id="Ⅱ-算法空间效率的度量"><a href="#Ⅱ-算法空间效率的度量" class="headerlink" title="Ⅱ 算法空间效率的度量"></a>Ⅱ 算法空间效率的度量</h5><ul>
<li><strong>渐进空间复杂度</strong></li>
</ul>
<p>空间复杂度：算法所需存储空间的度量，记作：$S(n) = O(f(n))$，其中$n$为问题的规模(或大小)。</p>
<p>算法要占据的空间：① 变量等算法本身要占据的空间，输入/输出，指令，常数，变量等；② 算法要使用的辅助空间。</p>
<h3 id="sect-2-线性表：顺序表和链表"><a href="#sect-2-线性表：顺序表和链表" class="headerlink" title="&sect; 2 线性表：顺序表和链表"></a>&sect; 2 线性表：顺序表和链表</h3><h4 id="2-1-线性表的定义和特点"><a href="#2-1-线性表的定义和特点" class="headerlink" title="2.1 线性表的定义和特点"></a>2.1 线性表的定义和特点</h4><p>线性表是具有<strong>相同特性</strong>的数据元素的一个<strong>有限序列</strong>：</p>
<script type="math/tex; mode=display">
(a_1, a_2, \cdots, a_{i-1}, a_i, a_{i+1}, \cdots, a_{n-1}, a_n)</script><p><img src="https://pic.imgdb.cn/item/667cbd4dd9c307b7e9b718bf.png" alt="image.png"></p>
<p>线性表的第一个数据元素$a_1$被称为起始节点，最后一个数据元素$a_n$被称为终端节点，中间的数据元素为普通的节点。</p>
<p><strong>线性表(Linear List)的定义：</strong></p>
<p>由$n(n \geq 0)$个数据元素(结点)$a_1，a_2，…，a_n$组成的有限序列。</p>
<ul>
<li>其中数据元素的个数$n$定义为表的长度；</li>
<li>当$n=0$时称为空表；</li>
<li>将非空的线性表($n&gt;0$)记作：$(a_1，a_2，…，a_n)$；</li>
<li>这里的数据元素$a_i$只是一个抽象的符号，其具体含义在不同的情况下不同。</li>
</ul>
<p>有两点需要注意：</p>
<ul>
<li>线性表中每个节点的数据元素类型是相同的；</li>
<li>之所以称为线性，是因为每一个元素只有一个直接前趋，并且也只有一个直接后继(除起始节点、终端节点)。</li>
</ul>
<p><strong>小结</strong></p>
<ol>
<li>线性表中数据元素的类型可以为解简单类型，也可以为复杂类型；</li>
<li>许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序。</li>
<li>从具体应用中抽象出共性的逻辑结构利基本操作（抽象数据类型），然后实现其存储结构和基本操作。</li>
</ol>
<h4 id="2-2-案例引入"><a href="#2-2-案例引入" class="headerlink" title="2.2 案例引入"></a>2.2 案例引入</h4><h4 id="2-3-线性表的类型定义"><a href="#2-3-线性表的类型定义" class="headerlink" title="2.3 线性表的类型定义"></a>2.3 线性表的类型定义</h4><p>抽象数据类型线性表的定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT List&#123;</span><br><span class="line">	数据对象:D=&#123;ai|ai属于Elemset,(i=<span class="number">1</span>,<span class="number">2.</span>..,n, n≥<span class="number">0</span>)&#125;</span><br><span class="line">	数据关系:R=&#123;&lt;a&#123;i<span class="number">-1</span>&#125;, ai|a&#123;i<span class="number">-1</span>&#125;,ai属于D,(i=<span class="number">2</span>,<span class="number">3</span>,...,n)&#125;</span><br><span class="line">	基本操作:</span><br><span class="line">		<span class="comment">// 初始化线性表</span></span><br><span class="line">		<span class="comment">// 操作结果：构造一个空的线性表L</span></span><br><span class="line">		<span class="built_in">InitList</span>(&amp;L);	</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 销毁线性表</span></span><br><span class="line">		<span class="comment">// 初始条件：线性表L已经存在</span></span><br><span class="line">		<span class="comment">// 操作结果: 销毁线性表L</span></span><br><span class="line">		<span class="built_in">DestroyList</span>(&amp;L);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 清楚表中数据</span></span><br><span class="line">		<span class="comment">// 初始条件：线性表L已经存在</span></span><br><span class="line">		<span class="comment">// 操作结果：将线性表L重置为空表</span></span><br><span class="line">		<span class="built_in">ClearList</span>(&amp;L);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 判断表中数据是否为空</span></span><br><span class="line">		<span class="comment">// 初始条件: 线性表L已经存在</span></span><br><span class="line">		<span class="comment">// 操作结果: 若L为空则返回TURE; 否则返回FALSE</span></span><br><span class="line">		<span class="built_in">ListEmpty</span>(L);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 求线性表长度</span></span><br><span class="line">		<span class="comment">// 初始条件: 线性表L已经存在</span></span><br><span class="line">		<span class="comment">// 操作结果: 返回线性表L中的数据元素个数</span></span><br><span class="line">		<span class="built_in">ListLength</span>(L);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 求线性表第i个位置的元素</span></span><br><span class="line">		<span class="comment">// 初始条件: 线性表L已经存在</span></span><br><span class="line">		<span class="comment">// 操作结果: 用e返回线性表L中第i个数据元素的值</span></span><br><span class="line">		<span class="built_in">GetElem</span>(L,i, &amp;e);</span><br><span class="line">		<span class="comment">// 查找搜索元素</span></span><br><span class="line">		<span class="comment">// 初始条件: 线性表L已经存在，compare()是数据元素判定函数</span></span><br><span class="line">		<span class="comment">// 操作结果: 返回L中第1个与e满足compare()的元素位序。若不存在则返回值为0</span></span><br><span class="line">		<span class="built_in">LocateElemL</span>(L,e,<span class="built_in">compare</span>());</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 求一个元素的前趋</span></span><br><span class="line">		<span class="comment">// 初始条件: 线性表L已经存</span></span><br><span class="line">		<span class="comment">// 操作结果: 若cur_e是L的数据元素且不是第一个,则用pre_e返回其前趋，否则操作失败</span></span><br><span class="line">		<span class="built_in">PriorElem</span>(L, cur_e, &amp;pre_e);</span><br><span class="line">		<span class="comment">// 求一个元素的后继</span></span><br><span class="line">		<span class="built_in">NextElem</span>(L, cur_e, &amp;next_e);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 插入一个元素 </span></span><br><span class="line">		<span class="comment">// 初始条件: 线性表L已经存在，1&lt;=i&lt;=ListLength(L)+1</span></span><br><span class="line">		<span class="comment">// 操作结果: 在L的第i个位置之前插入新的数据元素e，L的长度加一</span></span><br><span class="line">		<span class="built_in">ListInsert</span>(&amp;L,i,e);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 删除一个元素</span></span><br><span class="line">		<span class="comment">// 初始条件: 线性表L已经存在，1&lt;=i&lt;=ListLength(L)+1</span></span><br><span class="line">		<span class="comment">// 操作结果: 删除L的第i个数据元素，并用e返回其值，L的长度减一。</span></span><br><span class="line">		<span class="built_in">ListDelete</span>(&amp;L,i,&amp;e);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 遍历</span></span><br><span class="line">		<span class="comment">// 初始条件: 线性表L已经存在</span></span><br><span class="line"> 		<span class="comment">// 操作结果: 依次对线性表中每个元素调用visited()操作</span></span><br><span class="line">		<span class="built_in">ListTraverse</span>(&amp;L, <span class="built_in">visited</span>());</span><br><span class="line">&#125; ADT List</span><br></pre></td></tr></table></figure>
<h4 id="2-4-线性表的顺序表示和实现"><a href="#2-4-线性表的顺序表示和实现" class="headerlink" title="2.4 线性表的顺序表示和实现"></a>2.4 线性表的顺序表示和实现</h4><h5 id="Ⅰ-线性表的存储结构"><a href="#Ⅰ-线性表的存储结构" class="headerlink" title="Ⅰ 线性表的存储结构"></a>Ⅰ 线性表的存储结构</h5><p>在计算机内，线性表有两种基本的存储结构：① 顺序存储结构和 ② 链式存储结构。</p>
<h5 id="Ⅱ-线性表的顺序存储表示"><a href="#Ⅱ-线性表的顺序存储表示" class="headerlink" title="Ⅱ 线性表的顺序存储表示"></a>Ⅱ 线性表的顺序存储表示</h5><p><strong>(1) 基本概念</strong></p>
<p>线性表的顺序表示又称为<strong>顺序存储结构</strong>或<strong>顺序映像</strong>。</p>
<p>顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。</p>
<p><img src="https://pic.imgdb.cn/item/667cd2add9c307b7e9d5a52b.png" alt="图  顺序存储结构示意"></p>
<p>线性表的第1个数据元素$a_1$的存储位置，称作线性表的<strong>起始位置</strong>或<strong>基地址</strong>。</p>
<p>线形表顺序存储结构占用一片<strong><font color="green">连续</font></strong>的存储空间。知道某个元素的存储位置就可以计算其他元素的存储位置</p>
<p><strong>(2) 顺序表中元素存储位置的计算</strong></p>
<p>如果每个元素占用8个存储单元，$a_i$存储位置是2000单元，则$a_{i+1}$存储位置是2008。</p>
<p>假设线性表的每个元素需占$\ell$个存储单元，则第$i+1$个数据元素的存储位置和第$i$个数据元素的存储位置之间满足关系：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \text{LOC}(a_{i+1}) = \text{LOC}(a_i) + \ell \\
& \text{LOC}(a_{i}) = \text{LOC}(a_1) + (i-1) \ell
\end{aligned}</script><p>式中，$\text{LOC}(a_1)$为基地址。</p>
<p><img src="https://pic.imgdb.cn/item/667cd5e7d9c307b7e9dad79b.png" alt="顺序表与数组"></p>
<p>根据顺序表的性质，我们发现与<code>C</code>语言中的数组十分相似，但是仍然存在几个问题：</p>
<ul>
<li>数据长度是否可变<ul>
<li>线性表长可变(添加、插入、删除等)</li>
<li><code>C</code>语言中数组长度不可动态定义</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>C</code>语言中一维数组的定义方式：</p>
<p><code>类型说明符 数组名[常量表达式]</code></p>
<p>说明：常量表达式中可以包含常量和符号常量，不能包含变量。即C语言中不允许对数组的大小作动态定义。</p>
</blockquote>
<p>如何解决这个问题呢？一种方式是首先定义足够大的数组，然后额外用一个变量表示顺序表的长度属性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性表存储空间的初始分配量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType elem[LIST_INIT_SIZE]; 	<span class="comment">// ElemType可以是int、char或其他类型数据</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 当前长度</span></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>
<p>示例1：多项式的顺序存储结构类型定义</p>
<script type="math/tex; mode=display">
P_n(x) = p_1 x^{e_1} + p_2 x^{e_2} + \cdots + p_m x^{e_m}</script><p>线性表$P=((p1, e1), (p2, e2), \cdots, (pm,em))$，代码为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000 <span class="comment">//多项式可能达到的最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">// 多项式非零项的定义</span></span><br><span class="line">    <span class="keyword">float</span> p;	<span class="comment">// 系数</span></span><br><span class="line">    <span class="keyword">int</span> e;		<span class="comment">// 指数</span></span><br><span class="line">&#125;Polynomial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Polynomial *elem;	 <span class="comment">// 存储空间的基地址</span></span><br><span class="line">    <span class="keyword">int</span> length;			<span class="comment">// 多项式中当前项的个数</span></span><br><span class="line">&#125;SqList;	<span class="comment">//多项式的顺序存储结构类型为SqList</span></span><br></pre></td></tr></table></figure>
<p>示例2：图书表的顺序存储结构类型定义</p>
<p><img src="https://pic.imgdb.cn/item/667cd9d4d9c307b7e9e0c0c1.png" alt="图书表"></p>
<p><strong>(3) 顺序表的定义示意图</strong></p>
<p><img src="https://pic.imgdb.cn/item/66820428d9c307b7e9073cf7.png" alt="顺序表示意图"></p>
<h5 id="Ⅲ-内部基础算法实现"><a href="#Ⅲ-内部基础算法实现" class="headerlink" title="Ⅲ 内部基础算法实现"></a>Ⅲ 内部基础算法实现</h5><p><strong>(1) 线性表的初始化（参数引用法）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">% 初始化函数</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitList_Sq</span><span class="params">(SqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L.elem = <span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">if</span>(!L.elem) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(2) 销毁线性表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">% 销毁函数</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList</span><span class="params">(SqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.elem)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">delete</span> L.elem;	<span class="comment">// 释放空间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(3) 清空线性表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(SqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L.length = <span class="number">0</span>;	<span class="comment">// 线性表还占用空间没有释放，只是长度置为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(4) 求线性表的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(SqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> L.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(5) 判断线性表是否为空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(SqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(6) 顺序表的取值</strong>(根据位置i获取相应位置的数据内容)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i, ElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = L.elem[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(7) 顺序表的查找</strong>(按值查找)</p>
<p>在线性表L中查找与指定值e相同的数据元素的位置。从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，返回0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateELem</span><span class="params">(SqList L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在线性表L中查找值为e的数据元素，返回其序号(是第几个元素)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.elem[i] == e)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;		<span class="comment">//查找成功，返回序号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; 		<span class="comment">//查找失败，返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(8) 插入算法</strong></p>
<p>算法思想：<br>① 判断插入位置i是否合法；<br>② 判断顺序表的存储空间是否已满，若已满返回ERROR；<br>③ 将第n至第ì 位的元素依次向后移动一个位置，空出第i个位置；<br>④ 将要插入的新元素e放入第i个位置；<br>⑤ 表长加1，插入成功返回OK。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listlnsert_Sq</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>) <span class="comment">// 插入位置i不合法</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span>( L.length==MAXSIZE ) <span class="comment">// 当前存储空间已满，无法插入</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> j=L.length<span class="number">-1</span>; j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 插入元素</span></span><br><span class="line">    L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line">    <span class="comment">// 表长+1</span></span><br><span class="line">    L.length = L.length+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(9) 删除元素</strong></p>
<p>算法思想:<br>① 判断删除位置i 是否合法(合法值为1≤i≤n)；<br>② 欲删除的元素保留在e中；<br>③ 将第i+1至第n 位的元素依次向前移动一个位置；<br>④ 表长减1，删除成功返回OK.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListDelete_Sq</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (i&lt;<span class="number">1</span>) || (i&gt;L.length) ) <span class="comment">// i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> j=i; j&lt;=L.length<span class="number">-1</span>; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        L.elem[j<span class="number">-1</span>] = L.elem[j];  <span class="comment">// 被删除元素之后的元素前移</span></span><br><span class="line">        L.length--;  / /表长减<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅳ-线性表的顺序存储结构实现小结"><a href="#Ⅳ-线性表的顺序存储结构实现小结" class="headerlink" title="Ⅳ 线性表的顺序存储结构实现小结"></a>Ⅳ 线性表的顺序存储结构实现小结</h5><p>① 利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致；<br>② 在访问线性表时，可以快速地计算出任何一个数据元素的存储地址，因此可以粗略地认为，访问每个元素所花时间相等；<br>③ 这种存取元素的方法被称为<strong>随机存取</strong>法。</p>
<ul>
<li><strong>顺序表优缺点</strong><ul>
<li>优点<ul>
<li>存储密度大(结点本身所占存储量/结点结构所占存储量)；</li>
<li>可以随机存取表中任一元素；</li>
</ul>
</li>
<li>缺点<ul>
<li>在插入、删除某一元素时，需要移动大量元素；</li>
<li>浪费存储空间；</li>
<li>属于静态存储形式，数据元素的个数不能自由扩充。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-5-线性表的链式表示和实现"><a href="#2-5-线性表的链式表示和实现" class="headerlink" title="2.5 线性表的链式表示和实现"></a>2.5 线性表的链式表示和实现</h4><h5 id="Ⅰ-链式表的基本概念"><a href="#Ⅰ-链式表的基本概念" class="headerlink" title="Ⅰ 链式表的基本概念"></a>Ⅰ 链式表的基本概念</h5><p><strong>(1) 链式存储结构</strong></p>
<ul>
<li>结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻；<ul>
<li>用一组物理位置任意的存储单元来存放线性表的数据元素。<br>这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上的。</li>
</ul>
</li>
<li>线性表的链式表示又称为非顺序映像或<strong>链式映像</strong>。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66834dafd9c307b7e9c9f434.png" alt="链式表示例" style="zoom:60%"></p>
<p><strong>(2) 与链式表相关的概念</strong></p>
<ul>
<li>结点：数据元素的存储映像。由<strong>数据域</strong>和<strong>指针域</strong>两部分组成；</li>
<li>链表：n个结点由指针链组成一个链表。它是线性表的链式存储映像，称为线性表的链式存储结构。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66834eebd9c307b7e9cb2889.png" alt="带头结点单链表示意图" style="zoom:60%"></p>
<ul>
<li>单链表：结点只有一个指针域的链表，称为单链表或线性链表；</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66834fb2d9c307b7e9cbf5a0.png" alt="带头结点单链表示意图" style="zoom:70%"></p>
<ul>
<li>双链表：结点有两个指针域的链表，称为双链表；</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66834fe2d9c307b7e9cc2601.png" alt="双链表示意图" style="zoom:70%"></p>
<ul>
<li>循环链表：首尾相接的链表称为循环链表。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6683506ed9c307b7e9ccb75e.png" alt="带头结点循环链表示意图" style="zoom:40%"></p>
<ul>
<li>头指针：是指向链表中第一个结点的指针；</li>
<li>首元结点：是指链表中存储第一个数据元素a1的结点；</li>
<li>头结点：是在链表的首元结点之前人为附加的一个结点；</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66835185d9c307b7e9ced432.png" alt="头指针、头结点、首元结点示意图" style="zoom:60%"></p>
<p>根据是否带头节点，可将链表划分为2中类型：</p>
<p><img src="https://pic.imgdb.cn/item/668352d0d9c307b7e9d02d6f.png" alt="链表的两种形式" style="zoom:80%"></p>
<p><strong>(3) 几点讨论</strong></p>
<ul>
<li>讨论1：如何表示空表？<ul>
<li>无头结点时：头指针为空时表示空表；</li>
<li>有头结点时：头节点的指针域为空时表示空表；</li>
</ul>
</li>
<li>讨论2：额外添加头节点的优势？<ul>
<li>便于首元结点的处理<br>首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理；</li>
<li>便于空表和非空表的统一处理<br>无论链表是否为空，头指针都是指向头结点的非空指针因此空表和非空表的处理也就统一了。</li>
</ul>
</li>
<li>讨论3：头结点的数据域内装的是什么?<ul>
<li>头结点的数据域可以为空，也可存放线性表长度等附加信息，但此结点不能计入链表长度值。</li>
</ul>
</li>
<li>讨论4：链表(链式存储结构)的特点？<ul>
<li>(1) 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。</li>
<li>(2) 访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66835660d9c307b7e9d480a3.png" style="zoom:60%"></p>
<h5 id="Ⅱ-单链表的定义和表示"><a href="#Ⅱ-单链表的定义和表示" class="headerlink" title="Ⅱ 单链表的定义和表示"></a>Ⅱ 单链表的定义和表示</h5><p><strong>(1) 带头结点的单链表</strong></p>
<p>单链表是由表头唯一确定，因此单链表可以用头指针的名字来命名。若头指针名是L，则把链表称为表L。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> // 声明结点的类型和指向结点的指针类型，该结构体的名字为<span class="title">Lnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;	<span class="comment">// 结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>* <span class="title">next</span>;</span>	<span class="comment">// 结点的指针域  struct可加可不加</span></span><br><span class="line">&#125;LNode, *LinkList;	<span class="comment">// 根据typedef的作用：LNode是别名，LinkList为指向结构体Lnode的指针类型</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/66836250d9c307b7e9e461ea.png"></p>
<p>示例：存储学生学号、姓名、成绩的单链表结点类型定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> num[<span class="number">8</span>];	<span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">8</span>];	<span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">int</span> score;	<span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span>*<span class="title">next</span>;</span> <span class="comment">// 指针域</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<p>为了统一链表形式，通常将如上示例的多属性链表定义为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> num[<span class="number">8</span>];	<span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">8</span>];	<span class="comment">// 数据域</span></span><br><span class="line">	<span class="keyword">int</span> score;		<span class="comment">// 数据域</span></span><br><span class="line">&#125; ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>&#123;</span></span><br><span class="line">    ElemType data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<p><strong>(2) 单链表的初始化</strong></p>
<p>算法思想：<br>① 生成新结点作头结点，用头指针L指向头结点；<br>②  将头结点的指针域置空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitList</span><span class="params">(LinkList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> Lnode;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">// 初始化成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(3) 判断链表是否为空</strong></p>
<p>注意：链表为空指的是：链表中无元素，称为空链表(<strong>头指针和头结点仍然在</strong>)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListEmpty</span><span class="params">(LinkList&amp; L)</span> <span class="comment">//若L为空表，则返回1，否则返回0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(4) 单链表的销毁</strong></p>
<p>注意：链表销毁后不再存在，不仅所有的元素没有了，头指针、头节点也没有了。</p>
<p>算法思想：从头指针开始，依次释放所有结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DestoryList_L</span><span class="params">(LinkList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNods* p;	<span class="comment">// 或者 LinkList p;</span></span><br><span class="line">    <span class="keyword">while</span>(L != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        deltet p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(5) 单链表的清空</strong></p>
<p>注意：链表清空后仍然存在，但链表中元素没有了，头指针、头节点仍然存在。</p>
<p>算法思想：依次释放所有结点，并将头结点指针域设置为空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(LinkList&amp; L)</span></span>&#123;	<span class="comment">// 将L重置为空表</span></span><br><span class="line">    Lnode *p,*q;	<span class="comment">// 或 Linklist p,q;</span></span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) 	<span class="comment">// 没到表尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(6) 求链表的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength_L</span><span class="params">(LinkList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p = L-next;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">		len++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(7) 取第i个元素</strong></p>
<p>从链表的头指针出发，顺着链域next逐个结点往下搜索，直至搜索到第i个结点为止。因此，<strong>链表不是随机存取结构</strong>。</p>
<p>算法思想：<br>① 从第1个结点(L-&gt;next)顺链扫描，用指针p指向当前扫描到的结点，p初值p =L-&gt;next；<br>② j做计数器，累计当前扫描过的结点数，j初值为1；<br>③ 当 p指向扫描到的下一结点时，计数器j加1；<br>④ 当j==i时，p所指的结点就是要找的第i个结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取线性表L中的某个数据元素的内容，通过变量e返回</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList&amp; L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    p = L-&gt;next;	<span class="comment">// 初始化</span></span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; j&lt;i )	<span class="comment">// 向后扫描，直到p指向第i个元素或p为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>( !p || j&gt;i )</span><br><span class="line">        <span class="keyword">return</span> ERROR; <span class="comment">// 第i个元素不存在</span></span><br><span class="line">    e = p-&gt;data;	<span class="comment">// 取第i个元素</span></span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(8) 查找算法</strong>(按值查找)</p>
<p>算法思想：<br>① 从第一个结点起，依次和e相比较；<br>② 如果找到一个其值与e相等的数据元素，则返回其在链表中的位置或地址；<br>③ 如果査遍整个链表都没有找到其值和e相等的元素，则返回0或“NULL”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在线性表L中查找值为e的数据元素</span></span><br><span class="line"><span class="comment">// 找到，则返回L中值为e的数据元素的地址，查找失败返回NULL</span></span><br><span class="line"><span class="function">Lnode* <span class="title">LocateELem_L</span><span class="params">(LinkList&amp; L, Elemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>( p &amp;&amp; p-&gt;data!=e)</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在线性表L中查找值为e的数据元素的位置序号</span></span><br><span class="line"><span class="comment">// 返回L中值为e的数据元素的位置序号，查找失败返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateELem_L</span><span class="params">(LinkList&amp; L, Elemtype e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p=L-&gt;next; </span><br><span class="line">    j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; p-&gt;data!=e )</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next; </span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p) </span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(9) 插入操作</strong></p>
<p>算法思想：<br>① 首先找到$a_{i-1}$的存储位置 p；<br>② 生成一个数据域为 e的新结点s；<br>③ 插入新结点：新结点的指针域指向结点$a_i \Longrightarrow$结点 $a_{i-1}$的指针域指向新结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在L中第i个元素之前插入数据元素e</span></span><br><span class="line"><span class="function">Status <span class="title">Listinsert_L</span><span class="params">(LinkList&amp; L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p=L; </span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( p &amp;&amp; j&lt;i<span class="number">-1</span>) <span class="comment">// 寻找第i-1个结点，p指向i-1结点</span></span><br><span class="line">    &#123; </span><br><span class="line">        p=p-&gt;next; </span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p lj&gt;i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;  <span class="comment">// i大于表长+1或者小于1，插入位置非法</span></span><br><span class="line">    LNode* s=<span class="keyword">new</span> LNode; <span class="comment">// 生成新结点s，将结点s的数据域置为e</span></span><br><span class="line">    s-&gt;data=e;	<span class="comment">// 将结点s插入L中</span></span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">	p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(10) 删除操作</strong></p>
<p>算法思想：<br>① 首先找到$a_{i-1}$的存储位置 p，保存要删除的a的值；<br>② 令 p -&gt; next 指向$a_{i+1}$；<br>③ 释放结点$a_{i}$的空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将线性表L中第i个数据元素删除</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList&amp; L, <span class="keyword">int</span> i, ElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p=L;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>( p-&gt;next &amp;&amp; j&lt;i<span class="number">-1</span> ) <span class="comment">// 寻找第i个结点，并令p指向其前驱</span></span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next; </span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="number">-1</span>) <span class="comment">// 删除位置不合理</span></span><br><span class="line">    	<span class="keyword">return</span> ERROR; </span><br><span class="line">    LNode* q=p-&gt;next;	<span class="comment">// 临时保存被删结点的地址以备释放</span></span><br><span class="line">    p-&gt;next=q-&gt;next;	<span class="comment">// 改变删除结点前驱结点的指针域</span></span><br><span class="line">    e=q-&gt;data;	<span class="comment">// 保存删除结点的数据域</span></span><br><span class="line">    <span class="keyword">delete</span> q;	<span class="comment">// 释放删除结点的空间</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(11) 构建单链表：头插法</strong></p>
<p>算法思想：<br>① 从一个空表开始，重复读入数据；<br>② 生成新结点，将读入数据存放到新结点的数据域中；<br>③ 从最后一个结点开始，依次将各结点插入到链表的前端。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_H</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> LNode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>; <span class="comment">// 先建立一个带头结点的单链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        LinkNode p=<span class="keyword">new</span> LNode; 	<span class="comment">// 生成新结点 </span></span><br><span class="line">        cin &gt;&gt; p-&gt;data; 	<span class="comment">// 输入元素值</span></span><br><span class="line">        p-&gt;next=L-&gt;next;	<span class="comment">// 插入到表头</span></span><br><span class="line">        L-&gt;next=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(12) 构建单链表：尾插法</strong></p>
<p>算法思想：<br>① 从空表L开始，将新结点逐个插入到链表的尾部，尾指针r指向链表的尾结点；<br>② 初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点将新结点插入到尾结点后，r指向新结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 正位序输入n个元素的值，建立带表头结点的单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_R</span><span class="params">(LinkList&amp; L, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> LNode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	LNode* r=L;<span class="comment">// 尾指针r指向头结点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        LNode* p=<span class="keyword">new</span> LNode; </span><br><span class="line">        cin &gt; &gt;p-&gt;data;	<span class="comment">//生成新结点 ，输入元素值</span></span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;next=p;	<span class="comment">// 插入到表尾</span></span><br><span class="line">        r=p;	<span class="comment">// r指向新的尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅲ-循环链表"><a href="#Ⅲ-循环链表" class="headerlink" title="Ⅲ 循环链表"></a>Ⅲ 循环链表</h5><p>循环链表：是一种头尾相接的链表(即：表中最后一个结点的指针指向头结点，整个链表形成一个环)。</p>
<p><img src="https://pic.imgdb.cn/item/6684bd72d9c307b7e9646154.png" alt="单循环列表示意"></p>
<p>注意:<br>由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p-&gt;next 是否为空，而是判断它们是否等于头指针L。</p>
<p>例子：两个循环链表合并。</p>
<p><img src="https://pic.imgdb.cn/item/6684c120d9c307b7e96cede7.png" alt="循环链表合并" style="zoom:60%"></p>
<p><img src="https://pic.imgdb.cn/item/6685f3e4d9c307b7e980e888.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">Connect</span><span class="params">(LinkList Ta, LinkList Tb)</span> 	<span class="comment">// 假设Ta、Tb都是非空的单循环链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    p=Ta-&gt;next;	<span class="comment">// p存表头结点</span></span><br><span class="line">    Ta-&gt;next=Tb-&gt;next-&gt;next;	<span class="comment">// Tb表头连结Ta表尾</span></span><br><span class="line">    <span class="keyword">delete</span> Tb-&gt;next;	<span class="comment">// 释放Tb表头结点</span></span><br><span class="line">    Tb-&gt;next=p;	<span class="comment">// 修改指针</span></span><br><span class="line">    <span class="keyword">return</span> Tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅳ-双向链表"><a href="#Ⅳ-双向链表" class="headerlink" title="Ⅳ 双向链表"></a>Ⅳ 双向链表</h5><p>单链表的结点 → 有指示后继的指针域 → 找后继结点方便；<br>即：查找某结点的后继结点的执行时间为$O(1)$。</p>
<p>无指示前驱的指针域 → 找前驱结点难：从表头出发查找。<br>即：查找某结点的前驱结点的执行时间为$O(n)$。</p>
<p>可用<strong>双向链表</strong>来克服单链表的这种缺点。</p>
<p>双向链表：在单链表的每个结点里再增加一个指向其直接前驱的指域 prior ，这样链表中就形成了有两个方向不同的链，故称为双向链表。</p>
<p><strong>(1) 双向链表结构定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLnode</span>* <span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125; DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6685f88bd9c307b7e987638c.png" alt="双链表结构示意图"></p>
<p><strong>(2) 双向循环链表</strong></p>
<p>和单链的循环表类似，双向链表也可以有循环表：让头结点的前驱指针指向链表的最后一个结点，让最后一个结点的后继指针指向头结点。</p>
<p><img src="https://pic.imgdb.cn/item/6685f975d9c307b7e988a057.png" alt="双向循环链表示意图"></p>
<p>双向链表的<strong>对称性</strong>：设指针p指向某一结点，则：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p = p-&gt;next-&gt;prior</span><br></pre></td></tr></table></figure>
<p>在双向链表中有些操作(如：ListLength、GetElem等)，因仅涉及一个方向的指针，故它们的算法与线性链表的相同。但在插入、删除时，则需同时修改两个方向上的指针，两者的操作的时间复杂度均为$O(n)$。</p>
<p><strong>(2) 双向链表插入结点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Listinsert_DuL</span><span class="params">(DuLinkList&amp; L, <span class="keyword">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在带头结点的双向循环链表L中第i个位置之前插入元素 e</span></span><br><span class="line">    <span class="keyword">if</span>(!(p=GetElemP <span class="built_in">DuL</span>(L,i))) </span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    DuLinkList s=<span class="keyword">new</span> DuLNode;</span><br><span class="line">    s-&gt;date = e;</span><br><span class="line">    <span class="comment">// 四部曲</span></span><br><span class="line">    p-&gt;prior-&gt;next = s;</span><br><span class="line">    s-&gt;prior = p-&gt;prior;</span><br><span class="line">    p-&gt;prior = s;</span><br><span class="line">    s -&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(3) 双向链表删除结点</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_DuL</span><span class="params">(DuLink&amp; L, <span class="keyword">int</span> i, ElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 删除带头结点的双向循环链表L的第i个元素，并用 e返回.</span></span><br><span class="line">    <span class="keyword">if</span>(!(p=GetElemP <span class="built_in">DuL</span>(L,i)))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt; data;</span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-线性表的应用"><a href="#2-6-线性表的应用" class="headerlink" title="2.6 线性表的应用"></a>2.6 线性表的应用</h4><h5 id="Ⅰ-线性表的合并"><a href="#Ⅰ-线性表的合并" class="headerlink" title="Ⅰ 线性表的合并"></a>Ⅰ 线性表的合并</h5><p>问题描述：假设利用两个线性表La和Lb分别表示两个集合A和B，现要求一个新的集合A=AUB，注意，存在重复元素合并后只出现一次。</p>
<script type="math/tex; mode=display">
La = (7, 5, 3, 11) \quad Lb=(2,6,3) \quad \Longrightarrow \quad La=(7, 5, 3, 11, 2, 6)</script><p>算法步骤：依次取出Lb中的每个元素，执行以下操作：<br>① 在La中查找该元素；<br>② 如果找不到，则将其插入La的最后。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(List&amp; La, List Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    La_len=<span class="built_in">ListLength</span>(La);	<span class="comment">// 求链表长度</span></span><br><span class="line">    Lb_len=<span class="built_in">ListLength</span>(Lb);	<span class="comment">// 求链表长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=Lb_len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GetElem</span>(Lb,i,e);	<span class="comment">// 取出第i个元素e</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">LocateElem</span>(La, e))	<span class="comment">// 判断La中是否存在e</span></span><br><span class="line">            <span class="built_in">Listinsert</span>(&amp;La, ++La_len, e);	<span class="comment">// 不存在则插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-有序表的合并"><a href="#Ⅱ-有序表的合并" class="headerlink" title="Ⅱ 有序表的合并"></a>Ⅱ 有序表的合并</h5><p>问题描述：已知线性表La 和Lb中的数据元素按值非递减有序排列，现要求将La和Lb归并为一个新的线性表Lc，且Lc中的数据元素仍按值非递减有序排列。</p>
<script type="math/tex; mode=display">
La = (1, 7, 8) \quad Lb=(2, 4, 6, 8, 10, 11) \quad \Longrightarrow \quad Lc=(1, 2, 4, 6, 7, 8, 8, 10, 11)</script><p>算法步骤：<br>① 创建一个空表Lc；<br>② 依次从 La 或 Lb 中”摘取“元素值较小的结点插入到Lc表的最后，直至其中一个表变空为止；<br>③ 继续将 La 或 Lb 其中一个表的剩余结点插入在 Lc 表的最后。</p>
<ul>
<li><strong>用顺序表实现</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList LA, SqList LB, SqList&amp; LC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType* pa = LA.elem;</span><br><span class="line">    ElemType* pb = LB.elem;	<span class="comment">// 指针pa和pb的初值分别指向两个表的第一个元素</span></span><br><span class="line">    LC.length = LA.length+LB.length;	<span class="comment">// 新表长度为待合并两表的长度之和</span></span><br><span class="line">    LC.elem = <span class="keyword">new</span> ElemType[Lc.length];	<span class="comment">// 为合并后的新表分配一个数组空间</span></span><br><span class="line">    ElemType* pc = LC.elem;	<span class="comment">// 指针pc指向新表的第一个元素</span></span><br><span class="line">    ElemType* pa_last = LA.elem+LA.length<span class="number">-1</span>;	<span class="comment">// 指针pa_last指向LA表的最后一个元素</span></span><br><span class="line">    ElemType* pb_last = LB.elem+LB.length<span class="number">-1</span>;	<span class="comment">// 指针pb_last指向LB表的最后一个元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pa&lt;=pa_last &amp;&amp; pb&lt;=pb_last)	<span class="comment">// 两个表都非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pa&lt;=*pb)</span><br><span class="line">            *pc++=*pa++;	<span class="comment">// 依次“摘取”两表中值较小的结点</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            *pc++=*pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pa&lt;=pa_last)</span><br><span class="line">        *pc++=*pa++;	<span class="comment">// LB表已到达表尾，将LA中剩余元素加入LC</span></span><br><span class="line">    <span class="keyword">while</span>(pb&lt;=pb last)</span><br><span class="line">        *pc++=*pb++;	<span class="comment">// LA表已到达表尾，将LB中剩余元素加入LC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>用链表实现</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList&amp; La, LinkList&amp; Lb, LinkList&amp; Lc)</span>	<span class="comment">// La、Lb是带头结点的单链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList pa=La-&gt;next;</span><br><span class="line">    LinkList pb=Lb-&gt;next;</span><br><span class="line">    LinkList pc=La;</span><br><span class="line">    Lc = La;	<span class="comment">// 用La的头结点作为Lc的头结点</span></span><br><span class="line">    <span class="keyword">while</span>( pa &amp;&amp; pb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data&lt;=pb-&gt;data)</span><br><span class="line">        &#123; </span><br><span class="line">            pc-&gt;next=pa; </span><br><span class="line">            pc=pa; </span><br><span class="line">            pa=pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next=pb; </span><br><span class="line">            pc=pb; </span><br><span class="line">            pb=pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next=pa?pa:pb; <span class="comment">// 插入剩余段</span></span><br><span class="line">    <span class="keyword">delete</span> Lb;	<span class="comment">// 释放Lb的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅲ-实际案例1：稀疏多项式的运算"><a href="#Ⅲ-实际案例1：稀疏多项式的运算" class="headerlink" title="Ⅲ 实际案例1：稀疏多项式的运算"></a>Ⅲ 实际案例1：稀疏多项式的运算</h5><p><img src="https://pic.imgdb.cn/item/66860ef8d9c307b7e9aa2cb6.png" alt="稀疏多项式"></p>
<p>容易发现顺序存储结构存在问题：存储空间分配不灵活；运算的空间复杂度高。</p>
<p>因此这种稀疏多项式的运算比较适合于链表实现。</p>
<p>链式存储结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> coef;	<span class="comment">// 系数</span></span><br><span class="line">    <span class="keyword">int</span> expn;	<span class="comment">// 指数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pnode</span>* <span class="title">next</span>;</span>	<span class="comment">// 指针域</span></span><br><span class="line">&#125;PNode, *Polynomial;</span><br></pre></td></tr></table></figure>
<p>【多项式的创建】算法步骤：<br>① 创建一个只有头结点的空链表；<br>② 根据多项式的项的个数n，循环n次执行以下操作：<br>    a. 生成一个新结点<em>s；<br>    b. 输入多项式当前项的系数和指数赋给新结点</em>s的数据域；<br>    c. 设置一前驱指针pre，用于指向待找到的第一个大于输入项指数的结点的前驱，pre初值指向头结点；<br>    d. 指针q初始化，指向首元结点；<br>    e. 循链向下逐个比较链表中当前结点与输入项指数，找到第一个大于输入项指数的结点*q；<br>    f. 将输入项结点s插入到结点q之前。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePolyn</span><span class="params">(Polynomial&amp; P, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 输入m项的系数和指数，建立表示多项式的有序链表P</span></span><br><span class="line">    P = <span class="keyword">new</span> PNode;</span><br><span class="line">    P-&gt;next = <span class="literal">NULL</span>;	<span class="comment">// 先建立一个带头结点的单链表</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)	<span class="comment">// 依次输入n个非零项</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="keyword">new</span> PNode;	<span class="comment">// 生成新结点</span></span><br><span class="line">        cin &gt;&gt; s-&gt;coef &gt;&gt; s-&gt;expn;	<span class="comment">// 输入系数和指数</span></span><br><span class="line">        pre=P;	<span class="comment">// pre用于保存q的前驱，初值为头结点</span></span><br><span class="line">        q=P-&gt;next;	<span class="comment">// q初始化，指向首元结点</span></span><br><span class="line">        <span class="keyword">while</span>(q &amp;&amp; q-&gt;expn &lt; s-&gt;expn)	<span class="comment">// 找到第一个大于输入项指数的项*q</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre=q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;next=q;	<span class="comment">// 将输入项s插入到q和其前驱结点pre之间</span></span><br><span class="line">        pre-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【多项式的相加】算法步骤：</p>
<p>① 指针p1和p2初始化，分别指向Pa和Pb的首元结点；<br>② p3指向和多项式的当前结点，初值为Pa的头结点。<br>③ 当指针p1和p2均未到达相应表尾时，则循环比较p1和p2所指结点对应的指数值(p1-&gt;expn与p2-&gt;expn)，有下列3种情况：<br>    当p1-&gt;expn$==$p2-&gt;expn时，则将两个结点中的系数相加<br>        若和不为零，则修改p1所指结点的系数值，同时删除p2所指结点；<br>        若和为零，则删除p1和p2所指结点；<br>    当p1-&gt;expn $&lt;$ p2-&gt;expn时，则应摘取p1所指结点插入到“和多项式”链表中去；<br>    当p1-&gt;expn $&gt;$ p2-&gt;expn时，则应摘取p2所指结点插入到“和多项式“链表中去。<br>④ 将非空多项式的剩余段插入到p3所指结点之后；<br>⑤ 释放Pb的头结点。</p>
<h3 id="sect-3-线性表：栈和队列"><a href="#sect-3-线性表：栈和队列" class="headerlink" title="&sect; 3 线性表：栈和队列"></a>&sect; 3 线性表：栈和队列</h3><h4 id="3-1-栈和队列的定义和特点"><a href="#3-1-栈和队列的定义和特点" class="headerlink" title="3.1 栈和队列的定义和特点"></a>3.1 栈和队列的定义和特点</h4><h5 id="Ⅰ-概念概述"><a href="#Ⅰ-概念概述" class="headerlink" title="Ⅰ 概念概述"></a>Ⅰ 概念概述</h5><p>栈和队列是两种常用的、重要的数据结构。栈和队列是限定插入和删除只能在表的“<strong>端点</strong>”进行的<strong>线性表</strong>。</p>
<p><strong><font color="red">栈——后进先出</font></strong>：生活举例：电梯进出。</p>
<p><strong><font color="blue">队列——先进先出</font></strong>：生活举例：排队买票。</p>
<ul>
<li>由于栈的操作具有后进先出的固有特性，使得栈成为程序设计中的有用工具。另外，如果问题求解的过程具有”后进先出”的天然特性的话，则求解的算法中也必然需要利用”栈”。</li>
</ul>
<p>例如：数制转换、括号匹配的检验、行编辑程序、迷宫求解、表达式求值、八皇后问题、函数调用、递归调用的实现等都与栈这种数据结构有关。</p>
<ul>
<li>由于队列的操作具有先进先出的特性，使得队列成为程序设计中解决类似排队问题的有用工具。</li>
</ul>
<p>例如：脱机打印输出：按申请的先后顺序依次输出；<br>例如：多用户系统中，多个用户排成队，分时地循环使用CPU和主存；<br>例如：按用户的优先级排成多个队，每个优先级一个队列；<br>例如：实时控制系统中，信号按接收的先后顺序依次处理；<br>例如：网络电文传输，按到达的时间先后顺序依次进行。</p>
<h5 id="Ⅱ-栈-stack-的概念"><a href="#Ⅱ-栈-stack-的概念" class="headerlink" title="Ⅱ 栈(stack)的概念"></a>Ⅱ 栈(stack)的概念</h5><p><strong>(1) 栈的定义</strong></p>
<p>栈(stack)是一个特殊的线性表，是限仅在一端(通常是表尾)进行插入和删除操作的线性表。又称为后进先出(Last In First Out)的线性表，简称<strong>LIFO结构</strong>。</p>
<p>表尾(即$a_n$端)被称为栈顶Top，表头(即$a_1$端)被称为栈底Base。例如：</p>
<script type="math/tex; mode=display">
栈： S=(a_1, a_2, \cdots, a_n)</script><p><strong>入栈</strong>：插入元素到栈顶(表尾)的操作；<strong>出栈</strong>：从栈顶(表尾)删除最后一个元素的操作。</p>
<p><strong>(2) 栈的示意图</strong></p>
<p><img src="https://pic.imgdb.cn/item/668748abd9c307b7e908ccf7.png" alt="栈的示意图"></p>
<p><strong>(3) 栈概念和特点小结</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>相关概念</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>限定只能在表的一端进行插入、删除运算的线性表(只能在栈顶操作)</td>
</tr>
<tr>
<td>逻辑结构</td>
<td>与线性表相同，仍为一对一关系</td>
</tr>
<tr>
<td>存储结构</td>
<td>用顺序栈或链栈存储均可，但以<strong>顺序栈更常见</strong></td>
</tr>
<tr>
<td>运算规则</td>
<td>只能在栈顶运算，且访问结点时依照店进先出(LIFO)的原则</td>
</tr>
<tr>
<td>实现方式</td>
<td>关键是编写入栈和出栈函数，具体实现依顺序栈或链栈的不同而不同</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Ⅲ-队列-queue-的概念"><a href="#Ⅲ-队列-queue-的概念" class="headerlink" title="Ⅲ 队列(queue)的概念"></a>Ⅲ 队列(queue)的概念</h5><p><strong>(1) 队列的定义</strong></p>
<p>队列(queue)是一种先进先出(Frist In Frist Out ——FIFO)的线性表。在表一端插入(表尾)，在另一端(表头)删除。</p>
<script type="math/tex; mode=display">
队列：Q=(a_1, a_2, \cdots, a_n)</script><p><strong>(2) 队列示意图</strong></p>
<p><img src="https://pic.imgdb.cn/item/66874bacd9c307b7e90cffd7.png" alt="队列示意图"></p>
<p><strong>(3) 队列概念和特点小结</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>相关概念</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>只能在表的一端进行插入运算，在表的另一端进行删除运算的线性表(头删尾插)</td>
</tr>
<tr>
<td>逻辑结构</td>
<td>与线性表相同，仍为一对一关系</td>
</tr>
<tr>
<td>存储结构</td>
<td>顺序队或链队，以<strong>循环顺序队列</strong>更常见</td>
</tr>
<tr>
<td>运算规则</td>
<td>只能在队首和队尾运算，且访问结点时依照先进先出(FIFO)的原则</td>
</tr>
<tr>
<td>实现方式</td>
<td>关键是掌握入队和出队操作，具体实现依顺序队或链队的不同而不同</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-2-案例引入"><a href="#3-2-案例引入" class="headerlink" title="3.2 案例引入"></a>3.2 案例引入</h4><h5 id="Ⅰ-进制转换"><a href="#Ⅰ-进制转换" class="headerlink" title="Ⅰ 进制转换"></a>Ⅰ 进制转换</h5><p>十进制整数N向其它进制数d(二、八、十六)的转换是计算机实现计算的基本问题。</p>
<p>转换法则：</p>
<script type="math/tex; mode=display">
n = (n \text{ div }d)*d + n \text{ mod }d</script><p>其中，div为取商运算，mod为取余运算。</p>
<p><img src="https://pic.imgdb.cn/item/66874f2dd9c307b7e911e66e.png" alt="十进制转八进制" style="zoom:40%"></p>
<h5 id="Ⅱ-LeetCode-20有效的括号"><a href="#Ⅱ-LeetCode-20有效的括号" class="headerlink" title="Ⅱ  LeetCode 20有效的括号"></a>Ⅱ  <a href="https://leetcode.cn/problems/valid-parentheses/">LeetCode 20有效的括号</a></h5><h5 id="Ⅲ-表达式求值"><a href="#Ⅲ-表达式求值" class="headerlink" title="Ⅲ 表达式求值"></a>Ⅲ 表达式求值</h5><p>表达式求值是程序设计语言编译中一个最基本的问题，它的实现也需要运用栈。</p>
<p>这里介绍的算法是由运算符优先级确定运算顺序的对表达式求值算法——<strong>算符优先算法</strong>。</p>
<ul>
<li>表达式的组成<ul>
<li>操作数(operand)：常数、变量；</li>
<li>运算符(operator)：算术运算符、关系运算符和逻辑运算符；</li>
<li>界限符(delimiter)：左右括弧和表达式结束符。</li>
</ul>
</li>
</ul>
<p>任何一个算术表达式都由操作数(常数、变量)、算术运算符(+、-、*、/)和界限符(括号、表达式结束符<code>#</code>、虚设的表达式起始符<code>#</code>)组成。后两者统称为算符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">例如：# <span class="number">3</span>*(<span class="number">7</span><span class="number">-2</span>) #</span><br></pre></td></tr></table></figure>
<ul>
<li>为了实现表达式求值，需要设置两个栈：<ul>
<li>一个是<strong>算符栈OPTR</strong>，用于寄存运算符；</li>
<li>另一个称为<strong>操作数栈(OPND)</strong>，用于寄存运算数和运算结果。</li>
</ul>
</li>
<li>求值的处理过程是自左至右扫描表达式的每一个字符：<ul>
<li>当扫描到的是运算数，则将其压入栈OPND；</li>
<li>当扫描到的是运算符时：<ul>
<li>若这个运算符比OPTR栈顶运算符的优先级高，则入栈OPTR，继续向后处理；</li>
<li>若这个运算符比OPTR栈顶运算符优先级低，则从OPND中弹出两个运算数，从OPTR中弹出栈顶运算符进行运算，并将运算结果压入栈OPND。</li>
</ul>
</li>
<li>继续处理当前字符，直到遇到结束符为止。</li>
</ul>
</li>
</ul>
<h4 id="3-3-栈的表示和操作"><a href="#3-3-栈的表示和操作" class="headerlink" title="3.3 栈的表示和操作"></a>3.3 栈的表示和操作</h4><h5 id="Ⅰ-常见的栈操作"><a href="#Ⅰ-常见的栈操作" class="headerlink" title="Ⅰ 常见的栈操作"></a>Ⅰ 常见的栈操作</h5><p><code>InitStack(&amp;S)</code>：初始化操作；操作结果：构造一个空栈S。</p>
<p><code>DestroyStack(&amp;S)</code>：销毁栈操作；初始条件：栈S已存在；操作结果：栈S被销毁。</p>
<p><code>StackEmpty(S)</code>：判定S是否为空；初始条件：栈S已存在；操作结果：若栈S为空则返回true，否则false。</p>
<p><code>StackLength(S)</code>：求栈的长度；初始条件：栈S已存在；操作结果：返回S的元素个数，即栈的长度。</p>
<p><code>GetTop(S, &amp;e)</code>：取栈顶元素；初始条件：栈S已存在且非空；操作结果：用e返回S的栈顶元素。</p>
<p><code>ClearStack(&amp;S)</code>：栈置空操作；初始条件：栈S已存在；操作结果：将 S 清为空栈。</p>
<p><code>Push(&amp;S, e)</code>：入栈操作；初始条件：栈S已存在。操作结果：插入元素e为新的栈顶元素。</p>
<p><code>Pop(&amp;S, &amp;e)</code>：出栈操作；初始条件：栈S已存在且非空；操作结果：删除S的栈顶元素an，并用e返回<br>其值。</p>
<h5 id="Ⅱ-顺序栈的表示和实现"><a href="#Ⅱ-顺序栈的表示和实现" class="headerlink" title="Ⅱ 顺序栈的表示和实现"></a>Ⅱ 顺序栈的表示和实现</h5><p>存储方式：同一般线性表的顺序存储结构完全相同，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素。</p>
<p>栈底一般在低地址端。① 附设top指针，指示栈顶元素在顺序栈中的位置。② 附设base指针，指示栈底元素在顺序栈中的位置。③ 用stacksize表示栈可使用的最大容量。</p>
<p><img src="https://pic.imgdb.cn/item/66875a07d9c307b7e922d9ed.png" style="zoom:50%"></p>
<p>从上图可以看到，为了方便操作，通常top指示真正的栈顶元素之上的下标地址。</p>
<p><strong>空栈标志：</strong><code>base=top</code></p>
<p><strong>栈满标志：</strong><code>top-base=stacksize</code></p>
<p>栈满时的处理：1、报错，返回操作系统。2、分配更大空间，作为栈的存储空间，将原栈的内容移入新栈。</p>
<ul>
<li>使用数组作为顺序栈存储方式的特点：简单，方便、但易产生溢出(数组大小固定)<ul>
<li>上溢(overflow)：栈已经满，又要压入元素；</li>
<li>下溢(underflow)：栈已经空，还要弹出元素</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：上溢是一种错误，使问题的处理无法进行；而下溢一般认为是一种结束条件，即问题处理结束。</p>
</blockquote>
<p><strong>(1) 顺序栈的数据类型定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType* base;	<span class="comment">// 栈底指针</span></span><br><span class="line">    SElemType* top;	<span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;	<span class="comment">// 栈可用最大容量</span></span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure>
<p><strong>(2) 顺序栈的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base = <span class="keyword">new</span> SElemType[MAXSIZE];	<span class="comment">// base指针指向数组首元素地址</span></span><br><span class="line">    <span class="keyword">if</span>(!S.base)	<span class="comment">// 判断空间是否分配成功</span></span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(3) 顺序栈判断是否为空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 若栈为空，返回TRUE;否则返回FALSE</span></span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(4) 顺序栈求长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.top-S.base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(5) 顺序栈的清空</strong>(不销毁内存，只清空数据)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">( SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S.base ) </span><br><span class="line">        S.top = S.base;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(6) 顺序栈的销毁</strong>(销毁内存，清空数据)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">( SqStack&amp; S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S.base )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] S.base ;	<span class="comment">// 注意： ① []是否要加？；② delet是释放空间，指针还存在</span></span><br><span class="line">        S.stacksize =<span class="number">0</span>;</span><br><span class="line">        S.base = S.top = <span class="literal">NULL</span>;	<span class="comment">// 防止野指针？</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(7) 顺序栈的入栈操作</strong></p>
<p>算法思想：<br>① 判断是否栈满，若满则出错(上溢)；<br>② 元素e压入栈顶；<br>③ 栈顶指针加1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">( SqStack&amp; S, SElemType e)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base==S.stacksize)<span class="comment">// 栈满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *S.top = e;</span><br><span class="line">    S.top++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(8) 顺序栈的出栈操作</strong></p>
<p>算法思想：<br>① 判断是否栈空，若空则出错(下溢)；<br>② 获取栈顶元素e；<br>③ 栈顶指针减1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStaclk&amp; S, SElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 若栈不空，则删除S的栈顶无素，用e返回其值,并返回OK;否则返回ERROR</span></span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base)	<span class="comment">// 等价于if(StackEmpty(S))</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    --S.top;</span><br><span class="line">    e = *S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h5 id="Ⅲ-链栈的表示和实现"><a href="#Ⅲ-链栈的表示和实现" class="headerlink" title="Ⅲ 链栈的表示和实现"></a>Ⅲ 链栈的表示和实现</h5><p>链栈的表示：链栈是运算受限的单链表，只能在链表头部进行操作。</p>
<p><img src="https://pic.imgdb.cn/item/668792f8d9c307b7e9888e7b.png"></p>
<p>看上图，链栈有点类似于用头插法构造链表。</p>
<ul>
<li>链表的头指针就是栈顶</li>
<li>不需要头结点</li>
<li>基本不存在栈满的情况</li>
<li>空栈相当于头指针指向空</li>
<li>插入和删除仅在栈顶处执行</li>
</ul>
<p><strong>(1) 链栈的数据类型定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stacknode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stacknode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode, *LinkStack;</span><br><span class="line"></span><br><span class="line">LinkStack S;	<span class="comment">// 创建一个指向链栈结点的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 链栈的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(LinkStack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造一个空栈，栈顶指针置为空</span></span><br><span class="line">    S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(3) 链栈判断是否为空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(4) 链栈的入栈操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack&amp; S , SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkStack p=<span class="keyword">new</span> StackNode;	<span class="comment">// 生成新结点p</span></span><br><span class="line">    p-&gt;data=e;	<span class="comment">// 将新结点数据域置为e</span></span><br><span class="line">    p-&gt;next=S;	<span class="comment">// 将新结点插入栈顶</span></span><br><span class="line">    S=p;	<span class="comment">// 修改栈顶指针</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(5) 链栈的出栈操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack&amp; S, SElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=S-&gt; data;</span><br><span class="line">    p=S;</span><br><span class="line">    S=S-&gt; next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(6) 取栈顶元素</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-栈与递归"><a href="#3-4-栈与递归" class="headerlink" title="3.4 栈与递归"></a>3.4 栈与递归</h4><h5 id="Ⅰ-递归的定义"><a href="#Ⅰ-递归的定义" class="headerlink" title="Ⅰ 递归的定义"></a>Ⅰ 递归的定义</h5><p>若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的；</p>
<p>若一个过程直接地或间接地调用自己，则称这个过程是递归的过程。例如：递归求n的阶乘</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fact</span> <span class="params">( <span class="keyword">long</span> n )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> n * <span class="built_in">Fact</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下三种情况常常用到递归方法</p>
<p>① 递归定义的数学函数</p>
<ul>
<li>阶乘函数：</li>
</ul>
<script type="math/tex; mode=display">
\text{Fact}(n) = \begin{align}
\begin{cases}
1 & n = 1 \\
n \cdot \text{Fact}(n) & n \neq 1
\end{cases}
\end{align}</script><ul>
<li>2阶Fibonaci数列：</li>
</ul>
<script type="math/tex; mode=display">
\text{Fib}(n) = \begin{align}
\begin{cases}
1 & n = 1 \text{ OR }n=2\\
\text{Fib}(n) + \text{Fib}(n) & \text{others} 
\end{cases}
\end{align}</script><p>② 具有递归特性的数据结构</p>
<ul>
<li>二叉树</li>
<li>广义表</li>
</ul>
<p>③ 可递归求解的问题</p>
<ul>
<li>迷宫问题</li>
<li>Hanoi塔问题</li>
</ul>
<h5 id="Ⅱ-递归的本质解析"><a href="#Ⅱ-递归的本质解析" class="headerlink" title="Ⅱ 递归的本质解析"></a>Ⅱ 递归的本质解析</h5><p><strong>(1) 思想：用分治法求解问题</strong></p>
<p>分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解。</p>
<p>必备的三个条件：<br>① 能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，且这些处理对象是变化有规律的；<br>② 可以通过上述转化而使问题简化；<br>③ 必须有一个明确的递归出口，或称递归的边界。</p>
<p>分治法求解递归问题算法的一般形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(参数表)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(递归结束条件)</span><br><span class="line">        可直接求解步骤;	<span class="comment">// -----基本项</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">p</span>(较小的参数);	<span class="comment">// ------归纳项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(2) 函数调用过程</strong></p>
<ul>
<li>调用前，系统完成：<br>① 将实参、返回地址等传递给被调用函数；<br>② 为被调用函数的局部变量分配存储区；<br>③ 将控制转移到被调用函数的入口。</li>
<li>调用后，系统完成：<br>① 保存被调用函数的计算结果；<br>② 释放被调用函数的数据区；<br>③ 依照被调用函数保存的返回地址将控制转移到调用函数。</li>
</ul>
<p>当多个函数构成嵌套调用时，简单分析可知，最后调用的函数先返回结果，也就是遵循：<strong>后调用先返回——栈的特征</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/6688acb9d9c307b7e94cde7e.png" alt="阶乘函数调用"></p>
<p><strong>(3) 递归的优缺点</strong></p>
<p>优点：结构清晰，程序易读。</p>
<p>缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈恢复状态信息。时间开销大。</p>
<p>当对时间效率要求比较高的时候，就要想办法把递归变成非递归，通用的方法有2种：</p>
<p>① 尾递归、单向递归→循环结构；</p>
<p>尾递归：</p>
<p><img src="https://pic.imgdb.cn/item/6688af7dd9c307b7e9512999.png"></p>
<p>单向递归：虽然有一处以上的递归调用语句，但各次递归调用语句的参数只和主调函数有关，相互之间参数无关，并且这些递归调用语句处于算法的最后。</p>
<p><img src="https://pic.imgdb.cn/item/6688b0fdd9c307b7e95397ff.png"></p>
<p>② 自用栈模拟系统的运行时栈。</p>
<p>借助栈改写递归：</p>
<p>—— 递归程序在执行时需要系统提供栈来实现；</p>
<p>—— 仿照递归算法执行过程中递归工作栈的状态变化可写出相应的非递归程序；</p>
<p>—— 改写后的非递归算法与原来的递归算法相比，结构不够清晰，可读性较差有的还需要经过一系列优化。</p>
<p>详细步骤：</p>
<p><code>Step 1</code>：设置一个工作栈存放递归工作记录(包括实参、返回地址及局部变量等)；<br><code>Step 2</code>：进入非递归调用入口(即被调用程序开始处)将调用程序传来的实在参数和返回地址入栈(递归程序不可以作为主程序，因而可认为初始是被某个调用程序调用)；<br><code>Step 3</code>：进入递归调用入口:当不满足递归结束条件时，逐层递归，将实参、返回地址及局部变量入栈，这一过程可用循环语句来实现一模拟递归分解的过程；<br><code>Step 4</code>：递归结束条件满足，将到达递归出口的给定常数作为当前的函数值；<br><code>Step 5</code>：返回处理：在栈不空的情况下，反复退出栈顶记录，根据记录中的返回地址进行题意规定的操作，即逐层计算当前函数值，直至栈空为止一模拟递归求值过程。</p>
<h4 id="3-5-队列的表示和操作"><a href="#3-5-队列的表示和操作" class="headerlink" title="3.5 队列的表示和操作"></a>3.5 队列的表示和操作</h4><h5 id="Ⅰ-常见的队列操作"><a href="#Ⅰ-常见的队列操作" class="headerlink" title="Ⅰ 常见的队列操作"></a>Ⅰ 常见的队列操作</h5><p><code>InitQueue(&amp;Q)</code>：初始化操作；操作结果：构造一个空队列Q。</p>
<p><code>DestroyQueue(&amp;Q)</code>：销毁队列操作；初始条件：队列Q已存在；操作结果：队列Q被销毁。</p>
<p><code>ClearQueue(&amp;Q)</code>：判定Q是否为空；初始条件：队列Q已存在；操作结果：若队列Q为空则返回true，否则false。</p>
<p><code>QueueLength(Q)</code>：求队列Q的长度；初始条件：队列Q已存在；操作结果：返回队列Q的元素个数。</p>
<p><code>GetHead(Q, &amp;e)</code>：求队头元素；初始条件：队列Q已存在且非空；操作结果：用e返回队头元素。</p>
<p><code>EnQueue(&amp;Q, e)</code>：插入操作；操作结果：插入元素e为Q的队尾元素。</p>
<p><code>DeQueue(&amp;Q, &amp;e)</code>：删除操作；条件：Q为非空队列；操作结果：:删除Q的队头元素，用e返回值。</p>
<p>还有将队列置空、遍历队列等操作….</p>
<h5 id="Ⅱ-队列的顺序表示和实现"><a href="#Ⅱ-队列的顺序表示和实现" class="headerlink" title="Ⅱ 队列的顺序表示和实现"></a>Ⅱ 队列的顺序表示和实现</h5><p>队列的物理存储可以用顺序存储结构，也可用链式存储结构。相应地，队列的存储方式也分为两种，即顺序队列和链式队列。</p>
<p>队列的顺序表示 —— 用一维数组<code>base[MAXQSIZE]</code>。</p>
<p><strong>(1) 顺序队的数据类型定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 100 <span class="comment">// 最大队列长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType *base;<span class="comment">// 初始化的动态分配存储空间，用数组存储数据</span></span><br><span class="line">    <span class="keyword">int</span> front;	<span class="comment">// 头指针：称作指针，但实际不是指针类型变量，作用是指示队头位置</span></span><br><span class="line">    <span class="keyword">int</span> reary;	<span class="comment">// 尾指针</span></span><br><span class="line">&#125;sqQueue;</span><br></pre></td></tr></table></figure>
<p><strong>(2) 队列的假溢出</strong></p>
<p><img src="https://pic.imgdb.cn/item/6688ba4cd9c307b7e96324ee.png" alt="队列的假溢出"></p>
<ul>
<li>解决方法：<ul>
<li>方法1：将队中元素依次向队头方向移动。<br>缺点：时间消耗大，每移动一次，队中元素都要移动。</li>
<li>方法2：将队空间设想成一个<strong><font color="blue">循环的表</font></strong>，即分配给队列的m个存储单元可以循环使用，当rear为maxgsize时，若向量的开始端空着，又可从头使用空着的空间。当front为maxqsize时，也是一样。</li>
</ul>
</li>
</ul>
<p>综上，基本使用方法2的<strong>循环队列法</strong>：</p>
<p><code>base[0]</code>接在<code>base[MAXQSIZE-1]</code>之后，若<code>rear+1==M</code>，则令<code>rear=0</code>。实现方法：利用<strong>&lt;font color=re’d&gt;模(mod，C语言中%)运算&lt;/font&gt;</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">Q.base[Q.rear] = x;</span><br><span class="line">Q.rear = (Q.rear+<span class="number">1</span>)%MAXQSIZE; 	<span class="comment">// 对MAXQSIZE取模</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">x = Q.base[s.front]</span><br><span class="line">Q.front = (Q.front+<span class="number">1</span>)%MAXQSIZE;</span><br></pre></td></tr></table></figure>
<p>但是，采用了循环队列之后，要考虑队空和队满的情况，因为不做处理的时候，队空和队满情况是一样的，如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/6688c2bfd9c307b7e971db9e.png"></p>
<p><strong>(3) 循环队列解决队空/满的方法——这里介绍少用一个元素法</strong></p>
<p><img src="https://pic.imgdb.cn/item/6688c469d9c307b7e974951d.png"></p>
<p>注意，队空的判定仍然是使用<code>front==rear</code>，而队满采用：<code>(rear+1)%MAXQSIXZE==front</code>。</p>
<p><strong>(4) 循环顺序队列的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span> <span class="params">(SqQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.base = <span class="keyword">new</span> QElemType[MAXQSIZE];	<span class="comment">// 分配数组空间</span></span><br><span class="line">    <span class="keyword">if</span>(!Q.base) </span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);	<span class="comment">// 存储分配失败</span></span><br><span class="line">    Q.front=<span class="number">0</span>;	<span class="comment">// 头指针尾指针置为0，队列为空</span></span><br><span class="line">    Q.rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(5) 循环顺序队列求长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( (Q.rear-Q.front + MAXQSIZE)%MAXQSIZE ) 	<span class="comment">// 注意此处算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(6) 循环顺序队列的入队</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue&amp; Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (Q.rear+<span class="number">1</span>)%MAXQSIZE==Q.front )	<span class="comment">// 队满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR; </span><br><span class="line">    </span><br><span class="line">    Q.base[Q.rear]=e;	<span class="comment">// 新元素加入队尾</span></span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MAXQSIZE;	<span class="comment">// 队尾指针+1</span></span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(7) 循环顺序队列的出队</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue&amp; Q, QElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)	<span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    e = Q.base[Q.front];	<span class="comment">// 保存队头元素</span></span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MAXQSIZE;	<span class="comment">// 队头指针+1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Ok;</span><br></pre></td></tr></table></figure>
<p><strong>(8) 取队首元素</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetHead</span><span class="params">(SqQuere Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front!=Q.rear)	<span class="comment">// 队列不为空</span></span><br><span class="line">        <span class="keyword">return</span> Q.base[Q.front];	<span class="comment">// 返回队头指针元素的值，队头指针不变</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;	<span class="comment">// 看具体的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅲ-链队的表示和实现"><a href="#Ⅲ-链队的表示和实现" class="headerlink" title="Ⅲ 链队的表示和实现"></a>Ⅲ 链队的表示和实现</h5><p>若用户无法估计所用队列的长度，则宜采用链队列。</p>
<p><img src="https://pic.imgdb.cn/item/6688e7e2d9c307b7e9b6052d.png" alt="带头结点的链队"></p>
<p><strong>(1) 链队的数据类型定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链队的数据类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QElemType data;</span><br><span class="line">	stuct Qnode *next;</span><br><span class="line">&#125;QNode, *QuenePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头尾指针单独封装起来</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QuenePtr front;	<span class="comment">// 队头指针</span></span><br><span class="line">	QuenePtr rear;	<span class="comment">// 队尾指针</span></span><br><span class="line">&#125; LinkQueue;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6688eaf1d9c307b7e9bce5bb.png" style="zoom:70%"></p>
<p><strong>(2) 链队的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">initQueue</span> <span class="params">(LinkQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.front = <span class="keyword">new</span> QNode;</span><br><span class="line">    Q.rear = Q.front;</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(3) 链队的销毁</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue&amp; Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(Q.front)</span><br><span class="line">    &#123;</span><br><span class="line">        p=Q.front-&gt;next; </span><br><span class="line">        <span class="keyword">delete</span> Q.front; </span><br><span class="line">        Q.front=p;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(4) 链队的入队操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue&amp; Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QuenePtr p = <span class="keyword">new</span> QNode;</span><br><span class="line">    <span class="keyword">if</span>(!p) </span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data=e; </span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=p;</span><br><span class="line">    Q.rear=p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(5) 链队的出队操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue&amp; Q, QElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)	<span class="comment">// 空队</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    e=p-&gt;data;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p)	<span class="comment">// 队中只有一个元素时</span></span><br><span class="line">        Q.rear=Q.front;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(6) 链队求队头操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue Q, QElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) </span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e=Q.front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sect-4-串、数组和广义表"><a href="#sect-4-串、数组和广义表" class="headerlink" title="&sect; 4 串、数组和广义表"></a>&sect; 4 串、数组和广义表</h3><h4 id="4-1-串"><a href="#4-1-串" class="headerlink" title="4.1 串"></a>4.1 串</h4><h5 id="Ⅰ-串的概念"><a href="#Ⅰ-串的概念" class="headerlink" title="Ⅰ 串的概念"></a>Ⅰ 串的概念</h5><p>这里的串，特指“<strong>字符串(String)</strong>”：零个或多个任意字符组成的有限序列。</p>
<script type="math/tex; mode=display">
\text{String } S="a_1 a_2 \cdots a_n"</script><p><strong>(1) 几个相关概念</strong></p>
<ul>
<li><p><strong>字串</strong>：串中任意个连续字符组成的子序列称为该串的子串。</p>
</li>
<li><p><strong>主串</strong>：包含子串的串相应地称为主串。</p>
</li>
<li><p><strong>字符位置</strong>：字符在序列中的序号为该字符在串中的位置。</p>
</li>
<li><p><strong>子串位置</strong>：子串第一个字符在主串中的位置。</p>
</li>
<li><p><strong>空格串</strong>：由一个或多个空格组成的串，与空串不同。</p>
</li>
<li><p><strong>串相等</strong>：当且仅当两个串的长度相等，并且各个对应位置上的字符都相同时，这两个串才是相等的。</p>
<ul>
<li>所有的空串都是相等的。</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-案例引入"><a href="#Ⅱ-案例引入" class="headerlink" title="Ⅱ 案例引入"></a>Ⅱ 案例引入</h5><p>串的应用非常广泛，计算机上的非数值处理的对象大部分是字符串数据，例如：文字编辑、符号处理、各种信息处理系统等等。</p>
<p><strong>案例： 病毒感染检测</strong></p>
<p>研究者将人的DNA和病毒DNA均表示成由一些字母组成的字符串序列。然后检测某种病毒DNA序列是否在患者的DNA序列中出现过，如果出现过，则此人感染了该病毒，否则没有感染。</p>
<p>例如：假设病毒的DNA序列为baa(aab、aba)，患者1的DNA序列为aaabbba，则感染，患者2的DNA序列为babbba，则未感染。(注意，人的DNA序列是线性的，而病毒的DNA序列是环状的)</p>
<h5 id="Ⅲ-串的表示和实现"><a href="#Ⅲ-串的表示和实现" class="headerlink" title="Ⅲ 串的表示和实现"></a>Ⅲ 串的表示和实现</h5><p><strong>(1) 串的类型定义</strong></p>
<p>串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构。</p>
<p><img src="https://pic.imgdb.cn/item/66891600d9c307b7e912fb17.png" style="zoom:50%"></p>
<p><strong>涉及串的相关操作：</strong></p>
<p><code>StrAssign(&amp;T, chars)</code>：串赋值。</p>
<p><code>StrCompare(S, T)</code>：串比较。</p>
<p><code>StrLength(S)</code>：求串长。</p>
<p><code>Concat(&amp;T,S1,S2)</code>：串连结。</p>
<p><code>SubString(&amp;sub, S, pos, len)</code>：求子串。</p>
<p><code>StrCopy(&amp;T, S)</code>：串拷贝。</p>
<p><code>StrEmpty(S)</code>：串判空。</p>
<p><code>ClearString (&amp;S)</code>：清空串。</p>
<p><code>index(S, T, pos)</code>：子串的位置。</p>
<p><code>Replace(&amp;S,T, V)</code>：串替换。</p>
<p><code>Strlnsert(&amp;S, pos, T)</code>：子串插入。</p>
<p><code>StrDelete(&amp;S, pos, len)</code>：子串删除。</p>
<p><code>DestroyString(&amp;S)</code>：串销毁。</p>
<h5 id="Ⅳ-顺序串的表示和实现"><a href="#Ⅳ-顺序串的表示和实现" class="headerlink" title="Ⅳ 顺序串的表示和实现"></a>Ⅳ 顺序串的表示和实现</h5><p><strong>(1) 顺序串的存储结构</strong></p>
<p>顺序串在实际中比链串更常用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN+<span class="number">1</span>];	<span class="comment">//存储串的一维数组</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">//串的当前长度长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>
<p><strong>(2) 顺序串的模式匹配算法</strong></p>
<ul>
<li><strong>概念</strong>：确定主串中所含<strong>子串(模式串)</strong>第一次出现的位置(定位)。</li>
<li><strong>算法应用</strong>：搜索引擎、拼写检查、语言翻译、数据压缩算法。</li>
<li><strong>算法种类</strong>：<ul>
<li>BF算法(Brute-Force，又称古典的、经典的、朴素的、穷举的、暴力算法)</li>
<li><strong>KMP算法</strong>(特点：速度快)</li>
</ul>
</li>
</ul>
<p><strong><font color="blue">BF算法：穷举法思想<font></font></font></strong></p>
<p><img src="https://pic.imgdb.cn/item/66891d7ad9c307b7e9206ef1.png" alt="BF算法基本思想" style="zoom:40%"></p>
<p>简单来说：算法的思路是从S的第一个字符开始依次与T的字符进行匹配。</p>
<p>算法流程：</p>
<p>将主串的第pos个字符和模式串的第一个字符比较</p>
<p>—— 若相等，继续逐个比较后续字符；</p>
<p>—— 若不等，从主串的下一字符起，重新与模式串的第一个字符比较。</p>
<p>—— —— 直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号；</p>
<p>—— ——否则，匹配失败，返回值 0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> index <span class="title">BF</span><span class="params">(SString s, sString T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=S.length &amp;&amp; j&lt;=T.length) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.ch[i]==t.ch[j]) 	<span class="comment">// 主串和子串依次匹配下一个字符</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++i; </span><br><span class="line">            ++j; </span><br><span class="line">        &#125;	</span><br><span class="line">        <span class="keyword">else</span> 	<span class="comment">// 本次匹配不成功，主串、子串指针回溯重新开始下一次匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>; </span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j&gt;T.length) </span><br><span class="line">        <span class="keyword">return</span> i-T.length;	<span class="comment">// 返回匹配的第一个字符的下标</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 模式匹配不成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><font color="red">KMP算法<font></font></font></strong></p>
<p>利用已经部分匹配的结果而加快模式串的滑动速度？且主串S的指针i不必回溯！可提速到$O(n+m)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S,sString T, <span class="keyword">int</span> pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = pos;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( i&lt;s.length &amp;&amp; j&lt;Tlength ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( j==<span class="number">0</span> || S.ch[i]==Tch[j] )</span><br><span class="line">        &#123; </span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];	<span class="comment">// i不变j后退</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( j&gt;T.length )</span><br><span class="line">        <span class="keyword">return</span> i-T.length; 	<span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 返回不匹配标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>next[j]</code>的求法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(SString T, <span class="keyword">int</span>&amp; next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = <span class="number">1</span>; </span><br><span class="line">    next[<span class="number">1</span>]= <span class="number">0</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( i&lt;Tlength )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( j==<span class="number">0</span> || T.ch[i] == T.ch[j] )</span><br><span class="line">        &#123;</span><br><span class="line">            ++i; </span><br><span class="line">            ++j;</span><br><span class="line">            next[i] =j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j= next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/onlyblues/p/15609498.html">关于KMP算法中模式串的移动不会产生漏解的证明 - 博客园</a></p>
<p><a href="https://blog.csdn.net/qq_21989927/article/details/109520767">反证法证明：为什么KMP算法不会跳过（漏掉）正确的答案 - CSDN</a></p>
<h5 id="Ⅴ-链串的表示和实现"><a href="#Ⅴ-链串的表示和实现" class="headerlink" title="Ⅴ 链串的表示和实现"></a>Ⅴ 链串的表示和实现</h5><p><strong>(1) 链串的存储结构</strong></p>
<p><img src="https://pic.imgdb.cn/item/66891976d9c307b7e9194b0e.png" style="zoom:60%"></p>
<p>为例改善存储密度低的问题，一般采用下面这种方式，又被称为<strong><font color="green">块链串</font></strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE 80	<span class="comment">// 块的大小可由用户定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Chunk* head,* tail;	<span class="comment">// 串的头指针和尾指针</span></span><br><span class="line">    <span class="keyword">int</span> curlen;	<span class="comment">// 串的当前长度</span></span><br><span class="line">&#125;LString;	<span class="comment">// 字符串的块链结构</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-数组"><a href="#4-2-数组" class="headerlink" title="4.2 数组"></a>4.2 数组</h4><h5 id="Ⅰ-数组的概念"><a href="#Ⅰ-数组的概念" class="headerlink" title="Ⅰ 数组的概念"></a>Ⅰ 数组的概念</h5><p>数组：按一定格式排列起来的、具有<strong>相同类型</strong>的数据元素的集合。</p>
<p><strong>(1) 一维数组</strong></p>
<p>一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组。<br>一维数组的逻辑结构：线性结构，定长的线性表。<br>声明格式：<code>数据类型 变量名称[长度]</code>，e.g. <code>int a[5] = &#123;0, 1, 2, 3, 4&#125;</code>。</p>
<p><strong>(2) 二维数组</strong></p>
<p>二维数组：若一维数组中的数据元素又是一维数组结构，则称为二维数组。</p>
<ul>
<li>二维数组的逻辑结构可分为2种：<ul>
<li>非线性结构：每一个数据元素既在一个行表中，又在一个列表中。</li>
<li>线性结构(定长的线性表)：该线性表的每个数据元素也是一个定长的线性表。</li>
</ul>
</li>
</ul>
<p>声明格式：<code>数据类型 变量名称[行数][列数]</code>，e.g. <code>int num[5][8]</code>。</p>
<p><strong>(3) 高维数组</strong></p>
<p>三维数组：若二维数组中的元素又是一个一维数组，则称作三维数组。<br>n维数组：若n-1维数组中的元素又是一个一维数组结构则称作n维数组。</p>
<p><strong>(4) 结论</strong></p>
<p>线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。</p>
<p>数组特点：<strong>结构固定</strong>——定义后，维数和维界不再改变。</p>
<p>数组基本操作：除了结构的初始化和销毁之外只有取元素和修改元素值的操作。</p>
<h5 id="Ⅱ-数组的表示和操作"><a href="#Ⅱ-数组的表示和操作" class="headerlink" title="Ⅱ 数组的表示和操作"></a>Ⅱ 数组的表示和操作</h5><p>数组很少会采用链式存储结构，因为一般数组特点：<strong>结构固定</strong>。</p>
<p><strong>(1) 数组的顺序存储结构和基本操作</strong></p>
<p>数组可以是多维的，但存储数据元素的内存单元地址是一维的，因此，在存储数组结构之前，需要解决将多维关系映射到一维关系的问题。</p>
<p>例1：一个一维数组定义为：<code>int a[5]</code>，每个元素占用4字节，假设<code>a[0]</code>存储在2000单元，<code>a[3]</code>地址是多少?</p>
<p>答1：占据2012-2015存储单元。</p>
<p>二维数组的存储顺序可以按行、按列分为2种情况：</p>
<p><img src="https://pic.imgdb.cn/item/668a0dfcd9c307b7e994cd6d.png"></p>
<ul>
<li>以行序为主序时：<ul>
<li>设数组开始存储位置 <code>LOC(0,0)</code>，存储每个元素需要L个存储单元数组元素<code>a[i][j]</code>的存储位置是：<code>LOC(i,j)= LOC(0,0)+(n*i+j)*L</code>。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/668b3b42d9c307b7e919d43c.png"></p>
<p><strong>(2) 特殊矩阵的压缩存储</strong></p>
<p>矩阵：可以看作是一个由$m \times n$个元素排成的$m$行$n$列的表。</p>
<p>矩阵的常规存储：将矩阵描述为一个二维数组。矩阵的常规存储的特点：① 可以对其元素进行随机存取；② 矩阵运算非常简单；③存储的密度为 1。</p>
<p>这里考察某些比较特殊的矩阵的存储，这类矩阵不适宜常规存储的矩阵 —— 值相同的元素很多且呈某种规律分布，零元素多。</p>
<p><strong>矩阵的压缩存储</strong>：为多个相同的非零元素只分配一个存储空间；对零元素不分配空间。</p>
<p><strong>压缩存储的定义</strong>：若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间。一些特殊矩阵，如：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵等都适合采用压缩存储。</p>
<ul>
<li>对称矩阵<ul>
<li>[存储方法] 只存储下(或者上)三角(包括主对角线)的数据元素。共占用n(n+1)/2个元素空间。</li>
</ul>
</li>
<li>三角矩阵：对角线以下(或者以上)的数据元素(不包括对角线)全部为常数c<ul>
<li>[存储方法] 重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间。</li>
</ul>
</li>
<li>对角矩阵(带状矩阵)：在$n \times n$的方阵中，所有非零元素都集中在以主对角线为中心的带状区域中，区域外的值全为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等<ul>
<li>[存储方法] 如下图所示，但是这种方法只有当次对角线数量小于某一值时才可行。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/668b43bed9c307b7e923271d.png"></p>
<ul>
<li>稀疏矩阵：一般认为矩阵中非零元素占总元素的5%以下时是稀疏的。<ul>
<li>[存储方法1] <strong>三元组</strong>法 —— 存各非零元的值和非零元的行列位置。为更可靠描述，通常再加一个“总体”信息：即总行数、总列数、非零元素总个数。</li>
<li>[存储方法2] <strong>十字链表</strong>法 —— 在十字链表中，矩阵的每一个非零元素用一个结点表示该结点除了(row，col，value)以外，还要有两个域：<ul>
<li>right：用于链接同一行中的下一个非零元素；</li>
<li>down：用以链接同一列中的下一个非零元素。</li>
<li><img src="https://pic.imgdb.cn/item/668b475ad9c307b7e927994d.png" alt="十字链表法存储结构示意图" style="zoom:60%"></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/668b485ad9c307b7e929e78b.png" alt="注：图中中文行列指针标反了" style="zoom:60%"></p>
<p><strong>(3) 基本操作</strong></p>
<p><code>InitArray(&amp;A, n, bound1, ..., bound n)</code>：构造数组A；</p>
<p><code>DestroyArray(&amp;A)</code>：销毁数组A；</p>
<p><code>Value(A, &amp;e, index1, ..., index n)</code>：取数组元素值；</p>
<p><code>Assign (A, &amp;e, index1, ..., index n)</code>：给数组元素赋值。</p>
<h4 id="4-5-广义表"><a href="#4-5-广义表" class="headerlink" title="4.5 广义表"></a>4.5 广义表</h4><h5 id="Ⅰ-广义表的概念"><a href="#Ⅰ-广义表的概念" class="headerlink" title="Ⅰ 广义表的概念"></a>Ⅰ 广义表的概念</h5><p>广义表(又称列表 Lists)是 $n\geq 0$个元素 $a_0, a_1, … , a_{n-1}$ 的有限序列，其中每一个 $a_i$ 或者是原子，或者是一个广义表。</p>
<p>广义表通常记作：$LS = (a_1, a_2, \cdots, a_n)$，其中，$LS$为表名，$n$为长度，每一个$a_i$为表的元素。</p>
<p><strong>表头</strong>：若广义表$LS$非空，则其第一个元素$a_1$就是表头，记作：$\text{head}(LS) = a_1$，表头既可以是原子也可以是子表。</p>
<p><strong>表尾</strong>：除表头之外的其它元素组成的子表，记作：$\text{tail}(LS) = (a_2, \cdots,  a_n)$，注：表尾不是最后一个元素，而是一个子表；此外，若$LS$中只有一个元素，则只有表头，表尾是一个空的子表。</p>
<ul>
<li><p><strong>广义表的特性</strong>：</p>
<ul>
<li>① 广义表中的数据元素有相对次序；一个直接前驱和一个直接后继。</li>
<li>② 广义表的长度定义为最外层所包含元素的个数；</li>
<li>③ 广义表的深度定义为该广义表展开后所含括号的重数；</li>
<li>④ 广义表可以为其他广义表共享；如：广义表B就共享表A。在B中不必列出A的值，而是通过名称来引用：<code>B=(A)</code>。</li>
<li>⑤ 广义表可以是一个递归的表。如：<code>F=(a, F) = (a,(a,(a, ... )))</code>。注意：递归表的深度是无穷值，长度是有限值。</li>
<li>⑥ 广义表是多层次结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/668b562cd9c307b7e93cc9f3.png" style="zoom:60%"></p>
</li>
<li><p><strong>广义表的基本操作</strong></p>
<ul>
<li><code>GetHead(L)</code>：求表头。非空广义表的第一个元素，可以是一个原子，也可以是一个子表。</li>
<li><code>GetTail(L)</code>：求表尾。非空广义表除去表头元素以外其它元素所构成的表。表尾一定是一个子表。</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-广义表-VS-线性表"><a href="#Ⅱ-广义表-VS-线性表" class="headerlink" title="Ⅱ 广义表 VS 线性表"></a>Ⅱ 广义表 VS 线性表</h5><p>  广义表可以看成是线性表的<strong>推广</strong>，线性表是广义表的<strong>特例</strong>。</p>
<p>  广义表的结构相当灵活，在某种前提下，它可以兼容<strong>线性表</strong>、<strong>数组</strong>、<strong><font color="green">树和有向图</font></strong>等各种常用的数据结构。</p>
<p>  —— 当二维数组的每行(或每列)作为子表处理时，二维数组即为一个广义表。</p>
<p>  —— 另外，树和有向图也可以用广义表来表示。</p>
<p>由于广义表不仅集中了线性表、数组、树和有向图等常见数据结构的特点，而且可有效地利用存储空间，因此在计算机的许多应用领域都有成功使用广义表的实例。</p>
<h3 id="sect-5-树、二叉树"><a href="#sect-5-树、二叉树" class="headerlink" title="&sect; 5 树、二叉树"></a>&sect; 5 树、二叉树</h3><p><img src="https://pic.imgdb.cn/item/668b6590d9c307b7e95136c3.png"></p>
<h4 id="5-1-树形结构"><a href="#5-1-树形结构" class="headerlink" title="5.1 树形结构"></a>5.1 树形结构</h4><h5 id="Ⅰ-树的概念"><a href="#Ⅰ-树的概念" class="headerlink" title="Ⅰ 树的概念"></a>Ⅰ 树的概念</h5><p><strong>(1) 树的定义</strong></p>
<p><strong>树(Tree)</strong> 是 $n(n≥0)$ 个结点的有限集：</p>
<ul>
<li>若$n=0$，称为空树；</li>
<li>若$n&gt;0$，则它满足如下两个条件：<br>① 有且仅有一个特定的称为<strong>根 (Root)</strong>的结点；<br>② 其余结点可分为 $m(m≥0)$ 个互不相交的有限集T1,T2,T3,…,Tm，其中每一个集合本身又是一棵树，并称为根的<strong>子树(SubTree)</strong>。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/668b66d5d9c307b7e9534b33.png" style="zoom:70%"></p>
<p>显然，树的定义是一个<strong>&lt;/font color=red&gt;递归&lt;/font&gt;</strong>的定义。</p>
<p><strong>(2) 树的表示形式</strong></p>
<p><img src="https://pic.imgdb.cn/item/668b67ced9c307b7e954e53c.png" style="zoom:50%"></p>
<p><strong>(3) 树的相关术语</strong></p>
<p><img src="https://pic.imgdb.cn/item/668b6ae1d9c307b7e95a4be3.png"></p>
<p>有序树：树中结点的各子树从左至右有次序(最左边的为第一个孩子)，换了顺序就是另一棵树了。</p>
<p>无序树：树中结点的各子树无次序。</p>
<p>森林：是 $m(m≥0)$ 棵互不相交的树的集合。把根结点删除树就变成了森林。一棵树可以看成是一个特殊的森林。给森林中的各子树加上一个双亲结点，森林就变成了树。树一定是森林，但森林不一定是树。</p>
<h5 id="Ⅱ-二叉树"><a href="#Ⅱ-二叉树" class="headerlink" title="Ⅱ 二叉树"></a>Ⅱ 二叉树</h5><p>普通树(多又树)若不转化为二又树，则分支太多且不固定，运算很难实现。</p>
<ul>
<li>为何要重点研究每结点最多只有两个“叉”的树？<ul>
<li>二叉树的结构最简单，规律性最强；</li>
<li>可以证明，所有树都能转为唯一对应的二叉树不失一般性。</li>
</ul>
</li>
</ul>
<p><strong>(1) 二叉树的定义</strong></p>
<p>二叉树是 $n(n≥0)$ 个结点的有限集，它或者是空集($n= 0$)，或者由一个根结点及两棵互不相交的分别称作这个根的<strong>左子树</strong>和<strong>右子树</strong>的二叉树组成。</p>
<p><strong>特点1：</strong>每个结点最多有俩孩子(二叉树中不存在度大于 2 的结点)。<br><strong>特点2：</strong>子树有左右之分，其次序不能颠倒。<br><strong>特点3：</strong>二叉树可以是空集合，根可以有空的左子树或空的右子树。</p>
<blockquote>
<p>注意：二叉树不是树的特殊情况，它们是两个概念。</p>
<p>二叉树结点的子树<strong>必须区分</strong>左子树和右子树，即使只有一棵子树也进行区分，说明它是左子树，还是右子树。</p>
<p>树当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二又树与树的最主要的差别。</p>
<p><img src="https://pic.imgdb.cn/item/668b9788d9c307b7e9a84e03.png" style="zoom:50%"></p>
<p>简单来说：也就是二叉树每个结点位置或者说次序都是固定的，可以是空，但是不可以说它没有位置，而树的结点位置是相对于别的结点来说的，没有别的结点时，它就无所谓左右了)。</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/668b983dd9c307b7e9aa4d70.png" alt="二叉树的5种形态" style="zoom:40%"></p>
<p><strong>二叉树有且只有这五种基本形态</strong>。</p>
<h5 id="Ⅲ-案例引入"><a href="#Ⅲ-案例引入" class="headerlink" title="Ⅲ 案例引入"></a>Ⅲ 案例引入</h5><p><strong>(1) 数据压缩问题</strong></p>
<p>将数据文件转换成由0、1组成的二进制串，称之为<strong>编码</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/668b9a26d9c307b7e9ad48a9.png"></p>
<p><strong>(2) 利用二又树求解表达式的值</strong></p>
<p>以二叉树表示表达式的递归定义如下：</p>
<p>(1) 若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息；</p>
<p>(2) 若表达式为<code>第一操作数 运算符 第二操作数</code>的形式，则相应的二cha树中以左子树表示第一操作数右子树表示第二操作数，根结点的数据域存放运算符(若为一元运算符，则左子树为空)，其中，操作数本身又为表达式。</p>
<p><img src="https://pic.imgdb.cn/item/668b9adad9c307b7e9ae76a9.png"></p>
<h5 id="Ⅳ-树、二叉树的表示"><a href="#Ⅳ-树、二叉树的表示" class="headerlink" title="Ⅳ 树、二叉树的表示"></a>Ⅳ 树、二叉树的表示</h5><p><strong>(1) 二叉树的抽象数据类型定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADT BinaryTree</span><br><span class="line">&#123;</span><br><span class="line">    数据对象D: D是具有相同特性的数据元素的集合。</span><br><span class="line">    数据关系R: 若D=Φ，则R=Φ;</span><br><span class="line">    		  若D≠Ф，则R=&#123;H&#125;; H是如下二元关系：</span><br><span class="line">                  ① root 唯一    <span class="comment">//关于根的说明</span></span><br><span class="line">                  ② Dj ∩ Dk = Ф  <span class="comment">//关于子树不相交的说明</span></span><br><span class="line">                  ③ ...          <span class="comment">//关于数据元素的说明</span></span><br><span class="line">                  ④ ...          <span class="comment">//关于左子树和右子树的说明</span></span><br><span class="line"></span><br><span class="line">	基本操作 P:</span><br><span class="line">	<span class="comment">// 初始条件: definition给出二叉树T的定义。</span></span><br><span class="line">	<span class="comment">// 操作结果: 按definition构造二叉树T。</span></span><br><span class="line">	<span class="built_in">CreateBiTree</span>(&amp;T, definition);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始条件: 二叉树T存在。</span></span><br><span class="line">	<span class="comment">// 操作结果: 先序遍历T，对每个结点访问一次。</span></span><br><span class="line">	<span class="built_in">PreOrderTraverse</span>(T);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始条件: 二叉树T存在。</span></span><br><span class="line">	<span class="comment">// 操作结果: 中序遍历T，对每个结点访问一次。</span></span><br><span class="line">	<span class="built_in">InOrderTraverse</span>(T);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始条件: 二叉树T存在。</span></span><br><span class="line">	<span class="comment">// 操作结果: 后序遍历T，对每个结点访问一次。</span></span><br><span class="line">	<span class="built_in">PostOrderTraverse</span>(T);</span><br><span class="line"></span><br><span class="line">&#125;ADT BinaryTree</span><br></pre></td></tr></table></figure>
<p><strong>(2) 二叉树的性质与存储结构</strong></p>
<p><strong>满二叉树</strong>：一棵深度为 $k$且有$2^k-1$个结点的二叉树称为满二叉树。也就是说每一层上的结点数都是最大结点数(即每层都满)；叶子节点全部在最底层。</p>
<p>对满二叉树结点位置进行编号编号规则：从根结点开始，自上而下，自左而右。每一结点位置都有元素。如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/668c91a0d9c307b7e90bb2f7.png" alt="满二叉树" style="zoom:50%"></p>
<p><strong>完全二叉树</strong>：深度为$k$的具有$n$个结点的二叉树，当且仅当其每一 个结点都与深度为$k$的满二叉树中编号为$1 \sim n$的结点一一对应时，称之为完全二叉树。如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/668c9308d9c307b7e90d2eda.png"></p>
<p>完全二叉树的特点：1.叶子只可能分布在层次最大的两层上。2.对任一结点，如果其右子树的最大层次为$i$，则其左子树的最大层次必为$i$或$i+1$。</p>
<ul>
<li><p><strong>性质</strong></p>
<ul>
<li>① 在二叉树的第$i$层上至多有$2^{i-1}$个结点。</li>
<li>② 深度为$k$的二叉树至多有$2^k-1$个结点。</li>
<li>③ 对任何一棵二叉树T，如果其叶子数为$n_0$，度为$2$的结点数为$n_2$，则$n_0 = n_2+1$。</li>
<li>④ 具有$n$个结点的完全二叉树的深度为$\lfloor \log_2 n \rfloor +1$。</li>
<li>⑤  如果对一棵有$n$个结点的完全二叉树按层序编号(从第1层到第$\lfloor \log_2 n \rfloor +1$层，每层从左到右)，则对任结点$i(1≤i≤n)$，有:<ul>
<li>如果$i=1$，则结点$i$是二叉树的根，无双亲；如果$i&gt;1$，则其双亲是结点 $\lfloor i/2 \rfloor$。</li>
<li>如果$2i&gt;n$，则结点$i$为叶子结点，无左孩子；否则其左孩子是结点$2i$。</li>
<li>如果$2i+1&gt;n$，则结点$i$无右孩子；否则，其右孩子是结点$2i + 1$。</li>
</ul>
</li>
</ul>
</li>
<li><strong>树、二叉树的顺序存储结构</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/668c9f54d9c307b7e9217a8a.png" alt="二叉树的存储方式" style="zoom:60%"></p>
<p>按满二叉树的结点层次编号，依次存放二叉树中的数据元素。</p>
<p><img src="https://pic.imgdb.cn/item/668c9fe2d9c307b7e922b1c5.png" style="zoom:50%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树顺序存储表示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXTSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAXSTIZE];</span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure>
<p>当不是满二叉树、完全二叉树的时候：不满的地方用0值填充。</p>
<p><img src="https://pic.imgdb.cn/item/668ca1c1d9c307b7e925a51d.png" style="zoom:40%"></p>
<p>由此看来，二叉树的顺序存储结构的存储密度会很低，一般只适用于满二叉树和完全二叉树。</p>
<ul>
<li><strong>树、二叉树的链式存储结构</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/668ca3a5d9c307b7e928c600.png" style="zoom:70%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Binode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Binode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>	<span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125;BiNode,*BiTree;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/668ca4cfd9c307b7e92b41b4.png" style="zoom:40%"></p>
<p><strong><font color="red">二叉树的三叉链表存储</font>：</strong></p>
<p><img src="https://pic.imgdb.cn/item/668ca667d9c307b7e92dd96c.png" style="zoom:40%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TelemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TriTNode</span> *<span class="title">lchild</span>,*<span class="title">parent</span>,*<span class="title">rchild</span>;</span>	<span class="comment">// 左右孩子指针+双亲指针</span></span><br><span class="line">&#125;TriTNode, *TriTree;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-遍历二叉树"><a href="#5-2-遍历二叉树" class="headerlink" title="5.2 遍历二叉树"></a>5.2 遍历二叉树</h4><h5 id="Ⅰ-遍历的概念"><a href="#Ⅰ-遍历的概念" class="headerlink" title="Ⅰ 遍历的概念"></a>Ⅰ 遍历的概念</h5><p>遍历定义 —— 顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次(又称周游)。</p>
<p>“访问”的含义很广，可以是对结点作各种处理，如：输出结点的信息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构。</p>
<p>遍历目的 —— 得到树中所有结点的一个线性排列。</p>
<p>遍历用途 —— 它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。</p>
<h5 id="Ⅱ-遍历二叉树算法描述"><a href="#Ⅱ-遍历二叉树算法描述" class="headerlink" title="Ⅱ 遍历二叉树算法描述"></a>Ⅱ 遍历二叉树算法描述</h5><p>假设：L遍历左子树，D访问根结点，R遍历右子树则遍历整个二叉树方案共有6种，分别是：</p>
<script type="math/tex; mode=display">
DLR、LDR、LRD、DRL、RDL、RLD</script><p>其中，主要看前三种：先(根)序遍历DLR、中(根)序遍历LDR、后(根)序遍历LRD。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>先序遍历二叉树</th>
<th>中序遍历二叉树</th>
<th>后序遍历二叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td>若二叉树为空，则空操作；<br>否则<br>(1) 访问根结点；<br>(2) 先序遍历左子树；<br>(3) 先序遍历右子树。</td>
<td>若二叉树为空，则空操作；<br>否则<br>(1) 中序遍历左子树；<br>(2) 访问根结点；<br>(3) 中序遍历右子树。</td>
<td>若二叉树为空，则空操作；<br>否则<br>(1) 后序遍历左子树；<br>(2) 后序遍历右子树；<br>(3) 访问根结点。</td>
</tr>
</tbody>
</table>
</div>
<p>由二叉树的递归定义可知，遍历左子树和遍历右子树可如同遍历二又树一样“<strong>递归</strong>”进行。</p>
<p><img src="https://pic.imgdb.cn/item/668caee4d9c307b7e93f10f8.png" style="zoom:60%"></p>
<ul>
<li><p><strong>根据遍历序列确定二叉树</strong></p>
<ul>
<li>若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序列都是唯一的。</li>
<li>由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树。==只知道某一种序是不能唯一确定一棵二叉树的==。</li>
</ul>
</li>
</ul>
<h5 id="Ⅲ-先序遍历二叉树-递归方法"><a href="#Ⅲ-先序遍历二叉树-递归方法" class="headerlink" title="Ⅲ 先序遍历二叉树(递归方法)"></a>Ⅲ 先序遍历二叉树(递归方法)</h5><p><img src="https://pic.imgdb.cn/item/668cdf88d9c307b7e9b161e5.png" style="zoom:30%"></p>
<p>明显，利用<strong><font color="blue">递归</font></strong>的算法进行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先(根)序遍历</span></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span>	<span class="comment">// 指针T指向二叉树的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> OK; <span class="comment">// 空二叉树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T); <span class="comment">// 访问根结点，根据实际需要进行操作</span></span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);	<span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);	<span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打印输出当前节点数据</span></span><br><span class="line">    cout &lt;&lt; T-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/668ce2ead9c307b7e9bb4824.png" style="zoom:40%"></p>
<h5 id="Ⅳ-中序、后序遍历二叉树-递归方法"><a href="#Ⅳ-中序、后序遍历二叉树-递归方法" class="headerlink" title="Ⅳ 中序、后序遍历二叉树(递归方法)"></a>Ⅳ 中序、后序遍历二叉树(递归方法)</h5><p><img src="https://pic.imgdb.cn/item/668ce3abd9c307b7e9bce9a6.png" alt="中序遍历" style="zoom:60%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中(根)序遍历</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span>	<span class="comment">// 指针T指向二叉树的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> OK; <span class="comment">// 空二叉树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;lchild);	<span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);	<span class="comment">// 访问根结点</span></span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);	<span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后(根)序遍历</span></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> OK;	<span class="comment">// 空二叉树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;lchild);	<span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PostOrderTraverse</span>(T-&gt;rchild);	<span class="comment">// 递归遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);	<span class="comment">// 访问根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅴ-中序遍历二叉树-非递归方法"><a href="#Ⅴ-中序遍历二叉树-非递归方法" class="headerlink" title="Ⅴ 中序遍历二叉树(非递归方法)"></a>Ⅴ 中序遍历二叉树(非递归方法)</h5><p>二叉树中序遍历的非递归算法的关键：在中序遍历过某结点的整个左子树后，如何找到该结点的根以及右子树。</p>
<ul>
<li><strong>基本思想</strong><ul>
<li>① 建立一个栈；</li>
<li>② 根结点进栈，遍历左子树；</li>
<li>③ 根结点出栈，输出根结点，遍历右子树。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历非递归算法</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span> <span class="params">(BiTree T)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree p; </span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    p=T;</span><br><span class="line">    <span class="keyword">while</span>(p || !<span class="built_in">StackEmpty</span>(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Push</span>(S,p);	<span class="comment">// 入栈</span></span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="built_in">Pop</span>(s,q);	<span class="comment">// 弹出栈顶元素，用q接收</span></span><br><span class="line">            cout &lt;&lt; q-&gt;data &lt;&lt; endl;</span><br><span class="line">            p=q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;<span class="comment">//while</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅵ-二叉树的层次遍历"><a href="#Ⅵ-二叉树的层次遍历" class="headerlink" title="Ⅵ 二叉树的层次遍历"></a>Ⅵ 二叉树的层次遍历</h5><p>对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每一个结点仅仅访问一次。</p>
<ul>
<li>算法设计思路：使用一个<strong>队列</strong>。<ul>
<li>① 将根结点进队；</li>
<li>② 队不空时循环：从队列中出列一个结点*p，访问它;<ul>
<li>若它有左孩子结点，将左孩子结点进队；</li>
<li>若它有右孩子结点，将右孩子结点进队。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用循环顺序队列，其数据类型定义为</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BTNode data[MaxSize];	<span class="comment">// 存放队中元素</span></span><br><span class="line">    <span class="keyword">int</span> front;	<span class="comment">// 队头“指针”</span></span><br><span class="line">    <span class="keyword">int</span> rear;	<span class="comment">// 队尾“指针”</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树层次遍历算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BTNode *b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *p;</span><br><span class="line">    SqQueue *qu;	</span><br><span class="line">    <span class="built_in">InitQueue</span>(qu);	<span class="comment">// 初始化队列</span></span><br><span class="line">    <span class="built_in">enQueue</span>(qu,b);	<span class="comment">// 根结点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">QueueEmpty</span>(qu))	<span class="comment">// 队不为空，则循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">deQueue</span>(qu, p);	<span class="comment">// 出队结点，用指针p接收</span></span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; endl;	<span class="comment">// 访问结点p</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild!=<span class="literal">NULL</span>) </span><br><span class="line">            <span class="built_in">enQueue</span>(qu, p-&gt;lchild);	<span class="comment">// 有左孩子时将其进队</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild!=<span class="literal">NULL</span>) </span><br><span class="line">            <span class="built_in">enQueue</span>(qu, p-&gt;rchild);	<span class="comment">// 有右孩子时将其进队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅶ-遍历二叉树算法的应用"><a href="#Ⅶ-遍历二叉树算法的应用" class="headerlink" title="Ⅶ 遍历二叉树算法的应用"></a>Ⅶ 遍历二叉树算法的应用</h5><p><strong>(1) 构建一颗二叉树</strong></p>
<p>按先序遍历序列建立二叉树的二叉链表。</p>
<p>例：已知先序序列为：ABCDEGF</p>
<p>① 从键盘输入二叉树的结点信息，建立二叉树的存储结构；<br>② 在建立二叉树的过程中按照二叉树先序方式建立。</p>
<p>注意，只知道先序序列是无法得到唯一的一个二叉树的，那怎么办呢，一种方法是<strong><font color="red">补充空结点</font></strong>，如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/668e405cd9c307b7e97efd9c.png" style="zoom:50%"></p>
<p>根据补充的空结点的位置不一样，所得的树就不一样，这样就可确定一颗二叉树了。可以用一个特殊的字符表示空节点(例如：#)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归算法</span></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree&amp; T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T= <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !(T=<span class="keyword">new</span> BiTNode) )</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW); </span><br><span class="line">        T-&gt;data = ch;	<span class="comment">// 生成根结点</span></span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;lchild);	<span class="comment">// 构造左子树</span></span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;rchild);	<span class="comment">// 构造右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125; <span class="comment">// CreateBiTree</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 复制一颗二叉树</strong></p>
<ul>
<li>① 如果是空树，递归结束；</li>
<li>② 否则，申请新结点空间，复制根结点<ul>
<li>递归复制左子树</li>
<li>递归复制右子树</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Copy</span><span class="params">(BiTree T, BiTree&amp; NewT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="comment">//如果是空树返回0</span></span><br><span class="line">        NewT = <span class="literal">NULL</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        NewT = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        NewT-&gt;data=T-&gt;data;</span><br><span class="line">        <span class="comment">// 递归复制</span></span><br><span class="line">        <span class="built_in">Copy</span>(T-&gt;lChild, NewT-&gt;lchild);</span><br><span class="line">        <span class="built_in">Copy</span>(T-&gt;rChild, NewT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(3) 计算二叉树的深度</strong></p>
<ul>
<li>① 如果是空树，则深度为0</li>
<li>② 否则，递归计算左子树的深度记为$m$，递归计算右子树的深度记为$n$<ul>
<li>二叉树的深度计算方法为：$\max(m, n) + 1$。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">( BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 如果是空树返回0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m = <span class="built_in">Depth</span>(T-&gt;lChild);</span><br><span class="line">        n = <span class="built_in">Depth</span>(T-&gt;rChild);</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)</span><br><span class="line">            <span class="keyword">return</span> (m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span>(n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(4) 计算结点总数</strong></p>
<ul>
<li>① 如果是空树，则结点个数为0；</li>
<li>② 否则，结点个数为左子树的结点个数+右子树的结点个数再+1。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NodeCount</span>(T-&gt;lchile) + <span class="built_in">NodeCount</span>(T-&gt;rchile)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(5) 计算二叉树叶子结点数(补充)</strong></p>
<ul>
<li>① 如果是空树，则叶子结点个数为0；</li>
<li>② 否则，为左子树的叶子结点个数+右子树的叶子结点个数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)	<span class="comment">// 如果是空树返回0</span></span><br><span class="line">        <span class="keyword">return</span> O;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">// 如果是叶子结点返回1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LeafCount</span>(T-&gt;lchild)+<span class="built_in">LeafCount</span>(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-线索二叉树"><a href="#5-3-线索二叉树" class="headerlink" title="5.3 线索二叉树"></a>5.3 线索二叉树</h4><h5 id="Ⅰ-线索二叉树概念"><a href="#Ⅰ-线索二叉树概念" class="headerlink" title="Ⅰ 线索二叉树概念"></a>Ⅰ 线索二叉树概念</h5><p>当用二叉链表作为二叉树的存储结构时可以很方便地找到某个结点的左右孩子；但一般情况下，无法直接找到该结点在某种遍历序列中的前驱和后继结点。</p>
<ul>
<li><p><strong>提出的问题</strong>：如何寻找特定遍历序列中二叉树结点的前驱和后继？？？</p>
</li>
<li><p><strong>解决的方法</strong></p>
<ul>
<li><p>方法1：通过遍历寻找——费时间；</p>
</li>
<li><p>方法2：再增设前驱、后继指针域——增加了存储负担；</p>
</li>
<li><p>方法3：利用二叉链表中的<strong>空指针域</strong>。</p>
<blockquote>
<p>回顾：二叉树链表中空指针域的数量：</p>
<p>具有$n$个结点的二叉链表中，一共有$2n$个指针域；因为$n$个结点中有$n-1$个孩子，即$2n$个指针域中，有$n-1$个用来指示结点的左右孩子，其余$n+1$个指针域为空！</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>利用二叉链表中的空指针域</strong>：如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱，如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继。——这种改变指向的指针称为“<strong><font color="green">线索</font></strong>”。</p>
<p>加上了线索的二叉树称为<strong>线索二叉树(Threaded Binary Tree)</strong>，对二叉树按某种遍历次序使其变为线索二叉树的过程叫<strong>线索化</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/668e5e74d9c307b7e9a6d153.png" style="zoom:30%"></p>
<p>为区分<code>lchild</code>和<code>rchild</code>指针到底是指向孩子的指针，还是指问前趋或有后继的指针，对二叉链表中每个结点增设两个标志域<code>ltag</code> 和 <code>rtag</code> ，并约定：<br>—— <code>ltag=0</code>， <code>lchild</code> 指向该结点的左孩子；<br>—— <code>ltag =1</code>，<code>lchild</code> 指向该结点的前驱；<br>—— <code>rtag=0</code>，<code>rchild</code> 指向该结点的右孩子；<br>—— <code>rtag =1</code>，<code>rchild</code> 指向该结点的后继。</p>
<p>这样，线索二叉树中的结点构成如下：</p>
<p><img src="https://pic.imgdb.cn/item/668e5fb1d9c307b7e9a84ed9.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">typdef <span class="class"><span class="keyword">struct</span> <span class="title">BiThrnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">bool</span> ltag;</span><br><span class="line">    <span class="keyword">bool</span> rtag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrnode</span>* <span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrnode</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-先序线索二叉树"><a href="#Ⅱ-先序线索二叉树" class="headerlink" title="Ⅱ 先序线索二叉树"></a>Ⅱ 先序线索二叉树</h5><p><img src="https://pic.imgdb.cn/item/668e62ded9c307b7e9ac33a2.png" alt="image.png"></p>
<h4 id="5-4-树和森林"><a href="#5-4-树和森林" class="headerlink" title="5.4 树和森林"></a>5.4 树和森林</h4><p><img src="https://pic.imgdb.cn/item/668f326fd9c307b7e97facad.png" style="zoom:40%"></p>
<p>注意，树是不分左右顺序的。</p>
<h5 id="Ⅰ-树的存储结构"><a href="#Ⅰ-树的存储结构" class="headerlink" title="Ⅰ 树的存储结构"></a>Ⅰ 树的存储结构</h5><p><strong>(1) 双亲表示法</strong></p>
<p>实现：定义结构数组，存放树的结点，每个结点含两个域：① 数据域：存放结点本身信息。② 双亲域：指示本结点的双亲结点在数组中的位置。如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/668f3537d9c307b7e9824f86.png" style="zoom:60%"></p>
<p>这种方法有比较明显的优缺点：<strong>优点：</strong>找双亲容易；<strong>缺点：</strong>找孩子麻烦。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树的单个结点的数据存储类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 树的数据存储类型定义</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> r;	<span class="comment">// 根节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> n;	<span class="comment">// 节点个数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<p><strong>(2) 孩子链表</strong></p>
<p>把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储，则$n$个结点有$n$个孩子链表(叶子的孩子链表为空表)。而 $n$ 个头指针又组成一个线性表，用顺序表(含$n$个元素的结构数组)存储。</p>
<p><img src="https://pic.imgdb.cn/item/668f38fed9c307b7e9861ed5.png" style="zoom:60%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 孩子结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;* ChildePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双亲结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildePtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=====================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 树的数据存储类型定义</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> r;	<span class="comment">// 根节点的位置</span></span><br><span class="line">    <span class="keyword">int</span> n;	<span class="comment">// 结点个数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种方法有比较明显的优缺点：<strong>优点：</strong>找孩子容易；<strong>缺点：</strong>找双亲麻烦。</p>
<p><strong>(3) 带双亲的孩子链表</strong></p>
<p>结合上述2种方法的优点。</p>
<p><img src="https://pic.imgdb.cn/item/668f3aedd9c307b7e988151e.png" alt="带双亲的孩子链表" style="zoom:50%"></p>
<p><strong><font color="blue">(4) 孩子兄弟表示法 / 二叉树表示法 / 二叉链表表示法</font></strong> （常用）</p>
<p>实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其<strong>第一个孩子结点</strong>和<strong>下一个兄弟结点</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Csnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSnode</span>* <span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/668f3ccfd9c307b7e98a3839.png" style="zoom:40%"></p>
<h5 id="Ⅱ-树与二叉树的转换"><a href="#Ⅱ-树与二叉树的转换" class="headerlink" title="Ⅱ 树与二叉树的转换"></a>Ⅱ 树与二叉树的转换</h5><p>将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作。</p>
<p>由于树和二叉树都可以用<strong>二叉链表</strong>作存储结构，则以二叉链表作媒介可以导出树与二叉树之间的一个对应关系。</p>
<p><img src="https://pic.imgdb.cn/item/668f40f1d9c307b7e98eec51.png" style="zoom:40%"></p>
<p>给定一棵树，可以找到唯一的一棵二叉树与之对应。</p>
<ul>
<li><p><strong>树转换为二叉树</strong>：容易发现规律，右兄弟转换为右孩子，具体步骤如下：</p>
<ul>
<li>① 加线：在兄弟之间加一连线</li>
<li>② 抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系；</li>
<li>③ 旋转：以树的根结点为轴心，将整树顺时针转45°。</li>
</ul>
</li>
<li><p><strong>二叉树转换为树</strong>：</p>
<ul>
<li>① 加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子….沿分支找到的所有右孩子，都与p的双亲用线连起来；</li>
<li>② 抹线：抹掉原二叉树中双亲与右孩子之间的连线；</li>
<li>③ 调整：将结点按层次排列，形成树结构。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/668f44fcd9c307b7e9933df3.png"></p>
<h5 id="Ⅲ-森林与二叉树的转换"><a href="#Ⅲ-森林与二叉树的转换" class="headerlink" title="Ⅲ 森林与二叉树的转换"></a>Ⅲ 森林与二叉树的转换</h5><ul>
<li>森林转换成二叉树(二叉树与多棵树之间的关系)<ul>
<li>① 将各棵树分别转换成二叉树；</li>
<li>② 将每棵树的根结点用线相连；</li>
<li>③ 以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转构成二叉树型结构。</li>
<li>二叉树转换成森林</li>
</ul>
</li>
<li>① 抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树；</li>
<li>② 还原：将孤立的二叉树还原成树</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/668f472ad9c307b7e99595bc.png"></p>
<h5 id="Ⅳ-树和森林的遍历"><a href="#Ⅳ-树和森林的遍历" class="headerlink" title="Ⅳ 树和森林的遍历"></a>Ⅳ 树和森林的遍历</h5><p><strong>(1) 树的遍历</strong>(三种方法)</p>
<ul>
<li><strong>先(根)序遍历</strong>：若树不空，则先访问根结点，然后依次先根遍历各棵子树。</li>
<li><strong>后(根)序遍历</strong>：若树不空，则先依次后根遍历各棵子树，然后访问根结点。</li>
<li><strong>按层次遍历</strong>：若树不空，则自上而下自左至右访问树中每个结点。</li>
</ul>
<p><strong>(2) 森林的遍历</strong></p>
<p>为了遍历森林，我们以下面这种视角重新审视森林的结构：</p>
<p>将森林看作由三部分构成：<code>Part 1</code>：森林中第一棵树的根结点；<code>Part 2</code>：森林中第一棵树的子树森林；<code>Part 3</code>：森林中其它树构成的森林。</p>
<ul>
<li><strong>先序遍历</strong>：若森林不空，则<ul>
<li>① 访问森林中第一棵树的根结点；</li>
<li>② 先序遍历森林中第一棵树的子树森林；</li>
<li>③ 先序遍历森林中(除第一棵树之外)其余树构成的森林。</li>
<li>本质：依次从左至右对森林中的每一棵树进行<strong>先(根)序遍历</strong>。</li>
</ul>
</li>
<li><strong>中序遍历</strong>：若森林不空，则<ul>
<li>① 中序遍历森林中第一棵树的子树森林；</li>
<li>② 访问森林中第一棵树的根结点；</li>
<li>③ 中序遍历森林中(除第一棵树之外)其余树构成的森林。</li>
<li>本质：依次从左至右对森林中的每一棵树进行<strong>后(根)序遍历</strong>。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/668f4ac1d9c307b7e99989ad.png" style="zoom:70%"></p>
<h4 id="5-5-哈夫曼树-最优二叉树"><a href="#5-5-哈夫曼树-最优二叉树" class="headerlink" title="5.5 哈夫曼树(最优二叉树)"></a>5.5 哈夫曼树(最优二叉树)</h4><h5 id="Ⅰ-哈夫曼树的概念"><a href="#Ⅰ-哈夫曼树的概念" class="headerlink" title="Ⅰ 哈夫曼树的概念"></a>Ⅰ 哈夫曼树的概念</h5><p>首先来看个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//【例】编程:将学生的百分制成绩转换为五分制成绩</span></span><br><span class="line"><span class="comment">// &lt;60:E  60-69:D  70-79:C  80-89:B  90-100:A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(score&lt;<span class="number">60</span>)</span><br><span class="line">    grade == <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score&lt;<span class="number">70</span>)</span><br><span class="line">    grade ==`<span class="string">&#x27;D&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score&lt;<span class="number">80</span>)</span><br><span class="line">    grade ==<span class="string">&#x27;C&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(score&lt;<span class="number">90</span>)</span><br><span class="line">    grade ==`<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    grade ==<span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/668f4dc4d9c307b7e99cc2a9.png" alt="判断二叉树" style="zoom:50%"></p>
<p>判断树：用于描述分类过程的二叉树。</p>
<p>如果每次的输入量很大，则应考虑程序的操作时间。</p>
<p>若学生的成绩数据共10000个：E、D、C、B、A分别占总数据的5%、15%、40%、30%、10%。则5%的数据需1次比较，15%的数据需2次比较，40%的数据需3次比较，40%的数据需4次比较，因此10000个数据比较的次数为：</p>
<script type="math/tex; mode=display">
10000×(1×5\%+2×15\%+3×40\%+4×10\%)=31500次</script><p>考虑如何减少一些数据量：</p>
<p><img src="https://pic.imgdb.cn/item/668f4ffbd9c307b7e99f1534.png"></p>
<p><strong>(1) 相关概念</strong></p>
<p><strong>路径</strong>：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径。</p>
<p><strong>结点的路径长度</strong>：两结点间路径上的分支数。</p>
<p><img src="https://pic.imgdb.cn/item/668f800cd9c307b7e9db738f.png" style="zoom:40%"></p>
<p><strong>树的路径长度</strong>：从树根到每一个结点的路径长度之和，记作：TL。</p>
<script type="math/tex; mode=display">
树(a)的路径长度：TL(a) = 0+1+1+2+2+3+3+4+4=20 \\
树(b)的路径长度：TL(b) = 0+1+1+2+2+2+2+3+3=16</script><p><strong><font color="#FFA500">一个小结论：结点数目相同的二叉树中，完全二叉树是路径长度最短的 <u>一种(不唯一)</u>  二叉树。</font></strong> </p>
<p><strong>权重(weight)</strong>：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。</p>
<p><strong>结点的带权路径长度</strong>：从根结点到该结点之间的路径长度与该结点的权的乘积。</p>
<p><strong>树的带权路径长度</strong>：树中所有叶子结点的带权路径长度之和，记作WPL。</p>
<script type="math/tex; mode=display">
WPL = \sum_{k=1}^n w_k l_k</script><p><img src="https://pic.imgdb.cn/item/668f8490d9c307b7e9e2f06f.png" style="zoom:70%"></p>
<p><strong><font color="red">哈夫曼树</font></strong>：带权路径长度(WPL)最短的树。</p>
<blockquote>
<p>注意：</p>
<p>“带权路径长度最短”是在“<strong>度相同</strong>”的树中比较而得的结果，因此有最优二叉树、最优三又树之称等等。</p>
<p>结点的度：是结点拥有子树的的个数；树的度：是所有结点的度的最大值。</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/668f87fad9c307b7e9e79b13.png" style="zoom:50%"></p>
<h5 id="Ⅱ-哈夫曼树的构造"><a href="#Ⅱ-哈夫曼树的构造" class="headerlink" title="Ⅱ 哈夫曼树的构造"></a>Ⅱ 哈夫曼树的构造</h5><p>上面我开门观察得到一个结论：哈夫曼树具有“位高权重”的特点，也即离根近的叶子权重高，离根远的叶子权重低。根据这个特点，有如下的构造思想：</p>
<ul>
<li><strong><font color="#FF0FF">贪心算法</font></strong>：构造哈夫曼树时首先选择权值小的叶子结点。<ul>
<li><strong>① 构造森林全是根</strong><br>根据$n$个给定的权值$(w_1, w_2, \cdots, w_n)$构成$n$棵二叉树的森林$F=(T_1, T_2, \cdots, T_n)$，其中$T_i$只有一个带权为$w_i$的根结点。</li>
<li><strong>② 选用两小造新树</strong><br>在$F$中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li>
<li><strong>③ 删除两小添新人</strong><br>在$F$中删除这两棵树，同时将新得到的二叉树加入森林中。</li>
<li><strong>④ 重复②和③</strong><br>直到森林中只有一棵树为止，这棵树即为哈夫曼树。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66908142d9c307b7e9a2f357.png" style="zoom:70%"></p>
<p>这种算法得到的哈夫曼树：其结点的度数为0或2，没有度为1的结点。此外，包含$n$个叶子结点的哈夫曼树中共有$2n-1$个结点。</p>
<h5 id="Ⅲ-哈夫曼树的实现"><a href="#Ⅲ-哈夫曼树的实现" class="headerlink" title="Ⅲ 哈夫曼树的实现"></a>Ⅲ 哈夫曼树的实现</h5><p><strong>(1) 哈夫曼树的存储结构</strong></p>
<p>既可采用顺序存储结构，又可采用链式存储结构，一般而言采用顺序存储结构比较简单：<strong>一维结构数组</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;	<span class="comment">// 权重值</span></span><br><span class="line">    <span class="keyword">int</span> parent;	<span class="comment">// 双亲</span></span><br><span class="line">    <span class="keyword">int</span> lch;	<span class="comment">// 左孩子</span></span><br><span class="line">    <span class="keyword">int</span> rch;	<span class="comment">// 右孩子</span></span><br><span class="line">&#125;HTNode,*HuffmanTree;</span><br></pre></td></tr></table></figure>
<p><strong>(2) 实现：分2步</strong></p>
<ul>
<li><strong>初始化</strong><ul>
<li><code>HT [1, 2, ..., 2n-1]:lch=rch=parent=0</code>；</li>
<li>输入初始n个叶子结点：设置<code>HT[1,...,n]</code>的weight值；</li>
</ul>
</li>
<li><strong>构造过程</strong><ul>
<li>进行以下n-1次合并，依次产生n-1个结点<code>HT[n+1, ..., 2n-1]</code></li>
<li>a. 在<code>HT[1, ..., i-1]</code>中选两个未被选过(从<code>parent ==0</code> 的结点中选)的weight最小的两个结点<code>HT[s1]</code>和<code>HT[s2]</code>，<code>s1</code>、<code>s2</code>为两个最小结点下标；</li>
<li>b. 修改<code>HT[s1]</code>和<code>HT[s2]</code>的parent值：<code>HT[s1].parent=i, HT[s2].parent=i</code>；</li>
<li>c. 修改新产生的<code>HT[i]</code>：<br><code>HT[i].weight=HT[s1].weight + HT[s2].weight</code><br><code>HT[i]. lch=s1; HT[i].rch=s2</code></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHuffmanTree</span> <span class="params">(HuffmanTree HT, <span class="keyword">int</span> n)</span>	<span class="comment">// 构造哈夫曼树--哈夫曼算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span>*n<span class="number">-1</span>;	<span class="comment">// 数组共2n-1个元素</span></span><br><span class="line">    HT = <span class="keyword">new</span> HTNode[m+<span class="number">1</span>];	<span class="comment">// 0号单元未用，HT[m]表示根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; ++i)	<span class="comment">// 将2n-1个元素的lch、rch、parent置为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        HT[i].lch=<span class="number">0</span>; </span><br><span class="line">        HT[i].rch=<span class="number">0</span>; </span><br><span class="line">        HT[i].parent=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">        cin &gt;&gt; HT[i].weight;	<span class="comment">// 输入前n个元素的weight值</span></span><br><span class="line">    <span class="comment">// =================初始化结束，下面开始建立哈夫曼树===========</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>; i&lt;=m; i++)	<span class="comment">// 合并产生n-1个结点, 构造Huffman树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Select</span>(HT, i<span class="number">-1</span> ,s1, s2);	<span class="comment">// 在HT[k](1≤k≤i-1)中选择两个其双亲域为0,</span></span><br><span class="line">        						  <span class="comment">// 且权值最小的结点, 并返回它们在HT中的序号s1和s2</span></span><br><span class="line">        HT[s1].parent=i; HT[s2].parent=i;	<span class="comment">// 表示从F中删除s1,s2</span></span><br><span class="line">        HT[i].lch=s1; HT[i].rch=s2;	<span class="comment">// s1,s2分别作为i的左右孩子</span></span><br><span class="line">        HT[i].weight=HT[s1].weight + HT[s2].weight;	<span class="comment">// i的权值为左右孩子权值之和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅳ-哈夫曼数的应用——哈夫曼编码"><a href="#Ⅳ-哈夫曼数的应用——哈夫曼编码" class="headerlink" title="Ⅳ 哈夫曼数的应用——哈夫曼编码"></a>Ⅳ 哈夫曼数的应用——哈夫曼编码</h5><p><img src="https://pic.imgdb.cn/item/66909384d9c307b7e9c5a7bc.png"></p>
<ul>
<li><strong>两个问题</strong><ul>
<li>1、为什么哈夫曼编码能够保证是前缀编码？<br>因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其它叶结点编码的前缀。</li>
<li>2、为什么哈夫曼编码能够保证字符编码总长最短？<br>因为哈夫曼树的带权路径长度最短，故字符编码的总长最短。</li>
</ul>
</li>
<li><strong>性质</strong><ul>
<li>① 哈夫曼编码是前缀码；</li>
<li>② 哈夫曼编码是最优前缀码；</li>
</ul>
</li>
</ul>
<p><strong>哈夫曼树的实现</strong></p>
<p><img src="https://pic.imgdb.cn/item/66909bc4d9c307b7e9d7ea74.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode&amp; HC, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HC = <span class="keyword">new</span> <span class="keyword">char</span>*[n+<span class="number">1</span>];	<span class="comment">// 分配n个字符编码的头指针矢量</span></span><br><span class="line">    <span class="keyword">char</span>* cd = <span class="keyword">new</span> <span class="keyword">char</span>[n];	<span class="comment">// 分配临时存放编码的动态数组空间</span></span><br><span class="line">    cd[n<span class="number">-1</span>]= <span class="string">&#x27;\0&#x27;</span>;	<span class="comment">// 编码结束符</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        start = n<span class="number">-1</span>;</span><br><span class="line">        c = i; </span><br><span class="line">        f = HT[i].parent;</span><br><span class="line">        <span class="keyword">while</span>(f != <span class="number">0</span>)	<span class="comment">// 从叶子结点开始向上回溯，直到根结点</span></span><br><span class="line">        &#123;	</span><br><span class="line">            --start;	<span class="comment">// 逐个字符求哈夫曼编码</span></span><br><span class="line">            <span class="keyword">if</span> ( HT[f].lchild == c )</span><br><span class="line">                cd[start]= <span class="string">&#x27;0&#x27;</span>;	<span class="comment">// 结点c是的的左孩子，则生成代码0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;1&#x27;</span>;	<span class="comment">// 结点c是的右孩子，则生成代码1</span></span><br><span class="line">            </span><br><span class="line">            c=f; f=HT[f].parent;	<span class="comment">// 继续向上回溯</span></span><br><span class="line">        &#125;	<span class="comment">// 求出第i个字符的编码</span></span><br><span class="line">        </span><br><span class="line">        HC[i] = <span class="keyword">new</span> <span class="keyword">char</span>[n-start];	<span class="comment">// 为第i 个字符串编码分配空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);	<span class="comment">// 将求得的编码从临时空间cd复制到HC的当前行中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> cd;	<span class="comment">// 释放临时空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sect-6-图"><a href="#sect-6-图" class="headerlink" title="&sect; 6 图"></a>&sect; 6 图</h3><h4 id="6-1-图的定义和术语"><a href="#6-1-图的定义和术语" class="headerlink" title="6.1 图的定义和术语"></a>6.1 图的定义和术语</h4><h5 id="Ⅰ-图的基本概念"><a href="#Ⅰ-图的基本概念" class="headerlink" title="Ⅰ 图的基本概念"></a>Ⅰ 图的基本概念</h5><p><strong>图：G=(V，E)</strong>，V：顶点(数据元素)的有穷非空集合，E：边的有穷集合。</p>
<p><strong>完全图</strong>：任意两个点都有一条边相连。</p>
<p><img src="https://pic.imgdb.cn/item/6690a2bed9c307b7e9e7c6ee.png" style="zoom:50%"></p>
<p><strong>稀疏图</strong>：有很少边或弧(有向图的边)的图($e&lt;n \log n$)。</p>
<p><strong>稠密图</strong>：有较多边或弧的图。</p>
<p><strong>网</strong>：边/弧带权的图。</p>
<p><strong>邻接</strong>： 有边/弧相连的两个顶点之间的关系。存在$(v_i, v_j)$，则称$v_i$和$v_j$互为邻接点；存在$<v_i, v_j>$，则称$v_i$邻接到$v_j$，$v_j$邻接于$v_i$。</v_i,></p>
<blockquote>
<p>注意：</p>
<p>在离散数学中，$(\cdot, \cdot)$表示的<strong>无序</strong>偶对，$&lt;\cdot, \cdot&gt;$表示<strong>有序</strong>偶对。</p>
</blockquote>
<p><strong>关联(依附)</strong>：边/弧与顶点之间的关系。</p>
<p><strong>顶点的度</strong>：与该顶点相关联的边的数目，记为$TD(V)$。在有向图中，顶点的度等于该顶点的<u>入度</u>与<u>出度</u>之和。</p>
<blockquote>
<p>注意：</p>
<p>入度：顶点$v$的入度是以$v$为终点的有向边的条数，记作$ID(v)$；</p>
<p>出度：顶点$v$的出度是以$v$为始点的有向边的条数，记作$OD(v)$。</p>
</blockquote>
<p>问：当有向图中仅1个顶点的入度为0，其余顶点的入度均为1，此时是何形状?<br>答：是树！而且是一棵<strong>有向树</strong>！</p>
<p><img src="https://pic.imgdb.cn/item/6690cc8cd9c307b7e946d979.png" alt="有向树" style="zoom:60%"></p>
<p><strong>路径</strong>：接续的边构成的<u>顶点序列</u>。</p>
<p><strong>路径长度</strong>：路径上边或弧的数目/权值之和。</p>
<p><strong>回路(环)</strong>：第一个顶点和最后一个顶点相同的路径。</p>
<p><strong>简单路径</strong>：除路径起点和终点可以相同外，其余顶点均不相同的路径。（序列中顶点不重复出现的路径）</p>
<p><strong>简单回路(简单环)</strong>：除路径起点和终点相同外，其余顶点均不相同的路径。</p>
<p><img src="https://pic.imgdb.cn/item/6690cec0d9c307b7e94b77d0.png" style="zoom:70%"></p>
<p><strong>连通图(强连通图)</strong>：在无(有)向图G=(V，{E})中，若对任何两个顶点v、u都存在从v 到u的路径，则称G是连通图(强连通图)。</p>
<p><img src="https://pic.imgdb.cn/item/6690d060d9c307b7e94ef2b2.png" style="zoom:60%"></p>
<p><strong>权与网</strong>：图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网。</p>
<p><strong>子图</strong>：设有两个图G=(V，{E})、G1=(V1，{E1})，若$V1 \subseteq V$，$E1 \subseteq E$，则称 G1是G的子图。</p>
<p><img src="https://pic.imgdb.cn/item/6690d1fbd9c307b7e951c1c6.png" style="zoom:60%"></p>
<p><strong>连通分量(强连通分量)</strong>：</p>
<p>无向图G的<strong>极大</strong>连通子图称为G的连通分量。<strong>极大连通子图</strong>意思是：该子图是G连通子图，将G的任何不在该子<br>图中的顶点加入，子图不再连通。</p>
<p>有向图G的极大强连通子图称为G的强连通分量。<strong>极大强连通子图</strong>意思是:该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的。</p>
<p><img src="https://pic.imgdb.cn/item/6690d479d9c307b7e957c591.png" style="zoom:60%"></p>
<p><strong>极小连通子图</strong>：该子图是G的连通子图，在该子图中删除任何一条边子图不再连通。</p>
<p><strong>生成树</strong>：包含无向图G所有顶点的极小连通子图。</p>
<p><strong>生成森林</strong>：对非连通图，由各个连通分量的生成树的集合。</p>
<p><img src="https://pic.imgdb.cn/item/6690d536d9c307b7e958f5fd.png" style="zoom:60%"></p>
<h5 id="Ⅱ-案例引入-1"><a href="#Ⅱ-案例引入-1" class="headerlink" title="Ⅱ 案例引入"></a>Ⅱ 案例引入</h5><p><strong>案例6.1 六度空间理论</strong></p>
<p>“六度空间”理论又称作六度分隔(SixDegrees of Separation )理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过六个人你就能够认识任何一个陌生人。”该理论产生于20世纪60年代，由美国心理学家米尔格伦提出。</p>
<p>把六度空间理论中的人际关系网络抽象成一个无向图G。用图G中的一个顶点表示一个人，两个人认识与否用代表这两个人的顶点之间是否有一条边来表示。从任一顶点出发用广度优先方法对图进行遍历，统计所有路径长度不超过7的顶点</p>
<h5 id="Ⅲ-图的类型定义"><a href="#Ⅲ-图的类型定义" class="headerlink" title="Ⅲ 图的类型定义"></a>Ⅲ 图的类型定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图的抽象数据类型定义如下</span></span><br><span class="line">ADT Graph</span><br><span class="line">&#123;</span><br><span class="line">	数据对象V:具有相同特性的数据元素的集合，称为顶点集</span><br><span class="line">	数据关系R:R=&#123;VR&#125;</span><br><span class="line">				VR=&#123;&lt;v,w&gt;|&lt;v,w&gt;|v,w∈V ^ <span class="built_in">P</span>(v,w)&#125;</span><br><span class="line">				&lt;v,w&gt;表示从v到w的弧，<span class="built_in">P</span>(v,w)定义了弧&lt;v;w&gt;的信息(权)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 图的基本操作P</span></span><br><span class="line">	<span class="comment">// 图的创建操作。</span></span><br><span class="line">		<span class="comment">// 初始条件:无。</span></span><br><span class="line">		<span class="comment">// 操作结果:生成一个没有顶点的空图G。</span></span><br><span class="line">    <span class="built_in">Create_Graph</span>() </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求图中的顶点v的值。</span></span><br><span class="line">        <span class="comment">// 初始条件:图G存在，v是图中的一个顶点。</span></span><br><span class="line">        <span class="comment">// 操作结果:求v的值</span></span><br><span class="line">    <span class="built_in">GetVex</span>(G,v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始条件:V是图的顶点集，VR是图中弧的集合</span></span><br><span class="line">    <span class="comment">// 操作结果:按V和VR的定义构造图G。</span></span><br><span class="line">    <span class="built_in">CreateGraph</span>(&amp;G,V,VR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始条件:图G存在。</span></span><br><span class="line">    <span class="comment">// 操作结果:对图进行深度优先遍历。</span></span><br><span class="line">    <span class="built_in">DFSTraverse</span>(G);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始条件:图G存在。</span></span><br><span class="line">    <span class="comment">// 操作结果:对图进行广度优先遍历。</span></span><br><span class="line">    <span class="built_in">BFSTraverse</span>(G)</span><br><span class="line"></span><br><span class="line">&#125; ADT Graph</span><br></pre></td></tr></table></figure>
<h4 id="6-2-图的存储结构"><a href="#6-2-图的存储结构" class="headerlink" title="6.2 图的存储结构"></a>6.2 图的存储结构</h4><p>前面已经介绍了图的逻辑结构：<strong>多对多</strong>。</p>
<p>图没有顺序存储结构，但可以借助二维数组来表示元素间的关系——数组表示法(<strong>邻接矩阵</strong>)。</p>
<p>图有链式存储结构，具体有3种形式：① 多重链表；② 邻接表邻接多重表；③ 十字链表。</p>
<h5 id="Ⅰ-数组表示法-邻接矩阵"><a href="#Ⅰ-数组表示法-邻接矩阵" class="headerlink" title="Ⅰ 数组表示法(邻接矩阵)"></a>Ⅰ 数组表示法(邻接矩阵)</h5><p>建立一个<strong>顶点表</strong>(记录各个顶点信息)和一个<strong>邻接矩阵</strong>(表示各个顶点之间关系)。</p>
<p>设图$A=(V, E)$，有$n$个顶点，则可构建一个一维数组，称为顶点表$\text{Vexs}[n]$：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>…</th>
<th>n-1</th>
</tr>
</thead>
<tbody>
<tr>
<td>vexs[i]</td>
<td>v~1~</td>
<td>v~2~</td>
<td>v~3~</td>
<td>…</td>
<td>v~n-1~</td>
</tr>
</tbody>
</table>
</div>
<p>图的邻接矩阵是一个二维数组 $\text{A. arcs}[n][n]$，定义为:</p>
<script type="math/tex; mode=display">
\text{A. arcs}[i][i] = 
\begin{cases}
&1, & <i, j> \in E ~ 或 ~  (i, j) \in E \\
& 0,& \text{others}
\end{cases}</script><p><img src="https://pic.imgdb.cn/item/66939428d9c307b7e9a29f5d.png" style="zoom:40%"></p>
<p>分析1：无向图的邻接矩阵是对称的；</p>
<p>分析2：无向图顶点$v_i$的度=第$i$行(列) 中1的个数；</p>
<p>分析3：完全图的邻接矩阵中，对角元素为0，其余1。</p>
<p><img src="https://pic.imgdb.cn/item/6693975dd9c307b7e9a8a987.png" style="zoom:40%"></p>
<p>分析1：有向图的邻接矩阵可能是不对称的；</p>
<p>分析2：顶点的出度=第$i$行元素之和，顶点的入度=第$i$列元素之和，顶点的度=第$i$行元素之和+第$i$列元素之和。</p>
<p><strong>网(即有权图)</strong>的邻接矩阵表示法：</p>
<script type="math/tex; mode=display">
\text{A. arcs}[i][i] = 
\begin{cases}
&w_{ij}, & <i, j>~ 或 ~  (i, j) \in VR \\
& \infty,& \text{others}
\end{cases}</script><p><img src="https://pic.imgdb.cn/item/66939852d9c307b7e9aa54e8.png" style="zoom:30%"></p>
<h5 id="Ⅱ-邻接矩阵的存储表示"><a href="#Ⅱ-邻接矩阵的存储表示" class="headerlink" title="Ⅱ 邻接矩阵的存储表示"></a>Ⅱ 邻接矩阵的存储表示</h5><p>用两个数组分别存储<strong>顶点表</strong>和<strong>邻接矩阵</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 32767	<span class="comment">// 表示极大值，即∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100   	<span class="comment">// 最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VerTexType;	<span class="comment">// 设顶点的数据类型为字符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArcType;	<span class="comment">// 假设边的权值类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VerTexType vexs[MVNum];	<span class="comment">// 顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum];	<span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;	<span class="comment">// 图的当前点数和边数</span></span><br><span class="line">&#125;AMGraph; <span class="comment">// Adjacency Matrix Graph</span></span><br></pre></td></tr></table></figure>
<p><strong>采用邻接矩阵表示法创建无向网</strong>(无向图、有向图、有向网)</p>
<ul>
<li>【算法思想】<ul>
<li>(1) 输入总顶点数和总边数。</li>
<li>(2) 依次输入点的信息存入顶点表中。</li>
<li>(3) 初始化邻接矩阵，使每个权值初始化为极大值。</li>
<li>(4) 构造邻接矩阵。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图G中查找顶点u，存在则返回顶点表中的下标; 否则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(AMGraph G, VertexType u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">if</span>(u==G.vexs[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用邻接矩阵表示法，创建无向网</span></span><br><span class="line"><span class="function">Status <span class="title">CreateUDN</span><span class="params">(AMGraph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Gcin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;	<span class="comment">// 输入总顶点数，总边数</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G.vexnum; ++i)<span class="comment">// 依次输入点的信息</span></span><br><span class="line">        cin &gt;&gt; G.vexs[i];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G.vexnum; ++i) <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j&lt;G.vexnum; ++j)</span><br><span class="line">            G.arcs[i][j] = MaxInt;	<span class="comment">// 边的权值均置为极大值(无穷)</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k&lt;G.arcnum; ++k)&#123;	<span class="comment">// 构造邻接矩阵</span></span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;	<span class="comment">// 输入一条边所依附的顶点及边的权值</span></span><br><span class="line">        i = <span class="built_in">LocateVex</span>(G, v1);</span><br><span class="line">        j = <span class="built_in">LocateVex</span>(G, v2);	<span class="comment">// 该函数用于确定v1和v2在G中的位置</span></span><br><span class="line">        G.arcs[i][j] = w;	<span class="comment">// 边&lt;v1,v2&gt;的权值置为w</span></span><br><span class="line">        G.arcs[j][i] = G.arcs[i][j]; <span class="comment">// 置&lt;v1,v2&gt;的对称边&lt;v2,v1&gt;的权值为w</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//CreateUDN</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6693a15fd9c307b7e9bb8705.png" style="zoom:40%"></p>
<p>邻接矩阵存储方式有什么不好？</p>
<p>① 不便于增加和删除顶点；② 浪费空间——存稀疏图(点很多而边很少)有大量无效元素，对稠密图(特别是完全图)还是很合算的；③ 浪费时间——例如统计稀疏图中一共有多少条边。</p>
<h5 id="Ⅲ-邻接表表示法-链式"><a href="#Ⅲ-邻接表表示法-链式" class="headerlink" title="Ⅲ 邻接表表示法(链式)"></a>Ⅲ 邻接表表示法(链式)</h5><p><strong>(1) 无向图/网的邻接表</strong></p>
<p><img src="https://pic.imgdb.cn/item/6693a3bcd9c307b7e9c0b21d.png"></p>
<ul>
<li><strong>顶点</strong>：按编号顺序将顶点数据存储在一维数组中；<ul>
<li>头节点<code>data</code>：存放结点数据；</li>
<li>头节点<code>firstarc</code>：存放邻接结点的数组下标索引。</li>
</ul>
</li>
<li><strong>关联同一顶点的边(以顶点为尾的弧)</strong>：用线性链表存储。<ul>
<li>表结点<code>adjvex</code>：</li>
<li>表结点<code>nextarc</code>：链域，指示下一条边或弧；</li>
<li>附加：表结点<code>weight</code>：若有权值，则添加weight表示。</li>
</ul>
</li>
</ul>
<p><strong>特点</strong></p>
<p>① 邻接表不唯一；</p>
<p>② 若无向图中有$n$个顶点、$e$条边，则其邻接表需$n$个头结点和$2e$个表结点(空间复杂度$O(n+2e)$)。适宜存储稀疏图。</p>
<p>③ 无向图中顶点$v_i$的度为第$i$个单链表中的结点数。</p>
<p><strong>(2) 有向图/网的邻接表</strong></p>
<p><img src="https://pic.imgdb.cn/item/66947dafd9c307b7e9b72892.png"></p>
<p>若是带有权值的网，则在表结点上可以再添加一个单元存储<code>info</code>。</p>
<p><strong>(3) 图的邻接表实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100	<span class="comment">// 最大顶点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表结点定义(边、弧结点)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Arcnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;	<span class="comment">// 该边所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Arcnode</span>* <span class="title">nextarc</span>;</span>	<span class="comment">// 指向下一条边的指针</span></span><br><span class="line">    OtherInfo info;	<span class="comment">// 和边相关的信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VerTexType data;	<span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode* firstarc;	<span class="comment">// 指向第一条依附该顶点的边的指针 </span></span><br><span class="line">&#125;VNode, AdjList[MVNum];	<span class="comment">// AdjList表示邻接表类型</span></span><br><span class="line"><span class="comment">// 这里 AdjList v; 等价于 VNode v[MVNum];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表图定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList vertices;	<span class="comment">// vertices--vertex的复数</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;	<span class="comment">// 图的当前顶点数和弧数</span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6694828bd9c307b7e9bc0cd0.png" alt="邻接表操作举例说明"></p>
<p><strong>采用邻接表表示法创建无向网</strong></p>
<ul>
<li>【算法思想】<ul>
<li>(1) 输入总顶点数和总边数；</li>
<li>(2) 建立顶点表<br>依次输入点的信息存入顶点表中，并使每个表头结点的指针域初始化为NULL创建邻接表；</li>
<li>(3) 创建邻接表<br>依次输入每条边依附的两个顶点，确定两个顶点的序号$i$和$j$，建立边结点将此边结点分别插入到$v_i$和$v_j$对应的两个边链表的头部。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用邻接表表示法创建无向图G</span></span><br><span class="line"><span class="function">Status <span class="title">CreateUDG</span><span class="params">(ALGraph&amp; G)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;	<span class="comment">// 输入总顶点数，总边数</span></span><br><span class="line">    <span class="comment">// 输入各点，构造头结点表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G.vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; G.vertices[i].data;	<span class="comment">// 输入顶点值</span></span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;	<span class="comment">// 初始化表头结点的指针域为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输入各边，构造邻接表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;G.arcnum; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2;	<span class="comment">// 输入一条边依附的两个顶点</span></span><br><span class="line">        i = <span class="built_in">LocateVex</span>(G, v1);</span><br><span class="line">        j = <span class="built_in">LocateVex</span>(G, v2);</span><br><span class="line">        </span><br><span class="line">        ArcNode* p1 = <span class="keyword">new</span> ArcNode;	<span class="comment">// 生成一个新的边结点*p1</span></span><br><span class="line">        p1-&gt;adjvex = j;	<span class="comment">// 邻接点序号为j</span></span><br><span class="line">        p1-&gt;nextarc = G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc = p1;	<span class="comment">// 将新结点*p1插入顶点vi的边表头部</span></span><br><span class="line">        </span><br><span class="line">        ArcNode* p2 = <span class="keyword">new</span> ArcNode;	<span class="comment">// 生成另一个对称的新的边结点*p2</span></span><br><span class="line">        p2-&gt;adjvex = i;	<span class="comment">// 邻接点序号为i</span></span><br><span class="line">        p2-&gt;nextarc = G.vertices[j].firstarc;</span><br><span class="line">        G.vertices[j].firstarc = p2;	<span class="comment">// 将新结点*p2插入顶点vj的边表头部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//CreateUDG</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>邻接表特点</strong><ul>
<li>方便找任一顶点的所有“邻接点“</li>
<li>节约稀疏图的空间：需要N个头指针+2E个结点(每个结点至少2个域)</li>
<li>方便计算任一顶点的“度”?<ul>
<li>对无向图：是的</li>
<li>对有向图：只能计算“出度”，需要构造“逆邻接表”(存指向自己的边)来方便计算”入度“</li>
<li>不方便检查任意一对顶点间是否存在边。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Ⅳ-图的其他改进表示法"><a href="#Ⅳ-图的其他改进表示法" class="headerlink" title="Ⅳ 图的其他改进表示法"></a>Ⅳ 图的其他改进表示法</h5><p><img src="https://pic.imgdb.cn/item/66948bf8d9c307b7e9c7dc7b.png" style="zoom:60%"></p>
<p><strong>(1) 十字链表——用于有向图</strong></p>
<p>十字链表(Orthogonal List)是有向图的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。</p>
<p>有向图中的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点。</p>
<p><img src="https://pic.imgdb.cn/item/66948f46d9c307b7e9cba8ab.png"></p>
<p><strong>(2) 邻接多重表——用于无向图</strong></p>
<p><img src="https://pic.imgdb.cn/item/6694935bd9c307b7e9d14670.png"></p>
<p>第一个格子是标记域，搜索时用的，用来标记是否被查找过；</p>
<p>0后边指针的找相同相同位置带0的，1后边招相同位置带1的，推广到任意数。</p>
<h4 id="6-3-图的遍历"><a href="#6-3-图的遍历" class="headerlink" title="6.3 图的遍历"></a>6.3 图的遍历</h4><h5 id="Ⅰ-遍历的基本概念"><a href="#Ⅰ-遍历的基本概念" class="headerlink" title="Ⅰ 遍历的基本概念"></a>Ⅰ 遍历的基本概念</h5><p>从已给的连通图中某一顶点出发，沿着一些边访遍图中<strong>所有的顶点</strong>，且使每个顶点<strong>仅被访问一次</strong>，就叫做图的遍历，它是图的基本运算。</p>
<p>遍历实质：找每个顶点的邻接点的过程。</p>
<p><strong>图的特点</strong>：图中可能存在<u>回路</u>，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点。</p>
<ul>
<li>所以问题来了，怎样<strong>避免重复访问</strong>？<ul>
<li>解决思路：设置辅助数组 <code>visited[n]</code>，用来标记每个被访问过的顶点。</li>
<li>初始状态<code>visited [i]</code>设为0；顶点$i$被访问，改 <code>visited [i]</code>为1，防止被多次访问。</li>
</ul>
</li>
<li><strong>==图常用的遍历算法==</strong>：<ul>
<li>① 深度优先搜索(Depth First Search—DFS )，<strong>思想</strong>：一条道走到黑，然后再回退。</li>
<li>② 广度优先搜索(Breadth Frist Search—BFS)，</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-深度优先搜索-DFS"><a href="#Ⅱ-深度优先搜索-DFS" class="headerlink" title="Ⅱ 深度优先搜索(DFS)"></a>Ⅱ 深度优先搜索(DFS)</h5><p><strong>(1) DFS的基本步骤</strong></p>
<ul>
<li><strong>【算法思想】</strong><ul>
<li>在访问图中某一起始顶点$v$后，由$v$出发，访问它的任一邻接顶点$w_1$；</li>
<li>再从$w_1$出发，访问与$w_1$邻接但还未被访问过的顶点$w_2$；</li>
<li>然后再从$w_2$出发，进行类似的访问 … …</li>
<li>如此进行下去，直至到达所有的邻接顶点都被访问过的顶点$u$为止。</li>
<li>接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。<ul>
<li>如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；</li>
<li>如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6695d6e1d9c307b7e94fde0d.png"></p>
<p><strong>(2) 基于邻接矩阵表示的无向图DFS</strong></p>
<ul>
<li><strong>连通图的遍历</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AMGraph G <span class="keyword">int</span> v)</span>	<span class="comment">// 图G为邻接矩阵类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; v; </span><br><span class="line">    visited[v]= <span class="literal">true</span>;	<span class="comment">// 访问第v个顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w&lt;G.vexnum; w++)	<span class="comment">// 依次检查邻接矩阵v所在的行</span></span><br><span class="line">        <span class="keyword">if</span>((G.arcs[v][w]!=<span class="number">0</span>) &amp;&amp; (!visited[w]))</span><br><span class="line">            <span class="built_in">DFS</span>(G, w);	<span class="comment">// w是v的邻接点，如果w未访问，则递归调用DFS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>非连通图的遍历</strong></li>
</ul>
<p><strong>(3) 基于邻接表表示的无向图DFS</strong></p>
<h5 id="Ⅲ-广度优先搜索-BFS"><a href="#Ⅲ-广度优先搜索-BFS" class="headerlink" title="Ⅲ 广度优先搜索(BFS)"></a>Ⅲ 广度优先搜索(BFS)</h5><p><strong>(1) BFS的基本步骤</strong></p>
<ul>
<li><strong>【算法思想】</strong><ul>
<li>从图的某一结点出发，首先依次访问该结点的所有邻接点$v_{i1}, v_{i2}, …, v_{in}$，再按这些顶点被访问的先后次序依次访问与它们相邻接的所有未被访问的顶点；</li>
<li>重复此过程，直至所有顶点均被访问为止。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6695dd10d9c307b7e956bc0d.png"></p>
<p><strong>(2) 基于邻接表表示的无向图BFS</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按广度优先非递归遍历连通图G</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; v; </span><br><span class="line">    visited[v] = <span class="literal">true</span>;	<span class="comment">//访问第v个顶点</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);	<span class="comment">// 辅助队列Q初始化，置空</span></span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, v);	<span class="comment">// v进队</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(Q))	<span class="comment">// 队列非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, u);	<span class="comment">// 队头元素出队并置为u</span></span><br><span class="line">        <span class="keyword">for</span>(w = <span class="built_in">FirstAdjVex</span>(G, u); w&gt;=<span class="number">0</span>; w = <span class="built_in">NextAdjVex</span>(G, u, w))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])	<span class="comment">// w为u的尚未访问的邻接顶点</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;w; </span><br><span class="line">                visited[w]= <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q, w);	<span class="comment">// w进队</span></span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;<span class="comment">//BFS</span></span><br></pre></td></tr></table></figure>
<h4 id="6-4-图的应用"><a href="#6-4-图的应用" class="headerlink" title="6.4 图的应用"></a>6.4 图的应用</h4><h5 id="Ⅰ-最小生成树"><a href="#Ⅰ-最小生成树" class="headerlink" title="Ⅰ 最小生成树"></a>Ⅰ 最小生成树</h5><p><strong>(1) 最小生成树的概念</strong></p>
<p><strong>生成树</strong>：(所有顶点)均由边连接在一起，但不存在回路的图。</p>
<ul>
<li><p>所有生成树具有以下<strong>共同特点</strong>：</p>
<ul>
<li>生成树的顶点个数与图的顶点个数相同；</li>
<li>生成树是图的极小连通子图。去掉一条边则非连通；</li>
<li>一个有$n$个顶点的连通图的生成树有$n-1$条边；</li>
<li>在生成树中再加一条边必然形回路；</li>
<li>生成树中任意两个顶点间的路径是<strong>唯一</strong>的。</li>
</ul>
<blockquote>
<p>注意：含$n$个顶点$n-1$条边的图不一定是生成树。</p>
</blockquote>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6695e5e4d9c307b7e962c413.png" style="zoom:50%"></p>
<p>设图 G=(V,E)是个连通图，当从图任一顶点出发遍历图G 时，将边集 E(G)分成两个集合 T(G)和 B(G)。其中 <strong>T(G)是遍历图时所经过的边的集合</strong>，B(G)是遍历图时未经过的边的集合。显然，<strong>G1(V, T)是图的极小连通子图</strong>。即子图G1 是连通图 G 的<strong>生成树</strong>。</p>
<p><strong>(2) 最小生成树的应用</strong></p>
<ul>
<li><strong>最小代价生成树</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6695e778d9c307b7e9648710.png" style="zoom:70%"></p>
<p>给定一个无向网络，在该网的所有生成树中，使得各边权值之和最小的那棵生成树称为该网的最小生成树，也叫最小代价生成树。</p>
<p><strong>(3) 构造最小生成树MST</strong></p>
<p>构造最小生成树的算法很多，其中多数算法都利用了MST的性质。</p>
<p><strong><font color="blue">MST性质</font></strong>：设$N=(V,E)$是一个连通网，$U$是顶点集$V$的一个非空子集。若边$(u,v)$是一条具有最小权值的边，其中$u \in U，v \in V-U$，则必存在一棵包含边$(u,v)$ 的最小生成树。</p>
<p><img src="https://pic.imgdb.cn/item/6696129bd9c307b7e99d9ec8.png" alt="MST性质图示"></p>
<ul>
<li>在生成树的构造过程中，图中$n$个顶点分属两个集合：<ul>
<li>已落在生成树上的顶点：$U$；</li>
<li>尚未落在生成树上的顶点集：$V-U$；</li>
</ul>
</li>
<li>接下来则应在所有连通$U$中顶点和$V-U$中顶点的边中<strong>选取权值最小的边</strong>。</li>
</ul>
<p><strong>==构造最小生成树方法一：普里姆(Prim)算法==</strong></p>
<ul>
<li>【算法思想】<ul>
<li>设$N=(V, E)$ 是连通网，$TE$是$N$上最小生成树中边的集合。</li>
<li>初始令$U=\{u_0\},(u_0 \in V)$，$TE=\{ \}$；</li>
<li>在所有$u \in U, v\in V-U$的边$(u, v) \in E$中，找一条代价最小的边$(u_0, v_0)$。</li>
<li>将$(u_0, v_0)$并入集合$TE$，同时$v_0$并入$U$；</li>
<li>重复上述操作直至$U= V$为止，则 $T = (V, TE)$ 为$N$的最小生成树。</li>
</ul>
</li>
</ul>
<p><strong>==构造最小生成树方法二：克鲁斯卡尔(Kruskal) 算法==</strong></p>
<ul>
<li>【算法思想】（贪心算法）<ul>
<li>设连通网$N=(V, E)$，令最小生成树初始状态为只有$n$个顶点而无边的非连通图$T=(V, \{\})$，每个顶点自成一个连通分量。</li>
<li>在$E$中选取代价最小的边，若该边依附的顶点落在 $T$中不同的连通分量上(即<u>不能形成环</u>)，则将此边加入到 $T$中；否则，舍去此边，选取下一条代价最小的边。</li>
<li>依此类推，直至$T$中所有顶点都在同一连通分量上为止。</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-最短路径"><a href="#Ⅱ-最短路径" class="headerlink" title="Ⅱ 最短路径"></a>Ⅱ 最短路径</h5><p>典型用途：交通网络的问题 —— 从甲地到乙地之间是否有公路连通？在有多条通路的情况下，哪一条路最短？</p>
<p>交通网络用有向网来表示：顶点 —— 表示地点，弧 —— 表示两个地点有路连通，弧上的权值 —— 表示两地点之间的距离、交通费或途中所花费的时间等。</p>
<p>问题抽象：在有向网中 A点(源点)到达B点(终点)的多条路径中，寻找一条各边权值之和最小的路径，即<strong>最短路径</strong>。</p>
<blockquote>
<p>最短路径与最小生成树不同，路径上不一定包含$n$个顶点，也不一定包含 $n-1$ 条边。</p>
</blockquote>
<p><strong>最短路径的2类问题</strong>：</p>
<ul>
<li>单源最短路径：用Dijkstra(迪杰斯特拉)算法</li>
<li>所有顶点间的最短路径：用Floyd(弗洛伊德)算法</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66971859d9c307b7e942945f.png"></p>
<p><strong>(1) Dijkstra(迪杰斯特拉)算法</strong></p>
<ul>
<li>【思想概述】<ul>
<li>初始化：先找出从源点$v_0$到各终点$v_k$的直达路径$(v_0, v_k)$，即通过一条弧到达的路径；</li>
<li>选择：从这些路径中找出一条长度最短的路径$(v_0, u)$；</li>
<li>更新：然后对其余各条路径进行适当调整：<ul>
<li>若在图中存在弧$(u, v_k)$，且$(v_0, u) + (u, v_k) &lt; (v_0, v_k)$，则以路径$(v_0, u , v_k)$代替$(v_0, v_k)$；</li>
</ul>
</li>
<li>在调整后的各条路径中，再找长度最短的路径，依此类推。</li>
</ul>
</li>
<li>【迪杰斯特拉(Dijkstra)算法】按路径长度递增次序产生最短路径<ul>
<li>把$V$分成两组：<ul>
<li>(1) $S$：已求出最短路径的顶点的集合；</li>
<li>(2) $T=V-S$：尚未确定最短路径的顶点集合。</li>
</ul>
</li>
<li>将$T$中顶点按最短路径递增的次序加入到$S$中，保证：<ul>
<li>(1) 从源点$v_0$到$S$中各顶点的最短路径长度都不大于从$v_0$到$T$中任何顶点的最短路径长度；</li>
<li>(2) 每个顶点对应一个距离值：<ul>
<li>$S$ 中顶点：从$v_0$到此顶点的最短路径长度。</li>
<li>$T$ 中顶点：从$v_0$到此顶点的只包括$S$中顶点作中间顶点的最短路径长度。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66971ee7d9c307b7e94e4500.png" style="zoom:60%"></p>
<p> <strong>(2) Floyd(弗洛伊德)算法</strong></p>
<ul>
<li><strong>所有顶点间的最短路径</strong><ul>
<li>方法一：每次以一个顶点为源点，重复执行 Dijkstra 算法 n次。</li>
<li>方法二：弗洛伊德(Floyd)算法</li>
</ul>
</li>
<li>【算法思想】<ul>
<li>逐个顶点试探</li>
<li>从$v_i$到$v_j$的所有可能存在的路径中选出一条长度最短的路径</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66972320d9c307b7e9560a17.png" style="zoom:60%"></p>
<h5 id="Ⅲ-有向无环图：拓扑排序"><a href="#Ⅲ-有向无环图：拓扑排序" class="headerlink" title="Ⅲ 有向无环图：拓扑排序"></a>Ⅲ 有向无环图：拓扑排序</h5><p>有向无环图：无环的有向图，简称 DAG图(Directed Acycline Graph)。</p>
<p><img src="https://pic.imgdb.cn/item/669723c2d9c307b7e9574170.png" style="zoom:70%"></p>
<p>有向无环图常用来描述一个工程或系统的进行过程（通常把计划、施工、生产、程序流程等当成是一个工程）。一个工程可以分为若干个子工程，只要完成了这些子工程（活动）就可以导致整个工程的完成。</p>
<ul>
<li><strong><font color="blue">AOV 网：拓扑排序问题</font></strong><ul>
<li>用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以<strong>顶点表示活动</strong>，<strong>弧表示活动之间的优先制约关系</strong>，称这种有向图为顶点表示活动的网，简称 AOV网(Activity On Vertex network)。</li>
</ul>
</li>
<li><strong><font color="green">AOE 网：关键路径问题</font></strong><ul>
<li>用一个有向图表示一个工程的各子工程及其相互制约的关系，以<strong>弧表示活动</strong>，以<strong>顶点表示活动的开始或结束事件</strong>，称这种有向图为边表示活动的网，简称为AOE网(Activity On Edge)。</li>
</ul>
</li>
</ul>
<p><strong>AOV 网的特点</strong>：<br>① 若从$i$到$j$有一条有向路径，则$i$是$j$的前驱，$j$是$i$的后继。<br>② 若$<i,j>$是网中有向边，则$i$是$j$的直接前驱，$j$是$i$的直接后继。<br>③ AOV 网中不允许有回路，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的。</i,j></p>
<p><img src="https://pic.imgdb.cn/item/66972758d9c307b7e95f47d3.png" style="zoom:70%"></p>
<p><strong>问题：如何判别 AOV 网中是否存在回路</strong>？</p>
<p><strong>拓扑排序</strong>：在 AOV 网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧$<i,j>$存在，则在这个序列中，$i$一定排在$j$的前面，具有这种性质的线性序列称为<strong>拓扑有序序列</strong>，相应的拓扑有序排序的算法称为<strong>拓扑排序</strong>。</i,j></p>
<p><img src="https://pic.imgdb.cn/item/669729fed9c307b7e9646563.png" style="zoom:60%"></p>
<p><strong>拓扑排序的一个重要应用：检测 AOV 网中是否存在环方法</strong></p>
<p>对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该 AOV 网必定不存在环。</p>
<h5 id="Ⅳ-有向无环图：关键路径"><a href="#Ⅳ-有向无环图：关键路径" class="headerlink" title="Ⅳ 有向无环图：关键路径"></a>Ⅳ 有向无环图：关键路径</h5><p>关键路径问题引入：</p>
<p><img src="https://pic.imgdb.cn/item/66972c5cd9c307b7e968e0c4.png" style="zoom:40%"></p>
<p><img src="https://pic.imgdb.cn/item/66972e8ad9c307b7e96d2b21.png" style="zoom:60%"></p>
<p>设一个工程有 11项活动，9个事件：</p>
<p>事件$v_1$—表示整个工程开始(源点:入度为0的顶点)</p>
<p>事件$v_9$—表示整个工程结束(汇点:出度为0的顶点)</p>
<p><img src="https://pic.imgdb.cn/item/6697301cd9c307b7e970497f.png" style="zoom:50%"></p>
<p>对于AOE网，我们关心两个问题：① 完成整项工程至少需要多少时间？② 哪些活动是影响工程进度的关键？</p>
<p>这两个问题涉及关键路径算法——求路径最长(路径上各活动持续时间之和)。</p>
<ul>
<li>如何确定关键路径，需要定义4个描述量：<ul>
<li><code>ve(vj)</code>： 表示事件<code>vj</code> 的最早发生时间，例：<code>ve(v1)=0, ve(v2)= 30</code>；</li>
<li><code>vl(vj)</code> ：表示事件<code>vj</code>的最迟发生时间，例：<code>vl(v4)=165</code>；</li>
<li><code>e(i)</code>：表示活动 <code>ai</code> 的最早开始时间，例：<code>e(a3)= 30</code>；</li>
<li><code>l(i)</code>表示活动 <code>ai</code>的最迟开始时间，例：<code>l(a3)=120</code>。</li>
</ul>
</li>
<li><code>l(i)-e(i)</code>表示完成活动<code>ai</code>的时间余量。例：<code>l(3)-e(3)= 90</code>；</li>
<li><strong>关键活动</strong>：关键路径上的活动，<code>l(i)==e(i)</code>(即<code>l(i) - e(i) == 0</code>的活动。</li>
</ul>
<p>如何找<code>l(i)==e(i)</code>的关键活动？</p>
<p>设活动<code>ai</code>用弧$<j,k>$表示，其持续时间记为：$w_{j,k}$，则有：</j,k></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>关系</th>
<th>图示</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\begin{cases} e(i) = ve(j) \\ l(i) = vl(k) - w_{j,k} \end{cases}$</td>
<td><img src="https://pic.imgdb.cn/item/669735e5d9c307b7e97ce160.png" style="zoom:70%"></td>
</tr>
</tbody>
</table>
</div>
<p>如何求<code>ve(j)</code> 和 <code>v(j)</code>？</p>
<p>(1) 从 <code>ve(1)=0</code> 开始向前递推，$ve(j) = \max_i \{ ve(i) + w_{i,j}\}, <i, j> \in T, 2\leq j \leq n$，其中$T$是所有以$j$为开头的弧的集合。</i,></p>
<p>(2) 从 <code>v(n)= ve(n)</code>开始向后递推，$vl(i) = \min_j \{ vl(j) - w_{i,j}\},  <i, j> \in S, 1\leq i \leq n-1$，其中 $S$ 是所有以$i$为尾的弧的集合。</i,></p>
<p><img src="https://pic.imgdb.cn/item/66976d72d9c307b7e9fb1d02.png"></p>
<ol>
<li>若网中有几条关键路径，则需加快同时在几条关键路径上的关键活动。如：a11、a10、a8、a7；</li>
<li>若一个活动处于所有的关键路径上，那么提高该活动的速度，就能缩短工程的完成时间。如：a1、a4；</li>
<li>处于所有的关键路径上的活动完成时间不能缩短太多，否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。如：a1由6 天变成 3天，就会改变关键路径。</li>
</ol>
<h3 id="sect-7-查找操作"><a href="#sect-7-查找操作" class="headerlink" title="&sect; 7 查找操作"></a>&sect; 7 查找操作</h3><h4 id="7-1-查找的基本概念"><a href="#7-1-查找的基本概念" class="headerlink" title="7.1 查找的基本概念"></a>7.1 查找的基本概念</h4><p>本章讲解的查找操作，既不是在线性表上找，也不是在树或图上进行查找，而是在一个新的数据结构——<strong>查找表</strong>上进行查找。</p>
<p><strong><font color="red">查找表</font></strong>是由同一类型的数据元素(或记录)构成的<strong>集合</strong>。由于“集合”中的数据元素之间存在着<strong>松散的关系</strong>(没有前趋、后继、邻接等关系)，因此查找表是一种应用灵便的结构。</p>
<p><strong>查找操作</strong>：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或记录。</p>
<ul>
<li><strong>关键字</strong>：用来标识一个数据元素(或记录)的某个数据项的值。<ul>
<li><u>主关键字</u>：可唯一地标识一个记录的关键字是主关键字；</li>
<li><u>次关键字</u>：反之，用以识别若干记录的关键字是次关键字。</li>
</ul>
</li>
<li>查找表可分为两类<ul>
<li><u>静态查找表</u>：仅作“查询”(检索)操作的查找表。</li>
<li><u>动态查找表</u>：作“插入”和“删除”操作的查找表。<br>有时在查询之后，还需要将“查询”结果为“不在查找表中”的数据元素插入到查找表中；或者，从查找表中删除其“查询”结果为’在查找表中”的数据元素，此类表为动态查找表。</li>
</ul>
</li>
</ul>
<p>查找的方法取决于<strong>查找表的结构</strong>，即表中数据元素是依何种关系组织在一起的。</p>
<p>由于对查找表来说，在集合中查询或检索一个“特定的”数据元素时若无规律可循，只能对集合中的元素一一加以辨认直至找到为止。而这样的“查询”或“检索”是任何计算机应用系统中使用频度都很高的操作，因此设法<strong>提高查找表的查找效率</strong>，是本章讨论问题的出发点。</p>
<p>为提高查找效率，一个办法就是在构造查找表时，在集合中的数据元素之间人为地加上某种确定的<strong>约束</strong>关系。</p>
<h4 id="7-2-线性表上的查找"><a href="#7-2-线性表上的查找" class="headerlink" title="7.2 线性表上的查找"></a>7.2 线性表上的查找</h4><h5 id="Ⅰ-顺序查找-线性查找"><a href="#Ⅰ-顺序查找-线性查找" class="headerlink" title="Ⅰ 顺序查找(线性查找)"></a>Ⅰ 顺序查找(线性查找)</h5><p>应用范围：顺序表或线性链表表示的静态查找表，且表内元素之间无序。</p>
<p>数据元素类型定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;	<span class="comment">// 关键字域</span></span><br><span class="line">    ...	<span class="comment">// 其他域</span></span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType* R;	<span class="comment">// 表基地址</span></span><br><span class="line">    <span class="keyword">int</span> length;	<span class="comment">// 表长</span></span><br><span class="line">&#125;SSTable;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6698c7aad9c307b7e9727046.png" style="zoom:70%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">( SsTable ST , KeyType key )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若成功返回其位置信息，否则返回0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=ST.length; i&gt;=<span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">if</span>( ST.R[i].key==key )</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容易发现：每执行一次循环都要进行两次比较，是否能改进？</p>
<p><strong>改进</strong>：把待查关键字<code>key</code>存入表头（“硝兵“、监视哨”），从后往前逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。</p>
<p><img src="https://pic.imgdb.cn/item/6698ca58d9c307b7e975a833.png" style="zoom:60%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置监视哨的顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">( SsTable ST , KeyType key )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若成功返回其位置信息，否则返回0</span></span><br><span class="line">    ST.R[<span class="number">0</span>].key = key</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=ST.length; ST.R[i].key!=key; --i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>ST.length</code> 较大时，此改进能使进行一次查找所需的平均时间几乎减少一半。</p>
<ul>
<li><strong>顺序查找的特点</strong><ul>
<li>优点：算法简单，逻辑次序无要求，且不同存储结构均适用。</li>
<li>缺点：ASL太长，时间效率太低。</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-折半查找-二分查找"><a href="#Ⅱ-折半查找-二分查找" class="headerlink" title="Ⅱ 折半查找(二分查找)"></a>Ⅱ 折半查找(二分查找)</h5><p><strong>有序表</strong>表示静态查找表 → 折半查找：每次将待查记录所在区间缩小一半。</p>
<ul>
<li>【折半查找算法(非递归算法)】<ul>
<li>设表长为$n$，$\text{low}$、$\text{high}$和$\text{mid}$分别指向待查元素所在区间的上界、下界和中点，<code>key</code>为给定的要查找的值；</li>
<li>初始时，令$\text{low}=1$，$\text{high}=n$，$\text{mid} = \lfloor (\text{low} + \text{high})/2 \rfloor$；</li>
<li>让k与mid指向的记录比较<ul>
<li>若<code>key==R[mid].key</code>，查找成功；</li>
<li>若<code>key&lt;R[mid].key</code>，则<code>high=mid-1</code>；</li>
<li>若<code>key&gt;R[mid].key</code>，则<code>low=mid+1</code>；</li>
</ul>
</li>
<li>重复上述操作，直至<code>low&gt;high</code>时，查找失败。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Bin</span><span class="params">( SSTable ST, KeyType key )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 置区间初值</span></span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> high= STlength ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid =(low + high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (ST.R[mid].key == key)</span><br><span class="line">            <span class="keyword">return</span> mid;	<span class="comment">// 找到待査元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; ST.R[mid].key) <span class="comment">// 缩小查找区间</span></span><br><span class="line">            high=mid<span class="number">-1</span>;	<span class="comment">// 继续在前半区间进行查找</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            low = mid +<span class="number">1</span>; <span class="comment">// 继续在后半区间进行査找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 顺序表中不存在待查元素</span></span><br><span class="line">&#125;<span class="comment">// Search_Bin</span></span><br></pre></td></tr></table></figure>
<p>补充【算法7.3】折半查找—递归算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Bin</span> <span class="params">(ssTable ST, keyType key, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 查找不到时返回0</span></span><br><span class="line">    mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(key==ST.elem[mid].key)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;sTelem[mid].key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Search_Bin</span>(ST, key, low, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Search_Bin</span>(ST, key, mid<span class="number">-1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>折半查找的特点</strong><ul>
<li>折半查找优点：效率比顺序查找高。</li>
<li>折半查找缺点：只适用于有序表且限于顺序存储结构（对线性链表无效）；此外，只适合查找操作，若查找完后还有插入、删除等操作，则需要移动大量元素。</li>
</ul>
</li>
</ul>
<h5 id="Ⅲ-分块查找"><a href="#Ⅲ-分块查找" class="headerlink" title="Ⅲ 分块查找"></a>Ⅲ 分块查找</h5><p><strong>条件1</strong>：将表分成几块，且表或者有序，或者分块有序。若$i&lt;j$，则第$j$块中所有记录的关键字均大于第$i$块中的最大关键字。<br><strong>条件2</strong>：建立“索引表”(每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序)。</p>
<p><strong>查找过程</strong>：先确定待查记录所在块(顺序或折半查找)再在块内查找(顺序查找)。</p>
<p><img src="https://pic.imgdb.cn/item/6699bd5fd9c307b7e972e9a3.png" style="zoom:50%"></p>
<h4 id="7-3-树表上的查找"><a href="#7-3-树表上的查找" class="headerlink" title="7.3 树表上的查找"></a>7.3 树表上的查找</h4><p>对于前面讲的线性表查找，当表插入、删除操作频繁时，为维护表的有序性，需要移动表中很多记录。相当复杂。</p>
<p>一种方法是：改用<strong>动态查找表</strong>——几种特殊的树，表结构在查找过程中动态生成。对于给定值key，若表中存在，则成功返回，否则，插入关键字等于key的记录。</p>
<p><strong>特殊的树</strong>：二叉排序树、平衡二叉树、红黑树、B-树、B+树、键树。</p>
<h5 id="Ⅰ-二叉排序树-Binary-Sort-Tree"><a href="#Ⅰ-二叉排序树-Binary-Sort-Tree" class="headerlink" title="Ⅰ 二叉排序树(Binary Sort Tree)"></a>Ⅰ 二叉排序树(Binary Sort Tree)</h5><p><strong>(1) 定义</strong></p>
<p>二叉排序树或是空树，或是满足如下性质的二叉树：</p>
<p>(1) 若其左子树非空，则左子树上所有结点的值均小于根结点的值；<br>(2) 若其右子树非空，则右子树上所有结点的值均大于等于根结点的值；<br>(3) 其左右子树本身又各是一棵二叉排序树。</p>
<p><img src="https://pic.imgdb.cn/item/6699c220d9c307b7e976c054.png" style="zoom:50%"></p>
<p><strong>二叉排序树的性质</strong>：<strong>中序遍历</strong>非空的二叉排序树所得到的数据元素序列是一个按关键字排列的<strong>递增有序</strong>序列。</p>
<p><strong>(2) 查找操作</strong></p>
<p>【算法步骤】</p>
<ul>
<li>若查找的关键字等于根结点，成功；</li>
<li>否则：<ul>
<li>若小于根结点，查其左子树</li>
<li>若大于根结点，查其右子树</li>
<li>在左右子树上的操作类似</li>
</ul>
</li>
</ul>
<p>【二叉排序树的递归查找】</p>
<ul>
<li>若二叉排序树为空，则查找失败，返回空指针。</li>
<li>若二叉排序树非空，将给定值<code>key</code>与根结点的关键字<code>T-&gt;data.key</code>进行比较：<ul>
<li>① 若<code>key == T-&gt;data.key</code>，则査找成功，返回根结点地址；</li>
<li>② 若<code>key &lt;  T-&gt;data.key</code>，则进一步查找左子树；</li>
<li>③ 若<code>key &gt; T-&gt;data.key</code>，则进一步査找右子树。</li>
</ul>
</li>
</ul>
<p>【存储结构】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KerType key;	<span class="comment">// 关键字项</span></span><br><span class="line">    InfoType otherinfo;	<span class="comment">// 其他数据域</span></span><br><span class="line">&#125;ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;	<span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTnode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span>	<span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归查找</span></span><br><span class="line"><span class="function">BSTree <span class="title">SearchBsT</span><span class="params">(BSTree T, KeyType key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (!T) || key==T-&gt;data.key) </span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;lchild, key);	<span class="comment">// 在左子树中继续査找</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBST</span>(T-&gt;rchild, key); 	<span class="comment">// 在右子树中继续査找</span></span><br><span class="line">&#125; <span class="comment">// SearchBST</span></span><br></pre></td></tr></table></figure>
<p><strong>分析易知</strong>：含有$n$个结点的二叉排序树的平均查找长度和树的形态有关。</p>
<p><strong>问题</strong>：如何提高形态不均衡的二又排序树的查找效率？</p>
<p><strong>解决办法</strong>：做“<strong>平衡化</strong>”处理，即尽量让二叉树的形状均衡！</p>
<p>【补充：二叉排序树的插入操作】</p>
<ul>
<li>若二叉排序树为空，则插入结点作为根结点插入到空树中；</li>
<li>否则，继续在其左、右子树上查找<ul>
<li>树中已有，不再插入；</li>
<li>树中没有，查找直至某个叶子结点的左子树或右子树为空为止，则插入结点应为该叶子结点的左孩子或右孩子</li>
</ul>
</li>
</ul>
<p>【补充：二叉排序树的生成操作】</p>
<p>从空树出发，经过一系列的查找、插入操作之后，可生成一颗二叉排序树。</p>
<p>一个无序序列可通过构造二叉排序树而变成一个有序序列。构造树的过程就是对无序序列进行排序的过程。</p>
<p>插入的结点均为叶子结点，故无需移动其他结点。相当于在有序序列上插入记录而无需移动其他记录。</p>
<p><strong>但是：关键字的输入顺序不同，建立的二叉排序树不同。</strong>如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/6699d051d9c307b7e984f964.png" style="zoom:50%"></p>
<p>【补充：二叉排序树的删除操作】</p>
<p>从二叉排序树中删除一个结点，不能把以该结点为根的子树都删去，只能删掉该结点，并且还应保证删除后所得的二叉树仍然满足二叉排序树的性质不变。</p>
<p>由于中序遍历二叉排序树可以得到一个递增有序的序列。那么，在叉排序树中删去一个结点相当于删去有序序列中的一个结点。</p>
<ul>
<li>将因删除结点而断开的二又链表重新链接起来；</li>
<li>防止重新链接后树的高度增加；</li>
</ul>
<p><strong>第一种情况</strong>：被删除的结点是叶子结点</p>
<p>操作方法：直接删去该结点。</p>
<p><strong>第二种情况</strong>：被删除的结点只有左子树或者只有右子树</p>
<p>操作方法：用其左子树或者右子树替换它(结点替换)，也即其双亲结点的相应指针域的值改为“指向被删除结点的左子树或右子树“。</p>
<p><strong>第三种情况</strong>：被删除的结点既有左子树，也有右子树。</p>
<p>操作方法：可以以其中序前趋值替换之(值替换)，然后再删除该前趋结点。前趋是左子树中最大的结点。也可以用其后继替换之，然后再删除该后继结点，后继是右子树中最小的结点。</p>
<p><img src="https://pic.imgdb.cn/item/6699cf92d9c307b7e98445fc.png" style="zoom:50%"></p>
<h5 id="Ⅱ-平衡二叉树AVL"><a href="#Ⅱ-平衡二叉树AVL" class="headerlink" title="Ⅱ 平衡二叉树AVL"></a>Ⅱ 平衡二叉树AVL</h5><p><img src="https://pic.imgdb.cn/item/6699d25bd9c307b7e9873264.png" style="zoom:50%"></p>
<p>问题：如何提高形态不均衡的二又排序树的查找效率？</p>
<p><strong>解决办法</strong>：做“平衡化”处理，即尽量让二又树的形态均衡！$\Longrightarrow$ <strong>平衡二叉树</strong>。</p>
<p><strong>(1) 定义</strong></p>
<p>平衡二叉树(balanced binary tree)又称AVL树(Adelson-Velskii and Landis)。</p>
<p>一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：① 左子树与右子树的高度之差的<strong>绝对值小于等于1</strong>；② 左子树和右子树也是<strong>平衡二叉排序树</strong>。</p>
<p>为了方便起见，给每个结点<strong>附加一个数字</strong>，<u>给出该结点左子树一右子树的高度差</u>。这个数字称为结点的平衡因子BF)：</p>
<script type="math/tex; mode=display">
平衡因子\text{BF} = 结点左子树的高度-结点右子树的高度</script><p>根据平衡二叉树的定义，平衡二叉树上所有结点的平衡因子只能是：$0$、$1$或$-1$。</p>
<p><img src="https://pic.imgdb.cn/item/6699d586d9c307b7e98a8d71.png" style="zoom:50%"></p>
<p>对于一棵有$n$个结点的AVL树，其高度保持在$O(\log_2 n)$量级，ASL也保持在$O(\log_2 n)$数量级。</p>
<p><img src="https://pic.imgdb.cn/item/6699d89fd9c307b7e98f079e.png" style="zoom:50%"></p>
<p><strong>(2) 失衡二叉树的平衡调整</strong></p>
<p><img src="https://pic.imgdb.cn/item/6699da4dd9c307b7e990d6d8.png"></p>
<p>调整原则：1) 降低高度； 2）保持二叉排序树性质。</p>
<ul>
<li><strong>LL型调整</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6699dcd4d9c307b7e9938d0d.png"></p>
<ul>
<li><strong>RR型调整</strong></li>
</ul>
<p>这里就不贴全图了，RR型的思想本质和LL一样，只是位置正好相反而已。</p>
<p><img src="https://pic.imgdb.cn/item/669a0af9d9c307b7e9bb3bf2.png" style="zoom:60%"></p>
<p>① B结点带右子树β一起上升；② A结点成为B的左孩子；③ 原来B结点的左子树α作为A的右子树。</p>
<ul>
<li><strong>LR型调整</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/669a0da9d9c307b7e9bd5af5.png"></p>
<ul>
<li><strong>RL型调整</strong></li>
</ul>
<p>这里就不贴全图了，RL型的思想本质和LR一样，只是位置正好相反而已。</p>
<h4 id="7-4-哈希表-散列表"><a href="#7-4-哈希表-散列表" class="headerlink" title="7.4 哈希表/散列表"></a>7.4 哈希表/散列表</h4><h5 id="Ⅰ-散列表的概念"><a href="#Ⅰ-散列表的概念" class="headerlink" title="Ⅰ 散列表的概念"></a>Ⅰ 散列表的概念</h5><p><strong>(1) 基本概念</strong></p>
<p>基本思想：记录的存储位置与关键字之间存在对应关系。</p>
<p>对应关系——<strong>hash函数H(·)</strong>。</p>
<script type="math/tex; mode=display">
Loc(i)=H(key_i)</script><p>例如，构造下图所示的hash函数，其映射关系为：学号后两位 → 索引地址。</p>
<p><img src="https://pic.imgdb.cn/item/669a10c0d9c307b7e9c12362.png" style="zoom:60%"></p>
<p>优点：查找效率高；缺点：空间效率低。</p>
<p><strong>(2) 相关术语</strong></p>
<p><strong>散列方法(杂凑法)</strong>：选取某个函数，依该函数按关键字<u>计算元素的存储位置</u>，并按此存放，查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。</p>
<p><strong>散列函数(杂凑函数)</strong>：散列方法中使用的转换函数——<strong>hash函数H(·)</strong>。</p>
<p><strong>散列表(杂凑表)</strong>：按上述思想构造的表。</p>
<p><strong>冲突</strong>：不同的关键码映射到同一个散列地址，即$key_1 \neq key_2$，但是$H(key_1)=H(key_2)$。</p>
<p><strong>同义词</strong>：具有相同函数值的多个关键字。</p>
<p><strong>(3) 注意事项</strong></p>
<p>使用散列表要解决好两个问题：</p>
<p>1) 构造好的散列函数$H(·)$：(a) 所选函数尽可能简单，以便提高转换速度；(b) 所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费。<br>2) 制定一个好的解决冲突的方案：查找时，如果从散列函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其它相关单元。</p>
<h5 id="Ⅱ-散列函数的构造方法"><a href="#Ⅱ-散列函数的构造方法" class="headerlink" title="Ⅱ 散列函数的构造方法"></a>Ⅱ 散列函数的构造方法</h5><p><strong>(1) 构造散列函数考虑的因素</strong></p>
<p>① 执行速度(即计算散列函数所需时间)；<br>② 关键字的长度；<br>③ 散列表的大小；<br>④ 关键字的分布情况；<br>⑤ 查找频率。</p>
<ul>
<li>根据元素集合的特性构造<ul>
<li><strong>要求一</strong>：n个数据原仅占用n个地址，虽然散列查找是以空间换时间，但仍希望散列的地址空间尽量小。</li>
<li><strong>要求二</strong>：无论用什么方法存储，目的都是尽量均匀地存放元素，以避免冲突。</li>
</ul>
</li>
<li>常用的方法：1.直接定址法；2.数字分析法；3.平方取中法；4.折叠法；5.除留余数法；6.随机数法。</li>
</ul>
<p><strong>(2) 直接定址法</strong></p>
<script type="math/tex; mode=display">
H(key) = a*key+b（a、b为常数）</script><p>优点：以关键码key的某个线性函数值为散列地址，不会产生冲突。</p>
<p>缺点：要占用连续地址空间，空间效率低。</p>
<p><strong>(3) 除留余数法</strong></p>
<script type="math/tex; mode=display">
H(key) = key ~\text{ mod } ~ p（p是整数）</script><p>$p$选取的一个技巧：设表长为$m$，取 $p≤m$ 且为<strong>质数</strong>。</p>
<h5 id="Ⅲ-处理冲突的方法"><a href="#Ⅲ-处理冲突的方法" class="headerlink" title="Ⅲ 处理冲突的方法"></a>Ⅲ 处理冲突的方法</h5><ul>
<li><strong>常见的方法</strong><ul>
<li>开放定址法(开地址法)</li>
<li>链地址法(拉链法)</li>
<li>再散列法(双散列函数法)</li>
<li>建立一个公共溢出区</li>
</ul>
</li>
</ul>
<p><strong>(1) 开放定址法</strong></p>
<p>基本思想：有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入。</p>
<p><img src="https://pic.imgdb.cn/item/669a5519d9c307b7e905364a.png" style="zoom:50%"></p>
<ul>
<li><strong>线性探测法</strong></li>
</ul>
<script type="math/tex; mode=display">
H_i = [H(key) + d_i ] ~ \text{ mod }~ m</script><p>其中，$m$为散列表长度，$d_i$为线性增量序列。该方法一旦冲突，就找下一个地址，直到找到空地址存入。</p>
<p><img src="https://pic.imgdb.cn/item/669a583dd9c307b7e90a47f0.png" style="zoom:70%"></p>
<ul>
<li><strong>二次探测法</strong></li>
</ul>
<script type="math/tex; mode=display">
H_i = [H(key) + d_i ] ~ \text{ mod }~ m</script><p>其中，$m$为散列表长度，m要求是某个$4k+3$的质数，$d_i = 1^2, -1^2, 2^2, -2^2, \cdots, q^2, -q^2$。</p>
<p><strong>(2) 链地址法(拉链法)</strong></p>
<p><strong>基本思想</strong>：相同散列地址的记录链成一单链表。</p>
<p>m个散列地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。</p>
<p><img src="https://pic.imgdb.cn/item/669a5acfd9c307b7e90d896f.png" style="zoom:70%"></p>
<ul>
<li>链地址法建立散列表步骤<ul>
<li><code>Step1</code>：取数据元素的关键字<code>key</code>，计算其散列函数值(地址)。若该地址对应的链表为空，则将该元素插入此链表；否则执行<code>Step2</code>解决冲突。</li>
<li><code>Step2</code>：根据选择的冲突处理方法，计算关键字<code>key</code>的下一一个存储地址。若该地址对应的链表为不为空，则利用链表的前插法或后插法将该元素插入此链表。</li>
</ul>
</li>
</ul>
<h5 id="Ⅳ-散列表的查找"><a href="#Ⅳ-散列表的查找" class="headerlink" title="Ⅳ 散列表的查找"></a>Ⅳ 散列表的查找</h5><p><img src="https://pic.imgdb.cn/item/669a5f37d9c307b7e9133676.png" style="zoom:50%"></p>
<ul>
<li><strong>几点结论</strong><ul>
<li>散列表技术具有很好的平均性能，优于一些传统的技术；</li>
<li>链地址法优于开地址法；</li>
<li>除留余数法作散列函数优于其它类型函数。</li>
</ul>
</li>
</ul>
<h3 id="sect-8-排序操作"><a href="#sect-8-排序操作" class="headerlink" title="&sect; 8 排序操作"></a>&sect; 8 排序操作</h3><h5 id="Ⅰ-排序算法的基本介绍"><a href="#Ⅰ-排序算法的基本介绍" class="headerlink" title="Ⅰ 排序算法的基本介绍"></a>Ⅰ 排序算法的基本介绍</h5><p><strong>排序</strong>：将一组杂乱无章的数据按一定规律顺次排列起来。即，将无序序列排成一个有序序列(由小到大或由大到小)的运算。</p>
<blockquote>
<p>如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个域而言。</p>
</blockquote>
<ul>
<li><p><strong>排序方法的分类</strong></p>
<ul>
<li>按数据存储介质：内部排序和外部排序</li>
<li>按比较器个数：串行排序和并行排序</li>
<li>按主要操作：比较排序和基数排序</li>
<li>按辅助空间：原地排序和非原地排序</li>
<li>按稳定性：稳定排序和非稳定排序</li>
<li>按自然性：自然排序和非自然排序</li>
</ul>
<p><strong>(1) 按存储介质</strong></p>
</li>
</ul>
<p>内部排序：数据量不大、数据在内存，无需内外存交换数据；</p>
<p>外部排序：数据量较大、数据在外存(文件排序)。</p>
<blockquote>
<p>外部排序时，要将数据分批调入内存来排序，中间结果还要及时放入外存，显然外部排序要复杂得多。</p>
</blockquote>
<p><strong>(2) 按比较器个数</strong></p>
<p>串行排序：单处理机(同一时刻比较一对元素)；</p>
<p>并行排序：多处理机(同一时刻比较多对元素)。</p>
<p><strong>(3) 按主要操作</strong></p>
<p>比较排序：用比较的方法，例如：插入排序、交换排序、选择排序、归并排序；</p>
<p>基数排序：不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。</p>
<p><strong>(4) 按辅助空间</strong></p>
<p>原地排序：辅助空间用量为$O(1)$的排序方法。(所占的辅助存储空间与参加排序的数据量大小无关)</p>
<p>非原地排序：辅助空间用量超过$O(1)$的排序方法。</p>
<p><strong>(5) 按稳定性</strong></p>
<p>稳定排序：能够使任何数值相等的元素，排序以后相对次序不变；</p>
<p>非稳定性排序：不是稳定排序的方法。</p>
<p><img src="https://pic.imgdb.cn/item/669b7d74d9c307b7e9535421.png" style="zoom:60%"></p>
<p>排序的稳定性只对<strong>结构类型数据</strong>排序有意义。例如下面这种情况：</p>
<p>n个学生信息(学号、姓名、语文、数学、英语、总分)</p>
<p>1、按数学成绩从高到低排序<br>2、按照总分从高到低排序,<br>3、总分相同的情况下，数学成绩高的排在前面</p>
<p><strong>(6) 按自然性</strong></p>
<p>自然排序：输入数据越有序，排序的速度越快的排序方法。</p>
<p>非自然排序：不是自然排序的方法。</p>
<p><img src="https://pic.imgdb.cn/item/669b7f52d9c307b7e9560663.png" style="zoom:50%"></p>
<ul>
<li><strong>顺序表存储结构</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20	<span class="comment">// 设记录不超过20个</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;	<span class="comment">// 设关键字为整型量(int型)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义每个记录(数据元素)的结构======================================</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key ;	<span class="comment">// 关键字</span></span><br><span class="line">    InfoTypeother info;	<span class="comment">// 其它数据项</span></span><br><span class="line">&#125;RedType;	<span class="comment">//Record Type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义顺序表的结构=================================================</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    RedType r[ MAXSIZE +<span class="number">1</span> ];	<span class="comment">// 存储顺序表的向量</span></span><br><span class="line">    						  <span class="comment">// r[0]一般作哨兵或缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> length ;	<span class="comment">// 顺序表的长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-插入排序概述"><a href="#Ⅱ-插入排序概述" class="headerlink" title="Ⅱ 插入排序概述"></a>Ⅱ 插入排序概述</h5><p>【<strong>基本思想</strong>】每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止。</p>
<blockquote>
<p>即边插入边排序，保证子序列中随时都是排好序的。</p>
</blockquote>
<p>【<strong>基本操作</strong>】有序插入</p>
<p>在有序序列中插入一个元素，保持序列有序，有序长度不断增加。</p>
<ol>
<li>起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。</li>
<li>在插入a[i]前，数组a的前半段(a[0]—a[i-1])是有序段，后半段(a[i]—a[n-1])是停留于输入次序的“无序段”；</li>
<li>插入a[i]使a[0]—a[i-1]有序，也就是要为a[i]找到有序位置$j(0≤j≤i)$，将a[i]插入在a[j]的位置上。</li>
</ol>
<p>【<strong>插入排序的分类</strong>】</p>
<p><img src="https://pic.imgdb.cn/item/669b837cd9c307b7e95c1244.png" style="zoom:70%"></p>
<h5 id="Ⅲ-插入排序——直接插入排序"><a href="#Ⅲ-插入排序——直接插入排序" class="headerlink" title="Ⅲ 插入排序——直接插入排序"></a>Ⅲ 插入排序——直接插入排序</h5><p>直接插入排序——采用顺序查找法查找插入位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接插入排序为减少一次比较，采用了“哨兵”，存在开头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">( SqList&amp; L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">2</span>; i&lt;=L.length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.r[i].key &lt; L.r[i<span class="number">-1</span>].key)	<span class="comment">// 若&quot;&lt;&quot;,需将L.r[i]插入有序子表</span></span><br><span class="line">        &#123; </span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];	<span class="comment">// 复制为哨兵</span></span><br><span class="line">            <span class="keyword">for</span> ( j=i<span class="number">-1</span>; L.r[<span class="number">0</span>].key&lt;L.r[j].key; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                L.r[j+<span class="number">1</span>]=L.[r];	<span class="comment">// 记录后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j+<span class="number">1</span>]=L.r[<span class="number">0</span>];	<span class="comment">// 插入到正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【<strong>时间复杂度结论</strong>】</p>
<ol>
<li>原始数据越接近有序，排序速度越快<br>a. 最坏情况下(输入数据是逆有序的)：$Tw(n)=O(n^2)$<br>b. 平均情况下，耗时差不多是最坏情况的一半：$Te(n)=O(n^2)$</li>
<li>要提高查找速度：① 减少元素的比较次数；② 减少元素的移动次数。</li>
</ol>
<h5 id="Ⅳ-插入排序——折半插入排序"><a href="#Ⅳ-插入排序——折半插入排序" class="headerlink" title="Ⅳ 插入排序——折半插入排序"></a>Ⅳ 插入排序——折半插入排序</h5><p><img src="https://pic.imgdb.cn/item/669b8a57d9c307b7e963f6a3.png" style="zoom:70%"></p>
<p>其本质思想来自：第7章节的折半查找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(SqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=L.length; ++i)	<span class="comment">// 依次插入第2~第n个元素</span></span><br><span class="line">    &#123; </span><br><span class="line">        L.r[<span class="number">0</span>]= L.r[i];	<span class="comment">// 当前插入元素存到“哨兵”位置</span></span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> high=i<span class="number">-1</span>;	<span class="comment">// 采用二分查找法查找插入位置</span></span><br><span class="line">        <span class="keyword">while</span> ( low &lt;= high )</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( L.r[<span class="number">0</span>].key &lt; L.r[mid].key )</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="comment">//循环结束，high+1则为插入位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;=high+<span class="number">1</span>; --j)</span><br><span class="line">            L.r[j+<span class="number">1</span>] = L.r[j];	<span class="comment">// 移动元素</span></span><br><span class="line">        L.r[high+<span class="number">1</span>] = L.r[<span class="number">0</span>];	<span class="comment">// 插入到正确位置</span></span><br><span class="line">&#125; <span class="comment">// BInsertSort</span></span><br></pre></td></tr></table></figure>
<p>【<strong>复杂度简要结论</strong>】</p>
<ol>
<li>折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的们排列；</li>
<li>减少了比较次数，但没有减少移动次数；</li>
<li>平均性能优于直接插入排序。</li>
</ol>
<h5 id="Ⅴ-插入排序——希尔排序"><a href="#Ⅴ-插入排序——希尔排序" class="headerlink" title="Ⅴ 插入排序——希尔排序"></a>Ⅴ 插入排序——希尔排序</h5><p>【<strong>基本思想</strong>】</p>
<p>先将整个待排记录序列分割成<strong>若干子序列</strong>，分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。</p>
<p><img src="https://pic.imgdb.cn/item/669c6290d9c307b7e92aaf4a.png"></p>
<p>【<strong>希尔排序思路</strong>】</p>
<ol>
<li>定义增量序列$D_k$：$D_M&gt;D_{M-1}&gt;…&gt;D_1=1$；<br>刚才的例子中：$D_3=5，D_2=3，D_1=1$</li>
<li>对每个$D_k$进行“Dκ-间隔”插入排序($k=M, M-1, …, 1$)。</li>
</ol>
<p>【<strong>希尔排序特点</strong>】</p>
<ol>
<li>一次移动，移动位置较大，跳跃式地接近排序后的最终位置；</li>
<li>最后一次只需要少量移动；</li>
<li>增量序列必须是递减的，最后一个必须是1；</li>
<li>增量序列应该是<strong>互质</strong>的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对顺序表L进行一趟增量为dk的Shell排序，dk为步长因子</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=dk+<span class="number">1</span>; i&lt;=L.length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key &lt; L.r[i-dk].key) </span><br><span class="line">        &#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-dk; j&gt;<span class="number">0</span> &amp;&amp;(L.r[<span class="number">0</span>].key&lt;L.r[j].key); j=j-dk)</span><br><span class="line">                L.r[j+dk]=L.r[j];</span><br><span class="line">            L.r[j+dk]=L.r[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(Sqlist&amp; L, <span class="keyword">int</span> dltal[], <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 按增量序列dlta[0...t-1]对顺序表L作希尔排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;t; ++k)</span><br><span class="line">        <span class="built_in">ShellInsert</span>(L，dlta[k]);	<span class="comment">// 一趟增量为dlta[k]的插入排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【<strong>希尔排序算法分析</strong>】</p>
<ol>
<li>希尔排序算法效率与增量序列的取值有关<ol>
<li>一种常用的增量序列：<strong>Hibbard增量序列</strong>：$D_k=2^{k-1}$—相邻元素互质，其最坏情况：$T_{worst}=O(n^{3/2})$，猜想平均情况：$T_{avg}=O(n^{5/4})$。</li>
<li>另一种常用增量序列：<strong>Sedgewick增量序列</strong>。</li>
</ol>
</li>
<li>希尔排序法是一种<u>不稳定</u>的排序算法。</li>
<li>空间复杂度：$O(1)$。</li>
<li>不宜在链式存储结构上实现。</li>
</ol>
<h5 id="Ⅵ-交换排序——冒泡排序"><a href="#Ⅵ-交换排序——冒泡排序" class="headerlink" title="Ⅵ 交换排序——冒泡排序"></a>Ⅵ 交换排序——冒泡排序</h5><p>【<strong>基本思想</strong>】两两比较，如果发生逆序则交换，直到所有记录都排好序为止。</p>
<p>【<strong>冒泡排序基本思想</strong>】基于简单交换思想，每趟不断将记录两两比较，并按“前小后大”规则交换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(SqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, j;</span><br><span class="line">    <span class="keyword">int</span> n = L.length;</span><br><span class="line">    RedType x;	<span class="comment">// 交换时临时存储</span></span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;=n<span class="number">-1</span>; m++)	<span class="comment">// 总共需m趟</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=n-m; j++)</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key&gt;L.r[j+<span class="number">1</span>].key)	<span class="comment">// 发生逆序</span></span><br><span class="line">            &#123;</span><br><span class="line">                x=L.r[j]; </span><br><span class="line">                L.r[j]=L.r[j+<span class="number">1</span>];</span><br><span class="line">                L.r[j+<span class="number">1</span>]=x; <span class="comment">//交换</span></span><br><span class="line">            &#125; <span class="comment">//endif</span></span><br><span class="line">    &#125; <span class="comment">//for</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ⅶ-交换排序——快速排序"><a href="#Ⅶ-交换排序——快速排序" class="headerlink" title="Ⅶ 交换排序——快速排序"></a>Ⅶ 交换排序——快速排序</h5><ul>
<li>【<strong>基本思想</strong>】：递归思想<ul>
<li>任取一个元素 (如：第一个)为中心；</li>
<li>所有比它小的元素一律前放，比它大的元素一律后放，形成左右两个子表；</li>
<li>对各子表重新选择中心元素并依此规则调整；</li>
<li>直到每个子表的元素只剩一个。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/669c6d23d9c307b7e934b5f5.png" style="zoom:40%"></p>
<ul>
<li>【<strong>快速排序的特点</strong>】<ul>
<li>① 每一趟的子表的形成是采用从两头向中间交替式逼近法，</li>
<li>② 由于每趟中对各子表的操作都相似，可采用<strong>递归算法</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span> <span class="params">( SqList&amp; L, <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.r[<span class="number">0</span>]= L.r[low];</span><br><span class="line">    pivotkey = L.r[low].key;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey)</span><br><span class="line">            --high;</span><br><span class="line">        L.r[low] = L.r[high];</span><br><span class="line">        <span class="keyword">while</span> ( low &lt; high &amp;&amp; L.r[low].key &lt;= pivotkey )</span><br><span class="line">            ++low;</span><br><span class="line">        L.r[high]= L.r[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L.r[low]=L.r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对顺序表L快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)	<span class="comment">// 长度大于1</span></span><br><span class="line">    &#123; </span><br><span class="line">        pivotloc = <span class="built_in">Partition</span>(L, low, high);	<span class="comment">// 将L.r[low, high]一分为二，pivotloc为枢轴元素排好序的位置</span></span><br><span class="line">        <span class="built_in">QSort</span>(L, low, pivotloc<span class="number">-1</span>);	<span class="comment">// 对低子表递归排序</span></span><br><span class="line">        <span class="built_in">QSort</span>(L, pivotloc+<span class="number">1</span>, high);	<span class="comment">// 对高子表递归排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// QSort</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Qsort</span>(L, <span class="number">1</span>, L.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【<strong>快速排序复杂度分析</strong>】</p>
<p>时间复杂度：可以证明，平均计算时间是$O(n \log_2 n)$。</p>
<blockquote>
<p>实验结果表明：就平均计算时间而言，快速排序是我们所讨论的所有内排序分法中最好的一个。</p>
</blockquote>
<p>空间复杂度：快速排序不是原地排序<br>由于程序中使用了递归，需要递归调用栈的支持，而栈的长度取决于递归调用的深度。(即使不用递归，也需要用用户栈)。在平均情况下：需要$O(\log n)$的栈空间；最坏情况下：栈空间可达$O(n)$。</p>
<p>稳定性：快速排序是一种不稳定的排序方法。</p>
<p>自然性：输入数据次序越乱，所选划分元素值的随机性越好，排序速度越快，快速排序不是自然排序方法。</p>
<h5 id="Ⅷ-选择排序——简单选择排序"><a href="#Ⅷ-选择排序——简单选择排序" class="headerlink" title="Ⅷ 选择排序——简单选择排序"></a>Ⅷ 选择排序——简单选择排序</h5><p>【<strong>基本思想</strong>】在待排序的数据中选出最大(小)的元素放在其最终的位置。</p>
<ul>
<li>【<strong>基本操作</strong>】<ul>
<li>首先，通过$n-1$次关键字比较，从$n$个记录中找出关键字最小的记录，将它与第1个记录交换；</li>
<li>其次，通过$n-2$次比较，从剩余的$n-1$个记录中找出关键字次小的记录，将它与第2个记录交换；</li>
<li>重复上述操作，共进行$n-1$趟排序后，排序结束。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/669c7695d9c307b7e93c453a.png" style="zoom:60%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(SqList&amp; k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;L.length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        k=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=L.length; j++)</span><br><span class="line">            <span class="keyword">if</span>( L.r[j].key &lt; L.r[k].key)	<span class="comment">// 记录最小值位置</span></span><br><span class="line">                k=j;	</span><br><span class="line">        <span class="keyword">if</span>(k!=i)	<span class="comment">// 交换</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = L.r[i];</span><br><span class="line">            L.r[i] = L.r[k];</span><br><span class="line">            L.r[k] = temp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【<strong>简单选择排序复杂度分析</strong>】</p>
<p>时间复杂度：</p>
<ol>
<li>记录移动次数<br>最好情况为0，最坏情况为$3(n-1)$</li>
<li>比较次数<br>无论待排序列处于什么状态，选择排序所需进行的”比较”次数都相同</li>
<li>算法稳定性<br>简单选择排序是不稳定排序，但是可以稳定化。</li>
</ol>
<h5 id="Ⅸ-选择排序——堆排序"><a href="#Ⅸ-选择排序——堆排序" class="headerlink" title="Ⅸ 选择排序——堆排序"></a>Ⅸ 选择排序——堆排序</h5><p><strong>(1) 堆的定义</strong></p>
<p>若$n$个元素的序列$(a_1, a_2, \cdots, a_n)$满足：</p>
<script type="math/tex; mode=display">
\begin{cases}
a_i \leq a_{2i} \\
a_i \leq a_{2i+1}
\end{cases}

\quad
\text{OR}
\quad

\begin{cases}
a_i \geq a_{2i} \\
a_i \geq a_{2i+1}
\end{cases}</script><p>则称该序列为<strong>小根堆</strong>$\text{ OR }$<strong>大根堆</strong>。</p>
<p>从堆的定义可以看出，堆实质是满足如下性质的<strong>完全二叉树</strong>：二叉树中任一非叶子结点均小于(大于)它的孩子结点。</p>
<p><strong>(2) 堆排序</strong></p>
<p>若在输出堆顶的最小值(最大值)后，使得剩余$n-1$个元素的序列重又建成一个堆，则得到$n$个元素的次小值(次大值)…如此反复，便能得到一个有序序列，这个过程称之为堆排序。</p>
<p>实现堆排序需解决两个问题：1、如何由一个无序序列建成一个堆；2、如何在输出堆顶元素后，调整剩余元素为一个新的堆?</p>
<p><strong>(3) 问题2：如何在输出堆顶元素后，调整剩余元素为一个新的堆?</strong></p>
<ul>
<li>对于小根堆：<ul>
<li><ol>
<li>输出堆顶元素之后，以堆中最后一个元素替代之；</li>
<li>然后将根结点值与左、右子树的根结点值进行比较，并与其中<strong>小者</strong>进行交换；</li>
<li>重复上述操作，直至叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为“<strong>筛选</strong>”。</li>
</ol>
</li>
</ul>
</li>
<li>对于大根堆：与小根堆相反。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/669cafaed9c307b7e971ba66.png" alt="小根堆调整示例"></p>
<p>【<strong>筛选过程</strong>】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">已知R[s..m]中记录的关键字除R[S]之外均满足堆的定义，</span></span><br><span class="line"><span class="comment">本函数调整R[S]的关键字，使R[s..m]成为一个大根堆</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span> <span class="params">(elem R[], <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rc = R[s];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*s; j&lt;=m; j*=<span class="number">2</span>)	<span class="comment">// 沿key较大的孩子结点向下筛选</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m &amp;&amp; R[j]&lt; R[j+<span class="number">1</span>])</span><br><span class="line">            ++j;	<span class="comment">// j为key较大的记录的下标</span></span><br><span class="line">        <span class="keyword">if</span>( rc &gt;= R[j]) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        R[s] = R[j];	<span class="comment">// rc应插入在位置s上</span></span><br><span class="line">        s = j;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    R[s]= rc;	<span class="comment">// 插入</span></span><br><span class="line">&#125;<span class="comment">// HeapAdjust</span></span><br></pre></td></tr></table></figure>
<p><strong>(4) 问题1：如何由一个无序序列建成一个堆？</strong></p>
<p>显然：单结点的二叉树是堆；在完全二叉树中所有以叶子结点(序号i&gt;n/2)为根的子树是堆。</p>
<p>这样，我们只需依次将以序号为$n/2, n/2-1, …, 1$的结点为根的子树均调整为堆即可。即：对应由$n$个元素组成的无序序列，“筛选”只需从第$n/2$个元素开始。</p>
<p>由于堆实质上是一个线形表，那么我们可以顺序存储一个堆。</p>
<p>下面以一个实例介绍建一个小根堆的过程。例：有关键字为49，38，65，97，76，13，27，49的一组记录，将其按关键字调整为一个小根堆。</p>
<p><img src="https://pic.imgdb.cn/item/669cb952d9c307b7e97b9fb1.png"></p>
<p>由以上分析知：</p>
<p>若对一个无序序列建堆，然后输出根；重复该过程就可以由一个无需序列输出有序序列。<br>实质上，<u>堆排序就是利用完全二叉树中父结点与孩子结点之间的内在关系来排序的</u>。</p>
<p>【<strong>堆排序算法如下</strong>】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对R[1]到R[n]进行堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(elem R[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>( i=n/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">        <span class="built_in">HeapAdjust</span>(R,i,n);	<span class="comment">// 建初始堆</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( i=n; i&gt;<span class="number">1</span>; i--)	<span class="comment">// 进行n-1趟排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Swap</span>(R[<span class="number">1</span>]，R[i]);	<span class="comment">// 根与最后一个元素交换</span></span><br><span class="line">        <span class="built_in">HeapAdjust</span>(R, <span class="number">1</span>, i<span class="number">-1</span>);	<span class="comment">// 对R[1]到R[i -1]重新建堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HeapSort</span></span><br></pre></td></tr></table></figure>
<p>【<strong>堆排序算法复杂度</strong>】</p>
<h5 id="Ⅹ-归并排序"><a href="#Ⅹ-归并排序" class="headerlink" title="Ⅹ 归并排序"></a>Ⅹ 归并排序</h5><p>【<strong>基本思想</strong>】将两个或两个以上的有序子序列，“归并/合并”为一个有序序列。</p>
<p>在内部排序中，通常采用的是<strong>2-路归并排序</strong>，即：将两个位置相邻的有序子序列$R[1 \sim m]$和$R[m+1 \sim n]$归并为一个有序序列$R[1 \sim n]$。</p>
<p><img src="https://pic.imgdb.cn/item/669cbe01d9c307b7e9800f91.png" alt="2-路归并排序示例" style="zoom:30%"></p>
<p>关键问题：如何将两个有序序列合成一个有序序列?</p>
<p>这个问题其实在第2章线性表的时候已经学过了，过程可用下图示例。</p>
<p><img src="https://pic.imgdb.cn/item/669cc14cd9c307b7e9845f97.png" style="zoom:40%"></p>
<p><img src="https://pic.imgdb.cn/item/669cc1f3d9c307b7e984f7d9.png" alt="归并排序中的有序表合并" style="zoom:40%"></p>
<h5 id="Ⅺ-基数-桶-箱-排序"><a href="#Ⅺ-基数-桶-箱-排序" class="headerlink" title="Ⅺ 基数(桶/箱)排序"></a>Ⅺ 基数(桶/箱)排序</h5><p>【<strong>基本思想</strong>】分配+收集</p>
<p>也叫桶排序或箱排序：设置若干个箱子，将关键字为$k$的记录放入第$k$个箱然后在按序号将非空的连接。</p>
<p>【<strong>前提条件</strong>】数字是有范围的</p>
<p>均由0-9这十个数字组成，则只需设置十个箱子，相继按个、十、百….进行排序。</p>
<p>一副扑克牌，有4种花色，每种花色有13张牌，利用桶排序可以：<code>Step 1</code>先准备4个桶，将牌分成4种花色；<code>Step 2</code>再准备13个桶，将13张牌排序。也即：桶排序适合多关键字排序。</p>
<ul>
<li><strong>各种排序方法比较</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66b8a13dd9c307b7e97c66e2.png"></p>
<h3 id="补充1（不系统）：动态规划"><a href="#补充1（不系统）：动态规划" class="headerlink" title="补充1（不系统）：动态规划"></a>补充1（不系统）：动态规划</h3><p>首先我们来看一个经典的动态规划问题：</p>
<p>给你一个无序的数组nums = [1，5，2，4，3]，要求我们找出其中最长的递增的子序列（比如这里的 1,2,4 就是其中的一个，1,2,3 是另外一个答案）。这里我们再对这个问题做一些简化，我们要求这个算法只返回最长序列的“长度”就好了（也即3）</p>
<p>解决这道题，最容易想到的办法是<strong>暴力枚举</strong>/或者叫暴力搜索</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>文献数据库基础知识</title>
    <url>/2022/06/26/Database-knowledge/</url>
    <content><![CDATA[<h3 id="1-国际知名的权威学术出版社-会议组织者"><a href="#1-国际知名的权威学术出版社-会议组织者" class="headerlink" title="1 国际知名的权威学术出版社/会议组织者"></a>1 国际知名的权威学术出版社/会议组织者</h3><h4 id="1-1-IEEE-Institute-of-Electrical-and-Electronics-Engineering"><a href="#1-1-IEEE-Institute-of-Electrical-and-Electronics-Engineering" class="headerlink" title="1.1 IEEE(Institute of Electrical and Electronics Engineering)"></a>1.1 IEEE(Institute of Electrical and Electronics Engineering)</h4><ul>
<li>简介：IEEE是出版社和会议组织者，既组织学术会议，也出版学术期刊，IEEE出版社有自己出版的文献数据库，而网站IEEE Xplore就是查询该出版社文献数据库的入口。对应的(全文)文献数据库(查文献网址)：<a href="https://ieeexplore.ieee.org/Xplore/home.jsp">IEEE Xplore</a>。<h4 id="1-2-Springer-Springer-Verlag"><a href="#1-2-Springer-Springer-Verlag" class="headerlink" title="1.2 Springer(Springer-Verlag)"></a>1.2 Springer(Springer-Verlag)</h4></li>
<li>简介：德国斯普林格(Springer-Verlag)通过SpringerLink系统提供其学术期刊及电子图书的在线服务，该数据库包括了各类期刊、丛书、图书、参考工具书以及回溯文档。    对应的(全文)文献数据库(查文献网址)：<a href="https://link.springer.com/">SpringerLink</a>。<h4 id="1-3-Elsevier"><a href="#1-3-Elsevier" class="headerlink" title="1.3 Elsevier"></a>1.3 Elsevier</h4></li>
<li>简介：作为世界上最大的医学与其他科学文献出版商，爱思唯尔旗下出版2500余种期刊，包括具有高影响因子的《细胞》(《Cell》)和《柳叶刀》(《The Lancet》)这两大国际顶尖学术期刊。每年，爱思唯尔公司出版的期刊共发表约35万篇论文，同时爱思唯尔还提供世界最大的摘要和引文数据库Scopus。对应的(全文)文献数据库(查文献网址)：<a href="https://www.elsevier.com/solutions/sciencedirect">Elsevier</a>。<h4 id="1-4-Taylor-amp-Francis"><a href="#1-4-Taylor-amp-Francis" class="headerlink" title="1.4 Taylor &amp; Francis"></a>1.4 Taylor &amp; Francis</h4></li>
<li>简介：以出版科技书籍与参考书著称，在人类工程学、地理信息系统、建筑、土木工程、物理和生物技术等领域尤为突出。对应的(全文)文献数据库(查文献网址)：<a href="https://www.tandfonline.com/">Tandfonline</a>。</li>
</ul>
<h3 id="2-文摘-索引数据库"><a href="#2-文摘-索引数据库" class="headerlink" title="2 文摘/索引数据库"></a>2 文摘/索引数据库</h3><p>世界著名的三大期刊文献检索工具，SCI、EI、CPCI-S，它们也是国际公认的进行科学统计与科学评价的主要检索工具，其中 SCI 最为重要。<br>上面介绍了出版社和它们的文献数据库，现在说的 SCI、EI、CPCI-S 也是数据库，它们是引文数据库。文献数据库有该出版社的论文的全文，而引文数据库只有收录的文献的一些公开信息(题目、作者、摘要、参考文献等)。你在引文数据库只能找到论文的一些公开信息，想下载全文还得到出版社的文献数据库。<br><strong><font color="blue">引文数据库有点儿像豆瓣，我们能在豆瓣上看到某电影的相关信息，但要看电影还得跳到具体的视频网站(文献数据库)。</font></strong></p>
<blockquote>
<p>各出版社有了自己的文献数据库，为什么还要有引文数据库呢？<br>简单理解，这些出版社的文献的数据库是相互独立的，这时候用一种方法把它们整合到一起，在一个数据库就能搜到某一方向有哪些文献（各个出版社的）。但不是所有的出版社的都收录，不是每篇文献都有一样的权重，怎么整合需要采用一定的规则。比如SCI通过论文的被引用频次等的统计，对学术期刊和科研成果进行多方位的评价研究，从而评判一个国家或地区、科研单位、个人的科研产出绩效，来反映其在国际上的学术水平。被SCI收录的论文就称为SCI论文，被EI收录的论文称为EI论文。SCI一般会去收录高质量的期刊的文章，高质量的会议的文章，EI 会收录的更多一些，因为水平低一点的文章他也收录了。</p>
<h4 id="2-1-SCI-Science-Citation-Index"><a href="#2-1-SCI-Science-Citation-Index" class="headerlink" title="2.1 SCI(Science Citation Index)"></a>2.1 SCI(Science Citation Index)</h4><ul>
<li>简介：由美国科学信息研究所(ISI)1961年创办出版的引文数据库；SCI 既是检索工具，也是引文数据库。对应的引文数据库(查文献网址)：<a href="http://webofknowledge.com">Web Of Science</a>。</li>
<li>注意：SCIE 是 SCI 扩展版，二者在选刊上并没有什么本质的区别，只是收录的期刊数不同。随着网络版的普及，SCIE就是SCI，慢慢趋于通用，它们都是指Web of Science平台上的SCI-Expanded数据库，大学图书馆买的SCI数据库名称一般就为 SCI-E。<h4 id="2-2-EI-The-Engineering-Index"><a href="#2-2-EI-The-Engineering-Index" class="headerlink" title="2.2 EI(The Engineering Index)"></a>2.2 EI(The Engineering Index)</h4></li>
<li>简介：由美国工程信息公司出版，报道工程技术各学科的期刊、会议论文、科技报告等文献。对应的引文数据库(查文献网址)：<a href="https://www.engineeringvillage.com/">EngineeringVillage</a>。<h4 id="2-3-CPCI-Conference-Proceedings-Citation-Index"><a href="#2-3-CPCI-Conference-Proceedings-Citation-Index" class="headerlink" title="2.3 CPCI(Conference Proceedings Citation Index)"></a>2.3 CPCI(Conference Proceedings Citation Index)</h4></li>
<li>简介：汇集了世界上最新出版的会议录资料，包括专著、丛书、预印本以及来源于期刊的会议论文，提供了综合全面、多学科的会议论文资料，对应的引文数据库(查文献网址)：<a href="http://webofknowledge.com">Web Of Science</a>。<h4 id="2-4-国内外常见数据库"><a href="#2-4-国内外常见数据库" class="headerlink" title="2.4 国内外常见数据库"></a>2.4 国内外常见数据库</h4></li>
<li>外文引文数据库<ul>
<li>Science Citation Index, SCI</li>
<li>Social Sciences Citation Index, SSCI</li>
<li>Arts &amp; HumanitiesCitation Index, A&amp;HCI</li>
<li>Emerging Sources Citation Index</li>
<li>Conference Proceedings Citation Index, CPCI</li>
<li>The Engineering Index, EI</li>
<li>Chemical Abstracts, CA</li>
<li>JST(日本)、AJ(俄国)、ISR</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>中文引文数据库<ul>
<li>中国科学引文数据库, CSCD</li>
<li>中文社会科学引文索引, CSSCI, (南大核心)</li>
<li>中文核心期刊要目总览, (北大核心)</li>
<li>中国科技论文统计源期刊, CSTPCD</li>
<li>中国人文社会科学核心期刊, CHSSCD</li>
<li>中国人文社会科学核心期刊</li>
<li>中国核心期刊遴选数据库</li>
</ul>
</li>
</ul>
<h3 id="3-基础知识辨析"><a href="#3-基础知识辨析" class="headerlink" title="3 基础知识辨析"></a>3 基础知识辨析</h3><h4 id="3-1-会议组织者、出版商、科研工作者的关系"><a href="#3-1-会议组织者、出版商、科研工作者的关系" class="headerlink" title="3.1 会议组织者、出版商、科研工作者的关系"></a>3.1 会议组织者、出版商、科研工作者的关系</h4><p><strong>会议组织者：</strong>可能是某个学校；也可能是某个组织；他们为学术/经济利益举办会议，从科研工作者处收文章，收注册费；然后将论文集扔给出版商；<br><strong>出版商：</strong>具备一定声望，比如Elsevier/IEEE/Springer，其旗下有一些会议论文的项目，如Elsevier的Procedia(新推出的)，IEEE的Conference Program，Springer的Lecture Notes系列；<br>这些会议项目的共同特点是：<br>1.拿论文的版权；<br>2.向会议组织者收取出版费用(比如每100篇多少钱)；<br>3.会把论文放在自己的数据库里面，比如ScienceDirect，IEEExplorer等等；</p>
<blockquote>
<p><strong>收录：</strong>比如我建立起来了一个数据库叫 RabbitPaper，我可以自己抓取一些公开的数据，比如 IEEExplorer / Lecture Notes上面能找到的所有关于Rabbit的文章，我把所有的题目+摘要+参考文献，全扣下来放在我的数据库里面，那么我可以宣传说：我这个 Rabbit数据库里面收录了重要关于Rabbit的文献；<br>我不持有IEEExplorer / Lecture Notes的全文内容，只是抓取了公开的信息而已；</p>
<p><strong>检索：</strong>“检索”本身的意思是“在某个数据库里面发现某种内容”；检索工具有很多，Google/Google Scholar/Scirus/ScienceDirect/IEEExplorer/ISI这些都是检索工具；</p>
<ol>
<li>检索工具可能能帮你拿到论文的全文(比如Elsevier的Procedia的全文就是免费公开的，很方便下载)； </li>
<li>也可能不能帮你拿到全文(比如IEEExplorer是收费的，LNCS也是收费的)，需要有权限才能下载全文；<h4 id="3-2-SCI和EI是什么"><a href="#3-2-SCI和EI是什么" class="headerlink" title="3.2 SCI和EI是什么"></a>3.2 SCI和EI是什么</h4><h5 id="3-2-1-SCI是什么"><a href="#3-2-1-SCI是什么" class="headerlink" title="3.2.1 SCI是什么"></a>3.2.1 SCI是什么</h5>SCI(Science Citation Index)是ISI(Institute Scientific Information)做的数据库，其特点为：</li>
</ol>
<ul>
<li>SCI不是出版商，只是数据库，不是具体某篇文章内容版权的拥有者；所以在SCI里面，能看到只是题目+摘要+参考文献；</li>
<li>SCI自己有一个自己确定的期刊列表，SCI只是从出版商处抓取某些期刊的 论文里面的信息（题目/作者/摘要/参考文献），然后可能添加一些自己的信息，比如分类号一类的东西；</li>
<li>SCI的内容不是原始文献全文，卖点是每年推出JCR，里面给出影响因子。</li>
<li>“SCI全文收录”这个短语就是扯淡。。。因为SCI里面哪有全文啊。<h5 id="3-2-3-EI是什么"><a href="#3-2-3-EI是什么" class="headerlink" title="3.2.3 EI是什么"></a>3.2.3 EI是什么</h5>Engineering information Inc.，现在隶属于Elsevier旗下；大家常说的EI Compendex 收录论文的题录、摘要，并加个主题词、分类号什么的。</li>
<li>EI只是从 出版商处抓取某些期刊的论文里面的 信息(题目/作者/摘要/参考文献)。</li>
<li>“EI全文收录”这个短语就是扯淡。。。因为EI里面哪有全文啊。</li>
</ul>
</blockquote>
<h4 id="3-3-ISI、SCI-、汤森路透、路透社的关系"><a href="#3-3-ISI、SCI-、汤森路透、路透社的关系" class="headerlink" title="3.3 ISI、SCI 、汤森路透、路透社的关系"></a>3.3 ISI、SCI 、汤森路透、路透社的关系</h4><p>SCI是由美国科学信息研究所(ISI)1961年创办出版的一部世界著名的期刊文献检索工具，其出版形式包括印刷版期刊和光盘版及联机数据库，现在还发行了互联网上Web版数据库。</p>
<p>ISI通过它严格的选刊标准和评估程序挑选刊源，而且每年略有增减，从而做到SCI收录的文献能全面覆盖全世界最重要和最有影响力的研究成果。40多年来，SCI数据库不断发展，已经成为当代世界最为重要的大型数据库，被列在国际六大著名检索系统(SCI，EI，CA，SA，AJ/РЖ，JST)和三大检索工具(SCI，EI，ISTP)之首。它不仅是一部重要的检索工具书，而且也是科学研究成果评价一项重要依据。在我国，经国家科学技术部有关部门和领导研究，决定从2000年的统计工作起，SCI论文统计用检索系统改为用SCIE。也就是说：如果某位作者的论文被2000年版以后的SCIE收录，就算是被SCI收录了。</p>
<p>美国科学信息研究所(Institute for Scientific Information, 简称ISI)于1960年由Eugene Garfield创立。1992被加拿大汤姆森公司(The Thomson Corporation)的分公司Thomson Scientific &amp; Healthcare收购，于是就成了现在有名的Thomson ISI。后来这个分公司在2006年又分为Thomson Scientific and Thomson Healthcare两个子公司。</p>
<p>至于现在的汤森路透(Thomson Reuters)，网址<a href="http://thomsonreuters.com/，成立于2008年4月17日，是由Thomson公司与英国路透集团(Reuters">http://thomsonreuters.com/，成立于2008年4月17日，是由Thomson公司与英国路透集团(Reuters</a> Group PLC)合并组成的商务和专业智能信息提供商。现在的路透社只是其新闻业务的一部分。以下就介绍一下Thomson Scientific的SCI相关的产品。</p>
<p><strong>(1) ISI web of knowledge</strong></p>
<p>Thomson Scientific网络平台。收费的，通过<a href="http://apps.webofknowledge.com登录进入，或通过你所在学校图书馆或机构网站提供的入口进入。该产品是汤森路透公司的online学术服务产品，它包含了子产品">http://apps.webofknowledge.com登录进入，或通过你所在学校图书馆或机构网站提供的入口进入。该产品是汤森路透公司的online学术服务产品，它包含了子产品</a> “web of science”数据库以及其他资源。Web of science数据库就是我们平时检索SCI数据时所使用的网页，除SCI数据库外，Web of science数据库还包含另外的6个数据库：SSCI，AHCI，IC，CCR，CPCI:Science和CPCI:Social science and Humanities。</p>
<p><strong>(2) Master Journal List</strong></p>
<p>是免费的，汤森路透公司提供的ISI收录的期刊总列表。包括SCI，SCI-E，AHCI，SSCI，CC等众多索引数据库收录的期刊的信息。现在ISI收录的期刊总数是16415个。其中SCI 3772个，SCI-E 8198个。</p>
<ul>
<li>SCI从来源期刊数量来看可分为SCI和SCI-E。<br>SCI是指来源期刊为3772种左右的SCI核心区期刊，<br>SCI-E的全称是SCI-Expanded，是SCI扩展版，其来源期刊8198种左右。<br>SCI-E包括SCI中的期刊。</li>
</ul>
<p><strong>(3)Journal Citation Reports</strong></p>
<p>美国科学情报研究所（ISI）大概每年6月份公布上一年的期刊引用报告（Journal Citation Reports on the Web, JCR Web），JCR对包括SCI收录的SCI-Expanded（包括SCI核心区期刊）的期刊之间引用和被引用数据进行统计、运算，并针对每种期刊定义了影响因子(Impact Factor)等指数加以报道。</p>
<p>JCR可以告知用户的信息包括：每种期刊在当前年被引用的总次数(Total Cites)、每种期刊的影响因子(即该刊前两年发表的文章在当前年的平均被引次数(Impact Factor))、每种期刊当前年发表的文章在当前年的平均被引次数(Immediacy Index)、每种期刊当前年的文章总数(Articles)、每种期刊论文研究课题的延续时间(Cited Half-life)、每种期刊的引用期刊列表(Citing Journal)、每种期刊的被引用期刊列表(Cited Journal)、每种期刊的影响因子在近几年的变化情况(Trends)、每种期刊的来源数据情况(Source Data)等。</p>
<p>Thomson Scientific 还有许多著名的产品。如EndNote 和 Science Watch等。</p>
<h4 id="3-4-SCI分区"><a href="#3-4-SCI分区" class="headerlink" title="3.4 SCI分区"></a>3.4 SCI分区</h4><p>在中国，SCI有两种分区：一种是JCR分区；另一种是中科院分区。在国外，基本不存在分区概念，这只是一个参考，他们一般只投本学科权威期刊，不管分区的，但这些权威期刊一般影响因子都很高。</p>
<h5 id="3-4-1-两种分区方法"><a href="#3-4-1-两种分区方法" class="headerlink" title="3.4.1 两种分区方法"></a>3.4.1 两种分区方法</h5><p><strong>(1) JCR分区</strong><br>JCR将收录期刊分为176个不同学科类别，每个学科分类按照期刊的影响因子高低，平均分为4个区：</p>
<ul>
<li>影响因子前25%（含25%）的期刊为Q1区；</li>
<li>影响因子位于25-50%（含50%）为Q2区；</li>
<li>影响因子位于50-75%（含75%）为Q3区；</li>
<li>影响因子位于75%之后的期刊为Q4区。</li>
</ul>
<p><strong>(2) 中科院分区</strong><br>中科院首先将JCR中所有期刊分为数学、物理、化学、生物、地学、天文、工程技术、医学、环境科学、农林科学、社会科学、管理科学及综合性期刊13大类。然后，将13大类期刊分各自为4个等级，按照各类期刊影响因子划分，4个区:</p>
<ul>
<li>前5%为该类1区；</li>
<li>6%～20%为2区；</li>
<li>21%～50%为3区；</li>
<li>其余的为4区。 可以发现中科院完全使用JCR的影响因子数据，只是进行了不同的学科划分。今年中科院进行了改革，分区表分为基础班和升级版，比往年更加合理一点。<h5 id="3-4-2-两种分区比较"><a href="#3-4-2-两种分区比较" class="headerlink" title="3.4.2  两种分区比较"></a>3.4.2  两种分区比较</h5><strong>(1) 学科划分不同</strong><br>科睿唯安JCR的Journal Ranking没有设置大类学科，只分为176个具体学科，也就是中科院分区表中所指的小类学科。<br><img src="https://pic.imgdb.cn/item/62a896c70947543129ccbfb6.jpg" style="zoom:70%"></li>
</ul>
<p><strong>(2) 分区方法不同</strong><br>JCR是按照“平均主义”思想，根据刊物IF的高至低平均划分4个区，每个区含有该领域总量25%的期刊；中科院的分区如同社会阶层的金字塔结构，1区只有5%的顶级期刊，2~4区期刊数量也逐层增加。</p>
<p><img src="https://pic.imgdb.cn/item/62a897430947543129cd7cf5.jpg" style="zoom:70%"></p>
<p>显然中科院的1区和2区杂志很少，杂志质量相对也高，基本都是本领域的顶级期刊。 所以有的人发表的论文按JCR分区标准算一区，而按中科院分区算2区甚至三区。</p>
<p><strong>(3)指标取值不同 </strong><br>JCR是按本年度公布的IF进行分区，中科院是按期刊前3年IF的平均值进行分区。</p>
<h5 id="3-4-3-我们到底该看哪个分区"><a href="#3-4-3-我们到底该看哪个分区" class="headerlink" title="3.4.3 我们到底该看哪个分区"></a>3.4.3 我们到底该看哪个分区</h5><p>由于中科院分区备受争议，现在很多高校已经不用中科院分区了，虽然在今年中科院进行了改革，分区表分为基础班和升级版，但依然无济于事。 我认为JCR分区可以作为参考，不可SCI至上，因为数据是可以操纵的。</p>
<h3 id="4-资料链接"><a href="#4-资料链接" class="headerlink" title="4 资料链接"></a>4 资料链接</h3><p><a href="https://lib.tsinghua.edu.cn/__local/4/D6/C7/A4DC654D5B4D658CF131335DE9C_9EECFA6B_1E48B8.pdf?e=.pdf">https://lib.tsinghua.edu.cn/__local/4/D6/C7/A4DC654D5B4D658CF131335DE9C_9EECFA6B_1E48B8.pdf?e=.pdf</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>学术科研</category>
      </categories>
      <tags>
        <tag>科研技能</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号频域变换分析</title>
    <url>/2022/02/02/Digital-signal-spectrum-analysis/</url>
    <content><![CDATA[<h3 id="一、数字信号处理中常用矩函数计算和其物理意义"><a href="#一、数字信号处理中常用矩函数计算和其物理意义" class="headerlink" title="一、数字信号处理中常用矩函数计算和其物理意义"></a>一、数字信号处理中常用矩函数计算和其物理意义</h3><h4 id="一-常用矩函数"><a href="#一-常用矩函数" class="headerlink" title="(一) 常用矩函数"></a>(一) 常用矩函数</h4><h5 id="1-均值"><a href="#1-均值" class="headerlink" title="1. 均值"></a>1. 均值</h5><p>均值表示信号中<strong>直流分量</strong>的大小，用$E(x)$表示。对于高斯白噪声信号而言，它的均值为0，所以它只有交流分量。 </p>
<script type="math/tex; mode=display">
E(x) = \bar x = \frac{x_1 + x_2 + \cdots +x_n}{n} = \frac{\sum_{i=1}^{n}x_i}{n}</script><h5 id="2-均值的平方"><a href="#2-均值的平方" class="headerlink" title="2. 均值的平方"></a>2. 均值的平方</h5><p>均值的平方，用${E^2(x)}$表示，它表示的是信号中<strong>直流分量的功率</strong>。</p>
<h5 id="3-均方值"><a href="#3-均方值" class="headerlink" title="3. 均方值"></a>3. 均方值</h5><p>均方值表示信号平方后的均值，用$E(x^2)$表示。<strong>均方值表示信号的平均功率</strong>。信号的平均功率 = 信号交流分量功率信号直流分量功率。</p>
<h5 id="4-均方根值"><a href="#4-均方根值" class="headerlink" title="4. 均方根值"></a>4. 均方根值</h5><p>用RMS（root meansquare），即均方值的开根号。</p>
<script type="math/tex; mode=display">
X_{rms} = \sqrt{\frac{\sum_{i=1}^{n}X_i^2}{N}}</script><h5 id="5-均方差"><a href="#5-均方差" class="headerlink" title="5. 均方差"></a>5. 均方差</h5><p>均方差（mean squareerror），用MSE表示。均方差是各数据偏离真实值的距离平方和的平均数，也即误差平方和的平均数，计算公式形式上接近方差，它的开方叫均方根误差，均方根误差才和标准差形式上接近。均方差有时候被认为等同于方差。</p>
<script type="math/tex; mode=display">
X_{MSE} = \frac{1}{n}</script><h5 id="6-均方根误差"><a href="#6-均方根误差" class="headerlink" title="6. 均方根误差"></a>6. 均方根误差</h5><p>均方根误差用RMSE（root mean  squareerror）表示。它是观测值与真值偏差的平方和观测次数n比值的平方根，在实际测量中，观测次数n总是有限的，真值只能用最可信赖（最佳）值来代替。方根误差对一组测量中的特大或特小误差反映非常敏感，所以均方根误差能够很好地反映出测量的精密度。均方根误差有时被认为是标准差。</p>
<h5 id="7-方差"><a href="#7-方差" class="headerlink" title="7. 方差"></a>7. 方差</h5><p>方差用variance或deviation 或Var表示。方差描述信号的波动范围，表示信号中<strong>交流分量</strong>的强弱，即<strong>交流信号的平均功率</strong>。</p>
<script type="math/tex; mode=display">
D(X) = E[(X-E(X))^2]</script><script type="math/tex; mode=display">
s^2 = \frac{1}{n-1}\sum_{i=1}^{n}(x_i - \bar x)^2  ——或者另一种形式——s^2 = \frac{1}{n}\sum_{i=1}^{n}(x_i - \bar x)^2</script><blockquote>
<p>注意上面除以的是n-1，只有这样由样本值估计出的方差才是<strong>无偏的</strong>，即上面式子的期望才是X的方差。但是有的地方也有用除以n来表示方差，只不过这样求出的结果不是方差的无偏估计，计算结果的数学期望并不是X的方差，而是X方差的倍。 </p>
</blockquote>
<h5 id="8-标准差"><a href="#8-标准差" class="headerlink" title="8. 标准差"></a>8. 标准差</h5><p>标准差（Standard Deviation）用σ表示，有的时候标准差又可以被称为均方根误差RMSE。标准差是各数据偏离平均数的距离的平均数，它是离均差平方和平均后的方根，用σ表示，标准差能反映一个数据集的离散程度。</p>
<p>标准差σ， 反映了测量数据偏离真实值的程度，σ越小，表示测量精度越高，因此可用σ作为评定这一测量过程精度的标准。</p>
<script type="math/tex; mode=display">
S = \sqrt{\frac{\sum_{i=1}^{n}(x_i-\bar x)^2}{n}}</script><blockquote>
<p>有了方差为什么要使用标准差？标准差比方差有什么优势？</p>
<p>因为方差与我们要处理的数据的量纲是不一致的，虽然能很好的描述数据与均值的偏离程度，但是处理结果是不符合我们的直观思维的。 </p>
</blockquote>
<h4 id="二-总结"><a href="#二-总结" class="headerlink" title="(二) 总结"></a>(二) 总结</h4><p>（1）总的来说，均方差，均方根误差和方差，标准差是不能够等同的，尽管它们的公式相似。我们需要从真实值和均值之间的关系来区分它们</p>
<p>（2）对于方差和标准差而言，它们反映的是数据序列与均值的关系。</p>
<p>（3）对于均方差和均方根误差而言，它们反映的是数据序列与真实值之间的关系。</p>
<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：新浪博客/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> <a href="http://www.360doc.com/content/18/0715/14/908538_770556276.shtml">http://www.360doc.com/content/18/0715/14/908538_770556276.shtml</a></p>
<hr>
<h3 id="二、数字域频率与模拟频率"><a href="#二、数字域频率与模拟频率" class="headerlink" title="二、数字域频率与模拟频率"></a>二、数字域频率与模拟频率</h3><h4 id="一-二者关系"><a href="#一-二者关系" class="headerlink" title="(一) 二者关系"></a>(一) 二者关系</h4><p><strong>重点：数字域频率是模拟角频率相对于采样频率的归一化。</strong></p>
<h5 id="1-第一种理解："><a href="#1-第一种理解：" class="headerlink" title="1. 第一种理解："></a>1. 第一种理解：</h5><p>从”连续时间正弦信号与离散时间正弦信号“的关系来理解。</p>
<p><img src="https://pic.imgdb.cn/item/61f9eb132ab3f51d91a2dbbe.jpg" style="zoom:70%"></p>
<p>敲黑板，重点是</p>
<p><img src="https://pic.imgdb.cn/item/61f9ec4d2ab3f51d91a3d307.jpg" style="zoom:70%"></p>
<h5 id="2-第二种理解"><a href="#2-第二种理解" class="headerlink" title="2. 第二种理解"></a>2. 第二种理解</h5><p>从”采样信号的傅里叶变换与离散时间信号的傅里叶变换“的关系来理解。从时域采样出发，先看时域上离散时间信号$x(n)$的自变量$n$与连续时间信号$x(t)$的自变量$t$的关系，如下图。</p>
<p><img src="https://pic.imgdb.cn/item/61f9ed512ab3f51d91a4a253.jpg" style="zoom:70%"></p>
<p>在频域上模拟信号、采样信号、和采样序列(也就是离散时间信号)三者的频谱的关系，如下图所示。看看横轴，时域上，横轴由$t$变成$n$，是按照$n=t/T$的规则；而频域上，横轴由$\Omega$(模拟角频率)变成了$\omega$(数字域频率)，按照$\omega = \Omega × T$的规则。</p>
<p><img src="https://pic.imgdb.cn/item/61f9ee502ab3f51d91a55e3c.jpg" style="zoom:70%"></p>
<p>数字域频率$\omega$的最高频率是$\pi$，这一点可以结合采样定理来理解。采样间隔$T$，意味着采样角频率为$2\pi/T$，根据采样定理，最高的频率是采样频率的一半，也就是$\pi/T$，再将它转换为数字域频率（(乘以$T$)，不就是$\pi$吗?</p>
<h5 id="3-第三种理解"><a href="#3-第三种理解" class="headerlink" title="3. 第三种理解"></a>3. 第三种理解</h5><p>从z平面与s平面的映射关系上来理解。</p>
<p><img src="https://pic.imgdb.cn/item/61f9ef592ab3f51d91a62e74.jpg" style="zoom:70%"></p>
<h4 id="二-总结-1"><a href="#二-总结-1" class="headerlink" title="(二) 总结"></a>(二) 总结</h4><p>不管从哪种角度、哪种方式，殊途同归，结论是一样的，那就是——数字域频率是模拟角频率相对于采样频率的归一化。这一结论，是我们能够正确解读采样后的信号它的频谱分析结果的前提。<br>模拟角频率和数字域频率是数字信号处理中非常重要的两个概念，因为经常需要将模拟信号离散化后再进行频域分析，那么，得到的是数字域频率，必须正确转换为模拟角频率后，才能得到分析对象——模拟信号的频域信息。</p>
<h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：个人图书馆/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> <a href="http://www.360doc.com/content/19/0611/18/908538_841808354.shtml">http://www.360doc.com/content/19/0611/18/908538_841808354.shtml</a></p>
<hr>
<h3 id="三、离散时间傅里叶变换DTFT"><a href="#三、离散时间傅里叶变换DTFT" class="headerlink" title="三、离散时间傅里叶变换DTFT"></a>三、离散时间傅里叶变换DTFT</h3><p>首先要需要理解英文缩写DTFT的含义：离散时间DT、傅里叶变换FT，连起来就是DTFT。注意第二个T (也就是Time)，至关重要。它是“离散D”这个特性所描述的主体：也就是，时间是离散的。</p>
<h4 id="一-从z变换到DTFT"><a href="#一-从z变换到DTFT" class="headerlink" title="(一) 从z变换到DTFT"></a>(一) 从z变换到DTFT</h4><p><strong>重点1：从“单位圆上的z变换“这个角度来理解DTFT正变换的定义。</strong><br><strong>重点2：理解DTFT的周期性——离散时间信号的傅里叶变换都是以$2\pi$为周期的。</strong></p>
<p><img src="https://pic.imgdb.cn/item/61f9f1bb2ab3f51d91a81cbd.jpg"></p>
<h5 id="1-DTFT的正变换："><a href="#1-DTFT的正变换：" class="headerlink" title="1. DTFT的正变换："></a>1. DTFT的正变换：</h5><script type="math/tex; mode=display">
\text{DTFT}[x(n)] = X(e^{j\omega}) = \sum_{n = -\infty}^{\infty}x(n)e^{-j\omega n}</script><h5 id="2-DTFT的基本性质："><a href="#2-DTFT的基本性质：" class="headerlink" title="2. DTFT的基本性质："></a>2. DTFT的基本性质：</h5><p>​    $X(e^{j\omega})$是以$\omega$为自变量的<font color="red"><strong>连续</strong>函数</font>；</p>
<p>​    $X(e^{j\omega})$是以$2\pi$为周期的<font color="red"><strong>周期</strong>函数</font>；</p>
<h5 id="3-DTFT存在的充分条件："><a href="#3-DTFT存在的充分条件：" class="headerlink" title="3. DTFT存在的充分条件："></a>3. DTFT存在的充分条件：</h5><script type="math/tex; mode=display">
x(n)绝对可和：\sum_{n = -\infty}^{\infty}|x(n)| < \infty</script><h4 id="二-DTFT变换对及物理含义"><a href="#二-DTFT变换对及物理含义" class="headerlink" title="(二) DTFT变换对及物理含义"></a>(二) DTFT变换对及物理含义</h4><p><strong>重点1：理解离散信号频谱的物理概念及特点。</strong><br><strong>重点2：会求几种常用信号的DTFT(单位样值信号、矩形脉冲、指数衰减信号、离散Sa函数等)。</strong></p>
<h5 id="1-DTFT公式整理"><a href="#1-DTFT公式整理" class="headerlink" title="1. DTFT公式整理"></a>1. DTFT公式整理</h5><p><img src="https://pic.imgdb.cn/item/61f9f4c02ab3f51d91aa9178.jpg"></p>
<h5 id="2-物理含义"><a href="#2-物理含义" class="headerlink" title="2. 物理含义"></a>2. 物理含义</h5><p>(1) $x(n)$可以表示成复指数信号的线性组合(只需一个$2\pi$区间内的频率)；</p>
<p>(2) $X(e^{j\omega})$表示了$x(n)$中各个频率分量的相对大小及位置，称为$x(n)$的频谱(以$2\pi$为周期)。</p>
<script type="math/tex; mode=display">
X(e^{j \omega})=|X(e^{j \omega})| e^{j \angle X(e^{j \omega})}</script><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：个人图书馆/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> <a href="http://www.360doc.com/content/19/0611/18/908538_841808425.shtml">http://www.360doc.com/content/19/0611/18/908538_841808425.shtml</a></p>
<hr>
<h3 id="四、离散傅里叶级数DFS"><a href="#四、离散傅里叶级数DFS" class="headerlink" title="四、离散傅里叶级数DFS"></a>四、离散傅里叶级数DFS</h3><h4 id="一-离散时间周期信号的DFS"><a href="#一-离散时间周期信号的DFS" class="headerlink" title="(一) 离散时间周期信号的DFS"></a>(一) 离散时间周期信号的DFS</h4><p><strong>重点1：对照连续时间周期信号的FS的思想，理解离散时间周期信号的FS，二者的相同(离散谱)和不同之处。</strong><br><strong>重点2：理解离散时间周期信号的FS展开式为何只有N项，理解离散时间周期信号频谱的周期性。</strong></p>
<p><img src="https://pic.imgdb.cn/item/61f9f6e12ab3f51d91ac386f.jpg"></p>
<p>需要说明的是，DFS有两种表示形式，如下面两个式子，这两种方式的区别在于，1/N的系数在正变换(FS系数求解式)中，还是反变换(级数展开式)中。没有实质区别，只是差一个常数N。这里均采用第二种表示形式，即将1/N的系数放在反变换中。</p>
<script type="math/tex; mode=display">
第一种：\tilde{X} _ k = \frac{1}{N}\sum _ {n = 0}^{N-1}\tilde{x} _ ne^{-j\frac{2\pi}{N}kn}\text{ } - - - - \text{ }\tilde{x}(n) = \sum _ {k=0}^{N-1}\tilde{X} _ ke^{j\frac{2\pi}{N}kn}</script><script type="math/tex; mode=display">
第二种：\tilde{X}(k) =\sum _ {n = 0}^{N-1}\tilde{x} _ ne^{-j\frac{2\pi}{N}kn} \text{ } - - - -\text{ }\tilde{x}(n) =  \frac{1}{N}\sum _ {k=0}^{N-1}\tilde{X}(k)e^{j\frac{2\pi}{N}kn}</script><h4 id="二-离散时间周期信号的频谱"><a href="#二-离散时间周期信号的频谱" class="headerlink" title="(二) 离散时间周期信号的频谱"></a>(二) 离散时间周期信号的频谱</h4><p><strong>重点1：掌握离散时间周期信号频谱的特点——离散性、谐波性、周期性；</strong><br><strong>重点2：会求常用离散时间周期信号的DFS(见例题1和例题2)。</strong></p>
<p><img src="https://pic.imgdb.cn/item/61f9faf22ab3f51d91af8e23.jpg" style="zoom:80%"></p>
<h5 id="1-两类典型的求解DFS的题目："><a href="#1-两类典型的求解DFS的题目：" class="headerlink" title="1. 两类典型的求解DFS的题目："></a>1. 两类典型的求解DFS的题目：</h5><p><strong>第一类：</strong>周期信号直接以正弦、余弦之和形式给出(如例1)<br>方法：与标准形式的FS对照，直接得出FS的系数（即频谱)。<br><strong>第二类：</strong>一般的周期信号(如例2)<br>方法：用FS的系数求解公式。</p>
<h5 id="2-DFS与DTFT的关系"><a href="#2-DFS与DTFT的关系" class="headerlink" title="2. DFS与DTFT的关系"></a>2. DFS与DTFT的关系</h5><p><strong>重点：理解DFS与DTFT的关系——周期序列的离散谱是其主值序列连续谱的离散抽样。</strong></p>
<p>与上一讲中离散矩形脉冲的DTFT进行比较：可见，二者在时域上的关系是周期延拓，频域上的关系是离散抽样。如下图所示。 </p>
<p><img src="https://pic.imgdb.cn/item/61f9fc072ab3f51d91b070dc.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/61f9fc512ab3f51d91b0a4f4.jpg"></p>
<h5 id="3-四种傅里叶变换的关系"><a href="#3-四种傅里叶变换的关系" class="headerlink" title="3. 四种傅里叶变换的关系"></a>3. 四种傅里叶变换的关系</h5><p><strong>重点：一个域周期，对应另一个域离散。</strong></p>
<p><img src="https://pic.imgdb.cn/item/61f9fd6e2ab3f51d91b1b54d.jpg"></p>
<h5 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：个人图书馆/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> <a href="http://www.360doc.com/content/19/0611/18/908538_841808371.shtml">http://www.360doc.com/content/19/0611/18/908538_841808371.shtml</a></p>
<hr>
<h3 id="五、离散傅里叶变换DFT"><a href="#五、离散傅里叶变换DFT" class="headerlink" title="五、离散傅里叶变换DFT"></a>五、离散傅里叶变换DFT</h3><h4 id="一-背景介绍"><a href="#一-背景介绍" class="headerlink" title="(一) 背景介绍"></a>(一) 背景介绍</h4><p>为什么需要定义一种“新”的变换?</p>
<p>计算机处理的两个基本条件：<br><strong>第一，只能处理离散的数据(时域和频域都要离散)；</strong><br><strong>第二，要有限长。</strong></p>
<p>DTFT，时域上离散，但频域是连续的；DFS，时域频域都是离散的，但同时又都是周期的，周期序列长度为无限长。但同时我们也注意到，周期序列实际上只有有限个序列值有意义，因而它的离散傅里叶级数也适用于有限长序列，这就得到有限长序列的离散傅里叶变换(DFT)。</p>
<p><img src="https://pic.imgdb.cn/item/61f9fe8b2ab3f51d91b28d6c.jpg" style="zoom:80%"></p>
<p>所以，<strong>DFT并不是一种新的变换</strong>。它只是将DFS时域和频域上都取一个周期而已。<strong>DFT正反变换的定义式与DFS相同，只是加了一个取值范围的限定而已</strong>。换汤不换药。</p>
<h4 id="二-DFT的定义及物理含义"><a href="#二-DFT的定义及物理含义" class="headerlink" title="(二) DFT的定义及物理含义"></a>(二) DFT的定义及物理含义</h4><p><strong>重点：DFT与DFS、DTFT的关系</strong></p>
<h5 id="1-变换公式"><a href="#1-变换公式" class="headerlink" title="1. 变换公式"></a>1. 变换公式</h5><script type="math/tex; mode=display">
正变换：X(k)=\sum_{n=0}^{N-1} x(n) e^{-j \frac{2 \pi}{N} k n}, k=0,1, \ldots, N-1</script><script type="math/tex; mode=display">
逆变换：x(n)=\frac{1}{N} \sum_{k=0}^{N-1} X(k) e^{j \frac{2 \pi}{N} k n}, n=0,1, \ldots, N-1</script><p>定义<font color="red"><strong>旋转因子$W_N=e^{-j\frac{2\pi}{N}}$</strong></font>，则上式转变为：</p>
<script type="math/tex; mode=display">
正变换：X(k)=\sum_{n=0}^{N-1} x(n) W_{N}^{k n}, k=0,1, \ldots, N-1</script><script type="math/tex; mode=display">
逆变换：x(n)=\frac{1}{N} \sum_{k=0}^{N-1} X(k) W_{N}^{-k n}, n=0,1, \ldots, N-1</script><p>总上，这对变换记为：</p>
<script type="math/tex; mode=display">
x(n)\overset{N点\text{DFT}}{\longleftrightarrow}X(k)</script><p><img src="https://pic.imgdb.cn/item/61fa03b92ab3f51d91b6cb31.jpg" style="zoom:80%"></p>
<p><strong>DFT不是序列x(n)的真正的频谱。x(n)的真正的频谱是DTFT，DFT只是对其真正频谱的一个周期上的离散抽样值。</strong></p>
<h4 id="三-DFT的计算"><a href="#三-DFT的计算" class="headerlink" title="(三) DFT的计算"></a>(三) DFT的计算</h4><p><strong>重点：DFT的两种计算方法。</strong></p>
<h5 id="1-方法一：利用DFT定义式"><a href="#1-方法一：利用DFT定义式" class="headerlink" title="1. 方法一：利用DFT定义式"></a>1. 方法一：利用DFT定义式</h5><script type="math/tex; mode=display">
X(k) = \sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi}{N}kn},k=0,1,\cdots,N-1</script><h5 id="2-方法二：先求DTFT再抽样"><a href="#2-方法二：先求DTFT再抽样" class="headerlink" title="2. 方法二：先求DTFT再抽样"></a>2. 方法二：先求DTFT再抽样</h5><script type="math/tex; mode=display">
X(k)=X(e^{j \omega})| _ {\omega=\frac{2 \pi}{N} k} R _ {N}(k)</script><h5 id="3-方法三：DFT矩阵"><a href="#3-方法三：DFT矩阵" class="headerlink" title="3. 方法三：DFT矩阵"></a>3. 方法三：DFT矩阵</h5><p>设有一序列$x(n), n = 0, 1, \cdots, N-1$，求其$N$点DFT有：</p>
<script type="math/tex; mode=display">
X(k) = \mathrm{DFT}[x(n)] =  \sum_{n=0}^{N-1} x(n) \exp\left[{-\mathrm j}\dfrac{2\pi}{N}nk\right] = \sum_{n=0}^{N-1} x(n) W_N^{nk}</script><p>其中，$k = 0,1, \cdots, N-1$。</p>
<p>令 $\boldsymbol x = \left[x(0), x(1),\cdots, x(N-1)\right]^{\mathrm T}$，则DFT计算可以看做向量$\boldsymbol x$和一个矩阵的乘积，我们一般讲这个矩阵称作<strong>DFT矩阵</strong>：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{F_1} 
&= \left[\begin{array}{ccccc}
\mathrm e^{-\mathrm j \frac{2\pi}{N} 0 \cdot 0} &\mathrm e^{-\mathrm j \frac{2\pi}{N} 0 \cdot 1} & \mathrm e^{-\mathrm j \frac{2\pi}{N} 0 \cdot 2} & \cdots & \mathrm e^{-\mathrm j \frac{2\pi}{N} 0 \cdot (N-1)} \\
\mathrm e^{-\mathrm j \frac{2\pi}{N} 1 \cdot 0} &\mathrm e^{-\mathrm j \frac{2\pi}{N} 1 \cdot 1} & \mathrm e^{-\mathrm j \frac{2\pi}{N} 1 \cdot 2} & \cdots & \mathrm e^{-\mathrm j \frac{2\pi}{N} 1 \cdot (N-1)} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
\mathrm e^{-\mathrm j \frac{2\pi}{N} (N-1) \cdot 0} &\mathrm e^{-\mathrm j \frac{2\pi}{N} (N-1) \cdot 1} & \mathrm e^{-\mathrm j \frac{2\pi}{N} (N-1) \cdot 2} & \cdots & \mathrm e^{-\mathrm j \frac{2\pi}{N} (N-1) \cdot (N-1)}
\end{array}\right] \\
\\
&= \left[\begin{array}{ccccc}
W_N^{0 0} & W_N^{0 1} & W_N^{0 2} & \cdots & W_N^{0 (N-1)} \\
W_N^{1 0} & W_N^{1 1} & W_N^{1 2} & \cdots & W_N^{1 (N-1)} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
W_N^{(N-1) 0} &W_N^{(N-1) 1} & W_N^{(N-1) 2} & \cdots & W_N^{(N-1)(N-1)}
\end{array}\right]
\end{aligned}</script><p>此时，序列$x(n)$的DFT为：</p>
<script type="math/tex; mode=display">
\boldsymbol X = \left[\begin{array}{c} X(0)  \\ X(1) \\ \vdots \\ X(k) \\ \vdots \\ X(N-1) 
\end{array}\right] = \boldsymbol{F_1 x} = \boldsymbol{F_1}\left[\begin{array}{c} x(0)  \\ x(1) \\ \vdots \\ x(n) \\ \vdots \\ x(N-1) 
\end{array}\right]</script><p>或者，若将<strong>DFT矩阵</strong>定义为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{F_2} = \boldsymbol{F_1}^{\mathrm H} 
&= \left[\begin{array}{ccccc}
\mathrm e^{\mathrm j \frac{2\pi}{N} 0 \cdot 0} &\mathrm e^{\mathrm j \frac{2\pi}{N} 0 \cdot 1} & \mathrm e^{\mathrm j \frac{2\pi}{N} 0 \cdot 2} & \cdots & \mathrm e^{\mathrm j \frac{2\pi}{N} 0 \cdot (N-1)} \\
\mathrm e^{\mathrm j \frac{2\pi}{N} 1 \cdot 0} &\mathrm e^{\mathrm j \frac{2\pi}{N} 1 \cdot 1} & \mathrm e^{\mathrm j \frac{2\pi}{N} 1 \cdot 2} & \cdots & \mathrm e^{\mathrm j \frac{2\pi}{N} 1 \cdot (N-1)} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
\mathrm e^{\mathrm j \frac{2\pi}{N} (N-1) \cdot 0} &\mathrm e^{\mathrm j \frac{2\pi}{N} (N-1) \cdot 1} & \mathrm e^{\mathrm j \frac{2\pi}{N} (N-1) \cdot 2} & \cdots & \mathrm e^{\mathrm j \frac{2\pi}{N} (N-1) \cdot (N-1)}
\end{array}\right]
\\
\\
&= \left[\begin{array}{ccccc}
W_N^{-0 0} & W_N^{-0 1} & W_N^{-0 2} & \cdots & W_N^{-0 (N-1)} \\
W_N^{-1 0} & W_N^{-1 1} & W_N^{-1 2} & \cdots & W_N^{-1 (N-1)} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
W_N^{-(N-1) 0} &W_N^{-(N-1) 1} & W_N^{-(N-1) 2} & \cdots & W_N^{-(N-1)(N-1)}
\end{array}\right]
\end{aligned}</script><p>此时，序列$x(n)$的DFT变换为：</p>
<script type="math/tex; mode=display">
\boldsymbol X = \left[\begin{array}{c} X(0)  \\ X(1) \\ \vdots \\ X(k) \\ \vdots \\ X(N-1) 
\end{array}\right] = \boldsymbol{F_2}^{\mathrm H} \boldsymbol x = \boldsymbol{F_2}^{\mathrm H}\left[\begin{array}{c} x(0)  \\ x(1) \\ \vdots \\ x(n) \\ \vdots \\ x(N-1) 
\end{array}\right]</script><p>容易发现，DFT矩阵具有如下性质：</p>
<ul>
<li>① DFT矩阵是对称矩阵，即$\boldsymbol{F_1} = \boldsymbol{F_1}^{\mathrm T} \qquad \boldsymbol{F_2} = \boldsymbol{F_2}^{\mathrm T}$；</li>
<li>② $\boldsymbol{F_2} = \boldsymbol{F_1}^{\mathrm H}$；</li>
</ul>
<p>参考链接1：<a href="https://web.xidian.edu.cn/kywang/files/20171213_190241.pdf">第三章 离散傅里叶变换（DFT） 及其快速算法（FFT）</a><br>参考链接2：<a href="https://blog.csdn.net/weixin_44144171/article/details/100083924">DFT和IDFT分析 - CSDN</a></p>
<h5 id="4-例题"><a href="#4-例题" class="headerlink" title="4. 例题"></a>4. 例题</h5><p>下面的例题，分别用这两种方法进行求解。</p>
<html>
    <table style="margin-left: auto; margin-right: auto;">
        <tr>
            <td>
                <!--左侧内容-->
                求5点矩形窗函数$x(n) = R_5(n)$的5点DFT$X_1(k)$和10点DFT$X_2(x)$
            </td>
            <td>
                <!--右侧内容-->
                <img src="https://pic.imgdb.cn/item/61fa05922ab3f51d91b85a37.jpg">
            </td>
        </tr>
    </table>
</html>

<p><img src="https://pic.imgdb.cn/item/61fa090f2ab3f51d91bb0fba.jpg"></p>
<p>对于本题来说，方法二特别直观，便于理解DFT与DTFT的关系。</p>
<p><img src="https://pic.imgdb.cn/item/61fa09a32ab3f51d91bb8efb.jpg" style="zoom:70%"></p>
<p>可见，同一个序列的不同点数的DFT，得到的结果不同。DFT的点数$N$越大，$X(k)$越能反映连续频谱的形状。<br>当DFT的点数$N$&gt;序列的长度$N_0$时，相当于在序列后面补上$N-N_0$个零，故称为<strong>”补零DFT“</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/61fa0a292ab3f51d91bbff68.jpg" style="zoom:70%"></p>
<h4 id="四-DFT性质"><a href="#四-DFT性质" class="headerlink" title="(四) DFT性质"></a>(四) DFT性质</h4><h5 id="1-圆周移位-循环移位"><a href="#1-圆周移位-循环移位" class="headerlink" title="1. 圆周移位(循环移位)"></a>1. 圆周移位(循环移位)</h5><p>首先看，为什么要定义一种新的移位?这种新的移位为什么称为“圆周移位”？它与普通的移位有何异同？见下图。</p>
<p><img src="https://pic.imgdb.cn/item/61fa0ab42ab3f51d91bc7111.jpg" style="zoom:70%"></p>
<p>可见，圆周移位与普通移位的区别在于：多一个周期延拓、再取主值区间的过程。定义式如下：</p>
<script type="math/tex; mode=display">
圆周移位(循环移位)——x(n+m)_NR_N(n) = \tilde{x}(n+m)R_N(n)</script><p>圆周移位的步骤：先周期延拓、再移位、最后取主值区间；或者先移位、再周期延拓、最后取主值区间。前两步谁先谁后都可以。见下图。</p>
<p><img src="https://pic.imgdb.cn/item/61fa0bf72ab3f51d91bd7a9a.jpg" style="zoom:70%"></p>
<p>可见，这种新的移位，相当于先把序列放在一个圆上，然后转圈圈：左移，沿顺时针方向转(即上图中的情况);右移，沿逆时针方向转。<br><strong>与其他傅里叶变换一样，DFT依然满足：时域移位，频域线性相移；频域移位，时域调制。需要注意的是，这里的移位，都指的是<font color="red">圆周(循环)移位</font></strong>。</p>
<p><img src="https://pic.imgdb.cn/item/61fa0cb02ab3f51d91be2ca9.jpg" style="zoom:80%"></p>
<h5 id="2-圆周卷积-循环卷积"><a href="#2-圆周卷积-循环卷积" class="headerlink" title="2. 圆周卷积(循环卷积)"></a>2. 圆周卷积(循环卷积)</h5><p><strong>(1) 圆周卷积的定义</strong><br>仿照上面我们对移位操作做的改进——增加了“周期延拓、取主值区间”的过程，将“移位”改造成“圆周移位”一样，我们也对之前很熟悉的卷积和公式做改进，就得到一种新的卷积”圆周卷积“(或称为循环卷积)的定义。</p>
<p>$x_1(n)$的长度为$N_1$，$x_2(n)$的长度为$N_2$，$N \geq \max(N_1,N_2)$，则$N$点圆周卷积为：</p>
<script type="math/tex; mode=display">
x_1(n) \odot x_2(n) = \sum_{m=0}^{N-1}x_1(m)x_2(n-m)_NR_N(n)</script><p>为了区分，大家在《信号与系统》中所学习的卷积和，称为”线性卷积“。<br>显然易见，圆周卷积的结果与$N$有关。<br><strong>(2) DFT的圆周卷积定理</strong><br>在圆周卷积的定义下，DFT依然满足”一个域卷积，另外一个域相乘“这一更古不变的关系。</p>
<p><font color="bule"><strong>时域圆周卷积定理：</strong></font></p>
<script type="math/tex; mode=display">
x_1(n) \odot x_2(n) \overset{N点\text{DFT}}{\longleftrightarrow}X_1(k)X_2(k)</script><p><font color="bule"><strong>频域圆周卷积定理：</strong></font></p>
<script type="math/tex; mode=display">
x_1(n)  x_2(n) \overset{N点\text{DFT}}{\longleftrightarrow}\frac{1}{N}X_1(k) \odot X_2(k)</script><p><strong>(3) 圆周卷积的计算</strong><br>下面重点来看圆周卷积的计算。</p>
<p><img src="https://pic.imgdb.cn/item/61fa10de2ab3f51d91c1fa15.jpg" style="zoom:85%"></p>
<p><strong>(4) 圆周卷积与线性卷积的关系</strong><br>上面的例题中，两个序列的线性卷积是多少呢?圆周卷积与之相同吗?为什么?<br>线性卷积，是直接将序列2反转、平移，而没有”周期延拓、再取主值“这两步。可以用图解法或者竖式法得到（信号与系统中已学，此处直接给出结果)，线性卷积的结果如下：</p>
<script type="math/tex; mode=display">
两序列的5点线性卷积为:x _ 1(n) * x _ 2(n)=[1,3,6,9,12,9,5]</script><p>两种卷积为何不同呢?又有何关系呢?<br>下图从公式上推导圆周卷积与线性卷积的关系</p>
<p><img src="https://pic.imgdb.cn/item/61fa11ac2ab3f51d91c2b12a.jpg" style="zoom:80%"></p>
<p>我们可以得到以下结论：</p>
<p><strong>圆周卷积是线性卷积周期延拓后的主值序列：</strong></p>
<script type="math/tex; mode=display">
y_c(n) = \sum_{r=-\infty}^{\infty}y_l(n+rN)R_N(n)</script><p><strong>当$N\geq N_1+N_2-1$时，圆周卷积和线性卷积结果相同。</strong></p>
<p>根据以上结论，我们可以根据线性卷积的结果，直接得到N点圆周卷积的结果。如下图：</p>
<p><img src="https://pic.imgdb.cn/item/61fa12862ab3f51d91c36961.jpg" style="zoom:70%"></p>
<h5 id="3-圆周共轭对称性"><a href="#3-圆周共轭对称性" class="headerlink" title="3. 圆周共轭对称性"></a>3. 圆周共轭对称性</h5><p>这里不讲证明(教材上都有)，重点讲怎么理解教材上让人眼花缭乱的公式。我们把“公式”翻译成“人话”。<br>首先说明，文中所说的N点长序列，都指的是自变量取值范围为$[0,N-1]$，除此之外的区间，序列值为0。<br>先看第一个。<br><strong>(1) 共轭序列的DFT</strong><br>时频域有这样一个基本对应关系——时域取共轭，对应频域自变量取负然后函数取共轭。具体到DFT呢？“自变量取负”也就是“反转”，而“DFT隐含着周期性”，所以这里的“反转”要加上“周期延拓，再取主值区间”，所以，公式及证明过程如下</p>
<p><img src="https://pic.imgdb.cn/item/61fa135b2ab3f51d91c41e2a.jpg" style="zoom:70%"></p>
<p><strong>时域取共轭，对应DFT是：先周期延拓，再反转，再取主值区间，最后取共扼。</strong>当然，第一步与第二步可以交换次序，取共轮可以放在任意步骤上。关键是理解这个操作用公式的三种描述方式(上图中画红线处)：</p>
<ul>
<li>第①种：$X^*((-k))_N R_N(k)$，是最直观地展现上述过程的；</li>
<li>第②种：$X^*((N-k))_N R_N(k)$，可认为用其周期性(周期延拓得到的当然是以$N$为周期啦)，把$-k$换成$N-k$；</li>
<li>第③种：去掉了双括号，也去掉了$R_N(k)$，好像看不出“周期延拓”和“取主值区间”的操作了。大家会心存疑虑，这个等号成立吗?</li>
</ul>
<p>我们用下图的例子来说明一下这个等号成立，为了画图的方便，我们用函数值为实数的情况，图中是以$n$为自变量，换作$k$当然也是一样的。</p>
<p><img src="https://pic.imgdb.cn/item/61fa223c2ab3f51d91d25487.jpg"></p>
<p>$x(N-n)$可以看作简写形式，优点在于形式简洁明了，缺点在于掩盖了周期延拓再取主值的过程。用这种简写形式，要注意一点，$N$点长序列$x(n)$，$n$的取值范围为$0&lt;n&lt;N-1$，也即本应该$x(N)=0$，但此处当$n=0$时，$x(N-n)=x(N)$，不能认为$x(N)=0$，而要认为$x(N)=x(0)$。也就是说，要把$x(n)$的这$N$个点，认为是周期序列的主值区间，那么$x(N)$就是下一个周期的第一个点，所以$x(N)=x(0)$。</p>
<p>用这种简写形式来描述这个性质，就是：时域取共轭，对应的DFT，相当于把序号$k$与序号$N-k$做一个互换，然后取共轭。</p>
<p>下面看这个性质的两个推论：</p>
<p><strong>第一个推论：实序列的DFT是圆周共轭对称序列。</strong></p>
<ul>
<li>对于实序列$x(n)$，其DFT即$X(k)$满足：<script type="math/tex; mode=display">
X(k) = X^*(N-k)_NR_N(k) = X^*(N-k)</script><font color="red"><strong>实序列的DFT $X(k)$是圆周共轭对称序列</strong></font>。即：实部圆周偶对称，虚部圆周奇对称；模圆周偶对称，相角圆周奇对称。</li>
</ul>
<p>“圆周共轭对称”是个什么鬼？我们按照以下几步来解释一下：</p>
<ul>
<li><p>第一步：从“偶对称、奇对称”到“共轭对称/共轭反对称”</p>
<p>偶对称/奇对称地球人都知道吧。共轭对称/反对称就不是地球人都知道了，大学生才知道。</p>
<p>对于实函数$x(n)$，如果$x(-n)=x(n)$，称之为偶对称，$x(-n)=-x(n)$称之为奇对称。</p>
<p>扩展到复函数$x(n)$，如果$x^*(-n)=x(n)$，称之为共轭对称，与之相对应的还有共轭反对称。</p>
</li>
<li><p>第二步：从“共轭对称”到“圆周共轭对称”</p>
<p>圆周共轭对称定义：对于$N$点长序列$x(n)$，若$x(n)=x((N-n))_NR_N(n)$，或者用简写形式：$x(n)=x(N-n)$，那么称之为“圆周共轭对称”。</p>
<p>可以理解为：把$x(n)$放在一个圆周的$N$个等分点上，或者说把横轴掰弯成一个圆($n=N-1$与原点重合)，则这$N$个序列值关于原点对称，或者说关于$\dfrac{N}{2}$也对称，如下图所示。</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/61fa27d02ab3f51d91d78d3a.jpg" style="zoom:70%"></p>
<p>我们前面求解过的例题：5点矩形脉冲的DFT，如下图，也体现出圆周偶对称的特点。</p>
<p><img src="https://pic.imgdb.cn/item/61fa28242ab3f51d91d7e051.jpg" style="zoom:70%"></p>
<p><strong>第二个推论：实部/虚部与圆周共轭对称/反对称分量的关系</strong></p>
<p>首先解释一下什么叫圆周共轭对称分量和圆周共轭反对称分量。需要经过以下几步循序渐进的理解。</p>
<ul>
<li>第一步：实函数可以分解为偶分量+奇分量</li>
</ul>
<script type="math/tex; mode=display">
x(n) = x_e(n)+x_o(n)</script><p>其中：偶分量 —— $x_e = \dfrac{x(n)+x(-n)}{2}$，奇分量 —— $x_o = \dfrac{x(n)-x(-n)}{2}$</p>
<ul>
<li>第二步：从“偶分量/奇分量”到复函数可以分解为“共轭对称分量+共轭反对称分量”，把上式中的$x(-n)$改为$x^*(-n)$即可</li>
</ul>
<script type="math/tex; mode=display">
x(n) = x_e(n)+x_o(n)</script><p>其中：共轭对称分量 —— $x_e(n) = \dfrac{x(n)+\overline{x(-n)}}{2}$，共轭反对称分量——$x_o = \dfrac{x(n)-\overline {x^*(-n)}}{2}$</p>
<p>以上两式，无论是对无限长序列，还是有限长序列，都是适用的。如果$x(n)$为$N$点长，并且$0&lt;n&lt;N-1$，那么$x_e(n)$和$x_o(n)$是$2N-1$点长，并且$-(N-1) \leq n \leq N-1$。</p>
<ul>
<li>第三步：改造成适合DFT的。凡是涉及到自变量取负(也就是反转)的，都加上“周期延拓，再取主值区间”的操作。也就是把上式中的$x(-n)$改为$x((N-n))_NR_N(n)$，用简写形式表示就是$x(N-n)$。</li>
</ul>
<p>因此，得到圆周共轭对称分量和圆周共轭反对称分量的定义：</p>
<p>$N$点长的序列$x(n)$，可以分解为<font color="red">圆周共轭对称分量+圆周共轭反对称分量</font></p>
<script type="math/tex; mode=display">
x(n) = x_{ep}(n) + x_{op}(n)</script><p>其中：圆周共轭对称分量——$x_{ep}(n) = \dfrac{x(n)+\overline{x(N-n)}}{2}$，圆周共轭反对称分量——$x_{op}(n) = \dfrac{x(n)-\overline{x(N-n)}}{2}$</p>
<blockquote>
<p>注意，前提是$x(n)$为$N$点长序列，并且n的范围是$0≤n≤N-1$，圆周共轭对称/反对称分量的长度仍是$N$，$n$的范围也不变。而且如前所述，$n=0$时，$x(N-0)=x(N)=x(0)$。</p>
</blockquote>
<p>上面，是以$x(n)$为例，同样，对于DFT $X(k)$，也可以定义圆周共扼对称/反对称分量，不再赘述。</p>
<p>解释完这些，我们的核心公式就出来啦（证明过程省略，直接看结论)。序列$x(n)$及其DFT的实部/虚部与圆周共轭对称/反对称分量之间的关系，见下图：</p>
<p><img src="https://pic.imgdb.cn/item/61fa317c2ab3f51d91e0bda3.jpg" style="zoom:70%"></p>
<p>(此处省略若干公式)，翻译成人话(绕口令)就是：<br>序列实部的DFT是序列DFT的共轭对称分量<br>序列虚部×j的DFT是序列DFT的共轭反对称分量<br>序列共轭对称分量的DFT是序列DFT的实部<br>序列共轭反对称分量的DFT是序列DFT的虚部巧j</p>
<p>是不是像绕口令，但总比公式强多了。这—切，意义何在?</p>
<p><strong>第一，从图形上可以淋漓尽致地体现DFT隐含的周期性。</strong><br><strong>第二，为DFT的简化运算提供了思路。</strong></p>
<h5 id="4-Parseval定理"><a href="#4-Parseval定理" class="headerlink" title="4. Parseval定理"></a>4. Parseval定理</h5><p>有限长序列的能量：</p>
<script type="math/tex; mode=display">
\sum\limits_{n=0}^{N-1}|x(n)|^{2}=\dfrac{1}{N} \sum\limits_{k=0}^{N-1}|X(k)|^{2}</script><h4 id="五-频域抽样"><a href="#五-频域抽样" class="headerlink" title="(五) 频域抽样"></a>(五) 频域抽样</h4><p>实际上，<font color="red"><strong>DFT就是频域抽样</strong></font>。包括三个问题，这三个问题环环相扣、层层推进。</p>
<h5 id="1-DFT与DTFT、z变换的关系"><a href="#1-DFT与DTFT、z变换的关系" class="headerlink" title="1. DFT与DTFT、z变换的关系"></a>1. DFT与DTFT、z变换的关系</h5><p>先从公式上看三个变换的关系，再结合z平面的单位圆的概念，从图形上理解。如下图:</p>
<p><img src="https://pic.imgdb.cn/item/61fa339a2ab3f51d91e2d239.jpg" style="zoom:70%"></p>
<p><img src="https://pic.imgdb.cn/item/61fa33b52ab3f51d91e2eb74.jpg" style="zoom:70%"></p>
<p>毫无疑问，DFT的自变量$k$为离散的，而DTFT的自变量$\omega$、以及z变换的自变量$z$都是连续变量。DFT是另外两种变换的离散采样值。因为这种采样是在频域，所以称为”频域采样“。</p>
<p>那么问题来啦：能否由离散频谱值$X(k)$得到$X(z)$和$X(e^{j\omega})$？</p>
<p>不管在那个域进行抽样，其数学本质都是用一些离散的数值代替原来连续变化的函数，或者说用一些离散的点代表原来连续的曲线。能不能代表取决于两个因素：一是这些离散的点的间隔，即抽样间隔；二是原来那条连续曲线的变化起伏程度，(<font color="red"><strong>频域抽样定理</strong></font>)。</p>
<h5 id="2-频域抽样定理"><a href="#2-频域抽样定理" class="headerlink" title="2. 频域抽样定理"></a>2. 频域抽样定理</h5><p>傅里叶分析方法的好处在于，建立起时域和频域的一种重要的对应关系：一个域离散抽样，另外一个域周期延拓。所以，研究时域抽样时，把问题对应到频域上去研究；那么现在研究频域抽样时，又要把问题对应到时域上去研究。毫无疑问，时域上会周期延拓。如下图：</p>
<p><img src="https://pic.imgdb.cn/item/61fa34a62ab3f51d91e3d3f7.jpg" style="zoom:70%"></p>
<p>既然是以$N$为周期延拓，条件自然而然就出来了：</p>
<p>对于$M$点长的序列$x(n)$，频域抽样不失真的条件是：<font color="red"> <strong>一个周期内的频域抽样点数$N \geq M$</strong></font> ，此时有：</p>
<script type="math/tex; mode=display">
x_N(n) = \sum_{r = -\infty}^{\infty}x(n+rN)R_N(n) = x(n)</script><p>即满足该条件时，$N$个频率抽样值$X(k)$（即$x(n)$的$N$点DFT)能够完全代表$x(e^{j\omega})$及$X(z)$。</p>
<p>问题又来了，怎么表示？这就是第三个问题：频域的插值恢复。</p>
<h5 id="3-频域的插值恢复"><a href="#3-频域的插值恢复" class="headerlink" title="3. 频域的插值恢复"></a>3. 频域的插值恢复</h5><p>与时域抽样的恢复完全相同的思路，用离散的样本值乘以一个插值函数，得到一个连续的函数，只不过这里的插值函数是关于$\omega$或$z$的函数。下面的任务就是找这个函数$\varphi(w)$或$\varphi(z)$。</p>
<p><img src="https://pic.imgdb.cn/item/61fa365f2ab3f51d91e58cc6.jpg" style="zoom:70%"></p>
<p>z变换的形式更为简洁，因此首先解决由$X(k)$得到$X(z)$的问题。</p>
<p>以下推导过程的大致思路：把z变换定义式中的$x(n)$用IDFT的公式替换，然后交换求和次序，再利用旋转因子的性质，即可得到。如下图：</p>
<p><img src="https://pic.imgdb.cn/item/61fa36922ab3f51d91e5bf47.jpg" style="zoom:70%"></p>
<p>解决了由$X(k)$得到$X(z)$的问题，将$z$换成$e^{j\omega}$，自然就得到了$X(e^{j\omega})$。如下图：</p>
<p><img src="https://pic.imgdb.cn/item/61fa37172ab3f51d91e642e8.jpg" style="zoom:70%"></p>
<p>把内插公式和内插函数总结如下图，这个内插函数的幅度部分的图形我们可以画出来，我们发现，它在一些固定的位置($\dfrac{2\pi}{N}$的整数倍处）是零，而$\dfrac{2\pi}{N}​$恰好是频域抽样时的间隔，这是巧合吗？显然不是，这是必然的。</p>
<p><img src="https://pic.imgdb.cn/item/61fa377b2ab3f51d91e6a274.jpg" style="zoom:70%"></p>
<p>我们把内插公式展开来看，如下图所示。也就是说，把各个频域抽样值$X(k)$与做相应平移后的内插函数（平移$\dfrac{2\pi}N$的$k$倍）相乘，再相加，就得到连续的频谱函数$X(e^{j\omega})$。与第$k$个抽样值相乘的内插函数，在所有其他抽样点处刚好是零点，只有在第$k$个抽样点处的值不为零(值为1)。所以，重建后的这个连续函数，在每个抽样位置（也就是$\dfrac{2}{N}$的整数倍)上的值，就等于$X(k)$这一点的值，不需要任何其他抽样值参与;而在两个抽样点之间的值（没抽到的地方)，需要所有抽样值来参与共同构成。</p>
<p><img src="https://pic.imgdb.cn/item/61fa38172ab3f51d91e73dc1.jpg" style="zoom:70%"></p>
<p>这个问题的理解，与“时域抽样后信号的重建”问题是一样的。但有的人可能会说，时域抽样后信号的重建，我记得是通过理想低通滤波器来推导出重建的内插公式，这里怎么不是呢?<br>如果你能提出这样的疑问，要表扬，说明你“信号与系统”学的不错。其实，图7和图8中的内插公式，完全可以用“时域抽样信号重建连续时间信号的内插公式”相同的推导方法推导出来。感兴趣的同学可以试一下哦。</p>
<h5 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：个人图书馆/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> </p>
<p><a href="http://www.360doc.com/content/19/0611/18/908538_841808337.shtml">http://www.360doc.com/content/19/0611/18/908538_841808337.shtml</a></p>
<p><a href="http://www.360doc.com/content/19/0611/18/908538_841808319.shtml">http://www.360doc.com/content/19/0611/18/908538_841808319.shtml</a></p>
<p><a href="http://www.360doc.com/content/19/0611/18/908538_841808298.shtml">http://www.360doc.com/content/19/0611/18/908538_841808298.shtml</a></p>
<p><a href="http://www.360doc.com/content/19/0611/18/908538_841808274.shtml">http://www.360doc.com/content/19/0611/18/908538_841808274.shtml</a></p>
<hr>
<h3 id="六、快速傅里叶变换FFT"><a href="#六、快速傅里叶变换FFT" class="headerlink" title="六、快速傅里叶变换FFT"></a>六、快速傅里叶变换FFT</h3><h4 id="一-改进DFT计算的方法"><a href="#一-改进DFT计算的方法" class="headerlink" title="(一) 改进DFT计算的方法"></a>(一) 改进DFT计算的方法</h4><h5 id="1-DFT计算量分析"><a href="#1-DFT计算量分析" class="headerlink" title="1. DFT计算量分析"></a>1. DFT计算量分析</h5><p>对于$N$点长的序列$x(n)$其DFT变换为</p>
<script type="math/tex; mode=display">
正变换：X(k) = \text{DFT}[x(n)] = \sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi}{N}kn} = \sum_{n=0}^{N-1}x(n)W_N^{nk}</script><script type="math/tex; mode=display">
逆变换：x(n) = \text{IDFT}[X(k)] = \frac{1}{N}\sum_{k=0}^{N-1}X(k)e^{j\frac{2\pi}{N}kn} = \sum_{k=0}^{N-1}X(k)W_N^{-nk}</script><p>DFT正反变换的运算方式和运算量是相同的，后面的分析以DFT正变换为例。</p>
<p>观察正变换和反变换的公式可知，二者的运算方式和运算量是完全相同的。下面的分析均以DFT正变换为例。(顺便说一句，大家要像熟悉自己的手机一样熟悉旋转因子，闭着眼睛都知道它)<br>观察DFT正变换的公式，容易看出：每计算一个点的数据，需要$N$次复数乘法、$N-1$次复数加法，所以$N$点DFT，需要$N$的平方次复数乘法，$N(N-1)$次复数加法。我们知道，DFT的点数，至少要取成序列的长度，当序列长度很长时，运算量巨大！如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序列长度</th>
<th style="text-align:center">复数乘法$N^2$</th>
<th style="text-align:center">复数加法$N(N-1)$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">64</td>
<td style="text-align:center">56</td>
</tr>
<tr>
<td style="text-align:center">64</td>
<td style="text-align:center">4096</td>
<td style="text-align:center">4032</td>
</tr>
<tr>
<td style="text-align:center">1024</td>
<td style="text-align:center">1048576</td>
<td style="text-align:center">1047552</td>
</tr>
<tr>
<td style="text-align:center">2048</td>
<td style="text-align:center">4194304</td>
<td style="text-align:center">4192256</td>
</tr>
</tbody>
</table>
</div>
<p>以1024点为例，复数乘法的次数100万次之多。</p>
<p>1965年，库利(J.w.Cooley)和图基(J.W.Tukey)在《Mathmatics of Computation》上发表了《AnAlgorithm for the Machine Calculation of Complex Fourier Series》，提出一种DFT的快速算法，后人称为快速傅里叶变换(Fast Fourier Transform ——FFT)。</p>
<h5 id="2-改进DFT计算效率的基本途径"><a href="#2-改进DFT计算效率的基本途径" class="headerlink" title="2. 改进DFT计算效率的基本途径"></a>2. 改进DFT计算效率的基本途径</h5><p><img src="https://pic.imgdb.cn/item/61fa3b0a2ab3f51d91ea2f7a.jpg" style="zoom:70%"></p>
<p>$N$点DFT，直接计算，需要$N$的平方次乘法；分成2个$\dfrac{N}{2}$点DFT分别计算，乘法的次数减少了一半；分成4个$\dfrac{N}{4}$点DFT，乘法的次数又减少了一半。如果能够继续下去，前景很让人向往。</p>
<p>为了能够一直分下去，我们限定$N$为2的整数次幂，即：$N=2^M$，称为<strong>基2FFT</strong>。由此可见，<font color="red"><strong>FFT的基本思想是：把长序列分成几个较短的序列</strong></font>。</p>
<p>但怎么分？不能随便分，基本原则：要保证这几个短序列的DFT组合起来后能够很方便地构成原来长序列的DFT。所以DFT快速算法要解决的两个核心问题是：<strong>怎么分？怎么合？</strong></p>
<p>根据分与合的方式不同，有两种基2FFT算法，分别称为:</p>
<ul>
<li>按时间抽取的FFT算法———Decimation-in-Time，简称DIT-FFT。</li>
<li>按频率抽取的FFT算法———Decimation-in-Frequency，简称DIF-FFT。</li>
</ul>
<p>下面我们分别来归纳总结两种基2FFT算法。</p>
<h4 id="二-两种基2FFT算法"><a href="#二-两种基2FFT算法" class="headerlink" title="(二) 两种基2FFT算法"></a>(二) 两种基2FFT算法</h4><h5 id="1-按时间抽取DIT-FFT算法"><a href="#1-按时间抽取DIT-FFT算法" class="headerlink" title="1. 按时间抽取DIT-FFT算法"></a>1. 按时间抽取DIT-FFT算法</h5><p>以第一次分解($N$点分为2个$\dfrac{N}{2}$点)为例来说明算法原理，首先解决怎么分的问题。</p>
<p><img src="https://pic.imgdb.cn/item/61fa3c602ab3f51d91eb7188.jpg" style="zoom:70%"></p>
<p>通俗地说，就是大家列队、报数（从0开始），报偶数的一组，奇数的一组。</p>
<p><img src="https://pic.imgdb.cn/item/61fa3c902ab3f51d91eba2c8.jpg" style="zoom:70%"></p>
<p>然后解决怎么合的问题，我们略过看似艰苦卓绝实际很简单的推导过程，直接上结论：</p>
<p><img src="https://pic.imgdb.cn/item/61fa3cbd2ab3f51d91ebcde6.jpg" style="zoom:70%"></p>
<p>公式不好看，有人画了一幅图，并且起了个好听的名字：<strong>蝶形运算符号</strong>。下面的动图演示了蝶形运算的过程:</p>
<p><img src="https://pic.imgdb.cn/item/61fa3fae2ab3f51d91ee90ff.gif"></p>
<p>以8点长序列为例，我们来看分解为2个4点长DFT，是如何通过蝶形运算合成8点DFT的： </p>
<p><img src="https://pic.imgdb.cn/item/61fa3ff22ab3f51d91eecd84.gif"></p>
<p>经过第一次分解之后，总的运算量=两个N/2点DFT的运算+N/2个蝶形的运算。而每次蝶形运算，只需要1次乘法，2次加法。所以，总的乘法次数为：</p>
<script type="math/tex; mode=display">
\frac{N^2}{2}+\frac{N}{2} \approx \frac{N^2}{2}</script><p>总加法次数为：</p>
<script type="math/tex; mode=display">
N(\frac{N}{2}-1)+N \approx \frac{N^2}{2}</script><p>当$N$很大时，运算量减少了近一半。</p>
<p>这就给了我们信心，说明这种分解思路是可以有效减少运算量的。我们继续分解下去，经过M-1次分解，分解为N/2 个 2 点长序列。</p>
<p>而2点DFT也用蝶形运算来表示（因为计算机最擅长一致而重复的东西），就得到下面的流图：</p>
<p><img src="https://pic.imgdb.cn/item/61fa40ce2ab3f51d91ef97a2.jpg"></p>
<h5 id="2-按频率抽取DIF-FFT算法"><a href="#2-按频率抽取DIF-FFT算法" class="headerlink" title="2. 按频率抽取DIF-FFT算法"></a>2. 按频率抽取DIF-FFT算法</h5><p>仍以第一次分解（$N$点分为2个$\dfrac N2$点）为例来说明算法原理。</p>
<p><img src="https://pic.imgdb.cn/item/61fa41312ab3f51d91effcba.jpg" style="zoom:80%"></p>
<p>以8点长序列为例，我们来看分解为2个4点长DFT，是如何通过蝶形运算合成8点DFT的： </p>
<p><img src="https://pic.imgdb.cn/item/61fa415c2ab3f51d91f02935.gif" style="zoom:120%"></p>
<p>注意到，输出的频率数据，序号是按照偶数一组、奇数一组的顺序排列的，所以这种算法称为：按频率抽取。我们继续分解下去，经过$M-1$次分解，分解为$N/2$ 个 2 点长序列，就得到下面的流图：</p>
<p><img src="https://pic.imgdb.cn/item/61fa419d2ab3f51d91f0698d.jpg"></p>
<h5 id="3-运算量分析"><a href="#3-运算量分析" class="headerlink" title="3. 运算量分析"></a>3. 运算量分析</h5><p>通过前面的分析可见，两种基2FFT算法，运算量是一样的，N点DFT，就分解成了若干个蝶形的运算而已。多少个蝶形呢？序列长度$N=2^M$，共有 $M$级蝶形，每级$\dfrac N2$个蝶形，共$\dfrac{MN}{2}$个。而每个蝶形是1次复数乘法，2次复数加法。所以总的运算量为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">FFT</th>
<th style="text-align:center">DFT</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">复数乘法</td>
<td style="text-align:center">$\dfrac{NM}{2} = \dfrac{N}{2}\log_2N$</td>
<td style="text-align:center">$N^2$</td>
</tr>
<tr>
<td style="text-align:center">复数加法</td>
<td style="text-align:center">$NM = N\log_2N$</td>
<td style="text-align:center">$N(N-1)$</td>
</tr>
</tbody>
</table>
</div>
<p>频率作为自然界的一个基本物理量，是很多领域研究的重要内容。人们很早就认识到，用DFT的方法可以有效进行信号的频率分析。但是因为DFT算法运算量很大，在数字计算机发明以前，运算效率普遍很低的情况下，DFT也更多的是一种理论分析工具，很难被用于实际的信号处理。</p>
<p>FFT的出现，破解了这一历史性难题，极大地促进了数字信号处理这门学科的应用和发展。有人甚至以FFT算法提出的1965年作为数字信号处理这门学科的诞生之年。</p>
<h5 id="4-算法特点"><a href="#4-算法特点" class="headerlink" title="4. 算法特点"></a>4. 算法特点</h5><p>在计算机看来，这两种算法是非常相像的。两者互为转置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">DIF-FFT</th>
<th style="text-align:center">DIF-FFT</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">同址运算</td>
<td style="text-align:center">将蝶形运算的结果仍然保存在原输入量的存储单元中</td>
<td style="text-align:center">将蝶形运算的结果仍然保存在原输入量的存储单元中</td>
</tr>
<tr>
<td style="text-align:center">输入/输出顺序</td>
<td style="text-align:center">输入倒位序,输出自然顺序</td>
<td style="text-align:center">输入自然顺序，输出倒位序</td>
</tr>
<tr>
<td style="text-align:center">蝶形运算</td>
<td style="text-align:center">先乘旋转因子，后加减第$m$级节点间距离:$2^{m-1}$</td>
<td style="text-align:center">先加减，后乘旋转因子第$m$级节点间距离:$2^{L-m}$</td>
</tr>
</tbody>
</table>
</div>
<p>首先来看第一个特点：同址运算（又称同位运算或原位运算），每完成一个蝶形运算，输入的两个数据就没有用的，这就意味着，不需要再重新开辟新的存储单元来保存输出数据，计算结果仍保留在原输入数据占据的存储单元即可。</p>
<p>再来看第二个特点：输入/输出数据的顺序。这是两种算法的不同之处。以DIT-FFT为例来说明为什么会输入倒位序。</p>
<p>还是以8点长数据为例，输入数据的正常顺序是$x(0)、x(1)、x(2)……x(7)$，我们称之为 自然顺序。按照序号的奇偶分为两组，第一组是$x(0)、x(2)、x(4)、x(6)$，第二组是$x(1)、x(3)、x(5)、x(7)$。每个新的组再重新排队报数，按奇偶分，第一组又分成两个组，分别是$x(0)、x(4)$和$x(2)、x(6)$，第二组分成两个组，分别是$x(1)、x(5)$和$x(3)、x(7)$。</p>
<p>也就是说，8点长序列的DIT-FFT，输入数据的顺序是：$x(0)、x(4)、x(2)、x(6)、x(1)、x(5)、x(3)、x(7)$。这个序号的顺序乍看杂乱无章，其实有规律性。0、1、2、3、4、5、6、7的顺序与0、4、2、6、1、3、5、7有何关系的呢？用二进制来写一目了然，看下面的动图：</p>
<p><img src="https://pic.imgdb.cn/item/61fa439a2ab3f51d91f24b96.gif"></p>
<p>倒位序，是将二进制数的最高有效位到最低有效位的位序进行颠倒排列而得到的二进制数。 </p>
<p>DIT-FFT算法中，对时域序列按照序号的奇偶进行分解，造成输入序列的序号按照倒位序排列。</p>
<p>最后再说一说蝶形运算的规律。两种FFT算法，最终都是转换成了M列、每列N/2个、一共MN/2个蝶形运算。但二者蝶形运算的规律有差异。</p>
<ul>
<li>第一个差异：基本蝶形不同。DIT是先乘旋转因子，再加或减；而DIF是先加或减，再乘旋转因子。</li>
<li>第二个差异：两种算法，蝴蝶翅膀的距离（即节点间的距离）和旋转因子的数目恰好相反。</li>
</ul>
<p>仔细观察两种算法的流图，我们会发现，二者互为转置。</p>
<h4 id="三-其他FFT算法简介"><a href="#三-其他FFT算法简介" class="headerlink" title="(三) 其他FFT算法简介"></a>(三) 其他FFT算法简介</h4><h5 id="1-混合基FFT"><a href="#1-混合基FFT" class="headerlink" title="1. 混合基FFT"></a>1. 混合基FFT</h5><p><img src="https://pic.imgdb.cn/item/61fa445b2ab3f51d91f30d11.png" style="zoom:80%"></p>
<h5 id="2-Chirp-z变换"><a href="#2-Chirp-z变换" class="headerlink" title="2. Chirp-z变换"></a>2. Chirp-z变换</h5><p>实际应用中，有时只对信号的某一频段感兴趣，即只需要计算单位圆上某一段的频谱值，而不需要计算[0，Π]区间的所有频谱采样值。此时，可以用”Chirp-z变换“（CZT）。</p>
<p>适用场合：窄带信号的DFT。</p>
<h5 id="3-Goertzel算法"><a href="#3-Goertzel算法" class="headerlink" title="3. Goertzel算法"></a>3. Goertzel算法</h5><p>在某些应用场合，只需计算很少几个频率点的频谱值。例如，双音多频信号（DTMF）的检测。此时可以采用卡泽尔（Goertzel）算法。</p>
<p>除此之外，傅里叶变换的快速算法还有很多种。不过应用最广泛的依然能是基2FFT算法，它是数字信号处理最经典算法之一，几乎各种主流的计算机编程语言都有现成的函数可以调用。不同型号的芯片，硬件开发商也都会给出优化后的FFT算法源代码，一般情况下直接调用就可以。</p>
<h5 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：个人图书馆/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> <a href="http://www.360doc.com/content/19/0611/18/908538_841808253.shtml">http://www.360doc.com/content/19/0611/18/908538_841808253.shtml</a></p>
<hr>
<h3 id="七、FFT算法的应用"><a href="#七、FFT算法的应用" class="headerlink" title="七、FFT算法的应用"></a>七、FFT算法的应用</h3><h5 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：个人图书馆/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> </p>
<p><a href="http://www.360doc.com/content/19/0611/18/908538_841808231.shtml">http://www.360doc.com/content/19/0611/18/908538_841808231.shtml</a></p>
<p><a href="http://www.360doc.com/content/19/0611/18/908538_841808103.shtml">http://www.360doc.com/content/19/0611/18/908538_841808103.shtml</a></p>
<hr>
<h3 id="八、Matlab中的fftshift函数"><a href="#八、Matlab中的fftshift函数" class="headerlink" title="八、Matlab中的fftshift函数"></a>八、Matlab中的fftshift函数</h3><p>一般情况下，在<code>fft()</code>之间先对输入数据进行<code>fftshift()</code>处理是没有必要的。没有什么必然性。<code>fftshift()</code>这个函数的存在的目的并不是为了这个，单纯地就是上面所说的为了让频谱观测显得更自然一些而已。 </p>
<p>这里先给出一个简单的解释（有时间再来补详细的解释）。这是从根本上来说是因为<code>fft()</code>处理的离散数据，进行的是离散傅里叶变换（DFT）。如果所要解析的数据本身就是一个离散周期性信号，那<code>fft()</code>给出的结果就反映了真实情况。但是现实应用中，所分析的信号并不是离散周期性信号，而我们所能做的又只能是调用<code>fft()</code>执行离散傅里叶变换进行分析，这种情况下<code>fft()</code>结果并没有完全反映真实情况，而是一种近似的或者“变形”的体现。这个时候我们就需要对<code>fft()</code>结果进行合理的解释间接地得到真实的情况，某种意义上<code>fftshift()</code>将频域数据前后半颠倒以使得频域数据显示出来的效果显得更自然也是属于这种情况。</p>
<p>比如(4)中给出的例子是对对称时域信号进行调用<code>fft()</code>处理，然后将其结果与傅里叶变换的理论解析结果进行对比。原始信号的时间区间是$[-\dfrac{T}{2}, \dfrac{T}{2}]$，这个数据采样后直接用<code>fft()</code>进行处理的话，由于<code>fft()</code>自然地认为数据是从<code>t=0</code>开始，所以可以理解为<code>fft()</code>的输入数据其实是将原始信号在时域上右移$\dfrac{T}{2}$所得到的信号，而<code>fft()</code>的变换结果则代表着这个时域上右移$\dfrac{T}{2}$所得到的信号的周期性拓展后的信号的离散时间傅里叶变换（DTFT）的一个周期内的数据。接下来从这个结果进行解析可反推得到原始信号的DFT结果。在<code>fft()</code>之前做<code>fftshift()</code>可以看作是一个小的trick, as an alternative to the post-analysis of the fft() result, without physical significance and necessity.</p>
<p>参考链接8.1：<a href="https://zhuanlan.zhihu.com/p/396863191">fftshift讲解 - 信号处理小王子的文章 - 知乎</a></p>
<p>参考链接8.2：<a href="https://www.cnblogs.com/zxhyxiao/p/12359243.html">关于MATLAB中fft，fftshift，fftshift(fft(fftshift(x)))，FFT要乘以dx 等问题理解 - 博客园</a></p>
<p>参考链接8.3：<a href="https://blog.csdn.net/chenxy_bwave/article/details/119185124">Matlab fftshift and ifftshift and some confusions - 笨牛慢耕 - CSDN</a></p>
<p>参考链接8.4：<a href="https://www.cnblogs.com/limanjihe/p/10014142.html">fftshift函数详解 - 博客园</a></p>
<hr>
<h3 id="九-Matlab实现部分简单信号处理算法"><a href="#九-Matlab实现部分简单信号处理算法" class="headerlink" title="九 Matlab实现部分简单信号处理算法"></a>九 Matlab实现部分简单信号处理算法</h3><h4 id="（一）傅里叶变换"><a href="#（一）傅里叶变换" class="headerlink" title="（一）傅里叶变换"></a>（一）傅里叶变换</h4><script type="math/tex; mode=display">
F(\omega) = \int_{-\infty}^{+\infty} f(t) \exp({-\mathrm j \omega t}) \text{ d}t</script><script type="math/tex; mode=display">
F(k) = \sum_{n=0}^{N-1} f(n) \exp\left(-\mathrm j \dfrac{2\pi}{N}nk\right)</script><h5 id="1-实现方法1：matlab内置函数fft"><a href="#1-实现方法1：matlab内置函数fft" class="headerlink" title="1. 实现方法1：matlab内置函数fft"></a>1. 实现方法1：matlab内置函数fft</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% matlab内置fft函数</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">% 采样频率</span></span><br><span class="line">fs = <span class="number">100</span>;</span><br><span class="line"><span class="comment">% 采样点数</span></span><br><span class="line">N = <span class="number">128</span>;</span><br><span class="line"><span class="comment">% 时间轴</span></span><br><span class="line">n = <span class="number">0</span>:N<span class="number">-1</span>;</span><br><span class="line">t = n/fs;</span><br><span class="line"><span class="comment">% 正弦信号频率</span></span><br><span class="line">f0 = <span class="number">20</span>;</span><br><span class="line"><span class="comment">% 正弦信号</span></span><br><span class="line">x = <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f0*t);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 作正弦信号的时域波形</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, x);</span><br><span class="line">xlabel(<span class="string">&#x27;t&#x27;</span>); ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;正弦信号时域波形&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 进行FFT变换并做频谱图</span></span><br><span class="line">y = fft(x ,N);</span><br><span class="line"><span class="comment">% 进行对应的频率转换</span></span><br><span class="line">f = (<span class="number">0</span>:<span class="built_in">length</span>(y)<span class="number">-1</span>)&#x27;*fs/<span class="built_in">length</span>(y);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 做频谱图</span></span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(f, <span class="built_in">abs</span>(y));</span><br><span class="line">xlabel(<span class="string">&#x27;频率(Hz)&#x27;</span>); ylabel(<span class="string">&#x27;幅值&#x27;</span>);</span><br><span class="line">title(<span class="string">&quot;正弦信号幅频谱图&quot;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://pic.imgdb.cn/item/667a19ead9c307b7e997cb36.png" alt="1719278028723.jpg"></p>
<h5 id="2-实现方法2：自己编写函数"><a href="#2-实现方法2：自己编写函数" class="headerlink" title="2. 实现方法2：自己编写函数"></a>2. 实现方法2：自己编写函数</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 自己编写dft函数  参考链接 —— https://www.jianshu.com/p/06c65b2a0408</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">% 采样频率</span></span><br><span class="line">fs = <span class="number">100</span>;</span><br><span class="line"><span class="comment">% 采样点数</span></span><br><span class="line">N = <span class="number">128</span>;</span><br><span class="line"><span class="comment">% 时间轴</span></span><br><span class="line">n = <span class="number">0</span>:N<span class="number">-1</span>;</span><br><span class="line">t = n/fs;</span><br><span class="line"><span class="comment">% 正弦信号频率</span></span><br><span class="line">f0 = <span class="number">20</span>;</span><br><span class="line"><span class="comment">% 正弦信号</span></span><br><span class="line">data = <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f0*t);</span><br><span class="line"><span class="comment">% 时域信号转化为列向量</span></span><br><span class="line">xk = data.&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 作正弦信号的时域波形</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, xk);</span><br><span class="line">xlabel(<span class="string">&#x27;t&#x27;</span>); ylabel(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;正弦信号时域波形&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% DFT需要的相关矩阵:</span></span><br><span class="line">WN = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>/N);</span><br><span class="line">WN_nk = <span class="built_in">zeros</span>(N, N)+WN;</span><br><span class="line"><span class="comment">% 辅助的E(WN_kn的幂,单独拿出来算)</span></span><br><span class="line">E = <span class="built_in">zeros</span>(N, N);   </span><br><span class="line"></span><br><span class="line"><span class="comment">% 构造DFT矩阵</span></span><br><span class="line"><span class="keyword">for</span> row = <span class="number">0</span>:N<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> cow = <span class="number">0</span>:N<span class="number">-1</span></span><br><span class="line">        E(row+<span class="number">1</span>, cow+<span class="number">1</span>) = row*cow;</span><br><span class="line">        WN_nk(row+<span class="number">1</span>, cow+<span class="number">1</span>) = WN_nk(row+<span class="number">1</span>, cow+<span class="number">1</span>)^E(row+<span class="number">1</span>, cow+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 利用DFT矩阵计算频谱</span></span><br><span class="line">Xk = WN_nk * xk;</span><br><span class="line"><span class="comment">% 进行对应的频率转换</span></span><br><span class="line">f = (<span class="number">0</span>:<span class="built_in">length</span>(Xk)<span class="number">-1</span>)&#x27;*fs/<span class="built_in">length</span>(Xk);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 做频谱图</span></span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(f, <span class="built_in">abs</span>(Xk));</span><br><span class="line">xlabel(<span class="string">&#x27;频率(Hz)&#x27;</span>); ylabel(<span class="string">&#x27;幅值&#x27;</span>);</span><br><span class="line">title(<span class="string">&quot;正弦信号幅频谱图&quot;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://pic.imgdb.cn/item/667a1b94d9c307b7e99a9206.png" alt="image.png"></p>
<h5 id="3-实现方法3：轴采样实际数据，而不是离散化标号"><a href="#3-实现方法3：轴采样实际数据，而不是离散化标号" class="headerlink" title="3. 实现方法3：轴采样实际数据，而不是离散化标号"></a>3. 实现方法3：轴采样实际数据，而不是离散化标号</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 自己编写函数，轴采样实际数据</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">% 采样频率</span></span><br><span class="line">fs = <span class="number">100</span>;</span><br><span class="line"><span class="comment">% 采样点数</span></span><br><span class="line">N = <span class="number">128</span>;</span><br><span class="line"><span class="comment">% 时间轴</span></span><br><span class="line">n = <span class="number">0</span>:N<span class="number">-1</span>;</span><br><span class="line">t = n/fs;</span><br><span class="line"><span class="comment">% 正弦信号频率</span></span><br><span class="line">f0 = <span class="number">20</span>;</span><br><span class="line"><span class="comment">% 正弦信号</span></span><br><span class="line">data = <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*f0*t);</span><br><span class="line">xk = data.&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 作正弦信号的时域波形</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, xk);</span><br><span class="line">xlabel(<span class="string">&#x27;t&#x27;</span>); ylabel(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;正弦信号时域波形&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 频率轴设置方式1</span></span><br><span class="line">CR_axis = (<span class="number">0</span>:N<span class="number">-1</span>)*fs/N;</span><br><span class="line"><span class="comment">% 傅里叶矩阵</span></span><br><span class="line">F_matrix = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*CR_axis.&#x27;*t);</span><br><span class="line">Xk = F_matrix*xk;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 做频谱图</span></span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(CR_axis, <span class="built_in">abs</span>(Xk));</span><br><span class="line">xlabel(<span class="string">&#x27;频率(Hz)&#x27;</span>); ylabel(<span class="string">&#x27;幅值&#x27;</span>);</span><br><span class="line">title(<span class="string">&quot;正弦信号幅频谱图(频率轴1)&quot;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 频率轴设置方式2</span></span><br><span class="line">CR_axis = (<span class="number">0</span>:N<span class="number">-1</span>)*fs/N-fs/<span class="number">2</span>;</span><br><span class="line"><span class="comment">% 傅里叶矩阵</span></span><br><span class="line">F_matrix = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*CR_axis.&#x27;*t);</span><br><span class="line">Xk = F_matrix*xk;</span><br><span class="line"><span class="comment">% 做频谱图</span></span><br><span class="line">subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(CR_axis, <span class="built_in">abs</span>(Xk));</span><br><span class="line">xlabel(<span class="string">&#x27;频率(Hz)&#x27;</span>); ylabel(<span class="string">&#x27;幅值&#x27;</span>);</span><br><span class="line">title(<span class="string">&quot;正弦信号幅频谱图(频率轴2)&quot;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://pic.imgdb.cn/item/667a1d2bd9c307b7e99d4d90.png" alt="image.png"></p>
<h4 id="（二）卷积、相关与类相关计算"><a href="#（二）卷积、相关与类相关计算" class="headerlink" title="（二）卷积、相关与类相关计算"></a>（二）卷积、相关与类相关计算</h4><h5 id="1-卷积"><a href="#1-卷积" class="headerlink" title="1. 卷积"></a>1. 卷积</h5><script type="math/tex; mode=display">
y(t) = s(t) \otimes h(t) = \int_{-\infty}^{+\infty} s(u) h(t-u) \text{ d}u = \int_{-\infty}^{+\infty}s(t-u)h(u) \text{ d}u</script><p>设滤波器的时间长度为$T$，以$t=0$为中心（非因果滤波器），则：</p>
<script type="math/tex; mode=display">
y(t) = s(t) \otimes h(t) = \int_{t-T/2}^{t+T/2} s(u) h(t-u) \text{ d}u = \int_{-T/2}^{+T/2}s(t-u)h(u) \text{ d}u</script><p>对于实际中的因果滤波器，定义域为$[0, T]$，则：</p>
<script type="math/tex; mode=display">
y(t) = s(t) \otimes h(t) = \int_{t}^{t+T} s(u) h(t-u) \text{ d}u = \int_{0}^{T}s(t-u)h(u) \text{ d}u</script><h5 id="2-自相关"><a href="#2-自相关" class="headerlink" title="2. 自相关"></a>2. 自相关</h5><script type="math/tex; mode=display">
R(\tau) = \int_{-\infty}^{+\infty} s(t)s^*(t-\tau) \text{ d}\tau =  \int_{-\infty}^{+\infty} s(t)s^*(t+\tau) \text{ d}\tau</script><script type="math/tex; mode=display">
R(m) = \sum_{n=-\infty}^{+\infty} s(n)s^*(n-m) =  \sum_{n=-\infty}^{+\infty} s(n)s^*(n+m)</script><p>实际中自相关函数$R[m]$，对于一个离散信号$x[n]$的定义为：</p>
<script type="math/tex; mode=display">
R(m) = \sum_{n=-0}^{N-1} s(n)s^*(n-m) =  \sum_{n=0}^{N-1} s(n)s^*(n+m)</script><p>其中，$m$是滞后值，范围是$[−N+1,N−1]$， $N$是信号的长度。 </p>
<ul>
<li>实现方法1：matlab内置xcorr函数</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 内置xcorr函数</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">% 计算并绘制信号的估计自相关。在零滞后时（此时 x 与自身完全匹配），出现最大峰值。</span></span><br><span class="line"><span class="comment">% 创建一个离散信号示例</span></span><br><span class="line">x = [<span class="number">1</span>+<span class="number">1</span><span class="built_in">i</span>, <span class="number">2</span><span class="number">-1</span><span class="built_in">i</span>, <span class="number">3</span>+<span class="number">2</span><span class="built_in">i</span>, <span class="number">4</span><span class="number">-2</span><span class="built_in">i</span>, <span class="number">5</span>+<span class="number">3</span><span class="built_in">i</span>, <span class="number">6</span><span class="number">-2</span><span class="built_in">i</span>, <span class="number">3</span>+<span class="number">4</span><span class="built_in">i</span>, <span class="number">5</span>+<span class="number">5</span><span class="built_in">i</span>];</span><br><span class="line"><span class="comment">% 计算自相关函数</span></span><br><span class="line">[r, lags] = xcorr(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制自相关函数</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">stem(lags, <span class="built_in">abs</span>(r));</span><br><span class="line">title(<span class="string">&#x27;自相关函数&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;Lag&#x27;</span>); ylabel(<span class="string">&#x27;自相关&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/667a358dd9c307b7e9cea9c5.png" alt="image.png" style="zoom:60%"></p>
<ul>
<li>实现方法2：根据s(n)*s(n+m)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 自己编写，根据s(n)*s(n+m)</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line">x = [<span class="number">1</span>+<span class="number">1</span><span class="built_in">i</span>, <span class="number">2</span><span class="number">-1</span><span class="built_in">i</span>, <span class="number">3</span>+<span class="number">2</span><span class="built_in">i</span>, <span class="number">4</span><span class="number">-2</span><span class="built_in">i</span>, <span class="number">5</span>+<span class="number">3</span><span class="built_in">i</span>, <span class="number">6</span><span class="number">-2</span><span class="built_in">i</span>, <span class="number">3</span>+<span class="number">4</span><span class="built_in">i</span>, <span class="number">5</span>+<span class="number">5</span><span class="built_in">i</span>];</span><br><span class="line"></span><br><span class="line">R = my_xcorr_complex(x);</span><br><span class="line"><span class="comment">% 绘制自相关函数</span></span><br><span class="line">lags = -<span class="built_in">length</span>(x)+<span class="number">1</span>:<span class="built_in">length</span>(x)<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">stem(lags, <span class="built_in">abs</span>(R));</span><br><span class="line">title(<span class="string">&#x27;复数信号的自相关函数&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;滞后&#x27;</span>); ylabel(<span class="string">&#x27;自相关&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">R</span> = <span class="title">my_xcorr_complex</span><span class="params">(x)</span></span></span><br><span class="line">    N = <span class="built_in">length</span>(x);          <span class="comment">% 信号的长度</span></span><br><span class="line">    R = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">2</span>*N<span class="number">-1</span>);    <span class="comment">% 初始化自相关函数结果向量</span></span><br><span class="line">    <span class="keyword">for</span> k = -N+<span class="number">1</span>:N<span class="number">-1</span>        <span class="comment">% 滞后值范围从 -N+1 到 N-1</span></span><br><span class="line">        <span class="keyword">for</span> n = <span class="number">1</span>:N         <span class="comment">% 遍历信号的每个样本点</span></span><br><span class="line">            <span class="keyword">if</span> (n+k &gt; <span class="number">0</span>) &amp;&amp; (n+k &lt;= N)  <span class="comment">% 检查索引是否在有效范围内</span></span><br><span class="line">                R(k+N) = R(k+N) + x(n) * <span class="built_in">conj</span>(x(n+k));  <span class="comment">% 累加乘积，包含共轭</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/667a373bd9c307b7e9d2a8c2.png" alt="image.png" style="zoom:60%"></p>
<ul>
<li>实现方法3：根据s(n)*s(n-m)</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 自己编写，根据s(n)*s(n-m)</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line">x = [<span class="number">1</span>+<span class="number">1</span><span class="built_in">i</span>, <span class="number">2</span><span class="number">-1</span><span class="built_in">i</span>, <span class="number">3</span>+<span class="number">2</span><span class="built_in">i</span>, <span class="number">4</span><span class="number">-2</span><span class="built_in">i</span>, <span class="number">5</span>+<span class="number">3</span><span class="built_in">i</span>, <span class="number">6</span><span class="number">-2</span><span class="built_in">i</span>, <span class="number">3</span>+<span class="number">4</span><span class="built_in">i</span>, <span class="number">5</span>+<span class="number">5</span><span class="built_in">i</span>];</span><br><span class="line">R = my_xcorr_complex(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制自相关函数</span></span><br><span class="line">lags = -<span class="built_in">length</span>(x)+<span class="number">1</span>:<span class="built_in">length</span>(x)<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">stem(lags, <span class="built_in">abs</span>(R));</span><br><span class="line">title(<span class="string">&#x27;复数信号的自相关函数&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;滞后&#x27;</span>); ylabel(<span class="string">&#x27;自相关&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">R</span> = <span class="title">my_xcorr_complex</span><span class="params">(x)</span></span></span><br><span class="line">    N = <span class="built_in">length</span>(x);          <span class="comment">% 信号的长度</span></span><br><span class="line">    R = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">2</span>*N<span class="number">-1</span>);    <span class="comment">% 初始化自相关函数结果向量</span></span><br><span class="line">    <span class="keyword">for</span> m = -N+<span class="number">1</span>:N<span class="number">-1</span>        <span class="comment">% 滞后值范围从 -N+1 到 N-1</span></span><br><span class="line">        <span class="keyword">for</span> n = <span class="number">1</span>:N         <span class="comment">% 遍历信号的每个样本点</span></span><br><span class="line">            <span class="keyword">if</span> (n-m &gt; <span class="number">0</span>) &amp;&amp; (n-m &lt;= N)  <span class="comment">% 检查索引是否在有效范围内</span></span><br><span class="line">                R(m+N) = R(m+N) + x(n) * <span class="built_in">conj</span>(x(n-m));  <span class="comment">% 累加乘积，包含共轭</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/667a373bd9c307b7e9d2a8c2.png" alt="image.png" style="zoom:60%"></p>
<h5 id="3-类相关"><a href="#3-类相关" class="headerlink" title="3. 类相关"></a>3. 类相关</h5><p>这主要是是来自Wigner-Ville变换公式：</p>
<script type="math/tex; mode=display">
W_x(t, \Omega) = \int_{-\infty}^{+\infty} x\left(t+\dfrac{\tau}{2}\right) x^*\left(t-\dfrac{\tau}{2}\right) \exp(-\mathrm j \Omega \tau) \text{ d}\tau</script><p>离散化后：</p>
<script type="math/tex; mode=display">
W_x(n,l) = 2 \sum_k r_x(n, k) \exp\left(-\mathrm j \dfrac{4\pi}{N}kl\right)</script><p><img src="https://pic.imgdb.cn/item/667a6654d9c307b7e9340a52.png" alt="image.png"></p>
<p><img src="https://pic.imgdb.cn/item/667a6672d9c307b7e9343ed4.png" alt="image.png"></p>
<p>注意，上面例子中，当$n=3$时候，我在计算的时候出现了下面可笑的结果：</p>
<script type="math/tex; mode=display">
n=3时，r_x(3, k) = \{x_0x_6^*,  x_1x_5^*, x_2x_4^*, x_3x_3^*, x_4x_2^*, x_5x_1^*, x_6x_0^* \}</script><p>而实际上，这里是没有$x_6$这一项的，故$n=3$时只有5项。</p>
<h4 id="（三）连续信号变换的离散化"><a href="#（三）连续信号变换的离散化" class="headerlink" title="（三）连续信号变换的离散化"></a>（三）连续信号变换的离散化</h4><ul>
<li>这里简单用几句话总结一下目前的理解：<ul>
<li>① 首先离散化积分变量(这里积分变量在信号处理中一般是时间变量或时延变量或频率变量)；</li>
<li>② 其次，当没有积分项后，其实剩下的连续变量主要是看该连续变量的取值范围，然后直接离散化就行。</li>
</ul>
</li>
<li>两点注意：<ul>
<li>ì.  当考察到变量存在<strong>周期性</strong>时候，只需要在变量的一个周期内离散采样即可。</li>
<li>ìì. 注意变量的取值范围，确定不了就试，一般就试$(0 \sim N-1)$或$(-N/2 \sim N/2-1)$范围。</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>信号处理与雷达</category>
        <category>信号与系统</category>
      </categories>
      <tags>
        <tag>数字信号</tag>
        <tag>频谱分析</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习_吴恩达_Part_2</title>
    <url>/2023/06/15/Foundation-of-DeepLearning-2/</url>
    <content><![CDATA[<h3 id="第四章-深层神经网络"><a href="#第四章-深层神经网络" class="headerlink" title="第四章 深层神经网络"></a>第四章 深层神经网络</h3><p>上节主要介绍了浅层神经网络。首先介绍神经网络的基本结构，包括输入层，隐藏层和输出层。然后以简单的2 layer NN为例，详细推导了其正向传播过程和反向传播过程，使用梯度下降的方法优化神经网络参数。我们还介绍了不同的激活函数，比较各自优缺点，讨论了激活函数必须是非线性的原因。最后介绍了神经网络参数随机初始化的必要性，特别是权重<script type="math/tex">W</script>，不同神经元的<script type="math/tex">W</script>不能初始化为同一零值。本节课是对上节课的延伸和扩展，讨论更深层的神经网络。</p>
<h4 id="4-1-深层神经网络概述"><a href="#4-1-深层神经网络概述" class="headerlink" title="4.1 深层神经网络概述"></a>4.1 深层神经网络概述</h4><p>深层神经网络其实就是包含更多的隐藏层神经网络。如下图所示，分别列举了逻辑回归、1个隐藏层的神经网络、2个隐藏层的神经网络和5个隐藏层的神经网络它们的模型结构。</p>
<p><img src="https://pic.imgdb.cn/item/648ac9781ddac507cc6cd8f2.png"></p>
<p>命名规则上，一般只参考隐藏层个数和输出层。例如，上图中的逻辑回归又叫1 layer NN，1个隐藏层的神经网络叫做2 layer NN，2个隐藏层的神经网络叫做3 layer NN，以此类推。如果是L-layer NN，则包含了L-1个隐藏层，最后的L层是输出层。</p>
<p>下面以一个4层神经网络为例来介绍关于神经网络的一些标记写法。如图30所示。</p>
<ul>
<li>总层数：用<script type="math/tex">L</script>表示，<script type="math/tex">L=4</script>。输入层是第<script type="math/tex">0</script>层，输出层是第<script type="math/tex">L</script>层。</li>
<li><script type="math/tex">n^{[l]}</script>表示第<script type="math/tex">l</script>层包含的单元个数，<script type="math/tex">l=0,1,⋯,L</script>。这个模型中，<script type="math/tex">n^{[0]}=n_x=3</script>，表示三个输入特征<script type="math/tex">x_1,x_2,x_3</script>。<script type="math/tex">n^{[1]}=5，n^{[2]}=5，n^{[3]}=3，n^{[4]}=n^{[L]}=1</script>。</li>
<li>第<script type="math/tex">l</script>层的激活函数输出用<script type="math/tex">a^{[l]}</script>表示，<script type="math/tex">a^{[l]}=g^{[l]}(z^{[l]})</script>。</li>
<li><script type="math/tex">W^{[l]}</script>表示第<script type="math/tex">l</script>层的权重，用于计算z[l]。<br>另外，我们把输入<script type="math/tex">x</script>记为<script type="math/tex">a^{[0]}</script>，把输出层<script type="math/tex">\hat y</script>记为<script type="math/tex">a^{[L]}</script>。</li>
</ul>
<p>注意，<script type="math/tex">a^{[l]}</script>和<script type="math/tex">W^{[l]}</script>中的上标<script type="math/tex">l</script>都是从<script type="math/tex">1</script>开始的，<script type="math/tex">l=1,⋯,L</script>。</p>
<p><img src="https://pic.imgdb.cn/item/648ac9ba1ddac507cc6ddfdd.png" style="zoom:40%"></p>
<h4 id="4-2-深层神经网络中的前向传播"><a href="#4-2-深层神经网络中的前向传播" class="headerlink" title="4.2 深层神经网络中的前向传播"></a>4.2 深层神经网络中的前向传播</h4><p>对于第<script type="math/tex">l</script>层，其正向传播过程的<script type="math/tex">Z^{[l]}</script>和<script type="math/tex">A^{[l]}</script>可以表示为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
Z^{[l]}=W^{[l]} A^{[l-1]}+b^{[l]} \\
A^{[l]}=g^{[l]}\left(Z^{[l]}\right)
\end{gathered}</script><p>其中，<script type="math/tex">l = 1,...L</script>。</p>
<h4 id="4-3-核对矩阵的维数"><a href="#4-3-核对矩阵的维数" class="headerlink" title="4.3 核对矩阵的维数"></a>4.3 核对矩阵的维数</h4><p>对于单个训练样本，输入<script type="math/tex">x</script>的维度是<script type="math/tex">(n^{[0]},1)</script>神经网络的参数<script type="math/tex">W^{[l]}</script>和<script type="math/tex">b^{[l]}</script>的维度分别是：</p>
<script type="math/tex; mode=display">
\begin{gathered}W^{[l]}:\left(n^{[l]}, n^{[l-1]}\right) \\b^{[l]}:\left(n^{[l]}, 1\right)\end{gathered}</script><p>其中，<script type="math/tex">l=1,⋯,L</script>，<script type="math/tex">n^{[l]}</script>和<script type="math/tex">n^{[l−1]}</script>分别表示第<script type="math/tex">l</script>层和<script type="math/tex">l−1</script>层的所含单元个数。<script type="math/tex">n^{[0]}=n_x</script>，表示输入层特征数目。</p>
<p>顺便提一下，反向传播过程中的<script type="math/tex">\mathrm dW^{[l]}</script>、<script type="math/tex">\mathrm db^{[l]}</script>的维度和<script type="math/tex">W</script>、<script type="math/tex">b</script>的<strong>维度相同</strong>。</p>
<p>正向传播过程中的<script type="math/tex">z^{[l]}</script>和<script type="math/tex">a^{[l]}</script>的维度分别是：</p>
<script type="math/tex; mode=display">
\begin{aligned}&z^{[l]}:\left(n^{[l]}, 1\right) \\&a^{[l]}:\left(n^{[l]}, 1\right)\end{aligned}</script><p>$z^{[l]}$和$a^{[l]}$的维度是一样的，且$\mathrm dz^{[l]}$和$\mathrm da^{[l]}$的维度均与$z^{[l]}$和$a^{[l]}$的维度一致。</p>
<p>对于$m$个训练样本，输入矩阵$X$的维度是$(n^{[0]},m)$。需要注意的是$W^{[l]}$和$b^{[l]}$的维度与只有单个样本是一致的：</p>
<script type="math/tex; mode=display">
\begin{gathered}W^{[l]}:\left(n^{[l]}, n^{[l-1]}\right) \\b^{[l]}:\left(n^{[l]}, 1\right)\end{gathered}</script><p>只不过在运算$Z^{[l]}=W^{[l]}A^{[l−1]}+b^{[l]}$中，$b^{[l]}$会被当成$(n^{[l]},m)$矩阵进行运算，这是因为python的广播性质，且$b^{[l]}$每一列向量都是一样的。$\mathrm dW^{[l]}$和$\mathrm db^{[l]}$的维度分别与$W$和$b$的相同。但是，$Z^{[l]}$和$A^{[l]}$的维度发生了变化：</p>
<script type="math/tex; mode=display">
\begin{gathered}
Z^{[l]}:\left(n^{[l]}, m\right)\\
A^{[l]}:\left(n^{[l]}, m\right)
\end{gathered}</script><p>$\mathrm dZ^{[l]}$和$\mathrm dA^{[l]}$的维度分别与$Z^{[l]}$和$A^{[l]}$的相同。</p>
<h4 id="4-4-为什么使用深层表示"><a href="#4-4-为什么使用深层表示" class="headerlink" title="4.4 为什么使用深层表示"></a>4.4 为什么使用深层表示</h4><p>神经网络能处理很多问题，而且效果显著。其强大能力主要源自神经网络足够<strong>“深”</strong>，也就是说网络层数越多，神经网络就更加复杂和深入，学习也更加准确。接下来，我们从几个例子入手，看一下为什么深度网络能够如此强大。</p>
<p>先来看人脸识别的例子，如下图所示。经过训练，神经网络第一层所做的事就是从原始图片中提取出人脸的轮廓与边缘，即边缘检测。这样每个神经元得到的是一些边缘信息。神经网络第二层所做的事情就是将前一层的边缘进行组合，组合成人脸一些局部特征，比如眼睛、鼻子、嘴巴等。再往后面，就将这些局部特征组合起来，融合成人脸的模样。可以看出，<strong>随着层数由浅到深，神经网络提取的特征也是从边缘到局部特征到整体，由简单到复杂。可见，如果隐藏层足够多，那么能够提取的特征就越丰富、越复杂，模型的准确率就会越高。</strong></p>
<p>语音识别模型也是这个道理。浅层的神经元能够检测一些简单的音调，然后较深的神经元能够检测出基本的音素，更深的神经元就能够检测出单词信息。如果网络够深，还能对短语、句子进行检测。<strong>记住一点，神经网络从左到右，神经元提取的特征从简单到复杂。特征复杂度与神经网络层数成正相关。特征越来越复杂，功能也越来越强大</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/648acaa01ddac507cc70ee96.png"></p>
<p>除了从提取特征复杂度的角度来说明深层网络的优势之外，深层网络还有另外一个优点，就是能够减少神经元个数，从而减少计算量。例如下面这个例子，使用电路理论，计算逻辑输出：</p>
<script type="math/tex; mode=display">
y=x_{1} \oplus x_{2} \oplus x_{3} \oplus \cdots \oplus x_{n}</script><p>其中，⊕表示异或操作。对于这个逻辑运算，如果使用深度网络，深度网络的结构是每层将前一层的两两单元进行异或，最后到一个输出，如下图左边所示。这样，整个深度网络的层数是<script type="math/tex">log_2(n)</script>，不包含输入层。总共使用的神经元个数为：</p>
<script type="math/tex; mode=display">
1+2+\cdots+2^{\log _{2}(n)-1}=1 \cdot \frac{1-2^{\log _{2}(n)}}{1-2}=2^{\log _{2}(n)}-1=n-1</script><p>可见，输入个数是$n$，这种深层网络所需的神经元个数仅仅是$n-1$个。</p>
<p>如果不用深层网络，仅仅使用单个隐藏层，那么需要的神经元个数将是指数级别那么大。Andrew指出，由于包含了所有的逻辑位（0和1），则需要$2^{n−1}$个神经元。<strong>这里笔者推导的是</strong>$2^n$<strong>个神经元，为啥是</strong>$2^{n−1}$<strong>请哪位高手解释下。</strong></p>
<p>比较下来，处理同一逻辑问题，深层网络所需的神经元个数比浅层网络要少很多。这也是深层神经网络的优点之一。</p>
<p>尽管深度学习有着非常显著的优势，Andrew还是建议对实际问题进行建模时，尽量先选择层数少的神经网络模型，这也符合奥卡姆剃刀定律(Occam’s Razor)。对于比较复杂的问题，再使用较深的神经网络模型。</p>
<h4 id="4-5-搭建深层神经网络模块"><a href="#4-5-搭建深层神经网络模块" class="headerlink" title="4.5 搭建深层神经网络模块"></a>4.5 搭建深层神经网络模块</h4><p>下面用流程块图来解释神经网络正向传播和反向传播过程。如下图所示，对于第<script type="math/tex">l</script>层来说，正向传播过程中：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"><strong>正向传播</strong></th>
<th style="text-align:left"><strong>反向传播</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>输入</strong></td>
<td style="text-align:left">$a^{[l-1]}$</td>
<td style="text-align:left">$\mathrm da^{[l]}$</td>
</tr>
<tr>
<td style="text-align:left"><strong>输出</strong></td>
<td style="text-align:left">$a^{[l]}$</td>
<td style="text-align:left">$\mathrm da^{[l-1]}, \mathrm dW^{[l]}, \mathrm db^{[l]}$</td>
</tr>
<tr>
<td style="text-align:left"><strong>参数</strong></td>
<td style="text-align:left">$W^{[l]},b^{[l]}$</td>
<td style="text-align:left">$W^{[l]},b^{[l]}$</td>
</tr>
<tr>
<td style="text-align:left"><strong>缓存变量</strong></td>
<td style="text-align:left">$z^{[l]}$</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://pic.imgdb.cn/item/648acb1f1ddac507cc728405.png" style="zoom:50%"></p>
<p>刚才这是第$l$层的流程块图，对于神经网络所有层，整体的流程块图正向传播过程和反向传播过程如下所示：</p>
<p><img src="https://pic.imgdb.cn/item/648acb641ddac507cc737af1.png"></p>
<h4 id="4-6-前向和反向传播"><a href="#4-6-前向和反向传播" class="headerlink" title="4.6 前向和反向传播"></a>4.6 前向和反向传播</h4><p>接着上一部分流程块图的内容，推导神经网络正向传播过程和反向传播过程的具体表达式。首先是正向传播过程，令层数为第$l$层，输入是$a^{[l−1]}$，输出是$a^{[l]}$，缓存变量是$z^{[l]}$。其表达式如下：</p>
<script type="math/tex; mode=display">
\begin{gathered}
z^{[l]}=W^{[l]} a^{[l-1]}+b^{[l]} \\
a^{[l]}=g^{[l]}\left(z^{[l]}\right)
\end{gathered}</script><p>$m$个训练样本，向量化形式为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
Z^{[l]}=W^{[l]} A^{[l-1]}+b^{[l]} \\
A^{[l]}=g^{[l]}\left(Z^{[l]}\right)
\end{gathered}</script><p>然后是反向传播过程，输入是$\mathrm da^{[l]}$，输出是$\mathrm da^{[l−1]}, \mathrm  dw^{[l]}, \mathrm db^{[l]}$。其表达式如下：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathrm d z^{[l]}=\mathrm d a^{[l]} * g^{[l]^{\prime}}\left(z^{[l]}\right) \\
\mathrm d W^{[l]}=\mathrm d z^{[l]} \cdot a^{[l-1]} \\
\mathrm d b^{[l]}=\mathrm d z^{[l]} \\
\mathrm d a^{[l-1]}=W^{[l] T} \cdot \mathrm d z^{[l]}
\end{gathered}</script><p>由上述第四个表达式可得$\mathrm da^{[l]}=W^{[l+1]T}⋅\mathrm dz^{[l+1]}​$，将$\mathrm da^{[l]}​$代入第一个表达式中可以得到：</p>
<script type="math/tex; mode=display">
\mathrm d z^{[l]}=W^{[l+1] T} \cdot \mathrm d z^{[l+1]} * g^{[l]^{\prime}}\left(z^{[l]}\right)</script><p>该式非常重要，反映了$\mathrm dz^{[l+1]}$与$\mathrm dz^{[l]}$的递推关系。</p>
<p>$m$个训练样本，向量化形式为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathrm d Z^{[l]}=\mathrm d A^{[l]} * g^{[l]^{\prime}}\left(Z^{[l]}\right) \\
\mathrm d W^{[l]}=\frac{1}{m} \mathrm d Z^{[l]} \cdot A^{[l-1] T} \\
\mathrm d b^{[l]}=\frac{1}{m} n p \cdot \sum\left(\mathrm d Z^{[l]}, \text { axis }=1, \text { keepdim }=\text { True }\right) \\
\mathrm d A^{[l-1]}=W^{[l] T} \cdot\mathrm  d Z^{[l]} \\
\mathrm d Z^{[l]}=W^{[l+1] T} \cdot \mathrm d Z^{[l+1]} * g^{[l]^{\prime}}\left(Z^{[l]}\right)
\end{gathered}</script><h4 id="4-7-参数-VS超参数"><a href="#4-7-参数-VS超参数" class="headerlink" title="4.7 参数 VS超参数"></a>4.7 参数 VS超参数</h4><p>该部分介绍神经网络中的参数（parameters）和超参数（hyperparameters）的概念。</p>
<p>神经网络中的参数就是我们熟悉的<script type="math/tex">W^{[l]}</script>和<script type="math/tex">b^{[l]}</script>。而超参数则是例如学习速率<script type="math/tex">\alpha</script>，训练迭代次数<script type="math/tex">N</script>，神经网络层数<script type="math/tex">L</script>，各层神经元个数<script type="math/tex">n^{[l]}</script>，激活函数<script type="math/tex">g(z)</script>等。之所以叫做超参数的原因是它们决定了参数<script type="math/tex">W^{[l]}</script>和<script type="math/tex">b^{[l]}</script>的值。在后面的第二门课我们还将学习其它的超参数，这里先不讨论。</p>
<p>如何设置最优的超参数是一个比较困难的、需要经验知识的问题。通常的做法是选择超参数一定范围内的值，分别代入神经网络进行训练，测试cost  function随着迭代次数增加的变化，根据结果选择cost function最小时对应的超参数值。这类似于validation的方法。</p>
<h3 id="第五章-深度学习的实用层面"><a href="#第五章-深度学习的实用层面" class="headerlink" title="第五章 深度学习的实用层面"></a>第五章 深度学习的实用层面</h3><h4 id="5-1-训练-验证-测试集"><a href="#5-1-训练-验证-测试集" class="headerlink" title="5.1 训练-验证-测试集"></a>5.1 训练-验证-测试集</h4><p>选择最佳的<strong>训练集(Training sets)</strong>、<strong>验证集(Development sets)</strong>、<strong>测试集(Test sets)</strong>对神经网络的性能影响非常重要。除此之外，在构建一个神经网络的时候，需要设置许多参数，例如神经网络的层数、每个隐藏层包含的神经元个数、学习因子(学习速率)、激活函数的选择等等。实际上很难在第一次设置的时候就选择到这些最佳的参数，而是需要通过不断地迭代更新来获得。这个循环迭代的过程是这样的：</p>
<p>(1) 先有个想法Idea，先选择初始的参数值，构建神经网络模型结构；</p>
<p>(2) 然后通过代码Code的形式，实现这个神经网络；</p>
<p>(3) 最后通过实验Experiment验证这些参数对应的神经网络的表现性能。</p>
<p>根据验证结果，我们对参数进行适当的调整优化，再进行下一次的<strong>Idea-&gt;Code-&gt;Experiment</strong>循环。通过很多次的循环，不断调整参数，选定最佳的参数值，从而让神经网络性能最优化。</p>
<p>一般地，我们将所有的样本数据分成三个部分：Train/Dev/Test sets。Train sets用来训练你的算法模型；Dev sets用来验证不同算法的表现情况，从中选择最好的算法模型；Test sets用来测试最好算法的实际表现，作为该算法的无偏估计。</p>
<p>之前人们通常设置Train sets和Test sets的数量比例为70%和30%。如果有Dev sets，则设置比例为60%、20%、20%，分别对应Train/Dev/Test sets。这种比例分配在样本数量不是很大的情况下，例如100,1000,10000，是比较科学的。但是如果数据量很大的时候，例如100万，科学的做法是要将Dev sets和Test sets的比例设置得很低。因为Dev sets的目标是用来比较验证不同算法的优劣，从而选择更好的算法模型就行了。因此，对于大数据样本，Train/Dev/Test sets的比例通常可以设置为98%/1%/1%，或者99%/0.5%/0.5%。样本数据量越大，相应的Dev/Test sets的比例可以设置的越低一些。</p>
<p>现代深度学习还有个重要的问题就是<strong>训练样本和测试样本分布上不匹配</strong>，意思是训练样本和测试样本来自于不同的分布。解决这一问题的比较科学的办法是尽量保证Dev sets和Test sets来自于同一分布。值得一提的是，训练样本非常重要，通常我们可以将现有的训练样本做一些处理，例如<strong>图片的翻转、假如随机噪声等，来扩大训练样本的数量</strong>，从而让该模型更加强大。即使Train sets和Dev/Test sets不来自同一分布，使用这些技巧也能提高模型性能。</p>
<p>最后提一点的是如果<strong>没有Test sets也是没有问题</strong>的。Test sets的目标主要是进行<strong>无偏估计</strong>。我们可以通过Train sets训练不同的算法模型，然后分别在Dev sets上进行验证，根据结果选择最好的算法模型。这样也是可以的，不需要再进行无偏估计了。如果只有Train sets和Dev sets，通常也有人把这里的Dev sets称为Test sets，我们要注意加以区别。</p>
<h4 id="5-2-偏差和方差"><a href="#5-2-偏差和方差" class="headerlink" title="5.2 偏差和方差"></a>5.2 偏差和方差</h4><p>偏差(bias)和方差(Variance)是机器学习领域非常重要的两个概念和需要解决的问题。在传统的机器学习算法中，Bias和Variance是对立的，分别对应着欠拟合和过拟合，我们常常需要在Bias和Variance之间进行权衡。而在深度学习中，我们可以同时减小Bias和Variance，构建最佳神经网络模型。</p>
<p>如下图所示，显示了二维平面上，high bias，just right，high variance的例子。可见，high bias对应着欠拟合，而high variance对应着过拟合。</p>
<p><img src="https://pic.imgdb.cn/item/648acbe91ddac507cc755d84.png"></p>
<p>上图这个例子中输入特征是二维的，high bias和high variance可以直接从图中分类线看出来。而对于输入特征是高维的情况，如何来判断是否出现了high bias或者high variance呢？</p>
<p>例如猫识别问题，输入是一幅图像，其特征维度很大。这种情况下，我们可以通过两个数值<strong>Train set error</strong>和<strong>Dev set error</strong>来理解bias和variance。</p>
<p>(1) 假设Train set error为1%，而Dev set error为11%，即该算法模型对训练样本的识别很好，但是对验证集的识别却不太好。这说明了该模型对训练样本可能存在<strong>过拟合</strong>，模型泛化能力不强，导致验证集识别率低。这恰恰是<strong>high variance</strong>的表现。</p>
<p>(2) 假设Train set error为15%，而Dev set error为16%，虽然二者error接近，即该算法模型对训练样本和验证集的识别都不是太好。这说明了该模型对训练样本存在<strong>欠拟合</strong>。这恰恰是<strong>high bias</strong>的表现。</p>
<p>(3) 假设Train set error为15%，而Dev set error为30%，说明了该模型既存在high bias也存在high variance(深度学习中最坏的情况)。</p>
<p>(4) 假设Train set error为0.5%，而Dev set error为1%，即low bias和low variance，是最好的情况。</p>
<p>值得一提的是，以上的这些假设都是建立在<strong>base error是0</strong>的基础上，即人类都能正确识别所有猫类图片。base error不同，相应的Train set error和Dev set error会有所变化，但没有相对变化。</p>
<p>一般来说，Train set error体现了是否出现bias，Dev set error体现了是否出现variance(正确地说，应该是Dev set error与Train set error的相对差值)。</p>
<p>我们已经通过二维平面展示了high bias或者high variance的模型，下图展示了high bias and high variance的模型：</p>
<p><img src="https://pic.imgdb.cn/item/648acc1c1ddac507cc760c33.png" style="zoom:60%"></p>
<p>模型既存在high bias也存在high variance，可以理解成某段区域是欠拟合的，某段区域是过拟合的。</p>
<h4 id="5-3-机器学习基础"><a href="#5-3-机器学习基础" class="headerlink" title="5.3 机器学习基础"></a>5.3 机器学习基础</h4><p>机器学习中基本的一个诀窍就是<strong>避免出现high bias和high variance</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/648acc6d1ddac507cc771342.png"></p>
<p><img src="https://pic.imgdb.cn/item/648acd391ddac507cc79e747.png" style="zoom:60%"></p>
<p>这里有几点需要注意的。</p>
<p>第一，解决high bias和high variance的方法是不同的。实际应用中通过Train set error和Dev set error判断是否出现了high bias或者high variance，然后再选择针对性的方法解决问题。</p>
<p>第二，Bias和Variance的折中tradeoff。传统机器学习算法中，Bias和Variance通常是对立的，减小Bias会增加Variance，减小Variance会增加Bias。而在现在的深度学习中，通过使用更复杂的神经网络和海量的训练样本，一般能够同时有效减小Bias和Variance。这也是深度学习之所以如此强大的原因之一。</p>
<h4 id="5-4-正则化"><a href="#5-4-正则化" class="headerlink" title="5.4 正则化"></a>5.4 正则化</h4><p>如果出现了过拟合，即high variance，则需要采用正则化regularization来解决。虽然扩大训练样本数量也是减小high variance的一种方法，但是通常获得更多训练样本的成本太高，比较困难。所以，更可行有效的办法就是使用regularization。</p>
<p>回顾一下之前介绍的Logistic regression。采用L2 regularization，其表达式为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
J(w, b)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)+\frac{\lambda}{2 m}\|w\|_{2}^{2} \\
\|w\|_{2}^{2}=\sum_{j=1}^{n_{x}} w_{j}^{2}=w^{T} w
\end{gathered}</script><blockquote>
<p>这里有个问题：<strong>为什么只对w进行正则化而不对b进行正则化呢？</strong>其实也可以对b进行正则化。但是一般w的维度很大，而b只是一个常数。相比较来说，参数很大程度上由w决定，改变b值对整体模型影响较小。所以，一般为了简便，就忽略对b的正则化了。<br>除了L2 regularization之外，还有另外一只正则化方法：L1 regularization。其表达式为：</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{gathered}
J(w, b)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)+\frac{\lambda}{2 m}\|w\|_{1} \\
\|w\|_{1}=\sum_{j=1}^{n_{x}}\left|w_{j}\right|
\end{gathered}</script><p>与L2 regularization相比，L1 regularization得到的<script type="math/tex">w</script><strong>更加稀疏</strong>，即很多<script type="math/tex">w</script>为零值，所以其优点是节约存储空间。但实际L1 regularization在解决high variance方面比L2 regularization并不更具优势。而且L1的在微分求导方面比较复杂。所以，一般L2 regularization更加常用。</p>
<p>L1、L2 regularization中的<strong>λ就是正则化参数(超参数的一种)</strong>。可以设置λ为不同的值，在Dev set中进行验证，选择最佳的λ。顺便提一下，在python中，由于lambda是保留字，所以为了避免冲突，我们使用lambd来表示λ。</p>
<p>在深度学习模型中，L2 regularization的表达式为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
J\left(w^{[1]}, b^{[1]}, \cdots, w^{[L]}, b^{[L]}\right)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)+\frac{\lambda}{2 m} \sum_{l=1}^{L}\left\|w^{[l]}\right\|^{2} \\
\left\|w^{[l]}\right\|^{2}=\sum_{i=1}^{n^{[l]}} \sum_{j=1}^{n^{[l-1]}}\left(w_{i j}^{[l]}\right)^{2}
\end{gathered}</script><p>通常，我们把<script type="math/tex">||w^{[l]}||^2</script>称为Frobenius范数，记为<script type="math/tex">||w^{[l]}||^2_F</script>。一个矩阵的Frobenius范数就是计算所有元素平方和再开方，如下所示：</p>
<script type="math/tex; mode=display">
\|A\|_{F}=\sqrt{\sum_{i=1}^{m} \sum_{j=1}^{n}\left|a_{i j}\right|^{2}}</script><p>值得注意的是，由于加入了正则化项，梯度下降算法中的<script type="math/tex">dw^{[l]}</script>计算表达式需要做如下修改：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathrm d w^{[l]}=\mathrm d w_{\text {before }}^{[l]}+\frac{\lambda}{m} w^{[l]} \\w^{[l]}:=w^{[l]}-\alpha \cdot d w^{[l]}
\end{gathered}</script><p>L2 regularization也被称做<strong>权重衰减(weight decay)</strong>。这是因为，由于加上了正则项，<script type="math/tex">\mathrm  dw^{[l]}</script>有个增量，在更新<script type="math/tex">w^{[l]}</script>的时候，会多减去这个增量，使得<script type="math/tex">w^{[l]}</script>比没有正则项的值要小一些。不断迭代更新，不断地减小。</p>
<script type="math/tex; mode=display">
\begin{aligned}
w^{[l]} &:=w^{[l]}-\alpha \cdot \mathrm d w^{[l]} \\
&=w^{[l]}-\alpha \cdot\left(\mathrm d w_{\mathrm{befor} e}^{[l]}+\frac{\lambda}{m} w^{[l]}\right) \\
&=\left(1-\alpha \frac{\lambda}{m}\right) w^{[l]}-\alpha \cdot\mathrm d w_\mathrm{befor}^{[l]}
\end{aligned}</script><p>其中，<script type="math/tex">1-\alpha \frac{\lambda}{m}<1</script></p>
<h4 id="5-5-为什么正则化可以减少过拟合"><a href="#5-5-为什么正则化可以减少过拟合" class="headerlink" title="5.5 为什么正则化可以减少过拟合"></a>5.5 为什么正则化可以减少过拟合</h4><p>为什么正则化能够有效避免high variance，防止过拟合呢？下面通过几个例子说明。</p>
<p>还是之前那张图，从左到右，分别表示了欠拟合，刚好拟合，过拟合三种情况。</p>
<p><img src="https://pic.imgdb.cn/item/648acd901ddac507cc7b0e77.png"></p>
<p>假如我们选择了非常复杂的神经网络模型，如上图左上角所示。在未使用正则化的情况下，我们得到的分类超平面可能是类似上图右侧的过拟合。但是，如果使用L2 regularization，当<em>λ</em>很大时，<script type="math/tex">w^{[l]}≈0</script>意味着该神经网络模型中的某些神经元实际的作用很小，可以忽略。从效果上来看，其实是将某些神经元给忽略掉了。这样原本过于复杂的神经网络模型就变得不那么复杂了，而变得非常简单化了。如下图所示，整个简化的神经网络模型变成了一个逻辑回归模型。问题就从high  variance变成了high bias了。</p>
<p><img src="https://pic.imgdb.cn/item/648acda91ddac507cc7b514b.png" style="zoom:40%"></p>
<p>因此，选择合适大小的<script type="math/tex">\lambda</script>值，就能够同时避免high bias和high variance，得到最佳模型。</p>
<p>还有另外一个直观的例子来解释为什么正则化能够避免发生过拟合。假设激活函数是tanh函数。tanh函数的特点是在<script type="math/tex">z</script>接近零的区域，函数近似是线性的，而当<script type="math/tex">|z|</script>很大的时候，函数非线性且变化缓慢。当使用正则化，<script type="math/tex">\lambda</script>较大，即对权重<script type="math/tex">w^{[l]}</script>的<strong>惩罚较大</strong>，<script type="math/tex">w^{[l]}</script>减小。因为<script type="math/tex">z^{[l]}=w^{[l]}a^{[l]}+b^{[l]}</script>。当<script type="math/tex">w^{[l]}</script>减小的时候，<script type="math/tex">z^{[l]}</script>也会减小。则此时的<script type="math/tex">z^{[l]}</script>分布在tanh函数的近似线性区域。那么这个神经元起的作用就相当于是<strong>linear regression</strong>。如果每个神经元对应的权重<script type="math/tex">w^{[l]}</script>都比较小，那么整个神经网络模型相当于是多个linear regression的组合，即可看成一个linear network。得到的分类超平面就会比较简单，不会出现过拟合现象。</p>
<p><img src="https://pic.imgdb.cn/item/648acdfa1ddac507cc7c246d.png" style="zoom:60%"></p>
<h4 id="5-6-Dropout-正则化"><a href="#5-6-Dropout-正则化" class="headerlink" title="5.6 Dropout 正则化"></a>5.6 <strong>Dropout 正则化</strong></h4><p>除了L2 regularization之外，还有另外一种防止过拟合的有效方法：Dropout。</p>
<p>Dropout是指在深度学习网络的训练过程中，对于每层的神经元，按照一定的概率将其暂时从网络中丢弃。也就是说，每次训练时，每一层都有部分神经元不工作，起到简化复杂网络模型的效果，从而避免发生过拟合。</p>
<p><img src="https://pic.imgdb.cn/item/648ace5a1ddac507cc7d6ab8.png" style="zoom:60%"></p>
<p>Dropout有不同的实现方法，接下来介绍一种常用的方法：<strong>Inverted dropout</strong>。假设对于第<script type="math/tex">l</script>层神经元，设定保留神经元比例概率keep_prob=0.8，即该层有20%的神经元停止工作。<script type="math/tex">dl</script>为dropout向量，设置<script type="math/tex">dl</script>为随机vector，其中80%的元素为1，20%的元素为0。在python中可以使用如下语句生成dropout vector：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dl = np.random.rand(al.shape[<span class="number">0</span>],al.shape[<span class="number">1</span>])&lt;keep_prob</span><br></pre></td></tr></table></figure>
<p>然后，第<script type="math/tex">l</script>层经过dropout，随机删减20%的神经元，只保留80%的神经元，其输出为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">al = np.multiply(al,dl)</span><br></pre></td></tr></table></figure>
<p>最后，还要对<script type="math/tex">al</script>进行scale up处理，即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">al /= keep_prob</span><br></pre></td></tr></table></figure>
<p>以上就是Inverted dropout的方法。之所以要对<script type="math/tex">al</script>进行scale up是为了保证在经过dropout后，<script type="math/tex">al</script><strong>作为下一层神经元的输入值尽量保持不变</strong>。假设第<script type="math/tex">l</script>层有50个神经元，经过dropout后，有10个神经元停止工作，这样只有40神经元有作用。那么得到的<script type="math/tex">al</script>只相当于原来的80%。scale up后，能够尽可能保持<script type="math/tex">al</script>的期望值相比之前没有大的变化。</p>
<p>Inverted dropout的另外一个好处就是在对该dropout后的神经网络进行测试时能够减少scaling问题。因为在训练时，使用scale up保证<script type="math/tex">al</script>的期望值没有大的变化，测试时就不需要再对样本数据进行类似的尺度伸缩操作了。</p>
<p>对于<script type="math/tex">m</script>个样本，单次迭代训练时，随机删除掉隐藏层一定数量的神经元；然后，在删除后的剩下的神经元上正向和反向更新权重w和常数项b；接着，下一次迭代中，再恢复之前删除的神经元，重新随机删除一定数量的神经元，进行正向和反向更新w和b。不断重复上述过程，直至迭代训练完成。</p>
<p><strong>值得注意的是，使用dropout训练结束后，在测试和实际应用模型时，不需要进行dropout和随机删减神经元，所有的神经元都在工作。</strong></p>
<h4 id="5-7-理解Dropout"><a href="#5-7-理解Dropout" class="headerlink" title="5.7 理解Dropout"></a>5.7 理解Dropout</h4><p>Dropout通过每次迭代训练时，随机选择不同的神经元，相当于每次都在不同的神经网络上进行训练，类似机器学习中Bagging的方法(三个臭皮匠，赛过诸葛亮)，能够防止过拟合。</p>
<p>除此之外，还可以从权重<script type="math/tex">w</script>的角度来解释为什么dropout能够有效防止过拟合。对于某个神经元来说，某次训练时，它的某些输入在dropout的作用被过滤了。而在下一次训练时，又有不同的某些输入被过滤。经过多次训练后，某些输入被过滤，某些输入被保留。这样，该神经元就不会受某个输入非常大的影响，影响被均匀化了。也就是说，对应的权重<script type="math/tex">w</script>不会很大。这从从效果上来说，与L2 regularization是类似的，都是对权重<script type="math/tex">w</script>进行“惩罚”，减小了<script type="math/tex">w</script>的值。</p>
<p><img src="https://pic.imgdb.cn/item/648acec31ddac507cc7f27dd.png"></p>
<p>总结一下，对于同一组训练数据，利用不同的神经网络训练之后，求其输出的平均值可以减少overfitting。Dropout就是利用这个原理，每次丢掉一定数量的隐藏层神经元，<strong>相当于在不同的神经网络上进行训练</strong>，这样就<strong>减少了神经元之间的依赖性</strong>，即每个神经元不能依赖于某几个其他的神经元(指层与层之间相连接的神经元)，使神经网络更加能学习到与其他神经元之间的更加健壮robust的特征。</p>
<p>在使用dropout的时候，有几点需要注意。</p>
<p>(1) 不同隐藏层的dropout系数keep_prob可以不同。一般来说，神经元越多的隐藏层，keep_out可以设置得小一些，例如0.5；神经元越少的隐藏层，keep_out可以设置的大一些，例如0.8，设置是1。</p>
<p>(2) 实际应用中，不建议对输入层进行dropout，如果输入层维度很大，例如图片，那么可以设置dropout，但keep_out应设置的大一些，例如0.8，0.9。</p>
<p>总体来说，就是越容易出现overfitting的隐藏层，其keep_prob就设置的相对小一些。没有准确固定的做法，通常可以根据validation进行选择。</p>
<p>Dropout在电脑视觉CV领域应用比较广泛，因为输入层维度较大，而且没有足够多的样本数量。值得注意的是dropout是一种regularization技巧，用来防止过拟合的，最好只在需要regularization的时候使用dropout。</p>
<p>使用dropout的时候，可以通过绘制cost function来进行debug，看看dropout是否正确执行。一般做法是，将所有层的keep_prob全设置为1，再绘制cost function，即涵盖所有神经元，看<script type="math/tex">J</script>是否单调下降。下一次迭代训练时，再将keep_prob设置为其它值。</p>
<h4 id="5-8-其他正则化方法"><a href="#5-8-其他正则化方法" class="headerlink" title="5.8 其他正则化方法"></a>5.8 其他正则化方法</h4><p>除了L2 regularization和dropout regularization之外，还有其它减少过拟合的方法。</p>
<ul>
<li><strong>增加训练样本数量</strong><br>但是通常成本较高，难以获得额外的训练样本。但是，我们可以对已有的训练样本进行一些处理来“制造”出更多的样本，称为data augmentation。例如图片识别问题中，可以对已有的图片进行水平翻转、垂直翻转、任意角度旋转、缩放或扩大等等。如下图所示，这些处理都能“制造”出新的训练样本。虽然这些是基于原有样本的，但是对增大训练样本数量还是有很有帮助的，不需要增加额外成本，却能起到防止过拟合的效果。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/648acefc1ddac507cc800831.png"></p>
<p>在数字识别中，也可以将原有的数字图片进行任意旋转或者扭曲，或者增加一些noise，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648acf2b1ddac507cc80def8.png"></p>
<ul>
<li><p><strong>early stopping</strong></p>
<p>一个神经网络模型随着迭代训练次数增加，train set error一般是单调减小的，而dev set error 先减小，之后又增大。也就是说训练次数过多时，模型会对训练样本拟合的越来越好，但是对验证集拟合效果逐渐变差，即发生了过拟合。因此，迭代训练次数不是越多越好，可以通过train set error和dev set error随着迭代次数的变化趋势，选择合适的迭代次数，即early stopping。</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/648ad1d81ddac507cc8a8a35.png" style="zoom:60%"></p>
<p>然而，Early stopping有其自身缺点。通常来说，机器学习训练模型有两个目标：</p>
<p>一是优化cost function，尽量减小<script type="math/tex">J</script>；</p>
<p>二是防止过拟合。</p>
<p>这两个目标彼此对立的，即<strong>减小</strong><script type="math/tex">J</script><strong>的同时可能会造成过拟合</strong>，反之亦然。我们把这二者之间的关系称为正交化(orthogonalization)。该节课开始部分就讲过，在深度学习中，我们可以同时减小Bias和Variance，构建最佳神经网络模型。但是，Early stopping的做法通过减少得带训练次数来防止过拟合，这样<script type="math/tex">J</script>就不会足够小。也就是说，early stopping将上述两个目标融合在一起，同时优化，但可能没有“分而治之”的效果好。</p>
<p>与early stopping相比，<strong>L2 regularization可以实现“分而治之”的效果</strong>：迭代训练足够多，减小<script type="math/tex">J</script>，而且也能有效防止过拟合。而L2 regularization的缺点之一是最优的正则化参数<script type="math/tex">\lambda</script>的选择比较复杂。对这一点来说，early stopping比较简单。总的来说，L2 regularization更加常用一些。</p>
<h4 id="5-9-归一化输入"><a href="#5-9-归一化输入" class="headerlink" title="5.9 归一化输入"></a>5.9 归一化输入</h4><p>在训练神经网络时，标准化输入可以提高训练的速度。标准化输入就是对训练数据集进行归一化的操作，即将原始数据减去其均值<script type="math/tex">\mu</script>后，再除以其方差<script type="math/tex">σ^2</script>：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mu=\frac{1}{m} \sum_{i=1}^{m} X^{(i)} \\
\sigma^{2}=\frac{1}{m} \sum_{i=1}^{m}\left(X^{(i)}\right)^{2} \\
X:=\frac{X-\mu}{\sigma^{2}}
\end{gathered}</script><p>以二维平面为例，下图展示了其归一化过程：</p>
<p><img src="https://pic.imgdb.cn/item/648ad21a1ddac507cc8b622e.png"></p>
<p>值得注意的是，由于训练集进行了标准化处理，那么对于测试集或在实际应用时，应该使用同样的<script type="math/tex">\mu</script>和<script type="math/tex">σ^{2}</script>对其进行标准化处理。这样保证了训练集合测试集的标准化操作一致。</p>
<p>之所以要对输入进行标准化操作，主要是为了让所有<strong>输入归一化同样的尺度上</strong>，方便进行梯度下降算法时能够更快更准确地找到全局最优解。假如输入特征是二维的，且<script type="math/tex">x_1</script>的范围是<script type="math/tex">[1,1000]</script>，<script type="math/tex">x_2</script>的范围是<script type="math/tex">[0,1]</script>。如果不进行标准化处理，<script type="math/tex">x_1</script>与<script type="math/tex">x_2</script>之间分布极不平衡，训练得到的<script type="math/tex">w_1</script>和<script type="math/tex">w_2</script>也会在数量级上差别很大。这样导致的结果是cost  function与<script type="math/tex">w</script>和<script type="math/tex">b</script>的关系可能是一个非常细长的椭圆形碗。对其进行梯度下降算法时，由于<script type="math/tex">w_1</script>和<script type="math/tex">w_2</script>数值差异很大，只能选择很小的学习因子<script type="math/tex">\alpha</script>，来避免<script type="math/tex">J</script>发生振荡。一旦<script type="math/tex">\alpha</script>较大，必然发生振荡，<script type="math/tex">J</script>不再单调下降。如下左图所示。</p>
<p>然而，如果进行了标准化操作，<script type="math/tex">x_1</script>与<script type="math/tex">x_2</script>分布均匀，<script type="math/tex">w_1</script>和<script type="math/tex">w_2</script>数值差别不大，得到的cost function与<script type="math/tex">w</script>和<script type="math/tex">b</script>的关系是类似圆形碗。对其进行梯度下降算法时，<script type="math/tex">\alpha</script>可以选择相对大一些，且<script type="math/tex">J</script>一般不会发生振荡，保证了<script type="math/tex">J</script>是单调下降的。如下右图所示。</p>
<p><img src="https://pic.imgdb.cn/item/648ad2621ddac507cc8c5469.png"></p>
<p>另外一种情况，如果输入特征之间的范围本来就比较接近，那么不进行标准化操作也是没有太大影响的。但是，标准化处理在大多数场合下还是值得推荐的。</p>
<p>本小节参考链接：<a href="https://blog.csdn.net/u012768474/article/details/99871942">标准化和归一化的区别</a></p>
<h4 id="5-10-梯度消失与梯度爆炸"><a href="#5-10-梯度消失与梯度爆炸" class="headerlink" title="5.10 梯度消失与梯度爆炸"></a>5.10 梯度消失与梯度爆炸</h4><p>在神经网络尤其是深度神经网络中存在可能存在这样一个问题：梯度消失和梯度爆炸。意思是当训练一个层数非常多的神经网络时，计算得到的梯度可能非常小或非常大，甚至是指数级别的减小或增大。这样会让训练过程变得非常困难。</p>
<p>举个例子来说明，假设一个多层的每层只包含两个神经元的深度神经网络模型，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648ad2b81ddac507cc8d5d7a.png"></p>
<p>为了简化复杂度便于分析，我们令各层的激活函数为线性函数，即<script type="math/tex">g(Z)=Z</script>。且忽略各层常数项<script type="math/tex">b</script>的影响，令<script type="math/tex">b</script>全部为零。那么，该网络的预测输出<script type="math/tex">\hat Y</script>为：</p>
<script type="math/tex; mode=display">
\hat{Y}=W^{[L]} W^{[L-1]} W^{[L-2]} \ldots W^{[3]} W^{[2]} W^{[1]} X</script><p>如果各层权重<script type="math/tex">W^{[l]}</script>的元素都稍大于<script type="math/tex">1</script>，例如<script type="math/tex">1.5</script>，则预测输出<script type="math/tex">\hat Y</script>将正比于<script type="math/tex">1.5^L</script>。<script type="math/tex">L</script>越大，<script type="math/tex">\hat Y</script>越大，且呈指数型增长。我们称之为数值爆炸。相反，如果各层权重<script type="math/tex">W^{[l]}</script>的元素都稍小于<script type="math/tex">1</script>，例如<script type="math/tex">0.5</script>，则预测输出<script type="math/tex">\hat Y</script>将正比于<script type="math/tex">0.5^L</script>。网络层数<script type="math/tex">L</script>越多，<script type="math/tex">\hat Y</script>呈指数型减小。我们称之为数值消失。</p>
<p>也就是说，如果各层权重<script type="math/tex">W^{[l]}</script>都大于<script type="math/tex">1</script>或者都小于<script type="math/tex">1</script>，那么各层激活函数的输出将随着层数<script type="math/tex">l</script>的增加，呈指数型增大或减小。当层数很大时，出现数值爆炸或消失。同样，这种情况也会引起梯度呈现同样的指数型增大或减小的变化。<script type="math/tex">L</script>非常大时，例如<script type="math/tex">L=150</script>，则梯度会非常大或非常小，引起每次更新的步进长度过大或者过小，这让训练过程十分困难。</p>
<h4 id="5-11-神经网络的初始化权重"><a href="#5-11-神经网络的初始化权重" class="headerlink" title="5.11 神经网络的初始化权重"></a>5.11 神经网络的初始化权重</h4><p>下面介绍如何改善Vanishing and Exploding gradients这类问题，方法是对权重<script type="math/tex">w</script>进行一些初始化处理。</p>
<p>深度神经网络模型中，以单个神经元为例，该层(<script type="math/tex">l</script><em>)</em>的输入个数为<script type="math/tex">n</script>，其输出为：</p>
<script type="math/tex; mode=display">
\begin{gathered}z=w_{1} x_{1}+w_{2} x_{2}+\cdots+w_{n} x_{n} \\a=g(z)\end{gathered}</script><p><img src="https://pic.imgdb.cn/item/648ad35d1ddac507cc902cab.png" style="zoom:40%"></p>
<p>这里忽略了常数项<script type="math/tex">b</script>。为了让<script type="math/tex">z</script>不会过大或者过小，由上面的式子可以有思路是<strong>让</strong><script type="math/tex">w</script><strong>与</strong><script type="math/tex">n</script><strong>有关，且</strong><script type="math/tex">n</script><strong>越大，</strong><script type="math/tex">w</script><strong>应该越小才好</strong>。这样能够保证<script type="math/tex">z</script>不会过大。一种方法是在初始化时，控制<script type="math/tex">w</script>的方差。</p>
<p>(1) 如果激活函数是tanh，<strong>令</strong><script type="math/tex">w</script><strong>方差为</strong><script type="math/tex">1/n</script>;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w[l] = np.random.randn(n[l],n[l-<span class="number">1</span>])*np.sqrt(<span class="number">1</span>/n[l-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>(2) 如果激活函数是ReLU，<strong>令</strong><script type="math/tex">w</script><strong>方差为</strong><script type="math/tex">2/n</script>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w[l] = np.random.randn(n[l],n[l-<span class="number">1</span>])*np.sqrt(<span class="number">2</span>/n[l-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>除此之外，Yoshua Bengio提出了另外一种初始化w的方法，令其方差为<script type="math/tex">\frac{2}{n^{[l−1]}n^{[l]}}</script>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w[l] = np.random.randn(n[l],n[l-<span class="number">1</span>])*np.sqrt(<span class="number">2</span>/n[l-<span class="number">1</span>]*n[l])</span><br></pre></td></tr></table></figure>
<p>至于选择哪种初始化方法因人而异，可以根据不同的激活函数选择不同方法。另外，我们可以对这些初始化方法中设置某些参数，作为超参数，通过验证集进行验证，得到最优参数，来优化神经网络。</p>
<h4 id="5-12-梯度的数值逼近"><a href="#5-12-梯度的数值逼近" class="headerlink" title="5.12  梯度的数值逼近"></a>5.12  梯度的数值逼近</h4><p>Back Propagation神经网络有一项重要的测试是<strong>梯度检查(gradient checking)</strong>。其目的是检查验证反向传播过程中梯度下降算法是否正确。该小节将先介绍如何近似求出梯度值。</p>
<p><img src="https://pic.imgdb.cn/item/648ad5d11ddac507cc9a3d8a.png" style="zoom:70%"></p>
<p>利用微分思想，函数<script type="math/tex">f</script>在点<script type="math/tex">θ</script>处的梯度可以表示成：</p>
<script type="math/tex; mode=display">
\frac{\mathrm df}{\mathrm d\theta} = \lim_{\varepsilon \rightarrow 0}\frac{f(\theta+\varepsilon)-f(\theta-\varepsilon)}{2\varepsilon}</script><p>其中，<script type="math/tex">\varepsilon>0</script>且足够小。</p>
<h4 id="5-13-梯度检验"><a href="#5-13-梯度检验" class="headerlink" title="5.13 梯度检验"></a>5.13 梯度检验</h4><p>介绍完如何近似求出梯度值后，我们将介绍如何进行梯度检查，来验证训练过程中是否出现bugs。</p>
<p>梯度检查首先要做的是分别将<script type="math/tex">W^{[1]}, b^{[1]}, \ldots, W^{[L]}, b^{[L]}</script>这些矩阵构造成一维向量，然后将这些一维向量组合起来构成一个更大的一维向量<script type="math/tex">\theta</script>，这样cost function<script type="math/tex">J(W^{[1]}, b^{[1]}, \cdots, W^{[L]}, b^{[L]})</script>就可以表示成<script type="math/tex">J(\theta)</script>。</p>
<p>然后将反向传播过程通过梯度下降算法得到的<script type="math/tex">\mathrm d W^{[1]}, \mathrm d b^{[1]}, \cdots, \mathrm d W^{[L]}, \mathrm d b^{[L]}</script>按照一样的顺序构造成一个一维向量<script type="math/tex">\mathrm d\theta</script>(与<script type="math/tex">\theta</script>维度相同)。</p>
<p>接着利用<script type="math/tex">J(θ)</script>对每个<script type="math/tex">θ_i</script>计算近似梯度，其值与反向传播算法得到的<script type="math/tex">dθ_i</script>相比较，检查是否一致。例如，对于第<script type="math/tex">i</script>个元素，近似梯度为：</p>
<script type="math/tex; mode=display">
\mathrm d \theta_{\operatorname{approx}}[i]=\frac{J\left(\theta_{1}, \theta_{2}, \cdots, \theta_{i}+\varepsilon, \cdots\right)-J\left(\theta_{1}, \theta_{2}, \cdots, \theta_{i}-\varepsilon, \cdots\right)}{2 \varepsilon}</script><p>计算完所有<script type="math/tex">θ_i</script>的近似梯度后，可以计算<script type="math/tex">\mathrm dθ_{\text {approx}}</script>与<script type="math/tex">dθ</script>的<strong>欧氏(Euclidean)距离</strong>来比较二者的相似度。公式如下：</p>
<script type="math/tex; mode=display">
\frac{\left\| \mathrm d \theta_{\text {approx }}-\mathrm d \theta\right\|_{2}}{\left\|\mathrm d \theta_{\text {approx }}\right\|_{2}+\|\mathrm d \theta\|_{2}}</script><p>一般来说，若欧氏距离越小，例如<script type="math/tex">10^{−7}</script>甚至更小，则表明<script type="math/tex">\mathrm dθ_{\text {approx}}</script>与<script type="math/tex">dθ</script>越接近，即反向梯度计算是正确的，没有bugs。若欧氏距离较大，例如<script type="math/tex">10^{−5}</script>，则表明梯度计算可能出现问题，需要再次检查是否有bugs存在。若欧氏距离很大，例如<script type="math/tex">10^{−3}</script>，甚至更大，则表明<script type="math/tex">\mathrm dθ_{\text {approx}}</script>与<script type="math/tex">\mathrm dθ</script>差别很大，梯度下降计算过程有bugs，需要仔细检查。</p>
<h4 id="5-14-关于梯度检验实现的注记"><a href="#5-14-关于梯度检验实现的注记" class="headerlink" title="5.14 关于梯度检验实现的注记"></a>5.14 关于梯度检验实现的注记</h4><p>在进行梯度检查的过程中有几点需要注意的地方：</p>
<ul>
<li><strong>不要在整个训练过程中都进行梯度检查，仅仅作为debug使用。</strong></li>
<li><strong>如果梯度检查出现错误，找到对应出错的梯度，检查其推导是否出现错误。</strong></li>
<li><strong>注意不要忽略正则化项，计算近似梯度的时候要包括进去。</strong></li>
<li><strong>梯度检查时关闭dropout，检查完毕后再打开dropout。</strong></li>
<li><strong>随机初始化时运行梯度检查，经过一些训练后再进行梯度检查（不常用）。</strong></li>
</ul>
<h3 id="第六章-优化算法"><a href="#第六章-优化算法" class="headerlink" title="第六章 优化算法"></a>第六章 优化算法</h3><h4 id="6-1-Mini-batch-梯度下降法"><a href="#6-1-Mini-batch-梯度下降法" class="headerlink" title="6.1 Mini-batch 梯度下降法"></a><strong>6.1 Mini-batch 梯度下降法</strong></h4><p>之前介绍的神经网络训练过程是对所有<script type="math/tex">m</script>个样本，称为<strong>batch</strong>，通过向量化计算方式，同时进行的。如果<script type="math/tex">m</script>很大，例如达到百万数量级，训练速度往往会很慢，因为每次迭代都要对所有样本进行进行求和运算和矩阵运算。我们将这种梯度下降算法称为<strong>Batch  Gradient Descent</strong>。</p>
<p>为了解决这一问题，我们可以把<script type="math/tex">m</script>个训练样本分成若干个子集，称为<strong>mini-batches</strong>，这样每个子集包含的数据量就小了，例如只有1000，然后每次在单一子集上进行神经网络训练，速度就会大大提高。这种梯度下降算法叫做<strong>Mini-batch Gradient Descent</strong>。</p>
<p>假设总的训练样本个数<script type="math/tex">m=5000000</script>，其维度为<script type="math/tex">(n_x,m)</script>。将其分成<script type="math/tex">5000</script>个子集，每个mini-batch含有<script type="math/tex">1000</script>个样本。我们将每个mini-batch记为<script type="math/tex">X^{\{ t \}}</script>，其维度为<script type="math/tex">(n_x,1000)</script>。相应的每个mini-batch的输出记为<script type="math/tex">Y^{\{ t \}}</script>，其维度为<script type="math/tex">(1,1000)</script>，且<script type="math/tex">t=1,2,⋯,5000</script>。</p>
<p>这里顺便总结一下我们遇到的神经网络中几类字母的上标含义：</p>
<ul>
<li>$X^{(i)}$<strong>：第</strong>$i$<strong>个样本</strong></li>
<li>$Z^{[l]}$<strong>：神经网络第</strong>$l$<strong>层网络的线性输出</strong></li>
<li>$X^{\{t\}},Y^{\{t\}}$<strong>：第</strong>$t$<strong>组mini-batch</strong></li>
</ul>
<p>ini-batches Gradient Descent的实现过程是先将总的训练样本分成<script type="math/tex">T</script>个子集(mini-batches)，然后对每个mini-batch进行神经网络训练，包括Forward Propagation，Compute Cost Function，Backward Propagation，循环至<script type="math/tex">T</script>个mini-batch都训练完毕。</p>
<p><img src="https://pic.imgdb.cn/item/648adc111ddac507ccae58b0.png" style="zoom:70%"></p>
<p>经过<script type="math/tex">T</script>次循环之后，所有<script type="math/tex">m</script>个训练样本都进行了梯度下降计算。这个过程，我们称之为经历了一个<strong>epoch</strong>。对于Batch Gradient Descent而言，一个epoch只进行一次梯度下降算法；而Mini-Batches Gradient Descent，一个epoch会进行<script type="math/tex">T</script>次梯度下降算法。</p>
<p>值得一提的是，对于Mini-Batches Gradient Descent，可以进行多次epoch训练。而且，每次epoch，最好是将总体训练数据<strong>重新打乱</strong>、<strong>重新分成</strong><script type="math/tex">T</script><strong>组</strong>mini-batches，这样有利于训练出最佳的神经网络模型。</p>
<h4 id="6-2-理解Mini-batch-梯度下降法"><a href="#6-2-理解Mini-batch-梯度下降法" class="headerlink" title="6.2 理解Mini-batch 梯度下降法"></a>6.2 理解<strong>Mini-batch 梯度下降法</strong></h4><p>Batch gradient descent和Mini-batch gradient descent的cost曲线如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648add1e1ddac507ccb1c568.png"></p>
<p>对于一般的神经网络模型，使用Batch gradient descent，随着迭代次数增加，cost是不断减小的。然而，使用Mini-batch gradient descent，随着在不同的mini-batch上迭代训练，其cost不是单调下降，而是受类似noise的影响，出现振荡。但整体的趋势是下降的，最终也能得到较低的cost值。</p>
<p>之所以出现细微振荡的原因是不同的mini-batch之间是有差异的。例如可能第一个子集<script type="math/tex">(X^{\{1\}},Y^{\{1\}})</script>是好的子集，而第二个子集<script type="math/tex">(X^{\{2\}},Y^{\{2\}})</script>包含了一些噪声noise。出现细微振荡是正常的。</p>
<p>如何选择每个mini-batch的大小，即包含的样本个数呢？有两个极端：</p>
<p>(1) 如果mini-batch size=m，即为Batch gradient descent，只包含一个子集为<script type="math/tex">(X^{\{1\}},Y^{\{1\}}) = (X,Y)</script>；</p>
<p>(2) 如果mini-batch size=1，即为Stachastic gradient descent，每个样本就是一个子集<script type="math/tex">(X^{\{1\}},Y^{\{1\}}) = (x^{(i)},y^{(i)})</script>，共有<script type="math/tex">m</script>个子集。</p>
<p>我们来比较一下Batch gradient descent和Stachastic gradient  descent的梯度下降曲线。如下图所示，蓝线代表Batch gradient descent，紫线代表Stachastic  gradient descent。Batch gradient  descent会比较平稳地接近全局最小值，但是因为使用了所有<script type="math/tex">m</script>个样本，每次前进的速度有些慢。Stachastic gradient  descent每次前进速度很快，但是路线曲折，有较大的振荡，最终会在最小值附近来回波动，难以真正达到最小值处。而且在数值处理上就不能使用向量化的方法来提高运算速度。</p>
<p><img src="https://pic.imgdb.cn/item/648add4a1ddac507ccb24ba3.png" style="zoom:50%"></p>
<p>实际使用中，mini-batch size不能设置得太大(Batch gradient descent)，也不能设置得太小(Stachastic gradient descent)。这样，相当于结合了Batch gradient descent和Stachastic gradient descent各自的优点，既能使用向量化优化算法，又能叫快速地找到最小值。mini-batch gradient descent的梯度下降曲线如下图绿色所示，每次前进速度较快，且振荡较小，基本能接近全局最小值。</p>
<p><img src="https://pic.imgdb.cn/item/648add6c1ddac507ccb2b3fe.png" style="zoom:50%"></p>
<p>一般来说，如果总体样本数量<script type="math/tex">m</script>不太大时，例如<script type="math/tex">m≤2000</script>，建议直接使用Batch  gradient descent。如果总体样本数量<script type="math/tex">m</script>很大时，建议将样本分成许多mini-batches。推荐常用的mini-batch  size为<script type="math/tex">64</script>,<script type="math/tex">128</script>,<script type="math/tex">256</script>,<script type="math/tex">512</script>。这些都是<strong>2的幂</strong>。之所以这样设置的原因是计算机存储数据一般是2的幂，这样设置可以提高运算速度。</p>
<p>本小节参考链接：<a href="https://www.zhihu.com/question/501172146/answer/2247473794">关于Mini-batch梯度下降法的困惑，为什么会比批量梯度下降法快？</a></p>
<h4 id="6-3-指数加权平均"><a href="#6-3-指数加权平均" class="headerlink" title="6.3 指数加权平均"></a>6.3 指数加权平均</h4><p>举个例子，记录半年内伦敦市的气温变化，并在二维平面上绘制出来，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648addbb1ddac507ccb3a2ad.png"></p>
<p>看上去，温度数据似乎有noise，而且抖动较大。如果我们希望看到半年内气温的整体变化趋势，可以通过移动平均（moving average）的方法来对每天气温进行平滑处理。</p>
<p>例如我们可以设<script type="math/tex">V_0=0</script>，当成第<script type="math/tex">0</script>天的气温值。</p>
<p>第一天的气温与第<script type="math/tex">0</script>天的气温有关：</p>
<script type="math/tex; mode=display">
V_{1}=0.9 V_{0}+0.1 \theta_{1}</script><p>第二天的气温与第一天的气温有关：</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{2} &=0.9 V_{1}+0.1 \theta_{2} \\
&=0.9\left(0.9 V_{0}+0.1 \theta_{1}\right)+0.1 \theta_{2} \\
&=0.9^{2} V_{0}+0.9 \cdot 0.1 \theta_{1}+0.1 \theta_{2}
\end{aligned}</script><p>即第<script type="math/tex">t</script>天与第<script type="math/tex">t-1</script>天的气温迭代关系为：</p>
<script type="math/tex; mode=display">
\begin{aligned}V_{t} &=0.9 V_{t-1}+0.1 \theta_{t} \\&=0.9^{t} V_{0}+0.9^{t-1} \cdot 0.1 \theta_{1}+0.9^{t-2} \cdot 0.1 \theta_{2}+\cdots+0.9 \cdot 0.1 \theta_{t-1}+0.1 \theta_{t}\end{aligned}</script><p>经过移动平均处理得到的气温如下图红色曲线所示：</p>
<p><img src="https://pic.imgdb.cn/item/648adf601ddac507ccb8d5ff.png"></p>
<p>这种<strong>滑动平均算法</strong>称为<strong>指数加权平均(exponentially weighted average)</strong>。根据之前的推导公式，其一般形式为：</p>
<script type="math/tex; mode=display">
V_t = (1-\beta)V_{t-1}+\beta \theta_t</script><p>上面的例子中<script type="math/tex">β=0.9</script>。<script type="math/tex">\beta</script><strong>值决定了指数加权平均的天数</strong>，近似表示为：</p>
<script type="math/tex; mode=display">
\frac{1}{1-\beta}</script><p>例如，<script type="math/tex">β=0.9</script>，则<script type="math/tex">1/(1−β)=10</script>，表示将前<script type="math/tex">10</script>天进行指数加权平均。<script type="math/tex">β=0.98</script>，则<script type="math/tex">1/(1−β)=50</script>，表示将前<script type="math/tex">50</script>天进行指数加权平均。<script type="math/tex">\beta</script><strong>越大</strong>，则指数加权平均的天数<strong>越多</strong>，平均后的趋势线就<strong>越平缓</strong>，但是同时也会向右平移。下图绿色曲线和黄色曲线分别表示了<script type="math/tex">β=0.98</script>和<script type="math/tex">β=0.5</script>时，指数加权平均的结果。</p>
<p><img src="https://pic.imgdb.cn/item/648ae02f1ddac507ccbb94b6.png"></p>
<p>这里简单解释一下公式<script type="math/tex">1/{(1−β)}</script>是怎么来的。准确来说，指数加权平均算法跟之前所有天的数值都有关系，根据之前的推导公式就能看出。但是指数是衰减的，<strong>一般认为衰减到</strong><script type="math/tex">1/e</script><strong>就可以忽略不计了</strong>。因此，根据之前的推导公式，我们只要证明</p>
<script type="math/tex; mode=display">
\beta^{\frac{1}{1-\beta}} = \frac1e</script><p>令<script type="math/tex">\dfrac{1}{1-\beta}=N, N>0</script>，则<script type="math/tex">\beta=1-\dfrac{1}{N}, \dfrac{1}{N}<1</script>。即证明转化为：</p>
<script type="math/tex; mode=display">
\left(1-\frac{1}{N}\right)^{N}=\frac{1}{e}</script><p>显然，当<script type="math/tex">N>>0</script>时，上述等式是近似成立的。至此，简单解释了为什么指数加权平均的天数的计算公式为<script type="math/tex">1/{(1−β)}</script>。</p>
<h4 id="6-4-理解指数加权平均"><a href="#6-4-理解指数加权平均" class="headerlink" title="6.4 理解指数加权平均"></a>6.4 理解指数加权平均</h4><p>我们将指数加权平均公式的一般形式写下来：</p>
<script type="math/tex; mode=display">
\begin{aligned}V_{t}=& \beta V_{t-1}+(1-\beta) \theta_{t} \\=&(1-\beta) \theta_{t}+(1-\beta) \cdot \beta \cdot \theta_{t-1}+(1-\beta) \cdot \beta^{2} \cdot \theta_{t-2}+\cdots \\&+(1-\beta) \cdot \beta^{t-1} \cdot \theta_{1}+\beta^{t} \cdot V_{0}\end{aligned}</script><p>上式中<script type="math/tex">\theta_{t}, \theta_{t-1}, \theta_{t-2}, \cdots, \theta_{1}</script>是原始数据值，<script type="math/tex">(1-\beta),(1-\beta) \beta,(1-\beta) \beta^{2}, \cdots,(1-\beta) \beta^{t-1}</script>是类似指数曲线，从右向左，呈指数下降的。<script type="math/tex">V_t</script>的值就是这两个子式的点乘，将原始数据值与衰减指数点乘，相当于做了指数衰减，离得越近，影响越大，离得越远，影响越小，衰减越厉害。</p>
<p><img src="https://pic.imgdb.cn/item/648ae0fd1ddac507ccbe7f06.png" style="zoom:50%"></p>
<p>我们已经知道了指数加权平均的递推公式。实际应用中为了<strong>减少内存</strong>的使用，我们可以使用这样的语句来实现指数加权平均算法：</p>
<p><img src="https://pic.imgdb.cn/item/648ae16e1ddac507ccc01a03.png" style="zoom:70%"></p>
<p>本小节的参考链接：<a href="https://www.jianshu.com/p/41218cb5e099">为什么在优化算法中使用指数加权平均</a></p>
<h4 id="6-5-指数加权平均的偏差修正"><a href="#6-5-指数加权平均的偏差修正" class="headerlink" title="6.5 指数加权平均的偏差修正"></a>6.5 指数加权平均的偏差修正</h4><p>上文中提到当<script type="math/tex">β=0.98</script>时，指数加权平均结果如下图绿色曲线所示。但是实际上，真实曲线如紫色曲线所示。</p>
<p><img src="https://pic.imgdb.cn/item/648ae1b81ddac507ccc14d37.png"></p>
<p>我们注意到，紫色曲线与绿色曲线的区别是，紫色曲线开始的时候相对较低一些。这是因为开始时我们设置<script type="math/tex">V_0=0</script>，所以初始值会相对小一些，直到后面受前面的影响渐渐变小，趋于正常。</p>
<p>修正这种问题的方法是进行<strong>偏移校正(bias correction)</strong>，即在每次计算完<script type="math/tex">V_t</script>后，对<script type="math/tex">V_t</script>进行下式处理：</p>
<script type="math/tex; mode=display">
\frac{V_t}{1-\beta^t}</script><p>在刚开始的时候，<script type="math/tex">t</script>比较小，<script type="math/tex">(1−β^t)<1</script>，这样就将<script type="math/tex">V_t</script>修正得更大一些，效果是把紫色曲线开始部分向上提升一些，与绿色曲线接近重合。随着<script type="math/tex">t</script>增大，<script type="math/tex">(1−β^t)≈1</script>，<script type="math/tex">V_t</script>基本不变，紫色曲线与绿色曲线依然重合。这样就实现了简单的偏移校正，得到我们希望的绿色曲线。</p>
<p>注意机器学习中，偏移校正并不是必须的。因为，在迭代一次次数后(<script type="math/tex">t</script>较大)，<script type="math/tex">V_t</script>受初始值影响微乎其微，紫色曲线与绿色曲线基本重合。所以，一般可以忽略初始迭代过程，等到一定迭代之后再取值，这样就不需要进行偏移校正了。</p>
<h4 id="6-6-动量-momentum-梯度下降法"><a href="#6-6-动量-momentum-梯度下降法" class="headerlink" title="6.6 动量(momentum)梯度下降法"></a>6.6 动量(<strong>momentum</strong>)梯度下降法</h4><p>动量梯度下降与梯度下降相比，就是对梯度使用<a href="https://www.zhihu.com/search?q=%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A30743067%7D">指数加权平均</a>，其他的都保存一致</p>
<p>该部分将介绍动量梯度下降算法，其速度要比传统的梯度下降算法快很多。做法是在每次训练时，对梯度进行指数加权平均处理，然后用得到的梯度值更新权重<script type="math/tex">W</script>和常数项<script type="math/tex">b</script>。下面介绍具体的实现过程。</p>
<p><img src="https://pic.imgdb.cn/item/648ae1d51ddac507ccc1d475.png"></p>
<p>原始的梯度下降算法如上图蓝色折线所示。在梯度下降过程中，梯度下降的振荡较大，尤其对于<script type="math/tex">W、b</script>之间数值范围差别较大的情况。此时每一点处的梯度只与当前方向有关，产生类似折线的效果，前进缓慢。而如果<strong>对梯度进行指数加权平均</strong>，这样使当前梯度不仅与当前方向有关，还与之前的方向有关，这样处理让梯度前进方向更加平滑，减少振荡，能够更快地到达最小值处。</p>
<p>权重<script type="math/tex">W</script>和常数项<script type="math/tex">b</script>的指数加权平均表达式如下：</p>
<script type="math/tex; mode=display">
\begin{gathered}
V_{\mathrm d W}=\beta \cdot V_{\mathrm d W}+(1-\beta) \cdot \mathrm d W \\
V_{\mathrm d b}=\beta \cdot V_{\mathrm d b}+(1-\beta) \cdot \mathrm d b
\end{gathered}</script><p>从动量的角度来看，以权重<script type="math/tex">W</script>为例，<script type="math/tex">V_{\mathrm dW}</script>可以成速度V，<script type="math/tex">\mathrm dW</script>可以看成是加速度<script type="math/tex">a</script>。指数加权平均实际上是计算当前的速度，当前速度由之前的速度和现在的加速度共同影响。而<script type="math/tex">β<1</script>，又能限制速度<script type="math/tex">V_{\mathrm dW}</script>过大。也就是说，当前的速度是渐变的，而不是瞬变的，是动量的过程。这保证了梯度下降的平稳性和准确性，减少振荡，较快地达到最小值处。</p>
<p>动量梯度下降算法的过程如下：</p>
<p><img src="https://pic.imgdb.cn/item/648ae2051ddac507ccc2b4f9.png" style="zoom:70%"></p>
<p>初始时，令<script type="math/tex">V_{\mathrm dW}=0,V_{\mathrm db}=0</script>。一般设置<script type="math/tex">β=0.9</script>，即指数加权平均前10天的数据，实际应用效果较好。</p>
<p>另外，关于偏移校正，可以不使用。因为经过10次迭代后，随着滑动平均的过程，偏移情况会逐渐消失。</p>
<p>补充一下，在其它文献资料中，动量梯度下降还有另外一种写法：</p>
<script type="math/tex; mode=display">
\begin{gathered}
V_{\mathrm d W}=\beta V_{\mathrm d W}+d W \\
V_{\mathrm d b}=\beta V_{\mathrm d b}+\mathrm d b
\end{gathered}</script><p>即消去了<script type="math/tex">dW</script>和<script type="math/tex">db</script>前的系数<script type="math/tex">(1−β)</script>。这样简化了表达式，但是学习因子<script type="math/tex">\alpha</script>相当于变成了<script type="math/tex">\dfrac{α}{1−β}</script>，表示<script type="math/tex">\alpha</script>也受<script type="math/tex">\beta</script>的影响。从效果上来说，这种写法也是可以的，但是不够直观，且调参涉及到<script type="math/tex">\alpha</script>，不够方便。所以，实际应用中，推荐第一种动量梯度下降的表达式。</p>
<h4 id="6-7-root-mean-square-prop-RMSprop"><a href="#6-7-root-mean-square-prop-RMSprop" class="headerlink" title="6.7 root mean square prop(RMSprop)"></a>6.7 <strong>root mean square prop(</strong>RMSprop<strong>)</strong></h4><p>RMSprop是另外一种优化梯度下降速度的算法。每次迭代训练过程中，其权重W和常数项b的更新表达式为：</p>
<script type="math/tex; mode=display">
\begin{gathered}S_{W}=
\beta S_{\mathrm d W}+(1-\beta) d W^{2} \\S_{b}=\beta S_{\mathrm d b}+(1-\beta) \mathrm d b^{2} \\
W:=W-\alpha \frac{\mathrm d W}{\sqrt{S_{W}}}, b:=b-\alpha \frac{\mathrm d b}{\sqrt{S_{b}}}
\end{gathered}</script><p>下面简单解释一下RMSprop算法的原理，仍然以下图为例，为了便于分析，令水平方向为<script type="math/tex">W</script>的方向，垂直方向为<script type="math/tex">b</script>的方向。</p>
<p><img src="https://pic.imgdb.cn/item/648ae2e81ddac507ccc614ab.png"></p>
<p>从图中可以看出，梯度下降(蓝色折线)在垂直方向(<script type="math/tex">b</script>)上振荡较大，在水平方向(<script type="math/tex">W</script>)上振荡较小，表示在<script type="math/tex">b</script>方向上梯度较大，即<script type="math/tex">db</script>较大，而在<script type="math/tex">W</script>方向上梯度较小，即<script type="math/tex">dW</script>较小。因此，上述表达式中<script type="math/tex">S_b</script>较大，而<script type="math/tex">S_W</script>较小。在更新<script type="math/tex">W</script>和<script type="math/tex">b</script>的表达式中，变化值<script type="math/tex">\dfrac{\mathrm dW}{\sqrt{S_W}}</script>较大，而<script type="math/tex">\dfrac{\mathrm db}{\sqrt{S_b}}</script>较小。也就使得<script type="math/tex">W</script>变化得多一些，<script type="math/tex">b</script>变化得少一些。即加快了<script type="math/tex">W</script>方向的速度，减小了<script type="math/tex">b</script>方向的速度，减小振荡，实现快速梯度下降算法，其梯度下降过程如绿色折线所示。总得来说，就是如果哪个方向振荡大，就减小该方向的更新速度，从而减小振荡。</p>
<p>还有一点需要注意的是为了避免RMSprop算法中<strong>分母为零</strong>，通常可以在分母增加一个极小的常数<script type="math/tex">\varepsilon</script>：</p>
<script type="math/tex; mode=display">
W:=W-\alpha \frac{d W}{\sqrt{S_{W}}+\varepsilon}, b:=b-\alpha \frac{d b}{\sqrt{S_{b}}+\varepsilon}</script><p>其中，<script type="math/tex">ε=10^{−8}</script>，或者其它较小值。</p>
<h4 id="6-8-Adam优化算法"><a href="#6-8-Adam优化算法" class="headerlink" title="6.8 Adam优化算法"></a>6.8 Adam优化算法</h4><p>Adam(Adaptive Moment Estimation)算法<strong>结合</strong>了动量梯度下降算法和RMSprop算法。其算法流程为：</p>
<p><img src="https://pic.imgdb.cn/item/648ae7221ddac507ccd65acc.png" style="zoom:70%"></p>
<p>Adam算法包含了几个超参数，分别是：<script type="math/tex">α,β_1,β_2,ε</script>。</p>
<ul>
<li><script type="math/tex">β_1</script>通常设置为<script type="math/tex">0.9</script>；</li>
<li><script type="math/tex">β_2</script>通常设置为<script type="math/tex">0.999</script>；</li>
<li><script type="math/tex">\varepsilon</script>通常设置为<script type="math/tex">10^{−8}</script>。<br>一般只需要对<script type="math/tex">β_1</script>和<script type="math/tex">β_2</script>进行调试。</li>
</ul>
<p>实际应用中，Adam算法结合了动量梯度下降和RMSprop各自的优点，使得神经网络训练速度大大提高。</p>
<h4 id="6-9-学习率衰减"><a href="#6-9-学习率衰减" class="headerlink" title="6.9 学习率衰减"></a>6.9 学习率衰减</h4><p>减小学习因子<script type="math/tex">\alpha</script>也能有效提高神经网络训练速度，这种方法被称为learning rate decay。</p>
<p>Learning rate decay就是随着迭代次数增加，学习因子<script type="math/tex">\alpha</script><strong>逐渐减小</strong>。下面用图示的方式来解释这样做的好处。下图中，蓝色折线表示使用恒定的学习因子<script type="math/tex">\alpha</script>，由于每次训练<script type="math/tex">\alpha</script>相同，步进长度不变，在接近最优值处的振荡也大，在最优值附近较大范围内振荡，与最优值距离就比较远。绿色折线表示使用不断减小的<script type="math/tex">\alpha</script>，随着训练次数增加，<script type="math/tex">\alpha</script>逐渐减小，步进长度减小，使得能够在最优值处较小范围内微弱振荡，不断逼近最优值。相比较恒定的<script type="math/tex">\alpha</script>来说，learning rate decay更接近最优值。</p>
<p><img src="https://pic.imgdb.cn/item/648ae8241ddac507ccdab00c.png"></p>
<p>Learning rate decay中对<script type="math/tex">\alpha</script>可由下列公式得到：</p>
<script type="math/tex; mode=display">
\begin{equation}
\alpha=\frac{1}{1+\text { decay\_rate } * \text { epoch }} \alpha_{0}
\end{equation}</script><p>其中，<script type="math/tex">\text{deacy\_rate}</script>是参数(可调)，<strong>epoch是训练完所有样本的次数</strong>。随着epoch增加，<script type="math/tex">\alpha</script>会不断变小。除了上面计算<script type="math/tex">\alpha</script>的公式之外，还有其它可供选择的计算公式：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\alpha=0.95^{\text {epoch }} \cdot \alpha_{0} \\
\alpha=\frac{k}{\sqrt{\text { epoch }}} \cdot \alpha_{0} \quad \text { or } \quad \frac{k}{\sqrt{t}} \cdot \alpha_{0}
\end{gathered}</script><p>其中，<script type="math/tex">k</script>为可调参数，<script type="math/tex">t</script>为mini-bach number。除此之外，还可以设置<script type="math/tex">\alpha</script>为关于<script type="math/tex">t</script>的离散值，随着<script type="math/tex">t</script>增加，<script type="math/tex">\alpha</script>呈阶梯式减小。当然，也可以根据训练情况灵活调整当前的<script type="math/tex">\alpha</script>值，但会比较耗时间。</p>
<h4 id="6-10局部最优问题"><a href="#6-10局部最优问题" class="headerlink" title="6.10局部最优问题"></a>6.10局部最优问题</h4><p>在使用梯度下降算法不断减小cost function时，可能会得到局部最优解(local optima)而不是全局最优解(global optima)。之前我们对局部最优解的理解是形如碗状的凹槽，如下图左边所示。但是在神经网络中，local optima的概念发生了变化。准确地来说，大部分梯度为零的“最优点”并不是这些凹槽处，而是形如右边所示的马鞍状，称为<strong>saddle point</strong>。也就是说，梯度为零并不能保证都是convex(极小值)，也有可能是concave(极大值)。特别是在神经网络中参数很多的情况下，所有参数梯度为零的点很可能都是右边所示的马鞍状的saddle point，而不是左边那样的local optimum。</p>
<p><img src="https://pic.imgdb.cn/item/648ae86d1ddac507ccdbc60a.png"></p>
<p>类似马鞍状的plateaus会<strong>降低</strong>神经网络学习速度。Plateaus是梯度接近于零的平缓区域，如下图所示。在plateaus上梯度很小，前进缓慢，到达saddle point需要很长时间。到达saddle point后，由于随机扰动，梯度一般能够沿着图中绿色箭头，离开saddle point，继续前进，只是在plateaus上花费了太多时间。</p>
<p><img src="https://pic.imgdb.cn/item/648ae8921ddac507ccdc670a.png"></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习_吴恩达_Part_3</title>
    <url>/2023/06/15/Foundation-of-DeepLearning-3/</url>
    <content><![CDATA[<h3 id="第七章-超参数调试、Batch正则化和编程框架"><a href="#第七章-超参数调试、Batch正则化和编程框架" class="headerlink" title="第七章 超参数调试、Batch正则化和编程框架"></a>第七章 超参数调试、Batch正则化和编程框架</h3><h4 id="7-1-超参数调试处理"><a href="#7-1-超参数调试处理" class="headerlink" title="7.1 超参数调试处理"></a>7.1 超参数调试处理</h4><p>深度神经网络需要调试的超参数（Hyperparameters）较多，包括：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>参数</strong></th>
<th style="text-align:left"><strong>意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><script type="math/tex">\alpha</script></td>
<td style="text-align:left">学习因子/速率</td>
</tr>
<tr>
<td style="text-align:left"><script type="math/tex">\beta</script></td>
<td style="text-align:left">动量梯度下降因子</td>
</tr>
<tr>
<td style="text-align:left"><script type="math/tex">\beta_1, \beta_2, \varepsilon</script></td>
<td style="text-align:left">Adam算法参数</td>
</tr>
<tr>
<td style="text-align:left">#layers</td>
<td style="text-align:left">神经网络层数</td>
</tr>
<tr>
<td style="text-align:left">#hidden units</td>
<td style="text-align:left">各层隐藏神经元个数</td>
</tr>
<tr>
<td style="text-align:left">learning rate decay</td>
<td style="text-align:left">学习因子下降参数</td>
</tr>
<tr>
<td style="text-align:left">mini-batch size</td>
<td style="text-align:left">批量训练样本数的包含样本个数</td>
</tr>
<tr>
<td style="text-align:left">。。。</td>
<td style="text-align:left">。。。</td>
</tr>
</tbody>
</table>
</div>
<p>超参数之间也有重要性差异。通常来说，学习因子<script type="math/tex">α</script>是最重要的超参数，也是需要重点调试的超参数。动量梯度下降因子<script type="math/tex">β</script>、各隐藏层神经元个数#hidden units和mini-batch size的重要性仅次于<script type="math/tex">α</script>。然后就是神经网络层数#layers和学习因子下降参数learning rate decay。最后，Adam算法的三个参数<script type="math/tex">β_1, β_2, ε</script>一般常设置为<script type="math/tex">0.9，0.999</script>和<script type="math/tex">10^{−8}</script>，不需要反复调试。当然，这里超参数重要性的排名并不是绝对的，具体情况，具体分析。</p>
<p>如何选择和调试超参数？传统的机器学习中，我们对每个参数等距离选取任意个数的点，然后，分别使用不同点对应的参数组合进行训练，最后根据验证集上的表现好坏，来选定最佳的参数。例如有两个待调试的参数，分别在每个参数上选取5个点，这样构成了5x5=25中参数组合，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648ae96e1ddac507ccdfd1c7.png" style="zoom:50%"></p>
<p>这种做法在参数比较少的时候效果较好。但是在深度神经网络模型中，我们一般不采用这种均匀间隔取点的方法，比较好的做法是使用<strong>随机选择</strong>。也就是说，对于上面这个例子，我们随机选择25个点，作为待调试的超参数，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648aea321ddac507cce264c1.png" style="zoom:50%"></p>
<p>随机化选择参数的目的是为了尽可能地得到更多种参数组合。还是上面的例子，如果使用均匀采样的话，每个参数只有5种情况；而使用随机采样的话，每个参数有25种可能的情况，因此更有可能得到最佳的参数组合。</p>
<p>这种做法的另一个好处就是对重要性不同的参数之间的选择效果更好。设hyperparameter1为<script type="math/tex">\alpha</script>，hyperparameter2为<script type="math/tex">\varepsilon</script>，显然二者的重要性是不一样的。如果使用第一种均匀采样的方法，<script type="math/tex">\varepsilon</script>的影响很小，相当于只选择了<script type="math/tex">5</script>个<script type="math/tex">\alpha</script>值。而如果使用第二种随机采样的方法，<script type="math/tex">\varepsilon</script>和<script type="math/tex">\alpha</script>都有可能选择<script type="math/tex">25</script>种不同值。这大大增加了<script type="math/tex">\alpha</script>调试的个数，更有可能选择到最优值。其实，在实际应用中完全不知道哪个参数更加重要的情况下，随机采样的方式能有效解决这一问题，但是均匀采样做不到这点。</p>
<p>在经过随机采样之后，我们可能得到某些区域模型的表现较好。为了得到更精确的最佳参数，我们应该继续对选定的区域进行<strong>由粗到细</strong>的采样(coarse to fine sampling scheme)。也就是放大表现较好的区域，再对此区域做更密集的随机采样。例如，对下图中右下角的方形区域再做25点的随机采样，以获得最佳参数。</p>
<p><img src="https://pic.imgdb.cn/item/648aea541ddac507cce2d585.png" style="zoom:50%"></p>
<h4 id="7-2-为超参数选择合适的范围"><a href="#7-2-为超参数选择合适的范围" class="headerlink" title="7.2 为超参数选择合适的范围"></a>7.2 为超参数选择合适的范围</h4><p>上一部分讲的调试参数使用随机采样，对于某些超参数是可以进行尺度均匀采样的，但是某些超参数需要选择不同的合适尺度进行随机采样。</p>
<p>例如对于超参数#layers和#hidden units，都是正整数，是可以进行均匀随机采样的，即<strong>超参数每次变化的尺度都是一致的</strong>(如每次变化为1，犹如一个刻度尺一样，刻度是均匀的)。</p>
<p>但是，对于某些超参数，可能需要<strong>非均匀随机采样(即非均匀刻度尺)</strong>。例如超参数<script type="math/tex">\alpha</script>，待调范围是<script type="math/tex">[0.0001, 1]</script>。如果使用均匀随机采样，那么有<script type="math/tex">90\%</script>的采样点分布在<script type="math/tex">[0.1, 1]</script>之间，只有<script type="math/tex">10\%</script>分布在<script type="math/tex">[0.0001, 0.1]</script>之间。这在实际应用中是不太好的，因为最佳的<script type="math/tex">\alpha</script>值可能主要分布在<script type="math/tex">[0.0001, 0.1]</script>之间，而<script type="math/tex">[0.1, 1]</script>范围内<script type="math/tex">\alpha</script>值效果并不好。因此我们更关注的是区间<script type="math/tex">[0.0001, 0.1]</script>，应该在这个区间内细分更多刻度。</p>
<p>通常的做法是将<strong>linear scale转换为log scale</strong>，将均匀尺度转化为非均匀尺度，然后再在log scale下进行均匀采样。这样<script type="math/tex">[0.0001, 0.001]</script>，<script type="math/tex">[0.001, 0.01]</script>，<script type="math/tex">[0.01, 0.1]</script>，<script type="math/tex">[0.1, 1]</script>各个区间内随机采样的超参数个数基本一致，也就扩大了之前<script type="math/tex">[0.0001, 0.1]</script>区间内采样值个数。</p>
<p><img src="https://pic.imgdb.cn/item/648aea921ddac507cce3abf1.png"></p>
<p>一般解法是，如果线性区间为<script type="math/tex">[a, b]</script>，令<script type="math/tex">m=\log(a)，n=\log(b)</script>，则对应的<script type="math/tex">\log</script>区间为<script type="math/tex">[m,n]</script>。对<script type="math/tex">\log</script>区间的<script type="math/tex">[m,n]</script>进行随机均匀采样，然后得到的采样值<script type="math/tex">r</script>，最后反推到线性区间，即<script type="math/tex">10^r</script>就是最终采样的超参数。相应的Python语句为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = np.log10(a)</span><br><span class="line">n = np.log10(b)</span><br><span class="line">r = np.random.rand()</span><br><span class="line">r = m + (n-m)*r</span><br><span class="line">r = np.power(<span class="number">10</span>,r)</span><br></pre></td></tr></table></figure>
<p>除了<script type="math/tex">\alpha</script>外，动量梯度因子<script type="math/tex">\beta</script>也是一样，在超参数调试的时候需要进行非均匀采样。一般<script type="math/tex">\beta</script>的取值范围<script type="math/tex">[0.9, 0.999]</script>，<script type="math/tex">1−β</script>的取值范围就在<script type="math/tex">[0.001, 0.1]</script>。那么直接对<script type="math/tex">1−β</script>在<script type="math/tex">[0.001, 0.1]</script>区间内进行<script type="math/tex">\log</script>变换即可。</p>
<blockquote>
<p>这里解释下为什么<script type="math/tex">\beta</script>也需要向<script type="math/tex">\alpha</script>那样做非均匀采样。假设<script type="math/tex">\beta</script>从<script type="math/tex">0.9000</script>变化为<script type="math/tex">0.9005</script>，那么<script type="math/tex">\dfrac 1{1−β}</script>基本没有变化。但假设<script type="math/tex">\beta</script>从<script type="math/tex">0.9990</script>变化为<script type="math/tex">0.9995</script>，那么<script type="math/tex">\dfrac 1{1−β}</script>前后差别<script type="math/tex">1000</script>。<script type="math/tex">\beta</script>越接近<script type="math/tex">1</script>，指数加权平均的个数越多，变化越大。所以对<script type="math/tex">\beta</script>接近<script type="math/tex">1</script>的区间，应该采集得更密集一些。</p>
</blockquote>
<h4 id="7-3-超参数训练的实践：Pandas-vs-Caviar"><a href="#7-3-超参数训练的实践：Pandas-vs-Caviar" class="headerlink" title="7.3 超参数训练的实践：Pandas vs. Caviar"></a>7.3 超参数训练的实践：<strong>Pandas vs. Caviar</strong></h4><p>经过调试选择完最佳的超参数并不是一成不变的，一段时间之后（例如一个月），需要根据新的数据和实际情况，再次调试超参数，以获得实时的最佳模型。</p>
<p>在训练深度神经网络时，一种情况是受计算能力所限，我们只能对一个模型进行训练，调试不同的超参数，使得这个模型有最佳的表现。我们称之为Babysitting one model。另外一种情况是可以对多个模型同时进行训练，每个模型上调试不同的超参数，根据表现情况，选择最佳的模型。我们称之为Training many models in parallel。</p>
<p><img src="https://pic.imgdb.cn/item/648aeab31ddac507cce41e0f.png" style="zoom:50%"></p>
<p>因为第一种情况只使用一个模型，所以类比做Panda approach；第二种情况同时训练多个模型，类比做Caviar  approach。使用哪种模型是由计算资源、计算能力所决定的。一般来说，对于非常复杂或者数据量很大的模型，使用Panda  approach更多一些。</p>
<h4 id="7-4-正则化网络的激活函数"><a href="#7-4-正则化网络的激活函数" class="headerlink" title="7.4 正则化网络的激活函数"></a>7.4 正则化网络的激活函数</h4><p>Sergey Ioffe和Christian Szegedy两位学者提出了Batch Normalization方法。Batch Normalization不仅可以让调试超参数更加简单，而且可以让神经网络模型更加“健壮”。也就是说较好模型可接受的超参数范围更大一些，包容性更强，使得更容易去训练一个深度神经网络。接下来，我们就来介绍什么是Batch Normalization，以及它是如何工作的。</p>
<p>之前，我们在<strong>第五章</strong>中提到过在训练神经网络时，<strong>标准化输入可以提高训练的速度</strong>。方法是对训练数据集进行<strong>归一化</strong>的操作，即将原始数据减去其均值<script type="math/tex">\mu</script>后，再除以其方差<script type="math/tex">σ^2</script>。但是标准化输入只是对输入进行了处理，那么对于神经网络，又该如何对各隐藏层的输入进行标准化处理呢？</p>
<p>其实在神经网络中，第<script type="math/tex">l</script>层隐藏层的输入就是第<script type="math/tex">l−1</script>层隐藏层的输出<script type="math/tex">A^{[l−1]}</script>。对<script type="math/tex">A^{[l−1]}</script>进行标准化处理，从原理上来说可以提高<script type="math/tex">W^{[l]}</script>和<script type="math/tex">b^{[l]}</script>的训练速度和准确度。这种对各隐藏层的标准化处理就是Batch Normalization。值得注意的是，实际应用中，一般是对<script type="math/tex">Z^{[l−1]}</script>进行标准化处理而不是<script type="math/tex">A^{[l−1]}</script>，其实差别不是很大。</p>
<p>Batch Normalization对第<script type="math/tex">l</script>层隐藏层的输入<script type="math/tex">Z^{[l−1]}</script>做如下标准化处理，忽略上标<script type="math/tex">[l−1]</script>：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mu=\frac{1}{m} \sum_{i} z^{(i)} \\
\sigma^{2}=\frac{1}{m} \sum_{i}\left(z_{i}-\mu\right)^{2} \\z_{\text {norm }}^{(i)}=\frac{z^{(i)}-\mu}{\sqrt{\sigma^{2}+\varepsilon}}
\end{gathered}</script><p>其中，<script type="math/tex">m</script>是单个mini-batch包含样本个数，<script type="math/tex">\varepsilon</script>是为了防止分母为零，可取值<script type="math/tex">10^{−8}</script>。这样，使得该隐藏层的所有输入<script type="math/tex">z^{(i)}</script>均值为<script type="math/tex">0</script>，方差为<script type="math/tex">1</script>。但是，大部分情况下并不希望所有的<script type="math/tex">z^{(i)}</script>均值都为<script type="math/tex">0</script>，方差都为<script type="math/tex">1</script>，也不太合理。通常需要对<script type="math/tex">z^{(i)}</script>进行进一步处理：</p>
<script type="math/tex; mode=display">
\tilde{z}^{(i)}=\gamma \cdot z_{\text {norm }}^{(i)}+\beta</script><p>上式中，<script type="math/tex">γ</script>和<script type="math/tex">\beta</script>是learnable parameters，类似于<script type="math/tex">W</script>和<script type="math/tex">b</script>一样，可以通过梯度下降等算法求得。这里，<script type="math/tex">γ</script>和<script type="math/tex">\beta</script>的作用是让<script type="math/tex">\tilde z^{(i)}</script>的均值和方差为任意值，只需调整其值就可以了。例如，令：</p>
<script type="math/tex; mode=display">
\gamma=\sqrt{\sigma^{2}+\varepsilon}, \quad \beta=u</script><p>则<script type="math/tex">\tilde z^{(i)}=z^{(i)}</script>，即identity function。可见，设置<script type="math/tex">γ</script>和<script type="math/tex">\beta</script>为不同的值，可以得到任意的均值和方差。</p>
<p>这样，通过Batch Normalization，对隐藏层的各个<script type="math/tex">z^{[l](i)}</script>进行标准化处理，得到<script type="math/tex">\tilde z^{[l](i)}</script>，替代<script type="math/tex">z^{[l](i)}</script>。</p>
<p>注意，<strong>输入标准化</strong>处理Normalizing inputs和<strong>隐藏层标准化</strong>处理Batch  Normalization是有区别的。Normalizing inputs使所有输入的均值为<script type="math/tex">0</script>，方差为<script type="math/tex">1</script>。而Batch  Normalization可使各隐藏层输入的<strong>均值和方差为任意值</strong>。实际上，从激活函数的角度来说，如果各隐藏层的输入均值在靠近<script type="math/tex">0</script>的区域即处于激活函数的线性区域，这样不利于训练好的非线性神经网络，得到的模型效果也不会太好。这也解释了为什么需要用<script type="math/tex">γ</script>和<script type="math/tex">\beta</script>是来对<script type="math/tex">z^{[l](i)}</script>作进一步处理。</p>
<h4 id="7-5-将Batch-Norm拟合进神经网络"><a href="#7-5-将Batch-Norm拟合进神经网络" class="headerlink" title="7.5 将Batch Norm拟合进神经网络"></a>7.5 将Batch Norm拟合进神经网络</h4><p>我们已经知道了如何对某单一隐藏层的所有神经元进行Batch Norm，接下来将研究如何把Bath Norm应用到整个神经网络中。</p>
<p>对于<script type="math/tex">L</script>层神经网络，经过Batch Norm的作用，整体流程如下：</p>
<p><img src="https://pic.imgdb.cn/item/648aeae71ddac507cce4e5b1.png"></p>
<p>实际上，Batch Norm经常使用在mini-batch上，这也是其名称的由来。值得注意的是，因为Batch Norm对各隐藏层<script type="math/tex">Z^{[l]}=W^{[l]} A^{[l-1]}+b^{[l]}</script>有去均值的操作，所以这里的常数项<script type="math/tex">b^{[l]}</script>可以消去，其数值效果完全可以由<script type="math/tex">\tilde Z^{[l]}</script>中的<script type="math/tex">\beta</script>来实现。因此，我们在使用Batch Norm的时候，可以忽略各隐藏层的常数项<script type="math/tex">b^{[l]}</script>。在使用梯度下降算法时，分别对<script type="math/tex">W^{[l]}，β^{[l]}~ \text 和 ~γ^{[l]}</script>进行迭代更新。除了传统的梯度下降算法之外，还可以使用我们之前介绍过的动量梯度下降、RMSprop或者Adam等优化算法。</p>
<h4 id="7-6-Batch-Norm为什么有效"><a href="#7-6-Batch-Norm为什么有效" class="headerlink" title="7.6 Batch Norm为什么有效"></a>7.6 Batch Norm为什么有效</h4><p>我们可以把输入特征做均值为<script type="math/tex">0</script>，方差为<script type="math/tex">1</script>的规范化处理，来加快学习速度。而Batch Norm也是对隐藏层各神经元的输入做类似的规范化处理。总的来说，Batch Norm不仅能够提高神经网络训练速度，而且能让神经网络的权重<script type="math/tex">W</script>的更新更加“稳健”，尤其在深层神经网络中更加明显。比如神经网络很后面的<script type="math/tex">W</script>对前面的<script type="math/tex">W</script><strong>包容性更强</strong>，即前面的<script type="math/tex">W</script>的变化对后面<script type="math/tex">W</script>造成的影响很小，整体网络更加健壮。</p>
<p>举个例子来说明，假如用一个浅层神经网络(类似逻辑回归)来训练识别猫的模型。如下图所示，提供的所有猫的训练样本都是黑猫。然后，用这个训练得到的模型来对各种颜色的猫样本进行测试，测试的结果可能并不好。其原因是训练样本不具有一般性(即不是所有的猫都是黑猫)，这种训练样本(黑猫)和测试样本(猫)分布的变化称之为<strong>covariate shift</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/648aeafd1ddac507cce53503.png" style="zoom:50%"></p>
<p>对于这种情况，如果实际应用的样本与训练样本分布不同，即发生了covariate shift，则一般是要对模型<strong>重新训练</strong>的。在神经网络，尤其是深度神经网络中，covariate shift会导致模型预测效果变差，重新训练的模型各隐藏层的<script type="math/tex">W^{[l]}</script>和<script type="math/tex">B^{[l]}</script>均产生偏移、变化。而Batch Norm的作用恰恰是减小covariate shift的影响，让模型变得更加健壮，鲁棒性更强。Batch Norm减少了各层<script type="math/tex">W^{[l]}</script>、<script type="math/tex">B^{[l]}</script>之间的耦合性，让各层更加独立，实现自我训练学习的效果。也就是说，如果输入发生covariate shift，那么因为Batch Norm的作用，对个隐藏层输出<script type="math/tex">Z^{[l]}</script>进行均值和方差的归一化处理，<script type="math/tex">W^{[l]}</script>和<script type="math/tex">B^{[l]}</script>更加稳定，使得原来的模型也有不错的表现。针对上面这个黑猫的例子，如果我们使用深层神经网络，使用Batch Norm，那么该模型对花猫的识别能力应该也是不错的。</p>
<p>从另一个方面来说，<strong>Batch Norm也起到轻微的正则化</strong>(regularization)效果。具体表现在：</p>
<ul>
<li><strong>每个mini-batch都进行均值为</strong><script type="math/tex">0</script><strong>，方差为</strong><script type="math/tex">1</script><strong>的归一化操作</strong></li>
<li><strong>每个mini-batch中，对各个隐藏层的</strong><script type="math/tex">Z^{[l]}</script><strong>添加了随机噪声，效果类似于Dropout</strong></li>
<li><strong>mini-batch越小，正则化效果越明显</strong><br>但是，Batch Norm的正则化效果比较微弱，正则化也不是Batch Norm的主要功能。</li>
</ul>
<h4 id="7-7-测试时的Batch-Norm"><a href="#7-7-测试时的Batch-Norm" class="headerlink" title="7.7 测试时的Batch Norm"></a>7.7 测试时的Batch Norm</h4><p>训练过程中，Batch Norm是对单个mini-batch进行操作的，但在测试过程中，如果是单个样本，该如何使用Batch Norm进行处理呢？</p>
<p>首先，回顾一下训练过程中Batch Norm的主要过程：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mu=\frac{1}{m} \sum_{i} z^{(i)} \\
\sigma^{2}=\frac{1}{m} \sum_{i}\left(z^{(i)}-\mu\right)^{2} \\
z_{\text {norm }}^{(i)}=\frac{z^{(i)}-\mu}{\sqrt{\sigma^{2}+\varepsilon}} \\
\tilde{z}^{(i)}=\gamma \cdot z_{\text {norm }}^{(i)}+\beta
\end{gathered}</script><p>其中，<script type="math/tex">\mu</script>和<script type="math/tex">σ^2</script>是对单个mini-batch中所有<script type="math/tex">m</script>个样本求得的。在测试过程中，如果只有一个样本，求其均值和方差是没有意义的，就需要对<script type="math/tex">\mu</script>和<script type="math/tex">σ^2</script>进行估计。估计的方法很多，理论上可以将所有训练集放入最终的神经网络模型中，然后将每个隐藏层计算得到的<script type="math/tex">\mu^{[l]}</script>和<script type="math/tex">σ^{2[l]}</script>直接作为测试过程的<script type="math/tex">\mu</script>和<script type="math/tex">σ^2</script>来使用。但是，实际应用中一般不使用这种方法，而是使用我们之前介绍过的指数加权平均(exponentially weighted average)的方法来预测测试过程单个样本的<script type="math/tex">\mu</script>和<script type="math/tex">σ^2</script>。</p>
<p>指数加权平均的做法为，对第<script type="math/tex">l</script>层隐藏层，考虑所有mini-batch在该隐藏层下的<script type="math/tex">\mu^{[l]}</script>和<script type="math/tex">σ^{2[l]}</script>，然后用指数加权平均的方式来预测得到当前单个样本的<script type="math/tex">\mu^{[l]}</script>和<script type="math/tex">σ^{2[l]}</script>。这样就实现了对测试过程单个样本的均值和方差估计。最后，再利用训练过程得到的<script type="math/tex">\gamma</script>和<script type="math/tex">\beta</script>值计算出各层的<script type="math/tex">\tilde z^{(i)}</script>值。</p>
<h4 id="7-8-Softmax回归"><a href="#7-8-Softmax回归" class="headerlink" title="7.8 Softmax回归"></a>7.8 Softmax回归</h4><p>目前我们介绍的都是二分类问题，神经网络输出层只有一个神经元，表示预测输出<script type="math/tex">\hat y</script>是正类的概率<script type="math/tex">P(y = 1|x)</script>，若<script type="math/tex">\hat y>0.5</script>则判断为正类，否则判断为负类。</p>
<p>对于多分类问题，用<script type="math/tex">C</script>表示种类个数，神经网络中输出层就有<script type="math/tex">C</script>个神经元，即<script type="math/tex">n^{[L]}=C</script>。其中，每个神经元的输出依次对应属于该类的概率，即<script type="math/tex">P(y=c|x)</script>。为了处理多分类问题，一般使用Softmax回归模型。Softmax回归模型输出层的激活函数如下所示：</p>
<script type="math/tex; mode=display">
\begin{gathered}
z^{[L]}=W^{[L]} a^{[L-1]}+b^{[L]} \\
a_{i}^{[L]}=\frac{e^{z_{i}^{[L]}}}{\sum_{i=1}^{C} e^{z_{i}^{[L]}}}
\end{gathered}</script><p>输出层每个神经元的输出<script type="math/tex">a^{[L]}_i</script>对应属于该类的概率，满足：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{C} a_{i}^{[L]}=1</script><p>所有的<script type="math/tex">a^{[L]}_i</script>，即<script type="math/tex">\hat y</script>，维度为<script type="math/tex">(C, 1)</script>。</p>
<p>下面给出几个简单的线性多分类的例子(只有一个输出层)：</p>
<p><img src="https://pic.imgdb.cn/item/648aeb7e1ddac507cce6d5bb.png"></p>
<p>如果使用神经网络，特别是深层神经网络，可以得到更复杂、更精确的非线性模型。</p>
<h4 id="7-9-训练一个Softmax回归"><a href="#7-9-训练一个Softmax回归" class="headerlink" title="7.9 训练一个Softmax回归"></a>7.9 训练一个Softmax回归</h4><p>Softmax classifier的训练过程与我们之前介绍的二元分类问题有所不同。先来看一下softmax classifier的loss function。举例假如<script type="math/tex">C=4</script>，某个样本的预测输出<script type="math/tex">\hat y</script>和真实输出<script type="math/tex">y</script>为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\hat{y}=\left[\begin{array}{l}0.3 \\0.2 \\0.1 \\0.4
\end{array}\right] 
\qquad y=\left[\begin{array}{l}0 \\1 \\0 \\0
\end{array}\right]
\end{gathered}</script><p>从<script type="math/tex">\hat y</script>值来看，<script type="math/tex">P(y=4|x)=0.4</script>，概率最大，而真实样本属于第<script type="math/tex">2</script>类，因此该预测效果不佳。我们定义softmax classifier的loss function为：</p>
<script type="math/tex; mode=display">
L(\hat{y}, y)=-\sum_{j=1}^{4} y_{j} \cdot \log \hat{y}_{j}</script><p>然而，由于只有当<script type="math/tex">j=2</script>时，<script type="math/tex">y_2=1</script>，其它情况下，<script type="math/tex">y_j=0</script>。所以，上式中的<script type="math/tex">L(\hat y,y)</script>可以简化为：</p>
<script type="math/tex; mode=display">
L(\hat{y}, y)=-y_{2} \cdot \log \hat{y}_{2}=-\log \hat{y}_{2}</script><p>要让<script type="math/tex">L(\hat y,y)</script>更小，就应该让<script type="math/tex">\hat y_2</script>越大越好。<script type="math/tex">\hat y_2</script>反映的是概率，完全符合我们之前的定义。</p>
<p>所有<script type="math/tex">m</script>个样本的cost function为：</p>
<script type="math/tex; mode=display">
J=\frac{1}{m} \sum_{i=1}^{m} L(\hat{y}, y)</script><p>其预测输出向量<script type="math/tex">A^{[L]}</script>即<script type="math/tex">\hat Y</script>的维度为<script type="math/tex">(4, m)</script>。</p>
<p>softmax classifier的反向传播过程仍然使用梯度下降算法，其推导过程与二元分类有一点点不一样。因为只有输出层的激活函数不一样，我们先推导<script type="math/tex">dZ^{[L]}</script>：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathrm d a^{[L]}=-\frac{1}{a^{[L]}} \\
\frac{\partial a^{[L]}}{\partial z^{[L]}}=\frac{\partial}{\partial z^{[L]}} \cdot\left(\frac{e^{z_{i}^{[L]}}}{\sum_{i=1}^{C} e^{z_{i}^{[L]}}}\right)=a^{[L]} \cdot\left(1-a^{[L]}\right) \\
\mathrm d z^{[L]}=d a^{[L]} \cdot \frac{\partial a^{[L]}}{\partial z^{[L]}}=a^{[L]}-1=a^{[L]}-y
\end{gathered}</script><p>对于所有m个训练样本：</p>
<script type="math/tex; mode=display">
d Z^{[L]}=A^{[L]}-Y</script><p>可见<script type="math/tex">\mathrm dZ^{[L]}</script>的表达式与二元分类结果是一致的，虽然推导过程不太一样。然后就可以继续进行反向传播过程的梯度下降算法了，推导过程与二元分类神经网络完全一致。</p>
<h4 id="7-10-深度学习框架"><a href="#7-10-深度学习框架" class="headerlink" title="7.10 深度学习框架"></a>7.10 深度学习框架</h4><p>深度学习框架有很多，例如：</p>
<ul>
<li><strong>Caffe/Caffe2</strong></li>
<li><strong>CNTK</strong></li>
<li><strong>DL4J</strong></li>
<li><strong>Keras</strong></li>
<li><strong>Lasagne</strong></li>
<li><strong>mxnet</strong></li>
<li><strong>PaddlePaddle</strong></li>
<li><strong>TensorFlow</strong></li>
<li><strong>Theano</strong></li>
<li><strong>Torch(Pytorch)</strong><br>一般选择深度学习框架的基本准则是：</li>
<li><strong>Ease of programming(development and deployment)</strong></li>
<li><strong>Running speed</strong></li>
<li><strong>Truly open(open source with good governance)</strong></li>
</ul>
<h4 id="7-11-TensorFlow"><a href="#7-11-TensorFlow" class="headerlink" title="7.11 TensorFlow"></a><strong>7.11 TensorFlow</strong></h4><p>这里简单介绍一下最近几年比较火的一个深度学习框架：TensorFlow。</p>
<p>举个例子来说明，例如cost function是参数w的函数：</p>
<script type="math/tex; mode=display">
J(w) = w^{2}-10 w+25</script><p>如果使用TensorFlow对cost function进行优化，求出最小值对应的<script type="math/tex">w</script>程序如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">w = tf.Variable(<span class="number">0</span>,dtype=tf.float32)</span><br><span class="line"><span class="comment">#cost = tf.add(tf.add(w**2,tf.multiply(-10,w)),25)</span></span><br><span class="line">cost = w**<span class="number">2</span> - <span class="number">10</span>*w +<span class="number">25</span></span><br><span class="line">train = tf.train.GradientDescentOptimizer(<span class="number">0.01</span>).minimize(cost)</span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">session = tf.Session()</span><br><span class="line">session.run(init)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"><span class="comment"># &gt;&gt;0.0</span></span><br><span class="line">session.run(train)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"><span class="comment"># &gt;&gt;0.1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    session.run(train)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"><span class="comment"># &gt;&gt;4.99999</span></span><br></pre></td></tr></table></figure>
<p>TensorFlow框架内可以直接调用梯度下降优化算法，不需要我们自己再写程序了，大大提高了效率。在运行<script type="math/tex">1000</script>次梯度下降算法后，<script type="math/tex">w</script>的解为<script type="math/tex">4.99999</script>，已非常接近<script type="math/tex">w</script>的最优值<script type="math/tex">5</script>了。</p>
<p>针对上面这个例子，如果对<script type="math/tex">w</script>前的系数用变量<script type="math/tex">x</script>来代替，程序如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">cofficients = np.array([[<span class="number">1.</span>],[-<span class="number">10.</span>],[<span class="number">25.</span>]])</span><br><span class="line">w = tf.Variable(<span class="number">0</span>,dtype=tf.float32)</span><br><span class="line">x = tf.placeholder(tf.float32,[<span class="number">3</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">#cost = tf.add(tf.add(w**2,tf.multiply(-10,w)),25)</span></span><br><span class="line"><span class="comment">#cost = w**2 - 10*w +25</span></span><br><span class="line">cost = x[<span class="number">0</span>][<span class="number">0</span>]*w**<span class="number">2</span> + x[<span class="number">1</span>][<span class="number">0</span>]*w + x[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">train = tf.train.GradientDescentOptimizer(<span class="number">0.01</span>).minimize(cost)</span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">session = tf.Session()</span><br><span class="line">session.run(init)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"><span class="comment"># &gt;&gt;0.0</span></span><br><span class="line">session.run(train, feed_dict=(x:coefficients))</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"><span class="comment"># &gt;&gt;0.1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    session.run(train, feed_dict=(x:coefficients))</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"><span class="comment"># &gt;&gt;4.99999</span></span><br></pre></td></tr></table></figure>
<p>结果跟之前一样。此外，还可以更改<script type="math/tex">x</script>即cofficients的值，而得到不同的优化结果<script type="math/tex">w</script>。</p>
<p>另外，上段程序中的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">session = tf.Session()</span><br><span class="line">session.run(init)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br></pre></td></tr></table></figure>
<p>有另外一种写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">    session.run(init)</span><br><span class="line">    <span class="built_in">print</span>(session.run(w))</span><br></pre></td></tr></table></figure>
<p>TensorFlow的最大优点就是采用<strong>数据流图(data flow graphs)</strong>来进行数值运算。图中的节点(Nodes)表示数学操作，图中的线(edges)则表示在节点间相互联系的多维数据数组，即张量(tensor)。而且它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU(或GPU)，服务器，移动设备等等。<br>关于TensorFlow更多的原理和编程技巧这里就不在赘述了，感兴趣的朋友可以关注更详细的TensorFlow相关文档。</p>
<h3 id="第八章-机器学习策略"><a href="#第八章-机器学习策略" class="headerlink" title="第八章 机器学习策略"></a>第八章 机器学习策略</h3><p>《Structuring Machine Learning Projects》(构建机器学习项目)这门课是Andrw  Ng深度学习专项课程中的第三门课。这门课主要介绍机器学习中的一些策略和方法，让我们能够更快更有效地让机器学习系统工作，该门课共有两周的课时。</p>
<h4 id="8-1-1为什么是Machine-Learning-ML-策略"><a href="#8-1-1为什么是Machine-Learning-ML-策略" class="headerlink" title="8.1.1为什么是Machine Learning(ML)策略"></a>8.1.1为什么是Machine Learning(ML)策略</h4><p>当我们最初得到一个深度神经网络模型时，我们可能希望从很多方面来对它进行优化，例如：</p>
<ul>
<li>Collect more data</li>
<li>Collect more diverse training set</li>
<li>Train algorithm longer with gradient descent</li>
<li>Try Adam instead of gradient descent</li>
<li>Try bigger network</li>
<li>Try smaller network</li>
<li>Try dropout</li>
<li>Add L2 regularization</li>
<li>Network architecture: Activation functions, #hidden units…<br>可选择的方法很多，也很复杂、繁琐。盲目选择、尝试不仅耗费时间而且可能收效甚微。因此，使用快速、有效的策略来优化机器学习模型是非常必要的。</li>
</ul>
<h4 id="8-1-2-正交化"><a href="#8-1-2-正交化" class="headerlink" title="8.1.2 正交化"></a>8.1.2 正交化</h4><p>机器学习中有许多参数、超参数需要调试。通过每次只调试一个参数，保持其它参数不变，而得到的模型某一性能改变是一种最常用的调参策略，称之为<strong>正交化方法(Orthogonalization)</strong>。</p>
<p>Orthogonalization的核心在于<strong>每次调试一个参数只会影响模型的某一个性能</strong>。例如老式电视机旋钮，每个旋钮就对应一个功能，调整旋钮会调整对应的功能，而不会影响其它功能。也就是说彼此旋钮之间是互不影响的，是正交的，这也是Orthogonalization名称的由来。这种方法能够让我们更快更有效地进行机器学习模型的调试和优化。</p>
<p>对应到机器学习监督式学习模型中，可以大致分成四个独立的“功能”，每个“功能”对应一些可调节的唯一的旋钮。四个“功能”如下：</p>
<ul>
<li><strong>Fit training set well on cost function</strong></li>
<li><strong>Fit dev set well on cost function</strong></li>
<li><strong>Fit test set well on cost function</strong></li>
<li><strong>Performs well in real world</strong><br>第一条优化训练集可以通过使用更复杂NN，使用Adam等优化算法来实现；</li>
</ul>
<p>第二条优化验证集可以通过正则化，采用更多训练样本来实现；</p>
<p>第三条优化测试集可以通过使用更多的验证集样本来实现；</p>
<p>第四条提升实际应用模型可以通过更换验证集，使用新的cost function来实现。</p>
<p>概括来说，每一种“功能”对应不同的调节方法。而这些调节方法（旋钮）只会对应一个“功能”，是正交的。</p>
<p>顺便提一下，<strong>early stopping在模型功能调试中并不推荐使用</strong>。因为early stopping在提升验证集性能的同时降低了训练集的性能。也就是说early stopping同时影响两个“功能”，不具有独立性、正交性。</p>
<h4 id="8-1-3-单—数字评估指标"><a href="#8-1-3-单—数字评估指标" class="headerlink" title="8.1.3 单—数字评估指标"></a>8.1.3 单—数字评估指标</h4><p>构建、优化机器学习模型时，单值评价指标非常必要。有了量化的单值评价指标后，我们就能根据这一指标比较不同超参数对应的模型的优劣，从而选择最优的那个模型。</p>
<p>举个例子，比如有A和B两个模型，它们的<strong>准确率(Precision)</strong>和<strong>召回率(Recall)</strong>分别如下：</p>
<p><img src="https://pic.imgdb.cn/item/648aeddf1ddac507ccef3d76.png" style="zoom:80%"></p>
<p>如果只看Precision的话，B模型更好。如果只看Recall的话，A模型更好。实际应用中，我们通常使用单值评价指标<strong>F1 Score</strong>来评价模型的好坏。F1 Score综合了Precision和Recall的大小，计算方法如下：</p>
<script type="math/tex; mode=display">
F 1=\frac{2}{\frac1P+\frac1R}</script><p>然后得到了A和B模型各自的F1 Score：</p>
<p><img src="https://pic.imgdb.cn/item/648aedfc1ddac507ccefa608.png" style="zoom:80%"></p>
<p>从F1 Score来看，A模型比B模型更好一些。通过引入单值评价指标F1 Score，很方便对不同模型进行比较。</p>
<p>除了F1 Score之外，我们还可以使用<strong>平均值</strong>作为单值评价指标来对模型进行评估。如下图所示，A, B, C, D, E, F六个模型对不同国家样本的错误率不同，可以计算其平均性能，然后选择平均错误率最小的那个模型(C模型)。</p>
<p><img src="https://pic.imgdb.cn/item/648aeee81ddac507ccf2bf9c.png"></p>
<h4 id="8-1-4-满足和优化指标"><a href="#8-1-4-满足和优化指标" class="headerlink" title="8.1.4 满足和优化指标"></a>8.1.4 满足和优化指标</h4><p>有时候，要把所有的性能指标都综合在一起，构成单值评价指标是比较困难的。解决办法是，我们可以把某些性能作为<strong>优化指标(Optimizing metic)</strong>，寻求最优化值；而某些性能作为<strong>满意指标(Satisficing metic)</strong>，只要满足阈值就行了。</p>
<p>举个猫类识别的例子，有A，B，C三个模型，各个模型的Accuracy和Running time如下表中所示：</p>
<p><img src="https://pic.imgdb.cn/item/648aef171ddac507ccf359ea.png"></p>
<p>Accuracy和Running time这两个性能不合适综合成单值评价指标。因此，可以将Accuracy作为优化指标(Optimizing metic)，将Running time作为满意指标(Satisficing metic)。也就是说，给Running time设定一个阈值，在其满足阈值的情况下，选择Accuracy最大的模型。如果设定Running time必须在100ms以内，那么很明显，模型C不满足阈值条件，首先剔除；模型B相比较模型A而言，Accuracy更高，性能更好。</p>
<p>概括来说，性能指标(Optimizing metic)是需要优化的，越优越好；而满意指标(Satisficing metic)只要满足设定的阈值就好了。</p>
<h4 id="8-1-5-训练-验证-开发-测试集划分"><a href="#8-1-5-训练-验证-开发-测试集划分" class="headerlink" title="8.1.5 训练_验证(开发)_测试集划分"></a>8.1.5 训练_验证(开发)_测试集划分</h4><p>Train/dev/test sets如何设置对机器学习的模型训练非常重要，合理设置能够大大提高模型训练效率和模型质量。</p>
<p>原则上应该尽量保证dev sets和test sets来源于<strong>同一分布</strong>且都反映了实际样本的情况。如果dev sets和test sets不来自同一分布，那么我们从dev sets上选择的“最佳”模型往往不能够在test sets上表现得很好。</p>
<h4 id="8-1-6-开发集和测试集的大小"><a href="#8-1-6-开发集和测试集的大小" class="headerlink" title="8.1.6 开发集和测试集的大小"></a>8.1.6 开发集和测试集的大小</h4><p>在之前的课程中我们已经介绍过，当样本数量不多(小于一万)的时候，通常将Train/dev/test sets的比例设为60%/20%/20%，在没有dev sets的情况下，Train/test sets的比例设为70%/30%。当样本数量很大(百万级别)的时候，通常将相应的比例设为98%/1%/1%或者99%/1%。</p>
<p>对于dev sets数量的设置，应该遵循的准则是通过dev sets能够检测不同算法或模型的区别，以便选择出更好的模型。</p>
<p>对于test sets数量的设置，应该遵循的准则是通过test sets能够反映出模型在实际中的表现。</p>
<p>实际应用中，可能只有train/dev sets，而没有test sets。这种情况也是允许的，只要算法模型没有对dev sets过拟合。但是，条件允许的话，最好是有test sets，实现<strong>无偏估计</strong>。</p>
<h4 id="8-1-7什么时候该改变开发-测试集和指标"><a href="#8-1-7什么时候该改变开发-测试集和指标" class="headerlink" title="8.1.7什么时候该改变开发_测试集和指标"></a>8.1.7什么时候该改变开发_测试集和指标</h4><p>算法模型的评价标准有时候需要根据实际情况进行动态调整，目的是让算法模型在实际应用中有更好的效果。</p>
<p>举个猫类识别的例子。初始的评价标准是错误率，算法A错误率为3%，算法B错误率为5%。显然，A更好一些。但是，实际使用时发现算法A会通过一些色情图片，但是B没有出现这种情况。从用户的角度来说，他们可能更倾向选择B模型，虽然B的错误率高一些。这时候，我们就需要改变之前单纯只是使用错误率作为评价标准，而考虑新的情况进行改变。例如增加色情图片的权重，增加其代价。</p>
<p>原来的cost function：</p>
<script type="math/tex; mode=display">
J=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)</script><p>更改评价标准后的cost function：</p>
<script type="math/tex; mode=display">
\begin{aligned}J 
&=\frac{1}{w^{(i)}} \sum_{i=1}^{m} w^{(i)} L\left(\hat{y}^{(i)}, y^{(i)}\right) \\
w^{(i)} &= \begin{cases}1, & x^{(i)} \text { is non-porn } \\10, 
& x^{(i)} \text { is porn }
\end{cases}
\end{aligned}</script><p>概括来说，机器学习可分为两个过程：</p>
<pre><code>**(1)** Define a metric to evaluate classifiers

**(2)** How to do well on this metric
</code></pre><p>也就是说，第一步是找靶心，第二步是通过训练，射中靶心。但是在训练的过程中可能会根据实际情况改变算法模型的评价标准，进行动态调整。</p>
<p>另外一个需要动态改变评价标准的情况是dev/test sets与实际使用的样本分布不一致。比如猫类识别样本图像分辨率差异。</p>
<p><img src="https://pic.imgdb.cn/item/648aeffc1ddac507ccf70033.png"></p>
<h4 id="8-1-8-为什么是人的表现"><a href="#8-1-8-为什么是人的表现" class="headerlink" title="8.1.8 为什么是人的表现"></a>8.1.8 为什么是人的表现</h4><p>机器学习模型的表现通常会跟人类水平表现作比较，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648af01f1ddac507ccf77cd4.png" style="zoom:50%"></p>
<p>图中，横坐标是训练时间，纵坐标是准确性。机器学习模型经过训练会不断接近human-level performance甚至超过它。但是，超过human-level performance之后，准确性会上升得比较缓慢，最终不断接近理想的最优情况，称之为<strong>贝叶斯最优误差(bayes optimal error)</strong>。理论上任何模型都不能超过它，bayes optimal error代表了最佳表现。</p>
<p>实际上，human-level performance在某些方面有不俗的表现。例如图像识别、语音识别等领域，人类是很擅长的。所以，让机器学习模型性能不断接近human-level performance非常必要也做出很多努力：</p>
<ul>
<li>Get labeled data from humans.</li>
<li>Gain insight from manual error analysis: Why did a person get this right?</li>
<li>Better analysis of bias/variance.</li>
</ul>
<h4 id="8-1-9-可避免偏差"><a href="#8-1-9-可避免偏差" class="headerlink" title="8.1.9 可避免偏差"></a>8.1.9 可避免偏差</h4><p>实际应用中，要看human-level error，training error和dev error的相对值。例如猫类识别的例子中，如果human-level error为1%，training error为8%，dev error为10%。由于training error与human-level error相差7%，dev error与training error只相差2%，所以目标是尽量在训练过程中减小training error，即减小偏差bias。如果图片很模糊，肉眼也看不太清，human-level error提高到7.5%。这时，由于training error与human-level error只相差0.5%，dev error与training error只相差2%，所以目标是尽量在训练过程中减小dev error，即方差variance。这是相对而言的。</p>
<p>对于物体识别这类CV问题，human-level error是很低的，很接近理想情况下的bayes optimal error。因此，上面例子中的1%和7.5%都可以近似看成是两种情况下对应的bayes optimal error。实际应用中，我们一般会用human-level error代表bayes optimal error。</p>
<p>通常，<strong>把training error与human-level error的差值称为bias，也称作avoidable bias</strong>；<strong>把dev error与training error之间的差值称为variance</strong>。根据bias和variance值的相对大小，可以知道算法模型是否发生了欠拟合或者过拟合。</p>
<h4 id="8-1-10-理解人的表现"><a href="#8-1-10-理解人的表现" class="headerlink" title="8.1.10 理解人的表现"></a>8.1.10 理解人的表现</h4><p>我们说过human-level performance能够代表bayes optimal error。但是，human-level performance如何定义呢？举个医学图像识别的例子，不同人群的error有所不同：</p>
<ul>
<li><strong>Typical human : 3% error</strong></li>
<li><strong>Typical doctor : 1% error</strong></li>
<li><strong>Experienced doctor : 0.7% error</strong></li>
<li><strong>Team of experienced doctors : 0.5% error</strong><br>不同人群他们的错误率不同。一般来说，我们将表现最好的那一组，即Team of experienced doctors作为human-level performance。那么，这个例子中，human-level error就为0.5%。但是实际应用中，不同人可能选择的human-level performance基准是不同的，这会带来一些影响。</li>
</ul>
<p>假如该模型training error为0.7%，dev error为0.8。如果选择Team of experienced doctors，即human-level error为0.5%，则bias比variance更加突出。如果选择Experienced doctor，即human-level error为0.7%，则variance更加突出。也就是说，选择什么样的human-level error，有时候会影响bias和variance值的相对变化。当然这种情况一般只会在模型表现很好，接近bayes optimal error的时候出现。越接近bayes optimal error，模型越难继续优化，因为这时候的human-level performance可能是比较模糊难以准确定义的。</p>
<h4 id="8-1-11-超过人的表现"><a href="#8-1-11-超过人的表现" class="headerlink" title="8.1.11 超过人的表现"></a>8.1.11 超过人的表现</h4><p>对于自然感知类问题，例如视觉、听觉等，机器学习的表现不及人类。但是在很多其它方面，机器学习模型的表现已经超过人类了，包括：</p>
<ul>
<li>Online advertising</li>
<li>Product recommendations</li>
<li>Logistics(predicting transit time)</li>
<li>Loan approvals<br>实际上，机器学习模型超过human-level performance是比较困难的。但是只要提供足够多的样本数据，训练复杂的神经网络，模型预测准确性会大大提高，很有可能接近甚至超过human-level performance。值得一提的是当算法模型的表现超过human-level performance时，很难再通过人的直觉来解决如何继续提高算法模型性能的问题。</li>
</ul>
<h4 id="8-1-12-改善你模型的表现"><a href="#8-1-12-改善你模型的表现" class="headerlink" title="8.1.12 改善你模型的表现"></a>8.1.12 改善你模型的表现</h4><p>提高机器学习模型性能主要要解决两个问题：<strong>avoidable bias和variance</strong>。我们之前介绍过，training error与human-level error之间的差值反映的是avoidable bias，dev error与training error之间的差值反映的是variance。</p>
<p>解决avoidable bias的常用方法包括：</p>
<ul>
<li>Train bigger model</li>
<li>Train longer/better optimization algorithms: momentum, RMSprop, Adam</li>
<li>NN architecture/hyperparameters search<br>解决variance的常用方法包括：</li>
<li>More data</li>
<li>Regularization: L2, dropout, data augmentation</li>
<li>NN architecture/hyperparameters search</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/648af1351ddac507ccfaeda9.png"></p>
<h4 id="8-2-1-进行误差分析"><a href="#8-2-1-进行误差分析" class="headerlink" title="8.2.1 进行误差分析"></a>8.2.1 进行误差分析</h4><p>对已经建立的机器学习模型进行错误分析(error analysis)十分必要，而且有针对性地、正确地进行error analysis更加重要。</p>
<p>举个例子，猫类识别问题，已经建立的模型的错误率为10%。为了提高正确率，我们发现该模型会将一些狗类图片错误分类成猫。一种常规解决办法是扩大狗类样本，增强模型对够类(负样本)的训练。但是，这一过程可能会花费几个月的时间，耗费这么大的时间成本到底是否值得呢？也就是说扩大狗类样本，重新训练模型，对提高模型准确率到底有多大作用？这时候我们就需要进行error analysis，帮助我们做出判断。</p>
<p>方法很简单，我们可以从分类错误的样本中<strong>统计</strong>出狗类的样本数量。根据狗类样本所占的比重，判断这一问题的重要性。假如狗类样本所占比重仅为5%，即时我们花费几个月的时间扩大狗类样本，提升模型对其识别率，改进后的模型错误率最多只会降低到9.5%。相比之前的10%，并没有显著改善。我们把这种性能限制称为<strong>ceiling on performance</strong>。相反，假如错误样本中狗类所占比重为50%，那么改进后的模型错误率有望降低到5%，性能改善很大。因此，值得去花费更多的时间扩大狗类样本。</p>
<p>这种error analysis虽然简单，但是能够避免花费大量的时间精力去做一些对提高模型性能收效甚微的工作，让我们专注解决影响模型正确率的主要问题，十分必要。</p>
<p>这种error analysis可以同时评估多个影响模型性能的因素，通过各自在错误样本中所占的比例来判断其重要性。例如，猫类识别模型中，可能有以下几个影响因素：</p>
<ul>
<li>Fix pictures of dogs being recognized as cats</li>
<li>Fix great cats(lions, panthers, etc…) being misrecognized</li>
<li>Improve performance on blurry images<br>通常来说，比例越大，影响越大，越应该花费时间和精力着重解决这一问题。这种error analysis让我们改进模型更加有针对性，从而提高效率。</li>
</ul>
<h4 id="8-2-2-清除错误的数据"><a href="#8-2-2-清除错误的数据" class="headerlink" title="8.2.2 清除错误的数据"></a>8.2.2 清除错误的数据</h4><p>监督式学习中，训练样本有时候会出现输出<script type="math/tex">y</script>标注错误的情况，即incorrectly labeled examples。如果这些label标错的情况是随机性的(random errors)，DL算法对其包容性是比较强的，即健壮性好，一般可以直接忽略，无需修复。然而，如果是系统错误(systematic errors)，这将对DL算法造成影响，降低模型性能。</p>
<p>刚才说的是训练样本中出现incorrectly labeled data，如果是dev/test sets中出现incorrectly labeled data，该怎么办呢？</p>
<p>方法很简单，利用上节内容介绍的error analysis，统计dev sets中所有分类错误的样本中incorrectly labeled data所占的比例。根据该比例的大小，决定是否需要修正所有incorrectly labeled data，还是可以忽略。举例说明，若：</p>
<ul>
<li>Overall dev set error: 10%</li>
<li>Errors due incorrect labels: 0.6%</li>
<li>Errors due to other causes: 9.4%<br>上面数据表明Errors due incorrect labels所占的比例仅为0.6%，占dev set error的6%，而其它类型错误占dev set error的94%。因此，这种情况下，可以忽略incorrectly labeled data。</li>
</ul>
<p>如果优化DL算法后，出现下面这种情况：</p>
<ul>
<li>Overall dev set error: 2%</li>
<li>Errors due incorrect labels: 0.6%</li>
<li>Errors due to other causes: 1.4%<br>上面数据表明Errors due incorrect labels所占的比例依然为0.6%，但是却占dev set error的30%，而其它类型错误占dev set error的70%。因此，这种情况下，incorrectly labeled data不可忽略，需要手动修正。</li>
</ul>
<p>我们知道，dev set的主要作用是在不同算法之间进行比较，选择错误率最小的算法模型。但是，如果有incorrectly labeled data的存在，当不同算法错误率比较接近的时候，我们无法仅仅根据Overall dev set error准确指出哪个算法模型更好，必须修正incorrectly labeled data。</p>
<p>关于<strong>修正incorrect dev/test set data</strong>，有几条建议：</p>
<ul>
<li>Apply same process to your dev and test sets to make sure they continue to come from the same distribution</li>
<li>Consider examining examples your algorithm got right as well as ones it got wrong</li>
<li>Train and dev/test data may now come from slightly different distributions</li>
</ul>
<h4 id="8-2-3-快速搭建你的第一个系统"><a href="#8-2-3-快速搭建你的第一个系统" class="headerlink" title="8.2.3 快速搭建你的第一个系统"></a>8.2.3 快速搭建你的第一个系统</h4><p>对于如何构建一个机器学习应用模型，Andrew给出的建议是先快速构建第一个简单模型，然后再反复迭代优化。</p>
<ul>
<li>Set up dev/test set and metric</li>
<li>Build initial system quickly</li>
<li>Use Bias/Variance analysis &amp; Error analysis to prioritize next steps</li>
</ul>
<h4 id="8-2-4-在不同的划分上进行训练并测试"><a href="#8-2-4-在不同的划分上进行训练并测试" class="headerlink" title="8.2.4 在不同的划分上进行训练并测试"></a>8.2.4 在不同的划分上进行训练并测试</h4><p>当train set与dev/test set不来自同一个分布的时候，我们应该如何解决这一问题，构建准确的机器学习模型呢？</p>
<p>以猫类识别为例，train set来自于网络下载(webpages)，图片比较清晰；dev/test set来自用户手机拍摄(mobile app)，图片比较模糊。假如train set的大小为200000，而dev/test set的大小为10000，显然train set要远远大于dev/test set。</p>
<p><img src="https://pic.imgdb.cn/item/648af1f21ddac507ccfd9ad4.png"></p>
<p>虽然dev/test set质量不高，但是模型最终主要应用在对这些模糊的照片的处理上。面对train set与dev/test set分布不同的情况，有两种解决方法。</p>
<p>第一种方法是将train set和dev/test set完全混合，然后在随机选择一部分作为train set，另一部分作为dev/test set。例如，混合210000例样本，然后随机选择205000例样本作为train set，2500例作为dev set，2500例作为test set。这种做法的优点是实现train set和dev/test set分布一致，缺点是dev/test set中webpages图片所占的比重比mobile app图片大得多。例如dev set包含2500例样本，大约有2381例来自webpages，只有119例来自mobile app。这样，dev set的算法模型对比验证，仍然主要由webpages决定，实际应用的mobile app图片所占比重很小，达不到验证效果。因此，这种方法并不是很好。</p>
<p>第二种方法是将原来的train set和一部分dev/test set组合当成train set，剩下的dev/test set分别作为dev set和test set。例如，200000例webpages图片和5000例mobile app图片组合成train set，剩下的2500例mobile app图片作为dev set，2500例mobile app图片作为test set。其关键在于dev/test set全部来自于mobile app。这样保证了验证集最接近实际应用场合。这种方法较为常用，而且性能表现比较好。</p>
<h4 id="8-2-5-不匹配数据划分的偏差和方差"><a href="#8-2-5-不匹配数据划分的偏差和方差" class="headerlink" title="8.2.5 不匹配数据划分的偏差和方差"></a>8.2.5 不匹配数据划分的偏差和方差</h4><p>我们之前介绍过，根据human-level error、training error和dev error的相对值可以判定是否出现了bias或者variance。但是，需要注意的一点是，<strong>如果train set和dev/test set来源于不同分布，则无法直接根据相对值大小来判断。</strong>例如某个模型human-level error为0%，training error为1%，dev error为10%。根据我们之前的理解，显然该模型出现了variance。但是，training error与dev error之间的差值9%可能来自<strong>算法本身(variance)</strong>，也可能来自于<strong>样本分布不同</strong>。比如dev set都是很模糊的图片样本，本身就难以识别，跟算法模型关系不大。因此不能简单认为出现了variance。</p>
<p>在可能伴有train set与dev/test set分布不一致的情况下，定位是否出现variance的方法是<strong>设置train-dev set</strong>。Andrew给train-dev set的定义是：“Same distribution as training set, but not used for training.”也就是说，从原来的train set中分割出一部分作为train-dev set，train-dev set不作为训练模型使用，而是<strong>与dev set一样用于验证</strong>。</p>
<p>这样，我们就有training error、training-dev error和dev error三种error。其中，training error与training-dev error的差值反映了variance；training-dev error与dev error的差值反映了data mismatch problem，即样本分布不一致。</p>
<p>举例说明，如果training error为1%，training-dev error为9%，dev error为10%，则variance问题比较突出。如果training error为1%，training-dev error为1.5%，dev error为10%，则data mismatch problem比较突出。通过引入train-dev set，能够比较准确地定位出现了variance还是data mismatch。</p>
<p>总结一下human-level error、training error、training-dev error、dev error以及test error之间的差值关系和反映的问题：</p>
<p><img src="https://pic.imgdb.cn/item/648af21f1ddac507ccfe4d12.png" style="zoom:60%"></p>
<p>一般情况下，human-level error、training error、training-dev error、dev error以及test error的数值是递增的，但是也会出现dev error和test error下降的情况。这主要可能是因为训练样本比验证/测试样本更加复杂，难以训练。</p>
<p><img src="https://pic.imgdb.cn/item/648af3071ddac507cc01d8e0.png"></p>
<h4 id="8-2-6-解决数据不匹配"><a href="#8-2-6-解决数据不匹配" class="headerlink" title="8.2.6 解决数据不匹配"></a>8.2.6 解决数据不匹配</h4><p>关于如何解决train set与dev/test set样本分布不一致的问题，有两条建议：</p>
<ul>
<li>Carry out manual error analysis to try to understand difference between training dev/test sets</li>
<li>Make training data more similar; or collect more data similar to dev/test sets<br>为了让train set与dev/test set类似，可以用<strong>人工数据合成(artificial data synthesis)</strong>方法。例如说话人识别问题，实际应用场合(dev/test set)是包含背景噪声的，而训练样本train set很可能没有背景噪声。为了让train set与dev/test set分布一致，我们可以在train set上人工添加背景噪声，合成类似实际场景的声音。这样会让模型训练的效果更准确。</li>
</ul>
<p>但需要注意的是，我们不能给每段语音都增加同一段背景噪声，这样会出现对背景噪音的<strong>过拟合</strong>，效果不佳。这就是人工数据合成需要注意的地方。</p>
<h4 id="8-2-7-迁移学习"><a href="#8-2-7-迁移学习" class="headerlink" title="8.2.7 迁移学习"></a>8.2.7 迁移学习</h4><p>深度学习非常强大的一个功能之一就是有时候你可以将已经训练好的模型的一部分知识（网络结构）直接应用到另一个类似模型中去。比如我们已经训练好一个猫类识别的神经网络模型，那么我们可以直接把该模型中的一部分网络结构应用到使用X光片预测疾病的模型中去。这种学习方法被称为<strong>迁移学习(Transfer Learning)</strong>。</p>
<p>如果我们已经有一个训练好的神经网络，用来做图像识别。现在，我们想要构建另外一个通过X光片进行诊断的模型。迁移学习的做法是无需重新构建新的模型，而是利用之前的神经网络模型，只改变样本输入、输出以及输出层的权重系数<script type="math/tex">W^{[L]}, b^{[L]}</script>。也就是说对新的样本<script type="math/tex">(X,Y)</script>，重新训练输出层权重系数<script type="math/tex">W^{[L]}, b^{[L]}</script>，而其它层所有的权重系数<script type="math/tex">W^{[L]}, b^{[L]}</script>保持不变。</p>
<p><img src="https://pic.imgdb.cn/item/648af3561ddac507cc02ff49.png"></p>
<p>迁移学习，重新训练权重系数，如果需要构建新模型的样本数量较少，那么可以像刚才所说的，只训练输出层的权重系数<script type="math/tex">W^{[L]}, b^{[L]}</script>，保持其它层所有的权重系数<script type="math/tex">W^{[L]}, b^{[L]}</script>不变。这种做法相对来说比较简单。如果样本数量足够多，那么也可以只保留网络结构，重新训练所有层的权重系数。这种做法使得模型更加精确，因为毕竟样本对模型的影响最大。选择哪种方法通常由数据量决定。</p>
<p>顺便提一下，如果重新训练所有权重系数，初始<script type="math/tex">W^{[L]}, b^{[L]}</script>由之前的模型训练得到，这一过程称为<strong>pre-training</strong>。之后不断调试、优化<script type="math/tex">W^{[L]}, b^{[L]}</script>的过程称为<strong>fine-tuning</strong>。pre-training和fine-tuning分别对应上图中的黑色箭头和红色箭头。</p>
<p>迁移学习之所以能这么做的原因是，神经网络浅层部分能够检测出许多图片固有<strong>特征</strong>，例如图像边缘、曲线等。使用之前训练好的神经网络部分结果有助于我们更快更准确地提取X光片特征。二者处理的都是图片，而图片处理是有相同的地方，第一个训练好的神经网络已经帮我们实现如何提取图片有用特征了。 因此，即便是即将训练的第二个神经网络样本数目少，仍然可以根据第一个神经网络结构和权重系数得到健壮性好的模型。</p>
<p>迁移学习可以保留原神经网络的一部分，再添加新的网络层。具体问题，具体分析，可以去掉输出层后再增加额外一些神经层。</p>
<p><img src="https://pic.imgdb.cn/item/648af3a01ddac507cc040506.png"></p>
<p>总体来说，迁移学习的应用场合主要包括三点：</p>
<ul>
<li>Task A and B have the same input x.</li>
<li>You have a lot more data for Task A than Task B.</li>
<li>Low level features from A could be helpful for learning B.</li>
</ul>
<h4 id="8-2-8-多任务学习"><a href="#8-2-8-多任务学习" class="headerlink" title="8.2.8 多任务学习"></a>8.2.8 多任务学习</h4><p>多任务学习(multi-task learning)就是构建神经网络同时执行多个任务。这跟二元分类或者多元分类都不同，多任务学习类似将多个神经网络融合在一起，用一个网络模型来实现多种分类效果。如果有<script type="math/tex">C</script>个，那么输出<script type="math/tex">y</script>的维度是<script type="math/tex">(C,1)</script>。</p>
<p>例如汽车自动驾驶中，需要实现的多任务为行人、车辆、交通标志和信号灯。如果检测出汽车和交通标志，则<script type="math/tex">y</script>为：</p>
<script type="math/tex; mode=display">
y = [1,0,0,1]^{\text T}</script><p>多任务学习模型的cost function为：</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{1}{m} \sum_{i=1}^{m} \sum_{j=1}^{c} L\left(\hat{y}_{j}^{(i)}, y_{j}^{(i)}\right)
\end{equation}</script><p>其中，<script type="math/tex">j</script>表示任务下标，总有<script type="math/tex">c</script>个任务。对应的loss function为：</p>
<script type="math/tex; mode=display">
L\left(\hat{y}_{j}^{(i)}, y_{j}^{(i)}\right)=-y_{j}^{(i)} \log \hat{y}_{j}^{(i)}-\left(1-y_{j}^{(i)}\right) \log \left(1-\hat{y}_{j}^{(i)}\right)</script><p>值得一提的是，Multi-task learning与Softmax regression的区别在于Softmax regression是single label的，即输出向量y只有一个元素为1；而Multi-task learning是multiple labels的，即输出向量y可以有多个元素为1。</p>
<p>多任务学习是使用单个神经网络模型来实现多个任务。实际上，也可以分别构建多个神经网络来实现。但是，如果各个任务之间是相似问题(例如都是图片类别检测)，则可以使用多任务学习模型。另外，多任务学习中，可能存在训练样本<script type="math/tex">Y</script>某些label空白的情况，这并不影响多任务模型的训练。</p>
<p>总体来说，多任务学习的应用场合主要包括三点：</p>
<pre><code>Training on a set of tasks that could benefit from having shared lower-level features.

Usually: Amount of data you have for each task is quite similar.

Can train a big enough neural network to do well on all the tasks.
</code></pre><p>顺便提一下，迁移学习和多任务学习在实际应用中，迁移学习使用得更多一些。</p>
<h4 id="8-2-9-什么是端到端的深度学习"><a href="#8-2-9-什么是端到端的深度学习" class="headerlink" title="8.2.9 什么是端到端的深度学习"></a>8.2.9 什么是端到端的深度学习</h4><p>端到端(end-to-end)深度学习就是将所有不同阶段的数据处理系统或学习系统模块组合在一起，用一个单一的神经网络模型来实现所有的功能。它将所有模块混合在一起，只关心输入和输出。</p>
<p>以语音识别为例，传统的算法流程和end-to-end模型的区别如下：</p>
<p><img src="https://pic.imgdb.cn/item/648af3d61ddac507cc04b689.png"></p>
<p>如果训练样本足够大，神经网络模型足够复杂，那么end-to-end模型性能比传统机器学习分块模型更好。实际上，end-to-end让神经网络模型内部去自我训练模型特征，自我调节，增加了模型整体契合度。</p>
<h4 id="8-2-10-是否要使用端到端的深度学习"><a href="#8-2-10-是否要使用端到端的深度学习" class="headerlink" title="8.2.10 是否要使用端到端的深度学习"></a>8.2.10 是否要使用端到端的深度学习</h4><p>end-to-end深度学习有优点也有缺点。</p>
<p>优点：</p>
<pre><code>Let the data speak

Less hand-designing of components needed
</code></pre><p>缺点：</p>
<pre><code>May need large amount of data

Excludes potentially useful hand-designed
</code></pre><p><strong>到这里这门课程的学习暂告一段落(ps：并不是不学了，接下来学习一些网络CNN、读一些论文看看再决定下一步得计划)</strong></p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>参考链接1：<a href="https://www.bilibili.com/video/BV1FT4y1E74V?p=1">吴恩达深度学习deeplearning.ai</a></p>
<p>参考链接2：<a href="https://blog.csdn.net/wuzhongqiang/article/details/89702268">本笔记参考链接</a></p>
<p>参考链接3：<a href="https://www.zhihu.com/column/c_1007644614324535296">吴恩达机器学习课思维导图</a></p>
<p>参考链接4：<a href="https://blog.csdn.net/weixin_43061212/article/details/82750763?utm_source=app&amp;app_version=4.20.0">DeepLearning吴恩达深度学习课程笔记思维导图</a></p>
<p>参考链接5：<a href="https://www.bilibili.com/video/BV1yg411K72z">三个月从零入门深度学习，保姆级学习路线图</a></p>
<p>参考链接6：<a href="https://www.bilibili.com/video/BV1yg411K72z">【人工智能学习】逐句阅读100篇核心AI论文（双语字幕）</a></p>
<p>参考链接7：<a href="https://zhuanlan.zhihu.com/p/37349519">纯新手自学入门机器/深度学习指南） - 量子位的文章 - 知乎</a></p>
<p>参考链接8：<a href="https://www.bilibili.com/video/BV1Lv41177BW/">Pytorch环境安装配置 - Bilibili</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习知识查漏补缺</title>
    <url>/2024/08/06/Foundation-of-DeepLearning-4/</url>
    <content><![CDATA[<h3 id="1-梯度下降、反向传播的理解"><a href="#1-梯度下降、反向传播的理解" class="headerlink" title="1 梯度下降、反向传播的理解"></a>1 梯度下降、反向传播的理解</h3><h4 id="1-1-最小二乘法的梯度下降解法"><a href="#1-1-最小二乘法的梯度下降解法" class="headerlink" title="1.1 最小二乘法的梯度下降解法"></a>1.1 最小二乘法的梯度下降解法</h4><p>首先，我们先来看一下最小二乘法是如何利用梯度下降反向传播算法来求解的（PS：当然，最小二乘法一般都是用理论公式求解的）</p>
<p>假设我们有以下数据点：  $\{(1, 2), (2,4), (3,5), (4,4), (5,5)\}$，我们希望拟合一条直线： </p>
<script type="math/tex; mode=display">
y = kx + b</script><p>通过最小二乘法，找到最优的$k$和$b$。</p>
<p><strong>损失函数</strong>：最小二乘法的损失函数为</p>
<script type="math/tex; mode=display">
\begin{align}
L(k, b) 
&= \sum_{i=1}^n (y_i - \hat y_i)^2 \\
&=\sum_{i=1}^{n=5}(y_i - kx_i - b)^2 \\
& = (y_1 - kx_1 - b)^2 + (y_2 - kx_2 - b)^2 + (y_3 - kx_3 - b)^2 + (y_4 - kx_4 - b)^2 + (y_5 - kx_5 - b)^2 \\
\end{align}</script><p><strong>梯度计算</strong>：损失函数对$k$和$b$的梯度为</p>
<script type="math/tex; mode=display">
\dfrac{\partial L}{\partial k} = -2\sum_{i=1}^{n=5}(y_i - kx_i - b)x_i \quad \text{和} \quad \dfrac{\partial L}{\partial b} = -2\sum_{i=1}^{n=5}(y_i - kx_i - b)</script><p><strong>梯度下降更新规则</strong>：通过梯度下降法，逐步更新$k$和$b$</p>
<script type="math/tex; mode=display">
k = k - \eta \dfrac{\partial L}{\partial k} \quad \text{和} \quad b = b - \eta\dfrac{\partial L}{\partial b}</script><p><strong>具体步骤</strong></p>
<p> （1）初始化参数</p>
<ul>
<li>初始值：$k=0.0， b=0.0$</li>
<li>学习率：$η=0.01$</li>
<li>迭代次数：1000次</li>
</ul>
<p>（2）迭代过程</p>
<p>我们以第一次迭代为例，详细说明每一步的计算。</p>
<p>第一次迭代：</p>
<p></p><p style="text-indent:2em">1. 计算预测值：</p><p></p>
<script type="math/tex; mode=display">
\hat y_i  = kx_i+b=0.0⋅x_i+0.0=0.0 \qquad i = 1,2,3,4,5</script><p></p><p style="text-indent:2em">2. 带入梯度计算公式：</p><p></p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial L}{\partial k} & =-2\sum_{i=1}^{n=5}(y_i-kx_i-b)x_i & \frac{\partial L}{\partial b} & =-2\sum_{i=1}^{n=5}(y_i-kx_i-b) \\
 & =-2\sum_{i=1}^{n=5}y_ix_i & & =-2\sum_{i=1}^{n=5}y_i \\
 & =-2(2\cdot1+4\cdot2+5\cdot3+4\cdot4+5\cdot5) & & =-2(2+4+5+4+5) \\
 & =-132 & & =-40
\end{aligned}</script><p></p><p style="text-indent:2em"> 3. 更新参数：</p><p></p>
<script type="math/tex; mode=display">
k = k - \eta \dfrac{\partial L}{\partial k} = 0.0 − 0.01⋅(−132) = 1.32 \\
b = b - \eta\dfrac{\partial L}{\partial b} = 0.0−0.01⋅(−40)=0.4</script><p>第二次迭代：</p>
<p></p><p style="text-indent:2em"> 1. 计算预测值：</p><p></p>
<script type="math/tex; mode=display">
\hat y_i  = kx_i+b = 1.32⋅x_i + 0.4</script><p>经计算，对于$x=[1,2,3,4,5]$，$\hat y = [1.72,3.04,4.36,5.68,7.0]$。 </p>
<p></p><p style="text-indent:2em"> 2. 带入梯度计算公式：</p><p></p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial L}{\partial k} & =-2\sum_{i=1}^{n=5}(y_i-kx_i-b)x_i & \frac{\partial L}{\partial b} & =-2\sum_{i=1}^{n=5}(y_i-kx_i-b) \\
 & =-2\sum_{i=1}^{n=5}(y_i - \hat y_i)x_i & & =-2\sum_{i=1}^{n=5}(y_i - \hat y_i) \\
 & =−2(0.28⋅1+0.96⋅2+0.64⋅3 & & =−2(0.28+0.96+0.64−1.68−2.0) \\
 &  \quad \qquad +(−1.68)⋅4+(−2.0)⋅5) \\
 & =25.2  & & =3.6
\end{aligned}</script><p></p><p style="text-indent:2em"> 3. 更新参数： </p><p></p>
<script type="math/tex; mode=display">
k = k - \eta \dfrac{\partial L}{\partial k} = 1.32 − 0.01⋅25.2 = 1.068 \\
b = b - \eta\dfrac{\partial L}{\partial b} = 0.4−0.01⋅3.6 = 0.364</script><p>继续迭代：</p>
<p>重复上述过程，直到达到指定的迭代次数（如 1000 次）或损失函数收敛。</p>
<p>可以看到，<font color="red">损失函数是<strong>权重的函数</strong>，而不是输入数据的函数。 梯度下降是对<strong>权重（参数）</strong>进行下降，而不是对输入数据</font>。 </p>
<blockquote>
<p>2025-01-07日晚上之所以花时间写下这部分内容，主要就是有一个小小的问题把我困绕了好久，那就是神经网络的损失函数：</p>
<script type="math/tex; mode=display">
J = f(\boldsymbol W \boldsymbol X + \boldsymbol b) - \boldsymbol y</script><p>我们要使用$\dfrac{\partial J}{\partial \boldsymbol W}$来对权重$\boldsymbol W$进行梯度下降，使得$J$最小，但是我产生的疑惑是，每次批量输进去的图片都不一样，也就是$J$不是一个固定的函数，那要怎么求导呢，其实看了最小二乘的求解过程，我就知道问题所在就是要<strong><font color="blue">一次性使用全部的数据</font></strong>！！！</p>
</blockquote>
<p><strong><font color="purple">补充</font></strong>：为什么神经网络利用梯度下降进行反向传播时，不像最小二乘一样使用全部的数据来计算呢？</p>
<p>神经网络不一下子把所有数据全都喂进网络，再进行反向传播求解参数，主要有以下几个原因：</p>
<ul>
<li><strong>内存限制</strong><ul>
<li>训练大型神经网络时，数据集通常非常大。一次性将所有数据加载到内存中可能会导致内存不足的问题。</li>
</ul>
</li>
<li><strong>计算效率</strong><ul>
<li>现代硬件（如GPU和TPU）在处理大规模矩阵运算时非常高效，但它们在处理单个非常大的矩阵时可能不如处理多个较小的矩阵高效。通过将数据分成小批次，可以更好地利用这些硬件的并行计算能力，提高训练速度。</li>
</ul>
</li>
<li><strong>梯度估计的稳定性</strong><ul>
<li>在每次迭代中使用整个数据集来计算梯度，会导致梯度估计非常不稳定，因为每个梯度更新都基于整个数据集的统计特性。这可能导致训练过程波动较大，甚至可能使模型无法收敛。而使用小批次的数据来估计梯度，可以使梯度估计更加稳定，从而有助于更稳定的训练过程。</li>
</ul>
</li>
<li><strong>正则化效果</strong><ul>
<li>在小批次训练中，随机梯度下降（SGD）等优化算法引入了噪声，这种噪声有助于防止过拟合，起到一定的正则化效果。而在全量数据训练中，梯度更新过于平滑，可能会使模型过拟合训练数据。</li>
</ul>
</li>
<li><strong>在线学习与实时更新</strong><ul>
<li>在某些应用场景中，例如在线学习或实时更新模型，数据是持续到来的。在这种情况下，不可能一次性将所有数据加载到内存中进行处理。分批次处理数据使得模型能够逐步适应新数据，保持其性能。</li>
</ul>
</li>
<li><strong>分布式训练</strong><ul>
<li>在分布式训练环境中，数据需要被分割成小块并分发到不同的计算节点上。分批次处理数据使得这种分布式训练成为可能，并且可以有效地利用多台机器的计算资源。</li>
</ul>
</li>
</ul>
<h3 id="2-dropout层原理和反向传播"><a href="#2-dropout层原理和反向传播" class="headerlink" title="2 dropout层原理和反向传播"></a>2 dropout层原理和反向传播</h3><h4 id="2-1-dropout-的概念"><a href="#2-1-dropout-的概念" class="headerlink" title="2.1 dropout 的概念"></a>2.1 dropout 的概念</h4><p>深度神经网络结构的过拟合是指：在训练集上的正确率很高, 但在测试集上的准确率很低。为了缓解网络过拟合的问题，其中一种常见的办法是使用 dropout 函数。</p>
<p>dropout 是指在深度网络的训练中，以一定的概率随机地 “临时丢弃” 一部分神经元节点，具体来讲，<strong>dropout作用于每份小批量训练数据</strong>，由于其随机丢弃部分神经元的机制, 相当于每次迭代都在训练不同结构的神经网络。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">dropout 前网络结构示意</th>
<th style="text-align:center">dropout 后网络结构示意</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://pic.imgdb.cn/item/676a7470d0e0a243d4e93a9a.png"></td>
<td style="text-align:center"><img src="https://pic.imgdb.cn/item/676a7484d0e0a243d4e93a9c.png"></td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-2-dropout-的作用"><a href="#2-2-dropout-的作用" class="headerlink" title="2.2 dropout 的作用"></a>2.2 dropout 的作用</h4><p>dropout 最直接的作用就是可以提升模型的泛化能力，提高模型的健壮性，提高通用性。</p>
<blockquote>
<p>通俗的理解：</p>
<p>假设某公司存在一个职能稳定，合理分工团队。因为某些不可避免的原因，该团队的成员每天都有 50% 概率不能参与工作。为了完成任务，需要其他同事加班完成缺席员工任务。一段时间后, 该团队的成员普遍学会了其他同事的相关工作技能。于是，该团队拥有了更好的泛化能力。</p>
</blockquote>
<h4 id="2-3-训练过程中的-dropout"><a href="#2-3-训练过程中的-dropout" class="headerlink" title="2.3 训练过程中的 dropout"></a>2.3 训练过程中的 dropout</h4><p>为了定义 dropout，我们需要一个随机数生成函数<code>rand()</code>，每一次调用都会重新生成一个<code>0~1</code>之间的小数：</p>
<script type="math/tex; mode=display">
r = \text{rand()} \in (0,1)</script><p>假设每一次 dropout 都以$0&lt;p&lt;1$的概率随机丢弃一个节点，则 dropout 函数的定义为：</p>
<script type="math/tex; mode=display">
\text{dropout}(x) = 
\begin{cases}
0&, r < p \\
\dfrac{x}{1-p}&, r \geq p
\end{cases}</script><p>将通过的信号被放大$\dfrac{1}{1-p}$倍，保证总体信号强度不变 (加班)。</p>
<p>dropout函数是逐个元素处理的, 并不需要写成向量的形式，但为了方便编程实现，这里将其进行改编成向量的形式：考虑一个输入向量$\boldsymbol x$，同时定义一个随机掩码函数和一个随机掩码向量$\boldsymbol m$：</p>
<script type="math/tex; mode=display">
\begin{align}
& \boldsymbol x = (x_1, x_2, \cdots, x_k) \\
& r_i = \text{rand}() \\
& m_i = \text{randomMask}(x_i) = \begin{cases}
0&, r < p \\
\dfrac{1}{1-p}&, r \geq p
\end{cases}
\end{align}</script><p>dropout函数可用向量运算表示为：</p>
<script type="math/tex; mode=display">
\text{dropout}(\boldsymbol x) = \boldsymbol x \odot \boldsymbol m = (x_1m_1, x_2m_2, \cdots, x_km_k)</script><h4 id="2-4-测试过程中的-dropout"><a href="#2-4-测试过程中的-dropout" class="headerlink" title="2.4 测试过程中的 dropout"></a>2.4 测试过程中的 dropout</h4><p>训练完成后，恢复完整的网络结构：</p>
<script type="math/tex; mode=display">
\text{dropout}(\boldsymbol x) = \boldsymbol x</script><h4 id="2-5-反向传播"><a href="#2-5-反向传播" class="headerlink" title="2.5 反向传播"></a>2.5 反向传播</h4><p>考虑一个输入向量$\boldsymbol x$，经丢弃概率为$p$的dropout函数变换后得到向量$\boldsymbol d$，往前 forward 传播得到误差值 error (标量 e )，求在训练过程中 e 对 $\boldsymbol x$ 的梯度：</p>
<script type="math/tex; mode=display">
\begin{align}
& \boldsymbol x = (x_1, x_2, \cdots, x_k) \\
& \boldsymbol d = \text{dropout}(\boldsymbol x) \\
& e = \text{forward}(\boldsymbol d) 
\end{align}</script><p>求梯度：</p>
<script type="math/tex; mode=display">
\dfrac{\text{d} e}{\text{d}x_i} = \dfrac{\text{d} e}{\text{d}d_i} \dfrac{\text{d} d_i}{\text{d}x_i}</script><p>其中：</p>
<script type="math/tex; mode=display">
\dfrac{\text{d} d_i}{\text{d}x_i} = m_i = \begin{cases}
0&, r_i < p \\
\dfrac{1}{1-p}&, r_i \geq p
\end{cases}</script><p>故有：</p>
<script type="math/tex; mode=display">
\dfrac{\text{d} e}{\text{d}x_i}  = \dfrac{\text{d} e}{\text{d}d_i} \odot m_i</script><p>向量$\dfrac{\text{d} e}{\text{d}d_i}$由上游负责计算，是已知的。</p>
<p><a href="https://blog.csdn.net/oBrightLamp/article/details/84105097">dropout函数详解及反向传播中的梯度求导 - CSDN</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/35948928">dropout正则化的反向传播的代码实现 - 知乎</a></p>
<h3 id="3-卷积层为什么不使用dropout"><a href="#3-卷积层为什么不使用dropout" class="headerlink" title="3 卷积层为什么不使用dropout"></a>3 卷积层为什么不使用dropout</h3><p><a href="https://www.zhihu.com/question/52426832">卷积层为什么不使用dropout? - 知乎</a></p>
<h3 id="4-卷积核梯度计算"><a href="#4-卷积核梯度计算" class="headerlink" title="4 卷积核梯度计算"></a>4 卷积核梯度计算</h3><p><a href="https://blog.csdn.net/weixin_44246009/article/details/119379516">【PyTorch】卷积层、池化层梯度计算 - CSDN</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/64248652">卷积核梯度计算的推导及实现 - 渐渐弃坑的文章 - 知乎</a></p>
<h3 id="5-池化层的反向传播"><a href="#5-池化层的反向传播" class="headerlink" title="5 池化层的反向传播"></a>5 池化层的反向传播</h3><p><a href="https://blog.csdn.net/qq_36561737/article/details/120066997">MaxPooling和AvgPooling的求导过程 - CSDN</a><br><a href="https://blog.csdn.net/qq_50710984/article/details/123378960">池化层的反向传播 - CSDN</a><br><a href="https://www.bilibili.com/video/BV1Dd4y1Q7Qq/?p=126&amp;vd_source=b11850f360abfce51bee36035b825020">33.7.13 池化层的反向传播 - bilibili</a></p>
<h3 id="6-请问训练数据包含负数能用relu激活函数吗"><a href="#6-请问训练数据包含负数能用relu激活函数吗" class="headerlink" title="6 请问训练数据包含负数能用relu激活函数吗"></a>6 请问训练数据包含负数能用relu激活函数吗</h3><p><a href="https://www2.zhihu.com/question/357980658">卷积神经网络训练图像的时候，像素值都是大于0的，那么激活函数relu还有什么作用呢？- 知乎</a></p>
<p><a href="https://www2.zhihu.com/question/49096923">深度学习中，图片的预处理为什么要减去图片的平均值，在什么情况下要选择这种预处理方式？ - 知乎</a></p>
<h3 id="7-从零构建神经网络-不使用框架"><a href="#7-从零构建神经网络-不使用框架" class="headerlink" title="7 从零构建神经网络-不使用框架"></a>7 从零构建神经网络-不使用框架</h3><p><a href="https://www.zhihu.com/question/314879954">如何自己从零实现一个神经网络? - 知乎</a></p>
<h3 id="8-如何自定义激活函数"><a href="#8-如何自定义激活函数" class="headerlink" title="8 如何自定义激活函数"></a>8 如何自定义激活函数</h3><p><a href="https://blog.csdn.net/weixin_49117441/article/details/123056849">Pytorch 学习笔记-自定义激活函数 - CSDN</a></p>
<h3 id="9-关于激活函数的问题"><a href="#9-关于激活函数的问题" class="headerlink" title="9 关于激活函数的问题"></a>9 关于激活函数的问题</h3><p><a href="https://zhuanlan.zhihu.com/p/67054518">由dead relu引发的思考——正则化算法漫谈</a></p>
<p><a href="https://www.zhihu.com/question/444283657">为什么不用绝对值作为神经网络的激活函数？ - 知乎</a></p>
<p><a href="https://www.rvmcu.com/community-topic-id-654.html">【分享】 激活函数ReLU的理解与总结</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/535000741">ReLU的作用 - sylvia的文章 - 知乎</a></p>
<p><a href="https://blog.sciencenet.cn/blog-3428464-1285447.html">【转载】激活函数总结（一）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/431710950">关于RELU激活函数造成神经元不可逆死亡的思考. - RICH双子的文章 - 知乎</a></p>
<p><a href="https://blog.csdn.net/weixin_38190702/article/details/125540813">Dynamic ReLU激活函数 - CSDN</a></p>
<h3 id="10-其他问题"><a href="#10-其他问题" class="headerlink" title="10 其他问题"></a>10 其他问题</h3><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/2022/04/17/Foundation-of-Python/</url>
    <content><![CDATA[<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1o4411M71o" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/213b14bfbdbf54248a3f5fa742cb9f9c8f684274.png)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">40:08:30</span>
            </div>
            <div class="bvideo-info">
                <p class="title">黑马程序员全套Python教程_Python基础入门视频教程，零基础小白自学Python入门教程</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>172.3万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>4.9万</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">黑马程序员</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<h3 id="第〇章-PYTHON简介"><a href="#第〇章-PYTHON简介" class="headerlink" title="第〇章 PYTHON简介"></a>第〇章 PYTHON简介</h3><h4 id="0-1-Python简介"><a href="#0-1-Python简介" class="headerlink" title="0.1 Python简介"></a>0.1 Python简介</h4><p>Python时当前比较流行的<strong>编程语言</strong>。具有简单易学、免费开源、应用领域广泛等特点。</p>
<h4 id="0-2-计算机的组成"><a href="#0-2-计算机的组成" class="headerlink" title="0.2 计算机的组成"></a>0.2 计算机的组成</h4><p><img src="https://pic.imgdb.cn/item/625b8d63239250f7c550004f.jpg"></p>
<p>本节课重点关注<strong>CPU</strong>和<strong>内存</strong>的作用。其中内存是临时存储数据的地方，由于内存的速度远远高于硬盘，所以CPU处理的数据都是从内存调取的。</p>
<h4 id="0-3-Python学习路径"><a href="#0-3-Python学习路径" class="headerlink" title="0.3 Python学习路径"></a>0.3 Python学习路径</h4><p><img src="https://pic.imgdb.cn/item/625b8e94239250f7c551cf9a.jpg"></p>
<h3 id="第一章-PYTHON入门基础"><a href="#第一章-PYTHON入门基础" class="headerlink" title="第一章 PYTHON入门基础"></a>第一章 PYTHON入门基础</h3><h4 id="1-1-解释器的作用和分类"><a href="#1-1-解释器的作用和分类" class="headerlink" title="1.1 解释器的作用和分类"></a>1.1 解释器的作用和分类</h4><h5 id="一-解释器的作用"><a href="#一-解释器的作用" class="headerlink" title="(一) 解释器的作用"></a>(一) 解释器的作用</h5><p>Python解释器的作用：<font color="red"><strong>运行文件</strong></font>。(形象化类比人类翻译官，解释器就是将python语句“翻译为”计算机能读懂的机器码)。</p>
<h5 id="二-解释器的种类"><a href="#二-解释器的种类" class="headerlink" title="(二) 解释器的种类"></a>(二) 解释器的种类</h5><ul>
<li>CPython：C语言开发的解释器【官方】，应用广泛的解释器；</li>
<li>IPython：基于CPython的一种交互式解释器；</li>
<li>其他解释器<ul>
<li>PyPy：基于Python语⾔言开发的解释器器；</li>
<li>Jython：运行在Java平台的解释器器，直接把Python代码编译成Java字节码执行；</li>
<li>IronPython：运行在微软.Net平台上的Python解释器器，可以直接把Python代码编译<br>成.Net的字节码。</li>
</ul>
</li>
</ul>
<h4 id="1-2-下载Python解释器"><a href="#1-2-下载Python解释器" class="headerlink" title="1.2 下载Python解释器"></a>1.2 下载Python解释器</h4><p>安装了andaconda好像就不用单独安装解释器了。</p>
<h4 id="1-3-PyCharm的应用"><a href="#1-3-PyCharm的应用" class="headerlink" title="1.3 PyCharm的应用"></a>1.3 PyCharm的应用</h4><h5 id="一-PyCharm简介"><a href="#一-PyCharm简介" class="headerlink" title="(一) PyCharm简介"></a>(一) PyCharm简介</h5><p>PyCharm是一种<font color="blue">Python <strong>IDE（集成开发环境）</strong></font>，带有一整套可以帮助用户在使用Python语⾔言开发时提高其效率的工具，内部集成的功能有Project管理，智能提示，语法高亮，代码跳转，调试代码，解释代码(解释器)，框架和库等等。</p>
<h5 id="二-PyCharm设置"><a href="#二-PyCharm设置" class="headerlink" title="(二) PyCharm设置"></a>(二) PyCharm设置</h5><p>(1) 界面设置</p>
<p>(2) 设置解释器</p>
<p>(3) 项目管理</p>
<h4 id="1-4-注释"><a href="#1-4-注释" class="headerlink" title="1.4 注释"></a>1.4 注释</h4><p>注释分为两类：单行注释和多行注释</p>
<ul>
<li>单行注释(快捷键：ctrl+/)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释内容</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多行注释</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	多行注释1</span></span><br><span class="line"><span class="string">	多行注释2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	多行1</span></span><br><span class="line"><span class="string">	多行2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-5-变量"><a href="#1-5-变量" class="headerlink" title="1.5 变量"></a>1.5 变量</h4><h5 id="一-定义变量"><a href="#一-定义变量" class="headerlink" title="(一) 定义变量"></a>(一) 定义变量</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量名 = 值</span><br></pre></td></tr></table></figure>
<p>要注意，变量名的命名要符合<strong>标识符命名规则</strong>：</p>
<ul>
<li>由数字、字母、下划线组成</li>
<li>不能数字开头</li>
<li>不能使用内置关键字</li>
<li><strong>严格区分大小写</strong></li>
</ul>
<h5 id="二-命名习惯"><a href="#二-命名习惯" class="headerlink" title="(二) 命名习惯"></a>(二) 命名习惯</h5><ul>
<li>见名知义。</li>
<li>大驼峰：即每个单词⾸首字⺟母都⼤大写，例如： MyName 。</li>
<li>小驼峰：第二个（含）以后的单词首字母大写，例如： myName 。</li>
<li>下划线：例如： my_name 。</li>
</ul>
<h4 id="1-6-Bug问题"><a href="#1-6-Bug问题" class="headerlink" title="1.6 Bug问题"></a>1.6 Bug问题</h4><p>所谓bug，就是程序中的错误。如果程序有错误，需要程序员排查问题，纠正错误。</p>
<h5 id="一-Debug工具——调试"><a href="#一-Debug工具——调试" class="headerlink" title="(一) Debug工具——调试"></a>(一) Debug工具——调试</h5><p>(1) 步骤1：打断点</p>
<p>单击目标代码的行号右侧空白位置。</p>
<p>(2) 步骤2：调试</p>
<p>打成功断点后，在文件内部任意位置 — 右键 — Debug’文件名’ — 即可调出Debug工具⾯面板 — 单击Step<br>Over/F8，即可按步执行行代码。</p>
<ul>
<li>Debugger</li>
</ul>
<p>​        显示变量量和变量量的细节</p>
<ul>
<li>Console</li>
</ul>
<p>​        输出内容</p>
<h4 id="1-7-数据类型"><a href="#1-7-数据类型" class="headerlink" title="1.7 数据类型"></a>1.7 数据类型</h4><p><img src="https://pic.imgdb.cn/item/625bd2d4239250f7c5c6de00.jpg"></p>
<p>产看变量的类型使用<code>type</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &lt;class &#x27;int&#x27;&gt; -- 整型</span></span><br><span class="line">b = <span class="number">1.1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b)) <span class="comment"># &lt;class &#x27;float&#x27;&gt; -- 浮点型</span></span><br><span class="line">c = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c)) <span class="comment"># &lt;class &#x27;bool&#x27;&gt; -- 布尔型</span></span><br><span class="line">d = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(d)) <span class="comment"># &lt;class &#x27;str&#x27;&gt; -- 字符串</span></span><br><span class="line">e = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(e)) <span class="comment"># &lt;class &#x27;list&#x27;&gt; -- 列表</span></span><br><span class="line">f = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(f)) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt; -- 元组</span></span><br><span class="line">h = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(h)) <span class="comment"># &lt;class &#x27;set&#x27;&gt; -- 集合</span></span><br><span class="line">g = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;TOM&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(g)) <span class="comment"># &lt;class &#x27;dict&#x27;&gt; -- 字典</span></span><br></pre></td></tr></table></figure>
<h4 id="1-8-输出"><a href="#1-8-输出" class="headerlink" title="1.8 输出"></a>1.8 输出</h4><h5 id="一-认识格式化符号"><a href="#一-认识格式化符号" class="headerlink" title="(一) 认识格式化符号"></a>(一) 认识格式化符号</h5><ul>
<li>格式化输出<ul>
<li>格式化符号</li>
<li><strong>f-字符串串</strong></li>
</ul>
</li>
<li>print的结束符</li>
</ul>
<h5 id="二-格式化输出"><a href="#二-格式化输出" class="headerlink" title="(二) 格式化输出"></a>(二) 格式化输出</h5><p>(1) 常见格式化符号</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">格式符号</th>
<th style="text-align:center">转换</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:center">字符串</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">有符号的十进制整数</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">浮点数</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>技巧：</p>
<p>%06d，表示输出的整数显示位数，不足以0补全，超出当前位数则原样输出；<br>%.2f，表示小数点后显示的小数位数。</p>
</blockquote>
<p>(2) 格式化输出示例</p>
<p>格式化字符串除了%s，还可以写为<code>f&#39;&#123;表达式&#125;&#39;</code>(是Python3.6中新增的格式化方法，该方法更简单易读。)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line">name = <span class="string">&#x27;TOM&#x27;</span></span><br><span class="line">weight = <span class="number">75.5</span></span><br><span class="line">student_id = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的名字是%s&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的学号是0001</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的学号是%04d&#x27;</span> % student_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的体重是75.50公斤</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的体重是%.2f公斤&#x27;</span> % weight)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM，今年年18岁了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的名字是%s，今年%d岁了&#x27;</span> % (name, age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM，明年年19岁了了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我的名字是%s，明年%d岁了&#x27;</span> % (name, age + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我的名字是TOM，明年年19岁了了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;我的名字是<span class="subst">&#123;name&#125;</span>, 明年<span class="subst">&#123;age + <span class="number">1</span>&#125;</span>岁了&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意，其中%s的功能相对更强，可以格式化输出字符串、整数、浮点数。</strong></p>
</blockquote>
<h5 id="三-转义字符"><a href="#三-转义字符" class="headerlink" title="(三)  转义字符"></a>(三)  转义字符</h5><ul>
<li><code>\n</code>：换行</li>
<li><code>\t</code>：制表位，一个tab键(4个空格距离)</li>
</ul>
<h5 id="四-结束符"><a href="#四-结束符" class="headerlink" title="(四) 结束符"></a>(四) 结束符</h5><p>想⼀想，为什么两个print会换行输出？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;输出的内容&#x27;</span>, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># 修改结束符号为...</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;输出的内容&#x27;</span>, end=<span class="string">&quot;...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在Python中，print()， <strong>默认自带end=”\n” 这个换行行结束符</strong>，所以导致每两个print 直接会换⾏行行<br>展示，用户可以按需求更改结束符。</p>
<h4 id="1-9-输入"><a href="#1-9-输入" class="headerlink" title="1.9 输入"></a>1.9 输入</h4><h5 id="一-输入语法"><a href="#一-输入语法" class="headerlink" title="(一) 输入语法"></a>(一) 输入语法</h5><p>在Python中，程序接收用户输入的数据的功能即是输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量 = <span class="built_in">input</span>(<span class="string">&quot;提示信息&quot;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="二-输入的特点"><a href="#二-输入的特点" class="headerlink" title="(二) 输入的特点"></a>(二) 输入的特点</h5><ul>
<li>当程序执行到input ，等待用户输入，输入完成之后才继续向下执行；</li>
<li>在Python中， input 接收用户输入后，一般存储到变量，方便使用；</li>
<li>在Python中， input 会把接收到的任意用户输入的数据都当做字符串处理。</li>
</ul>
<h5 id="三-演示输入"><a href="#三-演示输入" class="headerlink" title="(三) 演示输入"></a>(三) 演示输入</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">password = <span class="built_in">input</span>(<span class="string">&#x27;请输⼊入您的密码：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;您输⼊入的密码是<span class="subst">&#123;password&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(password))</span><br></pre></td></tr></table></figure>
<h4 id="1-10-数据类型转换"><a href="#1-10-数据类型转换" class="headerlink" title="1.10 数据类型转换"></a>1.10 数据类型转换</h4><h5 id="一-转换数据类型的作用"><a href="#一-转换数据类型的作用" class="headerlink" title="(一) 转换数据类型的作用"></a>(一) 转换数据类型的作用</h5><p>问：input()接收⽤用户输入的数据都是字符串类型，如果用户输入1，想得到整型该如何操作？<br>答：转换数据类型即可，即将字符串类型转换成整型。</p>
<h5 id="二-转换数据类型的函数"><a href="#二-转换数据类型的函数" class="headerlink" title="(二) 转换数据类型的函数"></a>(二) 转换数据类型的函数</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int(x[,base])</td>
<td style="text-align:center">将x转换为一个整数</td>
</tr>
<tr>
<td style="text-align:center">float(x)</td>
<td style="text-align:center">将x转换为一个浮点数</td>
</tr>
<tr>
<td style="text-align:center">str(x)</td>
<td style="text-align:center">将对象 x 转换为字符串</td>
</tr>
<tr>
<td style="text-align:center">tuple(s)</td>
<td style="text-align:center">将序列列 s 转换为一个元组</td>
</tr>
<tr>
<td style="text-align:center">list(s)</td>
<td style="text-align:center">将序列列 s 转换为一个列表</td>
</tr>
<tr>
<td style="text-align:center">eval(str)</td>
<td style="text-align:center">用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td style="text-align:center">complex(real [,imag ])</td>
<td style="text-align:center">创建一个复数，real为实部，imag为虚部</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<h4 id="1-11-运算符的分类"><a href="#1-11-运算符的分类" class="headerlink" title="1.11 运算符的分类"></a>1.11 运算符的分类</h4><ul>
<li>算数运算符</li>
<li>赋值运算符</li>
<li>复合赋值运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
</ul>
<h5 id="一-算术运算符"><a href="#一-算术运算符" class="headerlink" title="(一) 算术运算符"></a>(一) 算术运算符</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">//</td>
<td style="text-align:center">整除</td>
<td style="text-align:center">9 // 4 输出结果为 2</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">取余</td>
<td style="text-align:center">9 % 4 输出结果为 1</td>
</tr>
<tr>
<td style="text-align:center">**</td>
<td style="text-align:center">指数</td>
<td style="text-align:center">2 <em>* 4 输出结果为 16，即 2 </em> 2 <em> 2 </em> 2</td>
</tr>
<tr>
<td style="text-align:center">()</td>
<td style="text-align:center">括号</td>
<td style="text-align:center">小括号⽤用来提高运算优先级，即 (1 + 2) * 3 输出结果为 9</td>
</tr>
</tbody>
</table>
</div>
<h5 id="二-赋值运算符"><a href="#二-赋值运算符" class="headerlink" title="(二) 赋值运算符"></a>(二) 赋值运算符</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">赋值</td>
<td style="text-align:center">将= 右侧的结果赋值给等号左侧的变量</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多变量赋值</span></span><br><span class="line">num1, float1, str1 = <span class="number">10</span>, <span class="number">0.5</span>, <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(num1)</span><br><span class="line"><span class="built_in">print</span>(float1)</span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多变量量赋相同值</span></span><br><span class="line">a = b = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<h5 id="三-复合赋值运算符"><a href="#三-复合赋值运算符" class="headerlink" title="(三) 复合赋值运算符"></a>(三) 复合赋值运算符</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+=</td>
<td style="text-align:center">加法赋值运算</td>
<td style="text-align:center">c += a 等价于 c = c + a</td>
</tr>
<tr>
<td style="text-align:center">-=</td>
<td style="text-align:center">减法赋值运算</td>
<td style="text-align:center">c -= a 等价于 c = c - a</td>
</tr>
<tr>
<td style="text-align:center">*=</td>
<td style="text-align:center">乘法赋值运算</td>
<td style="text-align:center">c <em>= a 等价于 c = c </em> a</td>
</tr>
<tr>
<td style="text-align:center">/=</td>
<td style="text-align:center">除法赋值运算</td>
<td style="text-align:center">c /= a 等价于 c = c / a</td>
</tr>
<tr>
<td style="text-align:center">//=</td>
<td style="text-align:center">整除赋值运算</td>
<td style="text-align:center">c //= a 等价于 c = c // a</td>
</tr>
<tr>
<td style="text-align:center">%=</td>
<td style="text-align:center">取余赋值运算</td>
<td style="text-align:center">c %= a 等价于 c = c % a</td>
</tr>
<tr>
<td style="text-align:center">**=</td>
<td style="text-align:center">指数赋值运算</td>
</tr>
</tbody>
</table>
</div>
<h5 id="四-关系-比较运算符"><a href="#四-关系-比较运算符" class="headerlink" title="(四) 关系/比较运算符"></a>(四) 关系/比较运算符</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">相等</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">不相等</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">>=</td>
<td style="text-align:center">大于等于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
</tr>
</tbody>
</table>
</div>
<h5 id="五-逻辑运算符"><a href="#五-逻辑运算符" class="headerlink" title="(五) 逻辑运算符"></a>(五) 逻辑运算符</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">逻辑表达式</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">and</td>
<td style="text-align:center">x and y</td>
<td style="text-align:center">布尔”与”：若x为False，x and y返回False，否则返回y值</td>
<td style="text-align:center">True and False，返回False</td>
</tr>
<tr>
<td style="text-align:center">or</td>
<td style="text-align:center">x or y</td>
<td style="text-align:center">布尔”或”：若x是True，返回 True，否则返回y的值</td>
<td style="text-align:center">False or True，返回True</td>
</tr>
<tr>
<td style="text-align:center">not</td>
<td style="text-align:center">not x</td>
<td style="text-align:center">布尔”非”：若x为True，返回False 。若x为False，返回 True</td>
<td style="text-align:center">not True 返回 False</td>
</tr>
</tbody>
</table>
</div>
<h5 id="六-小结"><a href="#六-小结" class="headerlink" title="(六) 小结"></a>(六) 小结</h5><ul>
<li>算数运算的优先级<ul>
<li>混合运算优先级顺序： () 高于 <em>* 高于 </em> / // % 高于 + -</li>
</ul>
</li>
</ul>
<h3 id="第二章-流程控制"><a href="#第二章-流程控制" class="headerlink" title="第二章 流程控制"></a>第二章 流程控制</h3><h4 id="2-1-条件语句"><a href="#2-1-条件语句" class="headerlink" title="2.1 条件语句"></a>2.1 条件语句</h4><p>条件语句，即条件成立执行某些代码，条件不成立则不执行这些代码。</p>
<h5 id="一-if语句语法"><a href="#一-if语句语法" class="headerlink" title="(一) if语句语法"></a>(一) if语句语法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">	条件成立执行的代码<span class="number">1</span></span><br><span class="line">	条件成立执行的代码<span class="number">2</span></span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<h5 id="二-if-else语句语法"><a href="#二-if-else语句语法" class="headerlink" title="(二) if-else语句语法"></a>(二) if-else语句语法</h5><p>作用：条件成立执行if下方的代码; 条件不成立执行else下方的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">	条件成立执行的代码<span class="number">1</span></span><br><span class="line">	条件成立执行的代码<span class="number">2</span></span><br><span class="line">	......</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	条件不成立执行的代码<span class="number">1</span></span><br><span class="line">	条件不成立执行的代码<span class="number">2</span></span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<h5 id="三-多重判断：if-elif-else语句语法"><a href="#三-多重判断：if-elif-else语句语法" class="headerlink" title="(三) 多重判断：if-elif-else语句语法"></a>(三) 多重判断：if-elif-else语句语法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">	条件<span class="number">1</span>成立执行的代码<span class="number">1</span></span><br><span class="line">	条件<span class="number">1</span>成立执行的代码<span class="number">2</span></span><br><span class="line">	......</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>：</span><br><span class="line">	条件<span class="number">2</span>成立执行的代码<span class="number">1</span></span><br><span class="line">	条件<span class="number">2</span>成立执行的代码<span class="number">2</span></span><br><span class="line">	......</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">3</span>:</span><br><span class="line">    ......</span><br><span class="line">......</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	以上条件都不成立执行的代码</span><br></pre></td></tr></table></figure>
<h5 id="四-if嵌套语法"><a href="#四-if嵌套语法" class="headerlink" title="(四) if嵌套语法"></a>(四) if嵌套语法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>：</span><br><span class="line">	条件<span class="number">1</span>成立执行的代码</span><br><span class="line">	条件<span class="number">1</span>成立执行的代码</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> 条件<span class="number">2</span>：</span><br><span class="line">		条件<span class="number">2</span>成立执行的代码</span><br><span class="line">		条件<span class="number">2</span>成立执行的代码</span><br></pre></td></tr></table></figure>
<h5 id="五-示例——猜拳游戏"><a href="#五-示例——猜拳游戏" class="headerlink" title="(五) 示例——猜拳游戏"></a>(五) 示例——猜拳游戏</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">提示：0-石头，1-剪刀，2-布</span></span><br><span class="line"><span class="string">1. 出拳</span></span><br><span class="line"><span class="string">玩家输入出拳</span></span><br><span class="line"><span class="string">电脑随机出拳</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. 判断输赢</span></span><br><span class="line"><span class="string">玩家获胜</span></span><br><span class="line"><span class="string">平局</span></span><br><span class="line"><span class="string">电脑获胜</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入random模块</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment"># 计算电脑出拳的随机数字</span></span><br><span class="line">computer = random.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(computer)</span><br><span class="line">player = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请出拳：0-石头，1-剪刀，2-布：&#x27;</span>))</span><br><span class="line"><span class="comment"># 玩家胜利 p0:c1 或 p1:c2 或 p2:c0</span></span><br><span class="line"><span class="keyword">if</span> ((player == <span class="number">0</span>) <span class="keyword">and</span> (computer == <span class="number">1</span>) <span class="keyword">or</span> ((player == <span class="number">1</span>) <span class="keyword">and</span> (computer == <span class="number">2</span>) <span class="keyword">or</span></span><br><span class="line">((player == <span class="number">2</span>) <span class="keyword">and</span> (computer == <span class="number">0</span>)):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;玩家获胜&#x27;</span>)</span><br><span class="line"><span class="comment"># 平局：玩家 == 电脑</span></span><br><span class="line"><span class="keyword">elif</span> player == computer:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;平局&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;电脑获胜&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="六-三元运算符"><a href="#六-三元运算符" class="headerlink" title="(六) 三元运算符"></a>(六) 三元运算符</h5><p>三元运算符也叫三目运算符或三元表达式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">条件成立执行的表达式 <span class="keyword">if</span> 条件 <span class="keyword">else</span> 条件不成立执行的表达式</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出c=b=2</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-循环语句"><a href="#2-2-循环语句" class="headerlink" title="2.2 循环语句"></a>2.2 循环语句</h4><h5 id="一-循环语句的分类"><a href="#一-循环语句的分类" class="headerlink" title="(一) 循环语句的分类"></a>(一) 循环语句的分类</h5><p>在Python中，循环分为while和for两种，最终实现效果相同。</p>
<h5 id="二-while循环的语法"><a href="#二-while循环的语法" class="headerlink" title="(二) while循环的语法"></a>(二) while循环的语法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">	条件成立重复执行的代码<span class="number">1</span></span><br><span class="line">	条件成立重复执行的代码<span class="number">2</span></span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<p>示例：计算1-100累加和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">	result += i</span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line"><span class="comment"># 输出5050</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<h5 id="三-while循环嵌套"><a href="#三-while循环嵌套" class="headerlink" title="(三) while循环嵌套"></a>(三) while循环嵌套</h5><p>略。。。</p>
<h5 id="四-for循环的语法"><a href="#四-for循环的语法" class="headerlink" title="(四) for循环的语法"></a>(四) for循环的语法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 序列:</span><br><span class="line">	重复执行的代码<span class="number">1</span></span><br><span class="line">	重复执行的代码<span class="number">2</span></span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<h5 id="五-循环与else"><a href="#五-循环与else" class="headerlink" title="(五) 循环与else"></a>(五) 循环与else</h5><p><strong>循环和else配合使用，else下方缩进的代码指的是当循环正常结束之后要执行的代码。</strong></p>
<font color="red">所谓else指的是循环正常结束之后要执行的代码，即如果是break终止循环的情况，else下方缩进的代码将不执行，但是对于continue语句则else正常执行。</font>

<p>(1) while…else</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">	条件成立重复执行的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	循环正常结束之后要执行的代码</span><br></pre></td></tr></table></figure>
<p>(2) for…else</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量量 <span class="keyword">in</span> 序列列:</span><br><span class="line">	重复执行的代码</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	循环正常结束之后要执行的代码</span><br></pre></td></tr></table></figure>
<h5 id="六-退出循环的两种方式——break、continue"><a href="#六-退出循环的两种方式——break、continue" class="headerlink" title="(六) 退出循环的两种方式——break、continue"></a>(六) 退出循环的两种方式——break、continue</h5><p>break和continue是循环中满足一定条件退出循环的两种不同方式。</p>
<ul>
<li>break控制循环流程，即终止此循环，跳出循环</li>
<li>continue控制循环流程，即退出当前一次循环继而执行下一次循环，不跳出循环</li>
</ul>
<h3 id="第三章-数据类型"><a href="#第三章-数据类型" class="headerlink" title="第三章 数据类型"></a>第三章 数据类型</h3><p><a href="https://www.cnblogs.com/chy18883701161/p/11291126.html">Python  序列、列表（List）、元组（Tuple）</a>：序列是Python中最基本的数据结构，主要包括有：<strong>字符串、列表、元组</strong>。序列，顾名思义，是有序的，序列都有索引，都能进行索引、切片（截取）、加（连接）、乘（倍增）、检查成员的操作。因为序列有序，可通过位置来区分元素，所以序列中可含有相同的元素。</p>
<h4 id="3-1-字符串"><a href="#3-1-字符串" class="headerlink" title="3.1 字符串"></a>3.1 字符串</h4><h5 id="一-认识字符串"><a href="#一-认识字符串" class="headerlink" title="(一) 认识字符串"></a>(一) 认识字符串</h5><p>字符串是 Python 中最常用的数据类型。我们一般使用单/双/三引号来创建字符串。创建字符串很简单，只要为变量分配一个值即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name1 = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">name2 = <span class="string">&quot;Rose&quot;</span></span><br><span class="line">name3 = <span class="string">&#x27;&#x27;&#x27; Tom &#x27;&#x27;&#x27;</span></span><br><span class="line">name4 = <span class="string">&quot;&quot;&quot; Rose &quot;&quot;&quot;</span></span><br><span class="line">a = <span class="string">&#x27;&#x27;&#x27; i am Tom,</span></span><br><span class="line"><span class="string">		nice to meet you! &#x27;&#x27;&#x27;</span></span><br><span class="line">b = <span class="string">&quot;&quot;&quot; i am Rose,</span></span><br><span class="line"><span class="string">		nice to meet you! &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>两个注意事项：</p>
<ul>
<li>注意1：三引号形式的字符串支持换行</li>
<li>注意2：用单引号创建一个带有单引号的字符串I’m Tom需要使用反斜杠进行转义，e.g.<code>&#39;I\&#39;m Tom&#39;</code>，但是用双引号就不需要，e.g.<code>&quot;I&#39;m Tom&quot;</code></li>
</ul>
<h5 id="二-字符串的下标索引"><a href="#二-字符串的下标索引" class="headerlink" title="(二) 字符串的下标索引"></a>(二) 字符串的下标索引</h5><p>“下标” 又叫“索引” ，就是编号。比如火车座位号，座位号的作用：按照编号快速找到对应的座位。同<br>理，下标的作用即是通过下标快速找到对应的数据。</p>
<ul>
<li><strong>python中对字符串的下标索引使用<code>[]</code>完成</strong></li>
<li><strong>字符串下标从0开始</strong></li>
<li><strong>可以使用负号索引</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;abcdef&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">1</span>])  <span class="comment"># b</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">0</span>])  <span class="comment"># a</span></span><br><span class="line"><span class="built_in">print</span>(name[-<span class="number">1</span>])  <span class="comment"># f</span></span><br></pre></td></tr></table></figure>
<h5 id="三-字符串切片操作"><a href="#三-字符串切片操作" class="headerlink" title="(三) 字符串切片操作"></a>(三) 字符串切片操作</h5><p>切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。</p>
<p><strong>(1) 语法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">序列[开始位置下标:结束位置下标:步长]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<ol>
<li>不包含结束位置下标对应的数据（即<strong>左闭右开区间</strong>）， 正负整数均可；</li>
<li>步长是选取间隔，正负整数均可，默认步长为1。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">2</span>:<span class="number">5</span>:<span class="number">1</span>]) <span class="comment"># cde</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment"># cde</span></span><br><span class="line"><span class="built_in">print</span>(name[:-<span class="number">1</span>]) <span class="comment"># abcdef, 负1表示倒数第⼀一个数据</span></span><br><span class="line"><span class="built_in">print</span>(name[-<span class="number">4</span>:-<span class="number">1</span>]) <span class="comment"># def</span></span><br></pre></td></tr></table></figure>
<h5 id="四-字符串查找操作"><a href="#四-字符串查找操作" class="headerlink" title="(四) 字符串查找操作"></a>(四) 字符串查找操作</h5><p>所谓字符串查找方法即是查找子串在字符串中的位置或出现的次数。</p>
<p><strong>(1) find函数</strong></p>
<p>find()：检测某个子串是否包含在这个字符串中，如果在返回这个子串开始的位置下标，否则返回-1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.find(子串, 开始位置下标, 结束位置下标)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr.find(<span class="string">&#x27;and&#x27;</span>)) <span class="comment"># 12</span></span><br><span class="line"><span class="built_in">print</span>(mystr.find(<span class="string">&#x27;and&#x27;</span>, <span class="number">15</span>, <span class="number">30</span>)) <span class="comment"># 23</span></span><br><span class="line"><span class="built_in">print</span>(mystr.find(<span class="string">&#x27;ands&#x27;</span>)) <span class="comment"># -1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。</p>
</blockquote>
<p><strong>(2) index函数</strong></p>
<p>index()：检测某个子串是否包含在这个字符串中，如果在返回这个子串开始的位置下标，否则报异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.index(子串, 开始位置下标, 结束位置下标)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr.index(<span class="string">&#x27;and&#x27;</span>)) <span class="comment"># 12</span></span><br><span class="line"><span class="built_in">print</span>(mystr.index(<span class="string">&#x27;and&#x27;</span>, <span class="number">15</span>, <span class="number">30</span>)) <span class="comment"># 23</span></span><br><span class="line"><span class="built_in">print</span>(mystr.index(<span class="string">&#x27;ands&#x27;</span>)) <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。</p>
</blockquote>
<p><strong>(3) rfind、rindex函数</strong></p>
<p>rfind()： 和find()功能相同，但查找方向为右侧开始。<br>rindex()：和index()功能相同，但查找方向为右侧开始。</p>
<p><strong>(4) count函数</strong></p>
<p>count()：返回某个子串在字符串中出现的次数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.count(子串, 开始位置下标, 结束位置下标)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr.count(<span class="string">&#x27;and&#x27;</span>)) <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(mystr.count(<span class="string">&#x27;ands&#x27;</span>)) <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(mystr.count(<span class="string">&#x27;and&#x27;</span>, <span class="number">0</span>, <span class="number">20</span>)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：开始和结束位置下标可以省略，表示在整个字符串序列中查找。</p>
</blockquote>
<h5 id="五-字符串修改操作"><a href="#五-字符串修改操作" class="headerlink" title="(五) 字符串修改操作"></a>(五) 字符串修改操作</h5><p>所谓修改字符串，指的就是通过函数的形式修改字符串中的数据。</p>
<p><strong>(1) replace函数</strong></p>
<p>replace()：替换字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.replace(旧子串, 新子串, 替换次数)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：替换次数如果查出子串出现次数，则替换次数为该子串出现次数。</p>
</blockquote>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr.replace(<span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;he&#x27;</span>))</span><br><span class="line"><span class="comment"># 结果：hello world he itcast he itheima he Python</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr.replace(<span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;he&#x27;</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 结果：hello world he itcast he itheima he Python</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr)</span><br><span class="line"><span class="comment"># 结果：hello world and itcast and itheima and Python</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：数据按照是否能直接修改分为<strong>可变类型</strong>和<strong>不可变类型</strong>两种。字符串类型的数据修改的时候不能改变原有字符串，属于不能直接修改数据的类型即是不可变类型。</p>
</blockquote>
<p><strong>(2) split函数</strong></p>
<p>split()：按照指定字符分割字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.split(分割字符, num)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：num表示的是分割字符出现的次数，即将来返回数据个数为num+1个。</p>
</blockquote>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr.split(<span class="string">&#x27;and&#x27;</span>))</span><br><span class="line"><span class="comment"># 结果：[&#x27;hello world &#x27;, &#x27; itcast &#x27;, &#x27; itheima &#x27;, &#x27; Python&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr.split(<span class="string">&#x27;and&#x27;</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 结果：[&#x27;hello world &#x27;, &#x27; itcast &#x27;, &#x27; itheima and Python&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr.split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="comment"># 结果：[&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;and&#x27;, &#x27;itcast&#x27;, &#x27;and&#x27;, &#x27;itheima&#x27;, &#x27;and&#x27;, &#x27;Python&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr.split(<span class="string">&#x27; &#x27;</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 结果：[&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;and itcast and itheima and Python&#x27;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果分割字符是原有字符串中的子串，分割后则丢失该子串。</p>
</blockquote>
<p><strong>(3) join函数</strong></p>
<p>join()：用一个字符或子串合并字符串，即是将多个字符串合并为一个新的字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符或子串.join(多字符串组成的序列)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：序列包括 列表、元组、集合等，但是序列中的元素必须是字符串</p>
</blockquote>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;chuan&#x27;</span>, <span class="string">&#x27;zhi&#x27;</span>, <span class="string">&#x27;bo&#x27;</span>, <span class="string">&#x27;ke&#x27;</span>]</span><br><span class="line">t1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;ddd&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;_&#x27;</span>.join(list1))</span><br><span class="line"><span class="comment"># 结果：chuan_zhi_bo_ke</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;...&#x27;</span>.join(t1))</span><br><span class="line"><span class="comment"># 结果：aa...b...cc...ddd</span></span><br></pre></td></tr></table></figure>
<p><strong>(4) 其他常用函数</strong></p>
<p>capitalize()：将字符串第一个字符转换成大写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.capitalize()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：capitalize()函数转换后，只字符串串第一个字符大写，其他的字符全都小写。</p>
</blockquote>
<p>title()：将字符串每个单词首字母转换成大写。</p>
<p>lower()：将字符串中大写转小写。</p>
<p>upper()：将字符串中小写转大写。</p>
<p>lstrip()：删除字符串左侧空白字符。</p>
<p>rstrip()：删除字符串右侧空白字符。</p>
<p>strip()：删除字符串两侧空白字符。</p>
<p><strong>(5) ljust函数</strong></p>
<p>ljust()：返回一个原字符串左对齐，并使用指定字符(默认空格)填充至对应长度的新字符串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.ljust(长度, 填充字符)</span><br></pre></td></tr></table></figure>
<p>rjust()：返回一个原字符串右对齐,并使用指定字符(默认空格)填充至对应长度的新字符串，语法和ljust()相同。</p>
<p>center()：返回一个原字符串居中对齐,并使用指定字符(默认空格)填充至对应长度的新字符串，语法和ljust()相同。</p>
<h5 id="六-字符串判断操作"><a href="#六-字符串判断操作" class="headerlink" title="(六) 字符串判断操作"></a>(六) 字符串判断操作</h5><p>所谓判断即是判断真假，返回的结果是布尔型数据类型：True 或 False。</p>
<p><strong>(1) startswith函数</strong></p>
<p>startswith()：检查字符串是否是以指定子串开头，是则返回True，否则返回False。如果设置开始和结束位置下标，则在指定范围内检查。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串序列.startswith(子串, 开始位置下标, 结束位置下标)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">&quot;hello world and itcast and itheima and Python &quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr.startswith(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line"><span class="comment"># 结果：True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr.startswith(<span class="string">&#x27;hello&#x27;</span>, <span class="number">5</span>, <span class="number">20</span>))</span><br><span class="line"><span class="comment"># 结果False</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) endswith函数</strong></p>
<p>endswith()：检查字符串是否是以指定子串结尾，是则返回True，否则返回False。如果设置开始和结束位置下标，则在指定范围内检查。</p>
<p>语法与startwith()相同</p>
<p><strong>(3) isalpha函数</strong></p>
<p>isalpha()：如果字符串中的所有字符都是字母，则返回True，否则返回False。此函数用于检查参数是否包含任何字母字符 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串.isalpha()</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">mystr2 = <span class="string">&#x27;hello12345&#x27;</span></span><br><span class="line">mystr3 = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr1.isalpha())  <span class="comment"># 结果：True</span></span><br><span class="line"><span class="built_in">print</span>(mystr2.isalpha())  <span class="comment"># 结果：False</span></span><br><span class="line"><span class="built_in">print</span>(mystr3.isalpha())  <span class="comment"># 结果：False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<strong>空格不算字母</strong></p>
</blockquote>
<p><strong>(4) isdigit函数</strong></p>
<p>isdigit()：如果字符串只包含数字则返回True，否则返回False。</p>
<p>用法与isalpha()相同。</p>
<p><strong>(5) isalnum函数</strong></p>
<p>isalnum()：如果字符串至少有一个字符并且所有字符都是字母或数字则返回True，否则返回False。常用于检测字符串是否由字母和数字组成。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字符串.isalnum()</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr1 = <span class="string">&#x27;aaa12345&#x27;</span></span><br><span class="line">mystr2 = <span class="string">&#x27;12345-&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mystr1.isalnum())  <span class="comment"># 结果：True</span></span><br><span class="line"><span class="built_in">print</span>(mystr2.isalnum())  <span class="comment"># 结果：False</span></span><br></pre></td></tr></table></figure>
<p><strong>(6) isspace函数</strong></p>
<p>isspace()：如果字符串中只包含空白(空格)，则返回True，否则返回False。</p>
<h4 id="3-2-列表-或list"><a href="#3-2-列表-或list" class="headerlink" title="3.2 列表[]或list()"></a>3.2 列表<code>[]</code>或<code>list()</code></h4><h5 id="一-列表的应用常景"><a href="#一-列表的应用常景" class="headerlink" title="(一) 列表的应用常景"></a>(一) 列表的应用常景</h5><p>思考：有一个人的姓名(TOM)怎么书写存储程序？<br>答：变量。<br>思考：如果一个班级100位学生，每个人的姓名都要存储，应该如何书写程序？声明100个变量吗？<br>答：列表即可， 列表一次性可以存储多个数据。</p>
<h5 id="二-列表的格式"><a href="#二-列表的格式" class="headerlink" title="(二) 列表的格式"></a>(二) 列表的格式</h5><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[数据<span class="number">1</span>, 数据<span class="number">2</span>, 数据<span class="number">3</span>, 数据<span class="number">4</span>, ......]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>列表可以一次性存储多个数据，且可以为<strong>不同数据类型</strong>。</p>
<p>列表中的元素可以<strong>重复</strong></p>
<p>列表里面的元素可以是列表</p>
</blockquote>
<h5 id="三-列表查找操作"><a href="#三-列表查找操作" class="headerlink" title="(三) 列表查找操作"></a>(三) 列表查找操作</h5><p><strong>(1) 下标查找法</strong></p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_list[<span class="number">0</span>]) <span class="comment"># Tom</span></span><br><span class="line"><span class="built_in">print</span>(name_list[<span class="number">1</span>]) <span class="comment"># Lily</span></span><br><span class="line"><span class="built_in">print</span>(name_list[<span class="number">2</span>]) <span class="comment"># Rose</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 函数查找法</strong></p>
<ul>
<li>index()：返回指定数据所在位置的下标 。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.index(数据, 开始位置下标, 结束位置下标)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list.index(<span class="string">&#x27;Lily&#x27;</span>, <span class="number">0</span>, <span class="number">2</span>)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果查找的数据不存在则<strong>报错</strong>。</p>
</blockquote>
<ul>
<li>count()：统计指定数据在当前列列表中出现的次数。</li>
</ul>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list.count(<span class="string">&#x27;Lily&#x27;</span>)) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>len()：访问列表长度，即列表中数据的个数。</li>
</ul>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(name_list)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<h5 id="四-列表判断操作"><a href="#四-列表判断操作" class="headerlink" title="(四) 列表判断操作"></a>(四) 列表判断操作</h5><ul>
<li>in：判断指定数据在某个列表序列，如果在返回True，否则返回False。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Lily&#x27;</span> <span class="keyword">in</span> name_list)  <span class="comment"># 结果：True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Lilys&#x27;</span> <span class="keyword">in</span> name_list)  <span class="comment"># 结果：False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>not in：判断指定数据不在某个列表序列，如果不在返回True，否则返回False。</li>
</ul>
<blockquote>
<p>in、not in是公共操作，字符串、列表、字典、元组等都有相应的用法。</p>
</blockquote>
<h5 id="五-列表增加操作"><a href="#五-列表增加操作" class="headerlink" title="(五) 列表增加操作"></a>(五) 列表增加操作</h5><p><strong>(1) append函数</strong></p>
<p>append()：列表<strong>结尾</strong>追加数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.append(数据)</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">name_list.append(<span class="string">&#x27;xiaoming&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br><span class="line"><span class="comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, &#x27;xiaoming&#x27;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>列表追加数据的时候，直接在原列表里面追加了指定数据，即修改了原列表，故列表为可变类型数据。</p>
</blockquote>
<p>如果append()追加的数据是<strong>一个序列</strong>，则追加整个序列到列表</p>
<p>示例2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">name_list.append([<span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;xiaohong&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br><span class="line"><span class="comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, [&#x27;xiaoming&#x27;, &#x27;xiaohong&#x27;]]</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) extend函数</strong></p>
<p>extend()：列表结尾追加数据，如果数据是一个序列，则将这个序列的数据逐一添加到列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.extend(数据)</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">name_list.extend(<span class="string">&#x27;xiaoming&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br><span class="line"><span class="comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, &#x27;x&#x27;, &#x27;i&#x27;, &#x27;a&#x27;, &#x27;o&#x27;, &#x27;m&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;g&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>示例2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">name_list.extend([<span class="string">&#x27;xiaoming&#x27;</span>, <span class="string">&#x27;xiaohong&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br><span class="line"><span class="comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, &#x27;xiaoming&#x27;, &#x27;xiaohong&#x27;]</span></span><br></pre></td></tr></table></figure>
<p><strong>(3) insert函数</strong></p>
<p>insert()：指定位置新增数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.insert(位置下标, 数据)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">name_list.insert(<span class="number">1</span>, <span class="string">&#x27;xiaoming&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br><span class="line"><span class="comment"># 结果：[&#x27;Tom&#x27;, &#x27;xiaoming&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;]</span></span><br></pre></td></tr></table></figure>
<h5 id="六-列表删除操作"><a href="#六-列表删除操作" class="headerlink" title="(六) 列表删除操作"></a>(六) 列表删除操作</h5><p><strong>(1) del函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> 目标</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> name_list</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br><span class="line"><span class="comment"># 结果：报错提示：name &#x27;name_list&#x27; is not defined</span></span><br></pre></td></tr></table></figure>
<p>示例2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> name_list[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br><span class="line"><span class="comment"># 结果：[&#x27;Lily&#x27;, &#x27;Rose&#x27;]</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) pop函数</strong></p>
<p>pop()：删除指定下标的数据(默认为最后一个)，并返回该数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.pop(下标)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">del_name = name_list.pop(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(del_name)  <span class="comment"># 结果：Lily</span></span><br><span class="line"><span class="built_in">print</span>(name_list)  <span class="comment"># 结果：[&#x27;Tom&#x27;, &#x27;Rose&#x27;]</span></span><br></pre></td></tr></table></figure>
<p><strong>(3) remove函数</strong></p>
<p>remove()：移除列表中某个数据的<strong>第一个</strong>匹配项。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表序列.remove(数据)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">name_list.remove(<span class="string">&#x27;Rose&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_list)  <span class="comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：只删除第一个匹配项。</p>
</blockquote>
<p><strong>(4) clear函数</strong></p>
<p>clear()：清空列列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">name_list.clear()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_list) <span class="comment"># 结果： []</span></span><br></pre></td></tr></table></figure>
<h5 id="七-列表修改操作"><a href="#七-列表修改操作" class="headerlink" title="(七) 列表修改操作"></a>(七) 列表修改操作</h5><p><strong>(1) 下标修改法</strong></p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">name_list[<span class="number">0</span>] = <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br><span class="line"><span class="comment"># 结果：[&#x27;aaa&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;]</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 函数修改法</strong></p>
<ul>
<li>reverse()：将列表元素逆序排列</li>
</ul>
<p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.reverse()</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">num_list.reverse()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(num_list)</span><br><span class="line"><span class="comment"># 结果：[8, 6, 3, 2, 5, 1]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sort()：将列表元素递增或递减排序</li>
</ul>
<p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">列表.sort(key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数：</p>
<ul>
<li>key<strong>接受的是一个只有一个形参的函数</strong>，<strong>key接收的函数返回值或者字典的键，表示此元素的权值，sort将按照权值大小进行排序</strong> ，参考示例2。</li>
<li>reverse表示排序规则，reverse = True降序， reverse = False升序（默认）</li>
</ul>
</blockquote>
<p>示例1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">num_list.sort()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(num_list)</span><br><span class="line"><span class="comment"># 结果：[1, 2, 3, 5, 6, 8]，默认升序</span></span><br></pre></td></tr></table></figure>
<p>示例2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取列表的第二个元素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeSecond</span>(<span class="params">elem</span>):</span></span><br><span class="line">    <span class="keyword">return</span> elem[<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">random = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定第二个元素排序</span></span><br><span class="line">random.sort(key=takeSecond)</span><br><span class="line"><span class="comment"># 输出类别</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;排序列表：&#x27;</span>, random)</span><br><span class="line"><span class="comment"># 结果：排序列表：[(4, 1), (2, 2), (1, 3), (3, 4)]</span></span><br></pre></td></tr></table></figure>
<h5 id="八-列表复制操作"><a href="#八-列表复制操作" class="headerlink" title="(八) 列表复制操作"></a>(八) 列表复制操作</h5><p>copy()：将列表复制一次</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">name_li2 = name_list.copy()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(name_li2)</span><br><span class="line"><span class="comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;]</span></span><br></pre></td></tr></table></figure>
<h5 id="九-列表遍历操作"><a href="#九-列表遍历操作" class="headerlink" title="(九) 列表遍历操作"></a>(九) 列表遍历操作</h5><p><strong>(1) while循环法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(name_list):</span><br><span class="line">	<span class="built_in">print</span>(name_list[i])</span><br><span class="line">	i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) for循环法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> name_list:</span><br><span class="line">	<span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<h5 id="十-列表嵌套操作"><a href="#十-列表嵌套操作" class="headerlink" title="(十) 列表嵌套操作"></a>(十) 列表嵌套操作</h5><p>所谓列表嵌套指的就是一个列表里面包含了其他的子列表。<br>应用场景：要存储班级一、二、三个班级学生姓名，且每个班级的学生姓名在一个列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [[<span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;小绿&#x27;</span>], [<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Lily&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>], [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>如何查找到数据”李四”？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一步：按下标查找到李四所在的列表</span></span><br><span class="line"><span class="built_in">print</span>(name_list[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 第⼆步：从李四所在的列表里面，再按下标找到数据李四</span></span><br><span class="line"><span class="built_in">print</span>(name_list[<span class="number">2</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="3-3-元组"><a href="#3-3-元组" class="headerlink" title="3.3 元组()"></a>3.3 元组<code>()</code></h4><h5 id="一-元组的应用场景"><a href="#一-元组的应用场景" class="headerlink" title="(一) 元组的应用场景"></a>(一) 元组的应用场景</h5><p>思考：如果想要存储多个数据，但是这些数据是不能修改的数据，怎么做？<br>答：列表？列表可以一次性存储多个数据，但是<strong>列表中的数据允许更改</strong>。一个元组可以存储多个数据，<strong>元组内的数据是不能修改的</strong>。</p>
<h5 id="二-元组的格式"><a href="#二-元组的格式" class="headerlink" title="(二) 元组的格式"></a>(二) 元组的格式</h5><p>元组特点：定义元组使用<strong>小括号</strong>，且逗号隔开各个数据，数据可以是不同的数据类型。</p>
<p>示例1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多个数据元组</span></span><br><span class="line">t1 = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment"># 单个数据元组</span></span><br><span class="line">t2 = (<span class="number">10</span>,)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果定义的元组只有一个数据，那么这个数据后面<strong>要添加逗号</strong>，否则数据类型为唯一的这个数据的数据类型，如示例2所示</p>
</blockquote>
<p>示例2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t2 = (<span class="number">10</span>,)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t2)) <span class="comment"># tuple</span></span><br><span class="line">t3 = (<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t3)) <span class="comment"># int</span></span><br><span class="line">t4 = (<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t4)) <span class="comment"># str</span></span><br></pre></td></tr></table></figure>
<h5 id="三-元组常见操作——查找"><a href="#三-元组常见操作——查找" class="headerlink" title="(三)元组常见操作——查找"></a>(三)元组常见操作——查找</h5><font color="red">**元组数据不支持修改(增加、删除等)，只支持查找**</font>

<ul>
<li>按下标查找数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="number">12</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(tuple1[<span class="number">0</span>]) <span class="comment"># aa</span></span><br></pre></td></tr></table></figure>
<ul>
<li>index()：查找某个数据，如果数据存在返回对应的下标，否则报错，语法和列表、字符串的index方法相同。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="number">12</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(tuple1.index(<span class="string">&#x27;aa&#x27;</span>)) <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>count()：统计某个数据在当前元组出现的次数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="number">12</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(tuple1.count(<span class="string">&#x27;bb&#x27;</span>)) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>len()：统计元组中数据的个数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;ccc&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="number">12</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(tuple1)) <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>特殊修改方法。。。</li>
</ul>
<blockquote>
<p>注意：元组内的直接数据如果修改则立即报错</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">tuple1[<span class="number">0</span>] = <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="comment"># 报错</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是如果元组里面有列表，修改列表里面的数据则是支持的，故自觉很重要。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple2 = (<span class="number">10</span>, <span class="number">20</span>, [<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;bb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>], <span class="number">50</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(tuple2[<span class="number">2</span>]) <span class="comment"># 访问到列列表</span></span><br><span class="line"></span><br><span class="line">tuple2[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;aaaaa&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(tuple2)</span><br><span class="line"><span class="comment"># 结果：(10, 20, [&#x27;aaaaa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;], 50, 30)</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-字典-或dict"><a href="#3-4-字典-或dict" class="headerlink" title="3.4 字典{}或dict()"></a>3.4 字典<code>&#123;&#125;</code>或<code>dict()</code></h4><h5 id="一-字典简介"><a href="#一-字典简介" class="headerlink" title="(一) 字典简介"></a>(一) 字典简介</h5><p><strong>字典类似与matlab的结构体</strong>。</p>
<p>字典里面的数据是以<strong>键值对</strong>形式出现，字典数据和数据顺序没有关系，即<strong>字典不支持下标</strong>，后期无论数据如何变化，只需要按照对应的键的名字查找数据即可。</p>
<h5 id="二-创建字典的语法"><a href="#二-创建字典的语法" class="headerlink" title="(二) 创建字典的语法"></a>(二) 创建字典的语法</h5><ul>
<li>符号为大括号</li>
<li>数据为键值对形式出现</li>
<li>各个键值对之间用逗号隔开</li>
</ul>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有数据字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 空字典</span></span><br><span class="line">dict2 = &#123;&#125;</span><br><span class="line">dict3 = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：一般称冒号前面的为键(key)，简称k；冒号后面的为值(value)，简称v。</p>
</blockquote>
<h5 id="三-字典修改-增添操作"><a href="#三-字典修改-增添操作" class="headerlink" title="(三) 字典修改/增添操作"></a>(三) 字典修改/增添操作</h5><p>语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字典序列[key] = 值</span><br></pre></td></tr></table></figure>
<p>注意：如果key存在则修改这个key对应的值；如果key不存在则新增此键值对。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">dict1[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;Rose&#x27;</span></span><br><span class="line"><span class="comment"># 结果：&#123;&#x27;name&#x27;: &#x27;Rose&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line">dict1[<span class="string">&#x27;id&#x27;</span>] = <span class="number">110</span></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;Rose&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;, &#x27;id&#x27;: 110&#125;</span></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：由例子可知<strong>字典为可变类型</strong>。</p>
</blockquote>
<h5 id="四-字典删除操作"><a href="#四-字典删除操作" class="headerlink" title="(四) 字典删除操作"></a>(四) 字典删除操作</h5><p><strong>(1) del() / del</strong></p>
<p>del() / del：删除字典或删除字典中指定键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">del</span> dict1[<span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"><span class="comment"># 结果：&#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 20&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如删除的键字典里没有则会报错</p>
</blockquote>
<p><strong>(2) clear()</strong></p>
<p>clear()：清空字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">dict1.clear()</span><br><span class="line"><span class="built_in">print</span>(dict1) <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="五-字典查找操作"><a href="#五-字典查找操作" class="headerlink" title="(五) 字典查找操作"></a>(五) 字典查找操作</h5><p><strong>(1) 按key值查找</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;name&#x27;</span>]) <span class="comment"># Tom</span></span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">&#x27;id&#x27;</span>]) <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) get函数</strong></p>
<p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">字典序列.get(key, 默认值)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果当前查找的key不存在则返回第二个参数(默认值)，如果省略第二个参数，则返回None。</p>
</blockquote>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dict1.get(<span class="string">&#x27;name&#x27;</span>)) <span class="comment"># Tom</span></span><br><span class="line"><span class="built_in">print</span>(dict1.get(<span class="string">&#x27;id&#x27;</span>, <span class="number">110</span>)) <span class="comment"># 110</span></span><br><span class="line"><span class="built_in">print</span>(dict1.get(<span class="string">&#x27;id&#x27;</span>)) <span class="comment"># None</span></span><br></pre></td></tr></table></figure>
<p><strong>(3) keys函数</strong></p>
<p>keys()函数：查找字典中的所有键key，返回<strong>可迭代对象(可用循环遍历的对象)</strong></p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dict1.keys()) </span><br><span class="line"><span class="comment"># dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27;])</span></span><br></pre></td></tr></table></figure>
<p><strong>(4) values函数</strong></p>
<p>value()函数：查找字典中所有键对应的值，返回<strong>可迭代对象(可用循环遍历的对象)</strong></p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dict1.values()) </span><br><span class="line"><span class="comment"># dict_values([&#x27;Tom&#x27;, 20, &#x27;男&#x27;])</span></span><br></pre></td></tr></table></figure>
<p><strong>(5) items函数</strong></p>
<p>items()函数：查找字典中所有的键及其对应的值，返回<strong>可迭代对象(可用循环遍历的对象)</strong></p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dict1.items()) </span><br><span class="line"><span class="comment"># dict_items([(&#x27;name&#x27;, &#x27;Tom&#x27;), (&#x27;age&#x27;, 20), (&#x27;gender&#x27;,&#x27;男&#x27;)])， 形式是元组</span></span><br></pre></td></tr></table></figure>
<h5 id="六-字典遍历操作"><a href="#六-字典遍历操作" class="headerlink" title="(六) 字典遍历操作"></a>(六) 字典遍历操作</h5><p><strong>(1) 遍历字典的key</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict1.keys():</span><br><span class="line">	<span class="built_in">print</span>(key)	</span><br></pre></td></tr></table></figure>
<p><strong>(2) 遍历字典的value</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dict1.values():</span><br><span class="line">	<span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>
<p><strong>(3) 遍历字典的元素</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> dict1.items():</span><br><span class="line">	<span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>
<p><strong>(4) 遍历字典的键值对</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dict1.items():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;key&#125;</span> = <span class="subst">&#123;value&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="3-5-集合-或set"><a href="#3-5-集合-或set" class="headerlink" title="3.5 集合{}或set()"></a>3.5 集合<code>&#123;&#125;</code>或<code>set()</code></h4><h5 id="一-创建集合"><a href="#一-创建集合" class="headerlink" title="(一) 创建集合"></a>(一) 创建集合</h5><p>创建集合使用<code>&#123;&#125;</code> 或<code>set()</code> ， 但是如果<strong>要创建空集合只能使用set() ，因为{}用来创建空字典</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s2 = &#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s2)</span><br><span class="line">s3 = <span class="built_in">set</span>(<span class="string">&#x27;abcdefg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s3)</span><br><span class="line">s4 = <span class="built_in">set</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s4)) <span class="comment"># set</span></span><br><span class="line">s5 = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s5)) <span class="comment"># dict</span></span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>集合可以<strong>去掉重复数据</strong></li>
<li>集合数据是<strong>无序的，故不支持下标</strong></li>
</ul>
<h5 id="二-集合增加数据操作"><a href="#二-集合增加数据操作" class="headerlink" title="(二) 集合增加数据操作"></a>(二) 集合增加数据操作</h5><p><strong>(1) add函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">s1.add(<span class="number">100</span>)</span><br><span class="line">s1.add(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(s1) <span class="comment"># &#123;100, 10, 20&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为<strong>集合有去重功能</strong>，所以，当向集合内追加的数据是当前集合已有数据的话，则不不进⾏行行任何操作。</p>
</blockquote>
<p><strong>(2) update函数</strong></p>
<p>update()：追加的数据是<strong>序列</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line"><span class="comment"># s1.update(100) # 报错</span></span><br><span class="line">s1.update([<span class="number">100</span>, <span class="number">200</span>])</span><br><span class="line">s1.update(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># 结果 &#123;a, 100, 200, 10, &#x27;b&#x27;, &#x27;c&#x27;, 20&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为集合无顺序，所有结果的顺序无所谓</p>
</blockquote>
<h5 id="三-集合删除数据操作"><a href="#三-集合删除数据操作" class="headerlink" title="(三) 集合删除数据操作"></a>(三) 集合删除数据操作</h5><p><strong>(1) remove函数</strong></p>
<p>remove()：删除集合中的指定数据，如果数据不存在则报错。</p>
<p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合.remove(元素)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">s1.remove(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># s1=&#123;20&#125;</span></span><br><span class="line">s1.remove(<span class="number">50</span>) <span class="comment"># 报错</span></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br></pre></td></tr></table></figure>
<p><strong>(2) discard函数</strong></p>
<p>discard()：删除集合中的指定数据，如果数据不存在也不会报错。</p>
<p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">集合.discard(元素)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">s1.discard(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line">s1.discard(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br></pre></td></tr></table></figure>
<p><strong>(3) pop函数</strong></p>
<p>pop()：<strong>随机删除</strong>集合中的某个数据，并<strong>返回这个数据</strong>。</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">集合.pop()</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line">del_num = s1.pop()</span><br><span class="line"><span class="built_in">print</span>(del_num)</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br></pre></td></tr></table></figure>
<h5 id="四-集合查找数据操作"><a href="#四-集合查找数据操作" class="headerlink" title="(四) 集合查找数据操作"></a>(四) 集合查找数据操作</h5><ul>
<li>in：判断数据在集合序列列</li>
<li>not in：判断数据不不在集合序列列</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">in</span> s1)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">not</span> <span class="keyword">in</span> s1)</span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<h3 id="第四章-公共操作"><a href="#第四章-公共操作" class="headerlink" title="第四章 公共操作"></a>第四章 公共操作</h3><p>Python中常见的数据结构可以统称为<strong>容器(container)</strong>。序列(如列表和元组)、映射(如字典)以及集合(set)是三类主要的容器。 </p>
<h4 id="4-1-运算符"><a href="#4-1-运算符" class="headerlink" title="4.1 运算符"></a>4.1 运算符</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">支持的数据(容器)类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">合并</td>
<td style="text-align:center">字符串、列表、元组</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">复制</td>
<td style="text-align:center">字符串、列表、元组</td>
</tr>
<tr>
<td style="text-align:center">in</td>
<td style="text-align:center">元素是否存在</td>
<td style="text-align:center">字符串、列表、元组、字典、集合</td>
</tr>
<tr>
<td style="text-align:center">not in</td>
<td style="text-align:center">元素是否不存在</td>
<td style="text-align:center">字符串、列表、元组、字典、集合</td>
</tr>
</tbody>
</table>
</div>
<h5 id="一-合并"><a href="#一-合并" class="headerlink" title="(一) +合并"></a>(一) <code>+</code>合并</h5><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">支持的数据类型的变量 + 支持的数据类型的变量</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line">str1 = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line">str2 = <span class="string">&#x27;bb&#x27;</span></span><br><span class="line">str3 = str1 + str2</span><br><span class="line"><span class="built_in">print</span>(str3)  <span class="comment"># aabb</span></span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">list2 = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">list3 = list1 + list2</span><br><span class="line"><span class="built_in">print</span>(list3)  <span class="comment"># [1, 2, 10, 20]</span></span><br><span class="line"><span class="comment"># 3. 元组</span></span><br><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">t2 = (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">t3 = t1 + t2</span><br><span class="line"><span class="built_in">print</span>(t3)  <span class="comment"># (10, 20, 100, 200)</span></span><br></pre></td></tr></table></figure>
<h5 id="二-复制"><a href="#二-复制" class="headerlink" title="(二) *复制"></a>(二) <code>*</code>复制</h5><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">支持的数据类型的变量 * 要复制的次数num</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">10</span>) <span class="comment"># ----------</span></span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(list1 * <span class="number">4</span>) <span class="comment"># [&#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;, &#x27;hello&#x27;]</span></span><br><span class="line"><span class="comment"># 3. 元组</span></span><br><span class="line">t1 = (<span class="string">&#x27;world&#x27;</span>,)</span><br><span class="line"><span class="built_in">print</span>(t1 * <span class="number">4</span>) <span class="comment"># (&#x27;world&#x27;, &#x27;world&#x27;, &#x27;world&#x27;, &#x27;world&#x27;)</span></span><br></pre></td></tr></table></figure>
<h5 id="三-in或not-in"><a href="#三-in或not-in" class="headerlink" title="(三) in或not in"></a>(三) <code>in</code>或<code>not in</code></h5><p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;abcd&#x27;</span>) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abcd&#x27;</span>) <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> list1) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> list1) <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 3. 元组</span></span><br><span class="line">t1 = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;aa&#x27;</span> <span class="keyword">in</span> t1) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;aa&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> t1) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 4. 字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> dict1) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Tom&#x27;</span> <span class="keyword">in</span> dict1.values()) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：对于字典数据类型<strong>直接</strong>使用in/not in<strong>只能判断键</strong>，不能用来判断键对应的值</p>
</blockquote>
<h4 id="4-2-公共方法"><a href="#4-2-公共方法" class="headerlink" title="4.2 公共方法"></a>4.2 公共方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
<th>支持容器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">len()</td>
<td style="text-align:left">计算容器中元素个数</td>
<td>字符串、列表、元组、字典、集合</td>
</tr>
<tr>
<td style="text-align:left">del 或 del()</td>
<td style="text-align:left">删除</td>
<td>字符串、列表、字典</td>
</tr>
<tr>
<td style="text-align:left">max()</td>
<td style="text-align:left">返回容器中元素最大值</td>
<td>字符串、列表、元组、集合、字典</td>
</tr>
<tr>
<td style="text-align:left">min()</td>
<td style="text-align:left">返回容器中元素最小值</td>
<td>字符串、列表、元组、集合、字典</td>
</tr>
<tr>
<td style="text-align:left">range(start,end, step)</td>
<td style="text-align:left">生成从start到end的数字，步长为 step，供for循环使用</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">enumerate()</td>
<td style="text-align:left">函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序</td>
</tr>
</tbody>
</table>
</div>
<h5 id="一-len-函数"><a href="#一-len-函数" class="headerlink" title="(一) len()函数"></a>(一) len()函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line">str1 = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(str1)) <span class="comment"># 7</span></span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(list1)) <span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 3. 元组</span></span><br><span class="line">t1 = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(t1)) <span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 4. 集合</span></span><br><span class="line">s1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s1)) <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 5. 字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Rose&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(dict1)) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<h5 id="二-del-函数"><a href="#二-del-函数" class="headerlink" title="(二) del()函数"></a>(二) del()函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串</span></span><br><span class="line">str1 = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="keyword">del</span> str1</span><br><span class="line"><span class="built_in">print</span>(str1)</span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line"><span class="keyword">del</span>(list1[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(list1) <span class="comment"># [20, 30, 40]</span></span><br></pre></td></tr></table></figure>
<h5 id="三-max-、min-函数"><a href="#三-max-、min-函数" class="headerlink" title="(三) max()、min()函数"></a>(三) max()、min()函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 字符串串</span></span><br><span class="line">str1 = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(str1)) <span class="comment"># g</span></span><br><span class="line"><span class="comment"># 2. 列列表</span></span><br><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(list1)) <span class="comment"># 40</span></span><br><span class="line"><span class="comment"># 3.字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;7&#x27;</span>: <span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(dict1)) <span class="comment"># 7 返回键的最大值</span></span><br></pre></td></tr></table></figure>
<h5 id="四-range-函数"><a href="#四-range-函数" class="headerlink" title="(四) range()函数"></a>(四) range()函数</h5><p>注意：range()⽣生成的序列<strong>不包含end数字</strong>，<strong>其返回值是一个可迭代对象</strong>。</p>
<p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(开始数字, 结束数字, 步幅)</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 3 5 7 9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>):</span><br><span class="line">	<span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">	<span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>示例2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 结果 range(1, 10, 2)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其返回值是一个可迭代对象</p>
</blockquote>
<h5 id="五-enumerate-函数"><a href="#五-enumerate-函数" class="headerlink" title="(五) enumerate()函数"></a>(五) enumerate()函数</h5><p>enumerate()：返回N个元组，每个元组形式为(索引值，对应的值)</p>
<p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enumerate</span>(可遍历对象, start=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：start参数用来设置遍历数据的下标的起始值，默认为0。</p>
</blockquote>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">enumerate</span>(list1):</span><br><span class="line">	<span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># (0, &#x27;a&#x27;)</span></span><br><span class="line"><span class="comment"># (1, &#x27;b&#x27;)</span></span><br><span class="line"><span class="comment"># (2, &#x27;c&#x27;)</span></span><br><span class="line"><span class="keyword">for</span> index, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(list1, start=<span class="number">1</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&#x27;下标是<span class="subst">&#123;index&#125;</span>, 对应的字符是<span class="subst">&#123;char&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># 下标是1, 对应的字符是a</span></span><br><span class="line"><span class="comment"># 下标是2, 对应的字符是b</span></span><br><span class="line"><span class="comment"># 下标是3, 对应的字符是c</span></span><br></pre></td></tr></table></figure>
<h4 id="4-3-容器类型转换"><a href="#4-3-容器类型转换" class="headerlink" title="4.3 容器类型转换"></a>4.3 容器类型转换</h4><h5 id="一-tuple-函数"><a href="#一-tuple-函数" class="headerlink" title="(一) tuple()函数"></a>(一) tuple()函数</h5><p>tuple()：将某个序列转换成元组</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">20</span>]</span><br><span class="line">s1 = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(list1))</span><br><span class="line"><span class="comment"># (10, 20, 30, 40, 50, 20)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(s1))</span><br><span class="line"><span class="comment"># (100, 200, 300, 400, 500)</span></span><br></pre></td></tr></table></figure>
<h5 id="二-list-函数"><a href="#二-list-函数" class="headerlink" title="(二) list()函数"></a>(二) list()函数</h5><p>list()：将某个序列转换成列表</p>
<h5 id="三-set-函数"><a href="#三-set-函数" class="headerlink" title="(三) set()函数"></a>(三) set()函数</h5><p>set()：将某个序列转换成集合</p>
<blockquote>
<p>注意：</p>
<ol>
<li>集合可以快速完成列表去重</li>
<li>集合不支持下标</li>
</ol>
</blockquote>
<h4 id="4-4-推导式"><a href="#4-4-推导式" class="headerlink" title="4.4 推导式"></a>4.4 推导式</h4><p>Python中只有列表、字典、集合有推导式，字符串和元组没有。</p>
<h5 id="一-列表推导式"><a href="#一-列表推导式" class="headerlink" title="(一) 列表推导式"></a>(一) 列表推导式</h5><p>作用：用一个表达式创建一个<strong>有规律</strong>的列表或控制一个有规律列表。列表推导式又叫列表生成式。</p>
<p>示例1：传统方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个0-10的列表</span></span><br><span class="line"><span class="comment"># ========while方法实现==========</span></span><br><span class="line"><span class="comment"># 1. 准备⼀一个空列列表</span></span><br><span class="line">list1 = []</span><br><span class="line"><span class="comment"># 2. 书写循环，依次追加数字到空列列表list1中</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:</span><br><span class="line">	list1.append(i)</span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="comment"># ========for方法实现==========</span></span><br><span class="line">list1 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">	list1.append(i)</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br></pre></td></tr></table></figure>
<p><strong>示例2：列表推导式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br></pre></td></tr></table></figure>
<ul>
<li>带if的列表推导式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建0-10的偶数列表</span></span><br><span class="line"><span class="comment"># 方法一：range()步长实现</span></span><br><span class="line">list1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)]</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"><span class="comment"># 方法二：if实现</span></span><br><span class="line">list2 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(list2)</span><br></pre></td></tr></table></figure>
<ul>
<li>多个for循环实现列表推导式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需求：创建列表如下：</span></span><br><span class="line"><span class="comment"># [(1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</span></span><br><span class="line">list1 = [(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br></pre></td></tr></table></figure>
<h5 id="二-字典推导式"><a href="#二-字典推导式" class="headerlink" title="(二) 字典推导式"></a>(二) 字典推导式</h5><p>思考：如果有如下两个列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;man&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>如何快速合并为一个字典？</p>
<p>答：字典推导式；字典推导式作用：快速合并列表为字典或提取字典中目标数据。</p>
<p>示例1：创建一个字典：字典key是1-5数字，value是这个数字的2次方</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;i: i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1) <span class="comment"># &#123;1: 1, 2: 4, 3: 9, 4: 16&#125;</span></span><br></pre></td></tr></table></figure>
<p>示例2：将两个列表合并为一个字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;man&#x27;</span>]</span><br><span class="line">dict1 = &#123;list1[i]: list2[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list1))&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br></pre></td></tr></table></figure>
<p>示例3：提取字典中目标数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">counts = &#123;<span class="string">&#x27;MBP&#x27;</span>: <span class="number">268</span>, <span class="string">&#x27;HP&#x27;</span>: <span class="number">125</span>, <span class="string">&#x27;DELL&#x27;</span>: <span class="number">201</span>, <span class="string">&#x27;Lenovo&#x27;</span>: <span class="number">199</span>, <span class="string">&#x27;acer&#x27;</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="comment"># 需求：提取上述电脑数量量大于等于200的字典数据</span></span><br><span class="line">count1 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> counts.items() <span class="keyword">if</span> value &gt;= <span class="number">200</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(count1) <span class="comment"># &#123;&#x27;MBP&#x27;: 268, &#x27;DELL&#x27;: 201&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="三-集合推导式"><a href="#三-集合推导式" class="headerlink" title="(三) 集合推导式"></a>(三) 集合推导式</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需求：创建一个集合，数据为下方列表的2次方</span></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">set1 = &#123;i ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> list1&#125;</span><br><span class="line"><span class="built_in">print</span>(set1) <span class="comment"># &#123;1, 4&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="第五章-函数"><a href="#第五章-函数" class="headerlink" title="第五章 函数"></a>第五章 函数</h3><h4 id="5-1-函数的作用"><a href="#5-1-函数的作用" class="headerlink" title="5.1 函数的作用"></a>5.1 函数的作用</h4><p>函数就是将一段具有独立功能的代码块整合到一个整体并命名，在需要的位置调用这个名称即可完成对应的需求。<br>函数在开发过程中，可以更高效的实现<strong>代码重用</strong>。</p>
<h4 id="5-2-函数的使用步骤"><a href="#5-2-函数的使用步骤" class="headerlink" title="5.2 函数的使用步骤"></a>5.2 函数的使用步骤</h4><h5 id="一-定义函数"><a href="#一-定义函数" class="headerlink" title="(一) 定义函数"></a>(一) 定义函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">参数</span>):</span></span><br><span class="line">	代码<span class="number">1</span></span><br><span class="line">	代码<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    (<span class="keyword">return</span> ...)</span><br></pre></td></tr></table></figure>
<h5 id="二-调用函数"><a href="#二-调用函数" class="headerlink" title="(二) 调用函数"></a>(二) 调用函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数名(参数)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol>
<li>不同的需求，参数可有可无；</li>
<li>在Python中，函数必须先定义后使用。</li>
</ol>
</blockquote>
<h5 id="三-函数的说明文档"><a href="#三-函数的说明文档" class="headerlink" title="(三) 函数的说明文档"></a>(三) 函数的说明文档</h5><p>思考：定义一个函数后，程序员如何书写程序能够快速提示这个函数的作用？<br>答：注释</p>
<p>思考：如果代码多，我们是不是需要在很多代码中找到这个函数定义的位置才能看到注释？如果想更方便的查看函数的作用怎么办？<br>答：函数的说明文档</p>
<ul>
<li>定义函数的说明文档</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">参数</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot; 说明文档的位置 &quot;&quot;&quot;</span></span><br><span class="line">	代码</span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<ul>
<li>查看函数的说明文档</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span>(函数名)</span><br></pre></td></tr></table></figure>
<h5 id="四-函数嵌套调用"><a href="#四-函数嵌套调用" class="headerlink" title="(四) 函数嵌套调用"></a>(四) 函数嵌套调用</h5><p>所谓函数嵌套调用指的是一个函数里面又调用了另外一个函数。</p>
<h5 id="五-函数使用步骤小结"><a href="#五-函数使用步骤小结" class="headerlink" title="(五) 函数使用步骤小结"></a>(五) 函数使用步骤小结</h5><ul>
<li>函数的参数：函数调用的时候可以传入真实数据，增大函数的使用的灵活性<ul>
<li>形参：函数定义时书写的参数(非真实数据)</li>
<li>实参：函数调用时书写的参数(真实数据)</li>
</ul>
</li>
</ul>
<h4 id="5-3-函数的详细理解"><a href="#5-3-函数的详细理解" class="headerlink" title="5.3 函数的详细理解"></a>5.3 函数的详细理解</h4><h5 id="一-变量作用域"><a href="#一-变量作用域" class="headerlink" title="(一) 变量作用域"></a>(一) 变量作用域</h5><p>变量量作用域指的是变量生效的范围，主要分为两类：局部变量和全局变量。</p>
<p><strong>(1) 局部变量</strong></p>
<p>所谓局部变量是定义在函数体内部的变量，即只在函数体内部生效。</p>
<p>局部变量的作用：在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量。</p>
<p><strong>(2) 全局变量</strong><br>所谓全局变量，指的是在函数体内、外都能生效的变量。</p>
<p>思考：如果有一个数据，在函数A和函数B中都要使用，该怎么办？<br>答：将这个数据存储在一个全局变量里面。</p>
<h5 id="二-函数的返回值"><a href="#二-函数的返回值" class="headerlink" title="(二) 函数的返回值"></a>(二) 函数的返回值</h5><p>如果一个函数要有多个返回值，该如何书写代码？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_num</span>():</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">result = return_num()</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># (1, 2)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：return后面可以连接列表、元组或字典，以返回多个值。</p>
</blockquote>
<p>python中可以使用<code>-&gt;</code>表示<strong>函数返回值的类型</strong>，即：函数后面跟着的箭头是函数返回值的类型建议符，用来说明该函数返回的值是什么类型，如下述示例代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">name: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">str</span>(name)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>greet</code> 函数接受一个类型为 <code>int</code> 的参数 <code>name</code>，函数返回一个字符串 <code>str</code> 类型的值。箭头 <code>-&gt;</code> 用于指示这一点。 </p>
<blockquote>
<p>若函数没有返回值，则可以使用<code>None</code>参数表明，如下代码示例：<code>def greet(name: int) -&gt; None:</code>。</p>
</blockquote>
<p style="text-indent:2em"> 插入：yield关键字</p>

<p><code>yield</code>是一个类似<code>return</code>的关键字，迭代一次遇到<code>yield</code>时就返回<code>yield</code>后面的值。重点是：下一次迭代时，从上一次迭代遇到的<code>yield</code>后面的代码开始执行。</p>
<p>简要理解：<code>yield</code>就是<code>return</code>返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后开始。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding:UTF-8  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yield_test</span>(<span class="params">n</span>):</span>  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  </span><br><span class="line">        <span class="keyword">yield</span> call(i)  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;i=&quot;</span>,i)  </span><br><span class="line">    <span class="comment">#做一些其它的事情      </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do something.&quot;</span>)      </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end.&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">i</span>):</span>  </span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">#使用for循环  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> yield_test(<span class="number">5</span>):  </span><br><span class="line">    <span class="built_in">print</span>(i,<span class="string">&quot;,&quot;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="三-函数的参数"><a href="#三-函数的参数" class="headerlink" title="(三) 函数的参数"></a>(三) 函数的参数</h5><p><strong>(0) 参数的类型</strong></p>
<p>python中，在参数后面使用冒号的作用是为了指明参数的类型，如下述示例代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(greet(<span class="string">&#x27;Alice&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>在上面的代码示例中，我们定义了一个名为<code>greet</code>的函数，该函数接受一个名为<code>name</code>的参数，并且该参数的类型为<code>str</code>。在参数后面使用冒号的作用是为了指明参数的类型。在函数的返回值后面也使用了箭头<code>-&gt;</code>来指明返回值的类型。</p>
<p><strong>(1) 位置参数</strong></p>
<p>位置参数：调用函数时根据函数定义的参数位置来传递参数。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">name, age, gender</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&#x27;您的名字是<span class="subst">&#123;name&#125;</span>, 年龄是<span class="subst">&#123;age&#125;</span>, 性别是<span class="subst">&#123;gender&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：传递和定义参数的<strong>顺序及个数必须一致</strong>。</p>
</blockquote>
<p><strong>(2) 关键字参数</strong></p>
<p>函数调用，通过“<font color="red"><strong>键=值</strong></font>”形式加以指定。可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">name, age, gender</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&#x27;您的名字是<span class="subst">&#123;name&#125;</span>, 年龄是<span class="subst">&#123;age&#125;</span>, 性别是<span class="subst">&#123;gender&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">user_info(<span class="string">&#x27;Rose&#x27;</span>, age=<span class="number">20</span>, gender=<span class="string">&#x27;女&#x27;</span>)</span><br><span class="line">user_info(<span class="string">&#x27;小明&#x27;</span>, gender=<span class="string">&#x27;男&#x27;</span>, age=<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：函数调用时，如果有位置参数时，<strong>位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序</strong>。</p>
</blockquote>
<p><strong>(3) 缺省参数</strong></p>
<p>缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值</p>
<p>（注意：<strong>所有位置参数必须出现在默认参数前，包括函数定义和调用</strong>）。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">name, age, gender=<span class="string">&#x27;男&#x27;</span></span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">f&#x27;您的名字是<span class="subst">&#123;name&#125;</span>, 年龄是<span class="subst">&#123;age&#125;</span>, 性别是<span class="subst">&#123;gender&#125;</span>&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment"># 您的名字是TOM, 年龄是20, 性别是男</span></span><br><span class="line">user_info(<span class="string">&#x27;Rose&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;女&#x27;</span>)</span><br><span class="line"><span class="comment"># 您的名字是Rose, 年龄是18, 性别是女</span></span><br></pre></td></tr></table></figure>
<p><strong>(4) 不定长参数</strong></p>
<p>不定长参数也叫可变参数。用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。此时，可用包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。</p>
<ul>
<li>包裹位置传递</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">*args</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>)</span><br><span class="line"><span class="comment"># (&#x27;TOM&#x27;,)</span></span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment"># (&#x27;TOM&#x27;, 18)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：传进函数的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个<font color="red"><strong>元组(tuple)</strong></font>，args是元组类型，这就是包裹位置传递。</p>
</blockquote>
<ul>
<li>包裹关键字传递</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_info</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(kwargs)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">user_info(name=<span class="string">&#x27;TOM&#x27;</span>, age=<span class="number">18</span>, <span class="built_in">id</span>=<span class="number">110</span>)</span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: 110&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>综上：无论是包裹位置传递还是包裹关键字传递，都是一个组包的过程。</p>
</blockquote>
<h5 id="四-拆包和交换变量值"><a href="#四-拆包和交换变量值" class="headerlink" title="(四) 拆包和交换变量值"></a>(四) 拆包和交换变量值</h5><p><strong>(1) 拆包</strong></p>
<ul>
<li>拆包：元组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_num</span>():</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">100</span>, <span class="number">200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num1, num2 = return_num()</span><br><span class="line"><span class="built_in">print</span>(num1) <span class="comment"># 100</span></span><br><span class="line"><span class="built_in">print</span>(num2) <span class="comment"># 200</span></span><br></pre></td></tr></table></figure>
<ul>
<li>拆包：字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;TOM&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">a, b = dict1</span><br><span class="line"><span class="comment"># 对字典进行拆包，取出来的是字典的key</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># name</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># age</span></span><br><span class="line"><span class="built_in">print</span>(dict1[a]) <span class="comment"># TOM</span></span><br><span class="line"><span class="built_in">print</span>(dict1[b]) <span class="comment"># 18</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 交换变量值</strong></p>
<p>需求：有变量a = 10 和b = 20 ，交换两个变量的值。</p>
<ul>
<li>方法1：借助第三变量存储数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 定义中间变量量</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"><span class="comment"># 2. 将a的数据存储到c</span></span><br><span class="line">c = a</span><br><span class="line"><span class="comment"># 3. 将b的数据20赋值到a，此时a = 20</span></span><br><span class="line">a = b</span><br><span class="line"><span class="comment"># 4. 将之前c的数据10赋值到b，此时b = 10</span></span><br><span class="line">b = c</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># 20</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方法2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">a, b = b, a</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<h5 id="五-引用"><a href="#五-引用" class="headerlink" title="(五) 引用"></a>(五) 引用</h5><p><strong>(1) 了解引用</strong></p>
<p>在python中，值是靠引用来传递来的。<br>我们可以用<code>id()</code>来判断两个变量是否为同一个值的引用。 我们可以<strong>将id值理解为那块内存的地址标识</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. int类型</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)) <span class="comment"># 140708464157520</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b)) <span class="comment"># 140708464157520</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># 1,说明int类型为不可变类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)) <span class="comment"># 140708464157552，此时得到是的数据2的内存地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b)) <span class="comment"># 140708464157520</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 列表</span></span><br><span class="line">aa = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">bb = aa</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(aa)) <span class="comment"># 2325297783432</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(bb)) <span class="comment"># 2325297783432</span></span><br><span class="line">aa.append(<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(bb) <span class="comment"># [10, 20, 30], 列列表为可变类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(aa)) <span class="comment"># 2325297783432</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(bb)) <span class="comment"># 2325297783432</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 引用当做实参</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">a</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line">	a += a</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># int：计算前后id值不不同</span></span><br><span class="line">b = <span class="number">100</span></span><br><span class="line">test1(b)</span><br><span class="line"><span class="comment"># 列表：计算前后id值相同</span></span><br><span class="line">c = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line">test1(c)</span><br></pre></td></tr></table></figure>
<h5 id="六-可变与不可变类型"><a href="#六-可变与不可变类型" class="headerlink" title="(六) 可变与不可变类型"></a>(六) 可变与不可变类型</h5><p>所谓可变类型与不可变类型是指：数据能够直接进行修改，如果能直接修改那么就是可变，否则是不可变。</p>
<ul>
<li><p><strong>可变类型</strong></p>
<p>  列表<br>  字典<br>  集合</p>
</li>
<li><p><strong>不可变类型</strong></p>
<p>  整型<br>  浮点型<br>  字符串<br>  元组</p>
</li>
</ul>
<p>不可变数据类型： 当该数据类型的对应变量的值发生了改变，那么它对应的内存地址也会发生改变，对于这种数据类型，就称不可变数据类型。</p>
<p>可变数据类型：当该数据类型的对应变量的值发生了改变，那么它对应的内存地址不发生改变，对于这种数据类型，就称可变数据类型。</p>
<p>总结：不可变数据类型更改后地址发生改变，可变数据类型更改地址不发生改变</p>
<h4 id="5-4-递归函数"><a href="#5-4-递归函数" class="headerlink" title="5.4 递归函数"></a>5.4 递归函数</h4><p>递归是一种编程思想</p>
<ul>
<li>函数内部自己调用自己</li>
<li>递归函数必须有出口</li>
</ul>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需求：3以内数字累加和 3+2+1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_numbers</span>(<span class="params">num</span>):</span></span><br><span class="line">	<span class="comment"># 1.如果是1，直接返回1 -- 出口</span></span><br><span class="line">	<span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="comment"># 2.如果不不是1，重复执行累加:</span></span><br><span class="line">	result = num + sum_numbers(num-<span class="number">1</span>)</span><br><span class="line">	<span class="comment"># 3.返回累加结果</span></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum_result = sum_numbers(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(sum_result)</span><br><span class="line"><span class="comment"># 输出结果为6</span></span><br></pre></td></tr></table></figure>
<h4 id="5-5-lambda表达式-匿名函数"><a href="#5-5-lambda表达式-匿名函数" class="headerlink" title="5.5 lambda表达式/匿名函数"></a>5.5 lambda表达式/匿名函数</h4><p>如果一个函数有一个返回值，并且只有一句代码，可以使用 lambda简化。</p>
<h5 id="一-lambda的语法"><a href="#一-lambda的语法" class="headerlink" title="(一) lambda的语法"></a>(一) lambda的语法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数列表 ： 表达式</span><br></pre></td></tr></table></figure>
<ul>
<li>lambda表达式的参数可有可无，函数的参数在lambda表达式中完全适用</li>
<li>lambda函数能接收任何数量的参数但只能返回一个表达式的值</li>
<li>该表达式必须有返回值，表达式处可以视为：<code>return 表达式</code></li>
</ul>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算a + b</span></span><br><span class="line"><span class="comment"># 方法1：普通函数实现=======================</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 方法2：lambda表达式=======================</span></span><br><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> a, b: a + b)(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<h5 id="二-lambda的参数形式"><a href="#二-lambda的参数形式" class="headerlink" title="(二) lambda的参数形式"></a>(二) lambda的参数形式</h5><p><strong>(1) 无参数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> : <span class="number">100</span>)())</span><br></pre></td></tr></table></figure>
<p><strong>(2) 一个参数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> a: a)(<span class="string">&#x27;hello world&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><strong>(3) 默认参数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> a, b, c=<span class="number">100</span>: a + b + c)(<span class="number">10</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure>
<p><strong>(4) 可变位置参数：*args</strong></p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> *args: args)(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 注意：这里的可变参数传入到lambda之后，返回值为元组。</p>
</blockquote>
<p> <strong>(5) 可变关键字参数：*kwargs</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> **kwargs: kwargs)(name=<span class="string">&#x27;python&#x27;</span>, age=<span class="number">20</span>))</span><br></pre></td></tr></table></figure>
<h5 id="三-lambda表达式的应用"><a href="#三-lambda表达式的应用" class="headerlink" title="(三) lambda表达式的应用"></a>(三) lambda表达式的应用</h5><p><strong>(1) 带判断的lambda</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> a, b: a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b)(<span class="number">1000</span>, <span class="number">500</span>))</span><br></pre></td></tr></table></figure>
<p><strong>(2) 列表数据按字典key的值排序</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;TOM&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;ROSE&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按name值升序排列</span></span><br><span class="line">students.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(students)</span><br><span class="line"><span class="comment"># 按name值降序排列</span></span><br><span class="line">students.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;name&#x27;</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(students)</span><br><span class="line"><span class="comment"># 按age值升序排列</span></span><br><span class="line">students.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(students)</span><br></pre></td></tr></table></figure>
<h4 id="5-6-高阶函数"><a href="#5-6-高阶函数" class="headerlink" title="5.6 高阶函数"></a>5.6 高阶函数</h4><p><strong>把函数作为另一个函数的参数传入</strong>，这样的函数称为高阶函数，高阶函数是函数式编程的体现。函数式编程就是指这种高度抽象的编程范式。</p>
<h5 id="一-体验高阶函数"><a href="#一-体验高阶函数" class="headerlink" title="(一) 体验高阶函数"></a>(一) 体验高阶函数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 完成计算任意两个数字的绝对值之和</span></span><br><span class="line"><span class="comment"># 方法1：普通函数法====================</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_num</span>(<span class="params">a, b</span>):</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">abs</span>(a) + <span class="built_in">abs</span>(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = add_num(-<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：高阶函数法====================</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_num</span>(<span class="params">a, b, f</span>):</span></span><br><span class="line">	<span class="keyword">return</span> f(a) + f(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = sum_num(-<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">abs</span>)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>两种方法对比之后，发现方法2的代码会更加简洁。</p>
<p>函数式编程大量使用函数，减少了代码的重复，提高了灵活性，因此程序比较短，开发速度较快。</p>
<h5 id="二-内置高阶函数"><a href="#二-内置高阶函数" class="headerlink" title="(二) 内置高阶函数"></a>(二) 内置高阶函数</h5><p><strong>(1) map()函数</strong></p>
<p><code>map(func, lst)</code>，将传入的函数变量<code>func</code>作用到<code>lst</code>列表变量的每个元素中，并将结果组成新的列表(Python2)/迭代器(可迭代对象，Python3)返回。</p>
<p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(function, iterable, ...)</span><br></pre></td></tr></table></figure>
<p>示例1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ：计算list1序列中各个数字的2次方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">	<span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">result = <span class="built_in">map</span>(func, list1)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># &lt;map object at 0x0000013769653198&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result)) <span class="comment"># [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>
<p>示例2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))   <span class="comment"># 使用 lambda 匿名函数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>
<p><strong>(2) reduce()函数</strong></p>
<p><code>reduce(func(x,y)，lst)</code>，其中<code>func</code>必须有两个参数。每次<code>func</code>计算的结果继续和序列的下一个元素做累积计算。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算list1序列中各个数字的累加和</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b</span>):</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">result = functools.reduce(func, list1)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 15</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>reduce()在python3中不属于内置函数，需要从functools模块调用</p>
</blockquote>
<p><strong>(3) filter()函数</strong></p>
<p><code>filter(func, lst)</code>函数用于过滤序列，过滤掉不符合条件的元素，返回一个filter对象。如果要转换为列表，可以使用list()来转换。和map()类似，filter()也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是<strong>True还是False</strong>决定保留还是丢弃该元素。 </p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">	<span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="comment">#返回True或False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">result = <span class="built_in">filter</span>(func, list1)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># &lt;filter object at 0x0000017AF9DC3198&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result)) <span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<h3 id="第六章-文件操作"><a href="#第六章-文件操作" class="headerlink" title="第六章 文件操作"></a>第六章 文件操作</h3><h4 id="6-1-文件操作的作用"><a href="#6-1-文件操作的作用" class="headerlink" title="6.1 文件操作的作用"></a>6.1 文件操作的作用</h4><p>思考：文件操作包含什么？<br>答：打开、关闭、读、写、复制….</p>
<p>思考：文件操作的的作用是什么？<br>答：读取内容、写入内容、备份内容……</p>
<p>文件操作的作用就是把一些内容(数据)存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力。</p>
<h4 id="6-2-文件的基本操作"><a href="#6-2-文件的基本操作" class="headerlink" title="6.2 文件的基本操作"></a>6.2 文件的基本操作</h4><h5 id="一-打开-创建文件——open"><a href="#一-打开-创建文件——open" class="headerlink" title="(一) 打开/创建文件——open()"></a>(一) 打开/创建文件——open()</h5><p>在python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(name, mode)</span><br></pre></td></tr></table></figure>
<p>name：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。<br>mode：设置打开文件的模式(访问模式)：只读、写入、追加等。</p>
<p><strong>(1) 打开文件模式</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头，这是<strong>默认模式</strong>。</td>
</tr>
<tr>
<td>rb</td>
<td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td>以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容<strong>会被删除</strong>。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb</td>
<td>以二进制格式打开一个文件只用于写入。如果该文件已存在则打开⽂文件，并从开头开始编辑，即原有内容<strong>会被删除</strong>。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文件用于读写。如果该文件已存在则打开⽂文件，并从开头开始编辑，即原有内容<strong>会被删除</strong>。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb+</td>
<td>以二进制格式打开一个文件用于读写。如果该文件已存在则打开⽂文件，并从开头开始编辑，即原有内容<strong>会被删除</strong>。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>ab</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td>ab+</td>
<td>以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意：对于a的模式打开文件，由于文件指针在文件的结尾处，因此无法使用read()读出内容，但是可以使用seek()函数改变文件指针</p>
<p>注意：使用w模式打开文件，一旦文件打开就自动删除文件的内容</p>
</blockquote>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test,txt&#x27;</span>, <span class="string">&#x27;w)</span></span><br></pre></td></tr></table></figure>
<h5 id="二-文件对象方法"><a href="#二-文件对象方法" class="headerlink" title="(二) 文件对象方法"></a>(二) 文件对象方法</h5><p><strong>(1) 写方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">文件对象.write(<span class="string">&#x27;内容&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 打开文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment"># 2.文件写入</span></span><br><span class="line">f.write(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"><span class="comment"># 3. 关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol>
<li>w 和a 模式：如果文件不存在则创建该文件；如果文件存在， w 模式先清空再写入， a 模式直接末尾追加。</li>
<li>r 模式：如果文件不存在则报错。</li>
</ol>
</blockquote>
<p><strong>(2) 读方法</strong></p>
<p><strong>① read()函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">文件对象.read(num)</span><br></pre></td></tr></table></figure>
<p>num表示要从文件中读取的数据的长度（单位是<strong>字节</strong>），如果没有传入num，那么就表示读取文件中所有的数据。</p>
<p><strong>② readline()函数</strong></p>
<p>readline()一次读取一行内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>)</span><br><span class="line">content = f.readline()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;第一行：<span class="subst">&#123;content&#125;</span>&#x27;</span>)</span><br><span class="line">content = f.readline()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;第二行：<span class="subst">&#123;content&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p><strong>③ readlines()函数</strong></p>
<p>readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个<strong>列表</strong>，其中每一行的数据为一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>)</span><br><span class="line">content = f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(content) <span class="comment"># [&#x27;hello world\n&#x27;, &#x27;abcdefg\n&#x27;, &#x27;aaa\n&#x27;, &#x27;bbb\n&#x27;, &#x27;ccc&#x27;]</span></span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p><strong>(3) 文件指针方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">文件对象.seek(偏移量, 起始位置)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>偏移量：n，单位字节</p>
<p>起始位置：<br>0：文件开头，1：当前位置，2：文件结尾</p>
</blockquote>
<p><strong>(4) 关闭文件</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">文件对象.close()</span><br></pre></td></tr></table></figure>
<h5 id="三-文件备份"><a href="#三-文件备份" class="headerlink" title="(三) 文件备份"></a>(三) 文件备份</h5><h4 id="6-3-文件和文件夹的操作"><a href="#6-3-文件和文件夹的操作" class="headerlink" title="6.3 文件和文件夹的操作"></a>6.3 文件和文件夹的操作</h4><p>在Python中文件和文件夹的操作要借助<strong>os模块</strong>里面的相关功能，具体步骤如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 导入os模块</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 2. 使用os模块相关功能</span></span><br><span class="line">os.函数名()</span><br></pre></td></tr></table></figure>
<h5 id="一-文件重命名"><a href="#一-文件重命名" class="headerlink" title="(一) 文件重命名"></a>(一) 文件重命名</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rename(目标文件名, 新文件名)</span><br></pre></td></tr></table></figure>
<h5 id="二-删除文件"><a href="#二-删除文件" class="headerlink" title="(二) 删除文件"></a>(二) 删除文件</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(目标文件名)</span><br></pre></td></tr></table></figure>
<h5 id="三-创建文件夹"><a href="#三-创建文件夹" class="headerlink" title="(三) 创建文件夹"></a>(三) 创建文件夹</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.mkdir(文件夹名字)</span><br></pre></td></tr></table></figure>
<h5 id="四-删除文件夹"><a href="#四-删除文件夹" class="headerlink" title="(四) 删除文件夹"></a>(四) 删除文件夹</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.rmdir(文件夹名字)</span><br></pre></td></tr></table></figure>
<h5 id="五-获取当前目录"><a href="#五-获取当前目录" class="headerlink" title="(五) 获取当前目录"></a>(五) 获取当前目录</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure>
<h5 id="六-改变默认目录"><a href="#六-改变默认目录" class="headerlink" title="(六) 改变默认目录"></a>(六) 改变默认目录</h5><p>os.chdir()方法用于改变当前工作目录到指定的路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.chdir(目录)</span><br></pre></td></tr></table></figure>
<h5 id="七-获取目录列表"><a href="#七-获取目录列表" class="headerlink" title="(七) 获取目录列表"></a>(七) 获取目录列表</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.listdir(目录)</span><br></pre></td></tr></table></figure>
<h4 id="6-4-文件路径操作"><a href="#6-4-文件路径操作" class="headerlink" title="6.4 文件路径操作"></a>6.4 文件路径操作</h4><h5 id="一-Windows下的路径写法"><a href="#一-Windows下的路径写法" class="headerlink" title="(一) Windows下的路径写法"></a>(一) Windows下的路径写法</h5><p><strong>由于windows的路径分隔符使用的是反斜杠\，它刚刚好是转义字符，故可能发生冲突</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误示范：反斜杠似乎被解释为转义字符而不是分隔字符</span></span><br><span class="line">path = <span class="string">&quot;F:\Python\test.txt&quot;</span>   </span><br><span class="line">path = <span class="string">&quot;F:\\Python\test.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;以下三种方式都是可行的&quot;&quot;&quot;</span></span><br><span class="line">path = <span class="string">&quot;F:\Python\\test.txt&quot;</span></span><br><span class="line">path = <span class="string">&quot;F:\\Python\\test.txt&quot;</span></span><br><span class="line">path = <span class="string">&quot;F:\Python\\test.txt&quot;</span>   </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;绝对路径的最后一个反斜杠使用了双反斜杠时就正常&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;原因是最后一个反斜杠可以与它紧挨着的字符t构成转义效果&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>结论：</strong>使用绝对路径的时候，要注意在绝对路径中使用的反斜杠与它后面紧跟着的字符会不会构成转义效果，如果会产生转义效果，如\t \n \r等等，则必须使用双反斜杠来取消单反斜杠的转义效果。如果产生了转义字符带来的错误，会出现<strong>open()</strong>提示 <strong>“Invalid arguments”</strong> </p>
<font color="blue">**Python中windows路径的3种写法**</font>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;C:\\Users\\10799\\Desktop\\learn\\C\\homework\\5&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">r&quot;C:\Users\10799\Desktop\learn\C\homework\5&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;C:/Users/10799/Desktop/learn/C/homework/5&quot;</span></span><br></pre></td></tr></table></figure>
<p>但是不可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;C:\Users\10799\Desktop\learn\C\homework\5&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="二-绝对路径与相对路径"><a href="#二-绝对路径与相对路径" class="headerlink" title="(二) 绝对路径与相对路径"></a>(二) 绝对路径与相对路径</h5><p><strong>相对路径相关写法：</strong></p>
<p><code>../</code> 表示当前文件所在的目录的上一级目录<br><code>./</code>表示当前文件所在的目录(可以省略)<br><code>/</code>表示当前站点的根目录(域名映射的硬盘目录) </p>
<h3 id="第七章-面向对象基础"><a href="#第七章-面向对象基础" class="headerlink" title="第七章 面向对象基础"></a>第七章 面向对象基础</h3><h4 id="7-1-理解面向对象"><a href="#7-1-理解面向对象" class="headerlink" title="7.1 理解面向对象"></a>7.1 理解面向对象</h4><p>面向对象就是将编程当成是一个事物，对外界来说，事物是直接使用的，不用去管他内部的情况。而编程就是设置事物能够做什么事。</p>
<p>面向对象是一种抽象化的编程思想，很多编程语言中都有的一种思想。<br>例如：洗衣服<br>思考：几种途径可以完成洗衣服？<br>答： 手洗 和 机洗。<br>手洗：找盆 - 放水 - 加洗衣粉 - 浸泡 - 搓洗 - 拧干水 - 倒水 - 漂洗N次 - 拧干 - 晾晒。<br>机洗：打开洗衣机 - 放衣服 - 加洗衣粉 - 按下开始按钮 - 晾晒。<br>思考：对比两种洗衣服途径，同学们发现了了什么？<br>答：机洗更简单<br>思考：机洗，只需要找到一台洗衣机，加入简单操作就可以完成洗衣服的工作，而不需要关心洗衣机内部发⽣生了了什么事情。</p>
<ul>
<li>面向对象的三大特征<ul>
<li>封装<ul>
<li>将属性和方法书写到类的里面的操作即为封装</li>
<li>封装可以为属性和⽅方法添加私有权限</li>
</ul>
</li>
<li>继承<ul>
<li>子类默认继承父类的所有属性和方法</li>
<li>子类可以重写父类属性和方法</li>
</ul>
</li>
<li>多态<ul>
<li>传入不同的对象，产生不同的结果</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-2-类和对象"><a href="#7-2-类和对象" class="headerlink" title="7.2 类和对象"></a>7.2 类和对象</h4><p><strong><font color="red">类和对象的关系：用类去实例化/创建一个对象</font></strong>。</p>
<h5 id="一-理解类和对象"><a href="#一-理解类和对象" class="headerlink" title="(一) 理解类和对象"></a>(一) 理解类和对象</h5><p><strong>(1) 类</strong></p>
<p>类是对一系列具有相同特征和行为的事物的统称，是一个抽象的概念，不是真实存在的事物。</p>
<ul>
<li>特征即是属性——变量</li>
<li>行为即是方法——函数</li>
</ul>
<p>类比如是制造洗衣机时要用到的图纸，也就是说类是用来创建对象。</p>
<p><strong>(2) 对象</strong></p>
<p>对象是类创建出来的真实存在的事物，例如：洗衣机。也就是说开发中先有类，再有对象。</p>
<h5 id="二-面向对象实现方法"><a href="#二-面向对象实现方法" class="headerlink" title="(二) 面向对象实现方法"></a>(二) 面向对象实现方法</h5><p><strong>(1) 定义类</strong></p>
<p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名():</span></span><br><span class="line">	代码</span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：类名要满足标识符命名规则，同时遵循<strong>大驼峰命名</strong>习惯。e.g. 每个单词的首字母都采用大写字母,例如:FirstName </p>
</blockquote>
<p><strong>(2) 创建对象</strong></p>
<p>对象又名实例。语法如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象名 = 类名()</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">haier1 = Washer()</span><br><span class="line"><span class="comment"># &lt;__main__.Washer object at 0x0000018B7B224240&gt;</span></span><br><span class="line"><span class="built_in">print</span>(haier1)</span><br><span class="line"><span class="comment"># haier对象调用实例方法</span></span><br><span class="line">haier1.wash()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在python下实例化一个类对象时一般都会在类名后加上小括号，但如果不带括号会执行什么操作呢？ 如果不带括号本质上是给类对象起了一个<strong>别名</strong>，类似C语言中的<strong>typedef</strong>关键字，而并<strong>不会创建一个实例</strong>。 </p>
</blockquote>
<p><strong>(3) self</strong></p>
<p>self指的是调用该函数的对象。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span>():</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wash</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我会洗衣服&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self)  <span class="comment"># &lt;__main__.Washer object at 0x0000024BA2B34240&gt;</span></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2. 创建对象</span></span><br><span class="line">haier1 = Washer()</span><br><span class="line"><span class="built_in">print</span>(haier1)  <span class="comment"># &lt;__main__.Washer object at 0x0000018B7B224240&gt;</span></span><br><span class="line"><span class="comment"># haier1对象调用实例方法</span></span><br><span class="line">haier1.wash()</span><br><span class="line">haier2 = Washer()</span><br><span class="line"><span class="built_in">print</span>(haier2)  <span class="comment"># &lt;__main__.Washer object at 0x0000022005857EF0&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：打印对象和self得到的结果是一致的，都是当前对象的内存中存储地址。</p>
</blockquote>
<h4 id="7-3-添加和获取对象属性"><a href="#7-3-添加和获取对象属性" class="headerlink" title="7.3 添加和获取对象属性"></a>7.3 添加和获取对象属性</h4><p>属性即是特征，比如：洗衣机的宽度、高度、重量…<br>对象属性既可以在类外面添加和获取，也能在类里面添加和获取。</p>
<h5 id="一-类外面添加对象属性"><a href="#一-类外面添加对象属性" class="headerlink" title="(一) 类外面添加对象属性"></a>(一) 类外面添加对象属性</h5><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象名.属性名 = 值</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">haier1.width = <span class="number">500</span></span><br><span class="line">haier1.height = <span class="number">800</span></span><br></pre></td></tr></table></figure>
<h5 id="二-类外面获取对象属性"><a href="#二-类外面获取对象属性" class="headerlink" title="(二) 类外面获取对象属性"></a>(二) 类外面获取对象属性</h5><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">对象名.属性名</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;haier1洗衣机的宽度是<span class="subst">&#123;haier1.width&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;haier1洗衣机的高度是<span class="subst">&#123;haier1.height&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="三-类里面获取对象属性"><a href="#三-类里面获取对象属性" class="headerlink" title="(三) 类里面获取对象属性"></a>(三) 类里面获取对象属性</h5><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.属性名</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span>():</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">print_info</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="comment"># 类里面获取实例属性</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;haier1洗衣机的宽度是<span class="subst">&#123;self.width&#125;</span>&#x27;</span>)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;haier1洗衣机的高度是<span class="subst">&#123;self.height&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">haier1 = Washer()</span><br><span class="line"><span class="comment"># 添加实例例属性</span></span><br><span class="line">haier1.width = <span class="number">500</span></span><br><span class="line">haier1.height = <span class="number">800</span></span><br><span class="line">haier1.print_info()</span><br></pre></td></tr></table></figure>
<h5 id="四-类变量和实例变量"><a href="#四-类变量和实例变量" class="headerlink" title="(四) 类变量和实例变量"></a>(四) 类变量和实例变量</h5><ul>
<li><strong>类变量</strong></li>
</ul>
<p>类变量是在类定义中直接声明的变量，它属于类本身，而不是类的任何特定实例。类变量在内存中只有一个副本，无论创建了多少个类的实例，这个变量都被所有实例共享。在类变量前不使用<code>self</code>（或任何其他实例引用）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span>  </span><br><span class="line">    class_variable = <span class="string">&quot;这是一个类变量&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 访问类变量  </span></span><br><span class="line"><span class="built_in">print</span>(MyClass.class_variable)  <span class="comment"># 这是一个类变量  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 通过实例也可以访问，但仍然是同一个变量  </span></span><br><span class="line">obj = MyClass()  </span><br><span class="line"><span class="built_in">print</span>(obj.class_variable)  <span class="comment"># 这是一个类变量</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>实例变量</strong></li>
</ul>
<p>实例变量（也称为对象变量）属于类的实例。每个实例都有自己独立的实例变量副本。实例变量通常在类的方法中通过<code>self</code>参数来定义和访问。<code>self</code>是一个对当前实例的引用，允许你访问该实例的属性和方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span>  </span><br><span class="line">        self.instance_variable = value  <span class="comment"># 这是一个实例变量  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 实例化对象并设置实例变量  </span></span><br><span class="line">obj1 = MyClass(<span class="string">&quot;实例变量1&quot;</span>)  </span><br><span class="line">obj2 = MyClass(<span class="string">&quot;实例变量2&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 访问实例变量  </span></span><br><span class="line"><span class="built_in">print</span>(obj1.instance_variable)  <span class="comment"># 实例变量1  </span></span><br><span class="line"><span class="built_in">print</span>(obj2.instance_variable)  <span class="comment"># 实例变量2</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>小结</strong><ul>
<li><strong>类变量</strong>：不使用<code>self</code>，直接定义在类体中，属于类本身，被所有实例共享。</li>
<li><strong>实例变量</strong>：通过<code>self</code>在类的方法中定义和访问，属于类的实例，每个实例都有自己的独立副本。</li>
</ul>
</li>
<li><strong>注意事项</strong><ul>
<li>你可以通过实例访问类变量，但若通过实例修改了类变量的值，那么这个修改会影响到所有实例，因为类变量在内存中只有一个副本。</li>
<li>类变量通常用于定义那些不需要为每个实例单独存储的、所有实例共享的数据。</li>
<li>实例变量则用于存储那些不同实例的数据会有不同的情况（例如不同的冰箱长宽不同）。</li>
</ul>
</li>
</ul>
<h4 id="7-4-魔法方法"><a href="#7-4-魔法方法" class="headerlink" title="7.4 魔法方法"></a>7.4 魔法方法</h4><p>在Python中，<code>__xx__()</code>的函数叫做魔法方法，指的是具有<strong>特殊功能</strong>的函数。</p>
<p>魔法方法是python内置方法，<strong>不需要主动调用</strong>，存在的目的是为了给python的解释器进行调用，几乎每个魔法方法都有一个对应的内置函数，或者运算符，当我们对这个对象使用这些函数或者运算符时就会调用类中的对应魔法方法，可以理解为重写这些python的内置函数(类似于方法重载)。 </p>
<h5 id="一-init-魔法方法"><a href="#一-init-魔法方法" class="headerlink" title="(一) __init__()魔法方法"></a>(一) <code>__init__()</code>魔法方法</h5><p>思考：洗衣机的宽度高度是与生俱来的属性，可不可以在生产过程中就赋予这些属性呢？<br>答：理应如此。</p>
<p><strong>(1) <code>__init__()</code> 方法</strong></p>
<p><code>__init__()</code> 方法的作用：初始化对象。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span>():</span></span><br><span class="line">	<span class="comment"># 定义初始化功能的函数</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="comment"># 添加实例属性</span></span><br><span class="line">		self.width = <span class="number">500</span></span><br><span class="line">		self.height = <span class="number">800</span></span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">print_info</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="comment"># 类里面调用实例属性</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;洗衣机的宽度是<span class="subst">&#123;self.width&#125;</span>, 高度是<span class="subst">&#123;self.height&#125;</span>&#x27;</span>)</span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">haier1 = Washer()</span><br><span class="line">haier1.print_info()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br><code>__init__()</code> 方法，在创建一个对象时默认被调用，不需要手动调用；</p>
<p><code>__init__(self)</code>中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递过去；</p>
<p><code>__init__()</code> 方法不需要调用是指在在创建对象时会自动调用，但是如果在没有创建对象时，需要调用</p>
</blockquote>
<p><strong>(2) 带参数的<code>__init__()</code></strong></p>
<p>思考：一个类可以创建多个对象，如何对不同的对象设置不同的初始化属性呢？<br>答：传参数。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span>():</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, width, height</span>):</span></span><br><span class="line">		self.width = width</span><br><span class="line">		self.height = height</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">print_info</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;洗衣机的宽度是<span class="subst">&#123;self.width&#125;</span>&#x27;</span>)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;洗衣机的高度是<span class="subst">&#123;self.height&#125;</span>&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">haier1 = Washer(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">haier1.print_info()</span><br><span class="line">haier2 = Washer(<span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line">haier2.print_info()</span><br></pre></td></tr></table></figure>
<h5 id="二-str-魔法方法"><a href="#二-str-魔法方法" class="headerlink" title="(二) __str__()魔法方法"></a>(二) <code>__str__()</code>魔法方法</h5><p>当使用print输出对象的时候，默认打印对象的内存地址。如果类定义了了<code>__str__()</code>方法，那么就会打印从<br>在这个方法中 return 的数据。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span>():</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, width, height</span>):</span></span><br><span class="line">		self.width = width</span><br><span class="line">		self.height = height</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;这是海尔洗衣机的说明书&#x27;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">haier1 = Washer(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(haier1) <span class="comment"># 这是海尔洗衣机的说明书</span></span><br></pre></td></tr></table></figure>
<h5 id="三-del-魔法方法"><a href="#三-del-魔法方法" class="headerlink" title="(三) __del__()魔法方法"></a>(三) <code>__del__()</code>魔法方法</h5><p>当删除对象时，python解释器也会默认调用<code>__del__()</code> 方法。(即使没有删除语句，在程序结束时也会调用该函数)</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Washer</span>():</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, width, height</span>):</span></span><br><span class="line">		self.width = width</span><br><span class="line">		self.height = height</span><br><span class="line">        </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;self&#125;</span>对象已经被删除&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">haier1 = Washer(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">del</span> haier1 <span class="comment"># &lt;__main__.Washer object at 0x0000026118223278&gt;对象已经被删除</span></span><br></pre></td></tr></table></figure>
<h5 id="四-call-魔法方法"><a href="#四-call-魔法方法" class="headerlink" title="(四) __call__()魔法方法"></a>(四) <code>__call__()</code>魔法方法</h5><p><code>__call__()</code>方法的作用其实是把一个类的实例化对象变成了可调用对象，只要类里实现了<code>__call__()</code>方法就行。</p>
<p>如当类里没有实现<code>__call__()</code>时，<strong>此时的对象p只是个类的实例，不是一个可调用的对象</strong>，当调用它时会报错：’Person’ object is not callable</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>)</span></span><br><span class="line"><span class="class">	<span class="title">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>)</span></span><br><span class="line"><span class="class">    	<span class="title">self</span>.<span class="title">name</span> = <span class="title">name</span></span></span><br><span class="line"><span class="class">        <span class="title">pass</span></span></span><br><span class="line"><span class="class">    <span class="title">pass</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Wjh</span> = <span class="title">Person</span>(<span class="params"><span class="string">&#x27;WJH&#x27;</span></span>)</span></span><br><span class="line"><span class="class"># 未写方法<span class="title">__call__</span>时强行调用对象</span></span><br><span class="line"><span class="class"><span class="title">Wjh</span>(<span class="params"><span class="string">&#x27;Bob&#x27;</span></span>)</span></span><br><span class="line"><span class="class"># 报错：&#x27;<span class="title">Person</span>&#x27; <span class="title">object</span> <span class="title">is</span> <span class="title">not</span> <span class="title">callable</span>        </span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>)</span></span><br><span class="line"><span class="class">	<span class="title">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>)</span></span><br><span class="line"><span class="class">    	<span class="title">self</span>.<span class="title">name</span> = <span class="title">name</span></span></span><br><span class="line"><span class="class">        <span class="title">pass</span></span></span><br><span class="line"><span class="class">     <span class="title">def</span> <span class="title">__call__</span>(<span class="params">self, friend</span>)</span></span><br><span class="line"><span class="class">    	<span class="title">print</span>(<span class="params"><span class="string">f&#x27;我的名字是<span class="subst">&#123;self.name&#125;</span>，我的朋友叫<span class="subst">&#123;friend&#125;</span>&#x27;</span></span>)</span></span><br><span class="line"><span class="class">        <span class="title">pass</span></span></span><br><span class="line"><span class="class">    <span class="title">pass</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Wjh</span> = <span class="title">Person</span>(<span class="params"><span class="string">&#x27;WJH&#x27;</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">Wjh</span>(<span class="params"><span class="string">&#x27;Bob&#x27;</span></span>)</span></span><br><span class="line"><span class="class"># 我的名字是<span class="title">WJH</span>，我的朋友叫<span class="title">Bob</span></span></span><br></pre></td></tr></table></figure>
<h3 id="第八章-面向对象—继承"><a href="#第八章-面向对象—继承" class="headerlink" title="第八章 面向对象—继承"></a>第八章 面向对象—继承</h3><h4 id="8-1-继承的概念"><a href="#8-1-继承的概念" class="headerlink" title="8.1 继承的概念"></a>8.1 继承的概念</h4><p>生活中的继承，一般指的是子女继承父辈的财产。</p>
<p>Python面向对象的继承指的是<strong>多个类之间的所属关系</strong>，即子类默认继承父类的所有属性和方法，具体如<br>下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.num = <span class="number">1</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">info_print</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(self.num)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># 子类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = B()</span><br><span class="line">result.info_print() <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<p>在Python中，所有类默认继承object类，object类是顶级类或基类；其他子类叫做派生类。</p>
<ul>
<li><font color="blue">**子类不重写`__init__`，实例化子类时，会自动调用父类定义的`__init__`。**</font> </li>
<li><strong>如果子类重写了<code>__init__</code> 方法，那么父类的属性是不能直接调用的。</strong> </li>
</ul>
<h4 id="8-2-单继承"><a href="#8-2-单继承" class="headerlink" title="8.2 单继承"></a>8.2 单继承</h4><p>一个子类只有一个直接父类时称这个继承关系为单继承。</p>
<blockquote>
<p> 故事主线：一个煎饼果子老师傅，在煎饼果子界摸爬滚打多年，研发了一套精湛的摊煎饼果子的技术。师⽗父要把这套技术传授给他的唯一的最得意的徒弟。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 师⽗父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.kongfu = <span class="string">&#x27;[古法煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">         </span><br><span class="line"><span class="comment"># 2. 徒弟类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prentice</span>(<span class="params">Master</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 创建对象daqiu</span></span><br><span class="line">daqiu = Prentice()</span><br><span class="line"><span class="comment"># 4. 对象访问实例例属性</span></span><br><span class="line"><span class="built_in">print</span>(daqiu.kongfu)</span><br></pre></td></tr></table></figure>
<h4 id="8-3-多继承"><a href="#8-3-多继承" class="headerlink" title="8.3 多继承"></a>8.3 多继承</h4><p>一个子类有两个或以上直接父类时称这个继承关系为多继承。 </p>
<blockquote>
<p>故事推进：daqiu是个爱学习的好孩子，想学习更多的煎饼果子技术，于是，在百度搜索到黑马程序员，报班学习煎饼果子技术。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.kongfu = <span class="string">&#x27;[古法煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建学校类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.kongfu = <span class="string">&#x27;[黑马煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prentice</span>(<span class="params">School, Master</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">daqiu = Prentice()</span><br><span class="line"><span class="built_in">print</span>(daqiu.kongfu)</span><br><span class="line">daqiu.make_cake()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<strong>当一个类有多个父类的时候，默认使用第一个父类的同名属性和方法。</strong></p>
</blockquote>
<h4 id="8-4-子类重写父类同名方法和属性"><a href="#8-4-子类重写父类同名方法和属性" class="headerlink" title="8.4 子类重写父类同名方法和属性"></a>8.4 子类重写父类同名方法和属性</h4><p>子类和父类具有同名属性和方时，默认使用子类的同名属性和方法。</p>
<p>一个对象调用一个方法，如果本类中没有这个方法那就会按照mro顺序去找与他相关的类是否有这个方法，如果找到顶级类object依然没有这个方法，那就会报错。包括后面的super().方法()也是按照mro顺序去找的，至于mro是怎么定义的，大家可以搜索下【拓扑排序】 </p>
<blockquote>
<p>故事：daqiu掌握了师父和培训的技术后，自己潜心钻研出自己的独门配方的一套全新的煎饼果子技术。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    	self.kongfu = <span class="string">&#x27;[古法煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.kongfu = <span class="string">&#x27;[黑马煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 独创配方</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prentice</span>(<span class="params">School, Master</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.kongfu = <span class="string">&#x27;[独创煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">daqiu = Prentice()</span><br><span class="line"><span class="built_in">print</span>(daqiu.kongfu)</span><br><span class="line">daqiu.make_cake()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Prentice.__mro__) <span class="comment"># 通过打印__mro__可以查看类的继承层级顺序</span></span><br></pre></td></tr></table></figure>
<h4 id="8-5-子类调用父类的同名方法和属性"><a href="#8-5-子类调用父类的同名方法和属性" class="headerlink" title="8.5 子类调用父类的同名方法和属性"></a>8.5 子类调用父类的同名方法和属性</h4><blockquote>
<p>故事：很多顾客都希望也能吃到古法和黑马的技术的煎饼果子。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    	self.kongfu = <span class="string">&#x27;[古法煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.kongfu = <span class="string">&#x27;[黑马煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prentice</span>(<span class="params">School, Master</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.kongfu = <span class="string">&#x27;[独创煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="comment"># 若先调用了父类的属性和方法，父类属性会覆盖子类属性，故在调用属性前，先调用自己子类的初始化</span></span><br><span class="line">		self.__init__()</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">		<span class="comment"># 调用父类方法，但是为保证调用到的也是父类的属性，必须在调用方法前调用父类的初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_master_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		Master.__init__(self)</span><br><span class="line">		Master.make_cake(self)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_school_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		School.__init__(self)</span><br><span class="line">		School.make_cake(self)</span><br><span class="line">        </span><br><span class="line">daqiu = Prentice()</span><br><span class="line">daqiu.make_cake()</span><br><span class="line">daqiu.make_master_cake()</span><br><span class="line">daqiu.make_school_cake()</span><br><span class="line">daqiu.make_cake()</span><br></pre></td></tr></table></figure>
<h4 id="8-6-多层继承"><a href="#8-6-多层继承" class="headerlink" title="8.6 多层继承"></a>8.6 多层继承</h4><p>一个子类可以有一个父类，一个父类还可以有一个父类。</p>
<blockquote>
<p>故事：N年后，daqiu老了，想要把所有技术传承给自己的徒弟。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    	self.kongfu = <span class="string">&#x27;[古法煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.kongfu = <span class="string">&#x27;[黑马煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prentice</span>(<span class="params">School, Master</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.kongfu = <span class="string">&#x27;[独创煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="comment"># 若先调用了父类的属性和方法，父类属性会覆盖子类属性，故在调用属性前，先调用自己子类的初始化</span></span><br><span class="line">		self.__init__()</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">		<span class="comment"># 调用父类方法，但是为保证调用到的也是父类的属性，必须在调用方法前调用父类的初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_master_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		Master.__init__(self)</span><br><span class="line">		Master.make_cake(self)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_school_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		School.__init__(self)</span><br><span class="line">		School.make_cake(self)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 徒孙类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tusun</span>(<span class="params">Prentice</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">xiaoqiu = Tusun()</span><br><span class="line">xiaoqiu.make_cake()  <span class="comment"># 运用[独创煎饼果子配方]制作煎饼果子</span></span><br><span class="line">xiaoqiu.make_school_cake()  <span class="comment"># 运用[黑马煎饼果子配方]制作煎饼果子</span></span><br><span class="line">xiaoqiu.make_master_cake()  <span class="comment"># 运用[古法煎饼果子配方]制作煎饼果子</span></span><br></pre></td></tr></table></figure>
<h4 id="8-7-super-调用父类方法"><a href="#8-7-super-调用父类方法" class="headerlink" title="8.7 super()调用父类方法"></a>8.7 super()调用父类方法</h4><p>使用super()可以自动查找父类。调用顺序遵循 <code>__mro__</code> 类属性的顺序。比较<strong>适合单继承</strong>使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Master</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.kongfu = <span class="string">&#x27;[古法煎饼果子配方]&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span>(<span class="params">Master</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.kongfu = <span class="string">&#x27;[黑马煎饼果子配方]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">		<span class="comment"># 方法2.1</span></span><br><span class="line">		<span class="comment"># super(School, self).__init__()</span></span><br><span class="line">		<span class="comment"># super(School, self).make_cake()</span></span><br><span class="line">		<span class="comment"># 方法2.2</span></span><br><span class="line">		<span class="built_in">super</span>().__init__()</span><br><span class="line">		<span class="built_in">super</span>().make_cake()</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prentice</span>(<span class="params">School</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.kongfu = <span class="string">&#x27;[独创煎饼果子技术]&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.__init__()</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&#x27;运用<span class="subst">&#123;self.kongfu&#125;</span>制作煎饼果子&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">	<span class="comment"># 子类调用父类的同名方法和属性：把父类的同名属性和方法再次封装</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_master_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		Master.__init__(self)</span><br><span class="line">		Master.make_cake(self)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_school_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">		School.__init__(self)</span><br><span class="line">		School.make_cake(self)</span><br><span class="line">        </span><br><span class="line">	<span class="comment"># 一次性调用父类的同名属性和方法</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">make_old_cake</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="comment"># 方法一：代码冗余；父类名如果变化，这里代码需要频繁修改</span></span><br><span class="line">		<span class="comment"># Master.__init__(self)</span></span><br><span class="line">		<span class="comment"># Master.make_cake(self)</span></span><br><span class="line">		<span class="comment"># School.__init__(self)</span></span><br><span class="line">		<span class="comment"># School.make_cake(self)</span></span><br><span class="line">	<span class="comment"># 方法二: super()</span></span><br><span class="line">	<span class="comment"># 方法2.1 super(当前类名, self).函数()</span></span><br><span class="line">	<span class="comment"># super(Prentice, self).__init__()</span></span><br><span class="line">	<span class="comment"># super(Prentice, self).make_cake()</span></span><br><span class="line">	<span class="comment"># 方法2.2 super().函数()</span></span><br><span class="line">	<span class="built_in">super</span>().__init__()</span><br><span class="line">	<span class="built_in">super</span>().make_cake()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">daqiu = Prentice()</span><br><span class="line">daqiu.make_old_cake()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： super() 在 python2、3中的区别</p>
<p>python3直接写成 super().方法名（参数） </p>
<p>python2必须写成 super（父类，self）.方法名（参数） </p>
</blockquote>
<h4 id="8-8-私有权限"><a href="#8-8-私有权限" class="headerlink" title="8.8 私有权限"></a>8.8 私有权限</h4><p>主要介绍了Python 私有属性与私有方法，私有属性是指在 Python 的面向对象开发过程中，对象的某些属性只想在对象的内部被使用，但不想在外部被访问到这些属。</p>
<blockquote>
<p>参考笔记：Python 私有属性与私有方法<a href="https://www.jb51.net/article/239280.htm">https://www.jb51.net/article/239280.htm</a></p>
</blockquote>
<h5 id="一-定义私有属性和方法"><a href="#一-定义私有属性和方法" class="headerlink" title="(一) 定义私有属性和方法"></a>(一) 定义私有属性和方法</h5><p> <strong>(1) 私有属性/方法是什么？</strong></p>
<font color="red">**两个下划线开头的属性是私有的(private)。其他为公共的(public)**。</font>

<ul>
<li><strong>私有属性：</strong></li>
</ul>
<p>是指在 Python 的面向对象开发过程中，对象的某些属性只想在对象的内部被使用，但不想在外部被访问到这些属性。<strong>即：</strong>私有属性是对象不愿意公开的属性。</p>
<ul>
<li><strong>私有方法：</strong></li>
</ul>
<p>是指在 Python 的面向对象开发过程中，对象的某些方法或者称为函数只想在对象的内部被使用，但不想在外部被访问到这些方法或函数。<strong>即：</strong>私有方法是对象不愿意公开的方法或函数。</p>
<p><strong>(2) 示例语法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Staff</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, s_name, s_salary</span>):</span></span><br><span class="line">      self.s_name = s_name</span><br><span class="line">      self.__salary = s_salary</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__secret</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;%s 的工资是 %d&quot;</span> % (self.s_name, self.__salary))</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>(1). __salary是以两个下划线开头来定义的私有属性。</li>
<li>(2). __secret(self)是以两个下划线开头来定义的私有方法。</li>
</ul>
</blockquote>
<h5 id="二-私有属性的调用"><a href="#二-私有属性的调用" class="headerlink" title="(二) 私有属性的调用"></a>(二) 私有属性的调用</h5><ul>
<li>类内部可以访问私有属性(方法)</li>
<li>类外部不能直接访问私有属性(方法)</li>
<li>类外部可以通过”_类名__私有属性(方法)名”访问私有属性(方法)(<font color="red"><strong>伪</strong></font>私有属性和私有方法)</li>
</ul>
<blockquote>
<p>方法本质上也是属性！只不过是可以通过()执行而执行</p>
</blockquote>
<h5 id="三-获取和修改私有属性值"><a href="#三-获取和修改私有属性值" class="headerlink" title="(三) 获取和修改私有属性值"></a>(三) 获取和修改私有属性值</h5><p>在Python中，一般定义公有方法函数名<code>get_xx</code>用来获取私有属性，定义<code>set_xx</code>用来修改私有属性值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">        self.__age = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#获取私有属性的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#设置私有属性的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_age</span>(<span class="params">self, new_age</span>):</span></span><br><span class="line">        self.__age = new_age</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#定义一个对象</span></span><br><span class="line">p = Person()</span><br><span class="line"><span class="comment">#强行获取私有属性</span></span><br><span class="line"><span class="comment">#崇尚一切靠自觉</span></span><br><span class="line"><span class="built_in">print</span>(p._Person__age)</span><br><span class="line"><span class="built_in">print</span>(p.name)</span><br><span class="line"><span class="comment">#想在类的外面获取对象的属性</span></span><br><span class="line">ret = p.get_age()</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#想在类的外面修改对象私有属性的值</span></span><br><span class="line">p.set_age(<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(p.get_age())</span><br></pre></td></tr></table></figure>
<h3 id="第九章-面向对象—多态—其他知识"><a href="#第九章-面向对象—多态—其他知识" class="headerlink" title="第九章 面向对象—多态—其他知识"></a>第九章 面向对象—多态—其他知识</h3><h4 id="9-1-多态"><a href="#9-1-多态" class="headerlink" title="9.1 多态"></a>9.1 多态</h4><h5 id="一-了解多态"><a href="#一-了解多态" class="headerlink" title="(一) 了解多态"></a>(一) 了解多态</h5><p>多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）。</p>
<ul>
<li><strong>定义：</strong></li>
</ul>
<p>多态是一种使用对象的方式，子类重写父类方法，调用不同子类对象的相同父类方法，可以产生不同的执行结果。</p>
<ul>
<li><strong>好处：</strong></li>
</ul>
<p>调用灵活，有了多态更容易写出通用的代码，做出通用的编程，以适应需求的不断变化！</p>
<ul>
<li><strong>实现步骤：</strong><ul>
<li>定义父类，并提供公共方法</li>
<li>定义子类，并重写父类方法</li>
<li>传递子类对象给调用者，可以看到不同子类执行效果不同</li>
</ul>
</li>
</ul>
<h5 id="二-多态示例"><a href="#二-多态示例" class="headerlink" title="(二) 多态示例"></a>(二) 多态示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span> <span class="comment"># 父类提供统一的方法，哪怕是空方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;指哪打哪...&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArmyDog</span>(<span class="params">Dog</span>):</span> <span class="comment"># 继承Dog类</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span> <span class="comment"># 子类重写父类同名方法</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;追击敌人...&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrugDog</span>(<span class="params">Dog</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;追查毒品...&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">work_with_dog</span>(<span class="params">self, dog</span>):</span> <span class="comment"># 传入不同的对象执行不同的代码，即不同的work函数</span></span><br><span class="line">		dog.work()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">ad = ArmyDog()</span><br><span class="line">dd = DrugDog()</span><br><span class="line">daqiu = Person()</span><br><span class="line">daqiu.work_with_dog(ad)</span><br><span class="line">daqiu.work_with_dog(dd)</span><br></pre></td></tr></table></figure>
<h4 id="9-2-类属性和实例属性"><a href="#9-2-类属性和实例属性" class="headerlink" title="9.2 类属性和实例属性"></a>9.2 类属性和实例属性</h4><h5 id="一-类属性"><a href="#一-类属性" class="headerlink" title="(一) 类属性"></a>(一) 类属性</h5><p><strong>(1) 设置和访问类属性</strong></p>
<ul>
<li>类属性就是<strong>类对象</strong>所拥有的属性，它被<strong>该类的所有实例对象</strong>所共有。</li>
<li>类属性可以使用<strong>类对象</strong>或<strong>实例对象</strong>访问。</li>
</ul>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	tooth = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">wangcai = Dog()</span><br><span class="line">xiaohei = Dog()</span><br><span class="line"><span class="built_in">print</span>(Dog.tooth) <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(wangcai.tooth) <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(xiaohei.tooth) <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 类属性的优点</strong></p>
<ul>
<li>类的实例 记录的某项数据 始终保持一致时，则定义类属性。</li>
<li>实例属性要求每个对象为其单独开辟一份内存空间来记录数据，而类属性为全类所共有，仅占用一份内存，更加节省内存空间。</li>
</ul>
<p><strong>(3) 修改类属性</strong></p>
<p>类属性只能通过类对象修改，不能通过实例对象修改，如果通过实例对象修改类属性，表示的是创建了了一个实例属性。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	tooth = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">wangcai = Dog()</span><br><span class="line">xiaohei = Dog()</span><br><span class="line"><span class="comment"># 修改类属性</span></span><br><span class="line">Dog.tooth = <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(Dog.tooth) <span class="comment"># 12</span></span><br><span class="line"><span class="built_in">print</span>(wangcai.tooth) <span class="comment"># 12</span></span><br><span class="line"><span class="built_in">print</span>(xiaohei.tooth) <span class="comment"># 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能通过对象修改属性，如果这样操作，实则是创建了一个实例属性</span></span><br><span class="line">wangcai.tooth = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(Dog.tooth) <span class="comment"># 12</span></span><br><span class="line"><span class="built_in">print</span>(wangcai.tooth) <span class="comment"># 20</span></span><br><span class="line"><span class="built_in">print</span>(xiaohei.tooth) <span class="comment"># 12</span></span><br></pre></td></tr></table></figure>
<h5 id="二-实例属性"><a href="#二-实例属性" class="headerlink" title="(二) 实例属性"></a>(二) 实例属性</h5><p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">		self.age = <span class="number">5</span></span><br><span class="line">        </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">info_print</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(self.age)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">wangcai = Dog()</span><br><span class="line"><span class="built_in">print</span>(wangcai.age) <span class="comment"># 5</span></span><br><span class="line"><span class="comment"># print(Dog.age) # 报错：实例属性不能通过类访问</span></span><br><span class="line">wangcai.info_print() <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>
<h4 id="9-3-类方法和静态方法"><a href="#9-3-类方法和静态方法" class="headerlink" title="9.3 类方法和静态方法"></a>9.3 类方法和静态方法</h4><h5 id="一-类方法"><a href="#一-类方法" class="headerlink" title="(一) 类方法"></a>(一) 类方法</h5><p><strong>(1) 类方法特点</strong></p>
<ul>
<li>第一个形参是类对象的方法</li>
<li>需要用装饰器<code>@classmethod</code>来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以<code>cls</code>作为第一个参数。</li>
</ul>
<p><strong>(2) 类方法使用场景</strong></p>
<ul>
<li>当方法中 需要使用类对象 (如访问私有类属性等)时，定义类方法</li>
<li>类方法一般和类属性配合使用</li>
</ul>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	__tooth = <span class="number">10</span> <span class="comment"># 私有-类-属性</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_tooth</span>(<span class="params">cls</span>):</span></span><br><span class="line">		<span class="keyword">return</span> cls.__tooth</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">wangcai = Dog()</span><br><span class="line">result = wangcai.get_tooth()</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment"># 10</span></span><br></pre></td></tr></table></figure>
<p><strong>(二) 静态方法</strong></p>
<p><strong>(1) 静态方法特点</strong></p>
<ul>
<li>需要通过装饰器<code>@staticmethod</code>来进行修饰，静态方法既不需要传递类对象也不需要传递实例对象(<strong>形参没有self/cls</strong>）。</li>
<li>静态方法也能够通过<strong>实例对象</strong>和<strong>类对象</strong>去访问。</li>
</ul>
<p><strong>(2) 静态方法使用场景</strong></p>
<ul>
<li>当方法中既不需要使用实例对象(如实例对象，实例属性)，也不需要使用类对象(如类属性、类方法、创建实例等)时，定义静态方法</li>
<li>取消不需要的参数传递，有利于减少不必要的内存占用和性能消耗</li>
</ul>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">info_print</span>():</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;这是一个狗类，用于创建狗实例....&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">wangcai = Dog()</span><br><span class="line"><span class="comment"># 静态方法既可以使用对象访问又可以使用类访问</span></span><br><span class="line">wangcai.info_print()</span><br><span class="line">Dog.info_print()</span><br></pre></td></tr></table></figure>
<h3 id="第十章-模块和包"><a href="#第十章-模块和包" class="headerlink" title="第十章 模块和包"></a>第十章 模块和包</h3><h4 id="10-1-模块"><a href="#10-1-模块" class="headerlink" title="10.1 模块"></a>10.1 模块</h4><p>Python 模块(Module)，是一个 Python文件，以 .py 结尾，包含了Python对象定义和Python语句句。模块能定义函数，类和变量，模块里也能包含可执行的代码。</p>
<h5 id="一-导入模块"><a href="#一-导入模块" class="headerlink" title="(一) 导入模块"></a>(一) 导入模块</h5><ul>
<li>import 模块名</li>
<li>from 模块名 import 功能名</li>
<li>from 模块名 import *</li>
<li>import 模块名 as 别名</li>
<li>from 模块名 import 功能名 as 别名</li>
</ul>
<h5 id="二-制作模块"><a href="#二-制作模块" class="headerlink" title="(二) 制作模块"></a>(二) 制作模块</h5><p>在Python中，每个Python文件都可以作为一个模块，模块的名字就是文件的名字。也就是说自定义模块名必须要符合标识符命名规则。</p>
<p><strong>(1) 定义模块</strong></p>
<p>新建一个Python文件，命名为<code>my_module1.py</code> ，并定义<code>testA</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testA</span>(<span class="params">a, b</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure>
<p><strong>(2) 测试模块</strong></p>
<p>在实际开中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如在<code>my_module1.py</code>文件中添加测试代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testA</span>(<span class="params">a, b</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(a + b)</span><br><span class="line">    </span><br><span class="line">testA(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>此时，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行testA函数的调用。解决办法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testA</span>(<span class="params">a, b</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(a + b)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行testA函数调用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	testA(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>__name__</code>是一个系统变量，当在自己文件内时其值为<code>__main__</code>，当在其他文件调用时其值为文件名</p>
</blockquote>
<p><strong>(3) 调用模块</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> my_module1</span><br><span class="line">my_module1.testA(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>(4) 注意事项</strong></p>
<p>如果使用<code>from .. import ..</code>或<code>from .. import *</code>导入多个模块的时候，且模块内有同名功能。当调用这个同名功能的时候，调用到的是<strong>后面导入的模块的功能</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my_module1: 模块1代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_test</span>(<span class="params">a, b</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(a + b)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># my_module2:模块2代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_test</span>(<span class="params">a, b</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(a - b)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 导入模块和调⽤用功能代码</span></span><br><span class="line"><span class="keyword">from</span> my_module1 <span class="keyword">import</span> my_test</span><br><span class="line"><span class="keyword">from</span> my_module2 <span class="keyword">import</span> my_test</span><br><span class="line"><span class="comment"># my_test函数是模块2中的函数</span></span><br><span class="line">my_test(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
<h5 id="三-模块定位顺序"><a href="#三-模块定位顺序" class="headerlink" title="(三) 模块定位顺序"></a>(三) 模块定位顺序</h5><p>当导入一个模块，Python解析器对模块位置的搜索顺序是：</p>
<ol>
<li>当前目录</li>
<li>如果不在当前目录，Python则搜索在shell变量PYTHONPATH下的每个目录。</li>
<li>如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。<br>注意：</li>
</ol>
<ul>
<li>自己的文件名不要和已有模块名重复，否则导致模块功能无法使用</li>
<li>使用<code>from 模块名 import 功能</code>时，若功能名字和自己定义的函数名重复，调用到的是最后定义或导入的功能。</li>
<li>使用<code>import 模块名</code>时，则会导致名字覆盖</li>
</ul>
<h5 id="四-all-变量"><a href="#四-all-变量" class="headerlink" title="(四) __all__变量"></a>(四) <code>__all__</code>变量</h5><p>如果一个模块文件中有<code>__all__</code>变量，当使用<code>from xxx import *</code>导入时，只能导入这个列表中的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my_module1模块代码</span></span><br><span class="line">__all__ = [<span class="string">&#x27;testA&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testA</span>():</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;testA&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testB</span>():</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;testB&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>导入模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_module1 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">testA() <span class="comment"># &#x27;testA&#x27;</span></span><br><span class="line">testB() <span class="comment"># __all__列表没有testB，调用报错</span></span><br></pre></td></tr></table></figure>
<h4 id="10-2-包"><a href="#10-2-包" class="headerlink" title="10.2 包"></a>10.2 包</h4><p>包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为<code>__init__.py</code>文件，那么这个文件夹就称之为包。</p>
<h5 id="一-制作包"><a href="#一-制作包" class="headerlink" title="(一) 制作包"></a>(一) 制作包</h5><p>[New] — [Python Package] — 输入包名 — [OK] — 新建功能模块(有联系的模块)。<br>注意：新建包后，包内部会自动创建<code>__init__.py</code>文件，这个文件控制着包的导入行为。</p>
<p><strong>(1) 快速示例</strong></p>
<ol>
<li>新建包mypackage</li>
<li>新建包内模块： my_module1 和 my_module2</li>
<li>模块内代码如下</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my_module1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info_print1</span>():</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;my_module1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my_module2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info_print2</span>():</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;my_module2&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="二-导入包"><a href="#二-导入包" class="headerlink" title="(二) 导入包"></a>(二) 导入包</h5><p><strong>(1) 方法一</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.模块名</span><br><span class="line"><span class="comment"># 调用方法</span></span><br><span class="line">包名.模块名.目标函数</span><br></pre></td></tr></table></figure>
<p><strong>(2) 方法二</strong></p>
<p>注意：必须在<code>__init__.py</code>文件中添加<code>__all__ = []</code>，控制允许导入的模块列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> 包名 <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 调用方法</span></span><br><span class="line">模块名.目标</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> *</span><br><span class="line">my_module1.info_print1()</span><br></pre></td></tr></table></figure>
<h3 id="第十一章-异常处理"><a href="#第十一章-异常处理" class="headerlink" title="第十一章 异常处理"></a>第十一章 异常处理</h3><hr>
<ul>
<li>Python的模块(module)、包(package)和库的区别<ul>
<li>模块(module)其实就是文件，里面定义了一些函数、类、变量等，可以作为module的文件类型有”.py”、”.pyo”、”.pyc”、”.pyd”、”.so”、”.dll” 等；</li>
<li>包(package)是多个模块module的聚合体形成的文件夹，里面可以是多个py文件，也可以嵌套文件夹；</li>
<li>库是参考其他编程语言的说法，是指完成一定功能的代码集合，在python中的形式就是模块和包；</li>
</ul>
</li>
<li>如何导入python包和模块<ul>
<li>模块的导入 就是直接import文件名即可 ；</li>
<li>导入包不能随便使用其中的模块，要导入到具体模块或者变量的层次 </li>
</ul>
</li>
</ul>
<h3 id="第十二章-OS、SYS和argparse模块"><a href="#第十二章-OS、SYS和argparse模块" class="headerlink" title="第十二章 OS、SYS和argparse模块"></a>第十二章 OS、SYS和argparse模块</h3><h4 id="12-1-OS模块"><a href="#12-1-OS模块" class="headerlink" title="12.1 OS模块"></a>12.1 OS模块</h4><h5 id="一-OS模块定义"><a href="#一-OS模块定义" class="headerlink" title="(一) OS模块定义"></a>(一) OS模块定义</h5><p>在自动化过程当中，经常需要<strong>查找操作文件</strong>，比如说查找配置文件(从而读取配置文件的信息)，查找测试报告(从而发送测试报告邮件)，经常要对大量文件和大量路径进行操作，这就依赖于<code>os</code>模块。</p>
<h5 id="二-OS模块常用方法"><a href="#二-OS模块常用方法" class="headerlink" title="(二) OS模块常用方法"></a>(二) OS模块常用方法</h5><div class="table-container">
<table>
<thead>
<tr>
<th>当前路径以及路径下的文件</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>os.getcwd()</code></td>
<td>查看当前所在路径</td>
</tr>
<tr>
<td><code>os.pardir</code></td>
<td>获取当前目录的父目录（上一级目录），以字符串形式显示目录名</td>
</tr>
<tr>
<td><code>os.listdir(path)</code></td>
<td>列举目录下的所有文件。返回的是列表类型。</td>
</tr>
<tr>
<td><code>os.path.abspath(path)</code></td>
<td>返回path的绝对路径。</td>
</tr>
<tr>
<td><code>os.path.join(path1, path2)</code></td>
<td>将path进行组合，若其中有绝对路径，则之前的path将被删除。</td>
</tr>
<tr>
<td><code>os.path.exists(path)</code></td>
<td>path：要判断的路径，可用绝对路径，也可用相对路径。<br>返回值：给定的路径存在则返回 True，否则返回 False。</td>
</tr>
<tr>
<td><code>os.path.dirname(path)</code></td>
<td>返回path中的文件夹部分，结果不包含\</td>
</tr>
<tr>
<td><code>os.path.basename(path)</code></td>
<td>返回path中的文件名</td>
</tr>
<tr>
<td><code>os.path.getsize()</code></td>
<td>文件或文件夹的大小</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意：</p>
<p><code>path</code>参数不写，默认当前项目路径，若写，则既可使用绝对路径<code>r&quot;E:\A.毕业设计\前期基础知识学习\deep learning project\MINIST-master\data&quot;</code>，又可使用相对路径<code>r&quot;.\dataset&quot;</code>(当前项目路径下的子文件夹dataset)</p>
<p><code>os.path</code>模块的更多函数参考：<a href="https://www.jb51.net/python/293897rnc.htm">Python常用基础模块之os.path模块详解</a></p>
</blockquote>
<h5 id="三-示例"><a href="#三-示例" class="headerlink" title="(三) 示例"></a>(三) 示例</h5><p>假设你当前所在的路径为<code>D:\Github_Project\UNet_Demo\datasets\cat\SegmentationClass</code>，下面有几个任务：</p>
<ul>
<li>① 统计当前目录下有几个<code>.txt</code>文件：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    # 绝对路径(Windows格式1)</span></span><br><span class="line"><span class="string">    directory_path = R&#x27;D:\Github_Project\UNet_Demo\datasets\cat\SegmentationClass\&#x27;</span></span><br><span class="line"><span class="string">    # 绝对路径(Windows格式2)</span></span><br><span class="line"><span class="string">    directory_path = &#x27;D:\\Github_Project\\UNet_Demo\\datasets\\cat\\SegmentationClass\&#x27;</span></span><br><span class="line"><span class="string">    # 绝对路径(Linux格式)</span></span><br><span class="line"><span class="string">    directory_path = &#x27;D:/Github_Project/UNet_Demo/datasets/cat/SegmentationClass/&#x27;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 相对路径</span></span><br><span class="line">    directory_path = <span class="string">&#x27;./&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> os.scandir(directory_path):</span><br><span class="line">        <span class="keyword">if</span> entry.name.endswith(<span class="string">&#x27;.txt&#x27;</span>) <span class="keyword">and</span> entry.is_file():</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Number of .txt files: <span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>统计<code>D:\Github_Project\UNet_Demo\my_folder</code>目录下有几个<code>.txt</code>文件：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    简单分析，当前路径为D:\Github_Project\UNet_Demo\datasets\cat\SegmentationClass\，则易知D:\Github_Project\UNet_Demo\my_folder相对于当前路径为【上级目录cat的上级目录datasets的上级目录UNet_Demo下的my_folder】，采用Linux的相对路径表示方法为【../../../my_folder/】</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    # 绝对路径(Windows格式1)</span></span><br><span class="line"><span class="string">    directory_path = R&#x27;D:\Github_Project\UNet_Demo\datasets\cat\SegmentationClass\&#x27;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 相对路径</span></span><br><span class="line">    directory_path = <span class="string">&#x27;../../../my_folder/&#x27;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> os.scandir(directory_path):</span><br><span class="line">        <span class="keyword">if</span> entry.name.endswith(<span class="string">&#x27;.txt&#x27;</span>) <span class="keyword">and</span> entry.is_file():</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Number of .txt files: <span class="subst">&#123;count&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h4 id="12-2-SYS模块"><a href="#12-2-SYS模块" class="headerlink" title="12.2 SYS模块"></a>12.2 SYS模块</h4><h5 id="一-SYS模块定义"><a href="#一-SYS模块定义" class="headerlink" title="(一) SYS模块定义"></a>(一) SYS模块定义</h5><p><code>OS</code>标准库是<strong>操作系统</strong>接口模块，提供了操作系统相关功能的调用函数。 Python的os模块是用于与操作系统进行交互的模块,它提供了许多函数和方法来执行文件和目录操作、进程管理、环境变量访问等 </p>
<p>而<code>sys</code>模块是与<strong>python解释器</strong>交互的一个接口。sys 模块提供了许多函数和变量来处理 Python 运行时环境的不同部分。 可以用于获取命令行参数、控制程序的执行、管理模块和包、处理异常等。 </p>
<h5 id="二-SYS模块常用方法"><a href="#二-SYS模块常用方法" class="headerlink" title="(二) SYS模块常用方法"></a>(二) SYS模块常用方法</h5><ul>
<li><strong>命令行参数</strong></li>
</ul>
<p><code>sys</code>模块提供了一些函数和变量用于获取和处理命令行参数。</p>
<p><code>sys.argv</code>：是一个包含命令行参数的列表，其中第一个元素是脚本的名称。可以使用<code>sys.argv[1:]</code>来获取除脚本名称外的所有参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.argv[<span class="number">0</span>]		<span class="comment"># 是脚本的名称。</span></span><br><span class="line">sys.argv[<span class="number">1</span>:]	<span class="comment"># 是除脚本名称外的所有参数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========例子=====================</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 获取脚本的名称</span></span><br><span class="line">script_name = sys.argv[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;脚本名称：&quot;</span>, script_name)</span><br><span class="line"><span class="comment"># 获取除脚本名称外的所有参数</span></span><br><span class="line">args = sys.argv[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;参数列表：&quot;</span>, args)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>系统相关</strong></li>
</ul>
<p><code>sys</code>模块还提供了一些函数和变量用于与系统相关的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.platform	<span class="comment"># 是一个字符串，表示当前运行的操作系统平台。</span></span><br><span class="line">sys.version		<span class="comment"># 是一个字符串，表示当前Python解释器的版本。</span></span><br><span class="line">sys.exit([arg])	<span class="comment"># 用于退出程序，可选地指定一个整数参数作为退出状态码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========例子=====================</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 获取当前操作系统平台</span></span><br><span class="line">platform = sys.platform</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;操作系统平台：&quot;</span>, platform)</span><br><span class="line"><span class="comment"># 获取当前Python解释器的版本</span></span><br><span class="line">version = sys.version</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python版本：&quot;</span>, version)</span><br><span class="line"><span class="comment"># 退出程序</span></span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>模块和包</strong></li>
</ul>
<p><code>sys</code>模块还提供了一些函数和变量用于管理模块和包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.modules		<span class="comment"># 是一个字典，包含了当前已导入的所有模块。</span></span><br><span class="line">sys.path		<span class="comment"># 是一个列表，包含了Python解释器在搜索模块时要查找的路径。</span></span><br><span class="line">sys.meta_path	<span class="comment"># 是一个列表，包含了当前已注册的所有导入钩子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========例子=====================</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 获取已导入的所有模块</span></span><br><span class="line">modules = sys.modules</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;已导入的模块：&quot;</span>, modules)</span><br><span class="line"><span class="comment"># 获取模块搜索路径</span></span><br><span class="line">path = sys.path</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;模块搜索路径：&quot;</span>, path)</span><br><span class="line"><span class="comment"># 获取已注册的导入钩子</span></span><br><span class="line">meta_path = sys.meta_path</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;已注册的导入钩子：&quot;</span>, meta_path)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>异常处理</strong></li>
</ul>
<p><code>sys</code>模块还提供了一些函数和变量用于处理异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sys.exc_info()		<span class="comment"># 返回当前异常的相关信息，包括异常类型、异常值和异常追踪信息。</span></span><br><span class="line">sys.exc_clear()		<span class="comment"># 清除当前异常。</span></span><br><span class="line">sys.exc_type		<span class="comment"># 是一个变量，保存了当前异常的类型。</span></span><br><span class="line">sys.exc_value		<span class="comment"># 是一个变量，保存了当前异常的值。</span></span><br><span class="line">sys.exc_traceback	<span class="comment"># 是一个变量，保存了当前异常的追踪信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ==========例子=====================</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 产生一个异常</span></span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;发生了一个错误&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># 获取当前异常的相关信息</span></span><br><span class="line">    exc_type, exc_value, exc_traceback = sys.exc_info()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异常类型：&quot;</span>, exc_type)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异常值：&quot;</span>, exc_value)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;异常追踪信息：&quot;</span>, exc_traceback)</span><br><span class="line">    <span class="comment"># 清除当前异常</span></span><br><span class="line">    sys.exc_clear()</span><br></pre></td></tr></table></figure>
<h4 id="12-3-argparse模块"><a href="#12-3-argparse模块" class="headerlink" title="12.3 argparse模块"></a>12.3 argparse模块</h4><p><a href="https://www.bilibili.com/video/BV1mv411G7xV/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b11850f360abfce51bee36035b825020">一个简单的argparse基础用法讲解视频 - bilibili</a><br><a href="https://www.bilibili.com/video/BV1jM4m1176F/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b11850f360abfce51bee36035b825020">深度学习基础 ｜ argparse 模块 ｜ 命令行参数解析 - bilibili</a></p>
<ul>
<li><code>argparse</code> 是一个用来解析命令行参数和选项的 Python 库，它是 Python 标准库的一部分。<ul>
<li>argparse 模块使<strong>编写用户友好的命令行界面变得容易</strong>。</li>
<li><strong>程序定义了所需的参数，而 argparse 将找出如何从 sys.argv 中解析这些参数。</strong></li>
<li>argparse 模块还会自动生成帮助和使用消息，并在用户为程序提供无效参数时发出错误。</li>
<li>简而言之，就是汇总函数接口，方便传参。</li>
</ul>
</li>
</ul>
<h5 id="一-argparse定义四个步骤"><a href="#一-argparse定义四个步骤" class="headerlink" title="(一 ) argparse定义四个步骤"></a>(一 ) argparse定义四个步骤</h5><ul>
<li>导入argparse包 —— <code>import argparse</code></li>
<li>创建一个命令行解析器对象 —— 创建 <code>ArgumentParser()</code> 对象</li>
<li>给解析器添加命令行参数 —— 调用 <code>add_argument()</code> 方法添加参数</li>
<li>解析命令行的参数 —— 使用 <code>parse_args()</code> 解析添加的参数</li>
</ul>
<h5 id="二-argparse的使用场景举例"><a href="#二-argparse的使用场景举例" class="headerlink" title="(二) argparse的使用场景举例"></a>(二) argparse的使用场景举例</h5><p>在深度学习代码中，特别是在<code>train.py</code>或<code>test.py</code>中，<code>argparse</code>最常被使用。</p>
<p>因为在这些文件中，通常要对其他.py文件中定义的class或function进行调用，因此必然要传入大量的参数，如果不对这些参数进行集中编写，那么在冗长的代码中去找参数的定义位置或传参的位置将会十分麻烦。</p>
<p><code>argparse</code>为用户提供了集中编写所需参数的机会，下面的使用教程中我会结合简单而具体的例子进行说明。</p>
<h5 id="三-具体使用流程"><a href="#三-具体使用流程" class="headerlink" title="(三) 具体使用流程"></a>(三) 具体使用流程</h5><ul>
<li><strong>1.创建一个解析器</strong></li>
</ul>
<p>即创建 <code>ArgumentParser()</code> 对象 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;该程序的功能是计算圆的面积&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>description：</strong>大多数对 <code>ArgumentParser</code> 构造方法的调用都会使用 <code>description= 关键字参数</code>。</p>
<p>这个参数简要描述这个程度做什么以及怎么做。</p>
<p>在帮助消息中，这个描述会显示在命令行用法字符串和各种参数的帮助消息之间。</p>
<ul>
<li><strong>2.添加参数</strong></li>
</ul>
<p>即调用 <code>add_argument()</code> 方法添加参数 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--binary&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>, </span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;action=store_true表示默认为False，当在命令行中使用--binary时自动变为True&#x27;</span>)</span><br><span class="line">parser.add argument(<span class="string">&#x27;--number&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">6</span>，<span class="built_in">help</span>=<span class="string">&#x27;普通数据，type可指定类型.&#x27;</span>)</span><br><span class="line">                    </span><br><span class="line">parser.add argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">300</span>, <span class="built_in">help</span>=<span class="string">&#x27;Number of epochs to train.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里说一下如何定义参数的格式 </p>
<p><code>ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])</code></p>
<ul>
<li><strong>name or flags：选项字符串的名字或者列表，例如 foo 或者 -f, —foo； action：命令行遇到参数时的动作，默认值是 store； store_const：表示赋值为const；</strong></li>
<li><strong>default ：不指定参数时的默认值。</strong></li>
<li><strong>type：命令行参数应该被转换成的类型；</strong></li>
<li><strong>choices：参数可允许的值的一个容器；</strong></li>
<li><strong>nargs ：应该读取的命令行参数个数，可以是具体的数字，或者是?号，当不指定值时对于 Positional argument 使用 default，对于 Optional argument 使用 const；或者是 * 号，表示 0 或多个参数；或者是 + 号表示 1 或多个参数。</strong></li>
<li><strong>required：可选参数是否可以省略 (仅针对可选参数)。</strong></li>
<li><strong>help：参数的帮助信息，当指定为 argparse.SUPPRESS 时表示不显示该参数的帮助信息.</strong></li>
<li><strong>metavar：在 usage 说明中的参数名称，对于必选参数默认就是参数名称，对于可选参数默认是全大写的参数名称</strong></li>
<li>dest：解析后的参数名称，默认情况下，对于可选参数选取最长的名称，中划线转换为下划线.</li>
<li>const：action 和 nargs 所需要的常量值。</li>
<li>append：将遇到的值存储成列表，也就是如果参数重复则会保存多个值; append_const：将参数规范中定义的一个值保存到一个列表；</li>
<li>count：存储遇到的次数；此外，也可以继承 argparse.Action 自定义参数解析；</li>
</ul>
</blockquote>
<ul>
<li><strong>3.解析参数</strong></li>
</ul>
<p>即使用 <code>parse_args()</code> 解析添加的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>
<h5 id="四-简单而具体的例子"><a href="#四-简单而具体的例子" class="headerlink" title="(四) 简单而具体的例子"></a>(四) 简单而具体的例子</h5><p>例如我现在有一个.py文件，我现在定义了好多好多函数（为了方便我只定义了两个），我现在需要集中管理我传入的参数，使用argparse就会非常方便，对于本.py文件中的传参一目了然。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--spring&#x27;</span> ,action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;nothing.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--summer&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">6</span>, <span class="built_in">help</span>=<span class="string">&#x27;num.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--fa11&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">11</span>, <span class="built_in">help</span>=<span class="string">&#x27;num.&#x27;</span>)</span><br><span class="line">parser.add argument(<span class="string">&#x27;--winter&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">100</span>, <span class="built_in">help</span>=<span class="string">&#x27;Number of epochs to train.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="comment"># FLAGs，unparsed = parser.parse_known_args() 这种解析方法用的比较少，有兴趣可以了解一下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_function</span>(<span class="params">num2sum_1, num2sum_2</span>):</span></span><br><span class="line">    sum_result = num2sum_1+num2sum_2</span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply_function</span>(<span class="params">num2multiply_1, num2multiply_2</span>):</span></span><br><span class="line">    multiply_result = num2multiply_1*num2multiply_2</span><br><span class="line">    <span class="keyword">return</span> multiply_result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;args.spring的值是&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(args.spring))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;args.summer的值是&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(args.summer))</span><br><span class="line"><span class="built_in">print</span>(sum_function(args.summer,args.fall))</span><br><span class="line"><span class="built_in">print</span>(multiply_function(args.summer,args.winter))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line"><span class="comment"># args.spring的值是False</span></span><br><span class="line"><span class="comment"># args.summer的值是6</span></span><br><span class="line"><span class="comment"># 17</span></span><br><span class="line"><span class="comment"># 600</span></span><br></pre></td></tr></table></figure>
<p>你可以发现，对本文件中的函数进行传参，无论有多少参数需要传，我们只要在argparse中写好需要传的参数，在传参时传入<strong>args.参数名</strong>，需要修改传参值时，统一在argparse中进行修改即可，这样就方便了参数的管理。 </p>
<h5 id="五-如何修改参数值"><a href="#五-如何修改参数值" class="headerlink" title="(五) 如何修改参数值"></a>(五) 如何修改参数值</h5><ul>
<li>第一，对于有default的参数，直接修改default的值即可；</li>
<li>第二，用命令行运行，例如在上面举例的程序，我如果想把summer的值改为10，fall的值改为20，那么命令行指令就是：python train.py —summer 10 —fall 20；如果我同时还想让spring的值成为True，那么命令行指令为：python train.py —summer 10 —fall 20 —spring</li>
<li>第三，在Edit Configurations中进行配置，然后run即可：</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66950883d9c307b7e96a5f63.png" alt="image.png"></p>
<ul>
<li>在 Python 的 <code>argparse</code> 模块中，位置参数不能使用 <code>default</code> 参数。因为定位参数是必需的，它们必须始终由用户提供，而不能使用默认值。 </li>
<li>在 Python 的 <code>argparse</code> 模块中，位置参数不能使用<code>action</code>参数，<code>action=&quot;store_true&quot;</code> 用于创建布尔开关，但它不适用于必需的位置参数。位置参数不应该使用 <code>action=&quot;store_true&quot;</code>。 </li>
</ul>
<hr>
<p>参考笔记：E:\A.毕业设计\前期基础知识学习\01-Python基础课件.pdf</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
        <category>编程语言学习</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>Python编程基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch基础</title>
    <url>/2022/04/24/Foundation-of-Pytorch/</url>
    <content><![CDATA[<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1hE411t7RN" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/aedf385ac09752547290e85319b88081c812cf06.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">09:50:38</span>
            </div>
            <div class="bvideo-info">
                <p class="title">PyTorch深度学习快速入门教程（绝对通俗易懂！）【小土堆】</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>635.8万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>5.7万</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">我是土堆</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<h3 id="第一章-Pytorch加载数据"><a href="#第一章-Pytorch加载数据" class="headerlink" title="第一章 Pytorch加载数据"></a>第一章 Pytorch加载数据</h3><h4 id="1-1-Pytorch加载数据初识"><a href="#1-1-Pytorch加载数据初识" class="headerlink" title="1.1 Pytorch加载数据初识"></a>1.1 Pytorch加载数据初识</h4><h5 id="一-常见的数据组织形式"><a href="#一-常见的数据组织形式" class="headerlink" title="(一) 常见的数据组织形式"></a>(一) 常见的数据组织形式</h5><ul>
<li>每一类事物分别放在单独的文件夹内，文件夹的名称即为该类的名字；</li>
<li>将数据集划分为训练集和测试集两个文件夹(即每类事物混合放)，并会提供一个训练集的数据对应的label文件；</li>
<li>直接在数据文件的命名中体现出label名。</li>
</ul>
<h5 id="二-使用的类"><a href="#二-使用的类" class="headerlink" title="(二) 使用的类"></a>(二) 使用的类</h5><p>pytorch中加载数据主要涉及两个类——<strong><font clolor="red">Dataset、Dataloader</font></strong>。</p>
<p>直白的说：</p>
<ul>
<li><strong>Dataset作用</strong>：提供一种方式获取数据以及数据对应的label，获取总共有多少数据；</li>
<li><strong>Dataloader作用</strong>：为后面的网络提供不同的数据形式，如：mini_batch大小、是否打乱等。</li>
</ul>
<blockquote>
<p>我们在打扑克，一摞的扑克牌就相当于dataset，拿牌的手相当于神经网络。而dataloader相当于抽牌的过程，它可以控制我们是否打乱排，一次抽几张牌，用几只手抽牌等。</p>
</blockquote>
<h4 id="1-2-Dataset类"><a href="#1-2-Dataset类" class="headerlink" title="1.2 Dataset类"></a>1.2 Dataset类</h4><p>Dataset是一个抽象类，所有的数据集都要继承这个类，所有的子类都应该重写<code>__getitem__</code>魔法方法(获取每一个数据及其对应的label)，可以选择重写<code>__len__</code>魔法方法(获取数据的总长度)</p>
<p>在Python中我们可以使用<code>__getitem__</code>、<code>__len__</code>等方法去创建类似于<strong>序列和映射</strong>的类。这种方法的好处是可以像列表一样使用索引功能访问元素。</p>
<blockquote>
<p>Python中常见的数据结构可以统称为<strong>容器(container)</strong>。序列(如列表和元组)、映射(如字典)以及集合(set)是三类主要的容器。   </p>
</blockquote>
<h5 id="一-getitem-魔法方法"><a href="#一-getitem-魔法方法" class="headerlink" title="(一) __getitem__()魔法方法"></a>(一) <code>__getitem__()</code>魔法方法</h5><p>如果在类中定义了<code>__getitem__()</code>方法，那么他的实例对象（假设为P）就可以这样<code>P[idx]</code>取值。当实例对象做<code>P[idx]</code>运算时，就会调用类中的<code>__getitem__()</code>方法。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataTest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">id</span>, address</span>):</span></span><br><span class="line">        self.<span class="built_in">id</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">        self.address = address</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, idx</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;调用了__getitem__方法&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">id</span>[idx]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = DataTest(<span class="number">1</span>, <span class="string">&quot;192.168.2.11&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(data[<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 调用了__getitem__方法</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<h5 id="二-len-魔法方法"><a href="#二-len-魔法方法" class="headerlink" title="(二) __len__()魔法方法"></a>(二) <code>__len__()</code>魔法方法</h5><p>如果一个类表现得像一个list，要获取有多少个元素，就得用<code>len()</code>函数。要让<code>len()</code>函数工作正常，类必须提供一个特殊方法<code>__len__()</code>，它返回元素的个数。</p>
<ul>
<li>类的对象能否使用<code>len()</code>函数，仅仅取决于其是否实现了<code>__len__()</code>函数而已。正如基本的str，tuple，list，dict，set等，它们可以使用<code>len()</code>函数，也仅仅是因为它们的类实现了<code>__len__()</code>函数而已； </li>
<li>自己创建的类和python中的基础类型（int,float,str,tuple,forzenset,list,set,dict）等均是平等的地位， 差别仅在于您自己创建的类中是否实现了与这些基础类中相同的功能(或者魔术函数)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如，写一个Students类，把名字传进去：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Students</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        self.names = args</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.names)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 只要正确实现了__len__()方法，就可以用len()函数返回Students实例的“长度”：</span></span><br><span class="line">ss = Students(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Tim&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(ss))</span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-Tensorboard类"><a href="#1-3-Tensorboard类" class="headerlink" title="1.3 Tensorboard类"></a>1.3 Tensorboard类</h4><h5 id="一-Tensorboard介绍"><a href="#一-Tensorboard介绍" class="headerlink" title="(一) Tensorboard介绍"></a>(一) Tensorboard介绍</h5><p>Tensorboard原本是Google TensorFlow的可视化工具，可以用于记录训练数据、评估数据、网络结构、图像等，并且可以在web上展示，对于观察神经网络的过程非常有帮助。PyTorch也推出了自己的可视化工具，一个是tensorboardX包，一个是<code>torch.utils.tensorboard</code>，二者的使用相差不大。</p>
<h5 id="二-Tensorboard的使用"><a href="#二-Tensorboard的使用" class="headerlink" title="(二) Tensorboard的使用"></a>(二) Tensorboard的使用</h5><p>首先展示该包的使用的大致流程 </p>
<ul>
<li>Step1：导入tensorboard，实例化SummaryWriter类，指明记录日记路径等信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="comment"># 实例化SummaryWriter，并指明日志存放路径。在当前目录如果每月logs目录将自动创建</span></span><br><span class="line"><span class="comment"># 如果不写log_dir，系统将会创建runs目录</span></span><br><span class="line">writer = SummaryWriter(log_dir = ‘logs’)</span><br><span class="line"><span class="comment"># 调用实例</span></span><br><span class="line">writer.add_xxx()</span><br><span class="line"><span class="comment"># 关闭writer</span></span><br><span class="line">writer.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Step2：调用相应的API，接口一般格式为：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_xxx(tag_name, <span class="built_in">object</span>, iteration-number)</span><br></pre></td></tr></table></figure>
<ul>
<li>Step3：启动tensorboard，在命令行中输入</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir=r’加logs所在路径’</span><br></pre></td></tr></table></figure>
<ul>
<li>Step4：复制网址在浏览器中打开</li>
</ul>
<h5 id="三-使用各种add方法记录数据"><a href="#三-使用各种add方法记录数据" class="headerlink" title="(三) 使用各种add方法记录数据"></a>(三) 使用各种add方法记录数据</h5><p><strong>(1) 单条曲线(scalar)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_scalar(tag, scalar_value, global_step=<span class="literal">None</span>, walltime=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>参数：</strong><ul>
<li>tag ( string ) – 数据标识符</li>
<li>scalar_value ( float或string/blobname ) – 要保存的值(对应Y轴)</li>
<li>global_step ( int ) – 要记录的全局步长值(对应X轴)</li>
<li>walltime ( float ) – 记录训练的时间，默认 walltime (time.time()) 秒</li>
<li>new_style ( boolean ) – 是使用新样式（张量字段）还是旧样式（simple_value 字段）。新样式可能会导致更快的数据加载。</li>
</ul>
</li>
</ul>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>) :</span><br><span class="line">    writer.add_scalar(<span class="string">&#x27;y = 2x&#x27;</span>, x, <span class="number">2</span> * x)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p><strong>(2) 多条曲线(scalars)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_scalars( main_tag , tag_scalar_dict , global_step = <span class="literal">None</span> , walltime = <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>参数：</strong><ul>
<li>main_tag ( string ) – 标签的父名称</li>
<li>tag_scalar_dict ( dict ) – 存储标签和对应值的键值对</li>
<li>global_step ( int ) – 要记录的全局步长值</li>
<li>walltime ( float ) – 记录训练的时间，默认 walltime (time.time()) 秒</li>
</ul>
</li>
</ul>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter()</span><br><span class="line">r = <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>) :</span><br><span class="line">    writer.add_scalars(<span class="string">&#x27;run_14h&#x27;</span>, &#123;<span class="string">&#x27;xsinx&#x27;</span> : x * np.sin(x / r), </span><br><span class="line">                                  <span class="string">&#x27;xcosx&#x27;</span> : x * np.cos(x / r), </span><br><span class="line">                                  <span class="string">&#x27;xtanx&#x27;</span> : x * np.tan(x / r)&#125;, x)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p><strong>(3) 图片(image)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add_image(tag, img_tensor, global_step=<span class="literal">None</span>, walltime=<span class="literal">None</span>, dataformats = ‘CHW’)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>参数：</strong><ul>
<li>tag ( string ) – 数据标识符</li>
<li>img_tensor ( torch.Tensor , numpy.array , or string/blobname ) – 图像数据</li>
<li>global_step ( int ) – 要记录的全局步长值</li>
<li>walltime ( float ) – 记录训练的时间，默认 walltime (time.time()) 秒</li>
</ul>
</li>
</ul>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">&#x27;zhou.jpg&#x27;</span>, cv.IMREAD_COLOR)<span class="comment">#输入图像要是3通道的，所以读取彩色图像</span></span><br><span class="line">img = cv.cvtColor(img, cv.COLOR_BGR2RGB)</span><br><span class="line">img = torch.tensor(img.transpose(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))<span class="comment">#cv读取为numpy图像为(H * W * C)，所以要进行轴转换</span></span><br><span class="line">writer.add_image(<span class="string">&#x27;zhou_ge&#x27;</span>, img, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p><strong>(4) 其他</strong></p>
<p>直方图(histogram)、渲染(figure)、网络(graph)等。</p>
<blockquote>
<p>请参考博文：<a href="https://blog.csdn.net/weixin_53598445/article/details/121301078">详解Tensorboard及使用教程 - 八岁爱玩耍 - CSDN</a></p>
</blockquote>
<h4 id="1-4-Transforms类"><a href="#1-4-Transforms类" class="headerlink" title="1.4 Transforms类"></a>1.4 Transforms类</h4><h5 id="一-Transforms结构"><a href="#一-Transforms结构" class="headerlink" title="(一) Transforms结构"></a>(一) Transforms结构</h5><p>torchvision 中的 transforms 主要是对图片进行一些变换。</p>
<p>tranforms对应 tranforms.py 文件，里面定义了很多类，输入一个图片对象，返回经过处理的图片对象。</p>
<p>transforms 更多指的是python文件，transforms.py 就像一个工具箱，里面定义的各种类就像各种工具，特定格式的图片就是输入对象，经过工具处理，输出期望的图片结果。 </p>
<p><img src="https://pic.imgdb.cn/item/62661394239250f7c57c4a9c.jpg" style="zoom:50%"></p>
<h5 id="二-Python中的用法"><a href="#二-Python中的用法" class="headerlink" title="(二) Python中的用法"></a>(二) Python中的用法</h5><p>使用 transforms 的方法就是先实例化选中的类，然后用实例化的对象去处理图片就行。 </p>
<h5 id="三-补充：ToTensor"><a href="#三-补充：ToTensor" class="headerlink" title="(三) 补充：ToTensor"></a>(三) 补充：ToTensor</h5><p>将第一节中的代码复制到 python 控制台，回车，可在右侧看到各种变量和对象的具体信息： </p>
<p>tensor 数据类型可以理解为包装了反向神经网络一些理论基础参数。在神经网络中，要将数据先转换为Tensor类型，再进行训练。</p>
<h5 id="四-图像的读取与显示"><a href="#四-图像的读取与显示" class="headerlink" title="(四) 图像的读取与显示"></a>(四) 图像的读取与显示</h5><p><strong>(1) 图像读取</strong></p>
<p>之前PIL image已经学会了读取，numpy.ndarray 最常用的读取方法就是 opencv。 </p>
<ul>
<li><p>区别1</p>
<ul>
<li>img = cv2.imread(path)，这是opencv中的处理图片的函数，使用时需 import cv2  </li>
<li>img = Image.open(path)，这是PIL中的一个处理图片的函数，使用时需 from PIL import Image </li>
</ul>
</li>
<li><p>区别2</p>
<ul>
<li><p>cv2.imread()读取的是图像的真实数据</p>
</li>
<li><p>Image.open()函数只是保持了图像被读取的状态，但是图像的真实数据并未被读取，因此如果对需要操作图像每个元素，如输出某个像素的RGB值等，需要执行对象的load()方法读取数据。具体如下： </p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;lena.jpg&quot;</span>)</span><br><span class="line">img = img.load()</span><br><span class="line"><span class="built_in">print</span>(img[<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment"># result：(255, 201, 166)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>区别3</p>
<ul>
<li><p>cv2.imread()得到的img数据类型是np.array()类型</p>
</li>
<li><p>Image.open(）得到的img数据类型呢是Image对象，不是普通的数组。</p>
</li>
</ul>
</li>
<li><p>区别4</p>
<ul>
<li><p>cv2.imread()读取通道的顺序为BGR</p>
</li>
<li><p>Image.open()函数默认彩色图像读取通道的顺序为RGB</p>
</li>
</ul>
</li>
</ul>
<p><strong>(2) 图像显示</strong></p>
<p>图像显示时常见方法有两种</p>
<ul>
<li><p>一种是matplotlib的plt.imshow()方法</p>
</li>
<li><p>一种是opencv的cv2.imshow()。</p>
</li>
</ul>
<p>两个函数的<strong>输入都要求是数组</strong>。因此Image读取的图片要先转化为数组，再进行图片的显示。plt函数读入的顺序为RGB，cv2.imshow()读入的顺序是BGR。</p>
<ul>
<li><p>因此image与plt.imshow()配合使用</p>
</li>
<li><p>opencv的方法配套使用</p>
</li>
</ul>
<h5 id="五-常用的Transforms类-方法"><a href="#五-常用的Transforms类-方法" class="headerlink" title="(五) 常用的Transforms类/方法"></a>(五) 常用的Transforms类/方法</h5><p><strong>(1) ToTensor()</strong>：将图片对象类型转为 tensor</p>
<p><strong>(2) Normalize()</strong>：对图像像素进行归一化计算</p>
<p><strong>(3) Resize()</strong>：重新设置 PIL Image的大小，返回也是PIL Image格式，效果是缩放，不是裁剪</p>
<p><strong>(4) Compose()</strong>：输入为 transforms 类型参数的列表</p>
<p>Compose()中的参数需要是一个列表，python中列表的表示形式为 [数据1，数据2，…]，在 Compose 中，数据需要是 transforms 类型，所以 Cmpose( [transforms 参数1, transforms 参数2], …)</p>
<p>目的是将几个 transforms 操作打包成一个，比如要先进行大小调整，然后进行归一化计算，返回 tensor 类型，则可以将 ToTensor、Normalize、Resize，按操作顺序输入到 Compose 中。</p>
<p><strong>(5) RandomCrop</strong>：随机裁剪</p>
<h4 id="1-5-torchvision类"><a href="#1-5-torchvision类" class="headerlink" title="1.5 torchvision类"></a>1.5 torchvision类</h4><h5 id="一-简介"><a href="#一-简介" class="headerlink" title="(一) 简介"></a>(一) 简介</h5><p>在Pytorch官网，torchvision 文档列出了很多科研或者毕设常用的一些数据集，如入门数据集 MNIST，用于手写文字。这些数据集位于 torchvision.datasets 模块，可以通过该模块对数据集进行下载，转换等操作。</p>
<p>torchvision 还有 io模块，但不常用；<strong>torchvision.models 会提供一些训练好的神经网络模型</strong>，在之后会用到；torchvision.transforms 之前已经学习过了，主要提供一些数据处理的工具。</p>
<p>接下来主要讲解如何联合使用 torchvision.datasets 和 torchvision.transforms</p>
<h5 id="二-CIFAR数据集"><a href="#二-CIFAR数据集" class="headerlink" title="(二) CIFAR数据集"></a>(二) CIFAR数据集</h5><p>用到的数据集是 CIFIAR，点击官网文档进行查看。</p>
<p><strong>(1) 数据集下载</strong></p>
<p><a href="https://www.cs.toronto.edu/~kriz/cifar.html">数据集官网</a>，该数据集包含了 60000 张 32*32 像素的 10 个类别的彩色图片，每个种类 6000 张图片，其中 60000 张中 50000 张是训练图片，10000 张是测试图片。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">若有 ssl 报错，添加如下代码</span></span><br><span class="line"><span class="string">import ssl</span></span><br><span class="line"><span class="string">ssl._create_default_https_context = ssl._create_unverified_context</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">train_set = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>)</span><br><span class="line">test_set = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>然后运行，torchvision 就会自动进行 CIFAR10 数据集的下载。 </p>
<p>这里分别下载训练集和测试集，下载好后会放到所设置的路径下，这里下载的数据集会被放带当前目录的 dataset目录下。</p>
<p><strong>(2) 数据集的使用</strong></p>
<p>查看下测试数据集中每个数据包含什么：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line"></span><br><span class="line">train_set = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>)</span><br><span class="line">test_set = torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(test_set[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(test_set.classes)</span><br><span class="line"></span><br><span class="line">img, target = test_set[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(img)</span><br><span class="line"><span class="built_in">print</span>(target)</span><br><span class="line"><span class="built_in">print</span>(test_set.classes[target])</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure>
<p>即一个数据单元里包含输入图片和对应的 tag，这里用数字进行映射，数字 3 也就是表示 cat ，可用 img.show() 查看下图片。因为这个数据集比较小，只有百 MB，图片像素只有 32*32，所以模糊，这里是将其分类为猫。 </p>
<h4 id="1-6-DataLoader类"><a href="#1-6-DataLoader类" class="headerlink" title="1.6 DataLoader类"></a>1.6 DataLoader类</h4><h5 id="一-简介-1"><a href="#一-简介-1" class="headerlink" title="(一) 简介"></a>(一) 简介</h5><p><strong>dataset类</strong>：在程序中起到的作用是告诉程序数据在哪，以及每个索引所对应的数据是什么。相当于一系列的存储单元，每个单元都存储了数据。这里可以类比成一幅扑克牌，一张扑克牌就是一个数据，一幅扑克牌就是一个完整的数据集。</p>
<p><strong>dataloader类</strong>： 是一个加载器，将数据加载到神经网络中。类比成手（神经网络），dataloader 每次从dataset 中去取数据，每次取多少，怎么取，通过 dataloader 参数进行设置。用手去抓扑克牌，每次抓几张，用一只手去抓取，还是用两只手，这就是 dataloader 要做的事，可以通过参数进行一个设置。</p>
<p><a href="https://blog.csdn.net/weixin_44227733/article/details/%5Btorch.utils.data%20%E2%80%94%20PyTorch%201.10%20documentation%5D%28https%3A//pytorch.org/docs/stable/data.html?highlight=dataloader#torch.utils.data.DataLoader%29">Pytoch 官网</a>对 dataloader 的介绍，各个参数都有详细的描述，这里就不再赘述。 </p>
<p><img src="https://pic.imgdb.cn/item/62668aa5239250f7c59926e0.jpg"></p>
<h5 id="二-dataloader-的使用"><a href="#二-dataloader-的使用" class="headerlink" title="(二) dataloader 的使用"></a>(二) dataloader 的使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备的测试数据集</span></span><br><span class="line">test_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor())</span><br><span class="line">test_loader = DataLoader(dataset=test_data, batch_size=<span class="number">4</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>, drop_last=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据集中第一张图片及 target</span></span><br><span class="line">img, target = test_data[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(img.shape)  <span class="comment"># 查看图片大小</span></span><br><span class="line"><span class="built_in">print</span>(target)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;dataloader&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    <span class="comment"># print(imgs.shape)</span></span><br><span class="line">    <span class="comment"># print(targets)</span></span><br><span class="line">    writer.add_images(<span class="string">&quot;test_data&quot;</span>, imgs, step)  <span class="comment"># 注意加 s</span></span><br><span class="line">    step = step + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<p>1、shuffle打乱是指在epoch阶段打乱，不是mini_batch级打乱</p>
</blockquote>
<h3 id="第二章-神经网络的基本骨架nn-Module的使用"><a href="#第二章-神经网络的基本骨架nn-Module的使用" class="headerlink" title="第二章 神经网络的基本骨架nn.Module的使用"></a>第二章 神经网络的基本骨架nn.Module的使用</h3><h5 id="一-torch-nn简介"><a href="#一-torch-nn简介" class="headerlink" title="(一) torch.nn简介"></a>(一) torch.nn简介</h5><p>搭建<a href="https://so.csdn.net/so/search?q=%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&amp;spm=1001.2101.3001.7020">神经网络</a>常用的工具在 torch.nn 模块，<a href="https://pytorch.org/docs/stable/nn.html">官网</a></p>
<p><img src="https://pic.imgdb.cn/item/62668fd5239250f7c5a5f02b.jpg"></p>
<p>Containers 中文翻译为容器，但这里可以理解为骨架，往这个骨架中添加一些内容就可以构成一个神经网络。</p>
<p>Convolution Layers、Pooling Layers、Paading Layers 都是要添加进网络的各层。</p>
<p>Containers 中 Module 是最常用的，它是所有神经网络的基本类，给所有神经网络提供基本的骨架。</p>
<p><img src="https://pic.imgdb.cn/item/6266900d239250f7c5a68458.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/62669121239250f7c5a91eef.jpg"></p>
<h5 id="二-简单示例"><a href="#二-简单示例" class="headerlink" title="(二) 简单示例"></a>(二) 简单示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jiaolong</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="comment"># Alt+insert 可重写方法或实现方法（Windows）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        output = <span class="built_in">input</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">jiaolong = Jiaolong()</span><br><span class="line">x = torch.tensor(<span class="number">1.0</span>)  <span class="comment"># 将 1.0 这个数转换成 tensor 数据类型</span></span><br><span class="line">output = jiaolong(x)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>
<h5 id="三-卷积操作"><a href="#三-卷积操作" class="headerlink" title="(三) 卷积操作"></a>(三) 卷积操作</h5><p>略</p>
<h3 id="第三章-神经网络"><a href="#第三章-神经网络" class="headerlink" title="第三章 神经网络"></a>第三章 神经网络</h3><h5 id="一-卷积层"><a href="#一-卷积层" class="headerlink" title="(一) 卷积层"></a>(一) 卷积层</h5><p>官网 Pytorch 的 nn 模块有 Convolution Layers，有3种卷积操作，nn.Conv1d、nn.Conv2d、nn.Conv3d 分别对应一维二维以及三维。</p>
<p>注：在Pytorch 官网文档左侧，有 torch.nn 和 torch.nn.fuctional，torch.nn 是对 torch.nn.fuctional 进行了一个封装，方便用户使用。想细致的了解一些 nn 模块中的函数可以从 torch.nn.fuctional 入手。这里主要介绍 nn.Conv2d，打开 torch.nn.fuctional 对应页面，可以看到对 conv2d 函数的介绍。</p>
<p>conv2d 需要的参数有 输入 input、权重 weight（更专业的名称是卷积核）、偏置 bias、步长 stride、填充Padding等。 </p>
<blockquote>
<p>应该是对象里面实现了<code>__call__()</code>魔法方法。</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/62673ce8239250f7c50e52b6.jpg"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./data&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jiaolong</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">6</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.conv1(x)	<span class="comment"># 应该是对象里面实现了__call__()魔法方法</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">jiaolong = Jiaolong()</span><br><span class="line"><span class="built_in">print</span>(jiaolong)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    output = jiaolong(imgs)</span><br><span class="line">    <span class="built_in">print</span>(output.shape)</span><br><span class="line">    <span class="built_in">print</span>(imgs.shape)</span><br><span class="line">    <span class="comment"># torch.Size([64, 3, 32, 32])</span></span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, step)</span><br><span class="line">    <span class="comment"># torch.Size([64, 6, 30, 30]) -&gt; torch.Size([xx, 3, 30, 30])</span></span><br><span class="line">    output = torch.reshape(output, (-<span class="number">1</span>,<span class="number">3</span>, <span class="number">30</span>, <span class="number">30</span>))  <span class="comment"># 第一个数不知道是多少用 -1，它会自动根据值计算</span></span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output,step)</span><br><span class="line">    step += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/62673e27239250f7c510a187.jpg"></p>
<h5 id="二-池化层"><a href="#二-池化层" class="headerlink" title="(二) 池化层"></a>(二) 池化层</h5><p><strong>最大池化</strong>(又称“下采样”)的作用是在保存数据特征的前提下去减小数据量。 池化函数使用某一位置的相邻输出的总体统计特征来代替网络在该位置的输出。本质是将采样，可以大幅减少网络参数量。</p>
<p><img src="https://pic.imgdb.cn/item/626745b0239250f7c51dba58.jpg"></p>
<p><code>ceil_mode:</code>当ceil_mode为 True时，将用<code>ceil</code>(向上取整)模式代替<code>floor</code>(向下取整) 模式去计算输出。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> MaxPool2d</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./data&quot;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>,</span><br><span class="line">                                       transform=torchvision.transforms.ToTensor())</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">36</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 最大池化无法对 Long 数据类型进行实现</span></span><br><span class="line"><span class="string">input = torch.tensor([[1, 2, 0, 3, 1],</span></span><br><span class="line"><span class="string">                     [0, 1, 2, 3, 1],</span></span><br><span class="line"><span class="string">                     [1, 2, 1, 0, 0],</span></span><br><span class="line"><span class="string">                     [5, 2, 3, 1, 1],</span></span><br><span class="line"><span class="string">                     [2, 1, 0, 1, 1]], dtype=torch.float32)</span></span><br><span class="line"><span class="string">input = torch.reshape(input, (-1, 1, 5, 5))</span></span><br><span class="line"><span class="string">print(input.shape)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jiaolong</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.maxpool1 = MaxPool2d(kernel_size=<span class="number">3</span>, ceil_mode=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        output = self.maxpool1(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">jiaolong = Jiaolong()</span><br><span class="line"><span class="comment"># output = jiaolong(input)</span></span><br><span class="line"><span class="comment"># print(output)</span></span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs_maxpool&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, step)</span><br><span class="line">    output = jiaolong(imgs)</span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, step)</span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<h5 id="三-非线性激活"><a href="#三-非线性激活" class="headerlink" title="(三) 非线性激活"></a>(三) 非线性激活</h5><p>非线性激活主要目的就是给网络增加非线性特征，以便训练出符合要求的泛化模型。常用的有</p>
<p>ReLU函数、Sigmoid函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> ReLU</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = torch.tensor([[<span class="number">1</span>, -<span class="number">0.5</span>],</span><br><span class="line">                      [-<span class="number">1</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="built_in">input</span> = torch.reshape(<span class="built_in">input</span>, (-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.shape)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jiaolong</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        inplace 为替换的意思</span></span><br><span class="line"><span class="string">        如 input = -1 </span></span><br><span class="line"><span class="string">           ReLU(input, inplace = True)</span></span><br><span class="line"><span class="string">           input = 0</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.relu = ReLU()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        output = self.relu(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">jiaolong = Jiaolong()</span><br><span class="line">output = jiaolong(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>
<h5 id="四-正则化层Normalization"><a href="#四-正则化层Normalization" class="headerlink" title="(四) 正则化层Normalization"></a>(四) 正则化层Normalization</h5><p>将数据进行正则化可以加快神经网络的训练速度</p>
<h5 id="五-线性层"><a href="#五-线性层" class="headerlink" title="(五) 线性层"></a>(五) 线性层</h5><p>线性层又叫全连接层，其中每个神经元与上一层所有神经元相连，多看<a href="https://blog.csdn.net/weixin_44227733/article/details/%5Btorch.nn%20%E2%80%94%20PyTorch%201.10%20documentation%5D%28https%3A//pytorch.org/docs/stable/nn.html%29">官方文档</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Linear</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./data&quot;</span>, train=<span class="literal">False</span>,</span><br><span class="line">                                       transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jiaolong</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.linear = Linear(<span class="number">196608</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        output = self.linear(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">jiaolong = Jiaolong()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    <span class="built_in">print</span>(imgs.shape)</span><br><span class="line">    output = torch.flatten(imgs)  <span class="comment"># 展平</span></span><br><span class="line">    <span class="comment"># output = torch.reshape(imgs, (1, 1, 1, -1))</span></span><br><span class="line">    <span class="built_in">print</span>(output.shape)</span><br><span class="line">    output = jiaolong(output)</span><br><span class="line">    <span class="built_in">print</span>((output.shape))</span><br></pre></td></tr></table></figure>
<h5 id="六-神经网络-搭建小实战和Sequential的使用"><a href="#六-神经网络-搭建小实战和Sequential的使用" class="headerlink" title="(六) 神经网络-搭建小实战和Sequential的使用"></a>(六) 神经网络-搭建小实战和Sequential的使用</h5><p><strong>(1) Sequential的使用</strong></p>
<p>Sequential 是一个时序容器。Modules 会以他们传入的顺序被添加到容器中。包含在 <a href="https://blog.csdn.net/weixin_44227733/article/details/%5Btorch.nn%20%E2%80%94%20PyTorch%201.10%20documentation%5D%28https%3A//pytorch.org/docs/stable/nn.html%29">PyTorch 官网</a>中 torch.nn 模块中的 Containers 中，在<a href="https://so.csdn.net/so/search?q=%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&amp;spm=1001.2101.3001.7020">神经网络</a>搭建的过程中如果使用 Sequential，代码更简洁。 </p>
<p><strong>(2) 搭建神经网络小示例</strong></p>
<p><img src="https://pic.imgdb.cn/item/62676095239250f7c5567e82.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/626760a6239250f7c556a3ea.jpg"></p>
<p>搭建上述神经网络的具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d, MaxPool2d, Flatten, Linear</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jiaolong</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Jiaolong, self).__init__()</span><br><span class="line">        self.conv1 = Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)</span><br><span class="line">        self.maxpool1 = MaxPool2d(kernel_size=<span class="number">2</span>)</span><br><span class="line">        self.conv2 = Conv2d(in_channels=<span class="number">32</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)</span><br><span class="line">        self.maxpool2 = MaxPool2d(kernel_size=<span class="number">2</span>)</span><br><span class="line">        self.conv3 = Conv2d(in_channels=<span class="number">32</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>)</span><br><span class="line">        self.maxpool3 = MaxPool2d(kernel_size=<span class="number">2</span>)</span><br><span class="line">        self.flatten = Flatten()</span><br><span class="line">        self.linear1 = Linear(<span class="number">1024</span>, <span class="number">64</span>)</span><br><span class="line">        self.linear2 = Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.maxpool1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = self.maxpool2(x)</span><br><span class="line">        x = self.conv3(x)</span><br><span class="line">        x = self.maxpool3(x)</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.linear1(x)</span><br><span class="line">        x = self.linear2(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">jiaolong = Jiaolong()</span><br><span class="line"><span class="built_in">print</span>(jiaolong)</span><br><span class="line"><span class="built_in">input</span> = torch.ones((<span class="number">64</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>))  <span class="comment"># 指定数据创建的形状，都是1</span></span><br><span class="line">output = jiaolong(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output.shape)</span><br></pre></td></tr></table></figure>
<p>现以Sequential搭建上述一模一样的神经网络，并借助tensorboard显示计算图的具体信息。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d, MaxPool2d, Flatten, Linear, Sequential</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jiaolong</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Jiaolong, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(kernel_size=<span class="number">2</span>),</span><br><span class="line">            Conv2d(in_channels=<span class="number">32</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(kernel_size=<span class="number">2</span>),</span><br><span class="line">            Conv2d(in_channels=<span class="number">32</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(kernel_size=<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">jiaolong = Jiaolong()</span><br><span class="line"><span class="comment"># print(jiaolong)</span></span><br><span class="line"><span class="built_in">input</span> = torch.ones((<span class="number">64</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>))  <span class="comment"># 指定数据创建的形状，都是1</span></span><br><span class="line">output = jiaolong(<span class="built_in">input</span>)</span><br><span class="line"><span class="comment"># print(output.shape)</span></span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">writer.add_graph(jiaolong, <span class="built_in">input</span>)  <span class="comment"># 计算图</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p>注意，要展示计算图，需要通过终端执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 激活环境</span></span><br><span class="line">conda activate py_env37</span><br><span class="line"><span class="comment"># 执行下面的命令</span></span><br><span class="line">tensorboard --logdir=logs_seq</span><br></pre></td></tr></table></figure>
<p>此外还有一点要注意，tensorboard要TensorFlow库的支持，若没有安装TensorFlow库，则先进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1：通常，TensorFlow可以通过conda的默认渠道或conda-forge渠道来安装</span></span><br><span class="line">conda install tensorflow -c conda-forge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：或者，你也可以尝试使用默认渠道（但请注意，默认渠道可能不包含最新版本的TensorFlow）</span></span><br><span class="line">conda install tensorflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：</span></span><br><span class="line">pip install tensorflow</span><br></pre></td></tr></table></figure>
<p>这其中会出现各种各样的问题，我也不好说，反正有问题请百度或者询问AI吧。（常见的一种问题是网络造成的，可尝试关闭代理服务器等方法）</p>
<p><img src="https://pic1.imgdb.cn/item/6789bd20d0e0a243d4f50e0c.png" alt="计算图"></p>
<blockquote>
<p>记录于：2025-01-17日</p>
<p>我去，无语了，为了搞这个计算图的环境配置，我可以说是整整搞了一天，除了今天写了个专栏标题。</p>
<p>这里简单把解决问题用到的相关连接放在下面吧，以后可能会用。</p>
<p><a href="https://www.bilibili.com/video/BV1MV411g7Sb">Anaconda、 tensorflow和keras的安装 - 哔哩哔哩</a></p>
<p><a href="https://blog.csdn.net/shencanggang/article/details/139585351">7.TensorBoard的使用（一）- CSDN</a></p>
<p><a href="https://blog.csdn.net/crist_meng/article/details/123271767">【ImportError: TensorBoard logging requires TensorBoard version 1.15 or above·已解决】 - CSDN</a></p>
<p><a href="https://blog.csdn.net/2401_84166536/article/details/137885240">【tensorboard】解决ValueError Duplicate plugins for name projector - CSDN</a></p>
<p><a href="https://blog.csdn.net/Enjoylalala/article/details/128209587">Pytorch学习日记——Tensorboard使用（一） - CSDN</a></p>
<p><strong><font color="purple">使用torchviz实现PyTorch计算图的可视化</font></strong>：<a href="https://www.guanjihuan.com/archives/40353">https://www.guanjihuan.com/archives/40353</a></p>
</blockquote>
<h5 id="七-参数初始化-补充于2025-01-13，炮哥带你学"><a href="#七-参数初始化-补充于2025-01-13，炮哥带你学" class="headerlink" title="(七) 参数初始化(补充于2025-01-13，炮哥带你学)"></a>(七) 参数初始化(补充于2025-01-13，炮哥带你学)</h5><p>初始化神经网络模型中的卷积层和全连接层的权重和偏置。</p>
<p>确保在训练神经网络之前，所有层的权重和偏置被合理地初始化，以提高模型的训练效果和稳定性。</p>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 省略。。。	卷积层、池化层、激活函数等的定义</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化权重代码</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():		<span class="comment"># 遍历模型中的所有子模块，包括卷积层、全连接层等</span></span><br><span class="line">            <span class="comment"># 如果当前模块是卷积层（nn.Conv2d），则使用Kaiming正态分布初始化其权重，</span></span><br><span class="line">            <span class="comment"># 并设置非线性激活函数为ReLU。</span></span><br><span class="line">            <span class="comment"># 如果卷积层有偏置项，则将其初始化为常数0。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                nn.init.kaiming_normal_(m.weight, nonlinearity=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    nn.init.constant_(m.bias, val=<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="comment"># 如果当前模块是全连接层（nn.Linear），则使用均值为0、标准差为0.01</span></span><br><span class="line">                <span class="comment"># 的正态分布初始化其权重。</span></span><br><span class="line">                <span class="comment"># 如果全连接层有偏置项，则将其初始化为常数0。</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">                    nn.init.normal_(m.weight, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br><span class="line">                    <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        nn.init.constant_(m.bias, val=<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 省略。。。</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="第四章-损失函数与反向传播"><a href="#第四章-损失函数与反向传播" class="headerlink" title="第四章 损失函数与反向传播"></a>第四章 损失函数与反向传播</h3><h4 id="4-1-交叉熵基本表示"><a href="#4-1-交叉熵基本表示" class="headerlink" title="4.1 交叉熵基本表示"></a>4.1 交叉熵基本表示</h4><p>交叉熵常用于分类问题的loss函数，其形式为</p>
<script type="math/tex; mode=display">
\mathrm{loss}(x, class) = -\log(\frac{\exp(x[class])}{\sum_{j}\exp(x[j])}) = -x[class]+\log(\sum_{j}exp(x[j]))</script><h4 id="4-2-示例"><a href="#4-2-示例" class="headerlink" title="4.2 示例"></a>4.2 示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> L1Loss, MSELoss</span><br><span class="line"></span><br><span class="line">inputs = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=torch.float32)</span><br><span class="line">targets = torch.tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], dtype=torch.float32)</span><br><span class="line"></span><br><span class="line">inputs = torch.reshape(inputs, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">targets = torch.reshape(targets, (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">loss = L1Loss(reduction=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line">result = loss(inputs, targets)</span><br><span class="line"></span><br><span class="line">loss_mse = MSELoss()</span><br><span class="line">result_mse = loss_mse(inputs, targets)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result_mse)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉熵</span></span><br><span class="line">x = torch.tensor([<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>])</span><br><span class="line">y = torch.tensor([<span class="number">1</span>])</span><br><span class="line">x = torch.reshape(x, (<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">loss_cross = nn.CrossEntropyLoss()</span><br><span class="line">result_cross = loss_cross(x, y)</span><br><span class="line"><span class="built_in">print</span>(result_cross)</span><br></pre></td></tr></table></figure>
<p>现在以 CIFAR10 数据集为例，在上一篇文章中最后搭建的神经网络中使用 CrossEntropyLoss 函数作为<a href="https://so.csdn.net/so/search?q=%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020">损失函数</a>，讲解在神经网络中如何使用损失函数。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Sequential, Conv2d, MaxPool2d, Flatten, Linear</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;D:\Code\Project\learn_pytorch\pytorch_p17-21\data&quot;</span>, 					train=<span class="literal">False</span>,download=<span class="literal">True</span>, transform=torchvision.transforms.ToTensor())</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jiaolong</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Jiaolong, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(kernel_size=<span class="number">2</span>),</span><br><span class="line">            Conv2d(in_channels=<span class="number">32</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(kernel_size=<span class="number">2</span>),</span><br><span class="line">            Conv2d(in_channels=<span class="number">32</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(kernel_size=<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">loss = nn.CrossEntropyLoss()</span><br><span class="line">jiaolong = Jiaolong()</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    outputs = jiaolong(imgs)</span><br><span class="line">    result_loss = loss(outputs, targets)</span><br><span class="line">    <span class="built_in">print</span>(result_loss)</span><br></pre></td></tr></table></figure>
<h3 id="第五章-优化器"><a href="#第五章-优化器" class="headerlink" title="第五章 优化器"></a>第五章 优化器</h3><p>优化器：神经网络的学习的目的就是寻找合适的参数，使得损失函数的值尽可能小。解决这个问题的过程为称为最优化。解决这个问题使用的算法叫做优化器。在 PyTorch 官网中，将优化器放置在 torch.optim 中，并详细介绍了各种优化器的使用方法。</p>
<p>现以 CIFAR10 数据集为例，损失函数选取交叉熵函数，优化器选择 SGD 优化器，搭建神经网络，并计算其损失值，用优化器优化各个参数，使其朝梯度下降的方向调整。设置 epoch，让其执行 20 次，并将每一次完整的训练的损失函数值求和输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Sequential, Conv2d, MaxPool2d, Flatten, Linear</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;D:\Code\Project\learn_pytorch\pytorch_p17-21\data&quot;</span>, train=<span class="literal">False</span>,</span><br><span class="line">                                       download=<span class="literal">True</span>, transform=torchvision.transforms.ToTensor())</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jiaolong</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Jiaolong, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(kernel_size=<span class="number">2</span>),</span><br><span class="line">            Conv2d(in_channels=<span class="number">32</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(kernel_size=<span class="number">2</span>),</span><br><span class="line">            Conv2d(in_channels=<span class="number">32</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(kernel_size=<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">loss = nn.CrossEntropyLoss()</span><br><span class="line">jiaolong = Jiaolong()</span><br><span class="line"><span class="comment"># 构建 SGD 优化器，其中 jiaolong.parameters() 表示：待优化参数的 iterable 或者是定义了参数组的 dict，lr=0.01 表示学习率</span></span><br><span class="line">optim = torch.optim.SGD(jiaolong.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        outputs = jiaolong(imgs)</span><br><span class="line">        result_loss = loss(outputs, targets)</span><br><span class="line">        <span class="comment"># 将上一轮计算的梯度清零，避免上一轮的梯度值会影响下一轮的梯度值计算</span></span><br><span class="line">        optim.zero_grad()</span><br><span class="line">        <span class="comment"># 反向传播过程，在反向传播过程中会计算每个参数的梯度值</span></span><br><span class="line">        result_loss.backward()</span><br><span class="line">        <span class="comment"># 所有的 optimizer 都实现了 step() 方法，该方法会更新所有的参数。</span></span><br><span class="line">        optim.step()</span><br><span class="line">        running_loss = running_loss + result_loss</span><br><span class="line">    <span class="built_in">print</span>(running_loss)</span><br></pre></td></tr></table></figure>
<h3 id="第六章-现有网络模型的使用与修改"><a href="#第六章-现有网络模型的使用与修改" class="headerlink" title="第六章 现有网络模型的使用与修改"></a>第六章 现有网络模型的使用与修改</h3><p>PyTorch是一个开源的Python机器学习库，基于Torch，用于自然语言处理等应用程序。他提供了大量的模型供我们所使用，如下图所示： </p>
<p><img src="https://pic.imgdb.cn/item/6267a215239250f7c5f7a34d.jpg"></p>
<p>下面，我们选择其中一个网络进行使用，介绍如何使用、并修改 pytorch 本身为我们提供的现有网络。最后介绍一下模型的保存和修改。</p>
<h4 id="6-1-pytorch-现有网络的使用与修改"><a href="#6-1-pytorch-现有网络的使用与修改" class="headerlink" title="6.1 pytorch 现有网络的使用与修改"></a>6.1 pytorch 现有网络的使用与修改</h4><p>下面以 VGG(Very Deep Convolutional Networks for Large-Scale Image Recognition)的使用为例，进行介绍该网络。</p>
<h5 id="一-VGG-16-简介"><a href="#一-VGG-16-简介" class="headerlink" title="(一) VGG 16 简介"></a>(一) VGG 16 简介</h5><p>VGG16网络是14年牛津大学计算机视觉组和Google DeepMind公司研究员一起研发的深度网络模型。该网络一共有16个训练参数的网络，该网络的具体网络结构如下所示：</p>
<p><img src="https://pic.imgdb.cn/item/6267a311239250f7c5f9aae8.jpg"></p>
<p>不难看出，该网络主要用于对 224 x 224 的图像进行1000分类。下面我们查看 VGG 在 pytorch 上的官方文档。</p>
<h5 id="二-VGG-16-doc"><a href="#二-VGG-16-doc" class="headerlink" title="(二) VGG 16 doc"></a>(二) VGG 16 doc</h5><p>从帮助文档中，我们可以清楚的看到 pytorch 为我们提供了各种版本的 VGG，我们选择 VGG 16 进行查看。</p>
<p><img src="https://pic.imgdb.cn/item/6267a34e239250f7c5fa28a9.jpg"></p>
<h5 id="三-VGG16-的简单使用"><a href="#三-VGG16-的简单使用" class="headerlink" title="(三) VGG16 的简单使用"></a>(三) VGG16 的简单使用</h5><p>从VGG 16的帮助文档可以得知，该模型训练的数据是 <code>ImageNet</code>，我们进入 torchvision.datasets 查看 ImageNet</p>
<p>但是该数据集实在是太大了，根本下不了，还是不搞了。建立一个该网络的模型查看参数: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">import</span> torchvision </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn </span><br><span class="line"><span class="comment"># import torchvision.models</span></span><br><span class="line"></span><br><span class="line">vgg_model_pretrained = torchvision.models.vgg16(pretrained=<span class="literal">True</span>, progress=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">vgg_model_original = torchvision.models.vgg16(pretrained=<span class="literal">False</span>, progress=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(vgg_model_original)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(vgg_model_pretrained)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="6-2-修改网络"><a href="#6-2-修改网络" class="headerlink" title="6.2 修改网络"></a>6.2 修改网络</h4><p>使用以下语句可以实现对网络的修改</p>
<h5 id="一-添加网络结构"><a href="#一-添加网络结构" class="headerlink" title="(一) 添加网络结构"></a>(一) 添加网络结构</h5><p><code>vgg_model_pretrained.add_module()</code></p>
<h5 id="二-修改网络结构"><a href="#二-修改网络结构" class="headerlink" title="(二) 修改网络结构"></a>(二) 修改网络结构</h5><p><code>vgg_model_original.classifier[num]</code></p>
<blockquote>
<p>num表示要修改网络的哪一层</p>
</blockquote>
<h5 id="三-伪代码示例"><a href="#三-伪代码示例" class="headerlink" title="(三) 伪代码示例"></a>(三) 伪代码示例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加：vgg_model_pretrained.add_module()</span></span><br><span class="line">vgg_model_original.classifier.add_module(<span class="string">&#x27;15&#x27;</span>, nn.Linear(in_features=<span class="number">1000</span>, out_features=<span class="number">10</span>, bias=<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(vgg_model_original)</span><br><span class="line"><span class="comment"># 修改：vgg_model_original.classifier[num]</span></span><br><span class="line">vgg_model_original.classifier[<span class="number">7</span>] = nn.Linear(in_features=<span class="number">1000</span>, out_features=<span class="number">15</span>, bias=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(vgg_model_original)</span><br></pre></td></tr></table></figure>
<h3 id="第七章-网络模型的保存与读取"><a href="#第七章-网络模型的保存与读取" class="headerlink" title="第七章 网络模型的保存与读取"></a>第七章 网络模型的保存与读取</h3><p>在搭建自己的神经网络模型之后，需要将模型进行保存，同时也需要读取或加载现有的神经网络模型。</p>
<h4 id="7-1-加载模型"><a href="#7-1-加载模型" class="headerlink" title="7.1 加载模型"></a>7.1 加载模型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># File : model_load.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式1 -&gt; 保存方式1，加载模型</span></span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line">model = torch.load(<span class="string">&quot;vgg16_method1.pth&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2 ，加载模型</span></span><br><span class="line">vgg16 = torchvision.models.vgg16(pretrained=<span class="literal">False</span>)</span><br><span class="line">vgg16.load_state_dict(torch.load(<span class="string">&quot;vgg16_method2.pth&quot;</span>))</span><br><span class="line"><span class="comment"># model = torch.load(&quot;vgg16_method2.pth&quot;)</span></span><br><span class="line"><span class="built_in">print</span>(vgg16)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式 1 陷阱</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jiaolong</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">jiaolong = Jiaolong()</span><br><span class="line">torch.save(jiaolong, <span class="string">&#x27;jiaolong_method1.pth&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="7-2-保存模型"><a href="#7-2-保存模型" class="headerlink" title="7.2 保存模型"></a>7.2 保存模型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># File : model_save.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line">vgg16 = torchvision.models.vgg16(pretrained=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 保存方式 1，模型结构+模型参数</span></span><br><span class="line">torch.save(vgg16, <span class="string">&quot;vgg16_method1.pth&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存方式2，模型参数（官方推荐）</span></span><br><span class="line">torch.save(vgg16.state_dict(), <span class="string">&#x27;vgg16_method2.pth&#x27;</span>)  <span class="comment"># 将模型的状态（参数）保存成字典形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式 1 陷阱，需要将模型写过来，但无需创建实例</span></span><br><span class="line"><span class="comment"># 可以引入，from model_save import *</span></span><br><span class="line">model = torch.load(<span class="string">&#x27;jiaolong_method1.pth&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(model)  <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure>
<h3 id="第八章-完整地模型训练-验证套路"><a href="#第八章-完整地模型训练-验证套路" class="headerlink" title="第八章 完整地模型训练/验证套路"></a>第八章 完整地模型训练/验证套路</h3><h4 id="8-1-训练套路"><a href="#8-1-训练套路" class="headerlink" title="8.1 训练套路"></a>8.1 训练套路</h4><h4 id="8-2-验证套路"><a href="#8-2-验证套路" class="headerlink" title="8.2 验证套路"></a>8.2 验证套路</h4><p>验证不是指的时在测试集上测试，而是找一张没有在数据集中的图片进行训练。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line">image_path = <span class="string">&quot;imgs/dog.png&quot;</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line"><span class="built_in">print</span>(image)</span><br><span class="line">image = image.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line"><span class="comment"># 因为png格式为四个通道，除了RGB三个通道外，还有一个透明度通道。所以调用此语句保留其颜色通道。</span></span><br><span class="line"></span><br><span class="line">transform = torchvision.transforms.Compose([torchvision.transforms.Resize((<span class="number">32</span>, <span class="number">32</span>)),</span><br><span class="line">                                            torchvision.transforms.ToTensor()])</span><br><span class="line"><span class="comment"># 这个照片size=258x208，因为模型为32×32，所以改一下</span></span><br><span class="line">image = transform(image)</span><br><span class="line"><span class="built_in">print</span>(image.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载网络模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tudui</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Tudui, self).__init__()</span><br><span class="line">        <span class="comment"># 为了避免上下两个def都写一整串，将整个网络放到序列当中，前边有讲过，注释了很多代码有老乡的那一篇</span></span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),   <span class="comment">#  卷积</span></span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),             <span class="comment">#  池化</span></span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Flatten(),</span><br><span class="line">            nn.Linear(<span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">64</span>),   <span class="comment"># 最后两步的展平</span></span><br><span class="line">            nn.Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.model(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = torch.load(<span class="string">&quot;tudui_0.pth&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># img输入到这个模型中</span></span><br><span class="line"><span class="comment"># 这里一开始用的gpu的模型，会报错，换成cpu的&quot;tudui_0.pth&quot;模型就行了</span></span><br><span class="line">image = torch.reshape(image, (<span class="number">1</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>))</span><br><span class="line"><span class="comment"># 这几步比较重要且容易忘记======================</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    output = model(image)</span><br><span class="line"><span class="comment"># 这几步比较重要且容易忘记======================</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"><span class="comment"># 显示是哪一类的概率最大</span></span><br><span class="line"><span class="built_in">print</span>(output.argmax(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="8-3-model-eval-与with-torch-no-grad"><a href="#8-3-model-eval-与with-torch-no-grad" class="headerlink" title="8.3 model.eval()与with torch.no_grad()"></a>8.3 model.eval()与with torch.no_grad()</h4><p>本文总结了PyTorch中requires_grad、volatile、no_grad、model.eval()的区别与用法。requires_grad控制梯度计算，volatile已弃用，由torch.no_grad()替代。model.eval()用于切换模型到验证/测试模式，不影响梯度计算但关闭dropout和batchnorm的动态计算。with torch.no_grad()则完全不计算梯度，用于加速和节省资源。</p>
<p>在推理时，通常需要同时使用这两个设置：</p>
<ul>
<li>model.eval()：确保模型的行为正确（例如关闭 Dropout、切换 BatchNorm）。</li>
<li>with torch.no_grad()：关闭梯度计算，节省内存和计算开销。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.<span class="built_in">eval</span>()  <span class="comment"># 切换到评估模式</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():  <span class="comment"># 关闭梯度计算</span></span><br><span class="line">    output = model(input_tensor)  <span class="comment"># 推理</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>总结：</p>
<ul>
<li><p>requires_grad=True 要求计算梯度；requires_grad=False 不要求计算梯度；</p>
</li>
<li><p>model.eval()中的数据不会进行反向传播，但是仍然需要计算梯度；</p>
</li>
<li><p>with torch.no_grad()或者@torch.no_grad()中的数据不需要计算梯度，也不会进行反向传播。（torch.no_grad()是新版本pytorch中volatile的替代）</p>
</li>
<li><p>model.eval()和with torch.no_grad() 需要配合使用：model.eval() 确保模型行为正确，with torch.no_grad() 提高推理效率。</p>
<ul>
<li>如果只使用 model.eval() 而没有 with torch.no_grad()，会导致不必要的梯度计算，增加内存和时间开销。</li>
<li>如果只使用 with torch.no_grad() 而没有 model.eval()，模型行为可能仍然是训练模式，导致结果不正确。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>原文链接：<a href="https://blog.csdn.net/star_xxzeng/article/details/108351557">model.eval()与with torch.no_grad() - CSDN</a></p>
<p>参考链接：<a href="https://blog.csdn.net/hxxjxw/article/details/107726309?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-107726309-blog-108351557.235^v43^pc_blog_bottom_relevance_base8&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">Pytorch的model.train() &amp; model.eval() &amp; torch.no_grad() - CSDN</a></p>
<h3 id="第九章-利用GPU进行训练"><a href="#第九章-利用GPU进行训练" class="headerlink" title="第九章 利用GPU进行训练"></a>第九章 利用GPU进行训练</h3><h4 id="9-1-方法1"><a href="#9-1-方法1" class="headerlink" title="9.1 方法1"></a>9.1 方法1</h4><p>采用方法 1 实现GPU训练网络模型只需要将原来的 CPU 版本的代码进行小量修改即可，具体修改的位置包括下面3个地方：</p>
<ul>
<li>网络模型</li>
<li>数据（输入、标注）</li>
<li>损失函数</li>
</ul>
<p>只需找到上述 3 个位置的代码加上<code>.cuda()</code>操作即可实现将CPU版本的代码修改为GPU版本的代码，现以上一篇博文中完整的模型训练代码为例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网络模型</span></span><br><span class="line">junheng = junheng.cuda()</span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss_function = loss_function.cuda()</span><br><span class="line"><span class="comment"># 数据（输入、标注）——包括训练和测试部分</span></span><br><span class="line">imgs = imgs.cuda()</span><br><span class="line">labels = labels.cuda()</span><br></pre></td></tr></table></figure>
<p>注意：最好可以在使用<code>cuda()</code>前加一个判断<code>if torch.cuda.is_available()</code></p>
<h4 id="9-2-方法2"><a href="#9-2-方法2" class="headerlink" title="9.2 方法2"></a>9.2 方法2</h4><p>打开 google colab（科学上网）</p>
<h4 id="9-3-方法3"><a href="#9-3-方法3" class="headerlink" title="9.3 方法3"></a>9.3 方法3</h4><p>用的<code>.to</code>操作来指定模型训练的设备，具体是CPU还是GPU，如果是GPU，还能具体到时哪一块GPU。</p>
<p>具体方法总结如下：</p>
<ul>
<li>定义具体的 device，例如：device=torch.device(“cpu”) 或者 device=torch.device(“cuda:0”) 或者 device=torch.device(“cuda:1”)；</li>
<li>利用 .to() 操作训练使用的具体设备，例如 .to(device)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 定义训练设备</span></span><br><span class="line">mydevice = torch.device(<span class="string">&quot;cpu&quot;</span>)	<span class="comment"># 设备在cpu运行</span></span><br><span class="line">mydevice = torch.device(<span class="string">&quot;cuda&quot;</span>)	<span class="comment"># 设备在gpu运行</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">另一种写法</span></span><br><span class="line"><span class="string">mydevice = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 网络模型使用训练设备</span></span><br><span class="line">junheng = junheng.to(mydevice)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 损失函数使用训练设备</span></span><br><span class="line">loss_function = loss_function.to(mydevice)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 数据（输入、标注）使用训练设备——包括训练和测试部分</span></span><br><span class="line">imgs = imgs.to(mydevice)</span><br><span class="line">labels = labels.to(mydevice)</span><br></pre></td></tr></table></figure>
<h3 id="第十章-训练自己的数据集"><a href="#第十章-训练自己的数据集" class="headerlink" title="第十章 训练自己的数据集"></a>第十章 训练自己的数据集</h3><h4 id="10-1-方法一"><a href="#10-1-方法一" class="headerlink" title="10.1 方法一"></a>10.1 方法一</h4><p>此方法来自于B站UP主“炮哥带你学”。此方法的具体记录如下。</p>
<ul>
<li><strong>首先，准备原始数据集</strong></li>
</ul>
<p>此种方法下准备的原始数据集结构如下图所示，其核心就是<strong><font color="purple">通过文件夹划分不同类别的数据，文件夹的名称就是类别名</font></strong>。</p>
<p><img src="https://pic1.imgdb.cn/item/678cafded0e0a243d4f59f8d.png"></p>
<ul>
<li><strong>其次，对数据进行划分</strong></li>
</ul>
<p>深度学习自然是要将数据划分为训练集和测试集的，其中训练集要进一步划分为训练集和验证集，如下所示。</p>
<p><img src="https://pic1.imgdb.cn/item/678cb253d0e0a243d4f5a036.png" style="zoom:70%"></p>
<p>这里我们可以使用下面的代码对数据进行划分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkfile</span>(<span class="params">file</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建目录（文件夹），如果指定的目录不存在，则创建该目录</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param file: 表示要创建的目录路径</span></span><br><span class="line"><span class="string">    :return: No Return</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># os.path模块中的一个函数，用于检查指定路径（文件或目录）是否存在</span></span><br><span class="line">    <span class="comment"># 如果路径存在，返回 True；否则返回 False。</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file):</span><br><span class="line">        os.makedirs(file)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取data文件夹下所有文件名（即需要分类的类名），并将这些名称存储在列表flower_class。</span></span><br><span class="line">file_path = <span class="string">&#x27;data_cat_dog&#x27;</span></span><br><span class="line">flower_class = [cla <span class="keyword">for</span> cla <span class="keyword">in</span> os.listdir(file_path)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建训练集train文件夹，并由类名在其目录下创建相应的子目录</span></span><br><span class="line">mkfile(<span class="string">&#x27;data/train&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> cla <span class="keyword">in</span> flower_class:</span><br><span class="line">    mkfile(<span class="string">&#x27;data/train/&#x27;</span>+ cla)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建验证集val文件夹，并由类名在其目录下创建子目录</span></span><br><span class="line">mkfile(<span class="string">&#x27;data/test&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> cla <span class="keyword">in</span> flower_class:</span><br><span class="line">    mkfile(<span class="string">&#x27;data/test/&#x27;</span>+ cla)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分比例，训练集：测试集 = 9:1</span></span><br><span class="line">split_rate = <span class="number">0.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定文件夹下的图像数据集按比例划分为训练集和测试集，</span></span><br><span class="line"><span class="comment"># 并将划分后的图像分别保存到 data/train 和 data/test 目录</span></span><br><span class="line"><span class="keyword">for</span> cla <span class="keyword">in</span> flower_class:</span><br><span class="line">    cla_path = file_path+<span class="string">&#x27;/&#x27;</span>+cla +<span class="string">&#x27;/&#x27;</span>           <span class="comment"># 某一类别的子目录</span></span><br><span class="line">    images = os.listdir(cla_path)               <span class="comment"># iamges 列表存储了该目录下所有图像的名称</span></span><br><span class="line">    num = <span class="built_in">len</span>(images)                           <span class="comment"># 当前类别下的图像总数</span></span><br><span class="line">    <span class="comment"># 从images列表中随机抽取k个图像文件名作为测试集，返回eval_index的值是图像的名称</span></span><br><span class="line">    eval_index = random.sample(images, k=<span class="built_in">int</span>(num*split_rate))</span><br><span class="line">    <span class="keyword">for</span> index,image <span class="keyword">in</span> <span class="built_in">enumerate</span>(images):</span><br><span class="line">        <span class="comment"># 如果当前图像在测试集索引中，则将其复制到 data/test/类别名/ 目录下</span></span><br><span class="line">        <span class="keyword">if</span> image <span class="keyword">in</span> eval_index:</span><br><span class="line">            image_path = cla_path + image</span><br><span class="line">            new_path =<span class="string">&#x27;data/test/&#x27;</span>+ cla</span><br><span class="line">            copy(image_path, new_path)      <span class="comment"># 将选中的图像复制到新路径</span></span><br><span class="line">        <span class="comment"># 其余的图像将其复制到 data/train/类别名/ 目录下</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            image_path = cla_path + image</span><br><span class="line">            new_path = <span class="string">&#x27;data/train/&#x27;</span> + cla</span><br><span class="line">            copy(image_path, new_path)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印当前类别的数据划分进度，\r: 使光标回到行首，实现动态更新进度条的效果</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\r[&#123;&#125;] processing [&#123;&#125;/&#123;&#125;]&quot;</span>.<span class="built_in">format</span>(cla, index + <span class="number">1</span>, num), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;processing done!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行完成后，会在当前目录下面生成一个名为<code>data</code>的文件夹，就是划分好的数据集，其结构如下图所示。</p>
<p><img src="https://pic1.imgdb.cn/item/678cb5f0d0e0a243d4f5a138.png"></p>
<p>注意，上面的代码AI评价写的一般，这是其建议修改后的代码，功能完全一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参数</span></span><br><span class="line">file_path = <span class="string">&#x27;data_cat_dog&#x27;</span></span><br><span class="line">split_rate = <span class="number">0.2</span></span><br><span class="line">flower_class = [cla <span class="keyword">for</span> cla <span class="keyword">in</span> os.listdir(file_path)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每个类别</span></span><br><span class="line"><span class="keyword">for</span> cla <span class="keyword">in</span> flower_class:</span><br><span class="line">    cla_path = os.path.join(file_path, cla)  <span class="comment"># 某一类别的子目录</span></span><br><span class="line">    images = os.listdir(cla_path)  <span class="comment"># 获取该目录下所有图像的名称</span></span><br><span class="line">    num = <span class="built_in">len</span>(images)</span><br><span class="line">    eval_index = random.sample(images, k=<span class="built_in">int</span>(num * split_rate))  <span class="comment"># 随机抽取验证集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历图像并划分</span></span><br><span class="line">    <span class="keyword">for</span> index, image <span class="keyword">in</span> <span class="built_in">enumerate</span>(images):</span><br><span class="line">        image_path = os.path.join(cla_path, image)</span><br><span class="line">        <span class="keyword">if</span> image <span class="keyword">in</span> eval_index:</span><br><span class="line">            new_path = os.path.join(<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, cla)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_path = os.path.join(<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;train&#x27;</span>, cla)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建目标目录并复制图像</span></span><br><span class="line">        os.makedirs(new_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line">        copy(image_path, new_path)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 打印进度</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\r[&#123;&#125;] processing [&#123;&#125;/&#123;&#125;]&quot;</span>.<span class="built_in">format</span>(cla, index + <span class="number">1</span>, num), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>再有，加载划分好的数据集</strong></li>
</ul>
<p>对应于使用官方库提供的数据集，官方对数据的加载已经封装的很好了，其加载代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_val_data_process</span>():</span></span><br><span class="line">	train_data = FashionMNIST(root=<span class="string">&#x27;./data&#x27;</span>,</span><br><span class="line">                              train=<span class="literal">True</span>,</span><br><span class="line">                              transform=transforms.Compose([transforms.Resize(size=<span class="number">224</span>),</span><br><span class="line">                                                            transforms.ToTensor()]),</span><br><span class="line">                              download=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">	train_data, val_data = Data.random_split(train_data,</span><br><span class="line">                                             [<span class="built_in">round</span>(<span class="number">0.8</span>*<span class="built_in">len</span>(train_data)),</span><br><span class="line">                                              <span class="built_in">round</span>(<span class="number">0.2</span>*<span class="built_in">len</span>(train_data))])</span><br><span class="line">    train_dataloader = Data.DataLoader(dataset=train_data,</span><br><span class="line">                                       batch_size=<span class="number">32</span>,</span><br><span class="line">                                       shuffle=<span class="literal">True</span>,</span><br><span class="line">                                       num_workers=<span class="number">2</span>)</span><br><span class="line">    val_dataloader = Data.DataLoader(dataset=val_data,</span><br><span class="line">                                     batch_size=<span class="number">32</span>,</span><br><span class="line">                                     shuffle=<span class="literal">True</span>,</span><br><span class="line">                                     num workers=<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">return</span> train dataloader,val dataloader</span><br></pre></td></tr></table></figure>
<p>但是，对于我们自己的数据集就不能再使用这种封装好的方法了，可以使用下面的代码加载数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_val_data_process</span>() -&gt; <span class="built_in">tuple</span>:</span></span><br><span class="line">    <span class="comment"># 定义训练集路径</span></span><br><span class="line">    ROOT_TRAIN = <span class="string">r&quot;data\train&quot;</span></span><br><span class="line">    <span class="comment"># 定义归一化方法，注意这一部分会紧接着在下面讲</span></span><br><span class="line">    normalize = transforms.Normalize(mean=[<span class="number">0.166</span>, <span class="number">0.149</span>,<span class="number">0.129</span>],</span><br><span class="line">                                     std=[<span class="number">0.0626</span>, <span class="number">0.0516</span>, <span class="number">0.0419</span>])</span><br><span class="line">    <span class="comment"># 定义数据集处理方法</span></span><br><span class="line">    train_transform = transforms.Compose([transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)), </span><br><span class="line">                                          transforms.ToTensor(), normalize])</span><br><span class="line">    <span class="comment"># 加载数据集</span></span><br><span class="line">    train_data = ImageFolder(root=ROOT_TRAIN, transform=train_transform)</span><br><span class="line">    </span><br><span class="line">    train_data, val_data = Data.random_split(train_data,</span><br><span class="line">                                             [<span class="built_in">round</span>(<span class="number">0.8</span>*<span class="built_in">len</span>(train_data)),</span><br><span class="line">                                              <span class="built_in">round</span>(<span class="number">0.2</span>*<span class="built_in">len</span>(train_data))])</span><br><span class="line"></span><br><span class="line">    train_dataloader = Data.DataLoader(dataset=train_data,</span><br><span class="line">                                       batch_size=<span class="number">32</span>,</span><br><span class="line">                                       shuffle=<span class="literal">True</span>,</span><br><span class="line">                                       num_workers=<span class="number">0</span>)</span><br><span class="line">    val_dataloader = Data.DataLoader(dataset=val_data,</span><br><span class="line">                                       batch_size=<span class="number">32</span>,</span><br><span class="line">                                       shuffle=<span class="literal">True</span>,</span><br><span class="line">                                       num_workers=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> train_dataloader, val_dataloader</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>最后，数据进行正态规范化</strong></li>
</ul>
<p>为了让模型更好地训练，我们可以讲数据进行正态规范化，公式和代码如下：</p>
<script type="math/tex; mode=display">
z = \dfrac{x - \mu}{\sigma} \qquad \text{其中，}\mu \text{为数据的均值，} \sigma\text{为数据的标准差}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#文件夹路径，包含所有图片文件</span></span><br><span class="line">folder_path = <span class="string">&quot;data_cat_dog&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化累积变量</span></span><br><span class="line">total_pixels = <span class="number">0</span></span><br><span class="line">sum_normalized_pixel_values = np.zeros(<span class="number">3</span>)   <span class="comment"># 如果是RGB图像，需要三个通道的均值和方差</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归遍历 folder_path 文件夹及其子文件夹，返回三元组 (root, dirs, files)：</span></span><br><span class="line"><span class="comment">#   root: 当前文件夹路径。</span></span><br><span class="line"><span class="comment">#   dirs: 当前文件夹下的子文件夹列表。</span></span><br><span class="line"><span class="comment">#   files: 当前文件夹下的文件列表。</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(folder_path):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">        <span class="comment"># 检查文件是否以.jpg、.jpeg、.png 或.bmp结尾，即是否为图片文件</span></span><br><span class="line">        <span class="keyword">if</span> filename.endswith((<span class="string">&#x27;.jpg&#x27;</span>,<span class="string">&#x27;.jpeg&#x27;</span>,<span class="string">&#x27;.png&#x27;</span>,<span class="string">&#x27;.bmp&#x27;</span>)):   <span class="comment"># 可根据实际情况添加其他格式</span></span><br><span class="line">            <span class="comment"># 构建图片的完整路径</span></span><br><span class="line">            image_path = os.path.join(root, filename)</span><br><span class="line">            <span class="comment"># 使用PIL库（Python Imaging Library）加载图片</span></span><br><span class="line">            image = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line">            <span class="comment"># 将图片转换为NumPy数组，方便后续计算</span></span><br><span class="line">            image_array = np.array(image)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 归化像素值到0-1之间</span></span><br><span class="line">            normalized_image_array = image_array / <span class="number">255.0</span></span><br><span class="line">            <span class="comment"># print(image_path)</span></span><br><span class="line">            <span class="comment"># print(normalized_image array.shape)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 累积归一化后的像素值和像素教量</span></span><br><span class="line">            <span class="comment"># 注意：normalized_image_array.size和n.shape是NumPy数组中两个不同的属性，</span></span><br><span class="line">            <span class="comment"># 分别表示数组的 元素总数 和 形状（维度）</span></span><br><span class="line">            total_pixels = total_pixels + normalized_image_array.size</span><br><span class="line">            <span class="comment"># 对图片数组的第0维（高度）和第 1 维（宽度）求和，得到每个通道的像素值之和（如果是彩色图片）</span></span><br><span class="line">            sum_normalized_pixel_values = sum_normalized_pixel_values + np.<span class="built_in">sum</span>(normalized_image_array, axis=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算均值</span></span><br><span class="line">mean = sum_normalized_pixel_values /total_pixels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum_squared_diff = np.zeros(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> root,dirs,files <span class="keyword">in</span> os.walk(folder_path):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> filename.endswith((<span class="string">&#x27;.jpg&#x27;</span>,<span class="string">&#x27;.jpeg&#x27;</span>,<span class="string">&#x27;.png&#x27;</span>,<span class="string">&#x27;.bmp&#x27;</span>)):</span><br><span class="line">            image_path = os.path.join(root,filename)</span><br><span class="line">            image = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line">            image_array = np.array(image)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 归一化像素值到0-1之间</span></span><br><span class="line">            normalized_image_array = image_array / <span class="number">255.0</span></span><br><span class="line">            <span class="comment"># print(normalized_image_array.shape)</span></span><br><span class="line">            <span class="comment"># print(mean.shape)</span></span><br><span class="line">            <span class="comment"># print(image_path)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                diff = (normalized_image_array - mean) ** <span class="number">2</span></span><br><span class="line">                sum_squared_diff += np.<span class="built_in">sum</span>(diff, axis = (<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;捕获到自定义异常&quot;</span>)</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="comment"># diff=(normalized_image_array-mean)** 2</span></span><br><span class="line">            <span class="comment"># sum_squared_diff += np.sum(diff,axis=(0，1))</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算方差</span></span><br><span class="line">variance = sum_squared_diff/total_pixels</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Mean:&quot;</span>, mean)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Variance:&quot;</span>, variance)</span><br></pre></td></tr></table></figure>
<p>注意，上面的代码进行平均值和方查的计算的时候，是<strong>所有类别的图像通一一起计算均值和方差的</strong>，而不是不同类别分别进行计算。</p>
<p>关于深度学习不同归一化方法地原理以及是否要进行归一化，可以参考一下下面3个链接。</p>
<p>参考链接1：<a href="https://blog.csdn.net/Blalaaa/article/details/142485779">深度学习——归一化 - CSDN</a><br>参考链接2：<a href="https://blog.csdn.net/m0_55097528/article/details/131352806">深度学习时，对数据归一化的作用？-CSDN</a><br>参考链接3：<a href="https://blog.csdn.net/u011775793/article/details/135370360">深度学习中，为什么要对数据进行归一化或标准化以及如何进行数据归一化或标准化？- CSDN</a></p>
<h3 id="参考笔记"><a href="#参考笔记" class="headerlink" title="参考笔记"></a>参考笔记</h3><p><a href="https://so.csdn.net/so/search?q=PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&amp;t=blog&amp;u=weixin_44227733">PyTorch深度学习笔记 - 小于同学饿了 - CSDN</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>Pytorch基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之内存和多线程</title>
    <url>/2024/08/06/Fundamentals-of-CPlusPlus/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="f7650a15df9db46e312015d230142979c4238e881e6bdf34f8f5fe5ace7489d2">270cb3bbed971930ec4ebcba9f8cc138f5d4800f50eb8f4502a546dcfd41431bea7e6e0decf234f62e25a821b456bdd0226b999e03433b1bfcab75ca55d6fe7340df37a19f2d66f257b4173ed99cae589adaf89b379a99639889d336bf1027e3d3d981ff0da5f29121cd61c9af9fb631985c099e4e48eeaba88d8aed510595ab4e0eac6cb5ab32f77a09bf88a920b826bfde85dd5ab27ce8747b35cd3f42df2698560e58b2e0eef0b7c59b30aec4112a70223ac4d40f8b7e48bfe9beff3eba837b1f62ac69d81fc0eab2b588b270a9dfbe7972dd21807e06a015269a22d020ef750d7c1110bf6297771bd70a3d01cfba6bda16a6933ca68d44e36c53bfb6dce925861938292e466a6b9963307cf5af06f4d071caef3efdea7eed9be0f089c141becc95c9f59a53f5482e3b8d7ae9a8467c11665d05a6d41fad8179033a0f7166a0308d5ba11478593ea778d1e270874c1841d89fab038a50dd72bb280c3410fca430759e91524d77761f6c67b2428e45b25826c7736b1bd8a25a124c9c1dfacbc44e50b5dd139ce4cbafec677066f4cd0d4f0640c0da2a36a2de3db89a3890128262b838a17a778b9900dca71ca296fafb4a119f31945bcd8a8e28bc8dad78c9952311cfc02fbebd0477976dd6e35a280851e4dc548b12c0bdb66b5dae0d7297cad66f2bda59db65f8cda213ab1ed663ba308d4783e32cc0561b7da558d98d936023dd660a6f6e28c3cbaaadce456048971b3d874bb7d38b969ad32dfb72437e555b93eb69c3c36b9fa9f22ed7063c03b65baf2d4f77477cb0bf92cbd568684efe6cd1d9de9e5e43281ee281759a4d4a012854abbd8bd51d2a34ad514f18d832d6905b3b1c550f22394c7d7eb45abbfcec5234ed19577441eab484393d37fb804f69b87a6386e60d298909a575887a36fbc2b6b3b0b83f5d71bb18294cb449b1617f6b5972c8fbf7dfe332e571a8596a38da45f09cd6bc1f3af72aef692bacb8ac0ea52e61822d5612b76f21faa17687fee81c0ae7936e826a7d24f62ff594c906baf4465be2b4d2cefa50050000b6069aadb686e3c9e0ff70aa4c62b09f04c9ce2d8c98da66e56c8347062a5ed50880311e6d8548403aed4f1cb2ff864dae11f43e7036c1fda9f48569927058f308501b1b42a9c748919ef0d15921fadfcd2b7a236c0f45e40275a2ce4024f2af2cb240fc673d73f24536786470d349ce4701d24c15646e0896baff83ce46e950aa66d01ee61f145f6773d3b4e76722e71ca0e1f74caa796538459c2df1b7023c36b0b09a50a65fca2e82286af65802c357daecaac4f774b68931b25a7f73e8586037ec60a9862ee403bfdb64853e123211bfcafda9cf78ee88b59407983d3b5c0ba557c8d8bf33d8b7aabb609ae833023fbe7c2186e9193fd90134522dd7190886ed5a50e5f6c056330287b674e3109457a6ba830d5ac8da68eff9eb3136ca4f8a2ea20c78d028203d199a9f18286ca4ee78348f8d3dc6f76861a5a81155750f5bf8f7dd8e2e7cdc307f4c8475119e053d07ef06d01cc3f2ad64106e1814d2aa9be4b5e90bfa5aa9764fa0cf23ddfe4d99ba8bb8059b5d951f7803cf68f397ce3dc31090115b847d9cde81fc890b10f6b4070e09d947ebe5cc992e3deaa3e16f9cab7c7ceca45502d9838c35311b9b0ef031fad09685c6269626b9bf91fb652594a3eca1076b26e21fa7d9ec3a80b213af30e2d9c006e46e80a759aec835265b530588042f326a1e17bf2068184578e955fb406b3a532fa0117f832027b95b87d2c65704bc3b916f5f7e58e74d580f8343644d24845aaba147742864e5f14f7651b887f8c261504a2022d8f95079768e381e9cd6fc56eb439d0e83b002609fed7dbb664e15361c61c39cc91f9eafce5cca5aeaf9b20989bc558ac9eaa4f1a622e1a0edec186429b6c7b85e671d5453e0ce23cd80c708e6f1150969ffb3c577e4cdb168c552591e2a3441eefc6a134c27b889f772364fab08e3c86fc7ab2c758c3013457819d6612cf48d2cc66c37b1a83b98ddf75399cfe150c3f05a42ddb2ad9062d061464cc4d55fe5d73d16501e3560c5751366067c65b03536c7fda95f552b155ac0ff5d4cad5baf43ea6237c93e204c32003674a93a8bc968df672be49496ba3b44441693aaf411a1ee639f7e6fd47d99061fa56035a4c1253c0366da1f8e4eb4c3647714e1ef10267e8c21e89d7e377fa4716605592a870a0a80d33871bf03098cce41aac8be663b0c8490351bfe4b19446e0f767e71cef6272c996f8a588095a4482cb939b3747143df7cff4939d282af75606f7537fdc77f7ef11b6e4148fe7d1fc1359ff0e734a2b92efa04d06e6ff7f00746e6d212ec3bcf9684a5381c4321df8031c10d49f8d513a56b0f525f4be3f50ae8a11dc8f570c4c63d180410f68f8102f438e1d8daaeb8fdce544221899512dc91e8037d22a6354ae010ac00b8b98b72086df1b73305d0aa64403f399bce9b33df54798520fe7a4ee30ccd26285a0f45a002de269d122fa7a222f2ca5956f903c916813029c4c96a9dd69885a12bf964e69a7bd87bf55f68154b9b3032ad1c34c82ba991060981e6f4a1336287df48f2fa246df4bb423aeb399c82e3cf4db5143cda5966d7efdfcab3a9311aecca1037ec2b3e592befe157c9365a35f99c0be3f9a26b08b9c429c121f1d332b7dc3b9d2a05bef5287751ba992d9c0f228b65644db774efaccfb6ea7711b05d2e85ebb604a00dea7210533a6f98b7f6a2ea5e5b4b1a50c5f40a5fea659bd009523907b88a7a7508ff251409da1a3dea9fc92e0a24da0fae3c6ba0d1eb75736fb4ec0959855982e55128db5195816d74d0685fe5ffc9f742605c46ca5df306729d7592a66ffd4877b4cf47635e08ffbc26e2994a89f84a13140c0f9f2a2d0396d41e22d7cb2521006650625da6386f58b81f7deb843db5701ed85bb6bcda628cf4a7c7a95e199f5636206939c48f233bed864880c9d92ac107eeded36d67ef8d866f01af2c728ffe31c08eb12b3bd1dd359119235f34fa95a355d4dcba8f398e0d21577e9729cff795855b46e1b2f9c3a7904db82675b2dcad2cb7022aa6d0c7d7f3f837604b25cd3cc26ac109df569e6b6a93f59502f5a5403d22ee60fbe788b5cc85dd7350467bd1dce2c6f8a99cf0d72b4b2244b6a35d75dd16c33bf2ca63fe344db886d568d8183b4bbf594a11abcf2f4ffcf2b513e4694cd7c29ec430a6783f6a8664fae770107fd7f009aef4ead68ac827b4ff7c70017f35935885481e07004e6faede57024920e99e1cc70d999400c2276a8ff1f5abbb3768ca7a5cfbb3df796ca77b95ce28fae45e20735e87b3f97f27e4e422829feffc057c510137bff51a322500b6fad1edfa6e8bc7cbc4c6a7df0ef45f054ebec83c7ff2130dfe619db610e0024138c53a5339c420df4d1c204562abe3175ea4ecbc92e594fd49230ccfefbbcf6498434342b1ce94046f13bb236d17933c59e99d578f5ec377162f78782fdcf0ddaf82bbe10f6a28c77b5c444bc62971998665957d468d59518faa225f5d2af4d9636a8c969f0650a91ae898d4659e5dbeb70cbd1013f342f7e87b7c47b71405c420e9a1c18d25cc1e5e6e0b1f01e38d1c437f651160b498a5c9b3aee100d5c9ce40e48971ad75623dfb7bb91dd0e9850c8031f7ad39fcfeb35ee25e4e7a445479e4c10b9f2a6e6700849c25fe6d73d14cb3b70fc5fc912e3d2f97f77a91f210363b0428957a01e3b9f3638e3af1827ae314668420ab8b0636248264f4697fd573efbc3c7ae3ba50978ee4dcaebe60a20157184edfd9a8e2d0f9873648c46084e11be2345cbecb1ff80e3a7b6cc328cea882059db0d04d3dbd3bb48f1b558c5793e3ed73fe34c374b4e066a6314a34a93757f7e77d6267b5516d0fad34860feb32cb6621c9a7a2b8ebaae4e35295ea701ca74d12817fdd29cbd5e62389d061ee59885e88b8954276648d620b588ce9d52c844bf14015538b8fb4beadaf4646b0ded1fc84185fa8e440837e8ed9b9d924840b946f9aa9648294c454bf13648a69b37af785eec7d8626f106b5ec35e4f63a8e9cfddeaa1fdcc158dca8968ccb662424d5e45334816dc417a6d9bbb32cb5a0dfe2b9e4350dcd4dae9b22ca3a029a88e0077c28456f5e6a6ea0548ec38e2605da71597dbe3fb48421f3fefecf3080d22bf13ee35167f2a5ba6d87c88e6d4bfe5d85213946dd8b33ed506f81a1252be139349fbf11c608c58c52b6784b2896d0622a0c18e43d04041c5c681b0afadeb8841a1037bc7b5e15ba91b2544bda4b98d06300b366c3a2dd1586d82c5b07eb93d85ff359046edbb3460c503398cc85b7f5a5f60f0feec41985c845b2072fbec5400eac3749be81063ac34d44b85d663fd17df172a504247a5d71784de39e85cd77a2fdf7dd4624596a1adf0539a7b68217df65d8774099b6199d4f5670ca1de050af8dea6b8aec122e6f12a5b188b7aff73118640e430bc60f72f38deaf0a6d571e1076e3d1d224316f552a17281a9e301d7a530c8ff4f315ce48dfdae7fa11e31fe5d087d2435080102a7ee5404ac733d10b48849dd2c254b56bb002ec237a9a71d116efe1c46650013a79c6e741166c8d1fdf18a0ff0c56c598ba63f24eecfaea873aa660df052038b70b0dc3dcc7cd770d5d31fe53e5bc3b61035a58255422e794fdcec591e23e7cc96c4f14c502ad0ec6ec44eba87204fd1ccb686a8cae4b0a001768048b4ec83a938ce937ab5a9b7abbd989250da9df6322e2b3ab7b641f7c126363d37bd87807c5268d3dbdcd54dec3ed5d8da800685e394a596a295e15f04c3a9734c91f7b3b60b3313b6e02dd9ba86da839b128a2c6c4aeb16e2d6fa0a160f49dc90ff33ebdd7f7bfe90e6d9e1d2b9262877df63b82583c2f3c5505dd830ece5dc18cf083cafcf8b08768db0e1dec92f7999c4970eec9db0aa9589cb6b80775ec1ee35df85f70c177c6bbd3c839195a821bc88bdcb933e8e9c38694e16bc4a85b07a1e9924370f64ad77b2c6b0e3b5b052bd52edb89935d75fc3160c0d8f60749b0017594697ae2be35d610a7fd81637aa9b96276f7ba5286e24d7c1655884dbb092ab721521c5ebcac98811aeb730c6a8a373c0f9b436f328106789372a3c69ea393b4bada5a77867143c22ece6d8865e5524fa69209221200d5c971f780e472f7c60f34c434285be5fd0dfa52307db28cbd30b63e0bedeb087b901e09bc5345a57baf169bc11f99f8e133f7463b327afdce227f8443e374ee8cb8b581d47a4d057927cd192069b6c19d772349d9b7a973120a3b2db9b9cde601b7e1b9e14e61fc4b46661339a59e1e82321db4ca64173250b0a91d8097da88e095966a8dab5ba3e47760456fc6cb4a14ad3a552dbb9f4fdd95126be9807f15808b7bfc1f584e3ee274c47fb562bd5ddef5e23d0f1f112d57ab78a681f4e3e6098e6e213ce593872ef0617b339f202dd98a28404c4c0bcf4bba1c3d6267096fc75f64f9e2036160541fe9dbbfdc82294a0c763fb5d926ef3d039d4f8fc35d7b6516d23519e3ec0bb3e42f505dba183ca64754c0cb6cd7d350028a8e5f1c99f1179a15533b02ba3bc1a9bdfb13dc26f45a6b55f6e0a77f9d67e1dd91b2fa36b9d56038e698d99da2d61219bf35ba58194dd45952d10f33278126098f2a28bf0d7d2b8002eafee96a5bac4812f1ec4e1a56b58ed26096bcce032a16f915cb6e3d445df31addc419a882398b2f3b6f208ca2b0c8bd0cd601585ab81d45f9619bc9769c17f682df04695d92754eafe45b442f1fdfcabbaf113d4984ebbb9bb82bbd17c6bcf5526c38752a7b116ad3d525dbac4b50fba827e8a30c94b29dac44ef809dfde1eda25f9434c154ac04750c93ae6c44cc6dfbeda7ecded51103530e0b2ea2f068283f5ce5614f90463895cadbe1cf5e486af71071d00e46616d5317668631bbf0b62a097523dc3c578dfbf9589e7de463eb799c1e1111187e1982552f274c1284b3197b53f0c10e6f9ee55bbff787297dff2d5cbf0f9ffebd020cd168b4a7d6369c904f5337edda4ec60acfa5edd74d44d8426fae717446a9435a52d5b601296a0ef75c2c4a31227e7a28648466c791501544ad24b0fc61e9170823f31a04ee0ce5935866da8d016909e67213a7fdc2db840bd034f954007d9a0ee00735bb98410dbc60ea05e1f03c646912eee31023d90be31e38f638c98989d9d0f830713707f3f5c76b3b2d425cb50fb1514eef6a3bed97c8fa83eab558acfd70ef000d808e4dbb96ed92aee3b1f24ab8819c4186ed51e78959facf1d6ef58ee25cdddc6b567551fcbde39c62ae93cc90ac547b1bb3580a8655aaf1de43e65f28171e01341fb53e2cdbc4731079f32c9da40a4a0acdbd1785ff06908be7e003e2952c16b0407c79ada3cc9b87cab5731593044554755da7ae57c1271c21d4b1a099efc186979176056ea3938dd0e2b73b946cac9a7a5bfd1997a4c3ebaeddb9f33af7d88771f95e0c7392ffda273028f52fef1126802a7996c9a3175fde128ccfaf46750bb178735262cba771d87fe48efe0cfec3599661e0a949ba5719dfc67e8d3d920283270a38484480cee8bbdae4c696644e6bc67b797ccb2b2be19e5b95bbc363f86f4778e7025d5c36b65e2ceeb04f1082dc996aa07af019bd3597aa20c7b2ce48209e1674e10fd97da1cd96e2252a53d5e41f0c4907679b5380507a76d5e6a7e30c3e029bb4b33fd99b52fbac3af41a30402306dd43401ab228da78159ba5ce28f8c628eb56e17ef9e4a676d18e4e448c3bbfa0dde95239316822dee0f8054e3f9dc84a0ceab33b57ec0f92ddf3b1c5b365d3d4723d55729083cb88ddc90a3142ea92e58449fc7cd87fe832675416cb338e5f0c04b84a4aca2a0c0945155253f73fcfba442231afbe5dbe4cc638fe8df6aade8e4b436f9b5986151138abaf07d6a0d8a562e32bca99485f504c22828c0af510b9082cb3e68cedc2deb31b365096a4047db1b2a390fbc4cb9681b6070211c83566c7b23a53e434fd5fef114de5020b7af2d9723975592bea895f2adbbcec866db6d28638a7336e17a11b724eacc6dec97cd09ead6ee251407d539a0576f3d55e4e67956098866aec51655a4b2cf91b8f4c8fc19f62527b1ce60b2e38e684b7d3749cfa762b736ef8ec5b36a0d3492b02f9154584d2d772d9d02dbba3fba68659e2ac28ccf790dcd326cf7a97f233859bd1f50bac6333f7f7e70afbf90854095b212c9553ce0e3f5d86907986d0aca46d707e0deba81399ac53d4ad6ae547528b70399ccc0f0dad4fbebc3b479ff803facce9fa72af8b7e02a95448251cac6343d3ed01e0298a09f746219c087e999c41627ac2669e4a0c5008fa5fad1a4bba117be78cab6f3b9384de17a15be9af7335e8510c704fe3232b7f662510ee504133becf7176b8a0fea98aeaa7b4f9e00bdeac41ae4b8889c1a2878282ed1652fea513571c8a1242f79b55cfb95bddd3938d6662c667b099e7cba59b67878cf0c6ad3d269d3291b4abf1a752aa554cb8e41bbbf1abdc31292744c650ee351f1edda1dc1b1aae6226996eabf92be8cb1d11759fc244f213b6e9d2fbe21044a914bfbb86a52cbb6dce2e84d14d78b423dc9dba985d51c121792bacb5e35f04064877380aba9d04f5e007f2d38eefa3c0ece78f35f65db37f56289ca5a4f46e262ff4d937ed6b5392067dd5cef85824d0ecad1078dbb761835a0d731119a105c37a7fef47e722f1dd4371069e805a6ee48d18cf58f3411a2583b9cc02667b1cf34540305e751a28849ed0a768561cfdb8fd5ab6f6564354ce7609f5565ab18beaf6217722a0abe51bbc5a1a34e35b81eb900371760aa44a0fdb3eb85338fb57fcd25db117f22d6494edc0e944e8651533c2f785ff6cde04e9939fc2196d5e62c631ca29ffeef1099ca6da8ebe7f090031c7aec8eb7e12a006ab615063d241f3da2f028efdd7192156b329f4a875d96d537c01946aee1fb0a554373e4806a31499eb575d66e504bfd275452e6367fd16c63f73491e5f9a6daecddb7661fcfab6a760c72b5332704b77a021be29b4960316d3e792b27bdde5944ae0cab495e7df714990c63f81381a43b33a1215580503441650c28f069b24936840b41979ae3e71cda1ec86fd541c311904af0ad2a48da3679f09570ab928561b24c38c8b47f173be3753e3c10be5c804de82c195868a669c0bd26ab41193aeeef44a139ec00751466142ff644fa6141c4ef4203941490c7a29c5dbd01155950944faa556dbe4f123c9293d3306982f8332442fafa49feb470f66f406b1249de788d2942c4c3239b8f19a18eaba6cb7a9484963775716edcfd974a872eb711f5cad36ede6edf69d514aa4bf188cc619cf89494fd4d2f9b579f0c6055e4557502f57e97c417d17f022df173b94d42895e4507b219dad862297401710df819b1a4486a2702e33e47432600cf6cd6ea956a112dbc826f697cc4c66e79f0e70c2e1387433ae7c41ed2d2fce32fa805983dee297f2ce57d5f2835128185c1c87cbeae60fc5909c21f6002d75398ba43a5950c6ad6a89ef7e2549bdce7316e5c4f756012fca9b2114d82664cea249a80ab5121360024b55f4ba0fe9de4460879693c210e30f77744fdb8ae7faa9cfeb4aa5870f1f5ac21fd97aebbc4b0e0469b2e7b4b9b55957a5bece5cb5b94a4150bfac5b3b63a4a3b72b1cdcfd07355b41e71aac867a72607f266f3262fbd08f0112f06c5e5bcf161882aa5c9e38f2fb07a667f792e3fe89b04ec576f39c3f1cbdff16681a100972432ace57836de65fbd1c070439fddf964c2eafeb0f9792bf4c1c3afabfbdb3638dd11911da4b3b3212b8df6011f13751d29387f03dad39d7014bd8da4877dd751c6f64043ae772ebf37d646feb823025a21c1dab5415f42c3f1e5ffbdfe8712dd36d611082b4dd3fa68545afed42b980ecf4705037bc6ee5a64f2e8fb0febad96e99bd8c340cc2f2fe652ef0833c9cf5cbcb44bebb04c25c0d93025faf2ec4e47a0793d653e0d360437285169f936ea888187a0fac57b0faec990fd86ef0c7913ea36b7c79d2adc7a0eaaacab22e3a30516837763f0cec316f6083d8fe3892e267285a9b8a1c3dc3d631cdb5bd6546385af69a864fd002b3e5cd3fd475ee1661f98c86fe5880b56212b154178e47112d0456e362db881d67336ea0ed0c8b6206f0c54c15e5c3307a3d7658f2958640e62db03f3b9ea12c0cd5af38ee437cd03e92f7977a3174cc571fc63f0bc6ce51baf80110d2149984a1d76c83c2cc1b4be8d7fabe6cfa4b5e3c6b00493567e3ea49bfc724196e6e59774f95fec474b8bac0c60076ee4b58a863bfcbdfe0a246794239e9719e951a8dab32bde37b1947d63dae5eeff9d1def53b0c70a53208cd76c8858dbdc1615be9169ca32664231dd0f459c111190a96efd7968e3f93ce982b4be93df7cd18df5b203f14906d10d122c2686267ca994cc6615a47e539054f9b0d95dfb48386752b7881af106680d511f01d82e05595c460cba8ba18c4bf2c19d534d9494ef46e63696f8d042897b295bd430c927090a7076195a1f4419fecc3433c7fa707fa1158d75b786cc6570340515cc564bfa97a9e31ba9fc0ee73220224368ad0bffb4c86e901d4860d6865afce421cad3e1244b8eb186f85fd96ee914fa9bf81d53f17a1c0ba3a5dbc01b8ce837023b4012839b7d4b3328e46a3e1f06b975dac49eb8aaa995d2f84707d18516b3f34d49eac4636b117db5cc7bd7075b691d87c5af6a4d73b4e79df923f5ddbdaaa8448def203cff24bcb66de591809376862343db9ce2ad8f2654489b609c4656ecb0ee2cbcf441bea5b0dc7a5044424f8cdbd43794f69583cfdbcf23d9996803d233cbc0761daf74f74dde82315a68692d50c1cbbf1db1a4df81cfdb34133c7864db2134cf74f58fd4f3e841d2f58e0b248e08af67ba7956119dbd401ddc1071f40710526f2ac633994c0fb9709c63e5af699b6e2d53f99ccefdd3ab38bc967a1e74e79915ea7927641a8a6c4a02ee0ca5a9e5c907740923aa934d556d65a678ebc48d79f7b7f8d4e7648c0e0776c6498217f1fe29b7194a9dc70744906a0b9ca257c4591efa524ac0047e454bb9c12fdc67f6bcee71f996ceafc61ac8c4a885095f0efe534a79cec8dbf1101924571502be6f4352a25db8d26ccdf918d2ca3d8b3513c7cc56608d7d27927c32b85e1143754e94028b3b500e85c24992794009a00b36b460643d5218027351e75ab2a6e89c71853ab46fa884e13705c2491dbd3cf657d837b5201a9fa03729741f1ee16de5398586ec0233b1b4b2f64ed32ef24a66d25109a2eca193cf6273b17f62fff6aed9d91cbbff0b2e3d2d7c2c9bde93c8e9de52d6caf5b6af2754849c3ae4cf46afb00c360e52e1e66acdb8badb0c14e0b2345c106b5781cb04a7de5406e84ebfa32137892ffe922a805532966cf038f9fbc87219df5f47528b6b6e968476787e04f8a3b36638a98a022e358e535f8713c4eb27435efb824869776c80944a2f5b1b206de5911adecad66eb92c9fa32f59c29baaaf112a63c2321e512e1222040a45db6c4e9587925b638b4a901f65164acc364c1c2e4adb95775889ef6c53730ed74c1eb1efbca3be9f1d86ac89d873387366e77ae99be9711b4b00f4f3e1f08354a82d06a80b80593d802c09b4a42328ffa3935a5c3b25f4a2e58b1703c392f6decf564ebdf14862e2ebec1a25dcc7a91e45430738862796b12352d42120ca442d02314be30b96d6024e4a7ec8ef032fbcedf308304000322877bd0e29808b056b52477f9b18830a06e8a5e17c39671eb82af7fa545afccc31180c049effe3890128574fcc30cd543ac20f2d526c8b94a8dd3cf347b202fd3b5bda55b579726a19a8e9c0661d6ea921c2ab900c796191a093173c465cc1af4c4b82b4d43fe9bcf8c1c828a5205ad61ce733dae09548f2f7a66aebaa623d083c227e7056c64a58c7d25c15e3408c924019228d6920e62660859ba8cd5e3a1c6640081b7441e95ab779b67883ffc4946ae0d8b5960f0a17c5d38d322628ffdc7ff70a6a16d879e783d43ea8ea20be5b726dfd8ea0e882181e0f67217c7ec9eab35f00beaa69b734dbc2b9a755d9e2bb143bf1651dc9d5d5d4bc868dae07afda1507d4a461b19ad4bef9b2562e0543e96fd4f61312f9160fb75902c02767fabf13c07554fdb0e479d821971126e458dd7b03914cb60a15e4556bc8ea2c18a7b93612e09de2702aa1b0d44af8591a1c8dee47eaae3bf17888891c5e503dc47a9e51800a093f0d1af46f95e33bd9f19a893790797551693debe13726e28c3086d79acbb301787a91772c7512c0662a8a5bd903621717a65096bf7e004e2e9795a75f3180446955e3faa49bc7385e5a63c4aa7df0dfbb28f9f445e63691a70dd38938ba7052b3e91373adc6167656d8eded06a300b5f3e26ec9315bc8f72ca2fbff891c7cfd5fb4b21c774beb9e49296afcf4c28fab42b8c0e06d397d9ecb925ae1c4dce6d823de352080f9ce50e5e1ca68c5f5ab7e1e43561beb8e9fef7a839778a700ac2311f82a75f52bb367793fff99ee2e8adac8cdf4a25be7223cda72f5ff2952ac757d828f67073cf13a808752d2ab64c403d9bd0e8d50a6e2426c25839364828539652425a17e268c2ab1df4bc757f00a1b884b275617d77d0c48d80c473965a99a4a4ebea737354e7d3b5e5eb678bdeca9b4947e51b0726d615a5cd6498a05c4b88b95423a2321afcc29f75d3828a557f8d856ce954f4f0cceabb239e88e4bd6e508034db03a9485456c8242f164a27e94981a976b848cb6272c18d79519f4014c62c06a2f7c6ef55ff306aa2d72f381bebe515fd5749e00d8d225f3433e85b6fad182d4b8edc35eeab3d6c4bc141ef51aa40ccb98b2cb0ac534cd807db2a0f2f75a2c099949e0c3f21e9cf2cd5737dcad3b527a11a8c4c0edf5785b6862691e5dcf7b3e424cb68af94694eb9fd0fe4d1af3ee47158a7d5de1e0b714a7f3ec51ca44d242d891a6196185d7dbd7293c4907bd1eed913dbf7ee4f30123ac6835268e862a32b4c3b0afe33c61652a58845f83d150be50523617617c2f631e978613f14b3664f55b49efb434796776b80716e933de8e0677006f4532b05d8afc7a52eb48b96e04b8b678f2bbab60d65fe2babccdc6ca9bf5851fd2a69a3d62e2286b3347303fed46f208149d7bf075c9b4d9054c8a7deef7170f8b01f1dea01f0fe52521a30ac151cbdc57977b0bca3b613b00f2efe8c4078a8ad6fa69c547988596a56a5edc1c3fbbd71a7a5ec6729c9baf67ad983df8a369725b1b9af2abfa079483b9862e6b9543c7e913dd3715accbc1a9337b8e0614c42daeefc9da9bed728300b4cd28b28bc7627ee6c9341ae37cdbe2e31d3be3bb30941d1c8f5459ed5689cb44f139bb5ec5507ffb875645ea47d7c9069d56686539fa9cee42e0adadbbfbebba4a777a2c2970612712036cc4c3702d12a30035394e548d9db6ec3c12a897f3f442c11d75b5cba5552c1392b477d982e6ec43138e115a7c5b8227af704220709e8e924d6857dec656481828473b1874ac59934842419bddf06f35c626fe40fadd82a03942f864fe0488c34938543d58765fcfa17f1324da0b860784438fab8af592eaff29299368b4712fc831edf6d257cb06db158dea6661fc81ecfd59caea4c4741103e2da9eb03e8392900ca2708a86b3ec7520b0173d99a7b81811732d23e4bc156a373923d5fafe508efe3e4415020788f6e6bfb9868a0779ef5e23df62672dc7affe761f471b85ff8501a4692bdb5df9eb9656dfdb22fe5cd6b8d3eff7d4a73877ab7a547e10f1ef8d8f4f52904618bf0e845befef369be0446738c878718b029191d52fb84c171ab7ddbf99b67458c090cbc78a89f3bcbfcae717978f181753b96d9079b476403a0f9f14a0534585bfc89b1a0fca3bba2b4c44e4388591b14aa3f77fe13866c11a27d659af5c407cf059801e58d5859c2880edddb0f565098ea08946243c7e7154dca903c109ab4ab25cdf254214c89d877fc12fc2475c54353fef4d03ec645454a96afe9b3b5088f86b1cea54227ffea03a734b5df07a81277e39754a5f081ccb17f4e0aa3be3f483278e1df1132cf4243405a951940a4e57e1457e5db77d6fc55b412599072691e29281ee25be35d160e534ff4f12154b2e689a9f58e9824a3e1b18c0bb944774925904fbde1b52f07268abee1fb0f8da97b1a06808c96f0b303af70f5f687ee48594f35548d87fe2bd5beae3c4c4dcd5d20a5cb2ed40823f1cfa2ad42bd4ac6a6a1c1ac2986f285b84e4c259b149fb4f3a3fb413932d07f92350a578b93f586c6e43b0cbf254a71ee0f29f58e6ff990cd7ffa6bec65aa72a9b587fac2eee70f77ffc70a23948e14eb9f5a897919ed25af2be8cc302694f97d295d499019b80611b6487822626167ec148ec5241b9896e5f491dc7856cad715bbeef25b60ab635e1566453a608663ca13f011841f6d5ada5381633569bd98946422b51dc5938cc6c3c2a4d6da1ce4a17e3f2d0d8bb785315f467fdf93f44f33cb8255b2881a09fe4161b7a059363e9597d3706856402c52f1ddce42407746e9796230e6bed2e6ff39ca146f1257cd321b32fbb8182e895e0186667596e84b8f0b3f219691a428c739e3a6834124ddd600cb5357d0abc443f131b9efef18c192f23b585e7c7db05ae4eb6db7134ebb79709da1a512074e16849eaaf376571080fcfda3bd5de417ee9393a2a415a3d796ea7cfe22c548e33a92415ef9e73c7f6fbce432ff134b8910752279e01d9e5cb031c20f276d1d8fa94ec41aab0519e58c22e0d186364ab845c51d2fd6cc58f977819a74b168cec072cce752cea340a0483088df05524987754271d325070ba95dedd5fa256a79883a6dce8c3e63608ca4c345245ec371d651dd1cdf0ca1e2ceeb8feb9984b7a7fc0c39161b3004301c8f7d6700c8c5063a96f7c56d5ed1ec9fc1f36db61a2bacc1d05335445605e347d9797082b874fc8b21e5b31f148aa0c8b9f0e8a32d0f1c72093586902fe685729d2925854f87daf1320ad33f5427463cf334c547a7cf3d18d464eb8157796f0f125a38a21f6444e6f27f22045fee502fa756f4767dd1032a43dc803c71d473926a041e6fbf357625655038ae1a86c75f650bcf12ce207b7815b598d5aca4680b0306655ac8fd24736a05e3a5eff01aab7413859bb2434d4e5025dfff9a0edb54451302d85a87f0582ebc2aadd54bf86a9b5b4af74e2493812c64bdc7644aeed5ff927669afebd9b51cba2d12b78f1c9e059d2ceb306feedaaadb78d77389fbe7cb131d5a2f541e9c5e4dc94d73e52153c37b389dba816be689bae923810cd8ddc5ad59017c5aafe137045982487a534d6f34a704784a6282780fe08873df4eaa2e3aeeab366902f132eef47804961e40d590d289fdec734d401ca7fc874e5a4017d9865f1b14b21a71361b7217abc294f4c28cb872f70ad7db5b4b07328e5c64b34de894360bb8ca41597db1f510250b419847d423ae7fc4f1e7b0fbaac99a5728df577b1d10012110059af49924dc3efa6338ca25c0c8ff253f506a1e1fdebab394ef11cae6d2d72194f0c2126cb613bec72c5e9c30698ba5817f4dc7c4446ac990d25ce005a9f78d7e72afab9e4a6edc6de713748b0cb8749414e01b90c754187549fe9ce40e063b5588af7336c4c4b40c61dbfbc47d8e97784c8cb115847513b9f223075b6e898f554636d32842a816055cac59b1ab6b0d109df498c098500bb338a6b42cb88359c54f25edcfd367def025ea07b6116e8e219faabfa267ee58323bb1b205ad3d19821586a22e234c648a812cf26de40578d415915b5254161573884a3759656e876f4e4cf1cf56cd3eb4e47968c9b9e5f0f4abeeca3f52206014e9bc72035d77a3593ca045a328f3de005f09e41b95a4ae0250dc687e5763b05712965e4947eee10516d40e7b82eeae5eb22f64cfadf83a1fee82eca19b3735626462ffb356e0f6c214b3afa4626a179635fa7333c2b1e32053a9f6a7bdd11a5d672951662bc2aa6a2a7fd154a27e947b6ffe7f424f489f840a2646f220fd0466abcdfeb7b894d3d5d9836109a9f47ee9b1c594da282ccb641a892f070c916f6fb9ebd58696a2b47ed4f04c53e12185f3cd59bb0d49badbb7844b7ed8f25f6f6b1686f3bdfba8ed78f1f1697208719c1dda60d5ae54efe92bdc7dbb9a83c3d7a7c60e6ad3fea6443452f6331ed53035f6ff8ff56565e0a4759df99b20389519038b18b39b534ac4c997d5037137e50bc5668c3ebaf2073be26a495ad2321db4f72902e76c5d80706beee103f819354b04ce7d9b421940ad23497eea627665e37310c4d3ce502e88570ee62e6d1d147427620c4bf876a2970ca9c98414fea6f8bd982dcaf65ca553812df3f230f594be3676c5d59f8d00af41b08cef3c443de8f28f4651203ab49949848ffa34beb833be8e3a63cd048c1d22b3b6a2e2ef7bcce5afe5ed0cd6bf7b16949c909a420f5658b819fc5e488109a509a029613f3e9d1723af12917d94321f581d29842dee38a0fc2483f89a7f8bdd0ae9eec7a6f8cfb4d3347295d9f5c0d8a10826efa2fe100d752b48e8abc0f90d81d2a0abce5085155b0018cc4338e9bf7499d5c843ee9031c0f43ef737947233cc0f78e60a0178ddb146c24d3f7fc093c5160828a44e703dde65979316f7300350a76a519fcc2a0834a2e7c61e2de7e3f507c07e0894364bdd4dda0cf00b7ccbc120d8bc8eb1a386692753572277693924acc452c74130b4d6c8c1c61ad1b2e72859e54f39e587db3bc1f5b0e226c1d8c95dd7fa94d2902436368767f9314098080ba2d46209baa40c5355de42257ebd5c6cca25f1b4671c02598709c5ce677f98475c71cedaafcfb8bf7437d5912c95b1e40b4bd9393a67f545418c3495d6fd9cc6b8efce2bbbf96a1d9238bfb051b6106184f3a76d60c3143e658d1c65ee074f34f0353f5d1323e1814f21c9fd701dfe55708820c591fc641342717a344b3c9bb0273f9cbb7dae7d84895f595a60f6974a5d13da1eed5cbb477cbec31ef4578ee751828c16a85e8bddb23233cb1a9757facb3d5736d56e2482ec166574058cf4130b761aaf78c9252cd52fea5d0b402a1e56280b2376e91fa7c41c11e9adcbd7e0268577c2a55f5b4d7da3aba7024d189f2f0dc42e61cbc3531591a63ecc31d0c2a6d6597df32ff7921294afc6f65eac20d650202e292b17628ac189a58a037d2731495f534f15666fda7a5a52bc6a7d371d49ef6983c2f08402fccfffca317c8eb8d92bdd552c751393ea35dd71d92d29b7403f016197c4ee1506fa141f6ed01dfabdb7c78c2f2334b598b132fb182940de2855c301852a5a9bbd578d49da19be233a67f7d56198029520ea9a70dd74043a46fd64609fc639ee1e9b9b26c399bdff273a61613a9db9deda7593455f2793d2711ad1cc0ac792b59ade02a14ae6826403f64fc43c75e1dd0659da04c106b7cf7ee9f816dd404b233b05109ea234cf4d277834c70be48210950e5a43d67d36ba3cd3f1dbfcec0bcd69d6e14005582ba83ae74bd449174b34d30bd699996b2422577f17faf513077323508f1d3c1b9005c705f0ba712b5de9d7857822b1663f96bdf1c4af0c6805c6319216de3fc0f2319e5e0a62a21a32e55980a3d00478bdbf640fde15bc6196adbf011912acb3fa9f1136443f810861006eba0303da3e8e1c36862a64d6bac17275c8d16c7053fba908fe0e636f894294d9cdfb906d30b2c46fd98686738e80952d6127a96ac3aaf96678e9c22f4c5a0416c49a9584f50ce4c1a76835e546fcd1b6247cb5bea5eb4b5b2f095ee8978875c86b811f2603b1032030eeee89ca5c5f9d0b084cc9ca2dfbc0f7eae8178354395f5ca7a39b219624e1b2c2c9b7886e6f5b12434a9f85aa1243f14ba8350e069cba4a99e47d0b7dea3b3b3f3cf928b41d2f0deb0d4692aa20147b85d14671f35e5c1d48cea1958e070a5eda58a6764e49c4b33edd558cf8cdbf1e9a1ba4d41dd1e5aa6fe10102e97a4b61e2377415e1acae21c2c85fd9ceba4f019842156ce7ccf058bb1d0d76fce782628ad44973ce7db2ad30d599d8e1ef240eb5e223069f8617de47b4352ca57fede32b237743f3d3fa49f85e03786f0dfe496acd0f4c86ea44324bea3e7c68ef3ca810b74d4c44c8309864160701c14d9a7631e65ad75b0bf5f7b7ec8afbee91d34444ca8fee5d94a6d5be638ce774f54156be2515bbb03199ef533b9a55cba928108c2609afa33357fb7082af8516ff6cd62222ad904524a3d99647557dba5796c5c692d0367a061664ec7b3b23d1e3ce2cbf7c92aa55cba22f5c0c6b9777ef96f781f55b246660122c21c791af42b135f92e86379319218cbe4518cd3df716ae5bfdb7579731d45658e94bdb55b548428c5c1c63c319586c620b7b9f130beb5ff7c2f12ee21dc36d34ff8c30198c8fe042fb2fa2d209a3267c633b9b9fd36b271b4e79a63e99bc3b2059bd7875ba9a7733c1ca190cd18ffca32fa625efe21ea9d36c370a00a0df1f237a3945f1ff55a3881e70b4857ecf78899909e7e1d332bf1e2908fe926c68d748cb3c895e3c9169eff3a4fb6da06b13807e132d501c561979eaa51d39bcdd195804b207eb8460ade60215041a77615fc0bd8d280e7ad804cbe3e7ee57dc61a9d65236ee66d29261b3d738bf6f618f0e3478325c92d9a05903f999fe9a1940f594848d6970e8e4a348b860b3896f065b50cf9c471d9676768117b3e2977c0669e0f503c826e241f5f0b31f138fdd8c44304ee8442f7f7ec584f6acfa31435b03d305389774b4dc58e30a1bd7b7ea6247cd86d5be05b3dcf3a2a689a696b6140f239ad2ce9c4e3e36dcd7a48257ee2aad064861f85f5b5b726f665b0a7a1f43d02b3a3d068669304514af8fa9d52308c8a3cd9af2724ca31eb3204a89ea76b8dbbb59c94e88e893bda281d9caca2dfa3c57dd6885fb416e7c359f29c2d8b1d1ce746911ca6bbcd73d283f33a581658ca6451933e3806013f85af2a14859c90b14f6a7c6ebbd94e2ff1ea28f40f24553adac66ce816727fcaf03cf3b2b4b7fd58b51dc6870794300774fc2174cbfed005b73e769ab836bf32c93a8cebfa7a6a46d1e84c6a5c77c6e155fd50426efaa8593cb1cd50073fb0a9a52563f9b2db356f644a89c6d326cbf06cd72cee7851d3b12b493e8bf7815cb73fc83a7a5640dc12a157b008bf696c1a01c13035f892846168f625a6fa5f7298bd5ecbfab3f6575a33bd6fb01e045d831597b34b527b186ddbd38d3ad880863338cb76c957ed48e058e2131e56c9c55de67ff63b0e181f39f9b616256fd764ca1c8087d1de30c8b27c3443358881ca04ca63191e13785df861c7403aa3b4cd354051ae54acba2106b379e22abfaf71fc4e2005d325b47fd2932a3e68dd9b7a65fd239225524895052e2fa719b7e3cd01dcd0e7b15ce21942f345150d3570a23ba92a1ce1c3b347e14ed7c70a0c32fcd47b1d3f3013e0b90d6d640a6fc2292d5b0ae8ab4cc22e719eb7a18e878c9cedfbbeb5fac523f7e276a1a2b7925852d579f9e5a69aca10733cd886a7f086947b6616ca89a69480a92cc5ccc5252cbbd73c4b0ff80759721cff5eaab7869ef1c0a4ce3dcb7055cfaf0620ef5815e8116fcb64d4b7d8df87aa663d63f87582f05236a877205cab2f43baa519cbd88e66e3a9b92ebba785c607edf74073316370f51b83b5cc780ee1e906de8a5dd6cf525fbe2a2b8feda00bb81578fad791fd2fa43e45672b3ac9a7ea0b87d486ed03db84e4c02a9048aa313f8fbd8bc79b5492109966246cc0c1c911bc66fcde9f8e78313b439e3efbf05b9dead502de6104bc382f53aca017cc8852e3d2a67949c6fd8f1944f95971f522586db607f02fc49ab6a24ad6a2bf0ed4ced04a04268fd121df773f2690f57bc3df366bddb6aa8e724d8313941b888980ae2d9d8ddfb5607c99dade8e83914c291745b6ead3f4bd2579cdd07dfbd63241cf2f1ddc2fe45f4e9062c0c83a33f716ff76b38d7df2de966fada9032c23056551001bf698c153b26f47e72e68aa934ad56aaf6fd214f6c46aa22d9bdd1bd1948cc747d121d3b720ea809d4fd4862a68cbaf4f4846751677b2cea455bab1f2a79ef65c85f30b3d40e2e7fbec19488805f4bcbad30465394789abd4f9b373ce4f1803f52e53f1d96dfd28ad2aee3cdba384084f69e83e238a1eba5c084b07f337150a7505c2aca35f13955d92e351de25ced1304807f46bf7b882e322ca5325b973ff9cdc895435ff82b1e8221c83b17c931872f19a647611682591a650116b07fc02c48621090275bf2509b38c7de44bb97037cc4e901a2b483c1159424e517ba77ae3d0f534ac2ce417a0f697060afbc9d23d54b426cb9d626a6694d4f004cb4d7c386f98370cd376e675bb20fe7c41a503f61b6abc2b0e5d14cef5dff08b96749255898b5c395451254ac5f4ddb0d78aa466385da071e39d242451436937db1d2b4be1eb787eb1b1435dc0a343d6f803ecdac1f5277fcf7718693bfe09129144727a8f38a2410052270ca61bc807612c284e7e7915131badcc3a4dc7808b1801839b9bf0c6c9313aef5ffe10c1238f09914c04a2d473edd20707cd33c0524d7ddecf3965d5c2fcae1cbb2f12b5f639206efcac0a8ce8238edc3ea285a37c24de751a87f86552aedc9586c65b769ebc3c6ff1b90494899d867d65a7231e426a2e18411a4462355fe69b38a101740524072f870fae619e454be50e16e28f563899a5d82a2659278b85e3f018b3e404bf67542d35cf8d5e5f96e1e074282b22e8d8ea90ad48d1ae7457c19f36bb091747ffb9435f57de60c8d98d143f29bf772d52d8a99799dc78827d9a23e9bec396cc0babfec29c2fe49f11bcea4a3fe39cf58b4f0dfeaa93ef0e2dc3ff401cbf323c5781fe7148260b72057b6b5eae7467f8eb1180d4f1e0070ecdcf9f0b474897e8568e4485b9ec350d4bfb84b32181503600699535ddce8cf0bc514e9d355ea7f97c2e298cd761e30d073644375d4171582ba054ea43e150c119eaf0fe8f3f5b67b1dc3d8526bd9be4bb63c9432db542a0d5c1019d5c56a228711f5f8b4873bbd188e1c8b6f50afeae0a5248db3a77155f84066208556867efc75a6abd4d3ff770340d71f9d636be918c82766b84658975d4ee2042b33990e2b7b716119b1590d5f532c5122feaea3383b5c6bfbd437b21c8b1b0c6ed36fc49a533976dec3d4315e3a1c3db7909e1411789fc0070b9b2f14786c601d07598cb525353209d1522395c1d22f3c92cdf94def6e1671df38936448af87306cba88a5ed6208ed96d80ef268d803fed3f1b9c40ffbe9170313315afd2cd2154b9835be05db8a5ea47076994b58085959584ddda2bac7a373ff52caeabaab8ac2364db24356c56f878e6bc5bd5bbd020cf0754312d236e6d610ada2bcef38a713923d32c817552024458af785a5e5bf674364a0f92f937106a94dae9a3ff50e78a0b013bae7f71a39898fb1b81265d73c8bd514f1e5bfa58de7121d39ae1c9021d11b629b1b3f235eb891b4e640ec8a50d29b05f513109c957e35f1ba54e5b081d94e5e19afdc1e833929617e3dcad90cf23da04c866bff7d76f3e7fcad9ec153fd5ee2170538af9bf700c3bc24d9e09c64f113417c63d8cd3e8de93fb9e783331979c3c97fc3ed4128e2241baafcc0159fe592953fad8bab1e428bc9630e911f9b712a81ad4a0ae6c32dfc89ab4747e6c90e1c20227077c92bb80b26ff8275f0c6d2ed8f279a2caee149c86bd7c4c3f8df8a22def213cf11270b2460668269b4495adc1f09a2b11a4bd7ae1c1b34ea2cf2d1d7808bbb1d478bd8b242057a2faf393922105d8de983d3f898221c05327978babafbca57c4b17d33d5b3dce26f3748dbd73cd49f32ff5fd49a7eaef7245e6388eb12a1a924d33ec4e673b1e15ef91e228c94152d0c1c0884a065f33212a4161abaa000249e29dbbcb88922b3da32b55a5f8b489e4924342f9c08891e6b87f4dd3fc29499eddc8411231c5e696e77f697f26ff98a5915e12eb070c22128f98743ce7d2c3acd469ea8e8205e196172889d6b82988b9128428b3ea5dd52bebc4c9d5571586b4ee782b48c0298e8361a6626b99e53b1c43f116a259b29e16f193b8b55356caadec7130473ae4d38bd5d8d503709f6019b83f48bcd235c73f027d5eed7cfd991bf61ddd0be945104ff1c3591f14f13aba96089a4771d3da7183c8b2a96356f8ca6e678e7ebd77ca96bc7d92b33ec77170f71a8bc7a16ee99c9848e3d054321e2937d440e73c6728d2d8dfd22ae92067d57d285fb17a793a8cdaad80b0b40b55179cdac3fe3922fb17ac6b96260912fcf67035ca918280983bb2d9e0be2285c1e3a12fe76df06495f0cb44792f04563497ae1953c0f2caf3bd613544b650358b83718e4b93db42698ec38d05718b6054395e1e1e28d4044969f782d1d9c6722100fb7f75c1b5a8cce124a5525667fdac2c29694d03286b646313f41892f80470d4499a2045b11f70a959a851d4d242d5fc0474c802733effd57c58e70f7704b06f158d250807417a6685d382831065bfbc73112b15af27726ea663eda07e43cd72a474e8ee0ada03562ac864836e841af73274e64ba9f1f2a6fd00370099b86bc6743967399a02c23ba5e13db80c0dda9b2e8f71b1ed0e09cf68371bb75a1aa7ddcd982d7781b410b0204a253ddaf905427968f759ed0d8c3bd3f973c2bbc24ea1aa85313c79b9b62b112ae75c0abaa44e8254e9f737445f72b3982afa3e175b12cfeb811321ff4164fa7e1e0e8521ba4f4838bab2e91398fbf68195decb53214ccde9e297b50be27c7aa6f4c69e2142e499f5641a40da0a197532a1839a64f061724fa24eda4165c12e110eda7b725b0e91184af2d0d368f766becde3dbdc03f207f50873abe2e794f41876fd363f79c48f4c7edd93395446a34f92f5f262558270081383ddd265a1436f5b30754e5d1b96b5520f867cb462f638393ce5df2067835889eb78eae37f91c893a5a2e104a7a3b1602dbba12b840c2ffe0a8e0ba6ae9e8f52423aaf6d45feabb43006e0154f571fa73bd5c35b0445baca51457dea05050a5f216448d2831b023af31ad3150359cb75c404f3bd044a9aa1ef219af2c550998d39582960940a4711290ae2332e15c4d7dbb46167f996400be9882dd9d1e431b06ab54bee64128a36fe311c8398730ad8412f8d6f1e30160839dc04ea59cf3699be8768ad80fea065470f5eb742c7396ee97bd8a29e9004099062cf7d69e18e16b7e65e4842bc5fff173073df83014c88ca54673db563de060acb39e0563a991387ef765af9346c9c38660d675f71eb041b17c068b5b4124f734ba137cef6bf7b3082b058d1d55d9c67cae7f86fb5f7e17ca2346649f70663bf797eed91ffc41397c72207bbfb3e660b769ae39e0934f1104448082a96750119d91e90e3f13f19ad37c31d11aae5229382381c4bda3161b04e856e8bc43f9ec2c8f0468a67738bd375288367669c411782d895f8f0a7bb703106461de3161833633c85a5aa2503228b742df31eae234aa851c7e24debd484cb189148cd3933e83460927ae71f3d287f0535fbf2fddf6b33ce158618dfc553ee7c1368bef2b9d91ea76a535ebc7e13b0d63a80f26684d66d0b95421a7235f925bec22e1640b9deaa3c31736b697bd76928be95003cc23f3fae821c09b2021378c0c6c4417787baa23d1bbda2d2f992e3922a3dd6a40b542ed552b25fe22c8d510167444be2448ab805490469c2806bf38ea7e06f92c8f24f090743f9f4f54e7d16f8c1e43f6d06f80d07b1b35b8d2ec7fd054117168adf39bba036f473d422204c6e724715052468bd51a675aaf4ffe60b4955a805cd9b3c5757a0bae077d75166af0dee076277bf504c968858d5f1e8a58e1bcddde9630550925ce03ac1dd8ca826fd6e66f9291b8de8f0ee4ee86ae6b09fd3560e05387c6e0b8a2dcfe384eb70401884c4392d74dccb5ecf729fc85cca9ac975d9022a48d2455bed62aabd25cb8b2170dd31ff46e0fc182695d264866a431b79c560d3b26c44f00de5d03a54862f5c4eaf40bbe9084b86fcbdec46205274eb45305f5a1c357ef2c5221a628c1196295b4a4358319b2952a9429153c73dde2b547b3e6bb35a53ae5bb093bf439088e560084f85358077258f14e8f2b28e3f0e2b3fc7996ca1ed896331af4331560b146c6d9091ddbe0cc32bbec262c05d78544531720015be21d28e802964cb5462d29dc151b193e6dc510387d3c7c979e4b59055e3a98320d9288298e59a3d3e73ef8d3b9db5fb148209c6240bcffb30bcded487b495b4ada89d0f5e4c43fdad71a88f40ff6d2eeddbe7746a4a0081341d16592c84e673208c599f75e8034ea1782c7c4bac69566577cde7fb5bd2516d224949ee89529bbd76a62ad2f2877f5555a4e54886c17c9a18de097e0f6912b8604ca162db927de7235b07e547c20ffaa8b47804ac4c5f9593e07a824cb95570732758e9f6e4a165dfb26080edad86f842acdcef681b9b993b96a0b3ca9c1a952dfcf7f91e46bf27a98af9929eea2aea64ce9197e4366af98750dae869d2d4ef118943826d3795b9ae87ef705c677ec022a709492f6ae83fdaadaf1f244906a34e07f21f8d1ca58247365943a2b70b4c70b1ed9d41b19891eec3ebbd9ad458c121a3b1851926aa1db0b2aec72db3138d6c6aec6cf1c476a9e9615a7d81b7e68173b641d6d3ec854dc1bce9d8cee244686f0f286bfc2d59674aff9914a83a5bfc47ab5af5819d26cd4315136f88b2a5900da2b82f46ec3b239dc3fea50e8c9a94bc2e517c3be9885eda1d7f37c68e7feb87c6801281fb9e397a447877197b52f441b643cc5be4bce9684b21b55009ce2d98d997fa2b7c6a7781783cba7d0bd5c8514545523ed56cc53913ca0ea1ef746723ca8a94582dfa8f72e7bc4b311b9bc70b7e9499ff790dfdf11efa62fb8de565af68ba8585667754df76207d6b374e8cde3885bab802be277e3c67f77169e715e9b6a377fd5168ce49d60f9a95afb7b8cd1621eadb8004b914fe79cf957ae89bb1e1f23dfd047f4e7f71a10e9022a3b933e99d74f534dd5d495521785839e6e485b1c693ed436489d6f16566eaab6df3d652cdc10f9626f695b9a552b43ff0d2d19870644602201885a3669a3ba3cd742918025fa3398a93712a2babc2c49944bc4adc757c805be28269e360184abb5de383a092a15f47b9fce13a3ed4da928d7e2ddb879abc5fef52a86eb8a6bfdfdf3d48147605809b7e936494097d4ca1481efaca7d7e8f601560066eb53ec49bf85fe5d86aaaa1934158a77b684370bf390e9eac95b435d65e9f65cbd2823bb1c97fc1f9a79992859ef771f4f00cc42f880d0e1e2ea30b584ad705aeef57c65d2effbed9a8b39b8a2e3329d688ead497527a4ec43e39aad0927dfb3366e0ef18424fc41c489a3f874850fbb7c89fed377d6938d655097ab4d1a34fe33c55f78691fe9546e0d66534d81d1c5d5e76aeb53cd9643252cb99103577270b82f7f056b1b4b524e7b54952a16fea0a9e87155cb04a710f22cd3c417c5dcff8c5cc92a20447aa4f6f7854e5df5b054a2665f68434ff258bca826928b8b64cc8e81b3d487f38fc7764fa5758adb29e4146a5e694530cbd43bee032051224b2c03380b8f5f3233c1850d28bd94ec78b60e883d6f9d70ce571c2aac4f0d4f7b7e7f8cb8299a0b61d23663eadd6f6d44f73455680a8e2993c456406ade860d471efe294466cafa859a21efc26737f46311d182a3ddf1e1d3381d8f2f795ec8fceb5ab0f078d2e084192bd66a50054ef1aee547fa5844073339729b6bd99bca1d371b5a5f3a543e0c61862cafadd82fc34588666f1f1fa55bf50b33fecc2fbae5a63df6d9b3dc68765d2b1aedae08f2cd0590d8e671fd71913e284e65b0b7bee6b8a4209e330cb843d28c8968c9c8c51ccb5c482730f8cc7371ca6820e6dfc1a2e551dc9eb5d322e8b39dc0ac13c06fc52e3e9a7df3b05ebd3cd94ad39913ad148d65dc3fb95c64567a14772c6f35fa0224dd192892a23469c196c164d80a0531c5c0bd393baf6f6bbe97837dee5ccc6c18c84e8340c5298f5c89cd14ed543015bffd79c017416dda06de988dae22d29b2b19dfdab100d007cddcbcaad94c86823ab37bb8f0ad1d50e940f9f9c0efc1efe5fa78d72a7f55f795e95d742ca1b20651c18627d44611e0f1cd3cf17db797164d8cdef279cd1238b21c3abdbf9f035fa8497ae6603381be3841cf2a93e8357e7136382ebbd56c3ae436e4e2111532e23e8a4653a60758ae187f5da8b521874c0402600f75e80c8ed4065001855bac1a4e40202063103f7261eeb455233cc22cac11a83035fff232c46d8d4c1f67617b953e38ae22cb669ee5fb461a5ecd575dbcc5fc08a86e766adb570171e08c420368e8bda6ff87cb128f1b270015c400b8bcef923882310895a5985c9a3c714aea21ad2cf22035c0050e2134ddb26b1f528f3d45a88ddc739a4bc9f734eb1ee3c575e7144b2df2a11cbdccff520b0123f0e9a9222b58c129aed67f229a52737fea2a0cb53b7234bb3f830e9da41b495dfb11cafa56504cb5818f91c0fe17e4f61e64ca4e23432678cb3f9d2ce1b179b20d2b35b33243d0c40e39b94af47c8ea294ca995bcea5b173d4cbb4cfd72fa725f8fdae828ef46ae33fa9552253db7be0b25ef710ef7cb479b199098ba93dca1495266abc204745d5703573d793e2104bdb0599a3d86a69c26b8757628577fc1ff43c81c36a77d3ecf4e53517ff486eb0f95f694f8a3ffd5bb51ca89c74c5c2ee1e5f15c6104ef8360c44924648cae4f705ca353c6601a8dda9ae9ad53e2749d5645fbc156d396975bb4e88efc9609d406d76f1d4c51b802eea897647f5eeb87a37e2a9d3287fd2d426612476a1602aebd2c2df1daf64abf660c6703f2fb4b5770e2f379bdc342af993a660490384533983673d67c1481b93de26c59360130db4d7c9424be56711ac6c0e2996a5e2ee3ec10e9bd551ae9dfb1ef48251af94208a483042123d4e6c71d882d05d9d2ea155358e42dcf3b830942b34492148fdd10d540e0cb7db8e5074cd67819857c49c48eaaee0dcb17fda4abf18847c2bce4035c958309d21a5aa1473587556618d021ab0bfa922df3e21a8ffccc8b2bc028cb429162ac8fd138bcf878440a0795ca49eeb1f12123be7c9de23e5c618bd83fe4a7a9f31b8dd557398ea47964df8a698d1601abf4f8cd7b31f46619f0c158e221afdb084db0ade561e82d2fe1a844679e297888c3a4f4fcab87fadc02aa4fc6c297aca37b64ca38ecdd97645c524999c727ca409104fdd8fac19962c5e9a5c1ad6b1f7358074229ba524f3366b7ef2540142ad6545b55f625e7ddebe349bc5f6bc5a8ab1fca9b77858497f70446653896a2e2c34ceb279d80b53d246b4aaaec9abcb08f5757000be8bb09cc809691a649c3cb993ea2a7bb2896626bd07a2b54c2ad08cdfd40a3697cef3b8274f24907de05945f220521743933ceb24eb5ad62ee00b28a153615bd984357cb59e17dbac14dbd79210b77c62143936f98518ff5b75bc179ca0d3e5130f65b7daa7922e551260d2961b9dd621e9ad5d89f429e56a5bf0e6c3c46e0f4c6852a6e05dfe17972a2a3faec50913b2cc74435d6c87abf065e5c01e63bb85b581fda3029eefd82b1bb3a49268b30bbddf8f3dc8ab057759247d56656bd6b8349901b866dc6541129536da6494f52f7e547703c93fdb46aebdeeaa7230cce907114c3f71475752f8b67c5730b625bf0ff83b85303ec5ef5ade7b99b83027e5c4c64b5feb591b989f694cd70a6fda84018215cf0e6087b53f99189add6d8f29337da36513d3b8c3c65ecf43078df8e96315264512d54fc7ab4d2467e2b98094f734616d67e8d96e7d4c2599e357fa88963e7475593e102d134261c1d5a5147966ab0903aae84bd38598385e19bcb80082128a4a92b0581e9927ef5df8554dca576e0947a1f88e20e331dc11cc873fd8f1f2f234a8a57a843285af7ac13a220530ce7c7c0b079362dc013d8d2c0ba4768d1441771c3ef67a9c8bec38484a3b2a658fdd3101a09f33d97e498b8f174bc8e6a004001eabdc2095e866c49286a2857f8fc26a0830aa45fb1d2ddcd2313fd8c314223c9ab4f536f6c2a43fc739912f5589c64fefe968d39781c6fac8aa81bb71047883a4dc01a8ee5c444dc3848d2d40341d59a5efe063b809d9e1b4f22b870c7f217e7f9270e2a8678aa3c4174dfe25a5bc3564c376260e11e3bb3bb89665ad59b91eb6cb6c7e0a56241da0b04bf355133e5c819758408ef50fa9cb48e2ca2b54fd6fb0a179d82bbdc9f292eaf543e6a186ba116eb7cc92392645290eb8ef1edfb9f84843678783e60d608e8dc2f0275cb00b65e9ae84c047b2c9ea9e11aafa9b385e99b07ea670972bebebb2f0cc023068b05f09e83d190338804398dcb8d5fff2f043a1f66293c97fe1dae53a2abf1e4a44331461abb885f109e9a5bd453502bf4c4b8cf24637e219b1241e9ba219199323ca37333d0a18dc99b1bb486af2eac01a814c7e23d82c3b7a4e7ccbe65990f987187126cde7586b2e18548368dc0827e3a3277202f3db1d9637bb017dcba570824ac01ab4531a3e105ae18160b2c347997fdcb74e61d260861dd3bf323afa870c2820e868102e954ebce17770b1fda68966a1d42ba5024073f1a91258a5eb174a3216ac82520ca63eb63084dde3ba2fce42302a37256cd03ce11e13354b756d21d6a370a981fb90f514ad6a55f80ad2f23d2248f8f6c51ede1f0f37ff806d5af6c8dc52dd18fc8421ea2038b38f34e2af9631b6e06cf7bc413b51189d948997ba812575c4bfa8d7612516632a2c0db5976a7ad099c7fc92af6f87639241592651401ce167580cbd85c4452676f8a990e2ebe580dee2c2141b171b8f17be1eeaac73679361c4791192c0f414989e19ecd00f37257182de0de3ee842b982305ab2ccc8d5d3a7f91bc377c57d9c89dfd7a8d03f41cadc2bf56a56587c5956e6fe084f4cb6318f155f3d73b84e6e3364914f5b14be0bdf0d60ad8b6e7521f0e24d5a0f2c18cc16182db4a2919ec1a44300d89de364fe52984fbd4c5054c1eabdf089626c895206b001fb4df3bbbfa7d335ca7de57166bcd70bd5e10c660561690952c038eb82e3bf4a9e31faa4dde086822e5f2806f0395f34b5a1636d8e07d29943ed19909784e3b660a155e6e89bb3df1f2a5a8c018d27ea16e1f5cfa9bd25bd5e6d7a038cccf7b67af86b44610ab895d2cc80208ee29576396ae79ff44d341e7c9e98d828e472bffcade4cd20fab2309cc0e03625b5c0c515170ac783027f38031d6f2297bf2787414bae5639ef9fa96e8553bdbc61253c624538e1c3690cd8e60b244630e2a5608eaccec38bbe0d03f3ca916277797df2a840dc7a2bfb3a0ac3f16c9c3c101b9b3a635247e0cc417513dd3f8b21c709fefaffa67c57e867c0abd4be3b16962bdc09f87fc5c858c947e91b05679e9ae2b1095181501c2199c451963963901f41a6db6e3c1c1acd9dfa696e737e8bd2ae4e831d08cd012591bdb27de5d93d72b5f151de733c4650cac5d761d33b42c38905d9bf201ebc91dcf232463739c779e2c29b488bb529f6ab1825ccbdc3b2a525662950edd300f2e8d36d0647780262a168c3240b8f33cddc813af13af12f0a5ead59013023ac256f4e6363a61abee4e36c1ca631b54d69173b001f36b43045d4a75fd3df2c3487f2e06679f1c5674832529ebc5aacc3b0e0036daaa5ddb127a049ce2842d959f53cc6c659dfbfdd10c46f6bdbe11460f273b7437adabc76486c48dc3abecfbd51d695f7b875c91342aded771d7e00ee28d406172c59121363f959bac16f6b788ea5975cb68dcfb234a9cfbce9a979fa79f7f60bf08d0ad543b14c7673d373e165c415d68a59fa4f2905cdacbc49c2f40153e7d61de4c12a2f99da7eb50a89a3930184aee5cd98b8b52bb27b0dab17aa9edc2c3c45b849a7f44bf0e5fdf4a3cf1d010d8f61cdaf6eb718a9887d9537f4f64e429f364c4804783a9910df721d8a16cb18308281ad92c1402f37138df21000f78c3f18d6041ed32a602774d8d57676d204bec27b949cb95db8a86b0312ed0c7fb6ecdccff2de76587a5bf9cdfc2ede42e38b859850980ab60c1fa3b3cc4a2d66692c312b09bcaaa6f8493a6ba535be0e719fcca088e6b2eb6ed6e0e789f7d0ba43c1e3db721ae8a0f86cecafe18100007f5676e1c31991e542c4a36edf9cb6164932ef8a378520df6e2eb6237d21865f9b9e3127571c600940d8f95e8b07c64c3ac3d0140d3fa0f78232cb15db6309ccc5d6bbd4f575daecd05c95df10237a36c0fd24235b6b2bc49db691eafe7c734c747cfb3814da0666fdec8442b41bbd399e83a3178d4653c3f8b9604ab22eddd99a22d54164c41dac26bb042454588320b694d5c379f34a2be2eaa24f90a7d4261ddec653b56feeab5392ff25cce703619c99c8302ddf7291248582848ac8e7fef9eb690ddf4ca798be736b4b83aa7957f0650ba613a9b1db6ff513ad695dfc79810c9a76e7f9786b0365da3526fc8d3955bbf8bc37aef9486f1527d418afc89b915797502d280c7042c64a3f0e6c16ed80fc712f4d242b3212357686924402f9bee087f584bcd4a8263b59db62f80d217777fdacceb2b883d385d367b104fa1c00c30bbe2347c4eff91e85dbcd91844014d6ba1d82715bb23e01cafb45303f5395bb89e3ac1b454596e676be62f30192b2db3fc9f02c866dafaa9f74333c9b1ae104bbb64a5d2e927d70c46b4d811039ee9ea4f010416a391a1b3e8a92a1a32b0de3df63c17ffdc08b2829dd7a35af1c0e41563b45a36792e4cbbd09952aa7ccc1ec85e5b2ea6d93a08880228072369216ee0103ba42077bf38d953de740b5d8a63d9cc49a3244eb7d0039a28d89e1f4c79d0ef646b7dd2c13b06e377e2e115a9ed0fbc8afc811dfb842abdf92d39be27fed8847394219fa3b42808205ec61cc9e1beb06eefd7723e97b09052dfb4ae2fd3a878fe32331ff6e3d0c674d7847d32e516dcf34b93340a30381b8678c273864454e8e43e97769520dab186f4f5ff8d70cbc5ba8746817c11f5f66a7e8ccfaf8463d246b9fbef4a4354de59ad252c1c8561c5eb603fb36ede8e1d2b8fbaed76f96078bd5ee114756e791315078c75e3d963aa30a069b8bd6496659874842198cdbe69260995bb55668e71cedbbc089271777d7b499d30009cdc654038ff56a418d2dd4358fb30eefb98015d8212a9f628fd50aed129c7c56c76491729c8dd2ffd3f5b6ec729b1fa273bbb3c9c663499e9d2d524e2be13d72c495ebeb3b6105eefc20beb59831484e0058ae3b7eeb06b5edb66c3325b2116e28d7a521d9f1c774f8720cba8d98a16df1157176156bf587ee54bab46f04ad3bedb012d5de08c706776b23e12960799eca6c20e3552392b9942b7c3c7c8a4b039b5b140a07533118c4f8c28ef06bee0a0fd5729abeca77bbabba4564519dcb282b496eb5523885a89265350db6bfde62fff355d36537224a8418fadc631feae227d728acf6ac2eb6a27bb5994d26c28ee8dcb758ffdad720f34f44e31981349e71f3a3403f613fd82da194c6bee2525ee774810623b4448ae38ff4b9175497b9676fd84bb362396429d2ea2560080695b9c753e268d0d9739028e3e45725ba46b5a6f3b4c7c5dab50389f43cb61c5d13da63f0b98478490dd0d2938dc535af2b51603a408db6702d05db4290c341e46f03dddf49a880f6c0fd5f6f777956b1d435539a8aa23d6bab47ec65a37def4defcb4e26147fa74af151040263616333cd89e0882d21a45917406de7a53cbd07fec3af26cf43a6f86e0dd19cfcf6bba78cce1478dadf3d20c3d97d19de161dc4e08e8a8ffae83e9cd8a056d3297d18636a98078f4dba020d69eb5ce9805753b70e7639b0eb86117cb6f2fb17d35799c0cd99e2a5fd386f2e75d72dcd3d4b77934c4edbc06f60d78513be9053084d92a97d473e620b805a9ee0aba3ae29e89468b01b4a9fbf33179971fb971d61cd4c1c8cdf9e10413e5241fae6dc85d3d5f87753862b3f3c930a49adda4c9058fe3fd3eaee1e53ca5b9097e0ddf6b1ef1cd7f94ba2e031e91d16f4f28b184ece34eaed774eeddf8ad731f8e652d7a7bffa9ca9f8f47b4ba62e2a84124dd4f66bd05610e889a6c4b6eaf647a53b0b6d24f57edd172e35b0e7c95d79817a1c57e9a22e5d26496fc7372bbe3a7fdbf474bbe7e7d3f767a3abbb2e7003fbc0bf1cf814822a9634f59b18b204af7bbb970b06a52034eb6cf9e4ea5bc5f05656b581be9f60126924c6e19a9e650770199d5c50023f803fa319a1a50b4bfc7fd25acd8617f34f15023591960e0bc5d5e6462d8a0ef2c36dfbc6116116ef8b7e7892cc18f50dad80699ff7e8f53b775963fa4b0cf57cf24bcd89ff5668a2689ea955f10334233509dbe91fe2204d59f43dcb867617b647f377f71b6c3d4de71b9828e9ad2e8fc5826e2162647ead8554ca5e34699793ff1d41b90de5c48fdb2176a3cd18ba36fdfd3c617bf5cff098497a4cfefedabc85f4489dbfd59e0ed205b1d672a1dce6764f84d12b4e23ae91fc044ad78878224e92bbdc97c19b81836224b67ca6c68d7f6ac56bc8840fe8703f9d83c2dba607a4352182aac46547ebce07fe546218e628bc840b6c64a4dbc1bcfdafca749b2dcbb1cb7924345dd038a36995d385ce549e46bc7337c4314132671df99a5d7edd4939c47f14fc442763093f5f3123a20ff9df6474eef906b97ddae898333dbdad1e77645ccc27ccef91eb2866562038df2f9aab826e080239527dd0b55e4a49c0ff7f8688fae8224787a47a39bec79e3f920e52c4676cb808c058cfb1d8d42d68e5b2fc954e4cbd912ae5ec80492e410e5c4de3bd4ab570bd617bc4a6246c035e98bd20851c70712afdc38923485b8c61a810484f2de25882865b68139666b8aea2f9895a1b8ab99cc9f759707a70918ce35f361ca5bfc54a216ff238f92076f0b615e713a5c0bfc79c81b00f7153d422670dfb7de56f3ed510a7cd56fdc569603285044085c670e2d89506c21d9b4475d8c52114e7c240c4d662dbf1608480d7daeaf9a777a3b776fa4aced94e8397251fb75df127f97ab60c2a3a1d098ab24c01b429a668885e53039d7c3c7046e9639ced2e2bb4f7d4abfe2026621fd7b30d4451e78ae30db62d4589effdb482d4889aeae0739c8d7140bc7792153e806a37b8761eef48b4993920aed2ed05d521c4b45802b1760eb164b964000e260840ea843a53983375d5bac33e545339d530b1071d5077177404f107c7f79aa69cf0293b2507b73c1bf86667d5e8570dbf878049d7ade8ad34280f7632de3f596af3035ede92b8615362331507279fae20b542bdeff581b92f2a5fdac1bc638705101741944c085ff6e5f69dccd7534684d8adb42c9b9a6735096f39717cb12d78d9ff786ff4b7fc9c5b366c1d6bd4c49d3da94797aed3edaf7c07909e1cf8a9e5b11d3a4651ff6a3c09a39de00cfef4d1ae68cf272c477398897b7f28f8d64a8bdd276372a105a7a8decbea00e94d54dc8713428376efbed980ee7e0e8d3c799a06b70d5a5098b580e33938c95df016bb7fe21ee7a133c773edac1c3a29a0b13e2ecb524cdae0d58e28253bae2ed83247659abc6ca9fd2d199e2942f47beb0ef121ed366861ad395aa910711bc263d7817fad0deff2ac5bc70fe33563e7d39136eef284a938547b7d32ef07f1fed1ff5adc529655d48d899695278f63ef014e180bb0c0ec8b8113f7c267d411bfc881f3024b4d1583bb60286d0779d96d1da5526e237efc272353408763d421e47935e3900a30bf03f012c4e416f66a91267270aaafc2e5dd4489245d8b9ab64938db54f8f8821d4d47a5c9499ef978f82ea92299331f2757310ccbbc19339fa0f5f4b6143993b881818a1582c423a37565ec3184fc23c54ba3bfe6481cfe077b9113333889235edc384d57b7374e196d3da258973df88e9c3964d98989bc1fb986838dd67eb0892bb2826623136c486595559bdb2cbd10783f33a81703070d5e25f3eb39d2453077b8810213a0879fb6ebd487170c90cf6b6a812f2fef026562036a8460f12b4c1b177e599974eba40217ac264125ad9d075a14879e7e2cdbca832025283a510c6e96a684facf1de0b37d66b1eed8b0a6dab6bf73ec1c1d29b9c635d1b005d599e51389dadc8a09c94eaad0ac66d6a68549c5047429203252c3e81ff463db7396cefe0044c51b7e2b99905d7410d27b7017a382a4b0551b1d27622b5577b8785941a6e76b2343eb56c1128cdf34fd781a6791796b3840e855492a03fd68bdc5f70c2fd7327c67a6e7020a791fd4f87deb6a57bcf7ea6adc86b8d8b55bdb8c637547f1d5e3316cbac475f8b184ec2e6f3ada43d9a17a226ce7ac70f56f2a52cc427129c80373234ace36eb5256c8bdef6592b9f0e93c3cd147e5e14294cbe5530fff6cf6ade18f70bd342247ec7c5e791f42c8121a2fb53daf8756f65712b478bfc0145e33517e1aeeedac9af593eb1a96c39abcc20a3c2b27424ba0634e4ddef6d918c478a985f88101f99721712136affa23fc3d2b18e25700c3346580059a26db6d41d65ae3a1cebf3bc1c08cc38cde33c20adc50e7798534658fa989ca76bbbd619968d08b5a4ccee53f8b69c5fe9ee363389bd98867e5aad2c91f833a2e4d167bc10028d588767121b1dc82caf982cc8c3209659d0a3e330b89b2911fc2126f18b027c8b92546ae62abfc5769d4a8c5ffc3d9ad1f22aa9210c2b7a0fcd4c8f997100a19fdcd9be78e96cc952cc67490701e036640d8c040221aed83b924d366330c904c990ba6c1ae51d944dd9950d8864e5c0d288e10d7c866cc402aae1ea87944fde9772d92c6209b0ad8af290e39128781c61817f30ffe2ff7fec8b90229d57fb4861466cdd9eb56b5cb4c31f219412ce90414312e17f83c39e6c1941ce442f2e87a3ae032cfbcd9b286e716dd6c9e1467d9ee0de8f195c4d56ce488bb72085e39680cdd75e3914c3b42af1452595d5608c30e1c5d39d38f22a98e4e18469f257c568334bb4e9d47ad94e8d44022e84fd00edf99e60e40c3bde6934fa16041474db8c14c9249dc6b1207fe27990162dbc7eaea5f83fbfbc01e19046e45e8d14a84933298ad5f3f8417431f81842f1ec70b025c9f3a10eb472e9d6068e49b9877d644e1a6be0ef40972299a14c87e080869d60e4d60d09921310bedc234c2fbb0ece03a50ffb1c67724777209d3d4de5e6fa58f690fe9cda8be9e50b0c8013e9a909bf243a42bc2bd6ded7296276513925b5a0b6963beadbd8bf798645a8ef3079c81c330c3ac7f48216de37501eadc0a007c4e101ec3b471a90bdd422b01394ba03dd8f608c7149038ca1d9e541bfb1ab75e54a0ebb16247968c362b506161c340179ee4f82a5b48fd02397cd2a70f6cd65ed0951930cc8314d0d3666f252ea63047ba91b0f4262e84d540f211fcbf5b7dcfe27c2266eb3344cc9942b245563565f7a31f6e5ab1b3ac0fb5026cc38079ee7430d43862f07f2cd12953a0d1827585bb10b862f831bdc7f985f3c49de1b8cceffb7b685e08589a0141372b5d64b36b0cd83d6b2d2758c790acdb8f5ccd5e675e0a6442888a5f6ce53ee550a261ed39d39e76f6fdda2adba482d9d565b3a47b50d3e0b91d61c4d1868a9dbab7796a21aa7929df93a561ac7b17094c285b923b03197d349e5d746e9820e6557fd95b4eba4f714e35c5d52e02d5a4ead833886ec885bd657e58f5bd48afcae445acc9cfb9488d05495a072c9b7b5e8f35c80120f0b124d9ac76832decb2a49adf9e91de7292178984bb48e2bcc98f40197f97fe64b72dd359eabf5c4dc5488bd1be38a79b9b3a4970ed906706e6b4077e6039f48ca37144d27ab58fb8768d9765fa4f90c0d26384560e10a7a7082991970ef7a3d93043d1023d466764c750b35ddc474bad985f6528c364c48967c9185db13cee7c7ef9ee7d62de8e55f1edbed13461a4238044ee1e95d0f56f514a8e656662d86c63a60bb520e8769fa319459587c55a8f1c6ec9b52707994f2c0c063b55faed690cf45f7a3a7863cc028cdf3c2aa1b18229808333b8bb7efe74002e9acb607602f8aade177b3d47d380367122b4890dc179048867574b4f5910a0199efdb864590ffc37a0a505e0440bb62a8553801ae80b0f26877382ae4a92a67f8ec2d7c1f7bde67b0c15fedb2d2aeba718759dda91f01b834f940fd0718efc54aae04e33e397bdd65fb51bdfdbeb004b75d5b39d023405f53e93bbefb8718057fb3df76b12dc4c54c495f0398030f5884d8f9038315ae56fd5b926678b3d3aa03583426173d2aefce01212b40ec6a10a278e19f052a47e2b2c186cb299f7419e1e2557259998471d1e5d10db1e8de39e2513e387ec152a5e2e4a99337f876184f059704a547fe3ca8e23101f03ea8e08b0abe412a709af45ee14c42b0de9797f474f42a3cd569a5bfe6fc8792c7c3301117a1c6e61df3026adb94db36d9f24dec9ab463af63647ab01130a1dcf1bcf058bdd147742d0a0b9df441a81b31292f6fde27066cb4f1443e87f3f6db5b672a4c96ed84ab36008262575178ce133b0374473d202e2106459743088b0ad35140c448698e0b8732524e300866d3bf9eb74d26fa6cf5d6c050cd99b1999ca6df9801af91b7b63f975d934479a65e763e44afd999e5879a142def75c04a2e7d8803470506a4763f3cf5ac1e1a6773f359d6ec84201da32cd909daa8f85cd45241922f24c4f5d183f15bc05448475c968b29b400b4a61113f77b116a435c174e5a6933cea53da13c98beccd59ad057078fcf6a153b310996081cd8140e0cc9b55d46d582af76896fd50b73026fd119ffbacb21299f1e85d9a4df79f2c2f2f8c1a751195ee5b7b838a3a11c4c2f04e349e975e9aafdb772ca5e140153dae54480e2bd0c28c768ca8e2d523fe6cea4ffc59835484bb08db9665c8431d87c5cbbf2ffadb29c8821d4f0e158e94a669ba32e764322149dbfb664d60773deeda8aba0eecfcc62f37b688f74d1dab9af73dfa65505ce3ef578d698e10ec27b235576138a140a9ad13923d12051586ac22627b9b15fc05831156b5a9f71b8d9766cb79a0e2557329911d5e05f4160675b6920bda5b3788e4daa8aa47567d218fa2ae3e2736c50801dd79f274bce15882a1face5cf9fae8022ae8f05106c126d127d6808d6e0048d5a1564c1b859c2d15e711b3fc1b5e045640680746e5737cae4975927f4ec1b952a6404f53d85dc62b06c2eb4b8f79c29c9707b49685dcfe14b4c4960a47d7c63a5a8343c4524b08c078d0151d5d0f428697720816f4b6d335b1b469ebf825c1adbc5f3822bd9061fd37bef7e0de6c705435dde117e36c0d8b2a84d89daf27cc68854a7c2e018e56e857d047621309505c4aaceb80eb7da0fe3957c0509649fc92760a9f15cb84fa5783928aeca13fa52247ce8f0de6cba050e2163c7599c63113247266d8b305b311326cac1e78b3238fefccdd6069cb2537a45a531ebd233f3b43280480360ac8f7d246d52729fa8bd0b87a8aad0df4ae0510e220688cfc164197c4754a4e952a16a60c48231192bd2a4169265714e5bb6e4bf60f1c8797b3379866a593da1fd9ff44a6b73c41e7cb8a3d1802d4c28f0594cf41812664df3be850358c85f59e23879eab75f5d0bf1941e727aeee7090fff4e2b3e9c9cb3d5f42de14ae7d014d9cf246e89f06428cc59ec607e37bca1774dcba73d177297bbaa1be0f7b2b95909e46246879b943bbd4b28b97c9d8481d848dd8ce04890b9a68fb1112af455ca72c994f9fa033fa54c4718801e70166e0fb02c1353c0e0cef216c027083458a2b203f6df4990055c4e6ca6360c38ae951cc94a9ff2e884643ffdb40ce634f1b5ea2bb6f2ca1a0d704b827fc1c42ccbcf3cf76e0e546781648ae172dd2fd2eb7c4b9231960ea3e71410a60a109a4d7864a73b1c29da5ad1b9f15a027562d0b5599311eaee89c842a9bf013e336944ef52f59f95fd2a83cf6f4e06735290df49bf590fac1fdd3684085af39fdbe3d16f66d314224f1c3c180b6b7544fea1710af69f25056a873075c97137152360388d0616827ac61cf82d76c1e992c819b8d70daea030b22014893aa06e6cd12cad20243230fea219e0896bb2d266a6188cccb9416637e4af0511f5cafd90c2903f4cdd818863713abe4b5dbbcafdd7d81a5a20eb35d70b12f676bc010ae6a774f832b3d3a19984970feffe939ebd899f499399f1a3a2dddc8da4b17114144826935bd6b4f732a98dcdcf92ae1676f7c6c65cd0a08eb7ce1ce1c1766e236d3aa5834c97d538dfd04322f165e2b8b082ddf4b31f0c21a79da9aae92407198c536f28d30bfe46044504fa92c8fdf8d9a53837cb3a1f90adb4f5dc9f3f0ece49a39978fa29939add6d0e5365a90c357db7cfe963cdd3757bcdb02b034d9a367329e1fb5aec5ce4277ec8b0dad050764db67dc435257286fc437bd61bf27d77d9b6bf08d7e59ae99538960a396e3dd42bf1bdcc48bc498f3d2fbb40f2138cae7b2a692a245a8c737c6ae63d296d8ef0a45fee51be0d5dd9324e4142f9a6c1c004e73639d51ebac18b0dddf9b55779fc84b1d8e930b2c9704fd0d821a5cb702e7fc07c0201b172f0e1b64405236a964a1a530ffdcfdb8b34b97d948dbf18c7b43eade0cc3687e98c052ecd3d1ade8f763e88270dbe301c7661163150d575fc7673c1afd01cd771782b7ed5f89717579a7f80d3eb399f59d5b5555c281279d4d596ed95a09adc778d7faaf0ea5304dcad896e5adb6d6398372e23fc12ccf00662d8fb865ea907a2505951c54ca5f37269180909e69fac2c1c3bb24c0769b8fd14bb8d543c472c14242e48c7aa0838b1954a8470aa2e9ec8ff4a5b995a8623201903f629eea953a81741e4012f1bc6d418958f016424fae43a9cf74c86f1efd80deb4dbb71ef506a47f5f59f38da0fb3d8d7c10397a49da3849ab2a41580b96b2c80c9f45a3ff6f3e81458792a183cf7e8530cfdfa4934d41cd5ce8d4fa72df516694271110808951df548f19fdc5d110f80f3c8468d3f52eb9bcb79c605fc3854b714c13a1c60e83d9a898dff92cc31a82f9e93e7d945b4839e41c6d0b64f0ba7287ee9110d6e7caae8be4ba9349d516d6c8aa2b12b83f40bd90066c752ff408210be2f6a17f27d2b4e8ba83c5c1ca45a3c17b95b91f99573b2c91445be113cdc1325375c10fce67c01c1ec8444facc6001ca15b1b722db3c4459ae71a9c2986b68b1d9220a905cf7f564d708810b08ffe42f9a049412d1fc9cd042da5ec17191a7e2020be6b42475b94ae0a251473325ccf3625205761c69862fba0253a1ad1fa95789091e25ad8462c895d743a462ef4c149e5a04db8f598d3d94c9dac2c412cf944d0114cad487dbf4768df70c3fe9781cb194ef7e8d05c5f3998fbd8b37d01c6ebe3c6c66f7a8710854741c3b90d671b89088b8fc9e7442f11ca5344c18da174e3b70a29336c9adaecdb7c081fb579fb1b5f9df0ea82fd9d37de621ce00ad93c6192e42ea8cc9522ebef2759bfc98c903f700eec774ba92c21623e084519c1ad8198da3f42932719b8165fea636ca25f3be5a275764aedfc524cf4aac31d5cfa486cb6df934d011157383c89637ab357d96676a6243172181d1e705545830a81f2e3fef4b7e51b41b99f3beb016b0a5a3bc1fb90093afd40506e47cd12776bd35884609ba68801ef7981fd53787af66860e8eeffffc6a039b28afc4f8b4a2d9caa7c5bc8dff7bc33ea7168a5adb3df55847a36f7f215ff5dd11423d7274a99597ff5ad4c166a37e6b4a1cf5957dfecbfbd9553326ca1353da3cf07bb857c3a6707e46466424977d220f77127db22fb1d7d05cfd671da5c330bb394222af637ca7d5a6419b2852ef77641fb1cf883dc2485adfe27671e08a8653db3922fc17c279ae933a9ce322dd27895eb29ce8c5532f041d780e53c3ca5e924ebd6eab54890d4bed88ca1b0883dd60a3c2c976b4684f4ff42398642a7f5a489481f7dcc65fbf08ab82fadd1ecb772d3c66c7b7182523305bc60ff5fa4e598b5bacdb54b7d9ea0eece789ad9a6c4b3a2952d6a4d5024972d5b273d94a6abc23a533ebfd345500b0c18e3bffd3ef4579c9650537b22937d1cfed53b3b17d0bad34b2d866c4e1664ebfda56a2a1b8e34a56231bf7f7970602ab93c2fefba720fd9fb834148d7b463cd3b026955a4add26f37b19db382665c9866a200f62b22b71c9c3339c73e1f806e393caaf50e408c901561bc1a09bef778cf84870ad7daaca816a6ce0b097462803672256b8fea41bf0dd8911382f776b44bd3c4fb0c62f17844a779be0cb418294c2c3b5880b818ef79c6c1aa77676aa472f28797aa4a34111696e1ac766c7bbdc565550646563911bd0ee11530aad1d02a5d46d82297d78b2030a10279b8bf3481cde17eda4bfc010d5f8b94a822df81716feed9b2aae8561982933d4db7d2b3284416a79a2f0751307ae1f970815088b2f11b8025ba7aec9dace42053ba299250df91b022e7d21f4508e2368c8f3829cd6b39dccb4d1bac38b541596efbe467bba2d86de656af8390be0560ec90dd112b4e08e1f8b20cec823d804a0cbe688f6ec509c3594e2c83ebc1582a03ccc3b9f6b860b06222302ec776fbe04486201447dfa8395b7f51c31213647cb2b61ed4c9b925b287ad9cada9235a598a1071a81db7e4206ef8664a91d63092a7f1076c8db2ccae402cd7fab9f90d922a33cb79eaa38cd3b5c205cf565ce5a7c7eba5cced328f647d403e3df118d506580802a1d4321b2f402fbf50c7a054bb8669731b4bfcc660a73a4f2a028e5a6399989da4af1bd49ee0eb3d961d562e3c200ea1db9398936b5017ed9e6c49a55d4cca4225f64a251fc1adab7943c7bd1a80e70222883c913e7f15ad36fbc7f8a3c33a0199030d7949cd961e965b6a67221c59fe719ad44405b531cb79a9a6ecafc3fb41b4158693647232295c26735f1f6e89431feacbb7362b9c6970f5ef119f08790d3c1777a8e0eff3101dc005fb4d6ea679631e98e37ce3ddc0cfcd48d83ff6de84619e37daf5cf1429de8b0773d3b65c8e66af48dcb2e4756f14873dbd8ceaa2139251258be183eb50fb150bfaced617b2e22815d10c8dcb7b91da991b8d2c75a25d04503655c7bea4130bfd3e957c2a2e4967ba9120d5b20c7255258c64c2953816171372aa8ecfac8fdc7ed9603590c9d007a0ad2622deb39131f5eb0c9fe7ebb2d762da5eda1a564b1d565494e1b1b640d1888e77a7cff5327c0d1cb7d7e86e622ee01a161f1dc0589170ea0bffc7fc14be4b6ff5a160e00e90ee217728a3a8b0fe5635030039999b8f7e19150751023ce1b92b4e47f882d74dd1ab0da9978284f4be92bfa505443dfbbe9f0e30db0cc2ae1fdddb187ebf7379a5a834ad3f80d9f270aabd022e57bfb9e2237d53458e97873ccb0fa760fc1ce5258dc0f7ce64b5aef73cec47282847fed94252c14ae595fa40a633a58b0dffc60c61e569e2599d3501fc7a5de000012e1b32f1868f25ffc45c269c76e73be5ce7f025a24ca49c4756e5ad682032e097fce08fe634f21c9fcf03ee5ae32478de72383d461eff8bac6b15639f0d96f7d12bc27631e3bd356503f11fe74ad60d12e1b7d6344ed7e359152887727cc7be0726784413eb27b0f3cd63e729ee2ffd6ad1bc9a7b0b9dfe7e3469090169b7f88b31b44508fc212efd89b9d81a4c95e21d3730eecba0791ec7fe4ab6e561504264afc12cf7153a7d3c4171c5468d496482f0418c793142552210d4381fb5af5e1e3d51574d909ae90f535124cfb15a8c2d68aec874c42799a05fb9b3e9924bc7c450da641811290b536b0aac01721c19aadfb3706538860073ce828f3fa1eb4aaa14c340d5a1c6dc363274ccaecd501c6fa178158902bcbbb3bd35eee881054ae555ee3d63b0930454e568765c3e9e520b814d9a0c3ed7565ea74e0f22ef951a15ebeaa3591b9c071c04f05df90f411e608eb42f5e54d9e2b23582781b782d4d823034c5a5f894adeb4a97e1390022d163ab746f4061263814428df8815f5dfbca055343342ea32897a82b885eb4bc1f4bf0711e7d5b2ebaa2598da66df24a7402aee4154a407d5d09057a2754d84c587032d7c67615f8f03802d5a98899e36b46a3165dcface46bf4e550153cd22972d530b934c785b1be591cecd8ce218652258c69ac4762f3710acfbf861f2794cf6afcf0340b988f4ff6799dd97ecee0678179cdeec514b6740088f4684f24fa10c375ed1429d034200da6f403f496554d14971e62f65018e20d10c368d35a1d2d43e0569b74b74836b7017f3805cb8e8c12dc864310d2499f92b52eabed6d81160ee9310415b1a578aa8e4c90a2b8c6d4000a838d69072ce40214dff62835f3df65e60423f71d8c8130e5e13c60aa4bd5d2ceca8b150871f0ebb50b66a3d3d48c88f07fd782ecb79dfe90e1849fa533c59ce87603adcef0d9d470bccc7e2460083bf861154d0f9fd45dc0806949d45bb94fca947b54c4d17f633cf3c029e8e55571081f1862b3318837eb316d9be06e8b4d029b012ca24e2202cf573fd9ebdd1c50d145c9a412b93c3ef4968ff5893d2de71f24529c3aeb4f4f3f64c2e482341e5f5245ec4f299b3e52e9a05d249e9f614d46cb9fca8f43e5edce445b3d4b7e11ca9ae16265ee49a5ec2bed5ff5674625d75e7e69e716d848471d6583f14aeb1d9ab248884f209385f86314b60cc782d8196daa71b664702bf79d73250c44eebdd8143890dd1e89995a3162e48d108424271395b853c80cd0a7771802709e44f000f66582cdba0b249d41c79da4b60e3d328b41aadb6250179c1de3b80dac802f67082375c3ffec55ebcee15ca7184e2c1d5934f389eb7fa030f9fe2ae74cf7e74977ef55d8612459f7e42b80c84eef18ff8b6365d405feec73282a4f44c37c49049ce1d30933be154e1d32da09943bbbb4a7561e2169c99a4f6c9408ab6d46a4b64d21817a608f2739684d89332df0790d9b78e86674e1767911849eb7bd3223027132c13dc8ac94c001171f1d04b30928a7aa46f262da2b90c843fba4c3caecefbdc7889b1284f44fbcc59970beb4395e6d45d7066ff3ba5f937e7fe68f61a6094ce7ba95032573deea6057b41ce8feb9f4f859256765f025ba4959d32952d1c74a4a55c194ea4947258a35a9ba499ebc37cf11c6172138446e6ca7dccffb9395558d46871dd59a52b8f925e68fdb32b3cba5f8a835bc9f73ecb07f965c2e14e0dfb4d5f0ee34a0aa21031abe8c7ec693c8cf229093681711af64c53ea610ffb0d0a46992e991c383142128614cefb6edfbdd1d96448786c0f799846b1693d8f4621d452f71bcc7dc4d60ce63add2cb3835a3dd34014d75184c78351463864758e20824f95e0292c226900514e7ff94dea1b7680f7c75b871e2a814f33cd752c01751bced9e1671b52c4c4032b9a2bebb14ef0b21bdf830ab3c5b7339b1cdec22ddf41cb423060d89dc8f072d0293588d1166799b8e2216099529e7b410d9ca70a666c48db5554744f63eb933c8cec67da980c9d2f9f6b22828a74e01f9698abf01354072ed2bb990c0ad0676566b64867d536d7ec8262053534c3e7578edb1238b296c86b6111c43e614444138801dd96e9874b842f24a4cd3fb5135bcfb8a7742537400df19cae3e137497234958c0481b486c11ff85d463ceb31fdf8b06a665404674bef98ab7277aec0880a708c51306242413b8aca73fa397afe9978ad4c50377125d5a9dc871175464b84252037439c8ebf3e909f6b2179ad498e8e10ec7b39258dc8851778b16b51de26a97c3fbeeb6a9dc2925d01dbe5b79e626ab7018061035dc4c9556dcae0f131985ed3d1a7842002d629c59311a3999e39c77d7e225cfc5b3d076a92574ce2b711b76376f611bc53c026f34f0f708e62414ca5f07c71680e2219b825d572c3e9188d4df10a12b6e5ce28f3a988989b8aefc5e5e7bcc4258197004327cba1f126483b4ba37b601e77d39f287783930c25ef199528384e3eea61682eaf9c712b295d60ea8e8a1c5ae8c9645b5b8d29e6a700985a390d0696eeb62e56deac1a9fb395ef9527bc8b7534570d2395c3645ebd3622091cc45ec32e9d130cb0fe1e1a24ca2faaacb29096741805db343c109bd893c5206b43a43296f1635239c6eda8a18d06608f3ba4edcf69da83317c9f57f75507765863dca2183b66526be3fa60f3354e93100a31bce648d9a97898eda1e7f30b7c28b87bffe7b11edf30ac59434d39eb0fb42e54e8364595b050c9a96fa69819c60eab37d77c6e9020eca2a6091e09c0b4c64130e7de171abaad0f12d668fde28ca9a54a35480c8d4dc67fbd4fd2dc1ae09cfbdeae7771eb2266d03b196448c5441e5e06ac8bbe973fb75414e261c5accc496b5ffc5282a7302833cf6b81f5c97ce86eddebf47bb44d9cb0b68c5279f9bed4039d0bee0e6c185880f62d5a9a83a4408176afedfe2ed4336ce06aca09c2b40e5a76b0f5cc71ced436f298ff1d29e69c817db1db5f3c2cf1585f0cf2a0f2c045b845583fd133bbd5316f3996746bb39b94fe2e8a2e6b86e4632cbce9ba454ae8a91163a57951415e21ea4f44c42ad8ab5093a5b8cd05e0acfbd8d91b5d0ee004d0003a0db896b8c3351ee392e21382101a422b611f003e167532ff534be14780c2e98ec39f95eac1f73bf21c4200c981dccdff62061ece685872aac4528a2d0b06dd5e9f1b978cdbd2bb52eb15756d1824f3a9900361e174f2dec75650698fc06a5df5ce64ad6a1b6b0e8360803070b8013cc62bfdcdb6339dc99715b190676ada859278fa46c8edb03cbf18f9356eaf02f1c9eeb2a9c183e3d39f6c7973ad52f6f3655a172b19ab0498722a9f3a51ce7e085814eb1ad9eb3b0e90605918352980da634e170c070be1f15cdb33c982356f1c9e2fe8db7e7cb9f66c34379bc802afcf22603cb24d7d1b6499200014fd7f9e6201091874adcd7fe47a740779f589fc61d6c1612eb142c648c451f1a6ec177ddec4579a42832e1ece3dc38c520c118e7c289bfe75eb3e95e426832bc9664087e495c4652f9572a292c54f5241dc5a20f1f92c7e5b0aa144c899913eb25d32e51186286e182bd32f2141e6f22af2d0126c23b53e64b2062f79d09f2c19948bf4f89e98da88c030d721abb4fa09f8f7a4aeb89ea04cc865922d67335c3c294bca8235f7d31a323063a1ffc3fa561e5e6b0ef498636ad2f5c86bc5747b09645c32c1ff1bb8dcc0332cda5a9f4aa216dfd9b48b8db27c1b310eb9c8abd014e474760ca7cb19085ecb832b40d8caa528152e847f0556a6f6128775226f2dc8a848c82b243e7b198a6fb021a3525f6fcdc13a5a97395b4904767b25852bf4b1f31088ac8edacbc0d81fc69189eb91169ba7cfabc36c50ca7a13b70a359aa1d5c4e2a942203205a19e2b6fc58c144df08e2b784a2ff9edc1c0c3958e3103244564c7ec9b36d3941b12932eee146eabff106afa36bf854aa0cb110dfd4160753a0f3e2d2c768b78fefca0b4966fc2450464daf47235c1198e4c3a7fa3e843278141083cf198749cb460cc0ff275c4f126f994b1e934cbb2608aa3ba795f8372ad3b8ab73d9392924ba50761d73169b3e3fde6938bb600a46a7ddcfb817e8f9af4470de74649745c059940203804c33436bb74790f442c5da61effd3279780cc68e0d8cdf0e4d2c335d83dfc4b28dacc7900d636375161805fc11bdad8b100fbd3583b8101bffd9625c2d90992cea002b06c9a3ae293c1385a89953a0409d0a2dd468ca77ae95c0af834fb3e0a486b81706a718395b949be0a728928ffee173a3e69066926f4866ace6d17ac7d2a2e12558ccff7cd7da15503ceefade0a02e63b81ade593a06da2804b1cf0c807f091f0ce178bc219281b9ec971ffe185bb9935a9cc258fe43b0617a25416dd5b211b534cb4a68f01cb19a9f79e8987f2ee76bd6f2fddc8e83f2cea0f718b9707c722762016532d67860a7221194387b14a924d93df130fe4350ab6c29bd3e0cda07f056faab433f774837644ba1727afbc0086640d0f906fabdcc26b745d7d35164318c09dc1a0ca309d096286c5697c77c2269438481ac748b840d26d3d7c688e05df2037aedcd4a747e7792844008c6d5676d5d385ef063d5184e395ea1638c5256ec89a3dfa15354eec12974e26e99e93ee55c5b5e88daf1460a91d40cc1154c8d4ba0f55f75073964639caab788a79520e538f97a9cbb02a170ccfc184bc0e21d51f9a0718182071c92e6f9b4d507ca1e1e0a7325c171dd7e8ffe84d92d9de0cedafb4011ebf86c08ee26de88f27e8a3d234ba2c1d50a0a77761d1e52e957223bf7a64869e0ab3a360548320bd7e704eed0026723a23c945a5e3084664e9db01e2d3beb10872c4b6e74d719ee84069ec171da0895557e4af3d10467d7968178bd1c387698cd1f90469073edcd9990c3f81c45b92d7985013a2cdf9f69b559c94e2dfc787dc940f68355a19ec803d831482a72519f80cfa815bf6ddd3be4c4a07102169c05775d3e6e44693569a973792b3915f219b70d5dbeba2915fff825320ae409c7be083c463db4685bab4206719e967db37d1b2bf316ee20b5388e51d24cc55e5a28c471ac84d3950b4fc61381719532eaf9527155e8e6a85933daa6fe205f41f28c16afe7689eb5e959ca2be7d96f8b7b83c74fb55d0705c24aebf792689ef6ace361cc87cba8064a83565888fcf57db4af560bc43450a032055bb0a7af10e9792f22f6be0d3e3588f369b0e1cf6c9ff9d3fbe7286f97eab5031dcf2ee4d5a9ac724936497586a0979b2fb0a7af87e799d6a6b90b252ce775906d019fdbc3c868ce5969059c5578fae2d7fadd71ea8ea3965cabe4b4ff92a3253030a1043752754b1a946def1362c1beb3bb4f32df4bb7b69bd84ee3596fe12cfdca39b5b136af69809964b23717800bc7478a9d1d3fb1add9609e584afe7e84afc3db996c93d6e4ddc3152761f2bae8dd1f92a910db90401f4e0acd4645f91848cf33c88a7992bcc9e0c746859a36aee1a3372b1758d2fff910f32b11bb261cf729b8dab206adbe544aec854eab4f370d7ac046bce394cf35264649ed7530cf02cd2261cf0c7507b6991f2562a8ca4cbc059699dfe86b9fe15f52fdbd507f14a9c4800d067b125ca963344ce2c1949ba2104fc7a51b58eb2edaca4859ef1deb158359d7899a523bcdd345c23b8d1739f84aacccac03464c792e7ead9bbdaa7851f4513c98075b2e1bd7a4ae5cbea04161f2be014d7e320bd1081e8fc878e95b84438b3a8e539f9f7fcb3def63f1d929e21c729af6c60370fdb6f88a3a90ac7c2fc78e2f44a31e8e57d1f00e7c91ee2185d53465305349635c85099b4502b4200d56b9f14c1c5c2542bf7b58da7983ffa5cc3fd5ba0ef2ee57f973d45d57c9c42e77c5f04de608563525152bbef9600e2953c246a578041bd3658c64e7bd492753a95151ffd863a175f37ce931c4c7b2dd2694eef0f48dddb9337ef6605021703b3579fdfb111159e82ea553475b1131962fbb6d2a086cf60fec8938b2c79c0c9313da1738635903f2846a8e0a34766cd37c40973e9297435f7c75d50064066de67761945107cda8628ba2f6567803064cb9dcb6b58cfaa394b81f4ec344ea6f3b031391edbbb0b037527c4e0dde50a64298c1da9d97db04b45c20f3c6fabbd2531cd47fda4457789eb60977d7342a38fca79087a7a30bdd29aaa5ea1c80280252fd1597fbab405e1ef8806a2e6203af9464ee654f052fdca35e1ba10711548db2b03f71fdb4d01870e8c8f8d755c58857c016a292d574c71f30c26e519e691843305a4a0de2c07f054aa16681d7de0b4b7a94c3a36b4b599190ad3868f653c128ee995f214ee33957a651677f006e786a6171a56436bbd893a81d2581487fd83200196a44fa7b037f0d8a3476b5addf0f93f62c8667b0e79e3b553b9de0cb04a0f6534bc5369f8ce7be2619ddd3ee8d7679d04fadd959cb6182d030330b7b465f1cf67212b16b0cc368ea3f37bb9164a1250ffb6947c2b8d7a93ba3df92cdad4fbdbc6037a7cf32fe74af77a18ba6652599816e726917ea8c7ed24c5b6aa942988d4d4ce500562a66865a78c90fe396a39d1bb7676a30d1ad162b12ab5f9eb3672072b0e637c12b841b57cc18a34b111d0666211d896dfe41897ab566ef4e9a11a45803113f9fdcb164f075b40b70909f05fcc6aa7177787e4e83b19985a43a6f762b2766357d9ebb3bf029d6213bd11b65c194521fcc1f6d1ed6f71a483bd8f5a4ad2a35f7b501f5465f7625e09d843c60039f05e768b87c4880e3ca47b0a0c356142b3d1e57660acd46932cb9fcd94fde92dce859ab3671d034ed17a6133b6f3c95d2ed7cbe7438de7e11c3c01938f01f607819b3387cadfafe037c52ae13bc7fae16498dd27a1b2bc99399bfeb2f28124088641dad7f467141b77962ed7ebf69b33eef4010f9f76118051226be32dc5d0ce155c66f894040514c93bb63f84be04e94b3e1f6fd7b302daf62ce72ce85c5e91e3e5ac8b19ab904b070a424fa126835b7c24000f6db9cf0b8cd13362de685b7b2a8d9a344917f395d43640cc1e16adc0bbd9970a9c5960c976e199ce267862e06da2a76d8adebc9c28db3504ca2191675db48178df4374d8ba598247ad44ace79f3cd51fafeeaa9fb4813dcdae832ae4eaad2773f0855376720ab58a6edc67997f79d734f06bc5133b47880c9914af27af3dd4d7a206f854369511c46496fceac06402d5d6c5c206691053e7dae525abf080492f3109e3758c1515d4c7f73e396a5052f60dee0a0114e9684223e11edba58ef9a1076d276407bedcf3ec86a90c6774121dc0efef2042637cfe82680f022ef1a06b33fce6de10810dbb0b9b0b33eaec0ea3ffeabce6dbd6a4b3a34c2bd6859d926cbbe024a49b102571d8e02e874e4fa8a5d731d7a4567fba3780ec21304df048bbf7601f41514995382c6b511905a47a3a34821a21a6279d489d59f8f3e520883f460e5c3c618cc5129e7213542e0bccf41d713566700a6aac6dfae0d87f3288e12f8eaeddfcbc5f4fc9f7962240e69283ffc81f482c3c17c632114e404dc4e105dc708c5e908ec6124a390009170ec62b4cd9f41b467d6e77f286f1e48930b3fbaade92507b204bb7b991d62e0bd5e00e76b3a5b0e66f0f7a3bc690c5e97f5df540868b8503825ef6aaafe6b91dc8e45a2ad3743939affea7ed45f7fd32b430bd1fee7c67da8f017f3e4cc2503df8ee996d609cb52daeae06c88c73c5d6c3ba06efcd30afcd6dcdf6f0be573ddb2a8a7ad13c95639a1b95c4d6febc2353016c8c306343f0dff42cbe71204c52d5230fb80e81b2fb52517daf101aa72153c06f3cb6de598ffd8760437752ba53ecf9ed565d95b9e399e0cc3de694acbf000b21d635a24c27797d9c07bbd4529d18b9a7dc5a00a02ef6fa1abf52d408ca8f972b4466958eb89dbfec15b55e00cf91250a8a2c1dd0fb1a393aa26eb7457efc1604e616ef46fef5f4e7d98ce2d028be3834cf8f45ccbaf4ac237fb3c5ac3edaafdeb5f86b73e05fce4fe8ba39bd17cb2a26e2b68ca266ff2336c634f22f19fae65320f9b825d7cc23e137a79ee36bffd6ae993ec10ff20348f5cff26f051db0bb00dc1a6d5976ee57a3c22cde406405d89dd63f03f4009c6f56427ea60a40416d17563d779836b14510d95c81d2e74ce1811d091615d9001c67eb70597acce2b50ce3618ae217f9bc7b4f6246edbbfeb76604b4ccbd2ad80c74f1e02e7df9cc3324d7c90a3fe41a6285301ebbfc2703e4afaffad372ba38d29420af2f3fc3a14abbf6c74772426acd2458630f85522390b2c56a84a1aa90f7d7f74b58462aacd9b2e0768ce794d3283267ba5aa29e817f0323a92008451d4aae0914adf3680544062378cf0adebe140765768fda6992fefeb7d7dc7c74ecce1a2876ff9f16b11cad02c3b35240b411921d0a20bb0dbaf5199ed9f54c2baf2e111dcc6c46bedbd4e36c0af50833e5e837bcd9c64ce3c3c5b242c20eefe191eb15304794666f5fce0b88701b815fb5faa97db2fefbccc5ea9816ce65a1ae87a6bd0e11838f89c2aff173245c9358f5d99aab350da8573a3775ee333ea93ab9f7569fc05f417890a0a8bd2d764818909c05b0aca3c22d129091bfe89726adb1029cde01de5cb475f173f8e47f28c40eeac360047ca43f36073549f50676202b5d3ecce84ea692c9684141983e9ca15ba8ed30694ff0a32aadd288a2622b05361c3ce6f61a647fa213531cf6704180f463156697ddb2a7af5444f63375b8e73712810d729c8d4bbd1bb4f04d2ed9c7af3de6735c2c2bbf9ff4f00e5caf47972e2ecc927aef50e5743245d680022998d4ed3d4c398c99bae8cb21019ccd07b22829dd10dd759fe6761e3ffeccc1351c640001babd7a1e0c9a73802a0d81baeeeffc61b59d995f674beda9d23e4ece41fac6c7eaf75dc0eddbae5e3f7d70202b4587296bfcf83fe470b58f42987db13742a600d0b0056601e4ea245972d8f81fdb9589a104948ac55e85b2677b0d088b07965cd818584bd56f5130607308fb09b0cc681a97a482c119fe39a0c017cac2898011e4d125f7b7b5b30bd864622acacc20895c645db4ebb2634fc5d0230b43f557f7885b928bf916f4deaa4f9713c06e39dd26e5c9c9cfa8ba53973f8da3cbd7b25e0ec83d8bdb81adea239d32af131fc00373e62edeb9f05ae688a48143a9f94f1b688d97df5d27f12c380caef487c744a0d7d746354ed48bf3c1d9ce9aef3571e997c6118673d7d165fe169bccf9828a32f05c09440c68ba4c089d5180bd6c2afef35119e8408bdd354615966855dfbe744140c053945e9980fa3d54735b01e08833e13ea659df0b356c02fbf7171bd5cf8ece7cf22fbef4961002e64f79e9eb17774f8ed4cca89fbada7a1add9ba8bef86c559d2c06c135b4a58960f872f47a64f242f362b7d4ec1558f2871a98829c883b192db2ea7f3349d6757e36f398b0b370c8156f13317264c3ce000bc43a40d76afc0b22d51184d020b7e096393fd589f5e66c1c258f5d7fee7e96b063387aded37b3fb7e0f4ef041737cdf4dc115a42140b5c334969a92c998013c3d57586c28d4c01a7561c4852f5abb6e42412aedf65b765b669097fa08fe6c2b262b778caef956791e52c285a567c3d74ffb09fc0e20bd82b23b2b4fcc87aa2913707e8cc18f7f8cde4fb0af45458bc13dc670d478ca6ca000aef4742f10b18411f7a7342375fe42b5054ebb7525f435cf024aad60ebbef88bfa5fa8dcd8ba32b9b9453fdec055970f8a6b2b1c331cf3d36a6ccea533b6854731f7c80d4e447b602cec34d238ca355e41834493dfd5e25fbe500b2f299f90867f830589982acbbe63d80a9d06a82670af62542ab9d3a8bdea7dde0f458d737410d7df4671a221f7f0be81be9e69f691c7e1c56c0dd2a22e6a62a63d98541a3aca7a8be2b790af1d318031a965927eb1c9fea174a0d581e16daee2ec4531a81d193266eb9d9dfe31a020339cbbf2aceee4a557c128e65a7c814fdfe5e2b374d02b1ccafc867d97e4c91d517e74de8b80ec0a7f54f2df5bfcb283aee16d2c1f344bc2eca01d68c2136e0b0f338e15ede8d75fb9c6581865c5ca69eea25ac332ab948a4f67f9d28862bf05270c9fd38cc2dc550282704fb7c83779fa989df8f53603937888b0ac381254b465f79e675ab774017adf6bd5749c2f6af67124592a2271c81d8e330695c6e7b1482dece5e202cdd0931188d03a59e488ef88b1cce74f729f39abbc32b658454f2ca2a17eeb7ea7bb3fa5722b4ec4aeedb3afb8773005f68906d4988407df1e50b682e5c85c135bdc3808b5bb942de38f7dc4489d616936bb820e9ae423fd71ca4e87f461eaf0e033ead455577bd0c6773a6dc0a2cc4f50e56686563cdb59f8f9a2d888b6bba366c67ff977197ac10ad781a0d0e01f7a079ac838d0c539320ec5c8e14da5374efd58740749efb666d07fcf973d33b6c7b26696f74cfab9c034f283abcbffda6e3b813b0f50c14308acaf9c3166f230838efaa2accd4787d28c9139832212e98ab23a1e8995547a626129cc93537300d04a19e95065f08d69cb5466b3e1c1bdd2c50a417e780379d45efa78485a9cadcdad89bae0192872acd0236811465400fe3878e13b1b15fbdd6f5e10b2001d8c286508a623acfd7b835fa93ceea0e153ebd9162d431cb7834ab2cfa9461aa4324e7cc407e846905161ee4ab9f74fa45df6ce8bc7e637b3b55dcc7488c609f537cf3cb77f868fbf9415ff2eafc733cc90ad42a87532f7228b4bc58aa821400f168c9bc154dd1cad36f880e4566b5fa65a9ddd8d3f06b11e393498d501b2ba5fb0dc098ef3e8966ef9cb3a6e0e0039eca36e3bdd817036bd4265b9807fcdccc672ff2a752c4f9237df57a5192ca5d8cc71ab315fb23fae025fe5ebe91a694633cfed4a35e49e43ecaecd6763f254b66e4a7b07ed87d0389bf797717f79022e4226fb4ad7def931c4ed0ac0470dc272bbe8aa0f15c4938f260758005998926dda05709126ef5fcdd8061c92061e254bcc6a335d26a7fa69099aeea6a167d40cda493fa400d7afcdc198c971f38f13008a6df6fded69c0ee7134dc8938c9c0582adcd58b44df342ebb7b7c3a0f13624fe075bd6be780d31be3ace9da1300698398b02138e8d44ff89f4da617a5397966dfc8d61e41791842271a60ef2f1c6e4687b8f03aac6458274155bffd78a4d90e21cde4f69b2d14a2cf39ca3142b6f5e37be76046e5ec5eba7c865bbd7586cc5252f4cebc25b68ac16b0f83607c6e1c0ba6e8a5d14353fdb1c1ebf560bf5b8790faecfa41bb636472ad8716576098549451cf118bb4632a47c86750e31b6a645a4b24bb120aef82ec58fe839ad8acf5475a8557e34e003a3b8ac05c9dcb33eca25965c8cad9fe68803e660b469f4b7ce61cbd66a861aa8b5990bb8bbdddec6ba2277fe6b743198cc80d3ea9786162c55d8647fa7957060947496493409098c6cc34b04cef3b72d9ff702bae00687911044fb3a785f5f39544f6ff96962152ee6417d4f4954bcaaf228756a43ae21c95fa64705aabc10f0a2298ca67ad121add3536a1915b2af00fa1be80e54238f421d994b8129b223a8d3ddfb539aaf1a80affcdb2f77f285c2254cfc71d0bfa42ec130c5685b301e158857e02e9e5c1bc0b31b0b3a79f2700f896000a66403f9c2b7b22163ec85e70e47919d7f9ec99e58dd1a70978dcdd5743861332910373012e21e60c9839f4e8e6c02e87db24f15b45112e3b269d3a6f68a90c08c08f73b72f6d6b996e6ff85e6b9f2ac4b16f2e88720f2ec2e16825e666ed6fda060bc8a57da8fface3aa1ac7ebd6e77544b2f5ee0553bec87b41ce839f32ab19d37e2533ccd035fd2a286a4b06867c08cc1149dfaa43699f1d58e37645c00576e8e76841b59b7abda03685999ec1bbb70b235feaa2501b313c2571b32bf529af6146bc3bff2fbc67d0662c30d98b91ee6b57e89ae8edcf388c48a4859028f907fd10c5cd5146f8d318f11a74254ebe778008a1e30d5c3f95ea49f7fde28b94ad2d0bc4cb1633cae42a0f6fd14f2b9eba4fa03f3c883744559e47d90c60760074640742c684a089025fc08824c7b0b0b501fe0ff04fed0ca133685cd9725395336386d7104a5808c23f8754396c131b11e1c2d9a32d0a675c1047340373136d4b9067f28f354dc53a288ffa67e4a4bbc5a9ebe7c23aa4881b07ce18d1fa8db91b2601f88385b0e7606f15d29661d44bfc90a97cf3c1d7ee7a4c02a818d85c6c6627466c5f4b7e0819574fcfc59985141b9699269ed39f8fd1a97669b14382d8d95307e63adf0d095331055d8949110cb8d8617386f7396b9d07e9ab75342366acb20ed8936e419a20cf6e8dda7db130c0cf332de10370a613234bc2f92a8dd2e5101dd580c21c1feaa73e481d4eedb43fb6e7ca4556710054178b526d6871e2b2c2f1067af355af4d8611678b68f776e79eafd7fd82c26446a6f9172f4b86b82388637eec3405691f9fe4da6bb400db05557d31c77969a35c1f86df6d68c4ba9a9ab028c4b5cc1c606dbddfe9fbcaea075a49032afe52bfe48213c3a87797a1444a5b44f3dfff564d95d3a1af5600ebb44c50da3376fe212e3cff2c7eb1a0f0a6d8fc7ee48c3224086eba1e9c70d2af0dac4de073c7eb44a1a792a49af76c08daa384716d6872e5c1b1e4e7b8442a09d78e1dc5c8cecfae9c26aac54d9db554edce15795d0c90b1a648c04011a0238d7e23175fb8e2da36b681ec54bbc1a304a9bad4a414157c6dc902fa24fb4157d3d526d603d2d5038efef2f6adfabc223e693bfb768f0db3df870b81b5fa4d83df2fc33b77025f4a4f3594265c7e6edf503d8bd6b8beac2c61f6124e88f92adbe4737b3afef8146c2783462035268f280839e141b103328c534230c6fbe7e8bb7cbe08bba15ff443dfd314ea091f73b9d73866b33f3a8e8447eab7d1f173ff6d920444b0523e337bc3548c9552fede1f27a81648339f0cad7111622a23945e06197feafbec2a141863ce1916b8e7ef55c552fee68660175adb67540951bffbe0c8740eaa2180e4d47629a0bec1b28b51913e665e9453ec2b4ee67b2593b66b560723caa52166f1cc8db28da655d91d26eb4d3ea6a3ca1c66c8f98d89197884849c2307e13d833237341f1611cf99c1cd016ae881384f5895b5cccb154c5ed0cff8c8972cba05660c0e4c9d49095e2d74c59894e3a43eb503f370c9739bb7f3e257617e093752bf1e50b101c2fd2ad38f615a2c8fe1fe7c5db8265cb02af34568cadc8e7c3e37bf06c43507f4a1c88a7e33c2a3f1f00c81ff008ba00e81cc579dba6001d539906323a7eaefc00feb0f03fd13f2df04f1af211ad777b013d369d6dfb6591fb07a48cfff98259f0bc8a0739ff34e431bf5f71086d6d92f683079553de4075e4171f837adc822652d47b84e2cea313235aa0f2fb39060b842232ada3dac5e3e4908f0977a659ca71e08ca928e871c16dd7d62671d57192f72ed6a41e3a23f94e450af39ae645ed1df95757c95b40d6b6e5a1eabb81974780f4790321bfea427d2a5edc88b9f02e756c1ce33890296995c7c0ca32c25e5733e03717e9d434653aef2f4e01d9c975eac031acaa981c237fe5a3d5a5d11806e1a77560db03665d0d5e639191988807d767d445e691742c0772d28d5d3dabe5e34a31f9bf86e043e3862d352472a30175a3696d2f5bd751a022136afe6949417045baa5348e8d83b03b037fcf9f1237c44c8d77714eed3d433c6d26f405d73f1ddacc5f0975eb907adf8d8ba8a90ef87e4802e1b3ce80f5d87ae59830338605dc7bf5f8e704187171ece60f525c4a241aa1b8c0e3a16d4486dd7b5e69b2f9ef28aee8ba5701d991b37d41e7f567a375de30ba8a475db8fde87b3fc229bf0e94aff90d4e39db1873e7bfc57f100a1c83d1905281f578fc42d6719f811a59e443662e45a2de9fe7b26e5e67d78ae40dae17496546c5d286611ff4d7c2b106d38feabc24bcd5d58a4f0bcf8ab8d84d1c188de4d6d33c1233aa6e558dcf13bedbc995b60eb36e557073397a4b53a4824f1a071f9d9117550ee8bdea8b6f3dfbe3a4cc4574e2fce83941446fa8163e6c7c8f67c2e993a465e2fb37376b130aa082076c8242173ff6c7e16ee133356652d7bc0b381b21f9c8b491c6e1c3049d378f18d402e34b28692cc8d3561e0e035780272beef40a0d061c903b49c12b9c3e5cb3ce30ccb86f904fa5ce37475dfa262463d0d5d70b4ca65f7ff92ada9ccdfbca4eda6311ffc4043b860e18d72f650c9ef6885e8f8bd51f5601b9829b4c42e521b16ba569995fee9695f4ed5a9e4937a0345d0232ac00594e6eccf6abae74d8962b1d8761bc266c857376f02915fad0897e750e0e39df11bb5ff8083babb53a05f7d27f83dd25ddc8ee83b6f89e770df03e61f94544898d107694a4640210c3ce8ad64c929b175e28eef402326fe127b03d40a7186e6de53079bc0b8f18f2d90ffdab1fa6d4fdaaca382b784897fe5e290aa332580fc685ffe74ee7051aea7321d864f293c8810039fb0bda049e834d643ae3cb62ae511eaf9c5a487c476ecfc5ebe5afb3b7b8ed8df276fb15b6f6ab82da6ded5262e1bf3e468e28de9485748bf21fed56aa5a1434e7bda6cfe1ea9c7568681323ffff8dff7cc74d8b77b11dc3b59d30c0e19af9ce1160bef57c33cbf4f2c8597de7a6bdf37c724c8237b4c4fde749d243508d9f95399c41f5f34b925207c7690d83c7afdfd8ecbd5eaa2190715b0a73d2a4113bcbe650b13228001fc290cba51ba57021bbbb0268cd7cd363077a88f90237866c2082f1fe38f495cd7d1aaa57c983360b1cecf66d1e1251442f4c00b6b8c6c783f3ddbf9c9805ccc3782ae38ef782ea10f4995b5e970ee2b7e369755c4106c4b6808705ef7dfca7083038f4b5e341a0c3e1cb602303cf9ded5d14d515f8d20cc9256edc79b28790cc1ffaf797aa5a3a661aebd14f0a9d33247056476710a690df0d40aa2aadb76dd4bab9da1e06745ca4a2507d1e97af3036f87e1f219839952c68ab3aa49be3e37bf2431ce9ebbfb1ace484bc663c391493299dc4b9b1a3815756b6813ef95ad59dc0fe642290140a2375c11d5bc7bf6b9fb3afa82755c0f1bac8eeddbcfc403b3cce4685ab5449630820cbdd97c452e4dc2e77f12d73bed5f0c3c09d28ee39fe959efed4076114b5b2326d38e2a36c50533b3eb730a45b1651a31e6f7d90eed3900d16a579bd549999af930832d25d8ef42216796ae2c9c32b5d948298ce5e21363c4f8c742e6cf2aa3502de70100ebd56002929577f3b9ed907b37aea014bcc63895ccab24bf9d75402f358c3d034a5947331c01e2c26d44bb6905d1350c40c9c971e8e81c9ac404b6ff36a6d68484c84b8c9426f91fdaa34b85f7387c27217a7a661a6c069e682082e328129d60b4f52411dbc74b7e03d4c0f4d61e92cacced2208614b90140a5e5896b266ac50e466b751a599c1da26645a6751a146e135a6b62453b2b89c993253e82521b76c8f1c29ef9b58f11c722dcd6d3580b5311c064254495b62a09f54b7ac7dfc70191db7ccdd49983836e1b34a658693bdd11355371b8ac410a66455cfa17ea716ff99b9314403be5aa8d5ec6f48cd2273be0271e4dbdba13578129bcdf1245a12c99b2f4603d92f7b84371f91c65c10d6419ea9390206ab5ad3ca4344d1b106519a469fc83e8ec06bff5835b72ae99ae6a290e62c1c3bf9af8f26d6d1f18ba268f3cf5cfdbafc91f2917f103f58498f4e7f26c047ea218d9b426d3167826e1dd6e8c4ec18063fbe2abf02146d2ff5a5f9e2fd42723b28bc7d6f228e1e9d7a1396d08b7991d5de105aa2405e3b33d4de914056758661d99cecc6f89e2f437b1662212b965817bb016af46af23959a22df768fa68a1a5e976a14273c3757b761e94d441634a37f3914d9466ecc3b71d3ee65b03a5249fae84bdcf6e9552af2f500f377575d882c092622489c4269c590c7ecc00821d83b33f459c5693b8b27f129df4449976e9443fd3f58935ec72b2bd79b7896c952a19856e50843c561faff263af1930dccea0a37384395c5472984c751840bacf7b89de1c6e4a32b77cbd631cec52d447bd4b4b8c5cb87d7c8be101e1d06b63e54dd6120a8e04b47996ee8f1c4bc982ff8e1929094fee059ee5dbf141e86d0646f06dbcadf5d836756eb4c9fd37a3c1ffb9ec00a56a248dcba9678dcce78e6a210d3f8b9a8ce9e146f285ca828fdab376942ea53d4ecbf7b37cecef615d213c8317581e06b8c26f22b3381991257d68b022ca9d2bd1cbd6d84325f05c962d5eddb656ab1e892611295dfb1714cb491ccf495223a79d5b3c39911218e7a5d743f9287023d67f9e90e86f3dd9a6a277baa6d15cdcf70e9da0a1a3b7e8c053aed8a7327f5492373ffb854cc36785c1b51601bf7dc659e666d8d45d5c368698df86bfc01e29b3d4c9cdd905c3ca2995888aa75f2b7917a823ee3d1d520f54e9f3a6aeef56188604d2506e27ab314ecd0d005f062d69a762c7299bb9c0b91c143b4fe25e2ffe7fa85e10f5804d544caa79dbe432892c57358c78ade912e4da4bda69c671ce48f3b92d92136daab5c359f16c8de305c58023ebbe3f99832b41879f66154f292063e0a6b5541753c6f02e84e0145b62eca76881edac985dded0b4daaa68444bc121190b4b9ed5f3e06d0a71d4f33f79ad7b7decc93a621bbefddde890fa943fd54e25a42d70a9fa9c75d71c66577ae0e3ad94f6faed304f2d76a0dfecd717c2fceefc376c910e93a2c31d070cefe30db1413b3effb141c198bf4affbc5819080d2470750138d2cebea7cfb42ce62d441e58373e56e5d94de56473606185c7aca8ca74d7771c29155fa9047666997a52c0deaca5eaf132d71f7ad1f5523e4f022501c98820cc7228000282f8d4888733c31e1acde8c76e27a39f751bad3218c340b5b1591454db9e98f951017e7f6cbabae7b55bc165dc2a20ca166ba41ed9ea8b86140de032264703742b210570af351942f38c53ee9b201f4da4e69bd0d0c0a811db060eb92d088b3ef761400c049801e3c622050a5b86245559bfb7a4f46c2e98c693ef0a930ac2abbf67f3e7ca32777a2bbf4ddb8edbc8b29b0fbc3111545a8479be8eab32d12305baa92226200ca16985a22c2275cc658769d59adbef075fafae67fce9fb331138edadd662edf2161b0e4952d63a6cac948a6331db18ee0f6be9ff90f9c39f72c50ee3592e99dbcd144b5b5f9f25970889f045c56fe8e4ba071c0eab9bd385ec1467fb0af5637f6029b7c12f9e86fa27be741e896366a577cf3a1ecaed7ab4138d780d8648019a46558af2e73a07989d42ae43aa065784fbb1f9232289e019058b9ac4cd468c68e2bb3568465f71a8beb6b05924fff59d3dc17f8301ce63bf8fd9e448e492bb3d77072afe22e0058712a4c20f4fc3c41dfc077be2a74b6174f3dc9e65842a92ff8b2e4c316b4b4adb0353a461be22b8d795d7a2d55805de2aff163bd44daa8443ae7a9f295c2c88398f2baa9b81968de35fa3b05e3adcf6b40512b14272666cdeb6f083cd39f7d92a9ba06462fa489b28f4f1a76afc5a00f4c145d6236963e6383c94b63ed2c9ae5241437396f588ec9924982e847e0dcb9566739702dbcd1e3fef2633d2addab344c81bf42b0b2dab429a668b1f67246a94294cd88e0b91089d04d623bc03bc32d49499895272802ca7983fddf7088583466ba608584eb2223bc75f19ca2b46988f8d75b446171504d94b44966e6b54beca184c8981ef6472b3cb602a0b81f7afa9029410a73a1a8250490a8dd13bd320dd454d42d2d038f3dd40e5f9b55b68842e7b6b556ce5d244d96be09ff708213aeacd8332b0f38b5adad0b20e89c58094e454f2869b00426d94c1e4c644c9ec95a8b7d068a8062abe694df82510c1e842d8ec2d612f59dc0e41ea242fcd866975707d7cb1680cd238d3c2f4882bdbda5e1b7d90e4415e516f8348eb8a48b0816210f30b2d62f1f49c2681a20327689ecae6d9b5612123ce7e41b179e301a07ac2932e05b6281d1b54cb18805f9b99ec1eee05a5b802d79d166afe02a50f8816cd5be38aebc66a564b4823d998666c60522455ec8d2796994eb14b93d769446b36675e5718bf963c817473305cb9bf3dfca83c2d127b364c513f96266e173f1e1c1f368ca62f2523c57bdf35e6d0377b5bc1c56b768d7caa9799d2b86ba5218f27bb850f69622ce163525140527cd3c30c62c351180b781bc985df2b695bafc6ddae26411edd79b90eab991dd4ae18f4dbd101231b780123143fd67987028ff35d967a43168ba903aadf4754604692ee7d8ca58e145583f5247aac569f6f67df7dd451c20d523d98d96ca1ef8122c768c4677e707de381613fa3bda9641977aaeacfd0a77d45f319303c22b90b1e5f0d814b596695548d1875deb38a99701884328851132bc3dd55094ae6d8034c1ec5afd02690bc285b221aad265f54b2362c17119af951821d0403f59a6575ff5e02444297d0d489251b14a2b11cebe7ef7fe8c357b352bc1ac7e36b3e288acf7133f2a13c3f5d04c61da22dd7ed2fd76997a6361083d071abd7e28484cd2c9322daea396302fd78085a99b762db1834410165961c30ee8907b610830dbe626c44ffa6e613254b4cc71409ad84edec87550fd72956d0081c7c157480ac2fe8c8f5d3eb5c2a3ca2696bc14b8a7845fc6702c1c47a437d009c9d9f06b6d44aeb7ac95a94b50544035d2c859ac37fa8aa1325dafdb3e2b4c5aeb15a11d042d80bbcd9bfe1d33d62c143d68089b6eeb1c356c5141e041b06115794787d04e20bcb160db50354d67036a06da01f77cfa8938bc55ed0501ed7f13fb7eada17b92a286ded0c71db4ce186a8ba0895fdddb856468c1c423eb65ebfe7e017e89e75840af18508abdcee7fc44fb45a390637a839c138524fe6c65b4b379e6a71a9bcfd9fdecccbc4727a203a4b0e8d4ae830dc7e88415110eed78eb08655e900007003fc5fb4005f688237c6cff3fb338d75e5e522d3599a1fc3c83e2910fa97469550d99222bc121deec524fee3e4eb11d30d638ced2942e2d69160ad3ba6ee7926457a426a6f2e797e9334e39622b626d6beb37ed3a7b65cfa08e0265f2e5a20b4aabc0c5c6fc0456e15a704175b633f6cfd6c63e3d68428bc6e72bb6a7618c32b3c688239a33b573b90f950b27ef4733b005d4261d5134acb9e34d27eee264e97c728a480ab7370d4ab04d999eabfd5be40541b51ed7bcf5b2358db351026606b9160e77e21ed3300b631341dbe09fd2490a12e4180aa3b307b04f51923b899def77e7b1207c875a7eb2ab53374d9e624bb80b87b732c8e77e9383ef5ed504b77d28d5f0fb825834a7474acd1626f23e7b21ec4dc4daeef41b260528b6664b5aff17d8ad0f8834dfc03641e848c03810019dbfaa5e3b99a5dbd1d979160e3cda787660ae85a9c6d08150d4c105c53c66f6c9484dd1fb02f40d4f45bf4da5afcf3eb99e1a904f071e1d46f58d9a899961505532f1e3c9997eb0aed5ffd83680122211307f5f1bad788d44c3af85708f6c7fbcd26eb9e918071e1173b4e87e49d898b3fc0304143c636b821b7588407fe71afb0fdec73883d6590ffaafa86e49938ec53728513eab38e2788182e81ddbfbcdf69ac65a01f05f3cd86fe63f75c4d4f727fa4196a0ebe6e27be7b36296206542b8921eacda27f09c4e1e08dc4a42ee5b696630c95537e0343384c373acc56092ab220eede09b66ece55e033d49edd35ad3a53bbc00fe821634547353a2f451dd7ab3fbb0906a14764b9dea1f6a8546f554c1af740b5271c45b86fea23572a364126b9f09b7786eabf1be121c376d65779f8a3a6ea1edd0032c09dd1ac45131980952ccd3b80a87db364c9481d2703d9ca31d7945c37ce77235b9e85fb523174c1e60de49dbed144983ee50dcd7b11d354ac8b8daf31392ea95a2cec8bccdeaad3a0ae5dc5d51de2a88bce4ba0c7dc2794017207b6f683febe3a554ca226aaf0f9ac5f4567d00b6ec172bf9f14c13d790779d5dfb22349a3a832a76d78d35a729feedc4b81ab595a2e620c3f86fac790d7399dc40e7edb606d658e274dcbb19b0ab8db8c5a4970815ffd8923754ddc94c2f0ce6e4ce1a65e1e43903261bf607910854140a06963aa6088f8a5fb2eb3c11ec63348d970ac1233c2ac27942c083aae495431a587ae1445bb4efba39001bcb8785aa2f607075dc4417d806a86e6785d395777179f22c752512d76a3cf2c7ad56d248830e0682036afb0d6a11844179cbe73c8a39b4ec0d3d4352628431fb07702e6a988de6305d3d7e77b7e0c5bac35949c1014327752ee9fd58c98a0d70682b9d6d219236f240ada04b780199db0f1ef91b54575a95b6620b3877e6bd5c035602b4cfaf33b2084bd046695e6f0bee889a32461047c0446c14b4c4b0f7472f1a0789a2498129d86fd1ffee94e2973d10e328f3b97b083496c46b22dc2763c4ad04b33f80008c9b6d84aafdbe072ccad8cd3b067f678fef853df9ba918988316c7df8a7e391411c088218eb5fe1853165a386b59a9bfbac9e18d9521258e151e25a2f300d253e5833e3cba27e69f2b8ea38d822551558900c3b459ff3ad7469791195949cc519a9921da46c2e2f469bc814fe2f2ce8bf658538e525f74556a11722ea20c0893cd6a4b9860495d00b4e35377568f1a4b143530801cd201656994a15ef4af20c1f4af3b245c5b3d7f0b1f7f3213bfa78c4e5ac30f3b75f09b759b9d454618b0b671c0f954a762c539f54bb6d40a9c93abb75f6bc14d4bfdc6628d8e18d8f7473ee1037479c802b1d14e8abe77b669e23e22cc19d4463aaa3e8fe8e5b499e5907f3488195b14319cec331e27737afbc04f26207a5009532462e3e6afaff71010611fcd8d0b562217d9fb3734c01f83093513796084bddb3e1740a92f7f05d911e98eb174842ad6fb50c5e683dacd36f24604cade8ac6da78aed20e356031cd73c134ebd1b78630f51b110f440e0cf99b2eaa25ab5df6a53f5f1df33bea2d2279bf726d8808ce2cb4dc958ecafbd1efbd902083408164a325bec1625acbfd6d15623820d10c7c4ddb98b20b161efaff0291d90e9d9a03c42c49c0e7ff0ee1bd8ff65c27fd8f20dcab3d4780722f64cbb76aedab0ae62cac9b6a41ca8b2114dd455d3e5bd15d969f045362d8c9dd6b956726976c71c3c04dae1a78686cc807f050f8b39a1ccbf9e7739eb6b0cec917d6743b29ba5a01901f022c449e323bf0bfe0de5f539097ecd412e78465b8cea92f2580241d1e214bbedbdab83447c241d57a32c218b0a616e916e2d3073a3680a1e8205d9708d55c604ce7d6833017b37950a76fb0368ef604c62196817bd95d198940cc2242b538271aaef8a305edfbfa3a97ab966bd2b1c1d79a07d607ec881e6e8b5165b6ac02ea6430242544c19aa4cfa52c70f64b4ae1e91db5ccff5ff37e1f444cbdb8a5a9e762a89f030a093c6aea1e285844b7982d76b644665bea61df527293e91de802e01290c350ff12523ebc3ab5fdc4216471d2816e3f184b4948e4d7d9f5cad52a29eeee0dd3c6c5a37f36a7f7d6e4eec42230a353f5d880629ea84255933b3599758f04cf11538e118f6d4ae7fea5565649fd917112bd04d6be14c42282c9dfa2d3282b58d0811eb7486ec1018f25e736f7fef3de0e3b5ea0750539f74a40370aa34cb62888f3d4dda302444c31d60813cc5609757d7d9b157e1ec4ed2638fd1be07233cc9f1e80c2068e9d14b592788aed2aaf1b977592338fc5cc8abfaf4ed872b31d082b25e3f4d82e5d3f95eccd6f7bd3b02da22aabe0ebf81550b800af2f4684450954d4b4ab9aad23e56f34ed46dee224a7fc5023ce9f95d1141565f3453d66a6b5d7c2719ab7a8530804c4c34ec802c10f0ee8abd6a5dc46870ceb233fdb4709428efff4e34529d618ff37fa27e90a35b906bee8bc6baccbe4150d227a61e33df8acdd23cfad89271e8c592baf61705d96053649b77ab1f7814b58908d6d6665a2f5fa47861f3d7f76ec46b16e4e3f31ae34f222c582557f2cc1be872f6a8c33a8fb4133f05ed733d6a8c6516089173a4259e94eba480a7c79bb4653a1cfa1e1c1885e691b16ec96480d51dd697f6732971eec797dd4a1b9df8d1d65147110d1a07c3cc8ba8f1873e8b88b00b7f50f5b65ff0a9c1896f1bddca20cbeb1e292cb319ee65966bd7d015ded4db07f330089cbb56bc80f91133de7891fcfd11e9cfb6cd225a24998b009af39249bf7b83595dd5e59f8d17b9688a7dc8975b4514b0b56939f82f69de1e44735883bbb5ca3f7677c0096c84e1b5dd627a66901691f6dd3b2b061d8133bd02a1661e5da7e8f65ae29a3534f861d3e121da6cbe7f02f0224408ddc554138d62f54e08f7aae34e92384f4ac8daa93a9aaa097bb62621e834f30d0523b30219a33b1afb37d4cd7569f7c1629fb99ab5a139c58d20a9f2d0a80b2c28a52afa09882a6c2594649b0a5a08265ffce40ae7b2a3a729fdce621366ddbbe0c9b7ebafdc75a9dda4d094842292a4dd57bfdc8273e81b92ff607ed94f55442f661ac65eab30dfc7c3c6c9843cc067a48b9c99a20cddc6d2555075f641d1a8129b0151bbc7a8d546315445ea2b3fdba57d2a298edecb51025dbb789bcc21940f58aaed63cd1055298f5e98b33960f22165083c774fb71af9db3745ba0359ec3b2c45010c543363b4e51d89132f0cea2dd1375aab469e9d5e9065a11a965e2d3687c74cac0a7cb9ca1fe75482b320aa27e035392ce356276774cf0b69f5b25d35b698bf09f3cd8df9055039a8b1b64fd0961637beec872672c652f5c26198909d5fea2e93b3972a704de8f957f8106e5c22f2a703e21d4003b213c0dd2db6847961327ec51ba92098d5148a5cc306b93bd1e736d339fc1541e3f2093359a4b38d0ed63e411c98339aaffe135f503d8e05ea1d499879420166fe42f3645782b46a59f6e529853f468682fd781707e3c083ed50914e0317e79c9574ce981d1df9a8b64772275763d4b215d1bec3104cda6eb52c6f9d50f90f6f2634ac5268f41f4358d408d78b168f211726036cd5cac809c8b91b7e7f9a473bcec536d1d727326ee4edd2669c0c56380efa8e978d1af37d1ffcf2c0ccd46e29a12625b584ffd4901dad8c51a789f21777ad6321b3bf8095e3fc46686721c7e1443fdf6439d4f9c48884e460ec1fe0047827bd211a62466230896f719a7ed7737c230c365c396373d621148414e574ff213c4d6c23e05c8b6e1e5cf35174fe23ce40eff6d5c9d845ed0766f62b66223903ae8b4041fbf678304030c4ee4414449b93c418cae16c62c6199356d84333765ad9ec626ef38a0a8ecbe53dfc5b5cf1af48b506de3bb3ebb2e0dc1da9a67cb54cf75aa086ef4e4858c7c031cac2c059e6e126e7ae84596fdd429de89d3071dddb0556e3231f998ff14bcf85922fd5424447f6ea5a257038dcc0578d84c217ccae9437ab48b6ef57300f65be34dfea53a7b7f4d2ce3f38f12a33d122ef7078883fa29792a0bf1f1b3e1e3764da7e27ae7af38209573a5a6a5b40d258d1aef0041696054625b08957188dfe9b9bf0ee0e549a7adb37f9627bf0b9dd6ec4c5b651c53dd5a15bf529387fb501d3855c8bc538cc66a5b162d835c9f7b82f7d4b03181d83b8ef68f54da7a524d02a0148dfc8be51a1f6c7a421c1287f391850dd7163eb01163929d3e1be4c3849bb3ed0380ca6194cd5198a2ad2185612d332e1bf903e598b3bee4804f5b15625ed0c57bcb3984e0eb467a810fd62dedee4849924564e9254add5b4c33734b48c99977ca7e9f6730a4832fc134c43fbcdddfd0f38003534a8323b0714e5f294c850eb1e6787cfa74360ce6b19601bc13de89afbb3edea8de7ebb5b6e6bb283af0578b2b5a7e833b334dd0e906a1c8a5d98145470846847a4ec695dc27d460e2a93ed04569803600dd9a96a2208cf99e7ac9d962bad37418eb0d813c0c95d0fafc3264e59e46c078cb3f17761851b4eeeda5d67bb78f943ba4f13166da47ad1fa9e3f66a6d12457dcba62b584428b461486f55279cdee8ea6acba167b033ef4ab53a2dfc21f5d6b2151730830d672d6652c94e4a210a5f048ffd2c450b7b248fef7e661d4c2083dacf361001b494ef4cf670f32bceca7fdb7c715cc38fb66bb47e32d69f59f2e33a839faca0057ad582ed9817a02756303c3f695d3e542ad4dcc34148bc6b157624b2e3182405c8899ecb78853d58f606243102620385e28e08702e804f576d6fb3e8a0aa1ca853491fbf3d6296d4484947f3fdb0a5f28a7e5157e47e5abfa3a9885a6514e41386a6c1ae71a55a7650ddff738ff6a993dd6f0a6d25c96ba47e4c60d939cf67c8cb00db84f55677fed2205e0b02ac1503e210c508e1536173c5a75b16da71c2b3b7cbd90ba8020ab0f1ab5e1f44f982e1b106288db5c335fc08fcfd539ad29eb33ebe8d841b018e2f69cd1b49bac49cf8bee0cb3db3c2a376385d2585263a605f7ed66b550ae406088a8d777adb12681d86ff7739b66536699a92fc8f29b4ed78ed1c2f7e910ca9fc4892614a93fd861917a8be05342305a7ffe7889b94d3329f0204a2f447c94967e460064b1823ef8d6ccf11ca4eb92734d81db2a2e99bf8759551653757363410bc700c4a4483e557d9da8bfb28f88e7e7a7021b5997a022ae5cd66f7519e4da38062dc1e51a19be79ca92a552493b4ac4bc78db5197efd228542225613214d4d0b570a4c9c5243ee7d2639097720a4dd1a5c41ee4b47b6f40acbe0fc92ef873829d04fd0db43992d8c8f2122dbb115afe32813d41ac7122f644247aaf93c0ab14f3b11f1018d0dc3d8c0f1708b5ec8881b8c931f6c6cd1a42071f1934aa2e4c402f93d7d11ae159cda64d4427f12b98055a0bbcf2dd06a40d6767a1ea01d43c13c91493ebbb0417f762a2041fa88eaad845c3ea5e4d62395427db87bca52fba3a0e7befd55875b11c4a29b6329df013c16e1fcf856b089ccd7b9799a3d8479a3a9e090779aaba1aed06b82112de6660d1a15c55b23a38d65635106e62455f4813c102080e35c663715303b65ceda86e69920b14cf479f24e1954ef0728b5be884152cead0c3bebeec3a6de0cab02687d3f6040bf754666d7985c9d51556e3012c329859d9c40c25f43e47678a6881597cb6d7ee8928f66df8b73fbe891fbfd7241b7414c3045db5236178bcd25ff8ebdb7953aa2c8c943b6f1aaa95c4dec5e77c5cf092100267875df34708cd678c3b99cd62b0021dbc6803426a6f45fbdfb108d459948eec4dd4d91c6ee5e3677da10b4302dd59ea108737a6704cda3df3904711e1a2603da2b544a948c304a97c8f3974c229135d105fd74e71d0104cce2877910b734d2b3f02306250d4c347171de2535ea23e5105b5e283c50d059062beb32a7ee1a2c4d2dee73adf49910b73a15495acdc259e0eb5502bbb0ad37f9a5785b4fd318edb4ecba206a9ab971264accae6cbd50d3146041ebfbedb2ae626dce29b95efd4a90f3b8fd3d7a93e50f29420d0a79566474f60b7a321ed584018a7501aa2ea9784fd16c8d6202c75bfc67b833bda7fc0c60c51b88eaea63c2b1b5fa63a0e391bb676842750a6b6929d4b5c1b6db4929f0d45435a328f3a843fd7dd0b30da57bd27380329c05e136a8700751ed88667155ee8d63e5355bf67b0d42c6ef9c8a4c96d6a82a00484019443e17197d59f6786ecab5874b7f1b3b50db72f7a4312bfe048900ceb6c3d9eef6d0513cf0427353b6ecc798f1a08508f9f84a9067ebf2d62b54cd07888e91ab83f6f96544f90c776c7b4c1ba0cbf99d73e83820fbdac695bb627b44b1a95bde00b4d72b5a1b1ea3e1fe11c75e4b57d26fe78f5ef8b133a2dd3eed1bf0cd4bb9ad999d5411c6b2a645edb987f143ceed2d1fe32bac677d44ef7c42015aa2a536d031b19e9471300c38122b477dbbb4235c20b59bc50db23439453b59a9a7a2f3a907f291d1fd0e7972bc4c4f8a2ab36acc6b8ad1ceb1049d41e7f936bf7b644aa09e562928120f67ec09f9ba308fc11e3196b7df5b82ec4bbf2e80e7f39700f9415324e24f264742a4da9c8626a980e219611a486a6086362988ed00828730aabc4328858ffcf4f71dce737cb56a2e323000fad8c85922dd4591bb870f8d63629cb3e18e76b2927e50a0ec36bd12b452e6749bdddd76c1ef237ff085fac599f06691d73e8d8986947d8cc835c3afce62ff5b1e619e8eb63c0051087b385e20a2dc351f1276a875507f27551fc4449bc8bd4403dfbba5e998a00e031eb4ecc5de2d801b98f6d3192f197193602d42df51b4055151fcf5749fa728f54af376d9d76e85227a9e7b4e06ea7e0269d69ca3ed1b48162886040b3861caeb24fa9a18288acee11ae2705a2336d2a457c3174188fd55d9f22cce297eac7eaf3d8a9be10d2301c348824aadb900790502d743a786bdae2150e66e5a1200a465d951395ff775a8cf58dbb85443cd1470a9b1e2c7bd3a6cbb31bb4db00d626339d2d27d3194c6d7102435178a648aec9c463649c94965fcc50f2ada72a65137244a239605f029a7ee507b6f539c4ce2632722d37d182a6ae5eef3056647b2793b9229c397e219a2e517275e9e2c12dec7c857f002ae58992cd820fde2157b8b47050a5cfe7c7a567d124330e4ed2afa65962c9379c310d39b80b826b2f69fad9fae0979da31d08471bfca4dfa8ba0af032952b4f49487b5777025583e99d975dab5c57efe8d191c239c96e56e578f2561201eb5a68b6e24364e86f8c3d449ae30f79bb274623adfdae0767b83463e7478c683ba996059f381e9051d89a8bb4f3211eb085316474fcd4a9f246fd12be763244268058c1d649e923b99840248d0a18c978681211d9d98513d902071921ee35f28fad2e489c56717e9e510cd00de0799da5bf4f234bbacfbf8cccdaaed71e43e03a996b63a80a2f955e04f09acd25a7356962ad1d04283e68cd1858202d30b385175dacb97b33605bbc3e186f764175ec588e044b32417ab9c440638b2c20c51aeca104e15fd7c2507ac9b69dced9f77cb82c0db057d57f2a489d87a5e89a1f3ed0dc3b0022694ab109890d1ef377bd1b220d85d9dce5ba2e1e967cda24d948daf9926e4d9d8524909800e0565bb14dea68e39099114d82499b54fb14ca9f4c4b73d3f0c936296e19001de98efe4c5eab64c13853108bc72cd128da7ef534e6b47d52e0e7b5152d18d1166fa16c966af18c7b5ae352bccb162b29c2fd29b982fdb9043431701b8c81cc802306edfbe2b7aafead724070eb4ead6730e8e7ce276a16263b1f91ff15bb0c7c7e7f44f6876f22aa362da74e53b1b5647f321a2b40ca61bc2c2f20252da08d6327fb7e48a5f5d5360e7d9fd5c48c325ed288fb537d53b8bd27acbb1579d517fad4e67696ec348fe100627738a870f10ee81584e8d37aba0cb333b3ec196c2bbb10d723ad0756b0eddcf4d0b7f870ed482c2fb7ff1e28cd66ce8f5599faaf451b4e9fecd15367fe1061ba3a7c9c74081748e14fd8b084fec176cea314b7255e6a6714a20325fc94b3586779d7914492d4204d2e483b9033960d576d1393eb038394e22e8b851693341269616166c02d457c84cb5d19068b83d5a0224403f8cdca5187a1fb34ce8086f2bb91bf86dec0307897ac0a120ef4e4c8872fc4fbd89396fcc08ce1d40cf25a57a60f5d40e15bf2e28be7102fcda4e8f1489e6df10e86656152642acd8b1630979d18f98c9bb8fd3b9686c63c11c49771b61d14d88c81d19bbcc653691b5538b8e6bc8324979b79441ff92c9f04a57fd7223cd284a0b1b0da1a829a5af4f8143a70956fc3dc6e771bfab78bda0759ccf296a3e8bd75a4c51a014aa4d2546efb07b87085e0f355203210a2ee7e11e4a537a54ffe4a42e58ba04bb03a0a407ded00395de6aadacbf81a25234add4eeeb23d9c45984fb1ed84ecaee8606378b75547eeed46422beb96f74ad136b420a9f5b95a9997223dc63658b8fddc40addc4b9a76ad6b066f111666ccb79545715cf7c955904faa1d83da49764dfb46803e70717def23cb0c383fd25cca67c79c84ee5716bcc8763f3fb755451e40b660ab2e3616812f0c6f02e0479f3767d7f71c111db8e816d713eab2d621f26c56eff89b47cdf3d59780cbfc57a24fb3fa7425745c654d94b0fe3e7297920d1245974972fae30b0bf0a6e3e694620e92b6e31b8f64cdd2c4cc7272eecfaa9c82316ff1dde07a95f85da01d23eab63a9857d6dca2bef546b1b0d1ed3217de1e96353131485915df637cf3f72a55169101362604295595dc3aea16bd4a1c6b5807cb2aca5a399a436247361cd940f6afb07608d5b9affa0ac8e9960d0af83d76624999f375d8beb8350f601fa0d0a3c3858940b931b3546916a6ad8612b099092fb76b3df840fac782ca8be68f410ad861196719edf83766c66d998e6522016bf7fde47ded84d4e5ff73e4fc3510c3a2a457c0c74ab6f787500a3bf6c183dd9dea97ae43a1f9866cf6d7e15c28c5fdbb7a58f847989006e600876475f77411baac7fff412152d366608228e5561f7b4293e692f7cecc2b0e7a0229720bfa80b13939a3743900610c452cf4064fe994c839ec8e2570d1c687da882d865457faefd016f329a0854eaa4f11e0c3dfee2d40be937e67da4720dd531dfe089cdd069e5c984c3a0396737ccb62b9f8234c4bb1ae6d4df7bef4ce3be6744f69a1e0046da8848516cb88e29f09e85c7b988c7fd64dac93b86ed5032572dbba3795f9d6935f5543be6a0af72e1e922139970c505ac35553f7368a939055a5fd2d92ee2c89dab9378e7b102551f0b6c8766e6c046ec9b8ae9f854bf7b8afc7f88c56e532ee28fd8f151c9be66c05f1c71c47f3e93f08fdfa4e74e73e6d456b7b3c5c0756ea759d07b13a311cb1c8731af5f979df6106fe2b31438bc4a1651618b7d7fc31b2d0296f4944c4d8ec65d23731cac700525841466ebe648d7d7be431e965abcf3c842800929613c98b5dbce7ad2baa3e31aa1f0e1da2edce23c6b72fb38b66268c1491034db6676ffa2c3ab78958b16729952eea997b42b714e44d001f101bec298035c5a55c49b68d17c143704fcb9d9f9caadf66133112b87253a608de56744771f2ebfb9f29a0182012e43ed5d350f3c0e6a9fe42c843e7c9bdc335228de271c6fc654cd15e8251de83fd63a9de323cd4114c4506a7fed3c7f9c1abf6881d523020492e9f537bfa2fc9a72f5f41f1ec6c437106a03f1c64de19a7c6a76ce99d4f5e100c3e5219749ca313179135e7752105cbb2017113727ff489325122b8563654a71ee35d8a957a5b0f0c0a1d57bc7d9d5fb06ea66ec12d725773c3b0c7a3b7c44334cd7e6f3ce9d95c548f4fd8785aa756010057d17b5bc3bc149aa219e86a098a20501150b7fb3431bae461b16362a8230ca8842fe746d5db1ede0bacc478f62e94592a789ffda2dc234b3c7422ee54348e544daaaee92328a5dc26a5070adb5fe6187224338380ab7c16a774d1096ae0985ae6a5b2f69571e9898e7265cc20368a1f6f37e2b104432d5b1ef2c438132f246fb087100f008c63010c201e959e0f9f6e59744e2a2c0522a4cfa12fd82bcc7a2679bee43499a296bdfba65d14e651ee10bc1f02580d7786a7be68c913060b3b3844d91405a2b2133193f52d42a2e35de273e63e7f8d569fae2636564168cf03539fa79006b0690f46b1a946697da052069ea3f21d475accbbd5c5a5302628e69fe1d239438939de00538a392fc1b62b20d3b413eb93255b562f2e1388fa32bea456109eb4157565c054d70537e686a46c65e8fa5dcfa83a021c189ead5e9ff145adf0e15efe5d97703faf54c205e0e2695a3d0cde340b9af16dc67d67334190d7b915cb564bf98e4a79e05744f275ff087235533afc291d65239484dd1b3aadcd2e3c3a623dcfb99b3b6338cb3957da022c0d962aca362ee9f7d6ddc2264d59ca239e75eb488349fd0a4aee7a3ad35357051eac9063ea853f2635a24fba249fd608bdfed9ed236391c655b67cba5b0aa1d11bc9fb7bb9b30645a6e54ff9663e45356a11e6bcf475c1795b463e250754719ad689ac429b4a0e5d5a0839dc3b64db85ab0ac5410723d43e72474207b799e660950d19b57def5491112567d6e1b705f21a67a20c0395e71cf46718fa11979d765263370c7b105ee5fda29bbe8f811af3bfd135a89c9b863fcea602bbfd5b21d6712eefbca3ef2dc074812363360dd46c394beee1356fe5b0afe4822e0be6740b31855afef48145debd113de2e6b4f0d96972c07aa34820a67881f7b5ecbc73d25edc7036b015501689276ce6be08c2173075ab1c758b6979a936b7dc0f00d4b8717ca3836c92866e5dc8ae042ab57a2f6ea446d0b035bc9e48bcd2bd2c9c62977648cebe5047543501293db4860d14ef2363643ff35f2eea96cbf4850c2c0b681bbc663e2366fc0ba20b15a6ca94897ff1f6c0c83b7f490801ee70c62b0c89ae294aa1e3744d0c9c0c852d13c2cf3ed591e8a2a5b9b9b5d9daad4bcba98ed62ffe88a584b7b964c4cf9da27aa501e120b5a852d909e19a99150a627d17d828f2943f3256065c5ea765b98f0987690a5a5a808cf4721f77e20a568565ee6daac66d018c545eb524ac26762d08633d6491db00753f1b50b143680604a608a7a4bb6f7775bfabf839e0925683387ec2ccb40cf03ee5cf77eaca1e15f342e70ecf5f344348819337d4fe7e8f69e5ea697f3e4bdec4084e1579fd6bf5520c32c43e4260895e9dc6869b62f30a0e1d07d4e95d073f0a54713bc6bbe6f2ce78aa23572eb00d2b8157c2085018502030ca4622ca171a8526734877886b392bdbf91a2f6c2e4a9c300dae6637a16fc448954d7b7f2d95f690b7ca6cd9afa59d130936c741f06c6b90298c66cc0372a19328c99b08cae04fd41c00c03164b1fa1525957ff8032a6e03896277c300529795be219db4341615254cc2310ff9456f232ef01484ca345b237a2f67845d6665890317c4e4b0d99cea146110279d6efaaf7bdf3970ed6403922a01e6ad276112b76e03a2586a7c6753aaa759a415d9637363fdbcf44d527c051e3f95d6e525ed48609d257ba520d5ee2432f536e77190804a349c36abd972d8a49963bb6d46e2ee5770b876d1fc16c6c1b064b4cc6f56c54ded7a6e8342472c6386e20fd4840a6a9e26ea9e18928aa712903d5f43aa6846a53867341842912fdfa2e88f29661774ccbcb6f9108a7f78900af94f1d273f8b285fcc3ac4937af2d061fd6f4f44400a39b5b1a41ba18d50237aff80879c885ced3b89693536006e1b7a0e16ab575d1894ca394fcf755bd04d7783d8c8a9b1e1827ff1b16f6a5239b2b44bc8ac2ae699d446f2e6706c952da1fd6400804f1c94a64322b2e3d3b2c34c0c3fcb3cc6e70c970b54c40d83a76bee8e2429882e844eb3fbb584e5fe03dd64c73285cb46ced2e4e95a891c28269a5273396f12aca33dbeee76382737a0718843c1d9b56b736dba753d5d53021c1dda76de265dea670f40ebe0e1d400ca37c9862549d4234ace2f22b4c3ee3cf38368c4176e165e6efc087a4e78d4a98b0d4cce725db44ada55ae37205636e2da6762f58103f2ac6068f53626169388681ceb7fe7b464bb91a1414bb4c0f0258161506222d0043b5686154bce23b847b87dc91a82f8c2b5292f1ed43f70d1eee800e2ecae548dea804888e2ecbfc2b9f9cb6b68ef915d45f81f1f7daf0fd4499f6bdf6abacacd8d71f8179f2f285bc42b37a91da03991a37931c476e289ecb7862120a2250b2b4810c9ce7d77814e832d1fb3cee49841fc406a9e180c74974f57fe39d0396bac4aec5f9ce44ee4eaa236db228250aada09547eac88882766abe14f31db41982d118e3377ee65e59f758a488a6ef012bcde624ed0c420169fce4f8d8595804724d44844cc6d9b15c0df25b5481f785851cdf3953f34b1714685276f7188e898db3db05568b6f1e6a28f6ee6db16ff25b40547b5f2eb502bccb12d570de7b20e8c78832b7ccc41e57a3738d4c176c04be6174c59430542dfadd09cb42471942975b35b433d61e72a14f4150943bcf2e8cf467bec965268046b37d7aaf4cef07d889706546308286cce319b080ac37251f870b07a75fea5641d9ba7fedd7bc9e7ed04ae63807fb2a3e94f2e8cbfa1a02e7b16e4a46fad1278519a9906ccdf16818431d4ab81e81606155d28ca02a1cca2377b362c9c73fab27db5d6f9f5940ec3adf95b714f2cb01f222145bb8951f595a20be4cd5f1ba2c525bfba3994b04b4da561ddd3b35d91dbb7f45625db4b624f4eaa7515d4669d98a1585bcc42bedcc74036d3504c7d7c105a2acfd52cf0deaa764228b6b42ef58b715f86a0a28a285828b94e3d3e87258cc87820c4463b6480b58abb3cbb075d2b2ac1c534206ea2adc9dc4eceb2f43ece804e01ef9bb37dd5c541c8328b4a7d436bbb628ad3337f7b5b004764fac87daa17b988d86f062a3599d1cea93b9c3e7354793654658facfb441aa3a1f39acf6882f784ee414a368ba2a9446764cda54ec6447a61bcb39edbea9af2acda30b536a3880a1bb97803d5ea7f3bc6f4a3857653fe3c706d99366f53f14d6db60ecc89405156464f29a0180d527fa27cc9f82c3767a7eb1eeca98967597342cd069614d6d4cd67c74d29a4bef14491b9171d433cd4cd476d5812c77cba306e5d58a5fa209beebe362eb5cbb17236381b6d4f094223a2fa48899092c98266907861f8aac2118bd97ecd917f8961c34fd19aa2353b3faef7e1ec5c042b22b893b2d35b860850ccf75a3e0ad2ea9a62b8c43cfbf850d0e56b6a8324d5ee464d857d179f724adca792c2b3086e2cc3b4397073bc2e2e5f38c6f73652bfd50494a9ff0fc6b321bf8e5f9c1b50280dc7682282777fddad31506aba2aaf3cfb4b601fb875009ea11d31699f9a4ce86a5a93812f6f69e25b1a1600608ed382e8efa485ec19d6c65dcac5079d85e24fd3571bba5d9e438649b5f669c1beab42fcdd4809bfc3bc6ed0e12edcadc5913ab6731eca4ef10139d16f5d73d74ede0b220bc750a404ba517f662358e3f2c20a1560e03245d98b9129bf0015a368ccd87234744bfa43c30f344d5730979084a977e5c5329036fadbcf19dce8f1c321de4c948f653d09183f18034a40d91c14f40109360127a0e342d060ca142bea791e7981f544d7052edf37d29fa1d79d7b48e8eed5ced4e307f60d4edf71aad921cda3641515d4f233d468661bc061cafedb59475a62f8acfcad6ff79edd0e582b27fbedc28f9533a08ece0221296fcb7dfa3374c306a3a7fd6e6385642393ac1cf3a88172c384f0e6b3d2ea38a2705cc8d7fd79f9cb818d1c5f4ec623ef325eae744b7d9d65211e16a648b3aceb39c40a183bcc1ca34e53d68bd9cf55ea64fada2b1bc79e8dbe675f31297d8cfcb2f20c29bed1adf313d2d1dbbd04ee7b43472d06b34da475cd326051e1e989731aac269ca9af1abda4b4a4c9f5fe76c818f1469b2a2bc4e95c9f84b2261e530f80ce6518ac4c646699bdbd4e76b4d417cc7ea7d3877bd366204d98ae6bb53d0397ba2237bda29639345e4805b92049d1b3c6d89318898d3169114eb60906b922aa27465290258cb351a338b32a6dcc93a236638ceab9ca6445e7f446496ed0c1ea5d3ee4e441168e5b0311c8a6f9357058fe1ac057facf8c9f16fbf345fc8c5f37d990fad552f38f8b82edbc65555c4ce1200893143b6856c91968f14e7c89300bd151f0dc2a7fbc9bce4c5b68190a235c285dc22cfcbc0f6dcb9af7047e471b86bfa4f371c9831f5f9637e836a2ea8a9bc747f3abdb0527cd7025848db568451a234a5c84e5d6dd974be11d4c735a1d94f3f2d33463a0570baed496d53356330ca29ace301369ee56a059187bbfdefde3f3837c82a43df9f75c1fedda6928db965fe1484f3322b720c6541c0204ee9d1ee544f77b8c6ef5f5f965b5d052f58b1baad7520e8bee62238fe3cc2807f79ba3dc01952ea38fd17a08c2ea8354a89bb3e3ab5cea3eb3588844358770358808cca73f20a344fb8dfb78ec06f449702abf9f58004709a6699ab13ebb89b75b81d5e88ff7d23e513b1f2a6e22285d440fd4060362d1a64ed767ef78f5e7542b32099b9f66eb2ce6d13ab6d659c4e691b9fd12078881939fe6ae1dd85ac09b83b954c21c3fe558770f5b80a8db603828eaec2e3f047ae8a94ca007446d4677c4091eddebc2be2940aa472de97c1eac559de27a57e07bdfc23f3540108f9ce96acf71667e11c3aab246c349a3e6dcb0c0789bd73fda925368da3c2d5060e1991cfb04156a3e21ef6e1a2f56ab1cd4426fecdb334d44c20e7137984e35e22e6e554ee38878bfe5bca22c91acc734db2407e9d132b657f8afd4721f7b5baee8cfd57027bb2a59b98211abb127cc1d7054e1a801b4c173edf6f133e4a3635e63673a2fed4b64d436b842050872f49e52fba82f7fbd3f7842ec1e22a1aceda4759d8e3a7cda13292293770bf0f7f9551bb0bb1683586d451981071640a050b37000243904593b1491cfd7248d06cb91bfc469be109851d80201407ac5035c71eef5823eca33ae2c72f9d9566420313ec77412c7b70041489d2c43f29632e3adc89051fd6e5994b54342c9b4c9cbe585543d1f826618ba788a2320dbd133d11da906e32f2b5f17461b6e100c4c6ab95064dd7db9a80f99c716c7a76af9ef8a1ad7620bfeec928471a1dfe9d8c09af1bf9c6aace2a49b5ca57b932cc20144f23423549e011d66fdf27446637f0371b6c339cd9dd4fa62168baa3cc0a7017ad83d0a5ff453ef9e559b8501fa878026ef707b3a4472ce1189c9e181b38fd14fe2b9742aa84d7f9ea525cd27ad6b96b7d1cd211f1eccc309dcf549001e881a67b3967f60de5fe675af88e509166bf2a587403cbbb789571789a6d982fd91db7d440e14d9823e454345a44aebb5de3f565c3b401f9e18dd3a9a44d42527095a2d74687742bcb6ce704ba057c2098783a9b11c4d9a10caebf90069d25b08da22db00fb48475c48069d7bbb131ef32fbf314c6881ab003f04c4f3d6a1a41483181c99e9fb8831b9d75409bf32ad7ad1a50adac3bed4faa9011298f1417a17d22d553b70c4395facf3d557d11fadc82fe93f1c9e33a0dffe995a65917f87ffdc45e820dfa8a77b6967488ed521b8bdbd8c7af40b8ad634d6361b8baba3cb2573b0cde0016e60a065eb71045af4d0e9c8b8e461dc91437b2f19f28641fedb85ee55792bcf718fcea83e3fadf9e5012fc49fb677d45d7981f63485d4ebb9bf89ec20b0ab337ff6e4c5cc8f6a197acf5aad7246bca53ce187cd233ab86074de046c8029269d85adc343409342fc341c061633e558dd2e887a1d65b6de9984f58bc5076ee2c8d0999486cec6b1ed3d723cf65639448a427cf3465736123211181b1c0b6f2eb32a4ca1608a0bddc5b4d3bfaf3eb79bc0119f40265198933530bc3c5cd3dc3e325a3ea40425898337099e73c1c83fb913db68940e121d056b663cd22ccadef98e2c7cf87bf387dcd8ff1ce0316a6a1939bc16b368132cbc749aa858a5dab7de0f2e3d44369090af102c7f566b84a8926077eb3bb5e25855b895ffe34059cd6d4354094ebd74f120a631ea017c59c060417ab3bd50bd1bb97ebbe5013f6006ee04c64845a2aa31655c2fe6d01211a907b49da09b096918c7875e294ff75f0d1adea58864ac1fdafa616fea4ef45b237b55e1ed8e82cdec199458290bdc864364fb70ca4f8ae2b22b21f65f934980de4abcc58be316ee2f4db6faa1044944cee3be4e0c4c0ff88dfc69f6f84361669e61484fe7b95bc2ba5df4019bce322383ffa0567034d8099cc7bf00503ac23aa31db66ed8731a0e5fe431c927056d61656179686ec4e640cf9ff9424a9610df02701d563c41cdb32b535657aab99034dfebf97bdbfefebfa5b478ac36aff9a55383376d8a17b676ceda85ff782d28f2926eec4d84d4469fdff154422deaf17f21dee64405d132c2908feb73fa2cbd9fc4799412ab7ef5ac545dcd4ea4eb03e68f903a1d1a22a440d30a5f295baebdf8e06ca28418d18da2d5182450d14fae7ec5fb0d3cda4d681edd4dc89c505ceb938c2c7f4740114d92432d4b4847c28a7409c845e4967d97a74039c509875ab093d36ff7900820e14c7050735819ff0ea86448e61e8bebdc51ec392498e18164da54da5f12dcaaf435559bbecf0873849fd97f323177538cd90f0f6259819d2c4e1893aeee8b5c34ed34fa44bb138efd1751816742c0368263a69ebaca50bafbdc4058c3629fd2e244d6221825ad31053920a18d20e06695b8d516f3777f9148d8f79ebb11e58a38645357ee9304334b00052d9b8238f0c7c1d17e5c26c4b70f13361ab3079b5943a56a80eca0bf0e32a6f165cf214916bfd60b41c877631d940aff107c336722c8012b349ed57c6245855134bcb6f668fd96716aad4e1163d5cc03c00bd9dcac17db8ff6926525061f562ecb0eeb2a2381f50375e7cf95321f2757909847116d618d8ab5a9a005602179a1e7ca0560de8326c1c936dfb7dbdff210dcb6e99d11ae5ba9f98fee66aea215495576831ccc7790e96d931216e73b0a972b889ec7e948c9f65e0fa53e9601a2a2f667c84813f41b478bc8ee4d82e3765d27e8b25f345bdc15d9259f08d1f2b093215026381859e436acfe6841cd02f9a29b5b71c7aeb20dfe423aec33989d403f82e54a819bde2612ab8087144aac60d0526d410b54a664cc7db6a0e68d350fbb7d35c6761cf2c4a90e0e8cafe07acaa6b3608b8c092042442a70e1926bf0fa8d8e3b39320614f346f880334fad8f916dea777c9284db7b2f9388a7b59cfc603d3078d634bf2a64a8f7deb45d8acfc23957dea311548569cbdd59231497e2fb5806011f2f4a4c9ebaccac248c9e480693bd0818dd93c9ce6af035b66fd6ee557db07514608febef7d773a6d0ac9fea01ae09e24739631621adf821af5a5d843a07f4d9c51881378ce08caa529402bc0ab386b05f7ac49f4545064f92ba15efafeb76403ddcf823673d93d42306a2f880fba78038768e94fe4070a50963e09dc961fb4c2564f747f0fb5ba46d5a11da5c80a081a910542d41e31341a80e403f074d15f767df42b5e1c9c7dd583b280a5881d5bb94054b216a3488e1aee295522f762ecb5d19bc34499de4cf2eedc49dc554867a3846b131ba541141af348f87c31a1ee77bbd9622d33eba7651139f37a817cb04033c75e0f67f2f61500ebed40ea7eaef987739f31e18a53fec49bfe1fb17aa4f23b4bcd70b0534fe2716995c2c689cc6232a7f11f3200be82783276982025c79625536645abdc82119b6c2f7f5bf9f351eb89e14b1c1aadeb2a4a7805ddd56807490a22ba806687c74e6c7a7b62655f09928580f624bdd2304b6fb4041ae302b152f18ad010f03a4d733ba87274f6c1a2c0e1975e5bfeb6c3d21fe618814b253fa84a860802b91db5c5f14cd8e5af59a2b9ff3f140d71368657f855cc7a5a3e26b19c5978bb5e56dc7d67fb53606d34a4e0dc8561e63ca80a4ad5d0ed6d708fd93e76c2529a441211f8665e8e1c8e8de3263cc61790a2074ec5e4052dc63b13cae4d4dee43ff5403b38baf9ffaf3d78231d5956ea8a1b8e75adfadfac048422f3d8ee0dd86c1c2ecf8b5a3ddc40da9e41f4b732061ac69fc3e343407e339a2094aadad74ffc0648164eb27f3b9e0684335006e78ce170a67005809a5356e9131bb1c2b5ab94da39451c31092f390df925bf09c3ac3c2a3f9cbbeff552d9a9eb4a27c98fe2f6f441c7b6db59b8196b6b712e13deb3ec356d474f479fd5eab3815150dba66ba309c3c36f62476bf8e6aaab597d41eb4f110292e4cd4c6844e7deb2dbf1d9748b61f17defdf7f8ea4e9882bdf9308ccd5ed9ad490fb7bc60f8e3adf4e59f6d2a7cb4baee7a6950a371ad35b4aed0e997b1210bb35f1fad6dd6f4f9c6541f55ff66c06d4ef1d6ff8bcfd60034a3a85c64b91b74d18ecf3b2f5d3642eb65b79486f065ace657adecccf700f6891e4688215bf95a8b4b1c79b0ae834afb0dfce5d2ce2573fb64e221df25e0f898f6dc0388700d915558441b9c4ce426df0fc8656b5c3858e20de094d614b7872c86048bd1e2154186bceb8fe696a3677d4843330cf1704fecd739ef6df42771ad4c4ef167d69b15bb23ba32ece53947f81d64b1daa73ffba1c9eed296b1135861ecfe37cf44f74057e0b5883ce5916bdd65903f9f5283c27253204beedc4a53b44fef61837d64f6e8c16e7ed2cc17db7b67630b38c6236c3c411b7faeba62308f44fd2629fb8812e03efa96735a9cf85f2037bf5dcd3991afce94ca49b908c8a22520b7426c85713af0ef853c1bdb73b36d15da55470c02fa5ee51f9260937db50144324b06f52f298609aedf0f6a1ebe7704bfa892e0d31f6c7886c1f5e4a0d57a84b6b6fc0d9eb1f2a3d428dd0a9a5342e3f82dd379a313c432bc0f1b47c65fd28965cb8dfc2edffb09995d7e147e2635d7add0458b5117942fe62faa0de1a547ca1cfde8ec0e9920e7372cc15c130fc8183f11dc4864b9af1b5232120d4ebb84dffbe29fecf185cde02f3fa36d40b422848f656e58026a17d36c8dc27e52e69712193a2165fdf4fd2e185948118e8ff0c3b241f725cb3b7998f947520a7eff555e96c9bbc79255c7d624b41703fcde62ec6026b2d97dc5534a818ea099227a78e0a6704514d47f107e69573b4fa34633a36ce5ea170a328a415c9c86f5f7665715201f91ee3da9b8d22be7100afeeea544f0dff38e57d6f48e6583837876d1a129af14d905391ac2204be09c8a10cb4926de81c794bdc4e7292d038686ea43403990b10af814506a76e2eed3f5f9fbd025acca7c289e650dbb94471a4529e96e5a745ed82660cdae3fec1dfdea2034c5256c327b385d0270f1c6bfba14594014580a1bea5292f6044ce8c0a17aed069117e634cbc5c38f592a89d1fabab2abdf0b579d4dde42d26b78db8098ab7ce2b3ba9562a62def3f0f72bf4535326d2daaedc5d3b31c5fd352baa836c8da6439ee7eb81978319455c4c1b0b0d1c7e76a0128cdb15d2e926378943dd9925403781a07e5c81db4724405e1c0ec9a5429deea0bc1d0aa9872693c07d7d387e86d482d6e25b0c49c9532606ec16f0ad9e30dc01e53f963dbd963b7d6fb378c6adff31a3e2cc273416b0a320013453f677df3148ad8c9ef8270f8befe5b75d4bf0d4200775d1f9bbe34010b523039a8451edaf929f0145d5becefb396641b9d7145d1f8b0a2b1b354c84c028a2252c2001f0faae68af557ccec217cb4d5ee25cb06e8b6251e4e479b54cf4da638974521968f6d755d2d4d879500d8ba8fbe9b9c36b491f7884999320a6385e71a0b480dd587dee526464c65f8e38100c399ffa9f19686c16e1bb71b1d4736d45f422880e80a39e3071008adba42114a46b8cb318d34b95ccaeb5847c010acb58bc27f4dafa1756959e0883be65247c90e799df0d498b0f4b3fdff8a91391e98b16c1fcb8e38a9c6c17491b33d9bbacf61ec1915def74fa54e31bd42961ebcb11a3dec064015fb2286864f0f38b7982ef88e09d3bb2b7e752f6b549bd2e4457b322a5fc62230c26332192cecf010a54f6f26e635bf5fb0946a8a9eeb19319a705bb228d4383ae5992cc9500e2f920d2c2049516f67da11da1f08304f4c50335e67746ef463e3d7258b6545ab83f4a277ea083bc78f82e4a39aa92ca4f6e64f1f52e2f89bd4030b6a16a729f4d78eb661027f3a752191cf4bac74a07a902beb2fddbf43060c9e6e71fe453d4687598ec6d1632c1d1b62f6c62e1a9972554e9959a8030d79ba7d468496c95fd80a89cad75f7634fa733edc6bdc28f8db4a76b3ddef9222a11bdbc07c890613eea39b8a0155552132ff84c211a72b77ad34f36c34890237ebb0a2aec386a94eee38ff316972e93d73465f58316e982a03a7ed7ced2218c7b73af695b05008ecee05f04a9086d551b75868a215196d5fe1b3cc06ff36494280cd6a2b246b986378fe4d02d01ecd45ba82c522f25b196089854b57ae22d1587259f5c60897962a880725221039512ececce4d50d945adcb911fcb8646f536e7d22baa2bf463588270d2966fe978f3632ba8f5965d880f69ba52f43826d13950bd7c4bac7163500bfc6fdc83c980c0f7dc4ddd0f10819c62bfeab06bdb6fd382ecffdb4e3d4b1a5e679ec45e4a724c161124f82a907007f80447027e88c735b1abd9c88e9c42d1ec7b8da2305b709950f8246f6c428a64632279a6df50b6110c7b2097b640e9e2824fb957253f8934cf90fca71796e767ba2aa18f76fa11daea8093e4566235fba9102436da054016906b1555eb53a38b57e6155f873e8f9f22ac8024f8bb7fd640acb97ca73da93ee52e591e8d847cda8ca19c9914106760472fef5d51ababae191015508ea35cbe1f1f1f56d916978dbfbe9183f6e706ffa23da7c1d2e4c0b662ba58c19a3a262ceb19c6190d117349b8e6e8ba21ed9379bd37ccd691831af500e5815598b6eeed873cf080a7ae8ba7b1540182f81177b6d24aab9bf05e87ab1b8d3fc4a16ff1f019cbb5f89daa13e7abb7e2fd13da9eea1949e45d5c8a9ad031037c1402d62e7196589e868e466efeefc1be174f0687928b957cf2a10c2f651e9bea0e49df44f4f1efa48d2a7809c749e49dea6f60d6671dd47260d7ead14ffea4af063155c3f097f135bac58b75fc39cbdc95072c22e0db8e800ab63a0c186e69b08f43c75dbc83192d8d77a3ce83a3abbdb79870afaae4c2026327520c37650f0c37033378d8ee4c06c42348608920e6b4b5ad971e10d02b7b6633206687fe16030337fcae6e75f13d7f9be5fabc9045c9a3962a1ffeb8e537fff270f1cb25b0ab0cb207500305383a4eceeb99448ba2b2acc8dacef8493fad0841ce6bde8c14d912d52114f3bc9401e200d956fc54142ea0e993b12a6a1eb54e03f62fdacbd1b09e6fcf9016fa47f37f7966f470db3aa0664fec144366ef4c57d6b843552095869315f87c21ea1dcbbc443e2c6374533a208895654ddb0e239da2d9b7ce6eb13a4a3403e1535676936ac414b720672982f0eb1c5546d625b5253cafa3277a5959b586ccc68b8f4f60abb96000621ade5213d7750359e5d68d28abb6e3c241615e60a712810c479d68c34dc883dd83898942c21d50d8be4e6fd1c04f597409d78e3b04621006e218427a7709f26fc0a6ff70edc5279468eb7135e947416861fefd2ebda0bfd53f862ecdf83fab1c13dd412216aa9b3dbbd35da31b5ca95c392f398d3422889fc11e004fcd7d781fec9050fe26d89e333eababa4641bc0e77e9fe563330ec61a4fc12332306de11a1a29b173656052f98d685e61c92236e4105bc6c8f86116ab1557a6b9fcf3085b2c46c0be477b54305c1d9234d684e63a6b5dfc938ebe0968b981099811c4238b7e0497571a6b931d48b22eb6766187002301ec503fd5d4bdc6852d032c6a58b0c32d90bb4cbe9ad386a84f7c26c482031fd2fec0dc3b494dc842cd442b162d4a05cb393e7c0ddbd670e3b427a0cae030fd110e445443012251b354e75dc59112038ed2c80095bdbdb3cdcec16310df1b6c845a8fd60796e61c9330d83234144e7b2d1fbd2bd68dc29f825d91ff7238a4775e16c56315e096fe55c3a450fa180b88a9f63ca0b6af4b703eccf26a06bf12ab32c1da3d64e25fe115dd253dd69e211a1f1f92456305ab96d0808ceb61f157b3eff4c01585458936e47dfc747a1b2f12b9002cd7a6df2946aeb769d9e99c85ac75e43e9134bca339a5985f967819625a1d3cebcf633a9b0e2906b6fdbe76bf025d41e854b92925a1374863824da44be54c10d9ae5e79d81cc5c089f33772e9de19a52d65a7b03dfc89b837dd24d6456e017a3387ea55fb63ae2c465ee45899ead2cd2238184edac35f399c5fb9e6af094b3e57eb2f8500f6d112a3bc007ed10ef9b1f782a5311728a16162de65a8ce34f6b79b6b695f95782d9d71b13600a90324cc4ccf407742daadfb71dc5677d24d49da87ef70d0d1cde711be4f9eb620b434cb67c8c34cf38d1732476e1aea8ace4e090f905e3eb49a2474419bf522bf0ca4957717e2c052dae4f4938d213ada2b0c32ba272fc6f459203a40266dc344b38a8c64fa10e7762b3db52055fb4eee761d8373037f4577009a9921de4d6f628d13a61ddf0c9b3dbd99f3f6c05217f5e1247211d504cca686f9e99f691cdd5f550c41cb7453f76e8448e9719e2e28785867c73aaa8a98cd5cff1bedd058afca52a4845cce608027220fcbc16f966bfea0eedc91f3baaa1a8e2e5bb6a72cd9f2b95e4b05b4f3cdb88c3725b0f0a445920716e2094f5abd230539700b373b62527a296952275284d899bc7e5c6d2435628cc2578862e64fa09b3d4b666c253144906fae75a7c17d32584ca35cf6c07b4523bc564957cace777a79c7c640fee17d7cc5d89701e0090a78f48ff5daad018365bdf63d3d3b0eaa6608e5ce5527ef8cc29f293265709750a27a884bf11523b705a6c882d30249f50d9566396dbf4353e867fc9f0c1edfc9247d25bd8bf163db329c85b7e391d968257791246b6bc5f8d30dc6e892d5c42f0c581071d80285fccaf9d24452fc521e1f4368c8772e7ee11af9f156ca8e92ad8320587813768ff9d41a102213eef7504f5cfffa06ab631af435da1db24e7795393933ad48d7f72bf3bbd835ed6d10cd3214d337019efd4a4db24cb100dc43da4c56323d6e03388fade25d840cddf5117d16f0d49278628fc40153d932d24f5b0890b103a27deafcf245f205bd746688400d0c66e62965f21e9767389edea1e485d870a7746a8b9d54d9b02b5b0a99702e824ef74c70bb48e82582de571623a7963d667584921b48a47e2c5c8ae6e76039a8109f31b3a449d4ea2fd13e931871eba5bb3bc6cca0d0f3340f6782962263092eec26da6d5eee33cf0461d7f0b28fc3991d94454bbd5405a88be440402f0b49885bd6082ad973b50ef54886b283152c44198975001998b6247c7085965a6e131e3663cbb8c8da4e52c82cb4898437d4b136c1e2de5511a8988cf5f7ec259ea8a084feca4b42fc40fd00f7d42d405aada8ccf27b0c037619693c4ef74bc10bc624f41507634b439278158368621a80fd020ad02ec78da23b9e293c0d1c5ee9fd46f65f2a28e45ad802bc9f48030db74542f2dae0808f08b08d87858c8e64375e5ff152434d1d987d2ea511e8e67fe86337b117c2e3ad5886d08e57303bf0ee542ca42d2a541609c97b018335e5f0ff9f3f7f7c90516b165004ffa9fb2a9bc123b00d9d95c99e414f729add50af7bdcfdece8d7cfc2a8f210e46f92d67dc396d248d7cf3a7fadc7d94cb0e947419f678198b34f16f81233b2e652e1eda09245007c6c75a83cf07d3fab463d7c05365bf589ff64dbde95de7fd74168856d040a21de984486445a24d919c8db3d1d6ec685ff751483397825ac3d3a315fd2ff390d87a92c0173cd0234d560b709104e632e86edfb56fdebacd920eb6c4bd74a86f1459eb2417bd54d15371d29743f1353f436989b2224d55ba2b37c13076882a23a6511c4edd37d1159f01b4dcc3f57defb0f85868fbacfad7f6ab62550042626022ce1e2ef3a131c9c0176c259d7167660fbd9b08b75221867b6b9ea2ffc4d9fc04785d2a3c5289eb599eae39a5dcf6ad894293a838b9116afd0043fae1219f31fe2de8475d96a1f9bc9cc4cf17da7564b894f26dd03c9c65af0c00f296f011ea780a6b600cd59ee1906c4f2bfe8e5696fa56c956b61161f944575d71108c7fac22ab0a6d00a3e8bb5ff0b964d2a7c8a09f715ed5ff80b0933877986c58a12963dc11d3f25f960b4882221e55c3afdf8c56d87a94a8f62c5eec00386e392123f9a117afb083b074176a81ce3fa2019f46d6a36385e6bbbb1a28a9947f515f4e3ff86b49041d4eaedf6d3992e91d855288894a8acaaf6477470f7170457fadfea1c2e088ffcec6b33aa435318c820bbe302557ddbce1e008dd81e4da65107fa51b01ecdaaa74bdda4bc0b7cff76be459e23de4d7e1bdbb01f0dd98514dafcfc80c03ffcf0e52811ffc86dbf7decaff3c36893564805a74b5c353afe3757911fa0a48dc609ad32c27e58a7ff26edd3008ce3b08c78736d7ef726adc0abf813ad89e33aa77c538b10c04e62111f8f46c31c2057d60ede26ba221baf446938f51c5cb85ea645e98906f4654fe9354ed6d887a0aed7232073bf5f382899faa4da28bb0fb1aea016d99b09006a230ce766f2f27ac65d16889d17b2d1e862bdb40a5801cd0356ff6ac30d527786fa09afd9d998b490501b456c72ac29e52a73ced9f0104152e6f49d3ad1e4050d12a60ab83c64878e6b60b43ee6e4b80ca2763d130e6e9362fabb68f83e427d1795a2c0bce3e1090ace014fea98cc6cc9d0c377e9c0be692c372d0b418d14babe5308adf68e208bcf1d2f1e41368ca7790e9622c8b26048eb9d68ebc2168ef65970c2c437e2152486be67d9f3d745e6d6ca03a04161e31163c69c9d2f3dbca310d80765cfd50d7d3a37432c9f3f1a78063b292841dcfb8119dcae452dddfe2be0ac8546bbd20dca09ccd3cf3da6fec3a2ba41b4282c9b95e3b7ee167d533b2ec977f298b649ae1fcbf917d672b91208aca810230797a6afbf557fcdc805fa68b774d7fd27210754de05f623d215e923506f44c2554174a59461fc2bba056117f18c04f9b6bdba359f65434a6f5640bb118819b32bad9488fa54f053ad8b20738077464396b5376a6d65d28804bae6c602807fcf9b18d2e01b10a7a3e4975d2462f6b09bda6bdf44bb93f15b6a9f7d4261507b3b985a358494a0cf81631c14de7a96d97c7d35c1c3d0531045ef3f452b850f0d7631d6b015892b27d2d59cf3792ec35b364465c6a1c898f82bc5863729422bad3e526ffb28fa96216eeea615244d1a0c6289fc2215e6d3abce56c7526fd7ffd0f729745ce085a4e6ce925e1efe9665e9bfb0d5f604bb5f773aa70ae6ad59e0ff6b2d7ea4ba9f53738e65317cb7de4f97c685a5d07814a5b8be242f9a10c6304aa9ff9a4b6bbff2454c47fcec0d8448b4233bd65f7983b58bd5b7310c507d48ce9bcc96a07083afa487c67704aeefd71e0e3ed521f46f2328e3eae93e070e58ad8413ee808e9b0e8f9ccb9ea28d88cda27134d76f979f35fa1c97a3ea5e71290287d3e816876f85470dffeb3ffd39db117258a39af912705e391192b32f882761c0990d5e4143e7e0cc2c37b1ff92d436ad9911bf781cc6abeaa75f1536608b9c86f1d91014a99d4c1cce16545c7c1bf7213151a37ff52019dd9c25a171eece07c419eb4c885975ca154ac572d079b9a9ca031ff5c39eef33810ad8ce5963ab96b68cb181e285a6bf032cf93e1fe6725a42a01ac7651afe7c430a6112a27289fa1959fcd644cffa7ae303322901cc471b0b0da2e05be090cf9719114a02aeaaae250b0402463feaca4fc466b59b0c00d822699b34712e6309e5c25f5deb2467181f91c053abbf4c73dfb743380dc765510967eda42ab803e6739ff3132b25c43276fe95f8b3d986a92db07672621fb838407f3c2a4c7d0a00ac8fcc9651ddf818b83983720a61835261263e818dc66f6d8c7b80a800045a48af342b9ded2d7014d75c4e364f54f1df02022d95bf480f7acea51754b178eef44dc84a64c7c02128daa2457f51a96cac8201c84fe7a1fb153d23494fb07bdee78f3713a5ab694ef8fff1d02a17d482af548ceb05c393485425f7613b24d7c33d7757a2d384db747ee007093032d84d4e4aa5f84c0b487cfd9cedeef7458ce0ebe32555b60748bca9950b74c1a9783fed20df732426edea3b1a821391d008978fd3b129003690241449929a67096606384f5f47f82138941efe69f5cf6c15177675284f5cc5b0e8c300517756296358326dc3c22424b5e3f406aea9748acb72b6df6146aaa084d5b641206d38c7ac1442bfd2ffff1643ad0d97ce97a8db5c4043aed9f144c0ae3a7676c60976cdf5561b440089eb56034e809f4670a51480877604a2746a7f2fed4dcced5c53462991bf97c7a93dd120ccb4f70a3701de2baaa42c2a56883fc15c21144f2eedabb05716e0bfed18642c831c66778c23e7a2e0d98711500d026da058aba91328e304bddf3f9059bcab828e305a1465bd69cdfbd5516f204605f23fbb10662334cc695f915dbdc0b86499c9dfd0796d4708d09d73d1c94589d359cc710f486e739bb94b14f7b4d7da4ea878351cf3fc63c69c8c3828ba157fc737f64f0d98117cfe8ebda3cb5a86c286ab63bab6653297d3b3d35c869f58dc25fe8f529692daf47f90b199df99af6635b9b97ef72439e5507f7979f727dada8bfbad2a4a90a1374bc7993fcd2a9d815e89a9955e1f72f38097c5e4afb032425c73b09a300102c985000479fcd56c16be0e1ccbec65aa6a6bef17c18780eb185a05aed436d9033652c2823d08a8a6c41ea9de40587f9b1b7640257d37022399e4c3754ff3aca5904494b5e911b8c3529d16bf90ba905a7dc4de6064b879cc00361e04ab1c1546eca42b62a4795eaeee30524a725d6b2cbf819711af7a5884efd06803d5e2db519859f7905846696ea4a5f3b90a5a6678ffdb54a16d52c950313c1829d1dfff3e0bb5172c3d8f40e25654510fb661547d4ad658bb69ce9eb1d2087e2cc94307b9b2b85033417f6c30b82223d3a74a978e5c90bb3bb5470c74676a8c9380f08751cc0cf9744530d16c27d1ac898c33ab0e4f1508766a02eba84281a1d9741fef3082e524fd6e28b33e05050d8c0ad7ca6a45285fcfcdafdba23bcb1f2dc618e53f52ba7ae6309c786a1ada272a3facc51eeef54da01c8f47fcec901482af087577a6959f501fa2c2cbf9310c35271382b31e0699155ba867bf2ca6eff8ec5d24a0f6c7680033552d08200fb14f96019073ab2dc3ff7b61464b800e5f2b18cd864ef6f5f768f79f6241853f92e37b64364df60f5c508fce4f8ff876e7aacd1b6873985dd4df5c7c5863d0ed468c9f99e085520a173ae714809be70bfbf9e910eb99bd3008a043375ac34520a39b5786a7901a819f505963775238866814755ad080bea8f092e48dfa9e5f0eaad59c9a2cd85133dd116f297bb9cb78d111d158357fdcaee3bff93be82a64228c1e6bf4490a723c62e86b11049f57b617d4258d6d59cb5b7a351a47eda772930bb0c805020c0ff3df5b3f50126ea12f78b88d472da13cdc428891daaf9bf79c4ecd4a7b8f22947e8795d3fdc7816c4bf61e4afdd2897835a76d5f0b54ef3fcae0f72eff3d32d02a35dda636b684cfcc932b310d21e4aa1e6a0c2613f978031574554dbe886d3553b7568db06b8cf55ae9f06b90968584a6139f4c24b056b2cf5b95b911ea9af90242929e2bd35f1cf882408b5d34060c3b3886f5718f909826f94e7190713da70287060e2d22d930f60079ef8d3c78bf107c2dc94a485c20f189d78721d1cb4042dcacce4ae35556381d87d26299adfa89c270b6cd0b79f1546bd397067d7e318e0ba28801cf7c7137d377912062fb5a5a57775718c9ee57f508152b9fc56e297a5b6ed6bac7a794a4e580271636304157b1292442fe367a9971bd9bd82c81e32df16631d7cc9969eb92d621b3bdde2c104270572b47ee9ac2804551179afe0f978e8967033158dc1e3fa4c4dd65d5b423958c638067f53a667bad2a90b8467b9ace39a791897caffd62217e48f07d842639c33423131b6502300514d1140e063cec71e4378ac90e527b7204b16a4836a9ba0be5dca35bc8ff109e4a845bf0352f81adbf0584ab59b8dfec4b09e2e752ac478852c6e3a70081ed821149566913e04985057548247e15d767ee54e7c0a112c56ae791af86170f095fb1b276fcf15b2eedcb250d965d563e24f29eefe441ddc584d48225ac6387ac01d3fab6757752255408d1c53d7eed0ad22a0702954f6102eabbf697ab5bc2cfd6cd79e6c553df9d61e441e64a0cd4424cb42717253cd66506c42bacb3ca969beb632b1340f6f3df752af1c8729ffc032ca2b576eada8aa8640894d54417a1a406d5cd0d15e0414e39c42423d2fe3280bc9a0cf5ec3412d793738a016c8810923db9ef2fa0123142a0365d78a3082f036f19a0423d18624b6df76ebc2eda06d2c828413148fe325f231d982c37fc868f4d9564c67b6182a6f632f95859f66e43fe1de2b781cdd33ac0c0261b26d8854275f82f02411466620229dad25d419c6240a7f02f346d6b838161362cbdb192319dee302eb8eaf60993a194800d70162db4acbf0e8f5fedf0dd35c124f39a55caab258afb5e278d8f3a95cff148a9af50d48f33255bb8c6b3bbc0410d31258dd5027cbe18d60dd6716d9059517463bb485250518588ffc9965b6093616ca80ac270525a26e745bb1e77adef244d1366a1b785d30bd4286054bf0da8246c3be71047a7740f7df2b2a5b2eea55f942936da8a68367f7546833c0a4f04cbbb521a276dc6e99418f3138dbd3fbe8bae3eb2750d1ed9e28cc60b25b086ca711784368f51aed2835154b405c6eb306383084f97e65e5ce8abdc1ea72564f8455413cafbe4b8a911f0a90d338ca66e830ee0401ab7d86b92708e6ea77f91a1c1735cd04bd0137a3771fd43c1d7eeccd35b8f21be5c705473ddae4d25cec1b009564e038912e9dc55f63191e8a65ced8246ccb2e41e9887378882f8a9751d1c63b1359aa50502e24e19aebb3ea17ff4dd316c8b6e63b011f4b8b089a2d576f8a2e920ff2bf6716ac165bbb7b0fcacd9d358a32e8a28c07306de99d4eec15f2b5a299a3670d8f3c34f492b56297f74b4a7009a1992f0e44893aedbb0996734e96ecacb739be6fd9c373af48147fc87e17346a70d0ad8bcc85335da69f3d2af989326a88417f0624d6fda8db53cbed02723aa3c5465e1532f0a38c6044635fcb948043dc9bcaf21b89aa1da6d358be514663813aaef997e5d3673453734934e2ab287b08de233a8d72f13b51cfd0bc62755147de7c12f0e295cd3d4392f62a1d4d8d823a59af5575aec9514925ac0e4424ad181985f0e39c06143e1c95f719be59247243f416df36bc6da253b1a9b98891bcbfb17e64860ed64603e0ed92059a848dc11f78674c94428b57dd8a12eaedd1abebfce530d68e6e264336b2b26728d14f7e6f2d89c26e86c3a46b7be9c5582102620f3603c0ad712e5debc2c18efc1016ce6fc8055399273767df59ae454e2a4c2bfad0b4ebfbc0d82b9da3d9b897b1bfab16b7d0a667179d36214d123c5e5c7daff36c503f177cf76afb4839295acdea50f26e22883493a9235c050024dfef6dce4ffeb43b66ecdee7823610e6dbdbfb5660d97c78cb502ce993aa8a1e122f4e6f766b720a811b89354ad91fbea19d3af73dffee251c4088c6a54da763b972f1e62482ee2bb30eb5edc250ef9f040d4d3b17a114798ba8c4ee41dae41691ef989b0ff75de1150e834697702dbd372a61b658176473791ed42af1a6cc63abbe3a352465e18fa77721d30a52cf35c037267e30996d31e370436a1545d1464d2988f5982aefe357373f844c061a3d23dec576315710f9b96fa5d09c98595767e9ed1d6249ecfa77191ba1017bd24ba4c832247de6986f6730b8bb9d96da5378b1dc9ba1b95905338c17cad1501ef0c16a0605c62336d284cafe1d67ce50f1ee4dc5ad0f85aa47c0e371e7dd3d9f8ca8b703851ae11852e98533183fd27480018204b8b3cc4cc2de273af7f79cf8bd0bfd0c25ee2e65a19155f5727c196415657629db5cdbe81c6523c2d0c6cdc6f2b82828da8150ebe774f51d3cf29afa70c2d0a3f8133284249826f9bd93a6ce240399d0d5ace2a7db34299ab774a4ba53664e437e21e796f3d2c7f5d7d10a1f0e3f384296ef7ca3f83d436869ead91fbbec052dfe936b722e87447483acac737e2f5911adf1d009a285da17af063e2131899dc07748a14a1ff8dddf31c449ac116e1b4d1a673a5877ddf15e337465ebf49728518079830df3b79a6087f08b0c09cd6f32a08048e1554e10675f1f053282268abdca999177c99678bb687c2e30ff9ce137e6f759509c499364670748cb8a230b5b0215f3afe41e8a06cb00bf218217b003494d425b97e32c7ed1a4a7d8c1d89c050d3153c14bba0a1262d9854eae4c888ae5502a1a07a35d176f18b25ec5fbede7424491c69cf156402b4068720d8c735b73167f3ed124e64a81646275e90b38d75f5564ad10fc8af01e67f5404b7dc61ff276eedd21460bdc36a65e05cc58cd7ce0d7381e19c249048e278dddfc3567c0fdfc6386e116b425dbfa7cdf7db586d666899127ddcfea2ba28c9205226dbc45b493de877593a136accd8b91a55881268259a63d900561922faf9603fe849831592b1c218a70927136c6ecad32cc95da695aea67e269286e3f4af9dc382e8c4c404ee2c8d8a06f208f7e8efde6b60cb6b4be99d39774a7e8dbf6e7c739a7c0142a695d2d5b36e87b2c92cbbc965a82687c2e2a45ef58288edc0553a644c1bd9310aec7e1d170354f19b2b3d06c02aa74613a6ef0703304b584515fe00f7d5ce339df41e9bcb610efa4f26dac76c62f4de6439038537f48d5459f7fa61232bbd4042787411d644dc2b5ddbf8b6aae700dc8ef8099a960cda1301cfe5fef0f9eb81b861937f8bfb407f213053b859dff8fa4f68d5775b17aadff63a939ea705b1e1a33c03c7e688a6646ac285a0415c103164109733bf62c285d89254631fd05d7c7fbb141687555d38268160587ef9aa8c1aedb44fd36c069d4e02dd10c05ab21d672a1912d656348a58d850a87119cc7d08886e385d70c799484f6cfa5aaea57c82703a263e51a85113bae238c0c90f75138bebe1f40489116beb0e5ebb24a056a356fa6dd2a709f7fcdba135f30502d55090ecde61241d2ae24f8666d911a677a50cd6c51360f029c0b95af61f2e57bc827d9bb2b7998cbee286a824bdff3efdc01ddbc33e7473dc532881adb8be94d7bf8243ed507b4bc8426c80b32ca3550c7f09d1bd4676551412292d49afa97fd3890bde9c5716beef80afe3c10a90b4e31be073e320832fd295b61890eceda3a4ccd6d998f64eaf3a5cda00b932bac36b0cb3c24cf1feebdad81e86c05548f0a7bd6b1bd4b4812acca96ef782026ac4bcb176a116a666b2a363f2fa70c961adc73a6dd5db5f2c2bb9a98da8f5df46379a42f1a70c48f0ff0ea10fc470df27be7ef9482797f4f3be05a2c1d4c7cfccfb05be040a09028502560c685d0f7feee48fa06ce4d4dc170dd206e3e3c8856c9a68c2dc22a6d8eca5bdd6109bf4e97b175418ec2a05a2d3c3412f4af780f3badd83334d459c338719a3fe5d7cb8215843838d257846ae8d2610f70f50e0cf0d401256775dd97a1e924b14d20750f7c787adb969f311c340d6e743d13ea0784eba50531ae58895ab8f374579c8ce947c29c88731103ddb05bf63d8ef340cabdfd3a80b0877efb269adb0396af953354a4775ebe930c2dd0879b136aa20f9280a15717cabf61d0e798c662d01819ff7697af868854a31545ce7dae6831f58d7b8b0df613b56845aaba00032e116bda49d23a4331c5a2bd385df1d8440067117dfeacf3b233d4007af804b80dfd6a811e6529fd1fe0c1086eeeeee322d032adf220f608daa12d5d0218803f809a036806c29a1feae26d4cc956dc8ef8471d99de44281b0995a3a5feb31d788bad532c455af79b96bc3e0bd4abd05aaca261525b10b1cd8c82759851bff3c1342f7a722e669b29f299cb98b17475b127d75dd415fc3a67b24d79b8bb51442952ad5caa26d51f43a9cc05dd03db2faaae9b7a4414768543756e3a9d5a9ac71f94d6d6c88017d8e5d53398031a09b1d2ad928951ba33e74dfd42f25098a074a7a768ff463322f8c8c5b7c2f5839f6bdecf729a3228f62090632dbe0e107ea58c92469a9421f04851f6ea9d9d82b26dce72ffbb86145e7c60304705d359aed99df573e778c0b75a186b12fa51c06d25243e65605eb4188fbeee54ddf6c3a63978c37519f2ec575d4ffc40b7ce0d840a39a5c8f25352c1a09ed692b412c95851bf767784b4670d125b643c9f2b9bff092c8e97aca2504b3d280b8ffd9c9c85dcd64663ae20480996ab489bdefb6830624037e1d0bf3a146ec8a1ab77bed8fc69d621cc0871c483bc21c9bca876b3495c5e687387aeee7fae90bc48e2af6dfb5d482bda92ed6ab4e43c503baf8b43ec3383bca2088197a934b2a7cad53b93125159e774f383328ff7d3ea06870bbd998114fbbd3d184db120d69e9884eb9ab9928067b181870d40cfde2d2db394d22dc9a6f35503659be9c8fd275d7718aaeefef54802be1707e39d29329442f7743701224d17dcbcd0ef79f88b32d475304d93317eeb1cb0843e1b2504af7e8e08850cc73d4111fe31c59ea7c3039fff4f79ac4d899e2ba98652bf09c0037448bbd75c4671f1db701a1f895f9df44407e2a2db22e1096cd1c8ed90f028d7405a09194eb0559f9bd6ed06dc6d307af01b8936dcb2628cda98abbfb78708fe95040374d7f3e1381aacea424980520913f34ebce25e68b37df3039e7cf6a2dbd4c86fdb837e73c9206022a3f02b852ee61a1d5eb2d4cceb755ccdacb33fd9ed062e99391f5ea830a2909a93c229eee46b1a00433f7063067a50e4ac2369a4fa34129c85ace876faa4d2456af6cc4022b1bd45c99b542ae3a60df0cf90c7acbb941d25d2f5a600986be93ad83f08822d2de522a0a773829a28722fbea93b7c355e02406e85e2546985abd83d60896014d052c91fc5908c93a672af9d8aca241df372a54f58c3f3cf38d7a3c477d4a987704f50cf009cdffc4439637c899b672c4d56cbe8e04a9e27e87aba981ce69bf90a9bc7deefce1ee495328daf6d32522818707051ca96b89c00c561ca01149e55bdd7fff4640f3eadbeb5304ef483779f050867b0914e733472a96ef1e6682e8c0fa572c29d43c3eb012627aa0c596b4978dff811d2132738d5122aa4572053985fc6704867bca855fd3788b25179381088e983f7c03432ac8c6e8dd2360e2fd4ca426de17fc9731f9196d5fe130695be55bbe364ff82ba4bfb850693c37d04ae7396215b49e229f0fbae25c5d3d9031b66624b352c0a35500f9fb44aab562e09b217ac8491a76566323fd67a602f0dcfdfea898db347c9a2307ae0c4afd5aafde799f690444ef74f20b90d4d840c552a9362ea9163465b9132b97315a7443256d55db872b21c13b163bc05377fb402619f62b21b1220d63d3ca59ee318c74d3e3ef4b5bc7716ecb4b2ea49470463bcbe7b70ca9e64a1ccab93103ee8c2386d46d1f9d50f3d0723e93c1f6bd5d447e169f41f2a353bf4f2dee269716246fbea98a656d48b8b08fa9a8e6b9a2f8a350743ec3279bd7b7285d3019e143b2946e59f0736dac482613c4506a2c763ee6f0f1b1a0fca31ace7d972877132d4613f47dcf77f98db03dfa27ccf40d99f2f9c064b0cd356861525ae8137b3525eb34d50a235adbfedc6c615102f0b120cb24fc556069fb3135c627599cf5e1942f47055172c98275216e2ccf86622e5e720a710b10c63dadad0faa450ec12f0c1f950038bb55172ac36356e2b2319f1970aeba517e233e3646f93915b924ad47f35350dc12f810f856e7d57efc911d443f37279040c86d647fc85575774c67891bffe38ec682ca8af98da03d8fea8d0cbb2c710fcefdc7cf8ccf9966d3070a1c253a13e811bc81413736809eaedd8317e5ecb3b8e5c9f971a5533f05a9068395e8ca06edd4f782935613687191c754b4051c0807655c610064d19cb929b490849eeca02cbd1f78e7d82e9904c44192fbc232a64774a9432b6f9f8cbda0e919dd298a55bd0bdc3844242679b63a32fe8781b1496457b414e8266014ce51bd291b79c8ae03860a04cfbf7de9f28bd90643baa24ba0710eda2da9a510da1dca19f9371f4ad1c125f692ad40eeed3048e977f323e9924ab809d651e11a7090b5e7962afea868d16c9d6654082127789d97d2c32ae9190b38f57048a464e5a05e55b8771afe959f3512727e41749fc5955ab5da68916e8bbb707c12fd75c31bd936f6fb8b80961f5c0879a692d7a389850563a8a959a15f29a897e41fcff5fa79cae68d00aae3a57d580a9803118f9bef07f588c32494863e5990c066980ba8ba7b8eca2f2e3f2951ae5df6c75be1ad7f6fe2c56898bd7f71f6cf4b8d4778440690de71a51fb3522be2eee6589938cfc25efe7ee75d472b3fad38a81b8fbf3e1d07cf442ab1cb70d7b26215c17c467542117f2a25762762cc210758b1209f083f268a7e52fd3f11f950a4f58d44e5b3377ffabaa3367095753414f9e5baaf80a066eebdf2c4901a61f680c55673ce093d0171ebbb7e185f94ce5206d6c972fc85a8fbbd1d31b962336de79ec87b1eab70b1f916cc2af198bab593052960200c0b553c2b52e10fa728c5b509ebce0f775892f3286380ff2acf03eb2f67bc68d630beafe535397d2fffda1d6958f0ce138f349f563e7a6151d7160f70caca51efff38f2b6d2417d122ca478a1add3be4bf983ddf1d553783306f685b0811b4aecb332d157295a38d0c17eb0af8b6318e8de7c3fbcdad77c9e116f92093ae148c996d999b4c789da28201a07cd24407c785898b4563c0730ee6cb91eca3de42ff45a25bfca6040b480214a462b38408601fc71ec32d9ba0ce67b26aa26b162ebf05aac71820429ada8988cf56be7d029794d990b7d542911dda488e5dba9d5a0cc3b6008a8efeabdd97a462a4ef90175f72709457a82312e94fca58209b75287551f2a1c6fd972128e96ba76abfd7c74b5a2ef90fb3e870d10712c476c8d1d36b9d42200bf245b8bb1b0abc75645210fa81ab13c39dfe6c30daced8ea16076aa32039131888edc94f23e9ae1f52e5eab1f71ae634283747c754b6978e05318235556d6f0ba3380d4dadbee1af65fd19992167315e86b6609f6380c349d4d0ff65c378d681498cd41cbf13064b98a684f0c0078cd7cdd95021ea5bc772e3c5c5b3bc002e49945e5452700bbea5930e641e2dc69c50540fd1e964bb14678b376717f6907520ad59fd06a8e1f510e53c98d4aa7969f70a0943663863856c0293eb664987d7713183d6aaa9a0f66a3c8c0090d81bee8711bb25c080592b66423c2c8a3d0f462981b0eee37a060027f5c22f9ed5f91e38d172b2fa661bb144e5591f46b6a5977196b30512b021b68cc9a49e86dcc7c28b4d4351b1adf6bf94c5d06e0d474492db4a0c171f55f7cb71298d71d30eb885468b35e6b3c78ae39a94c91dc1c3ef9c8c3735040c02006ba79c7d57e968db04029b076449d36cd4f6e3c304d2a55b004933c2aa1bbbc538557dcff59a122a2e102afb2c4ada981e6b1eb7dd8e8c6825b2bb5fd2ce71a6b3797cbe459656751a9daccc747bb824f0c29099ddad89b8fbcd603a111571b435a8d6bea376910a477a753cd91e23138bf8f2ee533ef3d602bba102154baa0dc796bc9c56186b0c2717d258dc5006c7e3eb360a65bef0f0ce7012f0f481126a4edb64d0052fec92f1a31e148f5ea3cb2961dbc4f0bfd809a552c6495b130e476b85e864279c6f9f2b1c5321affcf0933094c6ae5943a36e1c8698bbe92c88c4d5620e2ae81b91851a32bc7c9d2277d96b06d621d3896f08d45181a54ac54473c646f24916c789c751839094fd071630c103b420899a0a9fd75d16690090cc7b98d8ecec386704a2676396ba18220c3ebada18b0d9fa3fd37bb64f6e0d176609f17cfa2a3b960f6ce38b1beb7ad3d5a384183ca8e4930cf92375bd62eaef8bc016d5823a1b8768409738d54edaaa958022db9372c800a2cb043da52290a383340c446bb031c0463fc0feb38b59a30ba2d7ca18b7173e88a51d913d15084e243d5b660fdc82d699108ec39b147950c7604a6f9e2d49f1a0c0a3998706c5a6fb7d8f8ff8e54fb42a29e05c641ce8fd587c4b72200dc57a5aeee64eb14687a6aa273a4d7d8e49a62cf596a7e09d67d926d973be5f94d7b4642551652300d2fceef51aa1da4b8a7aaf88ec816cc251d87ed005b5e7f81820f272ae303c57b3f7e65185c29cb95173170b28635620c0698aedb5da6ed2be87aa46ff845f34a472b4154098870c363e24dbb33704b4e349a26d6c7dac12a65d3e2d94408a18bce880ac52d3790a20f56348890f1cbf8f94039ea5fbb59b290cdfaa7e26ec2b506c77b79650e6973f9503483ad86a8ee8db6d010458a07c75b27030642429e2c17e0a2b9b7e8b833de2fbf029b2f983d5459d4f2e09bb0f322e4493754b30ed996d035b5fff7d06162434ae2b4226ad6e1309c734d32b035e13b32a5000767f35424ecb6d2bd913eda3ad05f665b347c8a5f235b5cea4d258318b3d4d4a5ffb4bdad2a793d10f7a46695c5f3241a3e9d2e9d66a7140657735455caf1618eee6d47c323fa82fc15d88b3cc1fbd052a92d478f31d56811d4fee9028a73602ae7f1557c01ce2e2c13578305d56b678356febdbc04623833f3bdb0a06bca8a7f7667c658f05a3b1d3dbdf1392c88d3bd3292644551b81ca21d61da3f74d9fb4957c4d32b4c1f85cebecb202d6557bd827807ac64eca4b10c89a58eb124c98268cf64f3fe691340fbba434a20aa7e0d75a8ac3a0b673ba8c81ec5dfe60d838c85c9851d48b8c9762b096013d5351b0d14057d0ccc7d02242bdb04c2c9ac537ddd244214ad84fa509bbbc279b78562cc2fe3097ce00fdc9a165116f55e7e9a8b4a06580579ff139e1a722ae1b2d5c42ed1bf4c3535ba9fa3ab425da125ec90f9947ebcb0a0f140dc37294f9d382c94ab5d74fb1b3c50b44058d1f5b71a5b0828df7676641e2db951cef906ae6e525ab9eda5fddb72519fcf80534304927081a293567068a9d6390d3ebffa1180eb7c7960cde43f96c512933b3622a34a6750e85a40500ed588942265c554df622fa55fa86692c77f3cb9d86142b58aa75091bc576a7df3079cc3c179e4d344f036c88994d32c5e82f66c750bdbf68c31e4659403f0b2a6ee0c1b0c893f652e83fe1d55aebee5c0938fdaf45a131483d84a4d66738651cf4a0342964cd7395305dc5330021939feed65804780589a2ce49cef4db66a0103a157eb408ddebeffda5e1b32502cb9d748ea8b30b4894c154984ae7145bbeec8d127ac0862e41a81bf01693ac8644ea4752f2d0546873fc2495946af9b37a3c22484ecfb7ae0c5a3a8a1557760d5c6df8f3c7c118196981a50bdca899ce5180f46b483617fc745195b97180d71489e45c006256095edeec0e2253e59d7265d4bddb11651f35eebcb6753f07bfee6f8869ee9cf308f51c8713a2ddc2fdc12739460aefd2729e9f6ab1b56e5994630f80a71f29e44eed20c6450e530c777b9d992a84385e5e115912e5580d81797d629d5f7f8472488aa7ee4f51fa3fa1ccc36c602345e0e98f9b37f3c39b33480a6f4f9dc170e50923a63dcbb77483cf8420412f52695e3139b80815e399961505562d799f9276632f0e28274198a41989fbc00ab3f98e85c10084ea04bd28e941679dd9bc5ef519decf1f43ab7beebe1911cdfd441a23c79ad6c4e78b9996e8e067b6cbec9c03987167732ece4e8c77121d7c936ea8a2ed35775e635c4ae754c7caf35eae9ce766bc7003439b03b05a5b3cde9071b429eefccfa9475bab71732a01b28ec34542957448edb2eceaf41f8e66b8c6fba08c8ed7c3ce8c2119ed1c1ce02161347fe77e1e75cbf6c299af0b5ba08177536798939f75d9172dc1d0846e57638945989dbdd7b8eff0e730dada7a963be4426c54e01014f79be1273c4cbd9542ed5850d6aee3675f5354d2370073cf342dae6c94d1c9f938fbd09e6fd506b708a7ceae17e87ff7357ac45519bf7b0a2923b7d449a2644099cb5f9881852c398f5c39d2882729549e507658092d0f11c5a72c51d15b252da3ebdc171eb0e71cb6248eb1818175108b4c1c7440faf7f92f2860bbf4ca74babfaa1aec1823b3c58bb3a36dbf86598de7a27fdc94f419696507be42fafa147c39b177fc8fbc76917e9821adacc55728d70e65560901a3bb8fa301b267d05a145797ce7b93308ad80c41f970f23eae9541bac6482d7853a14d890379e8af4e268103a4693aeafe88dbecd2638ea16f36b0ead6ce0ec945dcabd6fe9a3ffcecd0d038b6a1314af3b5ab6051c94060a590a2c13278f5149bd766d64616a5beda70e66de03776abf75595ec891b020299123807641947ce50d8949f3c0a79d31d6320113096bfa7d041c2376770edd3a0ce7b7484023284fed149fdd0f11cd821b505a69f3cfa9cab229723fc9a5ea4c9f8070d5cc3ed12328c801b367a2003a86352fd61413028d82de9971d42543340c32e2ebd0726c27e87e36599ba96a4c7ed10f26fc1910ee61e6a0d2eef0d2e85169f9233201835c34d2c44b9f4dc9ffe9e468993137111712e654dd559f3a847128921e5747f67be1aa3d31234ef3aba7e4986077203d394204596cc03043e65016f44ce84a0d590b4701dcf80e8aee7662f50b2e8c45bdda26bdaa0de5f0d0aadd565a5a654c20cb579f26f36f4ab473a9c0ec0416ff9cae85326a824c9146686ff916efff321bd6423b1b9d6fdce62497d32df826e7fb04e1a4a39573b77bea301b8559b3911ec5209d88dc745234efec40581c43df22212622ebedcd79f0cb58f69db73d5e59fe8a639d9208f83e6d9afc71011f65909214e7e8bc09e23a9ba79361325d8c25c073ab96e805089be4fc4a47025445cf2f9b27bfd844ceba599c72ea218ac1d79758f1d60e00ec7a4655af4e2a7f154b7448338129559861d1d6ec8fc081a83a5fe6da9bcdfa0c29d34c0b9095c809fdc30205aa64d6067876f5098824deec6463bed14c28781480c5f8ce49acc9642fa73e324c09b4b9b572d5dc8666103b027e34f119d7a4a2a5975f71555c056285e2e79bbdf9e2379a78da1198642370db170cbf33ad39926a281c2f27a7bc535cc5f5f5d6f8775c29490ac299bb83b803818f8df095d36000ae143c25621f30778e253375706ccfa60b23f8c1ddf16296275cbe61d4e1eaef4b78ee4e34f92855202a6c09a4e1719525fa8e3dbf381fcb7b741c962eb12e2c6a866631da0d8d62026a13642f6b61f9ae0848cdbed0fdb87707bce12a7279126470360acba8ef1429ffaee6042020cd0d8576d9722a6f097324b7a612f26dc98650c4868e321a83213e6fa7eae9866ea4518332055360038512337792ba99d548a587a2a9272b3a263ea1d61974a5934e37a2adf9fafe19396ad96570f7fed71553b6c9e1454cf970a456ce0dabe59bf447833ffb6de7cf12068e62c0c62c62656b32fb564e9cf314782f92c80a29aeeba07f8fa02032ee32cf571762bf04dad678ed537fc2fe5fe19dfcb8904ecdbac407e428d501b63cdcaf2488f3ac1ad6f6f301a06769bc2be6d8060e20319db0afe71051244d67f00d08e2531f7e47599282ac107856cf6e093723c9191135e6c979ede4be2d21240103045f48885c12d0a4bf56cdca82d47c6672660b19fef56b9d3ef1b235e79a21e58b825ed02ae1df8e85b2b068ab27a1fb0805e13591091808c4ccb530933b289f18f5768edc8d67799b0a2d71c5b015288405afb8d928c0755a5eaab313b961ada98aabd85c313f366cc3ae7af3e65f3e050908c915075e98a359cb5a69f9cf126105fbd4946c73111936c5002ea52daf1b7edaacda6f1491a8f1fa02a6adedbb48fbefab02997dc43ed02743b6521bdaf562002820ae46bedf264be7fe07c75b799e1b81505cc45ffffeae8f40899630c424abf6d722bce03046014854ebca8f7b6fcd2d9db1895a02a7e6cf1a2c0e654c51237ce3ca78cc376feb789bb31f360f6093dd186d194fee21b178a6e1172f9a4760f108b7de7a095f084c7106b2a60fd86c39abb985ecb73a08c6ff5702ad7a424f26fd7dd413fee2102ce8caccc55783fdb06efdc74164047c41c57fbe0db3a63e41c59669ea3ca016bb993e4a95fc60759f181766261e1850608312947518755395df3de8d342cb3fccf613b8d88aad3c812e665d6eac308ae024167218c0e3b608247daa5195cc3d10f5453716304ac835dc5369766fcc63c6fff5cf847e2afd851d02ad9b1241b617051c592280caec4a02aefe358b7b5887efd6da541208e50d138507f3b0722543f55e6016b862e69cf4e0472a545098b3305977f38187d822986e2789d6923ed0da5d26ef0410525b13327bc3ce9579e1b204843f1ac19b516e3d7da1a2b3b58cbcf46f167352d37895c248ee310b3f8f4b652fe86c9b3dd77228f7b8e24a452a74bfc6411ac91f96fd1b20d85d66b62b5cc0f95e31e6a8d5f84b3c8f7b04153670539184c17e22b29ede4556cfe82ef14aae6731d58c635bf7cef2e14df8bb8b2646cfd14552e7d2562d3a76a5e89394f791114c69f7bf950517ff9876a3793dac93446f9161a10e914e8512c6fa01bbeb63880f7fc8863c3f64a6f5fc70130c96a2e74d70b40f6a1f047d1dd8e354fd31cd4ee3e768803b2feffbf1af7ef5d64d1e317ee6ab25c2259e5c6db70e85b05931472b9399c9c12e712407627f41a00367ae967a2af7bbeb126e370631d34ef1ff7ffdf3cbe00cafd28c019bca8f4aed5a075032c76696d69117926b68267e6426784cfb2f1b0779d5d43803b736f6abfbb5afa42c43621d1ad7e0c72b5ddced6fb62e0454f1e6706b4dd5a37be8cffa1b68db2130a6d567eb80a036e37fd0813a69e04d58518aac6cf18f41ccb5cdc03e17a4c21cf7f03c2a143c01004b0cb516ac6af0c305b2df13e5e98ecb527e466cd539253852bbda3fb652776277bb20d564d055f20915089391721278a09ae6a4941d8a4b86ef8653edde92ba97085d9b8ce2eb1c2828a6e81de5b7073ffe25f0468246660a2a09bc861edd4a44ebb18755a758e9db41f73356a022d3a878122d35426ea7751fc6d19e4aaabb56412beca8b7eada17369c3487b2284f79dd7fbab8e510929c70a5fbdc771957c3133f89fdb2782871eb967cebd0e9caac21d5a079eef1c75c8c4b267d63f8991aea89fc5c8a62e6d070a590f98aa49011fa02bdc1ddf5f9d8943d76ce4eaa8cb1b52a81429484c37f24f2255617c5d188de639cd940a3cfdab467835d473908827863ed5694225fec503ad202368fd98a8d49d574b3f38565b9de3f57fa03eab7a2d479791b4fe273b13e094ac26cd19974198039e717aa8af793d2c48add33044abe26cd013d8cce4fb7404131d12702efaa81be5ec334dbc791434f5781b130a370f77df7ade6c17bd14493c9fcc7835e6e7eb321ac6e71a82374f8f3f84c08ce6c33c20b497d2de3bf4e51a6d416657252db5e6aa2ecb1b972c2739f731998535997354aed71b8e709dfa1461466637c37a3de999e8af5daea2449c75175035e1c25bf506dec9a732c4a0711531104dca32f52582d318a0b3608c6f49bd6dd4592ed05db51dfd7b5cdc9ff378d02075cdaa26bdeaa417ed4fed325bab8556f06efb23da791157fbc8ed0b87bf77c9f9f6413e1d44eab99541b20afd85456b4762a1eab88f967817f4744426d7a7b13ca1f104f6b7eb9c1ea037b4958d87089392d7bbf1d04240aa8b6142e1d765374a98c9339bf7e1438f4a540e7b786647bd523456146bdbd6d09c59005c91513780a8aaf81ea660773033ecea01cee39b4374f4f9ca68d55c95ba15ccb300bddcfddceeb5a24a3fe8f6fad29c6d44d35f3ab363e0710aed7fc433ec5083f009af263ec25ac184d60a4f0f628c6833e4c25c73845ef8eb12b9b4b9d0f44323e0e86858673055272b21c871becababfd110ef0f61a33110d27c0c606930c6fc260fe2f3cc2f0eaf29eb23cbd7d7513bb994593acd5624cdb76a5fe88569e48e5748df79a95a9707a2bfcd8ecc1b06b4e4e585d5cc2508d93834d99ff97a2f309c15067214517e4166f171ce4d5454e0bdd13b6bf395de5a12f989da51dbe00a9373fe1896befe2d01ea41492c9ab811b07afcd6b756c5d0148356b544d9730024a8e6bcedbea8a6a6386244818c98ce5622fde1f47fa89c07e77a6d868d134beec7ef808a9ea1df4d6a3e4adedf0ff77a994dd293bb1414be88e19dde40a2fc83e458dcbc0ef7647a25d289c7e4699c463ff17e062edf49b3d745e2640eb366e65526f8a0512139601f762734c46f15f306e74aa1ca82941ec8e78be1830bb530aef3782b4de05545c526bea614752a7cca240123c2e051b7abc8426fa55a31cf27c50accfdbc81ff42ea350a291e8219833b92621dfc87fbef2125c40c5a11612134ea9be0874a3fcddd9649d43b0e5e1dc03bcd7c88e1f9fb1c20a2abd76be63e8b5bf54863e8cb09f7ff90e522dd8ca7a185849ae352b653759452bd4660ecae5d3be9560abdbf7e1245361c29d14ac5599d9ebd789184dbff2443f0b4757cf5389bf5313343060a227b19cd45e8dda76d0d22aa2b79fad46719e7c9c274ec1674caf7e5fed42a8d8495bdeb0bbb40cb40047fcd2f84443fcfb13b6ae5a1f5f3011abd996cfa0646be023f2de7d7335e9becff8d47f5a747e4ea36b33a73025577b8a21fdafd8249fef9dc11b5432c4fa9dcb0e9708a228be1ecea8cce6495f1d9b9cee85c288ed706f840fbfe6edd7d1cddb4ec0809b944ace5f55b384f4c0813c179a15bd0f73fb72a1a8616faf9bdc0ea7764821c49789a2489690e4cddefb354b748b98a7fd3022137a0b2255e6bef17874fff75e1bab5d65be16f832af36f0a8a95c2041ac0b0c813a92379cfdb4c459be384ca54d47cdf0a517564ad6cdeabddb139ed2bb0bcc649d26d56d42c977dc7f663527a2342285941783f914c51739b7d4733a693c6c9762e6c3f728f43ac33676f3ccc4c0844e238d66175a9c50f62d72586d5383ade68aba0709cbbfffd7375019ce406464a85bc1d890def1526bedf129fdd51161500eceb07855e59bfa18bedb7b469b05b8b1d3fd2631075ca304de61f430585ff18226e692f73b4e761f73f52bda3b211c3d103abba152f1a5bed3d177716791e31352d5ade6789e4676573c567de725db9d22f082d9f28b94b8f9e0cb4dea83496bac010f5589f428d050e3088772780408835ccddb9019112312cb2ff90a68afb5352d08f43798fc594fbdb19347fe2d5b32e433a17460c617ca1ddf89d5d5cd88e18bfdba02cadff6bba1cb27557aaa8ff05129432177a776e0c3ddb1131f987da7cbe6d07ccac5f7a8ea2962ecdf60ff7081175cab2540dc7bf9054ce24a05bdab28c715191aa914532e214d34d69a4ecfb7656c4e54889cc5d2d88f6a409ff2b1d1503aa8656be88d4d6568ebbf8ca07af7d4f417089b59473f967783ebbccd362869232ab3eb1bd279aa8b1e1c5b43164bc5e27c76b71ed8c6607f456b3c46a9a5705d8161d35571e1f397826bbc7c6988f74793c5da58aa62aa2f8beb57dbe65b8e23a3083fcb10a06fe94f0b26b5c5ef860aeddca6dce0593c16bda183f953b8560033d16d553b62f14df55df82c534bb6f752272cabbf1be4e2574f226ac73914cf1dafa2d96464a822cc0bd095eb8ea357fb89ad9dcdd538f6ec80864e42699a9fdc85174c897b008d8f942ddc1e5c66cd66b7a9b8a9472e2a907d746f37469e7a91a5654e36ab1fbf92962cbb632b40cadecd7d71e1a9ebf6563d44b5132152fae8b3e1a078e2fc872e501b432bb6f3192ce93e43c5e0d7ca26fd578a372e2b3418d2f3394210866e800422e695d6911af5c3465720cb684dfc246c4063882e14658215bb01a071b6400b0acaaeddc11b96c583be0249188f2ce33abdd32c9270869a9e2012f38faf3baebd08a2519ab2e3ed1676ea8fc70128818681e1d69e2437de7f6c85559366ecc5da282f7d639d2f0993d33d49353099ec36a6057068c3c9e752c2287651503a00203afa642cebf3562bf84bb656235cfdb30a65b4dc004132076f6ae5355f5e478b4b428e354310d270148a614814dbb870a2501f3a57533a589cf1a4535f2c4f0ec69d16718a2e6991adf67b9ba96458626eb77ea1dcf0355d6bbf08c33a0838e6a7bc06df1bcad8d13331ab84588a4f2d2c97dc4d20ad72721e9e55733631bc9b27fb0a5d13386016f5212196417329e5b335180c842adf369ac47218a48cfc69bfb125d423466c775e68106f699889f1f93a6192cb3a368c8795872a5a0e24120c9ba05da25aaa7e4df576549a1eb1e3cc5ac3856124ebd705a718affe25aaea1a8bc6476a8f93b7a89da5446f43d0ebe304be50d72e555dead11b50c358597ccc1622b403fcf5e20fe5a5c82cd8807fe4112b71c975ae589e095a77ade1a950b7296915403ae19917bb407a97f206b9ba27d5d41f4202a78dff82dd55eb9519be841c91cdfdb76864e504fd3f3319a6dd8915565681f43501c63f300be921759ccb6eb96d5bf049a7013f0d1fad1570f9ff280da5e0b288515ec0a7bee10f95a4c7dcb2305ee5065b416fefc642165b1ccd043f3beea1511df3892dafe3429a77799fe7c0e9e154f7beb24a540dcaaea46652ee3c90639b796c869343e91b83d79bbc2c6fd02cb86ed12095ad868c7ced044eb8ccf313499b8913605b3687ff75b6b5dde2dd19d2a9ed75012c52105bf92c3061d01a707b9af383b94f99f65ce7bd6ea08c5a7cbbe19c786aa31e587fdd55d563d23bb525f1161ccc728f2c76d84744cd6af6f7f8a72d713ca49a9af2cdce7d32bc1865b4d0c99b20e98f033a14265a4f9b236efcce8edd833dd24aaa8bbc83af80b83e5182e5f4f46b67152725fc91e9a472bb33450baa37dfcbbfc7a9feda229c84e6727ee68504b0b9daab45fc7dc23a99be7c74ba78dac73a8a9b944b1d1778f8e04486ec3602ee0c8c65decead947158fd345b24ea654b6132c23ac51aee75223ee19cef5d8d1df215629659e2b1dd84117bdbb8b3195e0c338cb5080cde32483a1a6b13f57954d0bd494872d98017032bb96215023f3ccc9ddb4d7fa1a52ed34de29a315e65500e7abac6190dbe5fbbe01467832214d9314e84cc81d927528c19bd1583a344f72ee3d1b2c787c1c5b4c9e75f163a047759d9edcb436f3169f228995049e6888cef4cecc973a18edbfd1c298797549671820b9c9d0c20f832f7d724eca3e7a121f13757ffa24bb7065d3cc3e47a7ef043292764e03ef9b3470e295d77e23d19e12dfdbf9fb9fce833ef87479a460a45871f448b2b9f46fc242de861a4d6d0078c369165d16d08beb0dc7033b31633e9589322dc284b3cf44e9d2e2ed4e0ff9a8ce533313cef8c7f3b9fff34288653d850ea26d3c5f12a1261788b8ced78c2afe87383b0d2dd53af9cc9452dafec60c338149c0151e87de3c1bc7d9a9b9bf0ade4bdbd1abb9710df9381d8cbd289ee281868e411550a3f6a52e4432482c22aaa5c93cdfcaef4f9222718982cc1d767cf0a683fe09490288edd9db7227520a51f6f328a4c0244c0c1cce2e232fac83855806a9baa2545d053ca26167a3658b9e1641ba953f6c930f974996a63fe8d5298db77b283b552072189433f35ed8b47404aa24de467ce7bcc23dcc63b5755810797ff2a99f26087badf1fc378581e7dbfa85d5b9580ad5b376255301842b4602ffe6d688b40e29d6dbb7fb7fb4cbd9b43f5bc82e4aca115effddc3f7795efc457849db585f709c2f1b07a96d1ca10614487577be556f16d3b04d600fa5f14003d66d2ad81ad225ea1ad150c2e1e662c5aba95fce2f183dfb8a1d79f054cf6683ca20c5124c6cd812fb07a1be642a4a54dfe5e8a0778c6c3f8567a981b08b7f91b1899effa6ea3d7cfca31ba5571625937a42486aab52af0e0f18a728e0599af93dc49e980a62118dc20732fb70442d72357b0d52ffdc235b3240b7456d227292005fcfa9e85f5de0e515718037b5ba7799132fd58274308e7bdde824e5764fdbbab6b06e046087ecd39ae4ba196dea0153adfef7a166cb03346d74af7eaec4188d1751240035e722b8f9fc5e96804eb75380a46f1693dc957ffb252951f06c54f463c3a7371a1e8bf986c01584e71103e7f9a5a062e2b3d30bb262d63e5f02a067b295d11ad3f1f0154f63b98725d4c3f8396c6a13935a8adbd1e3bf785da66db5fa9fe20dd5b9ac45643c0230165be9318967cb1dfbf953d0cd8086a22d59905c80d02693e5fdd58475be8f1cf8c770d6a911c0b609e25e7dd8bef790665fea87d175292cc0ac1b4ac50b2fb6d9b8a67c98681714c12c654d71702afe046f98626dc5baa7d5eea78db086071c66d43b96912a760ace5368aef5f77be488e243b4d97fd793da15089f1fc330b8a82e32f24e7217c612f5c0c77e4c4c41486f2ba8c44eb6fe2619fa6dd884a92475a82680f9217c0b4e70fb0dae4662cd699e24404dc0237968b2c563b0de550a57955245dc709af2dc97b1e8d6b734b9629604d3b1964007097fdd4d61049bf831f0fb174040fd16cb884a3fe5c1b822d62d17946a09c536da60b45b14449358fed740b6f16472d43954570beceea9cae334d41ac7d93e61324a5d333c8c264051c722e6eec8feb80a607b591db77928d2329b9dfbb9161f901e32cebb7c426daf75d1ee3df7e2aa36ec4f10699e1a04f07c002dbd95d65fd82d5fdad667801c1097361b3c6df0f65188ed0ec597f78e39789a85a31d2393d8e7b43393c545ecb577ba23987f5d612678a95f9c89d97d77cdd20be9fea5f417d789cfe0004bf483a18d34cb5e5cca321cf8c269e2355785305cef194ff15006a5494ec1bc4fbaeebb38395ae66418262c263d8ab5949a8f6c095783abd172fde389a00695bd713c284b4afaf45e2a64a70b47fb8dab22de45851d602959d91f41148a482cb2cef3c62b45a996e279295cc6579323d9c7ee9ac32104a5e73be98c4268e80e05f886832dfb41eb6e70538da5b0bff7f84ebef6a7fe0314e9a3577580c8e410da6150b0f79d0f07f6a40aabc223eafa7c875de1cbd63ea5680171ce4c6695950b17c3fa498605fb319d8d6bc7c868a3baf987bafdcdf9a4e1b014e15eedf9ec3113d82a3a098dbf2855aca2c60f67823a35d4840b223526597d38114a1da340f00cd53161a29e2f8b3cc27a8250106816470c81dc15baba97fea9c3ca9ff100765a405b5418acf109b403fcc069d1b52aee20fd064961cff4f26a7a85fe1fcaaa5a5d10699637fc9e554e3039c0ea258f1d0abc7eddad2857394ead15444eaa5af25f62e269341b97655b4d85ccbf1722dcb04bb6bd6a858d255ce32e9143f46b3ed5a8a593b7309e349779673f5211a2bc5a7a7f810b2bdaf58e998d46aa3b9f5303c9516348789253f1923029b86a9be8616f4f305e70973416e109a2a21ce20e7ad5eae08e95126e749056a838175f83886e135bea2f06ccb34758a05fcf1d141a19e15437f50f0ce7557ceae8e082363e09cb6a2a93179201a601f1515d448e4bcc4863287964163fe25f9f48410b3bee85e6b5b2f6f811d437a2800204116f4fbe0e3b7a501c96f139141f0d40c72986730ed9ea1d1bb0b3bcfa72ae5bc17dec769e9359f0079748369a8f4100d6cb4f0520b0dd7acba969655fb1dbd25114ad088c173868aa998a6840cc6058c2780c3448a8878f3e183468a9d09d3ca3b9c8bb54f39a75ec093560479d40f3fd7af004e4e5eb7770f8eb6cac729567e3bf1a8df775ace81c0c90696fef628730ec974e6ee5c73b93307efa4f1b29e34e7d53898dc7c5c20d70d94b2d14d635b7b35abc7821a9696530d2c1151fee152b4708dcde21dd3b98da0e55dc436c17befe08626ca9d67d083e1e6acac4eb3e7ebc797e2a563cd19804b22d9f515a66b521ae121077b97e6227c602707afcaf93037820e416ae1edc30158631cd7122d543c9ffb335ddef3d669e37bdbacc79e9405d126d5b500811e8c75a34e236b18852dcbddc9045fe00db513028e4190cd93713e65768aa64aa253dd7240608027e0c1cdc3f076c61f074434929036bd476c0602362380b52190b0612b16933389e3752d2e403474cd15679c273b6421bac04ad2fdc81cb3cd5c3bb8660bc372dfb6826f3821fcbf800b2ecc2f94fd601c4c1b67ea8db3dfd2291dcb1ea93d46d949e5c3f9c70dd2ca0526c7a669161878a7110af096a75c811cdf5d38fd5d4e838c0aa186be84ea669843f3b04439586cb176c8aeb086999117833e670ea5dc4ada3588e541c9d909ae991ebfd78b86ca731dabcd87c478ba232510324dc9b2c1b19bde31a02bc0323eb1983bfba01548f8cf69d8e710a1db3d7b5729454291de941019b51de77d749ef52a07f04d3675ab52e09b49876507ad8d1b9d3a393e2df8074ab09293c9a03cd96b676a28bd4babc0da315eb53f37cca7df256af1611269c8c8ee9e1f88ced887c3b505afae333afbe4bd25d51bf79edee4acecebf4a43a47d674474c1df77f15e0ac3c2266f55c16271ab7c504f63735d834c597e60b6d3877470c067e615b7de2b6d33396f5b0d78ad363ea996ed45d87dd99229e8f6589f9a3dea807d238f486e6ce8f6e46bd82de1abeecb30815cfaf69c36809442272285497932e0a9fe5443bade2262139ceeb6345bcbf478bf0cbf901521dae09364a58b8d17c544819680f27c89411939b9dbeeddf9b7999b2025302a1c3f1e82f01b44e2c42f3f37c9a71891c35933b70416cc39b7399214575589111806e1c92c100db08bb1435427b17487cb49864bd75b975cedac65758b018d5ff777d657e480c8af4377dbabae7a43b07bb34c1e95b8c331f7d524410eb4b6ba1e3558551cfa625d1bb47bffccd51cb387337fbc1c96ef4825de446c79094ae33667ff142c1623028a35fa89663d44e13d0ea7a39f9c9d334f59a4fce91c24f60b2f053a143a258b2b49881f3f7b685c5a3324f57a81820ece8a059d851c7a0503ad88d9b8e69e2b0625174124f7c505b07fca25db29beaefae1ad4c193387381086c7dcd25d89062f224e827ff694867b60c797d6e81b35554ce41289b62d17dd50f0470e664658d35e56c9ef7dff84a337adf6f6a30644b0eee840d4bc11a7cc970414aee201a795fab7c4a4fd5fe3d7cf132144a957d5215dc0f52aa473a013e64f197f60076b127d0585d0e4c9c74b64ed870a86adbeab78e8dd8d612bf5c5300c006f013657a9b3c770860a72c056a2364ad04e64bf2eab7185b14dbb51d3c6be7c1e181d71402f80914fe50a6619ff87d6b997b6b6488a909ec32e9a915110acd996ded9fb298300036e6f66e6db9f005aa4697e57f5fb6f10f25be7c87004e67543509c596d23217dbdc631c2df46d80e36562cbba1da031b29585dbe0ae0a7ea536a495c92c7c1c06a79986846afeb178de1beaced649d0557780d3f801d0259e8058ca5a1c7652899e8810df3956c1c0ec642b5ae0691506bfef17a599e2d17fccd95ba1cdb4eeff7efcc843b9ec068d29b957ba1c47f193037b69080997e498220b41c9ce831fa415431f05988761fd3b0beed01a8e1e2c889afb6d0ce290dc0e432e6cc2024aac80ba6f599dfca3c47e76ede06fd1816539dd00b8e96821eefb9a9383f8e13156a7a65d8e0f8ca7a5b10df48de9289760c3e6d6f6564305e00089d023cf6be0959e41570e386860afb1e72963339768c2e3f869774868e957946266edadddcc7a23c7927cf1d221e6016d24c245b77b291e58080f1bcc7aa64e1cd523aef5fe2adc6697a67520197ad8287a2809af32e603540fc1cdb44475c5f721df8d787a9bf77cd81a41857c166ebe2f66a6746275e411ad8909104cf93e1d994fc4099927d4a633bc375378e552539807272afcd19093d9a88508f275c8cf8ea262301276f41faf8379b815e46145804ecf328bb5dc864ab0c55db3f7eaaca9c45e9111c4e3cad5a520a94cd5dcc127466eac085120b0096d418bf81eb1d174c6ba8fee7dd9195f96b204621a92b191f852de28cf00ce233604bbd999ae992f6c79dc80a9d70e0e7df0e89bcd3ca77b3acd5359bf08e1eb5b6df7f349e17d842bc75feaac301c40db56d7cc5dc6bd7542e4a32c1377942e7f68f91759ea4cf3525159683d20ceeee0a4581b311ad6f99f0d9750058eb84cabebff7bb99d93dd40e14d0780d79f5bedfe5ff6233189d4bbb2abcac1fbd86d329dcbae365703ef6d855c56bf2c5cb460f56e487e81706d0c5216664d3d4f549d56728532f63f051fccf88492bf4e73658a1ba8b41d097c3a799a4ce6ee356c5870a514fbdb98e0c5ec20c704e0538a1a6516824a81b54f6b2b2414304d4a10999948fbca3f6bf315d34b4443e48763a9b39d38c0f2214c52b47950f5be75f2d5d3be11d0bce9ece7a30cb9052b0cc760cfc86537f3dcd2edb063b14ac8b175fb1adb35c5a13c5bef49725c965d79549ddbd2c0a2ebd783ae08489712f5aec0932dfd52dadad379980da6cef6d9361c40eedaaaf087e73dda606dc615e94ffefae9665f052d083059a5e3b8ddf7ec04f08f993bd8b5cac715aca27d15c4e65d15662129992baf89dd11865839d8860154cabd38b9db31653be4b4c2978771977a9c4131cecf5c183636024a89f60e186108675e6849e9e22ec44f8f2c949cc4542bc372d50672569bcbc93c47e0c3f7e3a2fc7a25f013e3133648133e760be93eb5856be3c2fb9f4fb8119efde54a948a2bcb49145451aced90528ceca2e51844fee5cdb47c94124d579ee457893a9b3e780ebdd7ab4d1d4fe4bc256f1a7c13935a097a1860ae8cd557e043ad76525e17253beb298fd3277b2f84ad933d679c0e6c7cb62e5328a9700090dd222a2b6ba55928507d6a2facd099920b8537f5ee1e83dce5fb69e938ec7d017b98ba88d6e6e5e87ad11f572b9ac1da16498814930532d0ac28a7b84db6a433267e580fecbad5a63f579a1d2cc9407afa773f3d7ce3cbce9d9c8081ad6f5732dd19729889fea08910b21bde2234271ef185502243d645f0f339f411f8dbe0e8a3a9b7b09fa12ac92a45b2f88b295449c3d690b356ed0f836be96f61b5d0efb0fb91226ac24fa9a115aa09dd30a0fdd04190a565cf88f6149f031a5d991e960d2cebf4e38980c2b1e39ba106b2394faa8071ad352c96ff7532c5754f0a27a9b5558d7a0521bde2331ae0569dacc404d18334df40f4927d209d5cbafa095df9a59d3ce5bb3b5b2b67fd2de4476fcbba87ac54efb5929b8a18a3f49a96fa0df3729f452cb18aab688d9dfae673bf287267902cfebdeac361ccf7e5fb6a147f4de3d3d0c8336330f20b05af6e8e651a3dce683621b43ca32490de52b6c30bdbcf4f3cf051af4faa8f433115f414abc0cf40d25a2480ae2c7d08fdf67487bfd3ad838bc4e308434df664b7bd49ecb9dae84c3a52f6ff0959f3c2b78a4857b5db8c54ece90cc42e2b59f9eef544e6a2b06e33b3dd9dfc54ed5559fd99da038260487756a47308fa6a906df5cfc435410e22254d6acc776758e036be430c559aae0719369d21f8d0ce80dbe14aa12f3c457c9a8b8803507462e4c5ba2c98126fe8b6b11983dcb46f4bbbad02ceb03d1417b1d43d6aee2916c7780b064aeac3e04a96fe9a20221abcf684aa6a024cb2ce09a24a17714dd81e217aac5345cec1e02e2abaec13f9e4048c8bb0186c0d00e92bac21e14401942a48fe28432c35f3090d5c0ab550e1a2b1d2c01d491865b51a7a2e33060d2a1f7efe59f01b85295e3ac18f9fc482409e0d8fac32832800e7d9dfbad5f840c8a3b126690cd7ccf3b6382a43a419d35cdf4c89e7620c2981390a91a8b54a966e48ec04ce077be6bf4f43ecf6d93bab3281b402d222e0c495a9a1a94e29d502ca19206b3009984589c14edfc136f0940aa55efdc307eb7e4d71569cc84e0906dfba0d4f55491e654e8192659e34610b0127789364dbc555f3fc34f71a96772b253d0c9063203296a8520f50146a36c21d7298e537e12bd41e54708770636cc5ab400503c3957c5a42ef70560ff6bf102552058bb02f4dc999949dadca3690be9c31392d985594841e2072465a9eeb426aac249efca18c6125ebc4333a3dcbb5962eae9222ff3c2946ebfaa4985d3e4775f0c42f7904eaf595bbdebdb95575fd2f7fac78b3fcb40ab5ac4a13e881fd103fe29395bcb75c66ba324e78d18a3dec7c29d62260cf14c74e3ec2cc2be375a79015d10eebadbd4dcf3e95884b0f399ecc2530c3bba6f9493ab8a3d170866784d7b7fc4ea461a6981eaf48f48ed52c2253cbd46c0ec6fe9a8ca2d695c8ead3c73970d9cbafe3e8426d0e051216d012df4b338f7d8e0dc912a4b270f5f374ef4893972982e24061a81f3be8b52e85ab10d790c48c2ed2ca6fb7352cd5756337ecfd2e62f1f0f0d4dc0fa03e62c73bf22f9bfffecdd94d4f4c9e9b447b6c544bd6623b8a5b865a30ebee91f2f1939b4e71a7491f433beceb55e7221f401e52f4dfc29eb50644244253a1d46ccfc12a5401647c127f368ffe0334381e4cff346e15f04f14ced66c7dfdcad4bd0ed022c7438388e971c91d2a2c2e45e095c466c78cd33029001617c1ebd29878e5de429580f1a2bb7cadb44551e7ab9ea1f956edc59d194c04aa46c6ebb47ee277404b9f8960213ce1e757ff37c2a55383fbf30c582ed365306e46b15c136f9ee79f5f5d7112c4688f9632d88d63c5c29797ab967251d4143d51f1ec54a4f98582d0fb58d5953b77292c261eeff354728672640c90bc0d8092911778c097c9e64118878d4407fff6f7b1a26683a6c5e7419d98e92a56ba62e0a0c3aec4fb2c673f7d5a77dd40c52d0174230e37817cc1da3df6df4802f4457ae66fef4031735a6f8c72bad0900379c720e1a527206c981e5c10c606b98cf321f905367a72b2674200f936509483e29faef3cd2ad71f9c84a43c95d88ce96b77a03d48464b7c2b9e8080b2f22c676d78ea363ade027eb885e99681b49d3874df98e8716728d21b20bc640d4fa7a7a3846ce68111ef146895d242ca4defd81ac8f7dea46d3ef04f85d45046f0996ad04aa8570adb2be9efab55d5cb80b46e68c2dfa18ee7278a0d032cd3c5884cf7a7bd14f10b7d01ac7dc708c1f36738ac949f9e7c9b000726e7400fb6b8d655d8733a8345a54918fa1a34e4fc734886daae3ba61643179c545c88a8d8ea5a9b8e31dfb04bd4f2c6ac0c966b170ecd272f6a49b157dfbc337e98bdf63b48de8aae139dd77a1babbb73c645bc6e9809ebc15af959b0e39dd40200e7a490451c2684d3cc68b49f0b2188a4fdfaa3d07e1f03f576ce86ff082127eeaf9d0223f0d36e49034152a3faefdb9740eac8b7c306ba127d3417cefb4eb00e281201839351b8d972948c6c875b89743443c7525491f0279404102817f7c21f7d47f6a2f00a5d843300b4379e483702a0fc12b48c37a09c888d3466f85c593e9e9bc165d154098a501a545ab0e2e17fc2c91cd38aad532d4874962ea5841d835abac17b9b949d5b6c13cb64505f829bb4b1d46aee2b993f5a9f3cb79c34df81b314ceb42f7f4a893a85aad597f983b35e09cc4201e0c4b18bfc9e637cc58fa3ed199a48465a3cde3956850769d6ce13ee1db2db97b6d5ce4d791fdfd0dc77c5da21b4bd0fd3b428524063c723df6e1feecda43d7826f8c2c8f848ce18509557e1104ef86357b94b760fd077d4fb2668942986934c6aba195a3aaf4c35c737694ae0df7db083bfdae52d0c93a218638764898694bec290c42c96b77718888caccaacc774e100685011cf488a4b948a5b24d272b7c576061a6aa009d2f3418ccd4af7eaab82f0f69d3ea0c130af6b8b2664bcea3d8421eab6906d0b1c814294dda5a594831a3bb85146c6dc0c8a817d6970d2b8d554571c19a82e572f2bb4e60e35dcfd1271bec5574f1c3308ffa211d7a92c407b0be2607493a4bc0e8c8af140931e7f63bf3722d3b17d5e74c8aefa4bfc99f8b21e690885ebc9146b9f86048976933aef137424181ee2b224cc45cfd6bb52ca9276689b07572d01ca83cee316084b906bea473023adee3e83ad23b944cdf11679fd9d06e901d0bd7d2deda9bdc276d024c4c5288fc7b1be5acb1c8317473628fbcffa41f4f99ffdce2a2cdac52bf240d0aa45b8f228483f745be5a1ac2d5b035656a83d6881b823c6523982b733c47c7260e3ee2d65e046e16d9c650d41777f32607c68e5da6bd0abc1635c7e407fb1a3a07298c2468bd902b0ea5a648122720bf6b3f10fc884478660073d7a05b407b0064ef06ca28e04881132a5045db528c8bb24765168847b6a4403b16a5d63272e2fc40915ad242ab72ce3605644b77c12ff7252104e8e58bd8568912111219d58499cedf66fc7b7f1f1416f3a1730fe7539d11f18b4c60a23db18539ffdee3ea040bf8dcdb27680b3dfb3d45e1e9c21b8f447a069267a62c3ba7a018cb3890127ad8a6302db0b6f67fcc8e1efa52daa22a5a6cd986cff323cc1384d4223622a7d9f06394bc3a0de268689ef70274a83959c8299eef8e0736ef640a37d45407f150b23b0439b883ac0ab12923fbd00b17cc376e5980d240991f0f02518961387c8c348a00c0fa4ec83054c0ffeaf7bcfb2c78580fb367ab56b1559ed357723a1e19774c394cc7a16c1f508d45b1e7431e7bf6010589c49b88d80ac95b3818c05f0f1666316a7c4b45ad1f2b8ee8559d219c97a65c83228e1e9869566e38b1a988b968c3e504f16b269d04f2f2f96ab2635593ea699c400b650b67ccf1d3616f53f5e1955ddc82c9b6adcb4b1774f7d819d319b8a68879e4a4cb0de38fc77d3549617cdd2d78baec0e95a281152534ad1b795375f9f79ae91a73698b74e49192863b2960d357437e07981ae70e3244fc42b190d243fc7ba4be5259e9b1d0d984f8417dcb9111dbcee4f9b4e4f4273413e97c7e0fe560da08d661ad5ad4bf8ab923fcefb34445c6b5a2df8a88c5e896a2ffb4b2e9500b9fdf9bc4d13cf875b03a9b3d732af152aba1286854fa24e23bd7e7d5ca4cde1a616efee934f0abb366c9dd7603299529fd184b19fb7ddf84e31e443961069215035fcc1460fe3836373da1ed746d7a6fb9782a680c91168bc11a04b116fd860571e7a16d198dc72348014e5f561cee54fea728de7d39f1f453b5e2cd4dee9a34c3c21f08aa0ee8341795b2a499146dcc04e3dd4844e91d5eb00fc46e6d482aaa313aba7448a39369cae1d87337b6da2a353978555cd113e8ef2161ede3b7e33118aa78a392e5b1cfa7313328bfb34945af050d3ac92b7b40a4762fc43edf5d51d47569725e4da459a526d52a53e643d95dfe3902c9217f05fdb2b469dae6d1127f66242dd1aa1afea339d892c380d0744099fe5142a9cee78cb5c4e05d56c827471280053d5bce228a060a8c1eaa53e362a19f39234a19035404a34fdc16d689b7f67c710ddd600aaf4606aba66b66ea526817221d01b0958f4dce7b51349d8967bf7be381408ffa79c954d78fbb083b88646b3f1c9aaf9e6852c2ec99f76c432216b17205e35e5e628d47f4c50e9421c9b78aa2b6d997209088bd286657d7133b2df5a4daf98343b3510dad088ecf88e42a00f5cbe3194136b51d4bafe60f55ad224c404324aa4bea35d5295b6f05374e4a62ae0e8aa8164390deacbc12119eb66e663fe13ca388facb3f5668b9de9ea1f227b9351837cb1b8fff4fcf5629ed781601ad0ba27fa5d91f18f61e0723463c83d75b0524538e273bc2c75d174a28b875ec4cda7983425bf13041b69f869ab64f3d21540084b7f721449dcc21156277720f45cb3810a880a92392b85fc30655cf419d23549145dbec2ea8e47b740d4c132fba6f951e248bac1f1211f79a4d0ed8d2ac5c979e26257dcf2ef242a24cf19b29a687239983a477113893f9fa05ef6ec29317c85d5dec480703fce27b7d31e3aa294588075b06c0025397dcecc1d91d7bcf87de47ff3abe402759c132ad67bad73135745f42151596954e1188e937b15d42589bed255bf9e9d461e4811f262626839c31835899e1d0926e6a0d35451c93c2ca1fbc2b331d9c531aa55135cb22886a386541e38ffade31b50054f556e1ce2aa17855c42826bf87404ac3f50bb8b6bccaec20d70f036afb6488d14d57977c7df9046d07bb398de2954117f0e743980ef5baa5e11f18b9e0bff710f628a14e55f8f92251b37c21c6eb4f5e5e72436b0604d3a20b5915d09d74c80021ff36fd358f1ed751d98080c31c74854c11a01705a6c726fb321b01f45a4831c8ba09fded350a8d3bc3b24475dd38809e8987f207be11434263a32a40267b3ea82cde277edb52b3961521189d7496f5fb048c6b328ef9bac8e34e2b6a3be990864469b83a5cb76780f1669184700d900d5a756a04d9bec8f01ecc2524623ba073e20fdef1b9921eb9c8654789b6321ad4e440caef4c1dd4322ceb95a7be0ee97deaa3e65b13915d04caf30423a6433b5ee37a30ef7dffa0565320ac473bb2720f12a1a71dd7b134507c32b656444b97ed9c1dc3336b745986d67cd3bf8915d6d4e5db787536c66ac16b3fe44428609e81d9663077f43581e652acca0829ec37b7e7f347eecb4f09c11f9de6d698d9bcef694817d2682a6450d350afa7220a16862713fbde425ac7d1d235bd44444aa7e171f01ac837ba3c6becffbd22a469de2fd852c4d6a1501f93d2edc9f0385ab0f245945138fe42a89639ff026dd06613b743197d4292abd26f903f45a93c8bd9c8277921212bed86db2f9b96566e368b7f12a25ad317dc42499c224a40dec16f8cee0263a99c8b0add03ebd9549e3ef2d93e1bdd29bd9a7e4520c87d6eabb8d38a46e0fef92f5664bd71eadb2494c0940eb68468ab7c97eeb775362c52fab89d1e2243ffe895904700c7baa701abc3be08d4654b43e987d947832521fa88f4b413bf0a912256a76262b9bcb004918b128c14bbcfd6df18f8890d7d3c4944f61f234d4b54cf8d46ebddb8db1a4425392e0501b3a56353ced3c08b6129fc9508500c96eb9fa1cfb829512e99636a8a270379ccfd4bcf6989f31658b1f9bb94e1da4826fe2fb3f50878e0871c41521ec7fbb834b17fa3d1182ef9465468275f7cc098f3458a9a7acbe13f336758b722a3f8d2e930e41ec9b29eb0197f2896788fbda597c0a588b3a1c595d5beef4ffed422caa2b1089f51b05f54755a7fd7a2500bf10f87f926db440b2a3185a3c7d31b3d4adc5cc370a58082bee7ccb76c93129fbf6f7fa5e5dc70059f711256d53ded2ff7f8cef3ed76b32843c8836a0f4926474011427f53426320a1d9d390ade36538e1a316709b328f6a22f808869e0fb4703e4c7224be3672caa5974f7edf7958c0401494edc75c8001a14cdc5e2c87ae97f43eaf5531507dca4106acc44d6eb57f481f4ee57a92ece5fe74d767c80cf6b7e9143d39e4bd1ba93fda4207c1a4c1ac6d37412291fb0e252189cfff7d9f4081e534f082fcbc1406b57d638b36bcfa0f70c289ca73c11b5bcdf1890401a685cb25ca10cf119f6f6f12a9a128d1b8082f8c08bb2bb424ba57d3901d64339b57cabe3f752134ef39070e03338a4c4e3492841e7de8653ffe8159fe1073e674742459d2eb650e67d2c6193a89191240bc990d39ee55fefba643ce50d4c3a70a171f43c4d95fdddef441b576ccca4fb4eee23ad751327b7d9248c838f4dd44cea4b95509d6f232c816df3da9f3aa20979a8334fdce631a681a232dcd5e3aff41ebbcde849734095536e08a7177d8cef48acd8228fa24b21b7e9b1af32746ab736e56e7815a39ea1cdca97b6b8fb8668bf864079b2ba8a8529808776b230ee8b9a1889c51b5bcabf9c4acd57c73f3687d46bd5ca5fe4dccdd01cda51f8aac58bc992b642a11487665832c7faca2c4d1664876465cdce2823b76daf4abea6a7220a218101bba1603086c8679e2c66d1fdbd1780ae660632f2f587ac08541b25a26b74ebb32f55dd27bf6c2b850804011bc2bc22ed3a4359bed10cd6e17b1a682abc176d7c13b94a48aa991ac9be1ffc59faafcb91ea074aed74ad4f85ba87870359333f24e00143d0a721345bc7a21b81ba1b80969bd4399b47d13ead02e6d72b82b8683fb2310d5742b4c8a48818abd356d729cfe8f80dff34669c7c503f3ee046334445107956ce66abf49fca9d4833a16672e806c8b06851095e86f4446a62e2a0c519ed49d67792b751dc084b9e36f2293734009446acbf8945adfea663f69c50d99c5d7eac668bea80c845116bf67475e75773604d954b9a06d69c27c1e2978e31f7aafa1fe7fca33fac034c150ebbe33c06877668638c304b56a09bb900737838f5c0c30f3143aead9d813fdc21150cc0751850f0e4c8e0ae5dc96e440605212e7dba2fda18b03a563aae2174ae173c7777b95117f1853236df90a84ee459220f1a89d1bf0da552677b983302862350ba69b1b86a8dc40f6119ecd00abe1f4517287ef58d83ee350f3892b9a2f8470bd8ab2cec5bc6c680bf3ce20a3744b41613c37f5ac75baeafe0249e43195c05923a6c982c5bca498f16b1d0a2e2de5061ed8de18a4402ac48a4c7fafa74a82fb7bd86790e5eb4e4983b7d382b4c7bd2d6f14b122eee86ebdedcfbff7fe24b71c4d03a84af59efe76251ab52af06e261eaceaea9bfe36994d3d7714c8ebfde10147f92b634d95eaccb37cf9e307bf0bf1ac239bc09b18af84dad9c87db0becb0fe429f4d97b83de35e3a9028615a78f7c3bb8118b29d0110a1c2fe2e2288169b99fd81d867e2e83c008a8196f3a9c4fbe4e6423d56f7aea887a18a4ad47816f74fad47a3094f7ea8835c3ec95e40a00d5516fcd35b9aa3807342ad2611d1c458abddbb851fbc234a5617ba676b38df0ded2dfbf41091e15d337f6c1b4ff8ac0ad86af3b49aa45718bce48d82d299953933818c2775edb98c1f994a0680531321a1ad778d0594031568bb7f3eaa5736180af673de79b0fb38b96f6bd97a26608e96caefdc5689abfd65267e35c0541cc061b55817ba848bbf54f6e00a3b644f0eafc4e7e708c79eb54e91524744f655c9a88fced30c3f94fb81761aec1c7380e914e7fdf95c7379358f660a66c0a9d954c6cbeace12f09d2b17072f540ffaa1a5e39935f5ff45a44f23352d41ddea7d212ba2fc7d91b37f003d4ac7c09391a2619e29a4697526af36bc3f282c46f007aa8028e98d46fadd8d85123bd153a3773e5dcfe6b55eb9e098f2996193c0aedf4a3ffafb1b57f897fa8dcee0224806f737d4d9dcceed71bf2275916c733024383231f068fd6280a7f06743d06679cd6620da119de1d5975d8a192c8e3a58678227f9c103326992341157eda537ae9f7c0956e513d17e9b690b937c48e9d77c19ed0282a85faebaa14c0cd38be1d1115e81ded5eec4b1db8ba8ea38bba4b97518cdf2b0c68b132140f84292e7f23402a1dad614b50f2fce8b9bfbcc4b2fa9fc59f70d73902ed3b0a570fcc4a58f41da86f4f4eef2116982ac1bd0d4fbc028640e94a6f919c8176c21a4efc10d49c4fa356587812b70a0d3ce95dde1979996e76c2fdc91c2e206c73bb89f49e5dc01210a0ea819fb830548d8855ff5752295d864bb3e5ab23f02aec4269fec9ceafb43ff545a5e68c56a1321250f68dcec13eced2cf1dab26e83d2f0aa7c72964071ec32504b6471b9ce9bc9a14fec74e7501638354a559aa33c94a17fddee81901025cd8ce94e175405d3491148f9182cb13b25478c9bf51898715ebe9952aa14a65c2d2740bfbbf710b6bb755457a324a7923e90a439f812ec5ee1b96127c0220185a9d4898dcdbf79e49b572db8f44dc6996bc79ea4549fbe61aec9af71c9796e2fcf2e6a556946ff55aec96396b5cb3277ec150c647351e158830d060adcad6cea96546c46dd24420a7f3f44182c42332f132b22c72cb26fbed50cbde91f80138f11a1bdd05f8ed972433f779ae3269ec5e2d1bf95fc37cbbaf646076584f246a9795e3ed337ce5522bc043e0fd8e8ce28ebea02c1f85bf200bad7600e507bc47a5832c6b1dd968857df71fbe555f8f06e14e2264ffe8e2ff3751cc2bc60aac8f89f99bac4793c9d56c7516dc05a44550a46706a6e8518d4deaf231ddc5007c4b0816d700f20d3121a8991ba99e1859d320591aee59615a14aaa79fc87a6bb4480774bef482de9771d6760c4294e96f88bf4750226b73ced396eceb4f81c49df7b49a780bcfcb656c8a684da882edf4775bfe97262b21c2a19520c461293a2125d9c98ef34e9a8d18da9cf57a481528af2e6fc75c1511e751589a4257be86c2cac662211238df6ee64e7ef9a5339792f28a435a403444c7e2b85c1a32b7138b9094a9e90565e8d6b1d7959dcf438df84c8ac686c5397271fe405240166e7f795b0188310e1bf39b041ee578574691c13ddd3034a225107a9d5022d400307c0820df77e82542f48fcb118132d26679b88f2ac329d9a576d47b3dd93e22e30c6e34f38cec4fee3b6ad72fd13933e8d1f1e2624bc36d925080067b284b7549713a42f7ea255dafcd4c473c88acd727372f857a3a6db0c225d7573718ea9f2a8c8b312c48c8776c29234b6669d5a10159dcc7b6e9edec014833825634a71041f941b10223e86ba28b7d8903fa0fe49cac069a3c6ef50a99f87617cdffebf9fe205e95549b68242c4a159b5b45f9a8eb774111eac77bd6477d503e37577cac14ce0848396d78b110242dc1073d8e62eb29123aa56861078162e8c24265cb4ac01ca9c012fd5023cfa977a0563c4f50e4f32e38557ffdb60b45c6e486cda67963325b7834b7ce8ef9d249c36407720e00d1a0d4ada9a03c087d513116150c0eb84e2bb22bc01082b6588a559c05ce1ea972a408c6bbf2002f5a8d6c656b7d9af5d3154f592d7cb5c496f99ad6be350dec275d4c481522fc79fa5e90d599a42ca0210ae7a21480f9e4d3ded11a0d1c7076371651dd2bf63adaca3b2d72178ea2bcc4de942445bd99542adaf32842ad09eae9f6e33bcb0de0d273953cd982488b819c66533b4445558363323c4a82434e8c561d87d6aea9cd8b8a8d7cb58819cb7c37bdc868faff8db1a54efef5608d6d5f976b5ccd95423874f348dd102a9d3c63b5683c910149abc86e7341849ee8ee1b905883d20b4df3dcb00c8f5b4c2aa9a5f56b89a8c7d47677274097ca074df1834ccb936d86fe3abb0885c92958047dad5b682d3c8bc0ccc1b2db719c48695008eb98e092e35a5e06fa2b0987f0c31938c78d6455f553f02c6129efe8a8e8b2b7f133741afd53c30bea70efc662738cac8d7d20297ab291872c82ab62e73d42775bbf4fd16d881260583ccb052a8c4a3893037f43bf4824d8b2131042cc83ac60925c06afc357eb420153ce72730d70de14ae43e61cd9d5ca513ee9830c5a0d98cf3b0677cb8854b90053eb5ca44d12cfc460e62ec18c0e82946ec160b52ac0678b59b80897dae3dc0e62d28abdade0695b3dfea0503db1209ea270717888950e31b2e0b79cbbda541abe2223527109a7bc95a8321c8405c8618e003f0b8ca42478d5e2dd8c1504931e7b110746b7636a51d678fb0f0884535e5f0afc9a9b4a6c54f5972af83689f73745f4445829fcf4b723a5fb67a4cc431c7ca325ffaa102058f2c35782ea3c989110d3e13265a6d15a291f41b7b4691de2d07fece445784c33387e0e6a103e762e93d8e79ce4a9c347f80bac360edb78e2db6df72427a485d6810fe41387d616545ed8b14165aa0d33e60219fa6c569435f0d9605c7e6e216d1f85f9895873b2944874f3b857ba6907055831138396baa2107c79d99c4a16b02a8f187c9b6105f5959647183fec4f5c100edc7b353202538766cbdd52ad93427b7b73e252a54ced0621a283000315ea15da51118776ace7182bbb2855206f55f624e9d8bfcb311b08e4e5e06ed36d01a3b5bb9428e468b8558b2210deeac0881fdb75bb629b8d72d42df74b01472bcd46440df45bab8b7322b194611bfce6eaff3236636f72c7106e77c9a083c231fa158bc910c2c8c7b6148f60f01b5c5927627b3c833d86959a8c7857acc40ee6a25d58dc87ee74bd50c1bce675c4c12f9cda8a015b7dd094131fdba86bfda76d2701103fcb6a86caa96fa6bd72482da957c53bdf4823346fec12286f19267b58ee99da15f66cdc14cec9a63589a07346eb591e5117c19f172477e19f9093b3cc67dee9748681d7a27ec26ce6abcd9ae396fedc8cef4853dcbd308cfd6cd4ed0930a2df3e574f0f0601c8b1ac827a9bbccec0babf7c2076098cf3909eb6f82700fcd14af9c258458848f6312eee8f36459d8667740458098ed39a56e97ec6c7056cf9821130fd229081a4bab0febfa8f5e0b9550733c64d054376d1c4b8d9cfaca3e77cf1d792d587bb5e398ae5daceff850756caced82899fdef4c3455adaf9aed1ff15bfb26b475647b34c28a5fd473a5be6ea79630ecbba3b8da416d3baa97b0686db4acbfca2872adca7a69c031d6f18792f6a8389c1c1ab46eccfe7eec3a36fe9678f51e1e6be1a03fbe1af53e2e061653c9deaf65632e296d9cf5859cb89502b9e47450abef201d9ce87f2ff1c0a5b861c8bf290578b1052c02b412aec67595475ff97fc0e13fdaa9c55f247723745542c3b9bd754fd2c7a4c011ac12a3282360d2bc3cc39399052d5795c7921df13f399617a806660bfe5ebdbcdce3dc64852debbdb7cdd5a7640327d0ca9d55d2ae263592332ec2f6a32bb9187e386ad7cc607d9f0e1454afe83ff0f641ef19e68fed0c794a2b2106432a5f1ec00730b6be631b49b4f614aef54e87446bc0313f674336308f657c4810cdd8e7db6faf20dd739d29a89c2c51eca883af304c7fc321b2a17db1f836407934425621361d3fc5f6fd67cf94ed541626fc506078f2181533dc0bf0f8f2998838a09fa207d71c835027a95f97f468985833d8e0bf019cf7abc87de3c73c4ee86ba1cd5f926ee663704a72edd5dd947612a354d215c7d1f2141cb7c105e305c232e3820d3fd899578516cd1f79d4387363c7950eb018de85c99bada6c8fba49fb5cd2716058a19aba56b6c5d26b270bb5d6be0a16a498a4b4092b33743ecd98615591c1c240fd2bb241ea655c3050c593d72add925c9773154204ddb1ba2f7922e590f0c2b2b04e82816f8b83aa522e0baf948203d4356b3ff3d478340ba2b681ffac7abeab7c66612e0b8d7f1cb17c9e44eecc5a723c1b5fa4f2c50d72c2a4a4bb7a2c4e4ff9e3e7c22cac230bccb5a0a4755bb45556d89bf10e0e55829492257dfa17401ba984b6f73f1bf78b4063549e023a9ce6bda07210c88f7d4c269bc7aa01da2273fc01d0a607b22fbdc7011f6fb3b11d59dcfc742d818fd46032b44c03eb412586b49dde9df35a32c50997d425890e19458eae671fb6daf797d48fc6a8558571d989fee4ab2222f8b6c591076e56a97c5afb8d96943ecea28c47766c85dff2a0d57a7d0439d774c53875d7d7e55244074529d35084da8d3ba79b634e2227c93a77d7481cd556fdccc701c33e691823f12c2eabc0ee2db30598a47cce8cccf4de61434429375e45b0f24c8dbe57841ca59e75b593f67d704e51a1a463a297a44e5f28539c6b3ce77680331058ac12cc6b7024fc98428173056f03768620d97f6ac3bcd26d318acc7574bfe24a4ec376becc28823490e3b6fad474186bba32d968148d01cbf4a924484422018a2d54e87e415a049c63e0597146d0376212df130a81e78329b1710e36db9f19a2dc3a2249ba917fc7859e90fb38140e0b54d56c89ce4898e9b4b044b90fcebe39cd5208ca0c57876884c7217473cb98b6a4ed6444900ff630fd9620bd0d8fd339332b2af00f81354ff6d61ceadd1251bcb038b08c3329da9fc37eccb2cdbf4282bdf00b010cb8c4e5d7647a6225d38f4d928a5d3024959561490160f233899885ed3d887af9bbf03807c93098b440c3f9eabecfbeff2a306a6adb564c0394c877c67963172ae71b90046663257b5388b7c4d99e00a35d36213053e15dcf5c047f6ec6f7180ac660ca2624d421fe249a854756db5108ff2d913a17c081eb027fe3a8d894b6738aa3183072e77db253359d78a0678bbe1dfd438d6da381659cec898d01ff5f0d74d9620896d39fee10173d72af032aff9690e7e3189caf62a843e50769914c24907288488a302d5d878ed4133b13e31387406b1eee2cbc9a7d0a62f5b91738d3da60d0e76402c3e3640e29edebd65feab649a8bb0c67f0902f82bd225ee474d64ece2faf086b4739525ffd2521be38bd7da6785c2e1c46e0eaeb62211c4185e824aebf98a0b126dbedf099fcfd2820150af5dc92fc647ba6d768eca0a0d13dcc40a5978b089c571fe885fd296324001547cc1a4f842912112f12a608a15a3479fa804c949842242ad041eda76e130609985ae5da15831d98baa54d24bed6701f4fd307c4cee37e27b62fa1eb9ea503ad64f526b4f452ac29bd23cf93d74983fb0d06daf37b22e01e9b37833f51aa605d8eafafdc5e0ab74fe68831c5b4663367e9100bcdeaf2e30339099611f3717430e06dd074827ad10b39ce0ea0e4f784b3bdbaed5148889c3dab1d6329ee1d2254920b6ef4aaaf059b54df0c01aa21c3000d1aaad187f50c58f7b22b22f4bcb576174533d26ce066e13424474b415f47b550f75c3243b1a32df567502f24adcf4781b82a5ba224995541ff386a250768346ba2e486ec352765dbd1bd525a2950e055bca8ec046dbad1d8b35ac1f494cc6044d6ced572e51b11a8e5c81491a2b5d7bdff965ed83b090cdc10b65a996b1eed7a63716360318f985f18bb33632596176e2d60589483e890b949f820e30347468ab732d69fc0cc9b986b5e7f37cecc134e4ab653dba22a1efb67f34c191a9117eaa79999cd4dc1e7b1983e822fbdc273702088766b0d20f3bbd2afb910fdead95f75bdf8fe056742dbff83dc4d14dcef2cee1cc77fca2927c1f6bf9d2c897121e8d4f17df16381eebb0afff54cc57079ac63eadbd5554a3d167f71469ff5750245626d90c5e792e45125ff9449de467c723ea9eaae430a4c067d11325cfa89c9c040d2bf328a27ce388bb608be4da7012f344aaaf3adf80bbe76d67c17018c2de8fd82371efaa999910c454ef9ccff8fc5e51472ddfdb0bd92f03704094548c0c3e1bb7543c2d04058ac36df10a429aafbee71c0719b489fe5a5a7529d8e08739100ee32d2e1cd08117621438adc5a13a3cb9d689698aa13d01d3b1049ce6d208144abf87355c7d402b8dc8e5e531b9729823b2f5ad32f1ae0ee84d1928e8001ecb7e28f72b09cedf6b01b63ecf7b8edb85a403fa1bcc8e02fb08e3950fa11636d0b9be9d1623b54913b48b0c123a6f27290342743edd48ee187943ed6f705e8e8b7960ffcc611c4bf6de8cc3df42a1afc0aeb44c27ba9e5602724f0d91dfb61d31231aa697d8d91f2fa80f9add56c8e8cd18db848d0e93be7d4a866b2b7e3fc837c16b4a19daa4c531a8d603692a470e0979d29ba904c9fc94daac53be49ac2f46226eadc4752d479daf9989bfa050215d1c37d53db4c31c83e99c94fac29737208303bcdbd91221106d7f2e760c7f9899e8f034f5b9a5fe15abdc6ec97fd99d53d8befb999b7f6bf48a9784a9e8daf1c72543e23943c737a3d58862d2831aa97927abac413f953f920a2cfd9f782e83e07c41fca4e7c83e54d2dd04e86d0956cd0d396eba2c5c8db61328b76bd582bbec31ecfb03cb8815ba11d84ec1ea9b39bdd1d236ec0aa0a81fd8475c7607d26eb260a4f2d0a125c6900f9690ff377b61ebace8ef4b8ebd1b02bc813cb643825e2f493aae74bc672a88d294661206b6e5b20706c4bf97d0af0c97331a8f0e3ca372900f156741101a08c871b763f25475199c4123cf8968ccae4fe4acb09c0491aa1886564d5a1e7772a88090acd1fa1d4851b0d9416c16e5fd5ebbba31dbc339e3ca5e388a62c3c8731b231da70a5234c030980fc6314d1e63bcba6adf5bf530799df389768ce51ceebcfe31fe7482c2807f88b9ef7b4254001f40f55d83c462b24636b0ed38edd04c198ce6e9a577cbdf193513489b124aa5544c60dea257950a3a36f9b6e4b390e7d190978fd1044c1cad32b1b21709e4ee0578e49ad270a13e8cda4c22e2194f1931714a5123a6780c2db086f3fb0b7384cbe5b34b5f4e08ca6043430461591d0eb7e0f16bf6722b3397ae3303e43c1b87b44e9ab900a072b17a03e24298de87cfc8080000ec0616c5010ccd24f2a9d46452c03a521310c6a5ebf51744dbada73f701cadc03b203d93fb6119caa94031828e0adaa05ba8606c17edce6d27451d8f76d21a5e99d8f54e28e2c5979ed779716c4c3c82c4b881ec8ec0f60b87c8ed44f896efd5ba4a1cba1dbfae43bcb51b6f2473d74c8100c35b5a61de49f48e2c12eeb4a0408c702b1f1ebc0b48fb67cc9ce1fb39f63cbee57499859fcb3daa31480f699bc29e700905163fd7a96dfed75bc6b447a9bc1f4ea5262e4aa32da58a9c91577124b2dee6e91b95298ac592eaec79009077c81aa5a5d7c2acc58cb4668373896ae8b05a0dd05698e09f3582c00c4e4aa5c8a4d20dd9176b31c376641e2ca41aaf5e23be0d3e74a05337c37a4941fe38d07985eb8b2788e594274efeef7e19e99278de5b95d872845d9d4d27c5cd5cfc98b2bb512d3c3c0466fcb7dfab342ddb87104f3e2c8b59a88ecca437082febe4f4135e305b2933f85cc3d858328521fbea8c77dc066048d6b3cba383f068ba8ad316f90241f2edfeb7a1946162c290848eb549345c29cae983f7401dd65e183ee85b969c70fccd49b178fea6e48b96f068091ef8361edf0e8a4297e043fb3f9d02f61c56071b0b2d82da44ac2f5397aee624c8d4ddeff00dd201c801a01043bc4a4c3667d95d107a58a7a821dfdbf0f4296c3fadfb2eb6e4c04a2be778ae0dbab05086595d8a300d8a8779ebfe85d1226b5d6b35c79c7513ce80ceecf0245ee266275acc91b97b102d0427e20f59f84857d294c4ae9d7747e4b80b9f39739a827e122617da79586cbdbd4b117c13e8af1772ce8f021b5e0e51c19feb7faeb8fe03f2d5ca92c606a8c2527f9e47ee85bedb2e15327756d379037f042012bd8d031f06228f15c53dd1e5733769aef203077aa357f3d5c943b3f4c6261168c17aeb6b683177efef775329ec790f0af9b91f15e5142dfd7a1393f6350ee0971056ad8a11c3858da9c989c78a2d67ac4743d9dd4c49756743a512e8691a44d023e9b183030ee21cdc2b9e0cf9dadf3c82de23f2bc88ad5347e1eb9c37c6366aa34802716596a552cb9404ba65391241ba7d2664631e0dbf54b1d8e31a7c61b51fd132dfbb0729a7f4d027ade9283be32859a8c19d5f5256a40b9ce7b0c9acd20103f5931cc81a4e166614b69241226132bd14b7eeb33379521f671dc4e154d6be9d810a5ec00bee13ca16189b9cf2b789b1d9eb835992bad353a0bd317b8c97f1909836139b87756ed92925876386846e86de4443965cefd56424806ae5f364fc493ef61cab3e933d9bab913451b36bdab4603e440e3a883411c3b4deb8895be8d56096de5960944a3d96ae4c93f050f52ba0833abd06e77d6d05f48294392ac4fff6f99b32348356ed8fe83dbcf84a0efa1cce68892a4ede1f448c741ede33da81f0f26a2308c2578e4cbcce2a6f9b701ecf395ed362c232ae105ea2c9272a57f529a58a0472daef6e0233ca8de9735d75fa6159b1cde9dd34ebd142595155496ec3494b60ea7bc3e74ed006d6fd430739b9f2eb43c1814510bef356cfbe680ff88c5feb001850342fd1dfc146014d873bb5122378a644f33c36bf9e3238336def9c73ceda63b65997202ddf122b2bca20c4a2b19fe582acd40dd2d3d10ff1f112de407d7eafdcdf0fa28bfa6f411ec26aa1f080e58443a8c837b26a601d38457495940f54c8a917d3e89dff9abbcdff0657349b7120ef400a45727f4f1d93ead6c5058d374eb45564039f8870bbdd3394312112055e1b4376da8fd407c07824a5ad755a0a6d40122479247aa1055d6cc8269db4836f55e0599f5763a55650d06403f06e76fad794bdcef69369f3edc0fc1d0ddc865f7bcbdccd1a65959693753767e31aa326c11a6fc47d24da008fdaf231c6d07aabad9e8e3747788e246778bc923cebf526641b840a4a930561a2dc99686bb39b27837cf56a666f18daeb7c0f8febd120f07dbe8645a496513d0c8ac75d12d92c988237875691f1e73a61d3b9f5e150b6cf844177ce71730cbccdc67b1e0bb9b67a782303085c6f12a0cc7f2cf89d05b8d4be07f3482a7851e7e471cd4092ab4ef1f13e54d5674fd96ae0e27592de2c205a865a45d25ff3f8df137d3504bdebf1cac6d92d981e1b1fc19fa962a9666599c55c9a20dbbde22fc5dfd97aa29929bdb9956975105a0906defc5c14980943de936dac2b0a70079e72cfa88e0e0f29fa3d26f4533d4bed6d1dc7498293cf66cdd8ba2c3b2a4667e82e47aea411952868f756a057377f18dd15f04ec5a22a1c783e68522fafc8228acc3eada769c6c7fbec539bf0dcb871b2989b141a6779268dec8448d907615bcd0f93826cc00a6c6116ad81006940ec3c874575e2255fce9e18750fa548a87286ddfae2f7b3fd511d8604ace01845d4adfd1d3bd4f4406f5ddfa9794f20ae55cd8244f2594ddf115dfee43e7b089d3e0dae33baf1379ed1001269ff61195b1e768166e8f7b85bf6f7789d5d93a80cfddd3533dce2e6e9c5d34b9f91dd44445cae4d10ea8d7d881cacf9fd03507139f5a52aee7fc6bcf53a52cf8e8edc4187d39a44a7c4e9eb5fe79a1b6db34b75eb18615686591f942ff099965f27291f37112ed5d0a23a2bcdd010b87541954fc04a51fbfce05a760da1cb60bbd025c2786b23648ddbc0df18f1f065ba4cbb439c9e6e020834a985b551459130c37f497701eb3da879eaab6670250db4b3c5bb9cc73920b5761c67e763c0273cb28f758d15df09bedf80de7fa1399bc1655e50da2b9baeba728f01f78ea5683e9db1a1aa37a0b95bbb9e0b8183b14308755fa4f9991fcc8f86c34522fdde9cd64def04757c2fff6e3d8639198a615d9d184bd1a73660f32564c25147041ba9c97b1b0d4a27bb48a147f7e9390e64625bc4b0c2a1e76791fc0ce414d9f7f6844281a1d745682f284fc195f521bd88f4f6c5db91afa85e71d57f785eabbe2307900069d7faeadabc8a93597d39cac29fe7e0219e9360c7f7ef341fa86de513c1af38c96116b05a1cfb9e4424fc5b60c61c3e9a0d7b4c87a1a67144ce5ab86fe05e8c5166f9127969762a5cdd0517c657cba076950e40d8f3a293ef915f562e73976a4802cff228c884ecd5834c3853987805bf7d59bcac85c0c1d25d9c0610431eeed13626030dbf961e30cc318b0a82aadccd8c642492b2388b792c172a2aba43f9dd4da8c2ec2dabda80626418f144fe471327be70ac5d55c688d1391fa216376ccdca6b1ebe65ccb3aed34886086a03a0672e149a166c9716dabe78265602f0356c81254be82a7c8236197601290a443f699a06ed43092102993eddf06fa3756fe691a24deaa58e4f41b37ec17713a908660af7e39470c1ca695fe87b0bc09cbf84c241fb98bcce40af66788f28c9f40b8e7b35cd940395753ab8cca5d80672b4f4cdb5f05442ba8ba755f85e8b3e44a980f2b0c8c24b1446785ee13e93556f80ab776c7db142320980e6d2f9e443a5e4d366c02f74c95a054cfa8baf08567cf7b3c5e4cb57805dd6147ca0dac047b16fa5edbb09b9c18d39f7d5f5548acf91cab15dd9f0b03056b9ae6d69ed6dbd2bd9ca76d49d630f546a3d143752e9d6e989f4f4114f43ca2acaeae889f8aa42d2214ab6912282b7aca6c85a964343a3a846852349489961739e98889e2385476202199663a8cfcdc14a3b16ed8b8b7471856aa93f8f1f96d89c857d6e3e7f38e4dce7c98ca8fbb586c2c80384224363c504f240a9f728782c1f8075d453e078d1b1a80e00ec2d56e279192580f98840f63e26bfa41f3d223859d451191635c65861c49fb9bfcd22ddd2c04bf577025d1b7da8269b49f29461b3d969d6ec94c114325009171a66b86941e891398dc42ab75475eecb897aba985199bf0a967afaeeec9d1f4bc5f70d714f5b14b8e4490d38177ac5ea0f3d6185fdc906fc121e6d8e0607bcc122a2797c7f12575278ad598b18b6a4e7300ac7b06a0e507860e8974cc4fe3d020140ed4d398214cf8e3353065d3bfdadaada926aec39669d83c6a441b8390380881640dba731dd05e0dc4bcb7b37ca93f435ca0af97cc14ba0acca6746bd22919691990fd32ba862e3c77e39eaa5ecbfff514c7cde5166148483bc9706a286a81914f1d018956555f63199e4ee34e2d5533ae3924072a0d3b89d79880e8fcc96edcef8497f6202d9d6435a2f726bdf9ee2b60758fbc2e14062dbea963ce2d612a8ebd35830d11b46326eccd8121739efc89e0f887f7b06dde477193e6ecd86c1cc45a9e380952e1926e70bda67c26803d077e8af3ce1661be7c45dda72790dc1b5644c3b8b6c40704541faec2875edcbb4c3f5f3bb4a01fa76757c89900ba90e57bb60775d0da6a6cb83e94f26deeca4cda5012638d8ea16d4e6ccd6929bf1e24cfc0ca731c9a5d7f2e413ef85f3dbb2c124fc624a4823191ee551fd648e1d33894849a57e7bcb9b10b266b619672d1e7d0ad0951f83bdb537d361f6c5178f4303ab15bac0eb5482dd0603dbc0ada16ed9846d32cea650a7cf7b5e3b92c51147954148fb54b57976c63e9b5e8346cdbca90918d6ed9b73a2f8929362ce89c716b070d2aa04acb39877b530720d888066f7c9b1f55717812a23f1b8d6a992818f8f98e86372b93b1d58e76ddc664ba23d0041a93f3a216760f1576f2cf7dafea7e1910206f049ed1de983ad69e85c4d924213feb2faa5e4a8c42a1efe388e8bfd931d9b07cc61ed8b4c72bedf5c30759719c3263bebe0b2d522e6bbd24fea77a290534fdb8d62b3a358466388e8f7c6ebefe526c10dac053c982c73ecce58388f3f328238a6d80f861fd1706ed7c986ace00d1ca6b3ed0e0c08102b73d701b46a3038954e38e6fc8f33d30b522396a564f031343e7cd9113ec2303ac6697f386d586d001f22b9d915349cf3d4acd99628f429d93395aba482e80d89f36325c448ea9749b3aebfae6f05a1a1ddbb24d8b5b7c472113ad6fa77dc114a04dbfd44d5576234227eac087bd2f87597db9a441cb0046971658960968d11c8bb0f1bf7e37c55135008244d9369dab4e28ca2d151660186708c26bd172c91557d9745d19fad384b66e51839890c47e712c1752c4887c1bf93b2e61758ca8fe30ea4ddd10c9c3e5398e401002bee6cb4caacb72b50cdcf795e5a0d8acc5c9d261b2be0bae84c1fb5a153160a9ce1e4b4bc9542a2569db5692ec3cc35a9361a0143133fecc32b41ef17cd9c26dac53341a3b07e74458db9bf75ddfd2c9d3c8131d9500fcf8b78badb88008732ff4619d7dcff834e32db776f9942abbdd1ce0f3b99c4c61fec8a1ecf845b50a92c23d553dba5cef296f56cfeda48c7eb3dc689cd56b4eb63afa59ac4ed54062fc975f2bce91b8740cb075809b690c2a6e0120387f2626d51d336550c6fb6e6bc86b77830dbeaa5e79432953fc3f829ca6208b38e1f42d1fe40a9b47ee68fa28f00d8fb63c8262ecb8e5eddabf53308a2ea4da46e36e54c724ad03ad38d3e7e4e873d50ed77bd31b4bdda155847389c0ea7169ce65d546ba5fa693f1680be43af2242ee9558ee77c2f5eb029ab494aae4f8e12af0a09dc557a1056304552bf751d5c65e78550032f45ecdec3cd411bf2d21ffbfb538b87a66e0622332b0d43749ee441c8d81b1d82b15cdd496d59ff4dcec44421b225b95169ed96eb6a0a4d466c2e0308d45eb06cac133f6a676d762e05461cb995255118db8ba360a93270cdc74fb885ae99a326caaa48f01a9391be71536a99a51bc8b351a14e17b30bb1957531c5c0690635bcd7053ff9a596bef533f33bbc40af8eebff67a6e7de61388de24ff0867669eb4e1af487fd36a52661a4e6db6d34692a117af19fed9fa705d33b41d7bc702ffa12fe5e8acf24ffde0f791344aaf0851f539bac9cb247839ec68651ab77b6d2b1ed6633184685025131e982f76cccefab17680337c7ea7a338d69f80719d4b0516e9af66a2740212741c6d0b6e9d8d2751baa9d6b393fcaf96d06a3af5e376d8ab9fd7d6335aff69ed807011c97f8dc0d8699122fdd811cfd4459b960852d0188302401b8948fd3d5f215ef41d2b79058f2c9e4314ceae4639e8a322288cedaf6f4e4793450e28181d45993348f7f5367737ebcf1236876d8cebcfb10540d1e8e087916c99f8e7b76ece5028fdd35799e9ded4292e2c3b2384135040d133f52877bb466a8a372a9eb96bdd5f359bfe0b8639fd3c5be714d84e81ce2cd51ec7fa2656e578bcf32df9ed1b6994b8919624db15d8a4e3a1d896cfef0fbebd40c109c8e16d468395ee880fbdc4124e25dcdf7305e1840dc2a2e1311ed5361b52c3403255c76450be28aa69b73e4d01de3816eedf9c00f358dc3214049035847d4289542317fed1d5007fc0aed3959a0ffe66e559e0f4285f44c9b7657cab593923952865f9d399b8163e7ce226ede0117d917aa9f253fad08b53271792b5852b21b972596de6f40adc99e458e65f0d9eacfc354ae5b7f502c7902ca042083500133fc359c39cc4e19f18eeca594c995380b2f7e19726e216607cafefda9833e2e6686bda7fb7003ab5936c9179b089bb37a9b26fcd4c34c43743e3ab41706581c0cc2c5f80513eb590242645896689f9e42513e11fa5fbedc11ff62d9354e9c699863cc3e84f7a708b0dc239ad415d4937a2e366efb34402070a3dfb83cfd5c9b5da0527dec5963ed12f6cab1c5ccaf9eee25e5b194d1de534d8b0c7f61cb36d833b6aac14c7d71baf1d435a21de80db165c4f7be5593a5ddd0ad3f03d854f13e6299144c2fa3d6ef9d1d0a830c984d634e1f1695a3e59b4cb19547d6399633ab7ea50f8d834c58127e54b877cf314620c88d9ee39e20960559ef70e05fbe86d3dcfe6ba0b10b40a3eeba16a37ae59683466dab2ab30870dc462f6739c361e402be6c81531743dc28a782bf4881dedd6609e84225e9484d2179ed3200fa764c9edeb892b9559fa44a7d41f4b4e4152ab08253a6caba26459c6132e20320256712843f470e96ef7492001feb7b17c9f8a4faaa177f51a86a4f7a26e890b94f13d4292942e57eb13d8e4214ce9b9e04653c89b979b4f5b9bf520977d33f90f2f1ada162b0a74a6203d61d64ccdddb148180a294a174b846e433da47eff49ba34502c430f8e93358950366f6e5ea0a572593efb8e917dd990022e28ec0ec37e1f7a924d6f3c8377bdeea6cfa37bbc29cdeb283dfedd63cf9669506c74d70715ee120a8199227b2d410d333d411ab0777273f6ba2a9ed740e666f608b1922b2e534162bd454afcec4748f37b010942adbd131c2bc2769227d6e7bd01ac2e5155aa58bd89cfe59bd212ed9e74dd12c59a64d23b8dcd48598cd5d9d6d20dc522a4e2e9465941096cb8eff752b64e996e1559e8b9019b05448c69efda3a63fae12f52b7f8cfd16092ec5563ec158f97ce8c340ded12fc1ea3bfe3c7fbee425d81ace998c63e071c41dc7d717c27050cb0c6df667bb4442dafd56ca05296743a8e8d363686bab7e1f7b0f188d55b85b0096f12aa68573e2c4ee12953edf01cac2484a9115224821f7cb43106e7cbfe5ea328f2457fdcaf377f6b689e7d5fa4d2686e4922dd076b74ab2a64815ceb4c79d48c89416435982bee7c83b49e073a1a2b417dd9bfed59ab74089618c7c1434c8a7c92851fd77e22fe8d8709efff21a759d4f030ef2692750b6400657b8dde3b564a8a347d8cdaa4c8d6601aa1efe7c744432dddc6ccb28219010597063bcae94a37e6a7cad889371c5d0b7a786a6391b00090e326f934eb29729282d19e24ea98e726a3627b3399a4f88808d7fac3cd1af14175968b59336cf8e61f30461f5c2606cd11902caaf0e2d49c02888d46cc201f3f0081744ce1cf8cb7d15e103a6f7f742a70e1d4f87c7f194603d03ea913c5da67e53183cedcbb4c4fb57acd15d6883fd450cd30836161e96829e6df24f2c3823a58d450b226e00aa305c15f1f2f40c0d1ec82367ce2835c3e132f4e37e59ee5af3d0ee7a35d8e893ec91df420e906986199d57f04c351875358f49c696388f9b7757ae85c4da938623c67cec3dc1142810161e24ef161b6dcfd4afb0d70afce8110c9ddee0eef3b39c1747a65eb8bb32af990219ae7039634a219f8792ccad991b69b6d10706444b3e34fec22407c55cd57d52a5508e6c381f1e52f467c41f0ba8afa931c30d4c7eb63a5305bb254650e8fe96ccb9964a58b87de7762377e239096f4168a8b88c42ea321fb58616c5234334e1445c9194a38fc77df9b867315660c00bfb17876d2245786e8314d35c60336099438ce3f1d4a30a47a96dfe2f0a4e693af5d087f59490086a6077a4ab26e527c386a4e381bd9d41496768c2fb01fa94ec9788730b200b327ddf9db853b4571d87c168421a4f2fc7a74a9eb9c06d4d6380a84aa92d268815ef4ab7a7b197601d463f480d8cc3af88df3621a4fe2bb3e7dd57d40dc066bae3dd0d4b2b14a6cbb70e9a52a3f4511de165e312a99d989b78368356ae7c7f344a2c96ee898b26096bc5a804ed566f9f6f2cc1c23df33da7d6bd9a9a0ede39afd7144e7f41b77e4815ec6d5d4ee4f4d998a8a573ff0ea8f767406f6e666a46bcc0b0c528660b1339fe5c4933187eb1988b672b20b96060a7d90da47f4575aa47a4294eb445cf70825b66bb68837d22d77ab70877d01a32dbb02911842c47e5a827e95b73b807e24085796fc64bd4cf2697b13e0665f55e2f2938330d04400377d0d199065928186c13e3134ef0063f9eaee6758581065eeab24db32d77ebe3df4529827fefae4cada3a0603d9f3184dca327e682f309666f518066b39a72bb6066c46aa14ccd255521d38a506906f12cef1694bdca732e7c8a4d0206de10d995ef09697467ee389f2334889409d2e6c02b8383798e4658b50ac51575a57c16fa1b9e8df90b4740b2cde2e5424bba12227f89eb52ee92f4be446dd4c3a82b36b53938cf2cdffb3347e7a127418eac5736b8d0e1e31db0b55a63e5705390116fcdec20650bbc1a2515712aad5a8b31f25f8502759f48061740c75a3163a8b7daf98e2d0da0ae24d923b078506b1e44d291559a2bc7246da3b4514eee3527d395dbb5ef64df9fc672dde3e596f81317755fc9123091de15bfcae92a71cfbfd86385371ad1206e94e81dd74f9963ba27dccb52f6866abed0971afb53de91d27d23424b0f088f496398155e35cb131f1f58ffd6181a53d4f4b8652556a5198daa77c95f153eb73b2208385709b7606a6065a16f787117726dc9c4134d52810d56fdf9037670a8f032d1ae71b7c2f7d12556ec1ccc84d35905ce95d801b2fd1cb7f453879e11a656aeadad3e28da146703b98afef22d6df04ffa5f1c6578be70053d9d4d696c2e235a264d754649b653f904010bea05450f5d14def2c0c7064ed2533f798829e65d9ee410edafd6f10aa908fb4f4c7b146d6a1ea0bccecd820e3032e50b21f772074cabee14696ad9618934997d16cc544a37ec37b0d8bb375030436f96afb00ea82b83c8d9619425f0e7c6a48315571acc1d48b7073ce66060f2ecba65cd41f4b7c0709640be497f516b009cc90a2480445389ed2a6d26bc994926c9c072add9f6faf67efb771a04899e058bb9788d547c90b1b4878fcf0e38585a9ef6faa7a07fec2b2334576d17d100b870a4c7816acdaac841c51f4436d7c751c38109c98c050b6fbd7f324ce18c1da729c9b98df5d11bb59df53ecc7f88b902aa10a3f37f05e51a2aa15ba5c381c2850fdf8b0251b2f2f76ad152cb3e94053cf15282162a8e3ad4703635703359c4b58114d6b4b993f022922bfcc38d6ee20518a01793933537f211bd529c5f7a1052aed1ff078814df4dd7fea302585d92e546c84ee4f6521e0600060639dc30ab570302d84d459787d7ea100a8195c2f1f317d5e1da6f9c03e8357922d119923b03012ff5db6596902391da7fd558997600e9af0d3de7bc1ca46affd46875222b97dd7900b676dcd9d60120d5a13be0effc30f520cea73dfcfb8e6fc0d81e895d958416af51e81e71b0ca326061d7f67bae3049e013501f44d67513bdca21a4e7984c836fca54772824c6b2e947a8b34953cf9b845f8fb782627e610f4a15b561d262bcfc0dea428385c1b4afa7aee6a9c6f4dc9163470d342471294fc3d1bfb37ef1730e21d91ca00891ba3923c8fc656ca44b35c49fbd5e60081e4b91d42c6f4d8850e5b00a1cf8c61d1ec56cf271a97f208178e2b8d76a67f5f0e156df67fa057a7ff52ca6a99ec554a119a124426b81ddeebc6a11834004ebf6996cdfcd91d7cc4abbb346d881be575f0c1c6eb01208ebe72b9b054ea71f8d9497ee776db4bd827f62c332fefd6b787bf6732963cc4f8a06c2a245a17cdd9d95749857d97873b4b6d5cd31654b25b6d1096d9f4d3a565c025d51f57ed9e90de9b5740c7be62be3eee8853238a0e289919360cdde389d629214c5272818bd58da74b07515ad9e1c2191ec3fa01adab0f3bac999a9e2a84091b751bd56688fca3c0424c525fb1ca44949bcb2f8181b15ac0a1f393cfaca82f995e5b0137079191bbfd028613a1dec108197969ebbd69965c551b240c3c5f3c9da2c13c058d9375d028ac21c0327e43f9afec9e465c75ea86bdcf52cb8499170695983245e4f2384c26380e22ca449a3783eca7eeb5123bcede7398a81af19e6cc89e73d986f8eec4686fdb079b9a62b6ee8dcbd18a9955b2a15ad3162024860b0277177bd4b833b91d6636cbaafcf435adbe8459dcc862a72ab4207a91184afbb8566ecb240a65d26d02a3a56fc785d44b38cee2fc30f4cfd6010a7936ce94336cafe3a3c19d6118d06cb84886b85106c889b820be3efc20e9f18b6bf45d64bdb6ba0976fe5b917149abfcfc4820993f3e3ac96c00579e78a426cfb762f2a0e7d8dbde81139561f52b748afd713281de6aedd250c768e82e4783768a9046f04056f8addd55111b1dab40c32022d628ec4f04708bf707c928b0757607032c77a977590637ff671f1cfb60ae4fd8a727a6ed91a8074a8cec8b5ae690b608d2cd696db91ce08c22fe4b5a8237d78f13793dc6f096082062fa419f6a16f883cfca4baf3cea8f133b7495e0350e8298ac7f54dff6b4d9ccf29bcc6af71e10f3010763e4eb20728c10a6bf65637571907f0d26c7e3191e8f049d027fa336d92c9b221e17e90e8c168b293a9039c3373ed1ee2efd435a9ed9b5068e0b919446d83b0a4c57b5150247e268ce89ad08d93c351622ae6bc724c6692bd0adc5ee8a8bdc43863ae21b0ba49734cb23e84093f1290125bed8ab7cda1a34891bd655ac6ed8af22ad7d1faf3229c195a131f3530f25592cc4ed46fcbbd8167e5fa9ea9d747ec06c5b5ab1226b693087ed3e3dd40ac3f227fdbad92a735e89e86e24439587bb2eb79bad6b5118dfe2889271140b51ed5b850e0dcf071434c8eb2626619d5791f31f3e9adfc3ced1c0ad27c29df3419f2dc1c6948c08ac7d7c8502ad3d9997a3ae5fd0d83c1600eadc8610f1fd9acf65a69fa5dd5e71ff0cda47f6d9d20581308ed8c3071c6df2d0cd580da1f2966d50a0a961125a0181982bb734727a2f986d49c52b94865112a00db7930239ee4be0ccafbacc8d42612aef3b7c0e5b987f714b97a069f82984b4cec27ea9666ca7ce919dddd73d2507a4f93a4baf623b1d0baee3e2103c704818bbf1c345580c84d0002d3da469d460f562dfa2a9d7f1d4e1627d3becc8d0ad8a031e7f972fd607a06e4a5a1fa4e1ab9492d6351dfd3ec934b0e77f9b641cb1e86a4e1f9f4b085821bd9057126eed21518d02229b8ccc6fe5782312cdb477b550a9ff65980a673df33da75d2d4e7177fe99506531950b30855cae2ed0122202b08650c42db1239ae842393df580ffd6663a54d82460e36cf9172d338062f57c27e3d6f9546b76de0941297627dcbff12036e2affe999abe177c89999c0484a23430d343d21be030548400cbe1ab52fc28eaae812c95031aa0459ae71492a48d33586f0f1ded8d94b97dc5b89e915809b70a13af0b917aafeceebb06aba9503cec0db77386e19ebadcd7c597f20b738a22dd1903fe035cc324256d1eb7930eb0a654a61628406321bb0dfffc33867537111503b2397892b16ea95a8809faadfe46ecdcbecc85ff52f0062148b7ac0490161c3296ee5d51bdf6466ae79df73cabffafa92645a6a4be6af4400f5f909cbe4e24beaa29c0358ec07d68a1529321c18e1b525950d04b6f32fef909663147da114624b1a7bc76c97ccaef49795bf8cafe77c1ae6d579c1ced53c716f3aa88cc60dc0a9f472d14e38c4197a1abd8849877b1482865d2cf618a8309286fe5d7a8e967dbdd64cc294317d9a10fcaf1567a8d3aec1999dbaa0a63e49ffccbde4c40c4475b98a4b54e7561bf9d8536809ad33a1dea9ffc022613f73e790f67b52b7239bf64ff23aa577e013414ab001dde45035af71c325f084968d11fd7e6833cc94b6654971fa909308c9a5d99e779430a83fe7139b6ac4eb8432f2bbc253b03fa7369a7e142523aebb635493250689d3fd9ea273c30f187b562fac8b02ef177c8888f0e88d8078d9c5214d77bab487e85990535fd7e7b32c1cdba2b4f6e2931ebe45441a2819f92ce3dfb9529cb9ee2c3573bd259d3504b69be08d75b1c7c9cde13db1ef0956a0c4ee55eeb53dc2b3e8d375848b2ac31402493d4fbbe46ec61a22f4dc17c76e22fae6492b9b73dbebdf8bbceaafe83746ba886c1cf61fbababb01f054d79211d7e71a86938d8919263ce0044398b0be42d7dd09cfcd829879a5b61f8ec2a8103b8ecdd25f1eba931ed139b1eba7ba0b240e14a89fca25c58d689001d7de027d07aaf006bc722976d2970a3a424f63283284612e4bf3f2bf285061ab7a957518142aec4261e6be410342f8a8f49892e160f6c3fd4cfcc5c6000955221397307c71be4ecafea51ab17b8848840e17d0534f358d50be9c7ffd6a2e1e337755ad3596a2fab5bb2d56ae7d9a1d39c7363a663ecb812327c2d4916935e5c541b4ea9adfb27aad704eeb9510c361872a931a9fb1f827efade13d1ae66ff5f107c765233b5a10e728061992dd8764a38bbbfd0c5cdaf9eaadebc7562a0de62a17013d962d0689c342eb2557fd518b9bb39c418e23e00e570d098446fe8d1d18229bd5d5faf2453a2b2ff4c08e6a5d94d5890c37151b033faacaa518d9d20c91d2bab14663a4df3b8b8812cc72aad59cac81c2da3da1a5f4fd44926084209580d6151507bc91374c69e29efcbc35b20818777b77a18e1e7bd216c77aa1c5232c6234b59e6736a806434ea7ae6925fd02459ec7b8f8ba5f904a3aeb30f21fcaab8ff939a85a63c083acefc0c9984559bacc8df46e03f176e43cac8c9e6879027e9b1c7a14fad33e5441550dbe52075d083f31f998d1637c513007953d89278efe7c739028665e952e4b427cb01a07761e7666362e3afe64def2a85cdde93c7a02c8214971fc09c31f557e86f38f96b32331493c5985d88d7e2d7220c6f9ecc5a9f23d1ec78e258862f3a52264cfc737b58e69616e196a632e9a5889b59efe51a4e0e862fd10f954e3d0ee8b6b89d7e5a8ceef0e28b03b00dee3ddb9c5f5a5a69b42f30cb42af875311fb0dea3359c9f2758f85a7bc545bd4fe9758139fe1388dee7a773bac33e21c96839dc863144b397a083c26c17e0a5caf081507ea6b6943d7fdedb79ab3e86f825890100bb71bd7e46c968f5ed028e14699e71dfa1a23b9efe2482e62677a668e1082bba94df76e28e774b870d7b0d02779dc9dfd0f160a3303359cae684c3efc69d35f165def547e88078298551c91507a8ae849afc652224aa2dcdd8ac39a38d7644c2e7e39f0287891e574bd16e366ff879b58378c76ea0dd73a34b8287a5414cceb0c5ec751c88bc23ce600357d52cb3ff7c38344cbd37385848cb0794beabdf144a480be00c38337ba28c08c48cf0a1d031c41596b8771653876342b9ed6dacbe5e3a8d252e3a37299c4ccbee441080ca7422b6e6c5882d88a17badc8f7aaacd7499e09ddb97c5b79296c9665b6a6aff5f292bd6dea6294cddf72dee05dd63b1b6a6cda3e1fcd4493a0373279e93f8a5b18058572b1d250c38aa25e476b008eae30f3d52bc70502fdf36a94177b8ea0486e9d6f3a1b3667f5ec64cd1042c55ce1903769aa29388d5e2c12f1c5cd047b0861a43d71e1c00b0be30087bb4f5eef6c1b1839be2312e67511a1ac1fe5908bf74b5d8609e71bd30c07a2ced9d3dcfce4557b23949508b90bc8e03843ff4405a98ede9b91d03dee165ab3dce03c869d1aa08745cfe77a2c4c61bf756a8a2d2a6d053e15ffc8082345d19e55d60c0c85cddbe71591c48e870469f7105c06a3145432ba6ec26008f923c188633fca100c5cd34323cfa8b742e523f3a1335513216fa31a07bacbc791b6e8db021d218677ef6554b8611f506f67cafd6650b75a82ffe6bae230568cee7e709ab41f685d4f5828a86635b2fab2a6b54c800a53e9a4743817eac66fc92581dad55dc6b07c86dff783361afd5f704e5b634ba664e27ebb5f44bb33902b1a7f3062ae0ffc750f6ab74e08c1cc4a772041c65d92853c0b978b7c18223056cd80dfa359cedeb65d7fe77825fdc9fe24eae973681f7d1157d2dddd97f7837febbbdb39963c9f1cfbfefa14d97c943a8e9cdb2a4554217f232fb4f740e5cfa8d74e6db400b3c9a2b4150e32eba978bc4d352b8459cf3f22e5b196ad1e5946a64c3d6595e759b8a18eaa8b3a66de03eac5d29cb1d9429caf64c52a47ca8145d51e74099ecaec626f7da780feb940766a776a8bdde826af81c49ca974ee08e57538e4593ad842d6ccaee69547568fbd2f010086cb23dec9bac63ea8ed62f4bcd862dbd2e58b84a4106a2008050efc436ff603c2dad6d637fb251dd2258987c47faca19a766b5c8f9a10591daf293b4f9ca767e8f42caf98679ebc013ff028b68e4286cef291f5bb04331ddb4f494026166fcf25a166f37ce02277449d5d547d76534f19aaac517534f5477373010a996d37ce1f5131ef84978811c49619c1b46a80f7dd38ef827e08f11ed7ae5b29e1da9ef8cc0f8e75bdb4a6cb1757d92f694444f76b173531acad8a1be412a8920860e22d474a6b8d4a8d635b9c9cb68ab94a1e4010da1b9764187e625990d24cd9fcf3ba9459540ca3230a2e290c80acc3b7d35b0ef6038e9e1a30e3f6996531f6d432145fbf8aa480b285deb8884fcc92572dbfd9f5320bd1e594b18d913caf3341877054582507d423273333434d9c30c6dec4d85287634b515eea9223dbe3bd8216dd37d0b920b3dcece2a5a155ebf337e042d29b90363ce4af688ddcf1e0697d7e145f455557443b60b0e02c6a2bbe02dd8a64e536e0ecefea19b8878c027ee30150bf6625baecd7fc120ea074706b81752a097184cc2b1bce9b81285b13b5830d3685bb1060c86cc806bcdf2d65ec4ac937c80f4589facd2a8621ed20aa390074abb63d9e79c440c01a5ea9274f3bc350e8f819643c28d318f48c1a7334c9769944a853338a779f778308b382c9d6e76649d3c476a0f19c57e370d3c22c5343dd0f52a38635034bd897584c3ff593432f14b5529adfba7520db41559701d3a822d0b9f20e8de6fe4d43bfea0b8b1bf0446b05c08bfba713c02aa378de2546e67cb2bb1d5409fb5eb109b4c43dac74381bcd4edf7c1d8e0170e0a804a857618c4ccb87b38ca2d6dd555e0b440cd5287f914ae5981fb8baf8611f8008dcbfbb897994cb437af7c15239b52faa6ab7e60578181eeefe92a6a19711b967a9296cf953610112a31b6acee6d5fefbb5239cf4b6eb0d4684750b36cc8b5d579fe232ae34581a383738df78a600959a01dbb50f62904c22806288c111c96a87f6a91b8bdb3776c50af16850ffccd4ca10f2617d5634e0f6e3a4eb3ed21f6e4bde1a00e083863551456c6a840c53c58d4550d48ec3d11651f9936dba0083b3133dc07d3d23131a239bce2f23f1393ff7f70948763bcb284ec2ffee3a89ea1dc17115c5e6c859243f0b0cf269cc395314469ab57e7970e28867c9d85229dee5e0856413e37618d1b50d43ba65f5269a09aefa1c811f7c8117ff0089ffabce85755f2dbb4e5e442b363078c4ebf904bd8be0db7f446c91b382efadacd005fa3dc530249f313bd6eca3a07af543bb766f775ff367234e2b06f1830510e91f0b50c3baedd789b5952f8041543ae6af2f0e1b2d2831e9321234185f5ec5dc57071774111abcfa1625877ff591040c93f1d20f07b9554321b0ba9a5f446f73a0bdea49c0e12123550474db6894f72897829cb9bba61c7cfccc0f8510c5362fb58ac5963bc58ececd2832aa67ca3a5af8f53fa5da2078b33eb1cc201f9ff02f80c420a772f701c46b32bd4cbd83c5809dfcdb7305bb72401f33cfce84fc138f659bea88c8dd90d2e6445a333f26d95f88eef521b3d996aeda73010b9f18c8b20a4f33ca2b75da56b5558eb5df7b79a304e6cc945455d5c37a132928f22f8a1ccf9b82c2e54f9fd7ed695cced1cf3c9a68eb49609e1c6691e6f6d2dad6fe762d6fd54c3367e25167233bfe39a95a4880a19fc614fac3b2b20c6054ac6adf4518402995f8672f0e8a499dcc2a8e397c33033d05ca4b988f31882d245050547c214e54965e78ea37bb2a38cfa8d1b58202b0d748ef55a9a051b51de689815256d49f618360ae11092ed02cb7829b3fbb44bf3b57a21811a66a898226cefeee8cec08683f2be3abd946258eca1607c484dfa82eb7579868a295c1c1fbb00f4d97152e31c7d182664d5a31db99425833ffa4279168dc932460e71860a8c99cf24f46e1220a5a45cbceeeca653d3830bfefac2aba8b3d3543260b24147fef113f4110237fcf68f6adae19a57e687340dd76bb625dfcde5cbbcdadfb9618ef9281acf75f35bce78ff0b85b28d5260ff9c310bd5f24c968b492a41fb41a2435a485b2c886410adbb51d3002776e29ace0263d8b36a4e9a7cb510a46205062b44e6b1ad877dc5e3e5ad353efb154eb050afa4c401499aeef28f698b270e746e42975a3d734dfbbe7f87cae1536f030f269937aef445304fd21e5a746413ebcb9c6da6d4158f1c7834ad92681985b8264ae1f8ffccf9b7d3993ec897de785b801a96b9391c16079301d842de5328fed7287d3a60682b5dcc0261cb23bdb69107837168a0bb9926965f92351983559ae69cb132ea258190fa7490b67a2096fbd7ebf08f53b49ff2ee0bba240fda8606927e08b79220b853076c53ffcb571864ed77ee1431a1bd299b0cc38b545c81f7a06ba0c4b14b3f3aa817d2e3beb574b42f3ebf1e08993d988458c1c7b8b8a123664bd8a2708aa21132de0a7b8746c1f87375c047d3a3c46e28a11979ffdfbffcf14e47730d09f036312463a76f2a660a2a3615f7c4b04da990489fbc9ac43a735cab2b47a1b35834a73e7c7bf27d2299960bdbf64e21818c91bde899e774b9cf8d04787e89af871f1ee3c7a485af18f8593e628a071fd229b02a2a33f7b1158a0f2917bf99642a36ead8f2cfccd750526a2f8f86bb8fa29d064002968c888c3d7c01179f3ee9a8e02b3b79f75c5503912af51797754ff69ca43f02e40a143e7baea05b174e204073ce7c67063dc34254d5f3a2f77f6684008f8db62e5ebdc2b7ca984d4737c78b92ed425adb1a3e2ba42dc7be6fd47e81d8b91e7a66affb13f8bf5a961f505770b4d446f6773b0b19652054d5e7c9f48e796f7fae8502e36e71b254b09ffca6b06bafb65f18ef729c3117f0e5d932769080124df14528b594e0c163366362fb2fda4dea329f55ad872c972f56b0ace334f61ec0109b1d77b8fcc0b0470fbc16357e734c59aff17b90443949dc3b9e0240461b7ff834898a5bc1c002a85004c5bf2a594d3ee96957ff7590582447ec0d63bca67fc4abd5cff8a0f46e3c7f7b8da0808a159dfb1c7b49501e5138010096560032345c57e92651bba01c360812955a1c62ee9cda1c0f661ea7f5bea1cd1bc456b6f8bd31393c6f59328e2655550e1a133d693d17f7f0482de5c29f6b69d5fd29d369a119479a37c5ea237b7c09fc6574aec893bdbab08bb1429c568d9f8e2c764a12a7988b434d7395fc35577457727eb5b1871797f17c1407e2b95513ae0c47cfac02f48200fdbb69f5a160e0581ab9dfb31d50d31d6900efca67398edf54d176c285e6f3fe1580507f283bc16a9c4b6e522a679c2dc3d8526e6caacf95792891510624333080858dabe1f5b388b58f9a8a766564bea5ddd553d83111887d4ea6230565f74e790b972e4fd24c9c59faadbfd6469c05b61b41642713e2c3af8c18744015e705258d82c9bb810c275c33edd64491c44d0067ba3742af7027b3ed3b9217fb0e2df423d92298c22e348d67dac64fc98457dfdb8f0e235094b9c4ae314ff0f6018f9c030c26419feb41997f498eb3382d86cc5756b66db5928f940d6d48475f588f3c93dcaab7565ebcf07443331101a9120410c470ea878481dd5076f24eb7a4ec9f885bc953e8ae7ccb65c1c2a06357f1128c03f64293aa4aa8b04d5ba4b953613a5e1fbcfcbdece66b33794cb908ddb6cb9707efc7ce1f87f105ac342c1b22b590be70aa936eb3f15f24381c079d6b6cc29fa9957496b01d8d9ca3e1746eddbbc26c85417fbd0fca465ac30d832f7fd93edfea8025d17350443b6ebbb66f1b743eaf714b2a461f4d43120e9284d8260b9cc7027bb3fdec91e4de827f7573afb7f48c483b77f072dc495161fcb1000a4edd384a69d11b4181208a966b681636cf325d95ac6a70e0e9e5c28850ac8e343cc3f9be7f89f820649da9b5e75630369e8d7b264ac6f9d02e6ee3cac670b5c96b34a1fbb0b9310559e62dd8c79fa90cfd33229853e7abc3d645a2a4b026e113a08742577e979c8c0a8fb4168220559cee062554308e64d7518d6f388cd7b97ea16dc288487e1992a93a3a29a011dd293b26e8cbd53d77fb247abffb52e525a7fe2dbac2d21cbecb0f80b458776aba80600c8f4b1ef42ae3ebfa1e932fa9c554fcd548b9c838fd41ac5aeaeae7a346297ecbe0b3ede42413a0da4c06a6da7c5ea0f9e5f092e7c0ac8bcd4cdb734a476c8a8c4b64b078bb6a14799df4d72acbef85e1a539bba1b493e34c53571e7f329c39d6f9c9dd64048fab0fb6b7791916e745ced7d37ed52ac9048842908b739916f2a8288a137c8f6271a8e6e97adfce828932cbff986e2604bc50f97fce9a593211c373651af0b7af5df2b304f4320b86bbd514901e175429eb05cd45ca6cddb37aed3e882532f84132dcd64ad2c994166ef95e952ba3f73e90aa8048e911ebfbff7f27c24eac98a8e5acbf701fd7b562ea471c3509e824e75a7350da7e266559d06e85c8171042e3ccb7a1ce9cc969f1f45ffc27f31d9b42537e001001a869d943f7a13a3cfc4f4f83adae3967e2581ab7ecaf319d4df3c9482192989c7022e4acbad5d89ba0a029f6c71f4d705710b2165aa5955f06a6f4d71bf5a1ed5999eb55bd61d2333fc3b5dc7006d38a04bb246695c90387576314affda45692a02bd4fb384fdfa66798f2d4283edba471a91e32c9ea0da4ba1d62e8b2cbe3ea30f4e041c6d792326afa5a8dfcb772a8f7ef535e4dc221d238fb855852d7646b457f3e6d10ab0bd4508e7b95572fce13ea7deac4e073677efeb09adf964912156b133e88f229baf25e1b06f43c3e501b3f990f2237c5ffa6b9d79718d5e7e50fa746510e9e3431876eb64af8f98247e11ba7a9a50cf4e44e2b0e616d9330fb0d69b22e165df44862b022b61f6a1f6de474543b6a67106bfb9d1f7110e7a32d32ff558fee84d669d4308739156bbae8c408d21e3f007d3ff2cc3ef637f1a0ecf16170fb82d756f53fb110593279656db0a512b68d99fb5566c0265faafc5bd0698f6448c9fadc79024f428633ab115efe355dd8215dd5dd694aa92a6ba44f41fd035befa33c8661e6e6f415478578c880df9a7a8b02a7e2b7c59ff83cd5053f60f92a9f4c95955b0b0b11d8115d3769d911557670339b89129b7e66f4e47acf670f4840f6686454c02f9a46e435a1c4df455bcbd8daaaeb300ff317a6869e58db8baade3883bcb2dde634f8184aa7b645be90b755f7364290bb08302ad1b6753eae2dacfec6780c2fb706f28362d60c5dda89ff72561c321b1fa660c59c2875ecc4e392a972e2cff6ddc555c0452b6b5332d04375a30d85f35c5bcd3fe276b46997f303d6a3858153f789e5ba3a751ad6a41a833f21d37e78ad02b341dc77298e5136f5cb5eb8571e6850c91d81f845798a1c3b93f5968d37d8f73f59d637e5ce3201b49ac1c0d1d3ccb45adcddeb63dc35767b9c8f0fe55e261650c4805dda5f3072e868ce97e5c2a3361b78c09c957f72c6c84739bfa5834365dbf077e321180ea678a5a3a1a013722521c1e28e25d0c0454d45eef4d2c423454fd2fde7d9e1c8458d680d74935e18966e5e191c7e0fd388970d494f2ba326eba014c731fe607cbec150b4ab02f3829e31f5aca19a5d6b25a48fcd41f8b7bb771a7853ba627c339a87fe657f1174392cb360ee69635512e5a41a8fbe90a0a49439d3cd214b3cc6f0bbb6daf84611830b3eb38caedc3c2d8bd8fee7a4838ef6e05ac403c90c0b6d315dc43c7974a8d28e6776b42f81ccd8d95dfa7e1ffa059eb8030e224b36d48d74c91e043c8c4a89fbe0450fbb901cc3a76bafdcfbf390ea3999f4461bbf4ff1835d4c491156dfc23812ab0deed157c32ff7096a80174761264a3e0263a16cb1e469f4357a5389f1d6c35ff1f9b1a4480199994d5cc4ccb2095a83a7a8e92786964ce8978704e92085013f370a0333b9b95a03712d5d5b4c089018449a9fc44949e48679f6ec616d23c983e0d09e7229c686a0ce7a0019eebce559c51dd01759992d3efbf186b759881bd2c50a87d54a103c9eab4dea0bd9846caaf655f8ecb0ac536d153d0e5b105314add1ec1d5aa452c61f59089458bee4343170577808fa8adf3cfb59f464888f5d0b9658470d2909063523551e94845c998030dd701e190c0283a50c2344b69c9c3c9ce3036d3d4770b12b737807bff0daee267e60dab97e879bb3c17d11cd6687dbba21b97f8b5174fa21aa157ec61fc15778d00469521cd646d9624298c23ddf422aa1400f8d3ed8f64ee92d41a59628a1c3fd3b987c7351a25f64e16148c53e0c353b6c70f75f2ffc19ed14fbe43bc68102686c24af24ea944e5c3e41e56a08c33ef45e63e3fb30e2126472f49633b9262cc5deedd78b2c7b35b47411e8f1887a4e2ef879de3b86390e3bc7a48dd943a9b819bc879616ab5c23d5f6a37e57e42ab68ca7d93938d6033e717e624b2f11206148d5c24d453dd0b7b55f6c460fe273c936848ca537ebdd88330c245e39f91049885a673701bd1a746007d1269d7c26fc856b6a6c0a668ae454219668fb3faef0ba295da638636fe8a04369f1398cc79d274805b61f4f52eefa4e156b55d729858f57e5cd75671afc7a58bf7320f4aa229a7d004b3d39e4d43008add51eba7aaccfdc6bfb1b2584d1c53b2125d0b70143bbc7830c839584786be7f1012887449124150e5339e6dd6432be843d0aa05de374a66f457aa1233fc407dca74323a4bbb90aa1ec9e0dbe38e365e0faccabc4c1f50aca03b0a45a3260b2ba6f10ffe3c999f3002619ffcd17a61e1fb44f18839439d94287e0a9c4ef6480dc86b52408d5e1d7faf9c09086b9b80369f1965e7320fa41ae22be75639496962f171c84643196e56ad1b04c65eefcc5ca1bd2a8a06549e6ed4db922991cb96e01ed7d2e8c88e17c5249e9b76f3aea04d2fd86aea6ff4fcb55b9916e78bdf6c3dc0a4a492440db89b79a3e7856eb87a03dd1e19e1be4b8f666b97332247bafe4e853ff044c874ac90878dcf48bcb303fa805025c854aaacdb139d352d0d34f4ea67c328810b056171b6b63100ed2491a5c3981c7ad2590055da4a515139e3108e8d109f63d4239a10bb6733c74ee8bc35a89e0a90e56691e3529569b6b5b2aab8009738954d2eb8dca70512abe6341fb0dcb0645778a684f9b9409b9426222530fe6edb62d9199517d7245cbc6efd5ac52f871587f487027eff2bd740ef3bd7d3068c8860d8711f24773f2c704e5683cb79cd54c3d4f89eb1aa774017c9906453a5cd1ae009b98e71468af20224b7b10d29edd8aa47ca81ee1918d32ce3824b538f30ac3345331fb9366fc737066c9a40bbb3d9842a3d972ac210d4e6aaebc01a178b2feefaa3ad9c50d59078b69ae90d9022d44103ae9af96f2e7f102e78c3c7a641651b2163f31bfcc802afe3e81de3d36e21d3f24ab8ac81cfe778be2d63301691dd637e95f8d164094db9bc23c0f5d5fa0cc67c8e6ee597317b4600eb9793b880cac1d719dbe4d98ef73bd254f611334d9ba105ecd95c2c93e808f648600d549027ac787b870055be319c930a84b4ea08413ad88cffe9275657f94b397462db7a8d92e6e4a9a76324d73e5bcc81f322d0e1655976ca71a66a31e6c48abf2bac5cc388cd91032550db5def3c585a419acddf621edf5c877534df06407972bc644a3acdaaa2bbaa7895024b6c333484c7c619e8b6ab19d30346345be518e104ff05d34c3f195bd692b952a18ee5bf779a116d62c90c47693f6cf09119152d3fc25ebadac2d156c02da889a9e06fb7e07e0e068be88d19fcf55d42b5cdbf2d8d8909a432ecc74c6a63abc622b9b8c77298ea21d32e0515313bf907f3be4623ace8092e3bebbb4d58e0fa935cffffaa184007f37a61665ea9f8bde503d09c5f34863a608c295a96d125b143eea542a661c8bfe3275e9fdf04ddc34cd9725d44a3529ceac30542e26525eca894a388bc3ae6686327a0291eeaef86af94d222b96aa7cdb144171cbe2cdc76a7a0cfc4e389a5add89734acdd4789788daa56f401e014aab4d97c32481ea41da0ed78359a29715989e39cfc6f7e54eac2b1669c718763ec04b59c7ea28ed36b530c027cd2416e019a9fb7347a3c897f7899fdb3764aafd855a2675357d58eb02644a844a2f7f2722247ac5ef92b41a0ba0145c13fc2a420c706022effd6034527c36cb4accab57273e35494488963c8f7230ba2be474fe7eb5558de00cae0d0b996b4b8e855be3252814c8804bb4f2bf0fcc6eda41dbd36309b9e86f0c6d4655eac84b8f5e19f571a282d3e92cdb986597667642c6bf3677c9db29a23e7fac2319b45b810b90dc009dd31779102649ae335417add6a23f0d185e7ab2d22ac7cd329c4846eaf9ef924befd06d164971b28f00a974742c6bd41052180083b3f5878d3cb454b45226d05653fd7b4cc8be34b7fe3030972a1e6bef888b95d7a49173af8ea42fbaa1025ff4ed75964d9ae65ecaf3097badc90bcd3f051cb9890115cb1cfabf7235b0ba461db87ca1811a53d8a957f0ba86caa74843c63bc49e45857475cf17a3eeb7dd7125974409ac82e0899432e5e7c8c544880c8c94419c6ba6288912b77f23fbfb359607ccd3fc60b217dc789498f9af63289a19ad6805a54a8690ecaee9053dc73191cab1de36b7b0be7411c809d8f4d46d7bb89f073881141db84d1a7c6851bb4da39aaee722bf56ca3ead827f7e7c5c0117221b4f0c449bdad37ebec00e810184d5422a850e9d465f5bf0873769428ff8a89ee079f1f8934ddbe97ece65584f70c1789e671a538074651e1e1b499d6430e8af7e76ee4cdf00bc411aeddeaf901ead642855958d504fa899f175c9538ddee51ce140d930c983d060dd444692c25cd00831a181aaefd3f453f3b883f7c06e96311f75ca0d91d39859c72018a5628331346784f51ca447cf59571700f6aa3b785548f5c3a50cd6fcb16f2720a6a422debaebdd7ba894be6882d49fda84da41775a459a571611a9bff258a006928146fc9004142ad1e024e1cb8fddc5dfee89c16efdc2e2592d0ccd1bd4f2bad8c0ba63818a345cd591dd693a394f8ce4bed1e82c05ab931e5c0fde6d5488b0a0183615188c027738c73a5dcadbeff63b69d374e4cf7103c2c1a93530bcf345714905dfd8d61d3753b2619f8de2a783ac39e3f7654b1f75612e2a7f6cffb3c0dee21249f295ad9efe27864bb79457836f64eae6f53410b706631a3158f7a0ee975d89fccf1670b4096abbf5cbb8a7b0b329a83972c7235eaa2124f8ba9d3949154aa95f8499d3ca09f1ec603f645b03d1e00cf830fd770ec63264e9a5954309ca0dd8badc3d1c2370b50183ce5d12354b26ddd322d0c49794083dfbf426ef05785a140d85dccecd3c896be2c5fddb57f001a0dd6c5e92cc3f4798572c3909e59322626f83269870eedfb742bf5571c97a75a684758151c3b3a52eb1aa116651b8d040e4e2888766c584aac8983b868258aa66faff070881cface59a43ee55cf3b8a47f5806975b3753b645db82180be330c017acd9c8201277b3cadb691d55d502e70e33271d01ab17b73a2336e328f9e88aa5e4184475f6b07035edb2e4014469009b26c1b5f099e40f7818ab7fa4850b17bed5828182e6cde30f2c52f36720b833f4c85800cca746a20e1dd3fcb0b7de7893971d48297387360952c6b6b35cd38630549cd8446eadc3fc9141afc9957f5568cb7f2298577a20fdfe7719f6a00eec4dfa82f7ea2a38cfaf7452202cb5b4f13a50396433e90007359102f7335c206bdfb7485afef3721bf52d311320d495450e93728bf11ddf668debe7413b85357736dd384a43008cfa8cbb30c6a8f387e9a48709d170771d549ee43a68d5c1dfdef8c3b48b7f43c100516e5d2a8a8f9dfa6467b5499a116a35afc28a66818f47105838e4314574b6cbb5774656fecd68fd29d6878d8aa99b07633ce218370f9356d1568e63279ce7c7713c01ab1744d0a68c329e6ce19dc7eb7bcce59ff85c546f64800a6e995fb0c434bb04d2091a8ef7a64c1c0053796fa827e174bac7167f278f19e21910d4be79720f24ee2083b6da33f05416d1a649d2cc0f3532b0d22d703fff58f3de74a3ef063ef4b3b437286dc80c3b97c695cfb900ca8716f6c2c580010260c56108ee9101121ab674409f4bd0f2f6f44cc2f1291f4f7d9748d1b74310a0056070e4386130bc774ece8b9b7046e519ba664142ad01d754936f494f00d6d6e71c2c8a4a004a3f2d48770d123c947088fdbd1966272765248bc1abaff575c5318b096e8b2bc441f87f222d1d90a58bb52108519c0fa119ce0476d9fcd84cb424d4efe465513c62c1261847abebc73b561be263a7545e2da332581da0d30bb06ed11b4dd040447f7d69a50dfa90c457ab3caa34a32032a9c0d50e009a0be82504ee6900a04a30f6d3ba1223eabd905df3d5b81c1910684187933a818ccdc8aa1c1edcf1760020da972afdfb6ea7168fbca8d25c457edd86f1accbd0a6aa18774708c62355a8b93319ba0a2dae9aa048266ad0071822ba8722e1fae6b0681260ec400484776e3e47656d18f18deac07e51aa3b95776bedd533d03e1cb373962ce48f7e01b63ed8643cdde9d1c25c448384d9f965fa7f671008f5b079bbe4ce8e5df3355be794249118366ad5c94e776ec266eef710f2193fd02915ffaab3c7a9c35b4eef5ae6d5155920db90d5de149b8f1833b905bc4d97d4268df8ef017a58a7b48546b02ad781361e0d6e78666dac1622ed15ef3c943c4d93b5df064aeb52dbdce5c700215ce5f066d27f498fcf04d17c593a821bc94a85b5d4e8a417c672997784f33242a7de2f4d309933336e4cab54232d83300a4b882ac533a31244476b56a81140119937f5fb9d1466c8bf692f07e92d6812940e984eb86bc9c399ef9c37f02113dcd00d887952e54c8b1f650da53a4f2a0cf30907536a0b40105d63a4049e3470ae80814215d42cebaff037b8cb683ba79d888d6d6b75b462fc46bcf45e02ae13332fb370800bef38b86ff723fb49d450b9bda8a181b438b18d55b86e2798ddfe400a36a0dcec26e2f8e9bbc322b2890189362c34ffd80e1cb1b449d46fad8759458806574cb52ef60d8c6deb091afba28ebd6724dcabbd2301031ac8020ceb7352793202f607bba397da93ef589d45536d2d6c3d9eb7d8472a9264a99b01f647312b45d9bdc1db421eccf14d49bd329d2555bf514cc5b99a0720042317b4fde0a05fc32f6d6d52590a1bb0c01f9b44d30a55d2d6a9b1c147b163de373997a2a642257c635b3eb86e62263cb8758ebe7d9eca3fb501ae66761a6b64426809835866313ee360eae5d17924e6875ea481dec19755a7f80f1b597a54e1f52e29b4b139e7a44436e3cac1b2947eb3b11b48fed5b76850dbbd5fdf3b6d0d151a49ae21db37bd03061f32dbd99ed604b940e4414281d4b33dd7a3b6d1942576dd2267a158d40ae819813d77e79179360add7a901f7be2dacaecac0df631c40fb3db43414d8c91fbd97874d177db42520dfff5835a07a3d45cba3089f5b7e51821ae7b5a6099a2fcd95badf67f78638098d1ecdf16dad65ca03d08fde8b7b6518eb6deea6a159aba62f48de04009f780fbadb2bf5587c22ba2724edeef64b0cd4e254130ed16d6992c9bd72e491a74086970c01e961144694a445a2ad540729faf585aa9e33312acedffbeb1066016b6ee44eb4a3224cb43eafe067aeb8291bdd2b371749e6326f46542f877826787d8a58593f61901abfda0bb04bfbfbfd643d54980204b729ae3973e554b97415bd41458aac238ebd73575a99a97dd6e1b336784bdb72161a32c6aaf3027c9e2c125500330d49d417790bdbdd5ce5f05beef0d2814c4c482adbf40b2558374f1876e9042e7b54b8900019861d4e341e1eac60f8004adce3ea954158d5d6adbc0878fb20a2bbc1e0b13493920fbc51df995652f8476e6fae480c85cd96b778df8c01463920e90f9ef50298bf3fbc9d21a45566ff554ebbccd1e6efe32e3d1e0040d58b6705c011e615a1087809229a44e07732bbd0fbc96736134e9217684514d2890643346d256e801d262c514dceff9cd9d8fc2ebd79b77be060dbd52480c31788e6c9fa9ca371d56391f7f30ff1a05fc70a82cba910f45b2e26e025977be3e33e89ca8ee3d046762ad3b43df9ab639d1b57fa2597f8b2cdfd5843d43fc851139ab029aae62ffa6b02e781b49e19cabc33822e586ff4efe26ba91e78f91ae72217caa9e5cc635506df8af6768a8eaca676e9e5e0fc4b2ccdddbcb8412bcb483d9c9a8c7a1535cce8b8184b21a36d9fbda770f5fa1b990b901c996d17e340005968754d3a56147caff357a4b0e7cdd5221434a680e4fe58074616a219b65bed0e82305e7c7d9117955a5c11583c529e7f37685528ff2c609917aa073cab46b568d000d8fd53dc8e260b3b1b920d8451997cc73b8b230fd52c710ccc00e8acff24390bf9b273910124a2f4308d3a48077d9211422f5aa8ea214fd6257b8cde80c0c28583e1ea16d0c7bf47c7979dc7ac0d726e17e11b298622515362ed0f55e92b39d396409a24ddd57a3b585081160a2a9a990596cd1e496ebf4d85286e3e356aff103551f86a0dd8dcb20b0230f6adfdc716cf4f68b1599b9c2de237b3f6d52a0feb09104496e8e85cb601a0fa21df2483c15aee4754886182fe28dce59ecc73d101b90a6c2a08ed5c3a596a5eaef33c4fad078fbc05baefb7daf4d5e494c8aa1da707b7c2936c1b47f7bba1b6889f03a16d0ae660010eb1a6c244fdbc2f0558ef4e55034d84630ef0e2c9941b8f8c991844f3ace7066cc608f353bf11888513e08c89e95a1bd98210f74c24034d5c3b5e2c183fb07b5b7a5022486402396858ac6806499f62a55cc9ee8a28e15cd628a35efbce94523823b34c04161408adc93d9e77b1fde31a30397f5c92c6335a560dde6a875026621f5052ed969577a65412ae10415bde129128f031359603cee61870fa0cf7ac69087a847c12208039cdb31799f30dd01c2bdd80a41e22a1e21139feea6ad73677c49161586cb78d77e88b84cf8977bca4afdfb14c9d3f0a3975b1c8357831025de473c034b300d8e885fd07a2eb69143ab32e7ea0ccf38973659e2f879520a4ab9e24f6bcbaee67fb55811bdd44f75f7714ea3ffe2f2e726f7f8fb30ec3a6c52eb161240b8eccf0ae0db7913fd932c49fd585c662820b6cb1fded1fcf704a532604cc26ea7c86f0fdcbc38db739240665bc6314319fb7318a0a3bc7d1f8aa7a20cffbf7140759b307774af7004fefddbd04d432c424399bf846cbf66da34d6c9c7239065011fd18a9647e990c5d11ca33e8685c0962923f4939b4221f3885fffb8d5798fd414ca6374c7e8c596c7e3d041945ee9946b3a260f92aa88cc755b7de8b63c70d913ce76333189a38b813654cd2538502fd1521b9f22bc9e5ff18c58872adabbaef9f6bccf082d7b850089b82ee735104f7d95fbdd565927a25a268def3f2a0d10cac6641602d5720f2ca31143f345d0163c474ed13fc7950617d4d49dbb3c40e2beb84da52a2b844c8a6dadc27c24a189a20e796402c205f1fc097c7f73e32caf29de6a5710e10c9ff86110fe57c6ce096d640123fd46fbb05469be4b9447674a27ed325b227f287dccf7ff4369b8fb1980874ccfcba573eb8e8660d413e92a3bac506fbbe54aad7863a9e0a7c4ab56709cfe4a1687e4b55ba0c9e2862323e171f20135443ce29873276d16b3ded5decb28f73bd880fd797f41d56ef05ab5d7c62f3fea578a7fcf82833f4b9a3b3e5f5731f3f09ed115edc3008acb64465188cca032f29710418d82532dc20b40319349236478bd3cfc4d282ccf20d89236e7aa01edbf57b6059b696c17ac3999fb8068796145e0ac7e90689bc32fe8eca3915ccef92995984812af123d5cf3659fee0bf3b1298ab28f58e5d19e5d5a23b4e6d5004b186343b233a54d1e83320b42841ac841ddbaa479e110f95bea77fcc074b419172c9f8587d9e939d321f3d671692f66b9ae88604a90952caa3d16dd1a488dc58383e6a48290beff3ce0c7b0793d8c5bcf0ea39de5ce1097059296b3baa23d615adaa915ca69f4bdeab7d2cd1504d38eba535a12e8a91c36ec9c0af0717d7df060d8963c8ae00aa8cc22a7ee6051df05f0357bfcdd0c8ad081162f9fad650b7b003d85efa350e4624251ef7322186b8302a12550559b9a5b275643d178a1ece9eb5d2833319c0e87a656da0289583ef9a0429936121e0c4df4bbb0027f589ffce47670bd4a7107c8706de13084279ccab433be8b1acb7f1ec4ed4e9cce25b8ae28937e510b9c1dc7105c3b0321d9a9b8b373da4c364d3bbe94922f256ad2604fac743d4a12aa30fa3376b21bbd3b71c2833a7a49b3abd6cfad85f99bc6b2830ea42c5c1b9477dfaf88f6025157b4bf7e0adcbd46cfa41fcf10ae2fd4db5c926b0872dabbabb1cce65f281c27338dcd4d3d54e8b47391b7cb8e3b8331a3c82e2c4e5ac34fff1ad4b0aa28d805ff809159d01c67cae72ae352d7b86a6ec2319b3392489033ba01aa80434286227ce532d667691977081baaf798c5da9487e666ab63c6472344cae743e2bbbe7616e7dbd79631d289f56ee2b306bc5361115c75017da49358ae1735ec9b953e6dfd5b24b7ec82fca9bd8f5da7e1903b8cb740b9154fa5ddbb6fd8b46aecaf4ab733298719de7de3de8ff7a623ec0c787b323047092db20d38895a7a5b87ace9f030a9d885b08d8dfcdc383fe282aeab736c387002ff10eaf95292648d1ed965224fd08479d0d82e7babc6acf705ae52230bb0f4765710bcbfde511d6aaba8ce729e5523979c0f187dd518d4cfb4f22fc660bbe72232eb4cd90099d9784901aadc9c1d88f8220fcc6f77f5f6c33325d501f9ccb6bb96d1808a30cfaad3569c153a22acf5ba5422103d4c98061cc9c7143d4a9ad91dbcb4a41de3df344f3fd924622ed1bec7dc0c637bdfda41d8107a77c5fcf9723ccef8c0461f33d4eb7399c939cfa45d326dbacc95fdbafffbeabb309dbd71b50e17c00e943d10c857c803811dcab55e32e0bc8f919b3bd8ba529357b27ddb47fd0f20ecc995e61eb89f9763c7d943fedc0b7000a2de9006483aa77821fcda42f33f02b820c4096be64ae314904fb0e72de9baf66134bc80d531277f8f3786ac1527fc44e7a9c8cdf9d0d636d48960b357298b6d08f6d794f69b569dd1c7003cf66774a6c9031acc2a2c34c6b7ac8d51cd82810e393f226bd12efe90bcf9d85ade7fe8b2c3defbf70eb3dfea4697e5d3e218fc9fa57b4780ff7fac64bf96eed230efe181ea72eb1706ddc697b0e008582a9b9bea58dc553fe9e551fd0804c85c9200625b6d3821e63250ed34b89b8ad1a0083cf0b7400cafab21869c752d957e942723b79f8cec0cbc17c21172ee1c70e4c2c92153884ca93b5f5b344efc7634da1ef1b986d04fb5d6902efc4903b3a54fba23578485a7c3d3f35228df3767eab51f20985bba90be42e695a167663d3f34561199e3859d7670d2f1914c9d1a1f1e53c0285777b0a756d4e22f4a842b1d9f4cd8a460f4df96784f303426db0f2d947c43b8ed3a48e5db2fc98bee393a5c9079e2d7a23e18be88880569caf68c8c517d8e06700def197a19d125a39060634c1ec0e22cee9a300c2f7b783bb25dd2877f574448e01da81477b7972136ac0285ccd0d8e7f0c07e09ea2a856d032dd67fcab94d85dcd0f36a8e2d32d115686c19429151f536351854e63ae2f3f807fc740a3dcce7d2f777519de92a18ee1fcaa017c031acb861d928d7cf49f3fc9798b74878d3418dc7b78957f9f43d986139431bc0a410e0ec041ea310506e90ef73702fb910adc3f436bbf9904e8985c9c93b04bc0b37dbc6746529737d39bf7afb7c700748e6ec89dbbe5da042a7d2227ca7504f168566f9604b86916b05971161d79d6dbdd5c2f76ce65b8fa916029dbe7a9a2491d2430676e1c539ecd18a4167fd7d7840dcb43732ea272bf632eb8a51324e496cf1aeb60af0e9ed1edff54baf08c94b09e0e18323a042cfa38594de3028a45bc897ad874b16da6468a31320ed8b377bc91b910d51e0a4ba58ccac102b23aeb1d163db51d183f66356ec90b336704ce1d6fdba405c1d90b604abd95b0cb1e5f05ac9479a4938034eaa81eb525b2234baf1d356a7057ef1a3ac72050c1e6d561a76d8b14d7d941cb535df13d22f64d412ddfcc96a59cb4c59db14b67315fc0a7b5ff37e3d96d4db62210d16b94989d215dd658f7b7e384b812d5a65f031f25106e1abc46347044bb33e64ad59444b3a1901df30ddcb300a21283bdb97b07e0ddbe8563ac273b40810fc5f3aed49491ffe323320a6c1053d6caa325506fcd5af11f0a2aaea09ae9956b10f2adf2cc93d264e6eeae66dd173a181c6fb8edaa5af58ae0a11a8bf167916cb350c38d18a13153092df703a0039b5fc49ab8d9d0e4feea87fd9b7fbfc76174b89ac8c9911131ca9c65e38441a1e44eb202ea0deb5401f3580059ac2eb500d6023a4f289b0e2724cf371df7ade7a86014cef251eb71cdb7f3e7203f8927c796c34647846d0371bd5ee60e07446a924f1b532a7b5beb553ca85b5b0fc0a9b987736c455e062f21ffeb03169799f5bc861a0be6bfbad1655c590ce43bcac0aa0414efc32a54b16c31d8e49da54a0d620062f6c072245be9e49263f6dc3e86195d0a452671eac0497da0297861edc615b8a1e102601b32df540b177d584f5544738b8bb4f05ee875178bf818a06454f63b9de8250232a8a2c74d72f519730391d208f8603627463abb12cbf364a3ebb7ee3f2e43709f90cf94258cb37d6c3349592053edb3d215b333b7eb99b6f720c9a6d3c3c52dc3dcaea0bb030ae3a4b2e463268d7820ffae7176f946a31d4fe1d9b8d13accb915d281dde330f5d99eedc047185ff0f8473d69c14831f17bc83f382c7de0f055b8d4a9026dd4fe53606e61e1ddcec5bff5a09edc09ddb2fefb8d5875684df679fd895cf0120540478a6c5e9a6e3728d97a8189cb2e747d7e15d298790fcc3cc5bf47596e105f776ea3e5fb1e38f1c7f0949bbdac9704ebbd1ec6d293409592d7ad9390f556f333d5cbfebb589b6cd0e8d054137f22eba6494a0b37f50dd669ac240967afd36ddb0db485ed36c68c576f3b2c299dfdfd2618ed615c19f1929b0a7c7407840f442b1c49e66b032c7df06c69c90613a32f00c092ce8842db55382b29e7181482b224db95d389a58ae8a740faa1d32d3bb62faaacbe0d4907acdb96287fe4e84d264ed043622b14eed58983d0762ce47af44008e6f8f9725d65ec5c8097c4a65ccc8ed02dd0fa8859c91415586579cd81371e18af4335716b36b695332d67f16be9335d0851ba0b776b633025bf42fbda2398e668fc866cc04679c73f798576a9cf99280aa56969be4a0ccb6b5810624de8e6004aefa3e6a538eaf109acc40a3b8361f6e1a6227f2fda4a30c36704ee5766681bc523664ac29c1fe6bd9f4d88a13b88671d2c1d78083071af110c8d8f62588c62ba67579d15d4105403462b9787e08ad6e442c3e5c327fd86e6a9b8136f5ae936c3542d72ff3632ba9dcb083cb394fb27144bbc9a22f24e64405ac111e1f9e2c88419ec23742f16078ace05329d15690841845f563844049a9541b8c8647f78ac235bdcd53e150cf60a630e5e808a886bc2aa7b2eff988d640b1a06df2d51391a6e9e9aeec0016cf86073aec027dddb57d14c26f1ac40d28d347fbcf9622e74dd3ec2ae3d7b8ed884306d02c8490391bfb5dd3cbf3e209d3c424249df1cde85ea53fb3bdc38195bc358d01e20f6d6758ededc4316139618f1d19735eae54cea27bbad4b4cab9a6978aea9741c33fb32c3d592d6866ecbbfd208fc12e54c65639f319bcfe92a0de6b04bff762414c65a0cb8526fbb960aaf235c9f22281cec40086ab551b6de7e3b96a2fa8f2c6ba15ab5fdf4c112eb94cc9255864e35362b066948fd60bb66b1f0e4699601c5610b229bc247e37b2e7deef9a384b4e1bf5996b3e6d50820d061d96c54c4e699fffa0b42eb8d083da2e12d56ba6d4a0f0db4cf4a7b68abbddc8574103a0dd99056c1a3d5d86a716ec7450e1c939282f430ba72c456f22e39069a7cb0c297750d8cc266033f06ccfd169b1dff43470bd426ac46c044637eb486ce4f7034146a3735ca0957c5828daf65bb7729bd21d909fdbf4430952da4aae38f10927ca5bd115b7b77e3fecce471f6d9259fe98ba6c1f8abaee11149ac7def48c440663a6f5b2749687a57b93fb4c0e53e582f10d594e9d11592cc4221626c1aa5205e0c813977bab27f8c5ec13c3350315a22970f03517103caca4798374a03b233947d982b53b2a929a4a5c91a2c9b04f4596c5923e2ef3f3780d7c81d30c27c6e00e6867336a9ca0d168545e4f5da69040daacc057771c2cff8d8d7acdffad1a9bb2bae326da5062cd53734ad9e04b10dbcc30d5b20495c945fd073389e2c518eda572212528bb64a2e83635bcfa8412a93fcc8d38a8c9c62ed8667034bae16a10f31c3f6359ae411fbe53e3de288e31b31e815270880587dfc8b2facc228595cf2761cb8569a0e3dc0752da9132472f3f6fbed6cb4844c2603431ca2127ea539daf13c9bacf36dbb9e4a4ea054024b042e4e887bb63cfc17e1b4eebb904ce176893103e4d04a82e27a26b9bcc5c7d3cb736d79399021698e3b956b6b529ebb7ab86c7e5ae3ee62ea5c7f757b9d0c50b5f136a1cdcbfccebf99bf1bdf984a7b73a56a3263475edd2358177aef091e4424d35a94c3f01029d14f9260214477f5ceb974d9287d8fc2b3039fa9a23ae512132c696ccff5dbfabd28c8a010089e23e4c879bcb7d9e60f4e754577e0094f94cf39eef7a4e61764a549e07dd059277ee44fab440ddf6468746fa1d9943423ba1191332527d3abd0a4ad88de8d940e1c1f671015dc141e0d19e010a2ed7115a1b0bdb5df71fce78ff851b298d88638e9d794519a3b5782837777f8746af36fe0f37e7d8e9de6d047a97d08b5435068318a115f208a7fd061d62f0036d97be33eac0d398a79cd1ddc10ca8f89157249462a3471eedfda58e46b62767310ff75f8e86c123386557d8786099a9e4977f4dd3e3f2a71b02763659ff20ad5ca8b87aa710c15f807928261bb5e1bc56cd4c918073f255aff61e132d256c7cb777d7564756d4508ba6ca5186aad8a140e972667a854405bad0f0ce8f40820e62aad5f26497363c7c2e934f48a3779b659817c6cf9e9da1b6f6f92385ecdd79a36da73043329bcb7c80b6cfebf8cd383bbd333520f1e1d357f01279f8a05af68ad6613a9e70f8aa8e89a4d8a4293f558cbafdfe6a085e4fe512c9c7fbcec73ceb5856e5c9269443d736c748e1d7c1eb407ffadf5d5c280dffa12ab783261bb69d2353282fdb48b8ee2553bb00883ebfb028698a4b3e0b90e41d916131b10bd3d9f76789026328ba2885fb5537939036c13393b4e7070f2ef77dd0fc5dcf43a74cd4d4e9d45068659a1b159423d29af22cc97ac4e1b5fa79de36c107d69c440465d9d9d58c1f56ecbb6012274a560df85755598cff675c652a3d6d171c5d93ca46e7b18b6927841307a0738b65a04cb08cb1a935f329828d418071292eb72d1d86fff476c161651915442a5d4b8586f715778f6318e010c94d6e7ae725420dc8deae6099acf1bda14a2e01b1c2f3e8f6d69b69273c809f02d65bef3e48f06f031f58a9c7537289dee52626eb5363a5f06c02dcdf3534e374e0e1db6367c68661eebb0e2bab8d2bc236b87433abf97fecc98e20882e13cf41ffa86a0406dcf968e88914c38d7e84e7256de21cce6a8818985e77f8f818db74ce61316671835b06b398a4c12cf11d6fc8f72ed064a5e0609cf71459382266e0a28e1f9329083a24ea28bff9cbc53826fee1f3ca49564770079add36ab5c073978fef44a93d344f18ca4d7921a7e54c993272bfe6da674118b6f270b142e29c32019742c313d75f8b66b60f9b3fcf47acdd444a211e79c9cef15a5ce817ec007b0434e2a7ad9815bacc46b07873650f01da7fc8274047f1bb8f16af64156e5a3c2f2064d731c461df0fa716a668dee2d0fcb52beed0c26b9748cc964a724eb6e6bd0c5ba195f419e6c65d72bd18ea5fa80eb2d7cee10b5ece9f01b41a1ae2e3fed3ddbef5b597a5e69f6f88c8afae6c99dfe58ba10874897c2790c7a0387a2b5274ef0f65edc04ba3f82d1bb675d594cc15138d1e4a0fb9ba718ee1685190f0af5a079625c6ffe558a071f830f6dd5af092b8b951ec4d170abfcddba382aaf74cb7e6fa4eff83f800c6cbc063123508ba801bf1c4cebbcae7a766b3e168f884c2e37b50a699a0a8c2721fffbbe396faa1d8ac5a30349f76ceac5e60a305d0c0a596ba1e617a7acca7753c63bcb3aa28c5c319e331c36e2df8c0e8822fd3e85e7b2bec63698b97b897b4e5ee8897925b6919219ee2cd1f6a2771b49cc994b97a477cf9f9f91b0569d6e33fc9d23151dc89d6c98d74dde7ef965d32200f94c95dab9f75b7d00ffeb7923769e1c2d730511a899941cca0cfda3c654c538b3379939861b2aa9595e3732cfe7ce6dfb0b77b5774a87dee74e7bcb38966d151e16c9a2559519c00c47c4404709481ec818729e69e75f045952a15fd5264ca654706e58e420a0cb77004900f5d4a3dbdb33e9eb22dfdad2198d4ee0b27431cee27dd54116f6507c1a3d375136203674a5f824b883fef38450867e889592dad9564e116e2ac1faa695ec198f2f42378da8407398290b8e3c8f48e1282f6107c2af899c92ab08c4eda40e4dbb03b92d49fa23a73833a0edf453b2b3f24f15ab9f0b7b3cbf17a3e66fe096092914af3b0f69090bf9998c0bf0974e0b925c68c26539441e7b8d349466571943cbe83e34e42f6c066970a7b1394ba70fc755863bd44066e1b603e9f54b8a353f4f428696990a4807865ac6214ce60e44cbd9451fa8e0455c2ab44adc8de4e584dced37b29922cecc730ef62893dc90e82b060573e67637760d5dbc5cd1b9375bbd78a7a262c12d55958fd93fd4fc83bcf9c1bee562087168787192a8015c8fe4df4314f216c8c5496cb095cffa05579174a9bc2e2d72f4cab5cad7bcd1075d8d4cfa5bb1617b667bd50583f6859cdcf66e2a524922e693af6efaec0c9d395a6ac5646a5347c3681a80b72c4e1426872147e9f89cb56b5d440aac2014e89f1061d2496d2a1b983026807af1356e6db2a69a41038c36793a02dfdadf7b297ed106011dac2fc8a83c9d6da4f3e1b6d753573c88e88afb169786863cb1956b6a6abb8af82fc9d1add4547796ec58417f0d64c9565115afb51ea42bc99f46afc7c01886c6dd171e23fc47df681b877d656dfdfd8b260bac671ac2138f0ce1b56ae560822c935d566337a12785c3b4be89e1e6f2908cdb6dfdbdeee7d4f9d19e50272d2aed9ae054c5e11e9184af95c164b98ba01539cc10484154f3ba006ae394bf49d59aaf6c09b8a58561982cf19073d58a311ae6d88df4b99b3682e4537400fd5cf62fe1c0aee6e159524051fdcf2df320f842b2619ae8aa20680c09a90317812ec9e27c40d8ef9b9ac16b41ae181785d93fcdbb0a5b16dbe863f213ae8b17db865c8bfeda91633129a35667b7356698ca246016f56984de58a877783f4f4d7ded5a2afcc4bfd58189aa66b6f1e9f762ddd05c86ee39c7d41310998465087851a59231805d495c674619dfd2331c09ef5df41d3aefa550241d9bc0f32302396a3651ce06d69bef3dbfe3d0980736e69a3be32ebdd7cd39b5ebd88fff937fe5953658ece248e708f11d81344c2dba7690bd877453e8b7b37064a5cb50c86774de5e6a04e45f7dbf970f8707f40c47724f3dcefa447017740225edf66d68741f279719e70b891d2d465675e2f0cd0e9026e5f41adf0e8772427934f5c3e941197eb5e5ce93c152ff25430afe7c26f6195f24a2aaaf8188e0d02dee9d5cc13307598dafa6c4ad0e783d084b421075d316c863aa8ce51fed8e6c185c5a980fd21564d0a6340f648e65c67c811fe9e8471d46f784c83f6927f9788ac7671a41491aec1383863f15c5d52740d25d8547d53f2b8cb28fc4a57625b89d53078a8b3ba25c79bf407a6a70e55faead4755c7d56ee324b02514a955a5f8f4bf05af56f3821ae870c4f33b158f1f8cf154a733b8fc5a9bb81f911f9aafe0142e16e87680b7bfdc4103ca38904cd3ef6cf40abf8624f0e05ab78a5ba02830a38c64504748bde09043cefe49d1b5f799fde48252f9e0260b2a557dbd3179b809d4ac8ea5009ee9568f34c141fbb300e25ceb599fb40fc904531203346332c928de411474a80f68a8b9d47046a388fd5798cb3439cc9b4cd0570d9617078e0061110ecd545ebb7b2527c941c358824fd822e2132b7b4eae5e3c8a2a07d101598d137786fa1e9bb30b4d3663c1664ce044f5de6ee028f355baf047f3dee955d99c6c9222ec10616b8603c861d526cc25ae52bf93dda1aff9821539b7d5a56170d6c924582f5692174aa5cfe085b3fb13408824d91b0ace05adaea111ae1da585071dc4a214c1be59e50ffcaea5402d6b32ed9c148aa95ff5bbca1021d30eb0aaaa3f4cd97126992c6a67266deb9a52958fdc7d658773a24bbadc14395509ac0ae38389c7dbe600a2b12bfaa58438e455c8203f6bab873e49d72bebfaf1d6c65105e17d6a27de4f46eedfe93f7b100a4dae3473ce9ff01660074e23cefd405885445064c564c6e4d0c32a491ac1d394f9983e1e7f24e832ae9dcc8ca216014356a01224aa0f814755515220ba9afa8a5589ae93fe8bfa84eb9df8870ee5a0e4170217a4029da00331768ec444e8830a9ffa98388c526448e1126feb9b46d2c49558204a68e2e1007e53093dae3ee571f14c3aa4af2886e51b57019a2100aed4b9f281dd3bdac992b2973ed6c844c8debf2afe3648af7f4e8e4c7552b6f1a54728f38464b1bfde905e58a7936492b313f09c7ad6a1610b3ecab1a0d7c2e161f579162c970d6e5a2372089142f3d82ae52e1eb1f27285d5a696b4bceec2205bcb0d56eefa99e87dbc77bf35160c18d6d07a670ad5f6d4b8056651205d5cd0ebd7b432bdeac3ebe589f80ac0a7df68bdeb06e454213f90c312dcec5379926038fe47505e9e36ed91f227007824a67cb1d22f7216eb340826f6fe8857a2c80f760c3f9749d3a804b20734354f0c6fc06b7a836ac59fcc78b58f84089202df196f93bafd809a88c068b712b2cb50e912e679983fbe56987f195647abfaf2e3d64d9e42567bb720bd3e215417dbb358ef4509d81067f54fe07f4451023dec56c968b8593ad55e0190dfe1fdce41786bf1cb38a52c9f5782dee76e4a0ee7ac8054f804109bade0a52b6d4c16718e93a0ba549ca8d4057d2a68c0a391ce19301108c09dcc48f840841e4cec066a28d0d71a750fde1adf0ca4d707eb400ded21a438e382cc06903e050cbf3e99cc99bd6033e7bb2b85e83b38ad8a19e5f6be1a822d3b9ce3be29584df36a4f4fad05d9f37f348f91e91a3dd38b34ac8251f9d8da2f3ec1155b52489809475609a3db76bd13c8c94da8e5dd03c07ff46cae199bd30604678f1359a2d3a7e7786ba2a85d3b874265e80a0ab8c66d3e7c0358701f41338974c6465da4ee86a8480d9c6585ba53f389032569bfa7f1a7d59c5456ae58f8491429b5494a4ed0b481fa1918b59ed64adf31160ac4c4b2695afa243e4e0c691c37dfdc90edc0cdd01d9aaa804e35b6e9b707adb0c09676af9b6af23d56968c54f0ad06e07c194edb5326182ddaebb92f944c24b45171105c9f9ada6d6408defeadd55eebe0b5a03aee9b73c63c28399cd48f89689f86acc104558719eae69d9c2cde7ce484b269b531a6fd25dafae05124ec9460b43f77185371193f85adfb4527ac256f3923850425eca60186ab8bd1b1ab46f54e771aaeb53da5bcfb28b205a00dd5e14c8507bc0563009edc0e13529c9d25fa42792fc7139550e1471fb396d14945c8dd1d74d0444fc621289a83ab7076e39ad9182791662abec7436d15e8921bab01844420ab414d9d693260a4b717b273a3c8a1a7a7473e013a4964869db065c7e7dd5fe6bde58c657129910490c4a1043531fc06188f5f558589dd65acdedc50ee358edaeea074f43675fc3d1ac925d0ddb4372ebac95963d3d1a1466776230ab66399bc498b2972bd3abefb89177b5b2496b51c3b139d6f003240da5c2e9887ed6847661ef1ec98fca3f1e650e2ebe82694a6dfea2053d9ffe636abf0583e77f22773756f04514ee3709a5b24f774db17cdd9533d8baa0da6792c99bf18a347c741b22147027616ead8cc58532cb3b2ab5188886779899eaf43a9f28875fe4ab7730d55fc14d929beadd52fa39a89585c871b844215ad0504802cfe77b655c1a1ae7c42d68d909d7355c6c2ae604c593b993e6939eeffb87f958373f8204310645866309e3b33b23d8dcba8d086438d62ba5275dd1f09232db43556f35883333cecc7710f55b505fd7d34f273c3ee67818216d8835f9f5401badc706831959e4be215a1bfe24cbec4c515493ad1cc24a8eb36189cce9ac89482e6a86ef355c1adfd448c2728c2315e6b69a6d54376cdf28239d2d0eb97b9e1272997673ee7727ad48aa87d803572a053247b198dd66f1b0168dff60fdf8d43b01d0e6ce6d599dc7f2be84d816d6d9a8c2f379efc0ce188f78277a91297ada97e6b690a5722c43699b32cc70de1e11b0113978880fdeb7af4beec8b5a2995c9309e81ef244afc17340ce09bf9eec25ed00b1fe21ed8f6ac19a06d95d898a55029874679db08fb5508c5da3cc67f63e0c2ce77a2b98641ccfd0e01d347fc05050a355d2a9490698d8d9f83d7a5d4a8b5ca96bde8ad554c55d86b7ceaf5fc8d22dd2e211caa06a00b99b6ef4b7c3deeefa3ffc518d5513d73cd3b323a0c585aef87ffecdec7b81e9b23e3e682e6f79459da995d43dbdda88a2b1348c8cdcc4538f992cb8e0cc5ee252cbfaf95f318adcf6fabb6c30b28d44786bbf6e23899e9bdf08ed1346344c24b7a0622d5381fb4fa37455f743af8f5716db2c7c31d3a321c0146aa7efa402ba03eba2a93be93d5998c081ca75caba1baed202f98d97f4c7094768453b84693a9cfa662a8eb8001b20a7a80cdff4f7d88de08e1a288211f4b2f72c16b85cd56471d1f02a133641186f5f85a8618d28e41d5de34273015f725fcb8a1dfdfc785804e792f780fa140418708d21a96c8317734fc452687bf4a96f8d38c8ee0849b9435196e166a68a5c8f2b923f0e7c63fa4d9b2fb462047e21befc601539b1a3e5add0fe8280e5ed93355cb8cb5379c607b1aabc61dfafc42e01f53985a369a7b4c0c7a30427f1fddbdb4bb609bcc6335c9bce438053cfb9831cfd7742de0674f32b291e0811cc584163084161dcb39433c2c0706eeb8358d3ed7d637ac7313d6deec2f50dc74dfd2f95d7673638de4594dfd9a597a0af309a9495d24160d2da3202fde81d428b77497db36969e25b9c74fca18ae024bbf9c420ad5369a9e38cb9a0bc448087b006c918ed4cba0394b5f3b2c42dd0d6cb707beb7d89a17216873089f89d3a400c4456b0f58aa21ab30bb79f6dc14b21c411a0955d9c476857ce985a8d7ab307311e2cfdb4fad9c821b0e382044043864411c0f02938d091f09474e7c6700937eb07a891a5d1e0c4333ce0c9f48d55fa73bdba3035faabd216e17ee66eebd7bc3b57e9c3987287b95266cd68f277d2c4b1b67b113fb9008db95872149c163df4875990d2d9317f1bc25328a96ce034f148c0ff457b4ece5ff3e83b5c70f5089f18290caaaf2027f60f0ec4a036fb6bf1bb9add5f1e99e9e94e89b4b12ddcec0882f18e40d983db0889db11ed5dec615df47bce266ddd64e6a21eade0ea1b1c4ddf225c8089e13a47ab922dcecfdbe83c1da25e325950932e03f9be846412e484c0c65cedb8ffe37b2ba12af43be56d450b45fe7c8f0c4e052ea20a134721c09f914a2d269b635e37e09a9e3e96138b75d724b921f32f01113101b48938ebeef978965094a0c7a39c3cf25165623d5bf9257042a8e055540f1cb042d46bc873c92d5cee4565a17c4e8772d238324277d42328ae4fe4c5fd6c18f22b5962aaa909ee8a63e6b54aee28f25e064140ca550c93dd35de879ff9b1ae41fa85bf9e29661d53e4faa1f404af8c0ca970afef4f188e8b0d718897d5a613086aa6da2aed32832dfaf5d9221f9c915400534300ce14167a5210645649f2be44a60d7ddbd62d33b75fd0a291d1601ce5d6977832f1e9f7982f1746b51e278ca9a710ae7c1d27aa8e490b9ca6c1eda81ac0eaafca53fb30753a507764f5884e2cd9b1a0c062531ace1bf6b0ae1aaeb0ef3d57f845522a6cbcb5db32284efca26f3397a57a52f6e60055e64ba675901c71be15824530cbb75707184f935eebf191051ce657c484eba4c8c4cd5c912b84067b94b69c772b820e6a1791e549ecf699b47b42782347fe5819dde5bab83fc00c8f58decdbed8941b7fa90f4e873d473d1ace67531fbe2f90c9d9befeb2694d97fa28785c9b9c6e9d7ba979a4ebd7b50736e694c6334a44dcc868ad7da7107da07fbc772c6eeea4b1d47df1292c6a4b810cb4d6cf68fe48aa2c0d89e4a1883c19c206f4913dd740cb8e53eea5c7346dcf08f520b8f5957773fbbc442ff67a9ad85e1973e2a99e5ce5d5a00d1aac04cbe786d9ac773381e6427963b2804e15ba58e11d1f302881e02ebbfc6f55b28bedaac459dcceb2466522a9ee67f29d5f1bbe862d9718579746c299054e1d5cc7a297e550a6025f955fe993f7364e9d663112f9dfd3e96791c825996c861e2cc4495fbedcdcc39188d51f4b2746d7776fbcfc97edfaf0babee93d4f8977554556d83f490255a5ad30b7291d8afb2abcf89aef186a6297362276e265662324c25c91f76a77925dab82a2265c307cfeee1eb7006d3cd465bddadefe8342d101dbe7b93a3df6a13567c898bca9e4d06bc237e058f67efe3ad65457048ae1ccc68e00b5bc30855b359720851164924f6cbc0455084630331c9bf5c499254d5a9be9661b7c792899f5a73a7097dfdba7537de4fe958f86947c80b841892d25ec46adc46b335fcee5f4311875667c235c605562648cbc90be4a08304762e1f9294f80646b5eda6b0f93de2a571074eb4c21fbc3a699360c6741231044d86c69fe8b8c3a47e1f14f6e7ecf362d27e2212d07bd632a570d9f056a45d9de8d82902783138f888bf98593252321933ab7c0ab93b7edbbf898d296d183f1fe27953bac839234298b508d9aa8767a8574df981560dc64c2e9177190350985c9dc58f43186dc2fadffb391c84a74b8e10f710b40350aa51d609a9c93c98eb9b2551d1ec47878120f16802423c517c3290c1b1551534a505a65b04692e72bd7ed265d870f1556be4cf7daec43bb23691718f841289697a8c71f0aad677bdcbfa70624421266d3a9a44dbe3004e2d315f069afddab3a60f54faba7fefc94481073129c14b36d86c83879f177662de84b289a290f427d1fa3d254d955071e71dae88c34c1536531257838f045c94ec6d14cbec63de6c7084f44bf86b5767492954b6934785a33eb0c0d2c27d7795e4542097e8ee47f0e6728a6a25e381255c485119f5f0f64bb321a24f51f060f87c561b9abd9d0c74dd4cc1773f240441d7a9bf82d070f29b373dbdd5f21d3bf46c582e4332a169250fa564d34ca2ee73510a906ba7f3a310190842e552cd6534f1a452472d72ed2706db587196a81c97e91b2ca675d77b7be1ea58d03a26c2444d913ad984157a04250a7f5a7a8d1d4d177daf6b20dba285d475534ed07c652bde20fbdd75dd91cee4929a1965513db4f44544a700498d68e7a84e71396afbbd2b281edd5464d5f38598012eabf8cfc66d8af06026eb34cd580ea00e7c7081ff0c10e58bd4dab5346e8a5585d29c23e61c05dccea8518f4861c1a544d5604576846165f98af3db4d406b17a3f0681d3d84b73d273ea75331ee1face6e2614633e37d837441b0dde6525b67512f0f3f554c7d2433be12d7c42d73c7e68b183918679832b7d1c0604899ff58b13521937b5135574de6730d5775235a894c71fbf7022d13b5b2136d002d9817aff60544571e9009a07238203554aa37ca9f47217d0fe595f30cb77d826fb0078ed5a588496313caa7f23d0626f1c9bfd690bc22a732cec863ab7432d8e183ce96738e56ce742ef94b4e8bd2c5788093d4e8a04c26748b640d98bfac63b5ff151973ce964fac8831b8b5f43b8fd56d4746cd6ddf67ef181795b0ca61caeba9f753459cd4eaa62997afe9550351ca028c84d37d3ff26efc66a2a047418b57445502f61b70da2a321a54e7444b4f39b380b1df04531f5ff839dedb5db66fa59c473cdd2d09add502b5a571cdc7e176b5e0a3a28724c64e6386025eae701f8b267c0ff831ad8b4599818a30c7f167e86ddc8ef133e5b823fee0f3cdf543fb89e810817ac02293fc8505fbf0bf42006ba9ac3eca248066eca14a08466dae276c5c5a7470e33c299b57a06457b2069b7eaa4d7df540a6b5319b7ad9126a281b565402920e176ac0a572540762557394641b37bae443d1dbed41e09bb275056556b9be88c8388b92869b7c95b9f5ac9330d42e192f6b4718ba7f896d36aaf73f59c60f81b2c7a57d48b8096670821c54ef1013ad7f072fd0afa275bdaaa11835a72671c79ca2de289d27c4cebfe1375c04d697a3f841ad5cf4c07dcc60467483c4c28b5fb96e45a9846a6cd3ca04f05122ca81839311e05101c27702da9ae59f03d9930f0e853541d9b00dafddbd2a071c10a5554e29e37f8c80957ce1d3e0ae689c44b6d12881194ddfc4a9cb3bbf6cc580af7626c818ed906bec98b28d31540ca46a39c691ad7a5692d021c4c9d1bab610a6a6e1c6c7fc53601deeae283ee8392d5ad9a1ef6d86f90970122d971ecb0b76e10affb6c820359d423813f690a5c5bbf4d9b8090cf44ea8a467c3ffd1392f81fbe47956e5144a8708fe559d876efb97987e92cb01c2ab84ff2d909b68f10d6b149b99d9bd673dc85627f3d301973c985ba095e8d4851cbb85278ceb80b12a23cbfa4754cf8041c69c663805545cd2f54ce98c59a4e6280e70a4fb9e72012e060dc42f1b0973cb05ca1585db8cacba301edcc5ab97acc29168d072363b6fedbc24b1aa8b8a91608dff0798daf9bd5404fc103162a38474a0ce28f130b329e8c87dc4510d1dbbe4e695be1edc92789c883b175e826129946eb3231efe784e6b389ca9cf53bcdeee262b9f1ae8b6bfb7c9446f551c84d7424ee8362bcc4b049c18305ff293da132c5b163212cd952593ea8b62e38e72dd1fba48a024fded861d1befde3ec6315c8a8403bfe26dd5f2e84c7da63014b1e96c6e04fba917a430f2632f9e081c2877a27461420f96037e6a609a52d36f8cada79e259786890a42ff56c3db240cd41ba067681732cd7c020dad3f7902e5f060256e6645a1215212d59279acf39c5a54f99cc50f43881a1fa12acaf52ad829bfee72cea22973d642f64f51c4e2e551c9bb8c9127c28b6f1be7ba43d7b7bbc42dee1b629cb5537e22e93f7f6f9f4c3f8bc5178cc7f67e0ab6e7b85517f70314d80e1fd82952584bfd2e4b1af830486dbbbebf99d2bea5e0618dc7b139bf4b688b5c0dba0a0955280bd6367efb7883a8fbb841ec4783322b25d2d661873432c8f1d13fcc0da00d75e9db0f0d9c836313bccd4f1365d5f450f5850ac3a13cd198af9d8689c67f945a3fb0648ac1cac9cb50cf23330c3b95fb336cf36128bbf4a61801aa1ad8991c5f5ec56c8d627388f8925dd0b18b3fbc991fa3bf6f38e16088ee6c59fec89260dc6299aef04d6c949e14c7637f90910bc655294f2c1e73be4ce24a74a7681d2f212dba0cbc8804d353d1af4e6b0a32ee5372ac3e3b20e3cadbaf3a2f0f29f2564a8e65fbfa00cd2d88e7a7d55aacf6733d8b0a70d47e6378331b724398bf4a5d4516cd89b8dea2ad8cd87b70c105b26c9fea96d85d297f10b39fcb2e1b0b207be7e04179bb6708661a715737332e3dc3dabc668b393e6f6010f353ebe0afd2637f69ab5f89b0a36542b8482472da0d9d4c4392cf55d0ef73940463bab9e2ad492a5bb12c3cf133de3eaa2aedf13834cacaa6341abb31ed550e1958e20d0abf937640be80213f17c63d696ddc158857c0b5ac1924d6973a0be07d83b834f1af835554719202acec36b59f035073e11612b8c3fdae31f02afb1224f674520d72a1fd5d9e60f16ade4f76e89032766a4fb07363aa8b659be20f0d43d24ffdc2afaae298dcb52cfb6751a48f358a981ad98cedc2cc5d0b4c8f1ac28b6008b2a7f384500881e5ffac20dffa0e57faa536a22a81c3df187073001d2c180d7a5e2cc06b162eb6bdbf0b36ec8d79ff8a3ba0d799bcb31176ae4e5a5a0363e9d97f9214cc6b954fa9b5de738eae930adda5557449b15826217446ebb223245cfad60579a6dda1fdad6fc1dfca7ae2af7c8c98e4604d4370584152c0266dce0ef584461a54fa3c6b633f81f1a69e4584dd043c6f3650364979facf2cf9bdd3991d637d4d4ae62f2e1422ee7a24f209fab106a91c0650977918fb1ac9fb5e6ab796176e3f412d8a95a2dbf7e26e12f2fd6e74be3171a42264f26f287592c9df766c9658dee59408cfd76399f01b4c4d2d16f68d8544fa644894ea982523d46869b304c9a0dc272ab56a1bea9928fef7dd7bab75aed91a3eea288142d209c1805dda800c5abcf7d5bbe843b6335c12442578245851be02a0bfbe04594dc5be25b6b6d4a51f99ae6fe3cbd7807738672359a9183265aeb93fcfc71261459d4bf7bb7754e3cd9cb0db75332292a7694d73d3b4a7f2b3e0e1ee569bd99457d30273e35240bdca3bfabf6da25780acc2231ff26ce94c800972bfc8f924f1259a5fa784aa8b435745c557b47735dd2dfd5d20eb6c95783b192de3f35c3f44c0c54b36d90cf7ed2abeef0a1d958c9d7e130e4541b6de52a064ba8025c6329e7fcd9e5ccd5a25d7a4d62017a11ba081587dcf06e6adec183e6918685150019d7116d886b19b809f44369b1531969bfd0d22d06a5bc484ae9387c5a263455a206abdf30cdf03b4190336b201d566ffb03cda925a144bdd83efc89c0b90b57b7d5dae3d7680b7ded6f4dde8351a03eaea28d77a5cb61cd152bb9e22a0c3557ed8076da897675d15f34e799c9440d4377b9fc4707a5498592aea0207d6b0a07e01d1de1abd2ffe95c9bfd04a0ec96b11e29991fb9bf745b69f5f8385a76441b82e4642d7fda93e5675b4ca349efaf831580bba7f2c2849647d29235bac5be4e7a3734217e30803c5d4dc170e9cbe98a6d71b86a934d7480134762d3e242fde9d42bb7d00a853990f3f15dfe76e5d234efa8f7db3a39247633d50ff9c580c7550a2509ea73907a814615344a8c0ba7537059daae2c88f04d967c55e8475c379c165cec9dd65ed3d3c669ac29b2e82f779943726b96bb64563039ccda5fc3ad1bae7320be6ebfc1391fe17ded50b06726317c355af3045a3eb49b1cb3598c6c33dea8a3e6f2bc89857e34aa6f9a57bfeb7a8e193768625b1897ec5ca8aef5fbf18857920ecfd2575e18a20d19ca0e74725a1d6f47d3d17b265c8fb175fc1a9d16d8a278ce3c51b0edbd9aee75df084381d511f24f25d28614bced0317845d8115fc1bea5750044f454e699dd7bcb3f8791a3b5ac78d4545083d8ed8d9e266e99f52fa061d9ad1cb1e50f9fa4a10c15f9757a5a3355dc76886bd911de1b30831c8c84f465a0fa601978b46eeb7a39c1d8ce05245db0953c069fffffd5869fc570c0ead6bcea6e5785fd45dcffb8a4f93756490528c52a747e9689024bf3b5882ecf27248c2a902bec2ef2a855ee1e7d614fafa47538060760e8ba49e03bbadb535b4c346aef795b3f89a832bac3f300a8828bbbdb911bd21b1d25283ca051937679aa0a3c807755dde4026634d0da83836a97d2d2d41b03993e5da79afcfe7e004b3dff52881cd3f34a8fef6650bf279984e7dc9a80c9f5d985622b64cdd21e3fa6ba69aac712c1ea67ce3cf68452272ebcdd6ce2ec19ed1c5a6039dcce98eb25f783f781887fa05de1dd57918030420eb201b1aa8c2ee2063ce38999638e42876c6b6e9dedf8bc159f813b6222934cf60b23d66173b07ec20991679bb77f8417e85ccb6e2b9cf43b340f5d2e09606e7ef5d67e59fed0945753f56b6376c406d0a55344a6ecd13c278f70e6aeaacddda3512bce31f4e1dc3b3abe4be5c9144701a0fa79e818e036cdef1c7c72f8400fff2f68e48f9b5d59109b5e3967d1849eab504201963346bbbc14be7f06eb0f64aa11ba63a6f8178bd893dbc95e159d18dba6d08e8b29cf4fd2ae6ea7c9f745db0da4771c0c00692b18dca85ac7a1fd19196c3a73ff043dfba39545d2a4e42aedb3b7422dfdd8e32aff09963e9c2beae286ac6d4aa14ee6a26772a0c3db89f6000318e8b991bfae87b6172417fb26895a70ba88acb79d2268e2283670c4d2e343f823a7eb887d7f791312a1b234e6b6e864e8117dfc66f95f0373d25aa44bf757347d773737ffdaee928aac6a9b2c080f3bd21f68f2d6ada728631263040084635979e39c6a6f3a8c3293f7b35177fc0e4b053528d9fe292090c12dc796a4f3d0d8c6283659922d50b77f85cd0b7623dcd437d6f01e4086035b93b1991210da46ebd6a7164d9f8b767a29ffbe76f054232e416a1f711454ddbf945d7c8ace9ad4ebf4c4d9d3ca2e896f7537dee2dc31e0226101f10ba7a7a6b8e8dc117b3aabbbfc5fd52bdd9ff1b8fc7242cc84326f11102</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
        <category>编程语言学习</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习_吴恩达_Part_1</title>
    <url>/2022/04/26/Foundation-of-DeepLearning/</url>
    <content><![CDATA[<h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="1-0-深度学习发展历史"><a href="#1-0-深度学习发展历史" class="headerlink" title="1.0 深度学习发展历史"></a>1.0 深度学习发展历史</h4><p><img src="https://pic.imgdb.cn/item/6267f189239250f7c59f6a42.png"></p>
<p>本小节参考链接：<br>参考链接1.1：<a href="https://zhuanlan.zhihu.com/p/29096536">深度学习(deep learning)发展史 - 极海·GeoHey的文章 - 知乎</a><br>参考链接1.2：深度学习发展历程(MindSpore)-哔哩哔哩, <a href="https://b23.tv/t4osJ6I">https://b23.tv/t4osJ6I</a></p>
<h4 id="1-1-欢迎"><a href="#1-1-欢迎" class="headerlink" title="1.1 欢迎"></a>1.1 欢迎</h4><p>从本节课我们将学到：</p>
<ul>
<li>学习神经网络的基础——神经网络与深度学习；</li>
<li>深度学习方面的实践；</li>
<li>如何结构化机器学习工程；</li>
<li>卷积神经网络(经常用于图像)；</li>
<li>序列模型以及如何应用到自然语言处理(NLP)，常见的序列模型有：循环神经网络(RNN)，长短期记忆网络(LSTM)模型。 </li>
</ul>
<h4 id="1-2-什么是神经网络"><a href="#1-2-什么是神经网络" class="headerlink" title="1.2 什么是神经网络"></a>1.2 什么是神经网络</h4><p>深度学习指的是“训练神经网络”</p>
<p>下面以房屋价格预测为例。首先，将已知的六间房子的价格和面积的关系绘制在二维平面上，如下图所示： </p>
<p><img src="https://pic.imgdb.cn/item/6267f293239250f7c5a1d58d.png" style="zoom:40%"></p>
<p>一般地，会用一条直线来拟合图中这些离散点，即建立房价与面积的线性模型。但是从实际考虑，价格永远不会是负数。所以对该直线做一点点修正，让它变成折线的形状，当面积小于某个值时，价格始终为零。如下图蓝色折线所示，就是建立的房价预测模型。 </p>
<p><img src="https://pic.imgdb.cn/item/6267f3cf239250f7c5a4cb1c.png" style="zoom:40%"></p>
<p>其实这个简单的模型（蓝色折线）就可以看成是一个神经网络，而且几乎是一个最简单的神经网络。我们把该房价预测用一个最简单的神经网络模型来表示，如下图所示： </p>
<p><img src="https://pic.imgdb.cn/item/6267f419239250f7c5a57391.png" style="zoom:40%"></p>
<p>上图中的小圆圈就可以视为一个独立的神经元，这个简单网络实现了左边函数的功能值得一提的是，上图神经元的预测函数（蓝色折线）在神经网络应用中比较常见。把这个函数称为<strong>线性整流函数(Rectified Linear Unit, ReLU)</strong>，形如下图所示： </p>
<p><img src="https://pic.imgdb.cn/item/6267f506239250f7c5a7c622.png" style="zoom:70%"></p>
<p>上面是一个最为简单的神经网络，更深的神经网络可以视为：将这些单个的神经元看作乐高积木，通过搭建积木来构建更大更深的网络。把上面举的房价预测的例子变得复杂一些，而不是仅仅使用房屋面积一个判断因素。 </p>
<p><img src="https://pic.imgdb.cn/item/6267f560239250f7c5a8b1e3.png" style="zoom:50%"></p>
<p>在给定这四个输入后，神经网络所做的就是输出房屋的预测价格y。上图中三个神经元所在的位置称之为<strong>中间层或者隐藏层</strong>(x所在的称之为输入层，y所在的称之为输出层)，每个神经元与所有的输入x都有关联(直线相连)。 </p>
<h4 id="1-3-使用神经网络进行监督学习"><a href="#1-3-使用神经网络进行监督学习" class="headerlink" title="1.3 使用神经网络进行监督学习"></a>1.3 使用神经网络进行监督学习</h4><p>由神经网络模型创造的价值基本上都是基于<strong>监督式学习(Supervised Learning)</strong>的。监督式学习与非监督式学习本质区别就是<strong>是否已知训练样本的输出y</strong>。在实际应用中，机器学习解决的大部分问题都属于监督式学习，神经网络模型也大都属于监督式学习。下面我们来看几个监督式学习在神经网络中应用的例子。</p>
<ul>
<li>房屋价格预测。根据训练样本的输入x和输出y，训练神经网络模型，预测房价。</li>
<li>线上广告。输入x是广告和用户个人信息，输出y是用户是否对广告进行点击。神经网络模型经过训练，能够根据广告类型和用户信息对用户的点击行为进行预测，从而向用户提供用户自己可能感兴趣的广告。</li>
<li>电脑视觉(computer vision)。电脑视觉是近些年来越来越火的课题，而电脑视觉发展迅速的原因很大程度上是得益于深度学习。其中，输入x是图片像素值，输出是图片所属的不同类别。</li>
<li>语音识别(speech recognition)。深度学习可以将一段语音信号辨识为相应的文字信息。</li>
<li>智能翻译。例如通过神经网络输入英文，然后直接输出中文。</li>
<li>自动驾驶。通过输入一张图片或者汽车雷达信息，神经网络通过训练来告诉你相应的路况信息并作出相应的决策。 </li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6267f5d9239250f7c5a9dfcd.png" style="zoom:50%"></p>
<p>根据不同的问题和应用场合，应该使用不同类型的神经网络模型。CNN和RNN是比较常用的神经网络模型。下图给出了Standard NN，Convolutional NN和Recurrent NN的神经网络结构图。 </p>
<p><img src="https://pic.imgdb.cn/item/6267f6c4239250f7c5ac1c6c.png"></p>
<p>数据类型一般分为两种：<strong>结构化数据(Structured Data)</strong>和<strong>非结构化数据(Unstructured Data)</strong> </p>
<p><img src="https://pic.imgdb.cn/item/6267f734239250f7c5ad2a26.png" style="zoom:40%"></p>
<h4 id="1-4-为什么深度学习流行起来了"><a href="#1-4-为什么深度学习流行起来了" class="headerlink" title="1.4 为什么深度学习流行起来了"></a>1.4 为什么深度学习流行起来了</h4><p>略</p>
<h3 id="第二章-神经网络基础之逻辑回归"><a href="#第二章-神经网络基础之逻辑回归" class="headerlink" title="第二章 神经网络基础之逻辑回归"></a>第二章 神经网络基础之逻辑回归</h3><p>下面开始介绍神经网络的基础：逻辑回归（Logistic Regression）。通过对逻辑回归模型结构的分析，为后面学习神经网络模型打下基础。 </p>
<h4 id="2-1-二分类-Binary-Classification"><a href="#2-1-二分类-Binary-Classification" class="headerlink" title="2.1 二分类(Binary Classification)"></a>2.1 二分类(Binary Classification)</h4><p>逻辑回归模型一般用来解决二分类(Binary Classification)问题。二分类就是输出只有{0,1\}两个离散值(也有{-1,1}的情况)。以一个图像识别问题为例，判断图片中是否有猫存在，0代表not cat，1代表cat。 </p>
<p><img src="https://pic.imgdb.cn/item/6267f7e7239250f7c5aece58.png" style="zoom:50%"></p>
<p>如上图所示，这是一个典型的二分类问题。一般来说，彩色图片包含RGB三个通道。例如该cat图片的尺寸为<script type="math/tex">(64, 64, 3)</script>。在神经网络模型中，我们首先要将图片输入<script type="math/tex">x</script>(维度是<script type="math/tex">(64, 64, 3)</script>)转化为一维的特征向量(feature vector)。方法是每个通道一行一行取，再连接起来。由于<script type="math/tex">64\times 64\times 3=12288</script>，则转化后的输入特征向量维度为<script type="math/tex">(12288, 1)</script>。此特征向量<script type="math/tex">x</script>是列向量，维度一般记为<script type="math/tex">n_x</script>。</p>
<p>如果训练样本共有<script type="math/tex">m</script>张图片，那么整个训练样本<script type="math/tex">X</script>组成了矩阵，维度是<script type="math/tex">(n_x,m)</script>。注意，这里矩阵<script type="math/tex">X</script>的行<script type="math/tex">n_x</script>代表了每个样本<script type="math/tex">x^{(i)}</script>特征个数，列<script type="math/tex">m</script>代表了样本个数。这里，Andrew解释了<script type="math/tex">X</script>的维度之所以是<script type="math/tex">(n_x, m)</script>而不是<script type="math/tex">(m, n_x)</script>的原因是为了之后矩阵运算的方便。算是Andrew给我们的一个小小的经验吧。而所有训练样本的输出<script type="math/tex">Y</script>也组成了一维的行向量，写成矩阵的形式后，它的维度就是<script type="math/tex">(1, m)</script>。</p>
<blockquote>
<p>后面课程会用到的一些符号<br>用一对<script type="math/tex">(x, y)</script>来表示一个单独的样本，其中<script type="math/tex">x</script>是<script type="math/tex">n_x</script>维特征向量(可记为<script type="math/tex">x \in \mathbb{R}^{n_x}</script>)，<script type="math/tex">y \in \{0, 1\}</script>，训练集由<script type="math/tex">m</script>个训练样本组成，<script type="math/tex">(x^{(i)}, y^{(i)})</script>表示样本<script type="math/tex">n</script>的输入输出。为了便于表示和区分，有时训练集表示为<script type="math/tex">m = m_{\text{train}}</script>，测试集表示为<script type="math/tex">m = m_{\text{test}}</script>，可进一步将训练集表示为更紧凑的形式，用矩阵<script type="math/tex">X</script>表示：<script type="math/tex">X=\left(\begin{array}{cccc}\vdots & \vdots & & \vdots \\x^{(1)} & x^{(2)} & \cdots & x^{(m)} \\\vdots & \vdots & & \vdots \\\end{array}\right)</script>，<script type="math/tex">X</script>的大小为<script type="math/tex">(n_x, m)</script>，<script type="math/tex">X \in \mathbb{R}^{n_x \times m}</script>，输出用<script type="math/tex">Y</script>表示：<script type="math/tex">Y = [y^{(1)}, y^{(1)}, \cdots, y^{(m)}]</script>，<script type="math/tex">Y</script>的大小为<script type="math/tex">(1, m)</script>，<script type="math/tex">Y \in \mathbb{R}^{1\times m}</script></p>
</blockquote>
<h4 id="2-2-logistic回归"><a href="#2-2-logistic回归" class="headerlink" title="2.2 logistic回归"></a>2.2 logistic回归</h4><p>这是一个学习算法，用于监督学习中输出<script type="math/tex">y​</script>是<script type="math/tex">0​</script>或<script type="math/tex">1​</script>的二元分类问题。</p>
<p>逻辑回归中，预测值<script type="math/tex">\hat{h} = \text{P}(y=1|x)</script>表示为输入<script type="math/tex">x</script>输出为<script type="math/tex">y = 1</script>的概率，取值范围在<script type="math/tex">[0,1]</script>之间，这是其与二分类模型不同的地方。使用线性模型，引入参数<script type="math/tex">w</script>和<script type="math/tex">b</script>。权重<script type="math/tex">w</script>的维度是<script type="math/tex">(n_x, 1)</script>，<script type="math/tex">b</script>是一个常数项，即<script type="math/tex">w \in \mathbb{R}^{n_x \times 1}, b \in \mathbb{R}</script>。这样，逻辑回归的线性预测输出可以写成：</p>
<script type="math/tex; mode=display">
\hat{y} = w^{\text{T}}x+b</script><p>值得注意的是，很多其它机器学习资料中，可能把常数<script type="math/tex">b</script>当做<script type="math/tex">w_0</script>处理，并引入<script type="math/tex">x_0=1</script>。这样从维度上来看，<script type="math/tex">x</script>和<script type="math/tex">w</script>都会增加一维。但在本课程中，为了简化计算和便于理解，Andrew建议还是使用上式这种形式将<script type="math/tex">w</script>和<script type="math/tex">b</script>分开比较好。</p>
<p>上式的线性输出区间为整个实数范围，而<strong>逻辑回归要求输出范围在</strong><script type="math/tex">[0,1]</script><strong>之间</strong>，所以还需要对上式的线性函数输出进行处理。方法是引入sigmoid函数，让输出限定在<script type="math/tex">[0,1]</script>之间。这样，逻辑回归的预测输出就可以完整写成：</p>
<script type="math/tex; mode=display">
\hat{y} = \text{sigmoid}(w^{\text T}x+b) = \sigma(w^{\text T}x+b)</script><p>sigmoid函数是一种非线性的S型函数，输出被限定在<script type="math/tex">[0,1]</script>之间，通常被用在神经网络中当作<strong>激活函数(Activation function)</strong>使用。Sigmoid函数的表达式：</p>
<script type="math/tex; mode=display">
\text{sigmoid}(z) = \frac{1}{1+e^{-z}}</script><p> 通过Sigmoid函数，就能够将逻辑回归的输出限定在<script type="math/tex">[0,1]</script>之间了。</p>
<h4 id="2-3-logistic回归损失函数"><a href="#2-3-logistic回归损失函数" class="headerlink" title="2.3 logistic回归损失函数"></a>2.3 logistic回归损失函数</h4><p>逻辑回归中，<script type="math/tex">w</script>和<script type="math/tex">b</script>都是未知参数，需要反复训练优化得到。因此，我们需要定义一个成本函数(cost function)，包含了参数<script type="math/tex">w</script>和<script type="math/tex">b</script>。通过优化cost function，当cost function取值最小时，得到对应的<script type="math/tex">w</script>和<script type="math/tex">b</script>。</p>
<p>如何定义所有<script type="math/tex">m</script>个样本的cost function呢？先从单个样本出发，我们希望该样本的预测值<script type="math/tex">\hat y</script>与真实值越相似越好。我们把单个样本的cost function用<strong>Loss function</strong>来表示，根据以往经验，如果使用平方错误(squared error)来衡量，如下所示：</p>
<script type="math/tex; mode=display">
L(\hat y, y) = \frac{1}{2}(\hat y-y)^2</script><p>但是，对于逻辑回归，我们一般不使用平方错误来作为Loss function。原因是这种Loss function一般是<strong>非凸(non-convex)</strong>的。non-convex函数在使用梯度下降算法时，容易得到局部最小值(local minumum)，即<strong>局部最优化</strong>。而我们最优化的目标是计算得到全局最优化(Global optimization)。因此，我们一般选择的Loss function应该是convex的。因此，我们可以构建另外一种Loss function，且是convex的，如下所示：</p>
<script type="math/tex; mode=display">
L(\hat y, y) = -(y\log \hat y + (1-y)\log(1-\hat y))</script><p>我们来分析一下这个Loss function，它是衡量错误大小的，Loss function越小越好。</p>
<p>当<script type="math/tex">y = 1</script>时，我们带入上式容易得知<script type="math/tex">\hat y\rightarrow1</script>时<script type="math/tex">L(\hat y, y)\rightarrow0</script>，预测效果越好；同理，当<script type="math/tex">y=0</script>时，<script type="math/tex">\hat y \rightarrow 0</script>则<script type="math/tex">L(\hat y,y)\rightarrow0</script>，预测效果越好。后续将会提到这个损失函数是如何推导出来的。</p>
<p>上面介绍的Loss function是针对单个样本的。那对于<script type="math/tex">m</script>个样本，我们定义Cost function，Cost function是<script type="math/tex">m</script>个样本的Loss function的平均值，反映了<script type="math/tex">m</script>个样本的预测输出<script type="math/tex">\hat y</script>与真实样本输出<script type="math/tex">y</script>的平均接近程度。Cost function可表示为：</p>
<script type="math/tex; mode=display">
J(w,b) = \frac1m \sum_{i=0}^{m}L(\hat y^{(i)}, y^{(i)})</script><p>Cost function已经推导出来了，Cost function是关于待求系数w和b的函数。我们的目标就是迭代计算出最佳的w和b值，<strong>最小化Cost function</strong>，让Cost function尽可能地接近于零。</p>
<p>其实逻辑回归问题可以看成是一个简单的神经网络，只包含<strong>一个神经元</strong>。这也是我们这里先介绍逻辑回归的原因。</p>
<h4 id="2-4-梯度下降法"><a href="#2-4-梯度下降法" class="headerlink" title="2.4 梯度下降法"></a>2.4 梯度下降法</h4><p>使用<strong>梯度下降(Gradient Descent)</strong>算法来计算出合适的<script type="math/tex">w</script>和<script type="math/tex">b</script>值，从而最小化<script type="math/tex">m</script>个训练样本的Cost function，即<script type="math/tex">J(w,b)</script>。</p>
<p>由于<script type="math/tex">J(w,b)</script>是convex  function，梯度下降算法是先随机选择一组参数<script type="math/tex">w</script>和<script type="math/tex">b</script>值，然后每次迭代的过程中分别沿着<script type="math/tex">w</script>和<script type="math/tex">b</script>的梯度(偏导数)的反方向前进一小步，不断修正<script type="math/tex">w</script>和<script type="math/tex">b</script>。每次迭代更新后，都能让<script type="math/tex">J(w,b)</script>更接近全局最小值。梯度下降的过程如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/648a82371ddac507ccb0ec36.jpg" style="zoom:50%"></p>
<p>梯度下降算法每次迭代更新，<script type="math/tex">w</script>和<script type="math/tex">b</script>的修正表达式为：</p>
<script type="math/tex; mode=display">
w:=w-\alpha \frac{\partial J(w, b)}{\partial w}</script><script type="math/tex; mode=display">
b:=b-\alpha \frac{\partial J(w, b)}{\partial b}</script><p>上式中，<script type="math/tex">\alpha</script>是学习因子(learning rate)，表示梯度下降的不仅长度。梯度下降算法能够保证每次迭代w和b都能向着J(w,b)全局最小化的方向进行。其<a href="http://blog.csdn.net/red_stone1/article/details/72229903">数学原理</a>主要是运用泰勒一阶展开来证明的。</p>
<h4 id="2-5-2-6-导数复习"><a href="#2-5-2-6-导数复习" class="headerlink" title="2.5-2.6 导数复习"></a>2.5-2.6 导数复习</h4><p>这一部分的内容相对简单，Andrew主要是给对微积分、求导数不太清楚的同学介绍的。梯度或者导数一定程度上可以看成是斜率。关于求导数的方法这里就不再赘述了。</p>
<h4 id="2-7-计算图"><a href="#2-7-计算图" class="headerlink" title="2.7 计算图"></a>2.7 计算图</h4><p>整个神经网络的训练过程实际上包含了两个过程：<strong>正向传播(Forward Propagation)</strong>和<strong>反向传播(Back Propagation)</strong>。正向传播是从输入到输出，由神经网络计算得到预测输出的过程；反向传播是从输出到输入，对参数w和b计算梯度的过程。下面，我们用<strong>计算图(Computation graph)</strong>的形式来理解这两个过程。</p>
<p>举个简单的例子，假如Cost function为<script type="math/tex">J(a,b,c)=3(a+bc)</script>，包含<script type="math/tex">a</script>，<script type="math/tex">b</script>，<script type="math/tex">c</script>三个变量。我们用<script type="math/tex">u</script>表示<script type="math/tex">bc</script>，<script type="math/tex">v</script>表示<script type="math/tex">a+u</script>，则<script type="math/tex">J=3v</script>。它的计算图可以写成如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648a82ed1ddac507ccb243d5.jpg" style="zoom:50%"></p>
<p>令<script type="math/tex">a=5,b=3,c=2</script>，则<script type="math/tex">u=bc=6,v=a+u=11,J=3v=33</script>。计算图中，这种从左到右，从输入到输出的过程就对应着神经网络或者逻辑回归中输入与权重经过运算计算得到Cost function的正向过程。</p>
<h4 id="2-8-使用计算图求导"><a href="#2-8-使用计算图求导" class="headerlink" title="2.8 使用计算图求导"></a>2.8 使用计算图求导</h4><p>下面我们来介绍反向传播(Back Propagation)，即计算输出对输入的偏导数。</p>
<p><img src="https://pic.imgdb.cn/item/648a83431ddac507ccb2e777.jpg" style="zoom:50%"></p>
<h4 id="2-9-logistic回归中的梯度下降法"><a href="#2-9-logistic回归中的梯度下降法" class="headerlink" title="2.9 logistic回归中的梯度下降法"></a>2.9 logistic回归中的梯度下降法</h4><p>对逻辑回归进行梯度计算。对单个样本而言，逻辑回归Loss function表达式如下：</p>
<script type="math/tex; mode=display">
\begin{gathered}
&z = w^\text Tx+b \\
&\hat y = a = \sigma(z) \\
&L(\hat y,y) = L(a, y) = -(y\log a+(1-y)\log(1-a))
\end{gathered}</script><p>该逻辑回归的正向传播过程非常简单。据上述公式，例如输入样本<script type="math/tex">x</script>有两个特征<script type="math/tex">(x_1,x_2)</script>，相应的权重也有两个<script type="math/tex">(w_1,w_2)</script>，则<script type="math/tex">z = w_1x_1+w_2x_2+b</script>。</p>
<p>然后，计算该逻辑回归的反向传播过程，即由Loss function计算参数<script type="math/tex">w</script>和<script type="math/tex">b</script>的偏导数：</p>
<script type="math/tex; mode=display">
\begin{gathered}
&\mathrm d a=\frac{\partial L}{\partial a}=-\frac{y}{a}+\frac{1-y}{1-a}\\
&\mathrm d z=\frac{\partial L}{\partial z}=\frac{\partial L}{\partial a} \cdot \frac{\partial a}{\partial z}=\left(-\frac{y}{a}+\frac{1-y}{1-a}\right) \cdot a(1-a)=a-y
\end{gathered}</script><p>知道了<script type="math/tex">\mathrm dz</script>之后，就可以直接对<script type="math/tex">w_1，w_2</script>和<script type="math/tex">b</script>进行求导了：</p>
<script type="math/tex; mode=display">
\begin{gathered}
&\mathrm d w_1=\frac{\partial L}{\partial w_1}=\frac{\partial L}{\partial z} \cdot \frac{\partial z}{\partial w_1}=x_1 \cdot \mathrm  d z=x_1(a-y)\\
&\mathrm d w_2=\frac{\partial L}{\partial w_2}=\frac{\partial L}{\partial z} \cdot \frac{\partial z}{\partial w_2}=x_2 \cdot \mathrm  d z=x_2(a-y)\\
&\mathrm d b=\frac{\partial L}{\partial b}=\frac{\partial L}{\partial z} \cdot \frac{\partial z}{\partial b}=1 \cdot \mathrm  d z=a-y
\end{gathered}</script><p>则梯度下降算法可表示为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
w{1}:=w{1}-\alpha ~\mathrm d w{1} \\
w{2}:=w{2}-\alpha ~\mathrm d w{2} \\
b:=b-\alpha ~\mathrm d b
\end{gathered}</script><p><img src="https://pic.imgdb.cn/item/648a84f21ddac507ccb64b43.jpg" style="zoom:50%"></p>
<h4 id="2-10-m-个样本的梯度下降"><a href="#2-10-m-个样本的梯度下降" class="headerlink" title="2.10 m 个样本的梯度下降"></a>2.10 m 个样本的梯度下降</h4><p>上一部分讲的是对单个样本求偏导和梯度下降。如果有m个样本，其Cost function表达式如下：</p>
<script type="math/tex; mode=display">
\begin{gathered}
z^{(i)}=w^{T} x^{(i)}+b \\
\hat{y}^{(i)}=a^{(i)}=\sigma\left(z^{(i)}\right) \\
J(w, b)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)=-\frac{1}{m} \sum_{i=1}^{m}\left[y^{(i)} \log \hat{y}^{(i)}+\left(1-y^{(i)}\right) \log \left(1-\hat{y}^{(i)}\right)\right]
\end{gathered}</script><p>Cost function关于<script type="math/tex">w</script>和<script type="math/tex">b</script>的偏导数可以写成和平均的形式：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathrm d w_{1}=\frac{1}{m} \sum_{i=1}^{m} x_{1}^{(i)}\left(a^{(i)}-y^{(i)}\right) \\
\mathrm d w_{2}=\frac{1}{m} \sum_{i=1}^{m} x_{2}^{(i)}\left(a^{(i)}-y^{(i)}\right) \\
\mathrm d b=\frac{1}{m} \sum_{i=1}^{m} \left(a^{(i)}-y^{(i)}\right)
\end{gathered}</script><p>这样，每次迭代中<script type="math/tex">w</script>和<script type="math/tex">b</script>的梯度有$m$个训练样本计算平均值得到。其算法伪代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">J=<span class="number">0</span>; dw1=<span class="number">0</span>; dw2=<span class="number">0</span>; db=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to m</span><br><span class="line">    z(i) = wx(i)+b;</span><br><span class="line">    a(i) = sigmoid(z(i));</span><br><span class="line">    J += -[y(i)log(a(i))+(<span class="number">1</span>-y(i)）log(<span class="number">1</span>-a(i));</span><br><span class="line">    dz(i) = a(i)-y(i);</span><br><span class="line">    dw1 += x1(i)dz(i);</span><br><span class="line">    dw2 += x2(i)dz(i);</span><br><span class="line">    db += dz(i);</span><br><span class="line">J /= m;</span><br><span class="line">dw1 /= m;</span><br><span class="line">dw2 /= m;</span><br><span class="line">db /= m;</span><br></pre></td></tr></table></figure>
<p>经过每次迭代后，根据梯度下降算法，<script type="math/tex">w</script>和<script type="math/tex">b</script>都进行更新：</p>
<script type="math/tex; mode=display">
\begin{gathered}
w_{1}:=w_{1}-\alpha ~ \mathrm d w_{1} \\
w_{2}:=w_{2}-\alpha ~ \mathrm d w_{2} \\
b:=b-\alpha ~ \mathrm d b
\end{gathered}</script><p>这样经过<script type="math/tex">n</script>次迭代后，整个梯度下降算法就完成了。</p>
<p>值得一提的是，在上述的梯度下降算法中，是利用for循环对每个样本进行dw1，dw2和db的累加计算最后再求平均数的。在深度学习中，样本数量$m$通常很大，使用for循环会让神经网络程序运行得很慢。所以，我们应该尽量避免使用for循环操作，而使用<strong>矩阵运算</strong>，能够大大提高程序运行速度。关于<strong>向量化(vectorization)</strong>的内容我们放在下次笔记中再说。</p>
<h4 id="2-11-2-12-向量化"><a href="#2-11-2-12-向量化" class="headerlink" title="2.11-2.12 向量化"></a>2.11-2.12 向量化</h4><p>深度学习算法中，数据量很大，在程序中应该尽量减少使用loop循环语句，而可以使用向量运算来提高程序运行速度。</p>
<p>向量化(Vectorization)就是利用矩阵运算的思想，大大提高运算速度。</p>
<p>上一部分我们讲了应该尽量避免使用for循环而使用向量化矩阵运算。在python的numpy库中，我们通常使用<strong>np.dot()</strong>函数来进行矩阵运算。</p>
<p>我们将向量化的思想使用在逻辑回归算法上，尽可能减少for循环，而只使用矩阵运算。值得注意的是，算法最顶层的迭代训练的for循环是不能替换的。而每次迭代过程对J，dw，b的计算是可以直接使用矩阵运算。</p>
<h4 id="2-13-向量化logistic回归"><a href="#2-13-向量化logistic回归" class="headerlink" title="2.13 向量化logistic回归"></a>2.13 向量化logistic回归</h4><p>在前面的笔记中我们提到过，整个训练样本构成的输入矩阵<script type="math/tex">X</script>的维度是<script type="math/tex">(,m)</script>，权重矩阵<script type="math/tex">w</script>的维度是<script type="math/tex">(,1)</script>，<script type="math/tex">b</script>是一个常数值，而整个训练样本构成的输出矩阵<script type="math/tex">Y</script>的维度为<script type="math/tex">(1,m)</script>。利用向量化的思想，所有<script type="math/tex">m</script>个样本的线性输出<script type="math/tex">Z</script>可以用矩阵表示：</p>
<script type="math/tex; mode=display">
Z = w^{\text T}X+b</script><p>在python的numpy库中可以表示为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Z = np.dot(w.T,X) + b      <span class="comment"># w.T表示w的转置</span></span><br><span class="line">A = sigmoid(Z)</span><br></pre></td></tr></table></figure>
<p>这样，我们就能够使用向量化矩阵运算代替for循环，对所有<script type="math/tex">m</script>个样本同时运算，大大提高了运算速度。 </p>
<h4 id="2-14-向量化logistic回归的梯度输出"><a href="#2-14-向量化logistic回归的梯度输出" class="headerlink" title="2.14 向量化logistic回归的梯度输出"></a>2.14 向量化logistic回归的梯度输出</h4><p>逻辑回归中的梯度下降算法如何转化为向量化的矩阵形式。对于所有<script type="math/tex">m</script>个样本，<script type="math/tex">\mathrm dZ</script>的维度是<script type="math/tex">(1, m)</script>，可表示为：</p>
<script type="math/tex; mode=display">
\mathrm dZ = A-Y</script><p>$\mathrm d b$可以表示为：</p>
<script type="math/tex; mode=display">
\mathrm d b = \frac{1}{m} \sum_{i=1}^{m}dz^{(i)}</script><p>对应的程序可以写成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dw = <span class="number">1</span>/m*np.dot(X,dZ.T)</span><br></pre></td></tr></table></figure>
<p>这样，我们把整个逻辑回归中的for循环尽可能用矩阵运算代替，对于单次迭代，梯度下降算法流程如下所示：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Z = np.dot(w.T,X) + b</span><br><span class="line">A = sigmoid(Z)</span><br><span class="line">dZ = A-Y</span><br><span class="line">dw = <span class="number">1</span>/m*np.dot(X,dZ.T)</span><br><span class="line">db = <span class="number">1</span>/m*np.<span class="built_in">sum</span>(dZ)</span><br><span class="line">w = w - alpha*dw</span><br><span class="line">b = b - alpha*db</span><br></pre></td></tr></table></figure><br>其中，<strong>alpha是学习因子</strong>，决定<script type="math/tex">w</script>和<script type="math/tex">b</script>的更新速度。上述代码只是对单次训练更新而言的，外层还需要一个for循环，表示迭代次数。</p>
<h3 id="第三章-浅层神经网络"><a href="#第三章-浅层神经网络" class="headerlink" title="第三章 浅层神经网络"></a>第三章 浅层神经网络</h3><h4 id="3-1-神经网络概览"><a href="#3-1-神经网络概览" class="headerlink" title="3.1 神经网络概览"></a>3.1 神经网络概览</h4><p>首先，我们从整体结构上来大致看一下神经网络模型。</p>
<p>前面的课程中，我们已经使用<strong>计算图</strong>的方式介绍了逻辑回归<strong>梯度下降算法</strong>的<strong>正向传播</strong>和<strong>反向传播</strong>两个过程。如下图所示。神经网络的结构与逻辑回归类似，只是神经网络的层数比逻辑回归多一层，多出来的中间那层称为<strong>隐藏层或中间层</strong>。这样从计算上来说，神经网络的正向传播和反向传播过程只是比逻辑回归多了一次重复的计算。</p>
<p>正向传播过程分成两层，<strong>第一层是输入层到隐藏层</strong>，用上标[1]来表示：</p>
<script type="math/tex; mode=display">
\begin{gathered}
z^{[1]}=W^{[1]} x+b^{[1]} \\
a^{[1]} = \sigma (z^{[1]})
\end{gathered}</script><p>第二层是<strong>隐藏层到输出层</strong>，用上标[2]来表示：</p>
<script type="math/tex; mode=display">
\begin{gathered}
z^{[2]}=W^{[2]} x+b^{[2]} \\
a^{[2]} = \sigma (z^{[2]})
\end{gathered}</script><p>在写法上值得注意的是，方括号上标[i]表示当前所处的层数；圆括号上标(i)表示第i个样本。</p>
<p>同样，<strong>反向传播过程也分成两层</strong>。第一层是输出层到隐藏层，第二层是隐藏层到输入层。其细节部分我们之后再来讨论。</p>
<p><img src="https://pic.imgdb.cn/item/648ac1111ddac507cc54a4ee.png" style="zoom:50%"></p>
<h4 id="3-2-神经网络的表示"><a href="#3-2-神经网络的表示" class="headerlink" title="3.2 神经网络的表示"></a>3.2 神经网络的表示</h4><p>下面我们以图示的方式来介绍单隐藏层的神经网络结构。如下图所示，单隐藏层神经网络就是典型的浅层(shallow)神经网络。</p>
<p><img src="https://pic.imgdb.cn/item/648ac1ad1ddac507cc56265f.png" style="zoom:60%"></p>
<p>结构上，从左到右，可以分成三层：<strong>输入层(Input layer)</strong>，<strong>隐藏层(Hidden layer)</strong>和<strong>输出层(Output  layer)</strong>。输入层和输出层，顾名思义，对应着训练样本的输入和输出，很好理解。隐藏层是抽象的非线性的中间层，这也是其被命名为隐藏层的原因。</p>
<p>在写法上，我们通常把输入矩阵<script type="math/tex">X</script>记为<script type="math/tex">a^{[0]}</script>，把隐藏层输出记为<script type="math/tex">a^{[1]}</script>，上标从<script type="math/tex">0</script>开始。用下标表示第几个神经元，注意下标从<script type="math/tex">1</script>开始。例如<script type="math/tex">a^{[1]}_1</script>表示隐藏层第<script type="math/tex">1</script>个神经元，<script type="math/tex">a^{[1]}_2</script>表示隐藏层第<script type="math/tex">2</script>个神经元等等。这样隐藏层有<script type="math/tex">4</script>个神经元就可以将其输出<script type="math/tex">a^{[1]}</script>写成矩阵的形式：</p>
<script type="math/tex; mode=display">
a^{[1]}=\left[\begin{array}{c}a_{1}^{[1]} \\a_{2}^{[1]} \\a_{3}^{[1]} \\a_{4}^{[1]}\end{array}\right]</script><p>相应的输出层记为<script type="math/tex">a^{[2]}</script>，即<script type="math/tex">\hat y</script>。这种单隐藏层神经网络也称为两层神经网络(2 layer NN)。</p>
<blockquote>
<p>之所以叫两层神经网络是因为，通常我们只会计算隐藏层输出和输出层的输出，输入层是不用计算的。这也是我们把输入层层数上标记为<script type="math/tex">0</script>的原因(<script type="math/tex">a^{[0]}</script>)。<br>关于隐藏层对应的权重<script type="math/tex">W^{[1]}</script>和常数项<script type="math/tex">b^{[1]}</script>，<script type="math/tex">W^{[1]}</script>的维度是<script type="math/tex">(4,3)</script>。这里的<script type="math/tex">4</script>对应着隐藏层神经元个数，<script type="math/tex">3</script>对应着输入层<script type="math/tex">x</script>特征向量包含元素个数。常数项<script type="math/tex">b^{[1]}</script>的维度是<script type="math/tex">(4,1)</script>，这里的<script type="math/tex">4</script>同样对应着隐藏层神经元个数。关于输出层对应的权重<script type="math/tex">W^{[2]}</script>和常数项<script type="math/tex">b^{[2]}</script>，<script type="math/tex">W^{[2]}</script>的维度是<script type="math/tex">(1,4)</script>，这里的<script type="math/tex">1</script>对应着输出层神经元个数，<script type="math/tex">4</script>对应着隐藏层神经元个数。常数项<script type="math/tex">b^{[2]}</script>的维度是<script type="math/tex">(1,1)</script>，因为输出只有一个神经元。</p>
</blockquote>
<p>总结一下，第<script type="math/tex">i</script>层的权重<script type="math/tex">W^{[i]}</script>维度的行等于<script type="math/tex">i</script>层神经元的个数，列等于<script type="math/tex">i-1</script>层神经元的个数；第<script type="math/tex">i</script>层常数项<script type="math/tex">b^{[i]}</script>维度的行等于<script type="math/tex">i</script>层神经元的个数，列始终为<script type="math/tex">1</script>。</p>
<h4 id="3-3-计算神经网络的输出"><a href="#3-3-计算神经网络的输出" class="headerlink" title="3.3 计算神经网络的输出"></a>3.3 计算神经网络的输出</h4><p>本节详细推导神经网络的计算过程。前面讲过两层神经网络可以看成是逻辑回归再重复计算一次。如下图所示，逻辑回归的正向计算可以分解成计算<script type="math/tex">z</script>和<script type="math/tex">a</script>的两部分：</p>
<script type="math/tex; mode=display">
\begin{gathered}
z = w^{\text T}x+b \\
a = \sigma(z)
\end{gathered}</script><p><img src="https://pic.imgdb.cn/item/648ac29f1ddac507cc58f815.png" style="zoom:50%"></p>
<p>对于两层神经网络，从输入层到隐藏层对应一次逻辑回归运算；从隐藏层到输出层对应一次逻辑回归运算。每层计算时，要注意对应的上标和下标，一般我们记上标方括号表示layer，下标表示第几个神经元。例如<script type="math/tex">a^{[l]}_i</script>表示第<script type="math/tex">l</script>层的第<script type="math/tex">i</script>个神经元。<strong>注意，</strong><script type="math/tex">i</script><strong>从</strong><script type="math/tex">1</script><strong>开始，</strong><script type="math/tex">l</script><strong>从</strong><script type="math/tex">0</script><strong>开始</strong>。</p>
<p>将从输入层到输出层的计算公式列出来：</p>
<script type="math/tex; mode=display">
\begin{aligned}&z_{1}^{[1]}=w_{1}^{[1] T} x+b_{1}^{[1]}, a_{1}^{[1]}=\sigma\left(z_{1}^{[1]}\right) \\&z_{2}^{[1]}=w_{2}^{[1] T} x+b_{2}^{[1]}, a_{2}^{[1]}=\sigma\left(z_{2}^{[1]}\right) \\&z_{3}^{[1]}=w_{3}^{[1] T} x+b_{3}^{[1]}, a_{3}^{[1]}=\sigma\left(z_{3}^{[1]}\right) \\&z_{4}^{[1]}=w_{4}^{[1] T} x+b_{4}^{[1]}, a_{4}^{[1]}=\sigma\left(z_{4}^{[1]}\right)\end{aligned}</script><p>然后，从隐藏层到输出层的计算公式为：</p>
<script type="math/tex; mode=display">
z^{[2]}_1 = w^{[1] \text T}_1a^{[1]}+b^{[2]}_1,a^{[2]}_1 = \sigma(z^{[2]}_1)</script><p>其中</p>
<script type="math/tex; mode=display">
a^{[1]}=\left[\begin{array}{c}a_{1}^{[1]} \\a_{2}^{[1]} \\a_{3}^{[1]} \\a_{4}^{[1]}\end{array}\right]</script><p>上述每个节点的计算都对应着一次逻辑运算的过程，分别由计算<script type="math/tex">z</script>和<script type="math/tex">a</script>两部分组成。</p>
<p>为了提高程序运算速度，我们引入向量化和矩阵运算的思想，将上述表达式转换成矩阵运算的形式：</p>
<p><img src="https://pic.imgdb.cn/item/648ac37a1ddac507cc5b55f3.png" style="zoom:50%"></p>
<p>之前也介绍过，这里顺便提一下，<script type="math/tex">W^{[1]}</script>的维度是<script type="math/tex">(4,3)</script>，<script type="math/tex">b^{[1]}</script>的维度是<script type="math/tex">(4,1)</script>，<script type="math/tex">W^{[2]}</script>的维度是<script type="math/tex">(1,4)</script>，<script type="math/tex">b^{[2]}</script>的维度是<script type="math/tex">(1,1)</script>。这点需要特别注意。</p>
<h4 id="3-4-多个样本的向量化"><a href="#3-4-多个样本的向量化" class="headerlink" title="3.4 多个样本的向量化"></a>3.4 多个样本的向量化</h4><p>上一部分我们只是介绍了单个样本的神经网络正向传播矩阵运算过程。而对于<script type="math/tex">m</script>个训练样本，我们也可以使用矩阵相乘的形式来提高计算效率。而且它的形式与上一部分单个样本的矩阵运算十分相似，比较简单。</p>
<p>之前我们也介绍过，在书写标记上用上标<script type="math/tex">(i)</script>表示第<script type="math/tex">i</script>个样本，例如<script type="math/tex">x^{(i)}</script>，<script type="math/tex">z^{(i)}</script>，<script type="math/tex">a^{[2](i)}</script>。对于每个样本<script type="math/tex">i</script>，可以使用for循环来求解其正向输出：</p>
<script type="math/tex; mode=display">
\begin{aligned}for \  i = 1 \ to \ m \\&z^{[1](i)}=W^{[1]} x^{(i)}+b^{[1]} \\&a^{[1](i)}=\sigma\left(z^{[1](i)}\right) \\&z^{[2](i)}=W^{[2]} a^{[1](i)}+b^{[2]} \\&a^{[2](i)}=\sigma\left(z^{[2](i)}\right)\end{aligned}</script><p>不使用for循环，利用矩阵运算的思想，输入矩阵<script type="math/tex">X</script>的维度为<script type="math/tex">(n_x,m)</script>。这样，我们可以把上面的for循环写成矩阵运算的形式：</p>
<script type="math/tex; mode=display">
\begin{gathered}Z^{[1]}=W^{[1]} X+b^{[1]} \\A^{[1]}=\sigma\left(Z^{[1]}\right) \\Z^{[2]}=W^{[2]} A^{[1]}+b^{[2]} \\A^{[2]}=\sigma\left(Z^{[2]}\right)\end{gathered}</script><p>其中，<script type="math/tex">Z^{[1]}</script>的维度是<script type="math/tex">(4,m)</script>，<script type="math/tex">4</script>是隐藏层神经元的个数；<script type="math/tex">A^{[1]}</script>的维度与<script type="math/tex">Z^{[1]}</script>相同；<script type="math/tex">Z^{[2]}</script>和<script type="math/tex">A^{[2]}</script>的维度均为<script type="math/tex">(1,m)</script>。对上面这四个矩阵来说，均可以这样来理解：<strong>行表示神经元个数，列表示样本数目</strong><script type="math/tex">m</script>。</p>
<h4 id="3-5向量化实现的解释"><a href="#3-5向量化实现的解释" class="headerlink" title="3.5向量化实现的解释"></a>3.5向量化实现的解释</h4><p>这部分Andrew用图示的方式解释了<script type="math/tex">m</script>个样本的神经网络矩阵运算过程。其实内容比较简单，只要记住上述四个矩阵的行表示神经元个数，列表示样本数目<script type="math/tex">m</script>就行了。</p>
<p>值得注意的是输入矩阵<script type="math/tex">X</script>也可以写成<script type="math/tex">A^{[0]}</script>。</p>
<h4 id="3-6-激活函数"><a href="#3-6-激活函数" class="headerlink" title="3.6 激活函数"></a>3.6 激活函数</h4><p>神经网络隐藏层和输出层都需要<strong>激活函数(activation function)</strong>，在之前的课程中我们都默认使用Sigmoid函数<script type="math/tex">σ(x)</script>作为激活函数。其实，还有其它激活函数可供使用，不同的激活函数有各自的优点。下面我们就来介绍几个不同的激活函数<script type="math/tex">g(x)</script>。</p>
<p><strong>(1) sigmoid函数</strong></p>
<p><img src="https://pic.imgdb.cn/item/648ac3fb1ddac507cc5c8851.png" style="zoom:70%"></p>
<p><strong>(2) tanh函数</strong></p>
<p><img src="https://pic.imgdb.cn/item/648ac49f1ddac507cc5df268.png" style="zoom:70%"></p>
<p><strong>(3) ReLU函数</strong></p>
<p><img src="https://pic.imgdb.cn/item/648ac4d01ddac507cc5e604c.png" style="zoom:70%"></p>
<p><strong>(4) Leaky ReLU函数</strong></p>
<p><img src="https://pic.imgdb.cn/item/648ac4ed1ddac507cc5ea77a.png" style="zoom:70%"></p>
<p>如上图所示，不同激活函数形状不同，<script type="math/tex">a</script>的取值范围也有差异。</p>
<p>如何选择合适的激活函数呢？首先我们来比较sigmoid函数和tanh函数。对于隐藏层的激活函数，一般来说，tanh函数要比sigmoid函数表现更好一些。因为tanh函数的取值范围在[-1,+1]之间，隐藏层的输出被限定在[-1,+1]之间，可以看成是在0值附近分布，均值为0。这样从隐藏层到输出层，数据起到了归一化（均值为0）的效果。因此，隐藏层的激活函数，tanh比sigmoid更好一些。而对于输出层的激活函数，因为二分类问题的输出取值为{0,+1}，所以一般会选择sigmoid作为激活函数。</p>
<p>观察sigmoid函数和tanh函数，我们发现有这样一个问题，就是当<script type="math/tex">|z|</script>很大的时候，激活函数的斜率（梯度）很小。因此，在这个区域内，梯度下降算法会运行得比较慢。在实际应用中，应尽量避免使z落在这个区域，使<script type="math/tex">|z|</script>尽可能限定在零值附近，从而提高梯度下降算法运算速度。</p>
<p>为弥补sigmoid函数和tanh函数的这个缺陷，就出现了ReLU激活函数。ReLU激活函数在<script type="math/tex">z</script>大于零时梯度始终为1；在<script type="math/tex">z</script>小于零时梯度始终为0；<script type="math/tex">z</script><strong>等于零时的梯度可以当成1也可以当成0</strong>，实际应用中并不影响。对于隐藏层，选择ReLU作为激活函数能够保证z大于零时梯度始终为1，从而提高神经网络梯度下降算法运算速度。但当z小于零时，存在梯度为0的缺点，实际应用中，这个缺点影响不是很大。为了弥补这个缺点，出现了Leaky ReLU激活函数，能够保证z小于零是梯度不为0。</p>
<p>最后总结一下，如果是分类问题，输出层的激活函数一般会选择sigmoid函数。但是隐藏层的激活函数通常不会选择sigmoid函数，tanh函数的表现会比sigmoid函数好一些。实际应用中，通常会会选择使用ReLU或者Leaky ReLU函数，保证梯度下降速度不会太小。其实具体选择哪个函数作为激活函数没有一个固定的准确的答案，应该要根据具体实际问题进行验证(validation)。</p>
<h4 id="3-7-为什么需要非线性激活函数"><a href="#3-7-为什么需要非线性激活函数" class="headerlink" title="3.7 为什么需要非线性激活函数"></a>3.7 为什么需要非线性激活函数</h4><p>我们知道上一部分讲的四种激活函数都是<strong>非线性(non-linear)</strong>的。那是否可以使用线性激活函数呢？答案是不行！下面我们就来进行简要的解释和说明。</p>
<p>假设所有的激活函数都是线性的，为了简化计算，我们直接令激活函数<script type="math/tex">g(z)=z</script>，即<script type="math/tex">a=z</script>。那么，浅层神经网络的各层输出为：</p>
<script type="math/tex; mode=display">
\begin{gathered}z^{[1]}=W^{[1]} x+b^{[1]} \\a^{[1]}=z^{[1]} \\z^{[2]}=W^{[2]} a^{[1]}+b^{[2]} \\a^{[2]}=z^{[2]}\end{gathered}</script><p>我们对上式中<script type="math/tex">a^{[2]}</script>进行化简计算：</p>
<script type="math/tex; mode=display">
\begin{align}a^{[2]}& =z^{[2]} \\& =W^{[2]} a^{[1]}+b^{[2]} \\& =W^{[2]}\left(W^{[1]} x+b^{[1]}\right)+b^{[2]} \\&=\left(W^{[2]} W^{[1]}\right) x+\left(W^{[2]} b^{[1]}+b^{[2]}\right) \\& =W^{\prime} x+b^{\prime}\end{align}</script><p>经过推导我们发现<script type="math/tex">a^{[2]}</script>仍是输入变量<script type="math/tex">x</script>的<strong>线性组合</strong>。这表明，使用神经网络与直接使用线性模型的效果并没有什么两样。即便是包含多层隐藏层的神经网络，<strong>如果使用线性函数作为激活函数，最终的输出仍然是输入</strong><script type="math/tex">x</script><strong>的线性模型</strong>。这样的话神经网络就没有任何作用了。因此，<strong>隐藏层的激活函数必须要是非线性的</strong>。</p>
<p>另外，如果所有的隐藏层全部使用线性激活函数，只有输出层使用非线性激活函数，那么整个神经网络的结构就类似于一个简单的逻辑回归模型，而失去了神经网络模型本身的优势和价值。</p>
<p>值得一提的是，如果是预测问题而不是分类问题，输出<script type="math/tex">y</script>是连续的情况下，输出层的激活函数可以使用线性函数。如果输出<script type="math/tex">y</script>恒为正值，则也可以使用ReLU激活函数，具体情况，具体分析。</p>
<h4 id="3-8-激活函数的导数"><a href="#3-8-激活函数的导数" class="headerlink" title="3.8 激活函数的导数"></a>3.8 激活函数的导数</h4><p>在梯度下降反向计算过程中少不了计算激活函数的导数即梯度。</p>
<p>(1) sigmoid函数的导数</p>
<script type="math/tex; mode=display">
\begin{gathered}g(z)=\frac{1}{1+e^{(-z)}} \\g^{\prime}(z)=\frac{\mathrm d}{\mathrm d z} g(z)=g(z)(1-g(z))=a(1-a)\end{gathered}</script><p>(2) tanh函数的导数</p>
<script type="math/tex; mode=display">
\begin{gathered}g(z)=\frac{e^{(z)}-e^{(-z)}}{e^{(z)}+e^{(-z)}} \\g^{\prime}(z)=\frac{\mathrm d}{\mathrm d z} g(z)=1-(g(z))^{2}=1-a^{2}\end{gathered}</script><p>(3) ReLU函数的导数</p>
<script type="math/tex; mode=display">
\begin{gathered}g(z)=\max (0, z) \\g^{\prime}(z)= \begin{cases}0, & z<0 \\1, & z > 0 \\0\ \text{or}\ 1,& z = 0\end{cases}\end{gathered}</script><p>(4) Leaky ReLU函数的导数</p>
<script type="math/tex; mode=display">
\begin{gathered}g(z)=\max (0.01z, z) \\g^{\prime}(z)= \begin{cases}0.01, & z<0 \\1, & z \geq 0\end{cases}\end{gathered}</script><h4 id="3-9-神经网络的梯度下降法"><a href="#3-9-神经网络的梯度下降法" class="headerlink" title="3.9 神经网络的梯度下降法"></a>3.9 神经网络的梯度下降法</h4><p>你的单隐层神经网络会有<script type="math/tex">W^{[1]}</script>，<script type="math/tex">b^{[1]}</script>，<script type="math/tex">W^{[2]}</script>，<script type="math/tex">b^{[2]}</script>这些参数，还有<script type="math/tex">n_x</script>个表示输入特征的个数，<script type="math/tex">n^{[1]}</script>表示隐藏单元个数, <script type="math/tex">n^{[2]}</script>表示输出单元个数。只介绍这种情况，那么参数:</p>
<p>矩阵<script type="math/tex">W^{[1]}</script>的维度就是<script type="math/tex">(n^{[1]}, n^{[0]})</script>，<script type="math/tex">b^{[1]}</script>就是<script type="math/tex">n^{[1]}</script>维向量，可以写成<script type="math/tex">(n^{[1]},1)</script>，就是一个的列向量。矩阵<script type="math/tex">W^{[2]}</script>的维度就是<script type="math/tex">(n^{[2]},n^{[1]} )</script>, <script type="math/tex">b^{[2]}</script>的维度就是<script type="math/tex">(n^{[2]},1 )</script>。</p>
<p>你还有一个神经网络的成本函数，假设你在做二分类任务，那么你的成本函数等于</p>
<script type="math/tex; mode=display">
J(W^{[1]}, b^{[1]}, W^{[2]}, b^{[2]}) = \frac{1}{m}\sum_{i=1}^{m}{L(\hat y,y)}</script><p>训练参数需要做梯度下降，在训练神经网络的时候，随机初始化参数很重要，而<strong>不是初始化成全零</strong>。当你参数初始化成某些值后，每次梯度下降都会循环计算以下预测值<script type="math/tex">\hat y, (i= 1,2,.... m)</script></p>
<script type="math/tex; mode=display">
\begin{aligned}&\mathrm d W^{[1]}=\frac{\mathrm d J}{\mathrm d W^{[1]}}, \mathrm d b^{[1]}=\frac{\mathrm d J}{\mathrm d b^{[1]}} \\&\mathrm d W^{[2]}=\frac{\mathrm d J}{\mathrm d W^{[2]}}, \mathrm d b^{[2]}=\frac{\mathrm d J}{\mathrm d b^{[2]}}\end{aligned}</script><p>其中，</p>
<script type="math/tex; mode=display">
\begin{aligned}&W^{[1]} \Rightarrow W^{[1]}-\alpha \mathrm d W^{[1]}, b^{[1]} \Rightarrow b^{[1]}-\alpha \mathrm d b^{[1]} \\&W^{[2]} \Rightarrow W^{[2]}-\alpha\mathrm  d W^{[2]}, b^{[2]} \Rightarrow b^{[2]}-\alpha \mathrm d b^{[2]}\end{aligned}</script><p>使用计算图的方式来推导神经网络反向传播过程。记得之前介绍逻辑回归时，我们就引入了计算图来推导正向传播和反向传播，其过程如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648ac6371ddac507cc6308ed.png"></p>
<p>由于多了一个隐藏层，神经网络的计算图要比逻辑回归的复杂一些，如下图所示。对于单个训练样本，正向过程很容易，反向过程可以根据梯度计算方法逐一推导。</p>
<script type="math/tex; mode=display">
\begin{gathered}\mathrm d z^{[2]}=a^{[2]}-y \\
\mathrm d W^{[2]}=\mathrm d z^{[2]} \cdot \frac{\partial z^{[2]}}{\partial W^{[2]}}=\mathrm d z^{[2]} a^{[1] T} \\
\mathrm d b^{[2]}=\mathrm d z^{[2]} \cdot \frac{\partial z^{[2]}}{\partial b^{[2]}}=\mathrm d z^{[2]} \cdot 1=\mathrm d z^{[2]} \\
\mathrm d z^{[1]}=\mathrm d z^{[2]} \cdot \frac{\partial z^{[2]}}{\partial a^{[1]}} \cdot \frac{\partial a^{[1]}}{\partial z^{[1]}}=W^{[2] T}\mathrm  d z^{[2]} * g^{[1]^{\prime}}\left(z^{[1]}\right) \\
\mathrm d b^{[1]}=\mathrm d z^{[1]} \cdot \frac{\partial z^{[1]}}{\partial b^{[1]}}=\mathrm d z^{[1]} \cdot 1=\mathrm d z^{[1]} \\
\mathrm d z^{[1]}=\mathrm d z^{[1]} \cdot \frac{\partial z^{[1]}}{\partial W^{[1]}}=\mathrm d z^{[1]} x^{T}\end{gathered}</script><script type="math/tex; mode=display">
\begin{aligned}&\mathrm d z^{[2]}=A^{[2]}-Y, Y=\left[\begin{array}{lll}y^{[1]} & y^{[2]} & \ldots & \left.y^{[m]}\right]\end{array}\right. \\
&\mathrm d W^{[2]}=\frac{1}{m} \mathrm d z^{[2]} A^{[1] T} \\&\mathrm d b^{[2]}=\frac{1}{m} \text { np.sum }\left(\mathrm d z^{[2]}, \text { axis }=1, \text { keepdims }=\text { True }\right) \\
&\mathrm d z^{[1]}=\underbrace{W^{[2] T} \mathrm d z^{[2]}}_{\left(n^{[1]}, m\right)} \quad \text { activation function of hidden layer } \quad * \underbrace{\left(z^{[1]}\right)}_{\left(n^{[1]}, m\right)} \\
&\mathrm d W^{[1]}=\frac{1}{m} \mathrm d z^{[1]} x^{T} \\
&\underbrace{\mathrm d b^{[1]}}=\frac{1}{m} \text { np.sum }\left(\mathrm d z^{[1]}, \text { axis }=1, \text { keepdims }=\text { True }\right)\end{aligned}</script><p><img src="https://pic.imgdb.cn/item/648ac7ce1ddac507cc677d5e.png"></p>
<p>上述是反向传播的步骤，注：这些都是针对所有样本进行过向量化，<script type="math/tex">Y</script>是<script type="math/tex">1 ∗ m</script>的矩阵；这里np.sum是python的numpy命令，<strong>axis=1表示水平相加求和</strong>，<strong>keepdims防止python输出那些古怪的秩数</strong><script type="math/tex">(n , )</script>，加上这个确保矩阵<script type="math/tex">db^{[2]}</script>这个向量输出维度为<script type="math/tex">( n , 1 )</script>这样标准的形式。</p>
<p>总结一下，浅层神经网络(包含一个隐藏层)，<script type="math/tex">m</script>个训练样本的正向传播过程和反向传播过程分别包含了6个表达式，其向量化矩阵形式如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648ac8041ddac507cc681841.png"></p>
<h4 id="3-10-选修-直观理解反向传播"><a href="#3-10-选修-直观理解反向传播" class="headerlink" title="3.10 (选修)直观理解反向传播"></a>3.10 (选修)直观理解反向传播</h4><p>本节记录一下我的两个疑问：</p>
<p>(1) 矩阵微积分问题</p>
<p>(2) <script type="math/tex">\mathrm dZ</script>的式子中没有<script type="math/tex">1/m</script>项</p>
<p>本小节笔记参考链接：<a href="https://blog.csdn.net/weixin_36815313/article/details/105341107">3.10 直观理解反向传播-深度学习-Stanford吴恩达教授_赵继超的笔记-CSDN博客</a></p>
<h4 id="3-11-随机初始化"><a href="#3-11-随机初始化" class="headerlink" title="3.11 随机初始化"></a>3.11 随机初始化</h4><p>神经网络模型中的参数权重W是不能全部初始化为零的，接下来我们分析一下原因。</p>
<p>举个简单的例子，一个浅层神经网络包含两个输入，隐藏层包含两个神经元。如果权重<script type="math/tex">W[1]</script>和<script type="math/tex">W^{[2]}</script>都初始化为零，即：</p>
<script type="math/tex; mode=display">
\begin{gathered}W^{[1]}=\left[\begin{array}{ll}0 & 0 \\0 & 0\end{array}\right] \\W^{[2]}=\left[\begin{array}{ll}0 & 0\end{array}\right]\end{gathered}</script><p><img src="https://pic.imgdb.cn/item/648ac8e91ddac507cc6ae7b1.png" style="zoom:60%"></p>
<p>这样使得隐藏层第一个神经元的输出等于第二个神经元的输出，即<script type="math/tex">a^{[1]}_1=a^{[1]}_2</script>。经过推导得到<script type="math/tex">dz^{[1]}_1 = dz^{[1]}_2</script>，以及<script type="math/tex">dW^{[1]}_1 = dW^{[1]}_2</script>。因此，这样的结果是隐藏层两个神经元对应的权重行向量<script type="math/tex">W^{[1]}_1</script>和<script type="math/tex">W^{[1]}_2</script>，每次迭代更新都会得到完全相同的结果，<script type="math/tex">W^{[1]}_1</script>始终等于<script type="math/tex">W^{[1]}_2</script>，完全对称。这样隐藏层设置多个神经元就没有任何意义了。值得一提的是，<strong>参数</strong><script type="math/tex">b</script><strong>可以全部初始化为零</strong>，并不会影响神经网络训练效果；<strong>此外权重</strong><script type="math/tex">W</script><strong>不能全初始化为零，也不能全部初始化为一样的值。</strong></p>
<p>我们把这种权重W全部初始化为零带来的问题称为symmetry breaking problem。解决方法也很简单，就是将W进行随机初始化(b可初始化为零)。python里可以使用如下语句进行W和b的初始化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">W_1 = np.random.randn((<span class="number">2</span>,<span class="number">2</span>))*<span class="number">0.01</span></span><br><span class="line">b_1 = np.zero((<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">W_2 = np.random.randn((<span class="number">1</span>,<span class="number">2</span>))*<span class="number">0.01</span></span><br><span class="line">b_2 = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里我们将<script type="math/tex">W^{[1]}_1</script>和<script type="math/tex">W^{[1]}_2</script>乘以<script type="math/tex">0.01</script>的目的是尽量使得权重<script type="math/tex">W</script>初始化比较小的值。之所以让<script type="math/tex">W</script>比较小，是因为如果使用sigmoid函数或者tanh函数作为激活函数的话，<script type="math/tex">W</script>比较小，得到的<script type="math/tex">|z|</script>也比较小(靠近零点)，而<strong>零点区域的梯度比较大</strong>，这样能大大提高梯度下降算法的更新速度，尽快找到全局最优解。如果<script type="math/tex">W</script>较大，得到的<script type="math/tex">|z|</script>也比较大，附近曲线平缓，梯度较小，训练过程会慢很多。</p>
<p>当然，如果激活函数是ReLU或者Leaky ReLU函数，则不需要考虑这个问题。但是，如果输出层是sigmoid函数，则对应的权重最好初始化到比较小的值。</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
        <category>深度学习基础</category>
      </categories>
      <tags>
        <tag>深度学习基础</tag>
      </tags>
  </entry>
  <entry>
    <title>英语语法学习</title>
    <url>/2022/04/29/English-grammar-learning/</url>
    <content><![CDATA[<h3 id="第〇章-英语语法体系框架概述"><a href="#第〇章-英语语法体系框架概述" class="headerlink" title="第〇章 英语语法体系框架概述"></a>第〇章 英语语法体系框架概述</h3><p>两个句子最基本的成分是“主语”+“谓语”</p>
<p>主语：一般是指人或物，包括抽象和具体</p>
<p>谓语：动作(动词)/发生了什么事</p>
<p>有哪些不同类型的动作：</p>
<ul>
<li>可以独立完成的动作——主语+不及物动词</li>
</ul>
<p>没有承受者的动词叫做“不及物动词”</p>
<ul>
<li>有1个动作承受者——主语+(单)及物动词+宾语</li>
</ul>
<p>有承受者的动词称为“(单)及物动词”，后接的动作承受者就是“宾语”</p>
<ul>
<li>有个动作承受者——主语+(双)及物动词+间接宾语+直接宾语</li>
</ul>
<p>e.g. My father teaches me English</p>
<p>上面的句子中及物动词为“teach”，教授的知识是英语，而知识的接收对象是“me”，这种情况将宾语分为“直接宾语”(English)，“间接宾语”(me)。此时动词称为“(双)及物动词”</p>
<ul>
<li>只有1个动作承受者(但有补充内容)——主语+复杂及物动词+宾语+宾语补足语</li>
</ul>
<p>e.g. I consider you smart</p>
<p>上面例句中“smart“是补充信息，语法上称为”宾语补足语/补语”，需要宾语补足语的动词称为“复杂及物动词”</p>
<ul>
<li>非动作——主语+系动词+(主语)补语/表语</li>
</ul>
<p>e.g. He is tall. She looks nice.</p>
<p>像例句中is、look等赋予主语某种性质状态的“划等号”的动词称为连系动词(系动词)。系动词后面的信息也属于补语，但是这里是“主语补足语”(又称“表语”)</p>
<p>综上，可以做个小总结</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>英语基本句型</th>
</tr>
</thead>
<tbody>
<tr>
<td>主语+动词</td>
</tr>
<tr>
<td>主语+动词+宾语</td>
</tr>
<tr>
<td>主语+动词+间接宾语+直接宾语</td>
</tr>
<tr>
<td>主语+动词+宾语+宾语补足语</td>
</tr>
<tr>
<td>主语+动词+(主语)补语/表语</td>
</tr>
</tbody>
</table>
</div>
<p>注意：严格说来，谓语不同于谓语动词，句子主语后面剩余的部分统称谓语，而谓语动词是谓语的一部分。</p>
<p>定语：主要用来修饰主语或宾语</p>
<p>状语：主要用来修饰谓语动词</p>
<p>e.g. The rabbit ate quickly.</p>
<p>上面例句中quickly就是ate的状语</p>
<p>同位语：主要用来再把主语或者宾语说一遍</p>
<p>e.g. The rabbit, an English teacher, eats carrots.</p>
<p>“an English teacher”就是把主语The rabbit再以不同的方式说一遍</p>
<p>以上是简单句的基本组成成分，但是英语中不可能总是简单句子，更多的是简单句子的叠加，叠加的句子分为两种：</p>
<ul>
<li>compound sentence/复合句/并列句：句子的简单叠加，是并列关系</li>
<li>complex sentence/复杂句：把一个句子套在另一个句子里，作为另一个句子的成分</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/626bda20239250f7c549ac0e.jpg" style="zoom:30%"></p>
<p>从句可以简单理解为把简单句子修改一下来充当另一个句子的句子成分</p>
<p><img src="https://pic.imgdb.cn/item/626be38a239250f7c56180ca.jpg" style="zoom:50%"></p>
<p>词性</p>
<p>名词：表人和物</p>
<p>动词：表示动作</p>
<p>冠词：说明人和事物</p>
<p>代词：替代人和物</p>
<p>形容词：形容人和物</p>
<p>数词：表示数量</p>
<p>副词：修饰动作或形容词</p>
<p>介词：表示和其他词关系的词</p>
<p>连词：连接词和句：and、but、because</p>
<p>叹词：表感叹</p>
<p>谓语动词的“三大本领”：</p>
<ul>
<li>表示动作的时间：比如动作可能发生在过去、现在、将来</li>
<li>表示动作的状态：动作可能是已经完成的状态、正在进行的状态等</li>
</ul>
<p>动作的时间和状态组合一起就是动词的时态</p>
<p><img src="https://pic.imgdb.cn/item/626beae2239250f7c57480cf.jpg"></p>
<p><img src="/2022/04/29/English-grammar-learning/Users\27275\AppData\Local\Temp\1651239758116.png" alt="1651239758116"></p>
<ul>
<li>表示动作的假设、情感、语气(并不是指的是平时说话的语气)等<ul>
<li>虚拟语气：用来表示意愿、和事实相反的假设</li>
<li>陈述语气：</li>
<li>祈使语气：</li>
</ul>
</li>
</ul>
<p>助动词：协助动词充分发挥作用</p>
<p><img src="https://pic.imgdb.cn/item/626bee5e239250f7c57e161c.jpg"></p>
<p>但是有一些助动词喜欢“伪装”，它们在做助动词时(没有实义，只是帮助谓语动词)，但是它们还可以做实义动词甚至其他词性，比如：can可以是“易拉罐”，have可以是“拥有”…</p>
<p>非谓语动词：</p>
<p>当动词在句子中充当除谓语动词以外的词时(主语、宾语、宾语补语、主语补语、定语等)称为非谓语动词，非谓语动词几乎可以取代所有的从句，从而简化句子，但此时这样的动词也就不再具有表示时间、状态、语态、语气的功能了</p>
<p><img src="https://pic.imgdb.cn/item/626bf04d239250f7c5836bc4.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/626bf0d3239250f7c584e808.jpg"></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>英语基础</category>
      </categories>
      <tags>
        <tag>英语语法</tag>
      </tags>
  </entry>
  <entry>
    <title>信息搜索技巧</title>
    <url>/2023/01/12/Google-Search-Tips/</url>
    <content><![CDATA[<h3 id="1-搜索引擎命令大全"><a href="#1-搜索引擎命令大全" class="headerlink" title="1 搜索引擎命令大全"></a>1 搜索引擎命令大全</h3><h4 id="1-1-site：在某个网站或域名下搜索"><a href="#1-1-site：在某个网站或域名下搜索" class="headerlink" title="1.1 site：在某个网站或域名下搜索"></a>1.1 site：在某个网站或域名下搜索</h4><blockquote>
<p>在特定的网站下进行检索，不仅可以搜索网页，还可以搜索某个站点下的所有图片、视频、新闻等。 例如：樱花 site:http ://edu.cn表示在中国教育网下搜索樱花</p>
</blockquote>
<p><strong>使用方式以及示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二战纪录片 site:zhihu.com; baidu.com</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63bfae4ebe43e0d30ea30f62.jpg"></p>
<p><strong>作用：</strong></p>
<ul>
<li>替代站内搜索</li>
<li>指定网站搜索、缩小范围、提供精准结果</li>
<li>搜索不能直接访问的网站；死网站；绕过注册</li>
</ul>
<h4 id="1-2-Filetype：搜索某种类型的文件"><a href="#1-2-Filetype：搜索某种类型的文件" class="headerlink" title="1.2 Filetype：搜索某种类型的文件"></a>1.2 Filetype：搜索某种类型的文件</h4><blockquote>
<p>搜索指定的文件类型，用来查找文献、电子书、PPT 等非常有用 支持的文件类型：ppt、ppts、doc、docx、xlsx、pdf、txt 等（不同的搜索引擎支持的文件类型不同）</p>
</blockquote>
<p><strong>使用方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">百年孤独 filetype:pdf</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63bfaed9be43e0d30ea3fedc.jpg"></p>
<h4 id="1-3-逻辑与、或：AND、OR"><a href="#1-3-逻辑与、或：AND、OR" class="headerlink" title="1.3 逻辑与、或：AND、OR"></a>1.3 逻辑与、或：AND、OR</h4><ul>
<li>注意AND、OR必须大写，否则会被认为是普通的单词，而不是搜索指令。</li>
<li>与普通编程语言不一样的是，OR指令优先于AND指令。</li>
<li>简写：AND指令一般以空格代替，不明确写出。另外AND指令还可以用+代替。OR指令可用 | 代替。</li>
</ul>
<p><strong>使用方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">手机 OR 相机 电脑 OR 鼠标 OR 键盘</span><br><span class="line">它等同于 (手机 OR 相机) (电脑 OR 鼠标 OR 键盘)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63bfb025be43e0d30ea61e37.jpg"></p>
<p><strong>4、逻辑非：-</strong></p>
<blockquote>
<p>逻辑非 - ，也就是减号，代表搜索不包含减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。Google 和 baidu 都支持这个指令。</p>
</blockquote>
<p><strong>使用方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">搜索引擎 历史 -文化 -中国历史 -世界历史</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63bfb271be43e0d30eac68af.jpg"></p>
<p><strong>5、双引号</strong></p>
<blockquote>
<p>把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。bd和Google 都支持这个指令。</p>
</blockquote>
<p><strong>使用方法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“模拟”信号处理</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63bfb1a0be43e0d30ea9c058.jpg"></p>
<h4 id="1-6-通配符：-和"><a href="#1-6-通配符：-和" class="headerlink" title="1.6 通配符：?和*"></a>1.6 通配符：?和*</h4><ul>
<li>与我们通常的习惯一致，“*”代表一连串字符，“?”代表单个字符。</li>
<li>样例：</li>
</ul>
<p>使用方法：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">示例<span class="number">1</span>：progr?m</span><br><span class="line"># 不要指望Google可用通过progr?m搜索到program，因为progr和m分别被当作一个独立的单词</span><br><span class="line"># 并且这两个单词之间允许出现一个字符，如此而已。</span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span>：the * of money</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63bfb33cbe43e0d30eae38b9.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/63bfb54bbe43e0d30eb18c22.jpg"></p>
<h4 id="1-7-in指令-位置关键词查找"><a href="#1-7-in指令-位置关键词查找" class="headerlink" title="1.7 in指令: 位置关键词查找"></a>1.7 in指令: 位置关键词查找</h4><ul>
<li>intitle: 在网页标题中查找。这通常对讨论比较多的热门话题很有效。<ul>
<li>例如：intitle:”GeForce 7800”+测试</li>
</ul>
</li>
<li>allintitle: 该指令属于排他指令，不能与其他指令混用。<ul>
<li>例如：allintitile:”GeForce 7800” 测试 与 intitle:”GeForce 7800”+测试 的含义一致。但是，allintitile是排他的，不能加上其他非intitle方面的限制条件。</li>
<li>注意：在这里，你会发现用+代替AND指令是很有意思的。如果没有+指令，我们就需要写：intitle:”GeForce 7800” intitle:测试，因为Google不支持这样的写法：intitle:(“GeForce 7800” 测试)</li>
</ul>
</li>
<li>inurl: 在网页的url地址中查找。<ul>
<li>例如：inurl:dowload 表示查找url中包含download的网页。</li>
</ul>
</li>
<li>allinurl: 结果中带有“XXX”和“YYY”，相当于“inurl:XXX inurl:YYY”</li>
<li>inanchor: 在网页的链接锚中查找。<ul>
<li>需要注意区别于inurl：inurl是网页本身的url地址，而inanchor是查找网页内容中的超链接。</li>
<li>例如：inanchor:download，你可能会发现有FlashGet最佳的下载管理程式，而该页面中根本就没有download字样。</li>
</ul>
</li>
<li>allinanchor</li>
<li>intext: 在正文中检索。</li>
<li>allintext</li>
</ul>
<h5 id="1-7-1-inurl"><a href="#1-7-1-inurl" class="headerlink" title="1.7.1 inurl"></a>1.7.1 inurl</h5><blockquote>
<p>用于指定搜索查询词出现在url 中的页面。baidu 和Google 都支持inurl 指令。inurl 指令支持中文和英文。</p>
</blockquote>
<p><strong>使用方法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inurl:大学</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63bfb648be43e0d30eb309a0.jpg"></p>
<h5 id="1-7-2-inanchor"><a href="#1-7-2-inanchor" class="headerlink" title="1.7.2 inanchor"></a>1.7.2 inanchor</h5><blockquote>
<p>inanchor:指令返回的结果是导入链接锚文字中包含搜索词的页面。百度不支持inanchor。 比如在Google 搜索 ：inanchor:点击这里 返回的结果页面本身并不一定包含“点击这里”这四个字，而是指向这些页面的链接锚文字中出现了“点击这里”这四个字。 可以用来找到某个关键词的竞争对收，而且这些竞争对手往往是做过SEO 的。研究竞争对手页面有哪些外部链接，就可以找到很多链接资源。</p>
</blockquote>
<p><strong>使用方法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inanchor:点击这里</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63bfb74cbe43e0d30eb4bf3b.jpg"></p>
<h5 id="1-7-3-intitle"><a href="#1-7-3-intitle" class="headerlink" title="1.7.3 intitle"></a>1.7.3 intitle</h5><blockquote>
<p>指定返回的页面 title 中包含关键词。Google 和bd都支持intitle 指令。</p>
</blockquote>
<p><strong>使用方法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intitle:知乎科技</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63bfb787be43e0d30eb5333f.jpg"></p>
<h5 id="1-7-4-allintitle"><a href="#1-7-4-allintitle" class="headerlink" title="1.7.4 allintitle"></a>1.7.4 allintitle</h5><blockquote>
<p>搜索返回的是页面标题中包含多组关键词的文件。 例如 ：allintitle:知乎 手机 科技 就相当于：intitle:知乎 intitle:手机 intitle:科技，返回的是标题中中既包含“知乎”，也包含“手机”和”科技”的页面</p>
</blockquote>
<p><strong>使用方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allintitle:知乎 手机 科技</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63bfb81cbe43e0d30eb62a14.jpg"></p>
<h4 id="1-8-link-搜索所有链接到某个URL地址的网页"><a href="#1-8-link-搜索所有链接到某个URL地址的网页" class="headerlink" title="1.8 link: 搜索所有链接到某个URL地址的网页"></a>1.8 link: 搜索所有链接到某个URL地址的网页</h4><ul>
<li>最重要的用途：迅速判断一个网页的“热度”。</li>
<li>例如：link:<a href="http://www.newhua.com">http://www.newhua.com</a> 表示所有指向“华军软件园”外部链接。</li>
<li>注意：和其他指令类似，link:和url之间不能有空格。之所以特别指出这一点，是因为网上有教程说link和allinurl等一样，是排他指令，中间可以有空格。我不太了解Google搜索指令的发展历史，只能猜测曾经如此。</li>
</ul>
<p><strong>使用方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link:www.newhua.com</span><br></pre></td></tr></table></figure>
<h4 id="1-9-related-寻找某网页的“类似网页”"><a href="#1-9-related-寻找某网页的“类似网页”" class="headerlink" title="1.9 related: 寻找某网页的“类似网页”"></a>1.9 related: 寻找某网页的“类似网页”</h4><ul>
<li>例如：related:<a href="http://www.newhua.com">http://www.newhua.com</a> 表示找和“华军软件园”类似的网页。</li>
<li>这条指令其实Google自己用得很广泛，只是可能没有引起你的注意罢了。在Google的每条搜索结果中，均有一个“类似网页”的链接。就是它了。</li>
</ul>
<p><strong>使用方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">related:www.newhua.com</span><br></pre></td></tr></table></figure>
<h4 id="1-10-数值范围："><a href="#1-10-数值范围：" class="headerlink" title="1.10 数值范围：.."></a>1.10 数值范围：..</h4><ul>
<li>例如：数码相机 600..900 万像素 3000..4000 元</li>
<li>注意：“900”与“万”之间必须有空格。</li>
</ul>
<p><strong>使用方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数码相机 600..900 万像素 3000..4000 元</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/63bfb914be43e0d30eb7abde.jpg"></p>
<h3 id="2-高级搜索技巧"><a href="#2-高级搜索技巧" class="headerlink" title="2 高级搜索技巧"></a>2 高级搜索技巧</h3><blockquote>
<p>google 在界面上提供搜索条件查询「限制语言」、「按照时间」、「精确匹配」（百度等其他同理）</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/63bfb9c7be43e0d30eb93c45.jpg"></p>
<blockquote>
<p>google 高级搜索界面，其实就是前面介绍的命令的界面版（百度等其他同理） </p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/63bfba8dbe43e0d30eba9658.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/63bfbaf5be43e0d30ebb408e.jpg"></p>
<p>相关链接：<a href="https://www.freecodecamp.org/chinese/news/how-to-google-like-a-pro-10-tips-for-effective-googling/">如何像专家一样高效使用 Google 搜索</a></p>
<hr>
<p>本文转自简书(侵删)：<br>作者：非凡公社<br>链接：<a href="https://www.jianshu.com/p/22aae651cc68">https://www.jianshu.com/p/22aae651cc68</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
      </categories>
      <tags>
        <tag>搜索技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数_Part1</title>
    <url>/2022/05/03/LinearAlgebra1/</url>
    <content><![CDATA[<h3 id="1-线性代数基础"><a href="#1-线性代数基础" class="headerlink" title="1 线性代数基础"></a>1 线性代数基础</h3><h4 id="1-1-方程组的几何解释基础"><a href="#1-1-方程组的几何解释基础" class="headerlink" title="1.1 方程组的几何解释基础"></a>1.1 方程组的几何解释基础</h4><p>本节主要介绍线性代数的基础。首先从解方程开始，学习线性代数的应用之一就是求解复杂的方程问题，本节核心之一就是从row picture(行图像)和column picture(列图像)的角度解方程。</p>
<h5 id="1-1-1-二维行图像"><a href="#1-1-1-二维行图像" class="headerlink" title="1.1.1 二维行图像"></a>1.1.1 二维行图像</h5><p>如下所示，一个普通的方程组：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{r}
2 x-y=0 \\
-x+2 y=3
\end{array}\right.</script><p>按行将方程组写成矩阵形式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cc}
2 & -1 \\
-1 & 2
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]=\left[\begin{array}{l}
0 \\
3
\end{array}\right]</script><p>分别可以记为：</p>
<ul>
<li>系数矩阵($\boldsymbol A$): 将方程组系数按行提取出来，构造完成的一个矩阵。</li>
</ul>
<ul>
<li>未知向量($\boldsymbol x$): 将方程组的未知数提取出来，按列构成一个向量。 </li>
</ul>
<ul>
<li>向量($\boldsymbol b$): 将等号右侧结果按列提取，构成一个向量。</li>
</ul>
<p>从行的角度来看，$2x-y=0$和$-x+2y = 3$分别表示两条二维平面中的直线，如果这两条直线相交，那么交点的坐标$(x^<em>, y^</em>)$即为方程组的解。</p>
<p>更确切的讲，如果两条直线相交于一点，那么该方程组有且仅有一个解，即为交点的坐标；如果两条直线重合，那么说明这两条直线方程实际上是同一条直线，此时直线上的所有点的坐标均为方程组的解；如果两条直线平行但不重合，则说明不存在点的坐标同时满足这两条直线的方程，此时方程组无解。</p>
<h5 id="1-1-2-二维列图像"><a href="#1-1-2-二维列图像" class="headerlink" title="1.1.2 二维列图像"></a>1.1.2 二维列图像</h5><p>从列图像的角度，再次求解上面的方程，即将方程按列提取，得到的矩阵为：</p>
<script type="math/tex; mode=display">
x\left[\begin{array}{c}
2 \\
-1
\end{array}\right]+y\left[\begin{array}{c}
-1 \\
2
\end{array}\right]=\left[\begin{array}{l}
0 \\
3
\end{array}\right]</script><p>使用列向量构成系数矩阵，将问题转化为：将向量$\boldsymbol \alpha=\left[\begin{array}{c}2 \\ -1\end{array}\right]$与向量$\boldsymbol \beta=\left[\begin{array}{c}-1 \\ 2\end{array}\right]$ 任意组合，使其结果构成$\boldsymbol \gamma=\left[\begin{array}{c}0 \\ 3\end{array}\right]$，也就是“线性组合”，它是贯穿线性代数的基本方法。$x, y$称为线性组合的系数，因此线性方程组就可以理解为：<br>是否存在合适的线性组合系数$x, y$，使得$\boldsymbol \alpha, \boldsymbol \beta$的线性组合 $x\boldsymbol \alpha + y\boldsymbol \beta$恰好等于$\boldsymbol \gamma$。如果存在，线性组合的系数为多少？</p>
<p>值得一提的是，从列的角度看待线性方程组是一种非常重要的理解方式，以后会经常用到这样的思想。</p>
<p>对于一般的$n$维线性方程组$\boldsymbol{Ax = b}$，其中$\boldsymbol A$是$n \times n$维系数矩阵，$\boldsymbol x$是$n$维列向量。$\boldsymbol b$是方程组右端的$n$维列向量。不妨设$\boldsymbol A$由$n$个列向量$(\boldsymbol \alpha_1, \boldsymbol \alpha_2, \cdots, \boldsymbol \alpha_n)$组成，$\boldsymbol x=\left[\begin{array}{c}x_1 \\ x_2 \\ \vdots \\ x_n\end{array}\right]$，则方程组$\boldsymbol{Ax = b}$可以表示为：</p>
<script type="math/tex; mode=display">
\left(\boldsymbol \alpha_{1}, \boldsymbol \alpha_{2}, \cdots, \boldsymbol \alpha_{n}\right)\left(\begin{array}{c}
x_1 \\ x_2 \\ \vdots \\ x_n \end{array}\right)= \boldsymbol b</script><p>即</p>
<script type="math/tex; mode=display">
x_1 \boldsymbol \alpha_{1} + x_2 \boldsymbol \alpha_{2} + \cdots + x_n\boldsymbol \alpha_{n} = \boldsymbol b</script><p>由此可以看出，矩阵$\boldsymbol A$乘以向量$\boldsymbol x$相当于对$\boldsymbol A$的$n$个列向量作线性组合，线性组合的系数即为向量$\boldsymbol x$各对应的分量。因此对线性方程组可以理解为：是否存在合适的线性组合系数，使得$\boldsymbol A$的列向量的线性组合恰好为$\boldsymbol b$。如果存在，线性组合的系数为多少？这些线性组合的系数就构成了$\boldsymbol{Ax = b}$的解向量$\boldsymbol x$。</p>
<h4 id="1-2-线性方程组有解情况"><a href="#1-2-线性方程组有解情况" class="headerlink" title="1.2 线性方程组有解情况"></a>1.2 线性方程组有解情况</h4><p>首先考虑对于任意的$n$维列向量$\boldsymbol x$，当$\boldsymbol x$变动时，$\boldsymbol{Ax}$也在变动，当 $\boldsymbol x$取遍所有的$n$维列向量时，$\boldsymbol{Ax}$就能取遍所有$\boldsymbol A$的列向量的线性组合，也就是说，所有的$\boldsymbol{Ax}$就构成了$\boldsymbol A$的列向量张成的线性空间$\boldsymbol{V} = \text{span} \begin{Bmatrix} \boldsymbol \alpha_1, \boldsymbol \alpha_2, \cdots, \boldsymbol \alpha_n \end{Bmatrix}$ (span是一组集合，它包含两个向量之间的全部线性组合)，因此：</p>
<script type="math/tex; mode=display">
\boldsymbol{Ax = b}有解 \Longleftrightarrow \boldsymbol b \in \boldsymbol{V} = \text{span} \begin{Bmatrix} \boldsymbol \alpha_1, \boldsymbol \alpha_2, \cdots, \boldsymbol \alpha_n \end{Bmatrix}</script><p>又由于</p>
<script type="math/tex; mode=display">
\boldsymbol b \in \boldsymbol{V} = \text{span} \begin{Bmatrix} \boldsymbol \alpha_1, \boldsymbol \alpha_2, \cdots, \boldsymbol \alpha_n \end{Bmatrix}</script><p>因此也就得出了</p>
<script type="math/tex; mode=display">
\boldsymbol{Ax = b}有解 \Longleftrightarrow \text{Rank}(\boldsymbol A) = \text{Rank}(\boldsymbol A, \boldsymbol b)</script><p>特别地，若$\boldsymbol A$的$n$个列向量线性无关，则这$n$个列向量就构成了$n$维向量空间的一组基。此时对任意的向量均可由$\boldsymbol A$的列向量线性表出，也即是一定有解。换言之，如果$\boldsymbol A$<strong>可逆/非奇异</strong>，则一定有解。</p>
<h4 id="1-3-矩阵乘法理解"><a href="#1-3-矩阵乘法理解" class="headerlink" title="1.3 矩阵乘法理解"></a>1.3 矩阵乘法理解</h4><p>有了对线性方程组的这些认识，我们可以更好地理解矩阵乘法。</p>
<p><strong>(一) 向量右乘矩阵</strong></p>
<p>首先考虑列向量$\boldsymbol x \in \mathbb{R}^n$右乘矩阵$\boldsymbol A \in \mathbb{R}^{n \times n}$。先从行的角度考虑，不妨设：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}=\left(\begin{array}{c}
\boldsymbol{a}_{1}^{\mathrm{T}} \\
\boldsymbol{\alpha}_{2}^{\mathrm{T}} \\
\vdots \\
\boldsymbol{\alpha}_{n}^{\mathrm{T}}
\end{array}\right), \boldsymbol{x}=\left(\begin{array}{c}
x_{1} \\
x_{2} \\
\vdots \\
x_{n}
\end{array}\right)</script><p>则有：</p>
<script type="math/tex; mode=display">
\boldsymbol{A} \boldsymbol{x}=\left(\begin{array}{c}
\boldsymbol{\alpha}_{1}^{\mathrm{T}} \\
\boldsymbol{\alpha}_{2}^{\mathrm{T}} \\
\vdots \\
\boldsymbol{\alpha}_{n}^{\mathrm{T}}
\end{array}\right) \boldsymbol{x}=\left(\begin{array}{c}
\boldsymbol{\alpha}_{1}^{\mathrm{T}} \boldsymbol{x} \\
\boldsymbol{\alpha}_{2}^{\mathrm{T}} \boldsymbol{x} \\
\vdots \\
\boldsymbol{a}_{n}^{\mathrm{T}} \boldsymbol{x}
\end{array}\right)=\left(\begin{array}{c}
\boldsymbol{\alpha}_{1} \cdot \boldsymbol{x} \\
\boldsymbol{\alpha}_{2} \cdot \boldsymbol{x} \\
\vdots \\
\boldsymbol{\alpha}_{n} \cdot \boldsymbol{x}
\end{array}\right)</script><p>由此可知，从行的角度来看，$\boldsymbol{Ax}$相当于分别用$\boldsymbol A$的行点乘$\boldsymbol x$，这就是矩阵乘法的定义。<br>下面从列的角度考虑，这是一种非常重要的理解方式。不妨设：</p>
<script type="math/tex; mode=display">
\boldsymbol A = (\boldsymbol \beta_1, \boldsymbol \beta_2, \cdots, \boldsymbol \beta_n)</script><p>则有：</p>
<script type="math/tex; mode=display">
\boldsymbol{A} \boldsymbol{x}=\left(\boldsymbol{\beta}_{1}, \boldsymbol{\beta}_{2}, \cdots, \boldsymbol{\beta}_{n}\right)\left(\begin{array}{c}
x_{1} \\
x_{2} \\
\vdots \\
x_{n}
\end{array}\right)=x_{1} \boldsymbol{\beta}_{1}+x_{2} \boldsymbol{\beta}_{2}+\cdots+x_{n} \boldsymbol{\beta}_{n}</script><p>由此即知，列向量$\boldsymbol x$右乘矩阵$\boldsymbol A$即是对$\boldsymbol A$的列向量作线性组合，$\boldsymbol x$的各分量即为线性组合的系数。</p>
<p><strong>(二) 向量左乘矩阵</strong></p>
<p>下面考虑行向量$\boldsymbol y^{\mathrm T}$左乘矩阵$\boldsymbol A \in \mathbb{R}^{n \times n}$，其中$\boldsymbol y \in \mathbb{R}^{n}$，不妨设：</p>
<script type="math/tex; mode=display">
\boldsymbol{y}^{\mathrm{T}}=\left(y_{1}, y_{2}, \cdots, y_{n}\right)</script><p>则有：</p>
<script type="math/tex; mode=display">
\boldsymbol{y}^{\mathrm{T}} \boldsymbol{A}=\left(y_{1}, y_{2}, \cdots, y_{n}\right)\left(\begin{array}{c}
\boldsymbol{\alpha}_{1}^{\mathrm{T}} \\
\boldsymbol{\alpha}_{2}^{\mathrm{T}} \\
\vdots \\
\boldsymbol{a}_{n}^{\mathrm{T}}
\end{array}\right)=y_{1} \boldsymbol{\alpha}_{1}^{\mathrm{T}}+y_{2} \boldsymbol{\alpha}_{2}^{\mathrm{T}}+\cdots y_{n} \boldsymbol{\alpha}_{n}^{\mathrm{T}}</script><p>由此即知，行向量$\boldsymbol y^{\mathrm T}$左乘矩阵$\boldsymbol A$相当于对$\boldsymbol A$的行向量作线性组合，$\boldsymbol y^{\mathrm T}$的各分量即为线性组合的系数。</p>
<p>综上所述，列向量$\boldsymbol x$右乘矩阵$\boldsymbol A$相当于对$\boldsymbol A$的列向量作线性组合，$\boldsymbol x$的各分量即为线性组合的系数；行向量$\boldsymbol y^{\mathrm T}$左乘矩阵$\boldsymbol A$相当于对$\boldsymbol A$的行向量作线性组合，$\boldsymbol y^{\mathrm T}$的各分量即为线性组合的系数。</p>
<p><strong>(三) 矩阵乘以矩阵</strong></p>
<p>对于矩阵与矩阵的乘法，只需把矩阵按行或列分块，即可按上述向量乘矩阵的方式理解。</p>
<script type="math/tex; mode=display">
\boldsymbol{A B}=\boldsymbol{A}\left(\boldsymbol{\beta}_{1}, \boldsymbol{\beta}_{2}, \cdots, \boldsymbol{\beta}_{n}\right)=\left(\boldsymbol{A} \boldsymbol{\beta}_{1}, \boldsymbol{A} \boldsymbol{\beta}_{2}, \cdots, \boldsymbol{A} \boldsymbol{\beta}_{n}\right)=\left(\begin{array}{c}
\boldsymbol{\alpha}_{1}^{T} \\
\boldsymbol{\alpha}_{2}^{T} \\
\vdots \\
\boldsymbol{\alpha}_{n}^{T}
\end{array}\right) \boldsymbol{B}=\left(\begin{array}{c}
\boldsymbol{\alpha}_{1}^{T} \boldsymbol{B} \\
\boldsymbol{\alpha}_{2}^{T} \boldsymbol{B} \\
\vdots \\
\boldsymbol{\alpha}_{n}^{T} \boldsymbol{B}
\end{array}\right)</script><p>也即是，矩阵$\boldsymbol B$右乘矩阵$\boldsymbol A$相当于对$\boldsymbol A$的列作线性组合，$\boldsymbol B$的各列的分量即为线性组合的系数；矩阵$\boldsymbol A$左乘矩阵$\boldsymbol B$相当于对$\boldsymbol B$的行作线性组合，$\boldsymbol A$的各行的分量即为线性组合的系数。这种理解方式也有助于我们更快地进行矩阵乘法的计算。</p>
<h3 id="2-矩阵消元"><a href="#2-矩阵消元" class="headerlink" title="2 矩阵消元"></a>2 矩阵消元</h3><p>对于线性方程组：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{r}
x+2 y+z=2 \\
3 x+8 y+z=12 \\
4 y+z=2
\end{array}\right.</script><p>首先通过消元来简化方程组，再通过回代求得方程组的解。考虑方程组系数矩阵$\boldsymbol A$及其右端向量$\boldsymbol b$：</p>
<script type="math/tex; mode=display">
\boldsymbol A=\left(\begin{array}{lll}
1 & 2 & 1 \\
3 & 8 & 1 \\
0 & 4 & 1
\end{array}\right), \boldsymbol b=\left(\begin{array}{c}
2 \\
12 \\
2
\end{array}\right)</script><p>我们称：</p>
<script type="math/tex; mode=display">
(\boldsymbol A,\boldsymbol b)=\left(\begin{array}{lll}
1 & 2 & 1 & 2\\
3 & 8 & 1 & 12\\
0 & 4 & 1 & 2
\end{array}\right)</script><p>为增广矩阵(augmented matrix)。下面对增广矩阵$(\boldsymbol A,\boldsymbol b)$进行消元：</p>
<p><img src="https://pic.imgdb.cn/item/62ab15940947543129489e3a.jpg"></p>
<p>其中，方框中框起来的元素1,2,5称为主元(pivot)，注意主元不能为0。下面通过回代求得线性方程组的解。</p>
<p>首先由增广矩阵的第3行可知$z = -2$，将$z = -2$代入第2行得$y = 1$，再将$z = -2, y = 1$代入第1行得$x = 2$。因此方程组的解为$x = 2, y = 1, z = 2$。</p>
<p>我们将$\boldsymbol A$通过消元后得到的上三角矩阵(upper triangular)记为$\boldsymbol U$，即：</p>
<script type="math/tex; mode=display">
\boldsymbol U=\left(\begin{array}{ccc}
1 & 2 & 1 \\
0 & 2 & -2 \\
0 & 0 & 5
\end{array}\right)</script><p>下面从矩阵乘法角度来说明$\boldsymbol A$是如何变成$\boldsymbol U$的。先将$\boldsymbol A$的第1行的−3倍加到第2行得到了$\boldsymbol A_1=\left(\begin{array}{ccc} 1 &amp; 2 &amp; 1 \\ 0 &amp; 2 &amp; -2 \\ 0 &amp; 4 &amp; 1 \end{array}\right)$，回忆一下矩阵乘法，一个矩阵左乘矩阵$\boldsymbol A$相当于对$\boldsymbol A$的行作线性组合，因此我们要找到一个合适的矩阵$\boldsymbol X$使得$\boldsymbol{XA = A_1}$，由$\boldsymbol A$和$\boldsymbol A_1$的第1行和第3行相同可知，矩阵$\boldsymbol X$的第1行和第3行分别为$(1,0,0),(0,0,1)$。 又由将$\boldsymbol A$的第1行的-3倍加到第2行得到$\boldsymbol A_1$可知，$\boldsymbol X$的第2行为$(−3,1,0)$，即：</p>
<script type="math/tex; mode=display">
\boldsymbol X=\left(\begin{array}{ccc}
1 & 0 & 0 \\
-3 & 1 & 0 \\
0 & 0 & 1
\end{array}\right)</script><p>我们将这个矩阵称为$\boldsymbol E_{21}$，因为它把$\boldsymbol A$的$(2,1)$位置的元素消成了0。这个矩阵称为<strong>初等矩阵</strong>或消元矩阵(elementary matrix or elimination matrix)。同理可知，第二次变换的矩阵为：</p>
<script type="math/tex; mode=display">
\boldsymbol E_{32}=\left(\begin{array}{ccc}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & -2 & 1
\end{array}\right)</script><p>$\boldsymbol E_{32}$同样是初等矩阵。因此我们即得：</p>
<script type="math/tex; mode=display">
\boldsymbol E_{32} \boldsymbol E_{21} \boldsymbol A = \boldsymbol U</script><p>这就是矩阵消元的乘法表示。</p>
<h3 id="3-矩阵乘法与逆"><a href="#3-矩阵乘法与逆" class="headerlink" title="3 矩阵乘法与逆"></a>3 矩阵乘法与逆</h3><h4 id="3-1-矩阵乘法的五种理解方式"><a href="#3-1-矩阵乘法的五种理解方式" class="headerlink" title="3.1 矩阵乘法的五种理解方式"></a>3.1 矩阵乘法的五种理解方式</h4><h5 id="3-1-1-定义的角度"><a href="#3-1-1-定义的角度" class="headerlink" title="3.1.1 定义的角度"></a>3.1.1 定义的角度</h5><p>设$\boldsymbol{C = AB}$，则矩阵$\boldsymbol A$的$(i,j)$处的元素为$\boldsymbol A$的第$i$行与$\boldsymbol B$的第$j$列的各元素相乘之和，即：</p>
<script type="math/tex; mode=display">
c_{i j}=a_{i 1} b_{1 j}+a_{i 2} b_{2 j}+\cdots+a_{i n} b_{n j}=\sum_{k=1}^{n} a_{i k} b_{k j}</script><p>也即是$\boldsymbol A$的第$i$行与$\boldsymbol B$的第$j$列点乘所得到的结果。</p>
<h5 id="3-1-2-列的角度"><a href="#3-1-2-列的角度" class="headerlink" title="3.1.2 列的角度"></a>3.1.2 列的角度</h5><p>设矩阵$\boldsymbol B$为：</p>
<script type="math/tex; mode=display">
\boldsymbol B = (\boldsymbol \beta_1, \boldsymbol \beta_2, \cdots, \boldsymbol \beta_n)</script><p>则：</p>
<script type="math/tex; mode=display">
\boldsymbol{AB} = \boldsymbol A (\boldsymbol \beta_1, \boldsymbol \beta_2, \cdots, \boldsymbol \beta_n) = (\boldsymbol A \boldsymbol \beta_1, \boldsymbol A \boldsymbol \beta_2, \cdots, \boldsymbol A \boldsymbol \beta_n)</script><p>因此，从列的角度来看，矩阵$\boldsymbol B$右乘矩阵$\boldsymbol A$所得到的矩阵的每一列都是$\boldsymbol A$的列的线性组合，线性组合的系数分别是$\boldsymbol B$的各列的分量。</p>
<h5 id="3-1-3-行的角度"><a href="#3-1-3-行的角度" class="headerlink" title="3.1.3 行的角度"></a>3.1.3 行的角度</h5><p>设矩阵$\boldsymbol A$为：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}=\left(\begin{array}{c}
\boldsymbol{a}_{1}^{\mathrm{T}} \\
\boldsymbol{\alpha}_{2}^{\mathrm{T}} \\
\vdots \\
\boldsymbol{\alpha}_{n}^{\mathrm{T}}
\end{array}\right)</script><p>则有：</p>
<script type="math/tex; mode=display">
\boldsymbol{AB}=\left(\begin{array}{c}
\boldsymbol{a}_{1}^{\mathrm{T}} \boldsymbol B\\
\boldsymbol{\alpha}_{2}^{\mathrm{T}} \boldsymbol B\\
\vdots \\
\boldsymbol{\alpha}_{n}^{\mathrm{T}} \boldsymbol B
\end{array}\right)</script><p>因此，从行的角度来看，矩阵$\boldsymbol A$左乘矩阵$\boldsymbol B$所得到的矩阵的每一行都是$\boldsymbol B$的行的线性组合，线性组合的系数分别是$\boldsymbol A$的各行的分量。</p>
<h5 id="3-1-4-从列乘以行的角度"><a href="#3-1-4-从列乘以行的角度" class="headerlink" title="3.1.4 从列乘以行的角度"></a>3.1.4 从列乘以行的角度</h5><p>设矩阵$\boldsymbol A$、$\boldsymbol B$分别为：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}=\left(\boldsymbol{\alpha}_{1}, \boldsymbol{\alpha}_{2} \cdots, \boldsymbol{\alpha}_{n}\right), \boldsymbol{B}=\left(\begin{array}{c}
\boldsymbol{\beta}_{1}^{\mathrm{T}} \\
\boldsymbol{\beta}_{2}^{\mathrm{T}} \\
\vdots \\
\boldsymbol{\beta}_{n}^{\mathrm{T}}
\end{array}\right)</script><p>则有：</p>
<script type="math/tex; mode=display">
\boldsymbol{A B}=\boldsymbol{\alpha}_{1} \boldsymbol{\beta}_{1}^{\mathrm{T}}+\boldsymbol{\alpha}_{2} \boldsymbol{\beta}_{2}^{\mathrm{T}}+\cdots+\boldsymbol{\alpha}_{n} \boldsymbol{\beta}_{n}^{\mathrm{T}}=\sum_{k=1}^{n} \boldsymbol{\alpha}_{k} \boldsymbol{\beta}_{k}^{\mathrm{T}}</script><p>由于列向量乘以行向量得到的是一个矩阵，因此从列乘以行的角度来看，矩阵$\boldsymbol A$乘以$\boldsymbol B$得到的是$n$个矩阵之和，其中第$i$个矩阵由$\boldsymbol A$的第$i$列乘以$\boldsymbol B$的第$j$行得到。</p>
<h5 id="3-1-5-分块乘法-block-multiplication"><a href="#3-1-5-分块乘法-block-multiplication" class="headerlink" title="3.1.5 分块乘法(block multiplication)"></a>3.1.5 分块乘法(block multiplication)</h5><p>矩阵乘法同样可以分块来乘，只要分块的大小能够使乘法有意义即可(分块的大小要相互匹配)如</p>
<script type="math/tex; mode=display">
\boldsymbol{A B}=\left(\begin{array}{ll}
\boldsymbol{A}_{1} & \boldsymbol{A}_{2} \\
\boldsymbol{A}_{3} & \boldsymbol{A}_{4}
\end{array}\right)\left(\begin{array}{ll}
\boldsymbol{B}_{1} & \boldsymbol{B}_{2} \\
\boldsymbol{B}_{3} & \boldsymbol{B}_{4}
\end{array}\right)=\left(\begin{array}{ll}
\boldsymbol{A}_{1} \boldsymbol{B}_{1}+\boldsymbol{A}_{2} \boldsymbol{B}_{3} & \boldsymbol{A}_{1} \boldsymbol{B}_{2}+\boldsymbol{A}_{2} \boldsymbol{B}_{4} \\
\boldsymbol{A}_{3} \boldsymbol{B}_{1}+\boldsymbol{A}_{4} \boldsymbol{B}_{3} & \boldsymbol{A}_{3} \boldsymbol{B}_{2}+\boldsymbol{A}_{4} \boldsymbol{B}_{4}
\end{array}\right)</script><h4 id="3-2-矩阵的逆"><a href="#3-2-矩阵的逆" class="headerlink" title="3.2 矩阵的逆"></a>3.2 矩阵的逆</h4><h5 id="3-2-1-矩阵逆的定义"><a href="#3-2-1-矩阵逆的定义" class="headerlink" title="3.2.1 矩阵逆的定义"></a>3.2.1 矩阵逆的定义</h5><p>如果存在矩阵$\boldsymbol B$使得$\boldsymbol{A B} = \boldsymbol{B A} = \boldsymbol I$，则矩阵$\boldsymbol B$称为矩阵$\boldsymbol A$的逆矩阵(inverse matrix)，记为$\boldsymbol A^{-1}$。一个矩阵可逆那么它是<strong>非奇异矩阵</strong>。<br>如果存在矩阵$\boldsymbol B$使得$\boldsymbol{AB = I}$，我们称$\boldsymbol B$是$\boldsymbol A$的右逆(right inverse)，事实上，可以证明$\boldsymbol B$还是$\boldsymbol A$的左逆(left inverse)，即$\boldsymbol{BA = I}$，因此，直接称满足$\boldsymbol{A B} = \boldsymbol{B A} = \boldsymbol I$的矩阵$\boldsymbol B$为$\boldsymbol A$的逆矩阵(inverse matrix)，即为$\boldsymbol A^{-1}$。</p>
<h5 id="3-2-2-判断矩阵是否存在逆"><a href="#3-2-2-判断矩阵是否存在逆" class="headerlink" title="3.2.2 判断矩阵是否存在逆"></a>3.2.2 判断矩阵是否存在逆</h5><p>以矩阵$\boldsymbol A$为例：</p>
<script type="math/tex; mode=display">
\boldsymbol A=\left(\begin{array}{cc}
1 & 3 \\
2 & 6 
\end{array}\right)</script><p>为例，如果从行列式的角度来看，由于$\boldsymbol A$的行列式为零，显然$\boldsymbol A$不可逆。但是，有没有其他方式来说明$\boldsymbol A$不可逆呢？<br>注意到$\boldsymbol A$的两列是线性相关的(都是$\left[\begin{array}{c}1 \\ 2\end{array}\right]$的倍数)，假设存在矩阵$\boldsymbol B$使得$\boldsymbol{AB = I}$，再来回忆下矩阵的乘法可知，$\boldsymbol{AB}$的每一列都是$\boldsymbol A$的列的线性组合，因此$\boldsymbol{AB}$的每一列也都是$\left[\begin{array}{c}1 \\ 2\end{array}\right]$的倍数，显然是不可能等于单位矩阵$\boldsymbol I$的，因此$\boldsymbol A$不可逆。</p>
<ul>
<li>或者我们可以再换一种方式来说明：<br>如果存在向量$\boldsymbol x \neq \boldsymbol 0$使得$\boldsymbol{Ax = 0}$，那么$\boldsymbol A$不可逆。<br>这个结论的证明是显然的，假设$\boldsymbol A$可逆，那么$\boldsymbol{Ax = 0}$两边同时乘以$\boldsymbol A^{-1}$，则得到$\boldsymbol{x = 0}$，矛盾，因此$\boldsymbol A$不可逆。<br>显然，可取$\boldsymbol x=\left[\begin{array}{c}-3 \\ 1\end{array}\right]$，则$\boldsymbol{Ax = 0}$，因此，A 不可逆。</li>
</ul>
<h5 id="3-2-3-求矩阵的逆"><a href="#3-2-3-求矩阵的逆" class="headerlink" title="3.2.3 求矩阵的逆"></a>3.2.3 求矩阵的逆</h5><p>利用<strong><font color="red">Gauss-Jordan</font></strong> 消元法，对矩阵$(\boldsymbol{A, I})$通过行变换消元，当$(\boldsymbol{A, I})$中的$\boldsymbol A$变为$\boldsymbol I$时，$(\boldsymbol{A, I})$中的矩阵$\boldsymbol I$就变成了$\boldsymbol A^{-1}$，即：</p>
<script type="math/tex; mode=display">
(\boldsymbol{A, I}) \frac{\text { 行变换消元, 相当于在左边乘以矩阵 } \boldsymbol{X}}{\text { 当 } \boldsymbol{X A=I} \text { 时, } \boldsymbol X \text { 即为 } \boldsymbol A^{-1}, \boldsymbol I \text { 就变为 } \boldsymbol A^{-1}}\left(\boldsymbol I, \boldsymbol A^{-1}\right)</script><p>这种方法的原理可以从矩阵线性变换来考虑，初等行变换就是线性变换，其实就是对矩阵$\boldsymbol A$、$\boldsymbol I$同时进行相同的线性变换，当$\boldsymbol A$变成了$\boldsymbol I$，此时$\boldsymbol I$就变成了$\boldsymbol A^{-1}$。<br>发现矩阵的逆与线性相关/无关、矩阵的秩、矩阵行列式有很多相互关联关系。</p>
<h3 id="4-矩阵的LU分解"><a href="#4-矩阵的LU分解" class="headerlink" title="4 矩阵的LU分解"></a>4 矩阵的LU分解</h3><p>从另一种角度来看待Gauss消元(本质上，LU分解是高斯消元的一种表达方式)。</p>
<p>首先考虑没有行交换的情形（也就是主元位置的元素不为0）。对矩阵$\boldsymbol A$进行Gauss消元相当于用一系列初等矩阵左乘$\boldsymbol A$从而得到上三角矩阵$\boldsymbol U$。</p>
<p>以$3 \times 3$矩阵为例。设$\boldsymbol A$是一个$3 \times 3$矩阵，$\boldsymbol E_{21}$、$\boldsymbol E_{31}$、$\boldsymbol E_{32}$是初等矩阵(将$\boldsymbol E_{ij}$位置的元素消为0），$\boldsymbol U$是消元后所得到的上三角矩阵，即：</p>
<script type="math/tex; mode=display">
\boldsymbol E_{32}\boldsymbol E_{31}\boldsymbol E_{21} \boldsymbol A= \boldsymbol U</script><p>因此：</p>
<script type="math/tex; mode=display">
\boldsymbol A = \boldsymbol E_{21}^{-1}\boldsymbol E_{31}^{-1}\boldsymbol E_{32}^{-1} \boldsymbol U</script><p>记：</p>
<script type="math/tex; mode=display">
\boldsymbol{E}=\boldsymbol{E}_{32} \boldsymbol{E}_{31} \boldsymbol{E}_{21}, \boldsymbol{L}=\boldsymbol{E}_{21}^{-1} \boldsymbol{E}_{31}^{-1} \boldsymbol{E}_{32}^{-1}</script><p>则以上两式即为：</p>
<script type="math/tex; mode=display">
\boldsymbol{EA = U}, \boldsymbol{A = LU}</script><p>而当我们写成$\boldsymbol{A = LU}$的形式时，显然$\boldsymbol L$是对角元素全为1的<strong>下三角矩阵</strong>(一般认为，下三角矩阵的左乘代表了对矩阵进行行变换)，且$\boldsymbol L$下三角部分各位置的元素可通过消元过程快速确定。<br>因此，我们只需记录消元所用的乘数，就能快速地确定矩阵$\boldsymbol L$(注意我们这里所讨论的是没有行交换的情形)，不需要进行任何计算，这就是我们使用形式$\boldsymbol{A = LU}$的好处。<br>数学家们喜欢0，喜欢1，喜欢对称，$\boldsymbol{A = LU}$显然不那么对称，$\boldsymbol{U}$对角线上是主元，$\boldsymbol{L}$对角线上是1，这太不美观了实际上，我们还可以进一步分解：</p>
<script type="math/tex; mode=display">
\boldsymbol U = \boldsymbol{DW} = \left[\begin{array}{cccc}
d_{1} & & & \\
& d_{2} & & \\
& & \ddots & \\
& & & d_{n}
\end{array}\right]\left[\begin{array}{cccc}
1 & u_{12} / d_{1} & u_{13} / d_{1} & \cdot \\
& 1 & u_{23} / d_{2} & \cdot \\
& & \ddots & \vdots \\
& & & 1
\end{array}\right]</script><p>因此，有：</p>
<script type="math/tex; mode=display">
\boldsymbol{A = LDW}</script><p>此处$\boldsymbol{DW = U}$，$\boldsymbol D$是一个只有主对角线元素的矩阵，$\boldsymbol W$是对角元素全为1的上三角矩阵。</p>
<blockquote>
<p>你一定跟我当时一样心中一万匹羊驼在奔腾，觉得折腾这玩意有啥用啊，折腾过来折腾过去，没啥用啊，这么弄的目的是啥嘛，但是当天晚上回家看数值分析的书，刚好也讲这个过程，原来这么做的目的是为了减轻计算，举个例子$\boldsymbol{Ax = b}$这种计算过程在工程应用里非常常见，而且多半时间是$\boldsymbol A$不变，不同的$\boldsymbol b$来解不同的$\boldsymbol x$，那么按照高斯消元法，每次要从头消元，因为$\boldsymbol b$改变了增广矩阵，但是很多计算是冗余的，所以使用三角矩阵的好处就是可以大大减少冗余计算。<br>第一步：就是把矩阵分解成 LU 或者 LDU 形式（factor）<br>第二步：通过回代，把x求出来（solve）<br><img src="https://pic.imgdb.cn/item/62ab37de0947543129a17814.jpg" style="zoom:80%"><br>过程(1)(2)并不需要求逆，而是通过回代的过程进行，根据计算时间复杂度（也就是计算量，计算次数），factor的时间复杂度是$O(\dfrac{1}{3}n^3)$，solve的时间复杂度大概是$O(n^2)$，如果你对时间复杂度不了解，可以去看《算法导论》的最开始那一章，这个理论还是非常有用的，尤其是对研究算法的童鞋。通过回代而不是消元，能够降低不少多余的计算。</p>
</blockquote>
<h3 id="5-转置、置换、空间-mathbb-R-n"><a href="#5-转置、置换、空间-mathbb-R-n" class="headerlink" title="5 转置、置换、空间$\mathbb{R}^n$"></a>5 转置、置换、空间$\mathbb{R}^n$</h3><h4 id="5-1-置换矩阵-permutation-matrix"><a href="#5-1-置换矩阵-permutation-matrix" class="headerlink" title="5.1 置换矩阵(permutation matrix)"></a>5.1 置换矩阵(permutation matrix)</h4><p>置换矩阵可以用来行行交换。由上一节我们知道，一个矩阵若恰好不需要行变换就能完成$\boldsymbol{A = LU}$分解是十分简单，但是当被分解的矩阵的行主元有零时，则需要行变换才能完成分解，所以此时就变成了：</p>
<script type="math/tex; mode=display">
\boldsymbol{PA = LU}</script><ul>
<li>置换矩阵的每一行和每一列都恰好有一个1，其余的元素都是0；</li>
<li>置换矩阵可由单位矩阵经过行或列交换得到；</li>
<li>一个矩阵乘以置换矩阵，相当于对矩阵的行或列进行交换；</li>
<li>置换矩阵的性质：$\boldsymbol P^{-1} =\boldsymbol P^{\mathrm T}$，即置换矩阵都是<strong>正交矩阵</strong>。</li>
<li>由于置换矩阵的每一行都可以看作取自单位矩阵的某一行，因此$n \times n$维置换矩阵共有$n!$个。</li>
</ul>
<h4 id="5-2-转置"><a href="#5-2-转置" class="headerlink" title="5.2 转置"></a>5.2 转置</h4><p>矩阵$\boldsymbol A$的转置记为$\boldsymbol A^{\mathrm T}$，满足：</p>
<script type="math/tex; mode=display">
\boldsymbol A_{ij}^{\mathrm T} = \boldsymbol A_{ji}</script><p>若矩阵$\boldsymbol A$满足$\boldsymbol A = \boldsymbol A^{\mathrm T}$，则称$\boldsymbol A$为对称矩阵。对于任何一个矩阵$\boldsymbol A$，不管$\boldsymbol A$是长方形矩阵还是方阵，$\boldsymbol {AA}^{\mathrm T}$、$\boldsymbol A^{\mathrm T}\boldsymbol A$一定是对称矩阵，因为：</p>
<script type="math/tex; mode=display">
 \left(\boldsymbol{A} \boldsymbol{A}^{\mathrm{T}}\right)^{\mathrm{T}}=\left(\boldsymbol{A}^{\mathrm{T}}\right)^{\mathrm{T}} \boldsymbol{A}^{\mathrm{T}}=\boldsymbol{A} \boldsymbol{A}^{\mathrm{T}},\left(\boldsymbol{A}^{\mathrm{T}} \boldsymbol{A}\right)^{\mathrm{T}}=\boldsymbol{A}^{\mathrm{T}} \boldsymbol{A}</script><p>这也是构造对称矩阵的一种方法。</p>
<h4 id="5-3-向量空间"><a href="#5-3-向量空间" class="headerlink" title="5.3 向量空间"></a>5.3 向量空间</h4><p>向量空间必须对线性组合封闭，主要是“<strong>加法封闭和数乘封闭</strong>”。</p>
<ul>
<li>矩阵的列空间<br>矩阵$\boldsymbol{A}$的列的所有线性组合构成一个线性空间，称为$\boldsymbol{A}$的列空间。</li>
</ul>
<h3 id="6-列空间和零空间"><a href="#6-列空间和零空间" class="headerlink" title="6 列空间和零空间"></a>6 列空间和零空间</h3><h4 id="6-1-子空间-Subspace"><a href="#6-1-子空间-Subspace" class="headerlink" title="6.1 子空间(Subspace)"></a>6.1 子空间(Subspace)</h4><p>设非空集合$\boldsymbol S ⊂ \mathbb{R}^n$，且$\boldsymbol S$中的元素对加法和数乘封闭(即对任意的$\boldsymbol u, \boldsymbol v \in \boldsymbol S$，$\boldsymbol{u+v} \in \boldsymbol S$，$\lambda \boldsymbol u \in \boldsymbol S$，$\lambda$是常数），子空间中必须包含“0向量”，则$\boldsymbol S$是$\mathbb{R}^n$的子空间。</p>
<p>设$\boldsymbol V, \boldsymbol W$是$\mathbb{R}^n$的子空间，则$\boldsymbol V \cap \boldsymbol W$也是$\mathbb{R}^n$的子空间(显然对加法和数乘封闭)，但$\boldsymbol V \cup \boldsymbol W$未必是$\mathbb{R}^n$的子空间，因为$\boldsymbol V \cup \boldsymbol W$中的元素未必对加法和数乘封闭。</p>
<p>“子空间”为包含于向量空间内的一个向量空间。它是原向量空间的一个子集，而且本身也满足向量空间的要求。但是“子空间”和“子集”的概念有区别，所有元素都在原空间之内就可称之为子集，但是要满足对线性运算封闭的子集才能成为子空间。</p>
<h4 id="6-2-列空间-Column-space"><a href="#6-2-列空间-Column-space" class="headerlink" title="6.2 列空间(Column space)"></a>6.2 列空间(Column space)</h4><p>矩阵$\boldsymbol{A}$的所有列向量的线性组合构成一个线性空间，称为$\boldsymbol{A}$的列空间，记为$C(\boldsymbol{A})$。</p>
<p>由此可知，线性方程组$\boldsymbol{Ax = b}$有解当且仅当$\boldsymbol{b}$在$\boldsymbol{A}$的列空间中，也即是当且仅当$\boldsymbol{b}$是$\boldsymbol{A}$的列向量的线性组合。</p>
<p>显然，<strong>列空间是线性空间</strong>。(存疑？？？)</p>
<h4 id="6-3-零空间-Nullspace"><a href="#6-3-零空间-Nullspace" class="headerlink" title="6.3 零空间(Nullspace)"></a>6.3 零空间(Nullspace)</h4><p>方程组$\boldsymbol{Ax = 0}$的所有解$\boldsymbol x$的集合称为$\boldsymbol A$的零空间，记为$N(\boldsymbol{A})$。</p>
<p>零空间也是线性空间，因为若$\boldsymbol{u,v} \in N(\boldsymbol A)$，则$\boldsymbol {A(u+v)=Au+Av=0}$，故$\boldsymbol{u+v} \in N(\boldsymbol A)$，同理可知对数乘也封闭。</p>
<p>方程组$\boldsymbol{Ax = b}$的<strong>解</strong>构成的集合不是线性空间，因为其不含零向量(也可很容易地验证对加法和数乘不封闭)。</p>
<h3 id="7-求解-boldsymbol-Ax-0-：主变量、特解"><a href="#7-求解-boldsymbol-Ax-0-：主变量、特解" class="headerlink" title="7 求解$\boldsymbol{Ax = 0}$：主变量、特解"></a>7 求解$\boldsymbol{Ax = 0}$：主变量、特解</h3><p>以：</p>
<script type="math/tex; mode=display">
\boldsymbol A=\left(\begin{array}{cccc}
1 & 2 & 2 & 2 \\
2 & 4 & 6 & 8 \\
3 & 6 & 8 & 10
\end{array}\right)</script><p>为例，对$\boldsymbol A$进行消元(行变换，消元不改变$\boldsymbol A$的行空间和零空间，改变$\boldsymbol A$的列空间)得：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{cccc}
1 & 2 & 2 & 2 \\
0 & 0 & 2 & 4 \\
0 & 0 & 0 & 0
\end{array}\right) \triangleq \boldsymbol{U}</script><p>其中，1、2为主元(每个非零行的第一个非零元素就是主元)，1、2所在的列第1列、第3列称为<strong>主元列</strong>，第2列、第4列称为<strong>自由列</strong>。主元的个数即为$\boldsymbol A$的秩，即$\text{rank}(\boldsymbol A) = 2$。</p>
<blockquote>
<p>主元列和自由列的一个重要区别就是，自由列可以表示为其左侧所有主元列的线性组合，而主元列则不可以。具体参考：<a href="https://zhuanlan.zhihu.com/p/45815011">https://zhuanlan.zhihu.com/p/45815011</a></p>
</blockquote>
<p>设$\boldsymbol x=\left[\begin{array}{c}x_1 \\ x_2 \\ x_3 \\ x_4\end{array}\right]$，则$x_1, x_3$为主变量，$x_2, x_4$为自由变量。自由变量的个数为未知数的个数减去主元的个数(即减去$\boldsymbol A$的秩)，即若$\boldsymbol A$是$m \times n$维矩阵，则自由变量的个数为$n - \text{rank}(\boldsymbol A)$。</p>
<p>由于消元不改变方程组的解，因此求解$\boldsymbol{Ax = 0}$就等价于求解$\boldsymbol{Ux = 0}$。分别取自由变量$(x_2, x_4) = (1, 0)$、$(x_2, x_4) = (0, 1)$， 可得$\boldsymbol{Ux = 0}$的两个特解：</p>
<script type="math/tex; mode=display">
\boldsymbol{\xi}=\left(\begin{array}{c}
-2 \\
1 \\
0 \\
0
\end{array}\right), \boldsymbol{\eta}=\left(\begin{array}{c}
2 \\
0 \\
-2 \\
1
\end{array}\right)</script><p>因此，零空间中的元素为：$\boldsymbol{x} = a\boldsymbol{\xi} + b\boldsymbol{\eta}$，其中，$a, b$为任意常数。</p>
<p>进一步简化行阶梯形式，在简化行阶梯形式中，主元上下的元素都为0，且主元都为1。下面我们进一步将矩阵$\boldsymbol U$化为简化行阶梯形式$\boldsymbol R$：</p>
<script type="math/tex; mode=display">
\boldsymbol R = \left(\begin{array}{cccc}
1 & 2 & 0 & -2 \\
0 & 0 & 1 & 2 \\
0 & 0 & 0 & 0
\end{array}\right)</script><p>这样，求解$\boldsymbol{Ax = 0}$就等价于$\boldsymbol{Ux = 0}$再等价于$\boldsymbol{Rx = 0}$，从而能够更快地写出方程组的解。</p>
<blockquote>
<p>这一讲有点难以理解，可以多看几遍课程+参考笔记：<a href="https://zhuanlan.zhihu.com/p/45815011">MIT—线性代数笔记07 求解Ax=0：主变量，特解 - 三少爷的键的文章 - 知乎</a></p>
</blockquote>
<h3 id="8-boldsymbol-Ax-b-：可解性及解的结构"><a href="#8-boldsymbol-Ax-b-：可解性及解的结构" class="headerlink" title="8 $\boldsymbol{Ax = b}$：可解性及解的结构"></a>8 $\boldsymbol{Ax = b}$：可解性及解的结构</h3><h4 id="8-1-可解的条件-Solvability-conditions-on-b"><a href="#8-1-可解的条件-Solvability-conditions-on-b" class="headerlink" title="8.1 可解的条件 Solvability conditions on b"></a>8.1 可解的条件 Solvability conditions on b</h4><p>仍取：</p>
<script type="math/tex; mode=display">
\boldsymbol A=\left(\begin{array}{cccc}
1 & 2 & 2 & 2 \\
2 & 4 & 6 & 8 \\
3 & 6 & 8 & 10
\end{array}\right)</script><p>则方程为：</p>
<script type="math/tex; mode=display">
\boldsymbol{A x}=\left(\begin{array}{cccc}
1 & 2 & 2 & 2 \\
2 & 4 & 6 & 8 \\
3 & 6 & 8 & 10
\end{array}\right)\left(\begin{array}{l}
x_{1} \\
x_{2} \\
x_{3} \\
x_{4}
\end{array}\right)=\left(\begin{array}{l}
b_{1} \\
b_{2} \\
b_{3}
\end{array}\right)</script><p>矩阵$\boldsymbol A$的第3行为第1行和第2行的加和，因此$\boldsymbol{Ax = b}$中$\boldsymbol b$的第3个分量也要等于其第1和第2个分量的和。若$\boldsymbol b$不满足$b_3 = b_1+b_2$则方程组无解，下面取$\boldsymbol b = \left(\begin{array}{l} 1 \\ 5 \\ 6 \end{array}\right)$。</p>
<p>检验$\boldsymbol{Ax = b}$是否可解的方法是对增广矩阵进行行消元。如果矩阵$\boldsymbol{A}$的行被完全消去的话，则对应的$\boldsymbol b$的分量也要得0。在本例中，矩阵$\boldsymbol{A}$的第3行被消去。</p>
<p>可解的条件：如果$\boldsymbol{Ax = b}$有解的话，则$\boldsymbol b$应该处于矩阵$\boldsymbol A$的列空间$C(\boldsymbol A)$ 里面。等价的另一种描述方式为：矩阵$\boldsymbol A$的行向量若经过线性组合为零向量时，则对应的$\boldsymbol b$经同样的线性组合后也为0(注意是单个0)。</p>
<h4 id="8-2-特解A-particular-solution"><a href="#8-2-特解A-particular-solution" class="headerlink" title="8.2 特解A particular solution"></a>8.2 特解A particular solution</h4><p>求$\boldsymbol{Ax = b}$特解的方法是将自由变量均赋为0，求解其主变量。本例中，令$x_2 = 0, x_4 = 0$得到方程组：</p>
<script type="math/tex; mode=display">
\begin{array}{r}
x_{1}+2 x_{3}=1 \\
2 x_{2}=3
\end{array}</script><p>可解得$x_1 = -2, x_3 = \dfrac{3}{2}$，即特解为：$\boldsymbol x_p=\left[\begin{array}{c}-2 \\ 0 \\ \dfrac{3}{2} \\ 0 \end{array}\right]$。</p>
<h4 id="8-3-通解Complete-solution"><a href="#8-3-通解Complete-solution" class="headerlink" title="8.3 通解Complete solution"></a>8.3 通解Complete solution</h4><p>为求得$\boldsymbol{Ax = b}$的所有解，我们首先检验方程是否可解，然后找到一个特解。将特解和矩阵零空间的向量相加即为方程的通解。</p>
<ul>
<li>与零空间进行线性组合 Combined with nullspace：</li>
</ul>
<script type="math/tex; mode=display">\boldsymbol{A x_p = b}</script><script type="math/tex; mode=display">\boldsymbol{A x_n = 0}</script><script type="math/tex; mode=display">\boldsymbol{A (x_p + x_n) = b}</script><p>即通解为：$\boldsymbol x_{\text{complete}} = \boldsymbol x_p + \boldsymbol x_n$。</p>
<p>将$\boldsymbol A$转换成rref(行最简)，则结果如下所示：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}=\left(\begin{array}{cccc}
x_{1} & x_{2} & x_{3} & x_{4} \\
- & - & - & - \\
1 & 2 & 0 & -2 \\
0 & 0 & 1 & 2 \\
0 & 0 & 0 & 0
\end{array}\right)</script><p>将$x_2, x_3$进行互换，把主元列、自由列分别放在一起，则为：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}=\left(\begin{array}{cccc}
x_{1} & x_{2} & x_{3} & x_{4} \\
- & - & - & - \\
1 & 0 & 2 & -2 \\
0 & 1 & 0 & 2 \\
0 & 0 & 0 & 0
\end{array}\right)
=\left(\begin{array}{cc}
\boldsymbol I & \boldsymbol F  \\
\boldsymbol 0 & \boldsymbol 0
\end{array}\right)</script><p>互换后的$\boldsymbol{Ax = 0} \stackrel{转变为}{\longrightarrow} \boldsymbol{Rx = 0}$解应该为</p>
<script type="math/tex; mode=display">
\left(\begin{array}{c}
-\boldsymbol{F} \\
\boldsymbol{I}
\end{array}\right)=\left(\begin{array}{cc}
-2 & 2 \\
0 & -2 \\
1 & 0 \\
0 & 1
\end{array}\right)</script><p>再将$x_2, x_3$互换回来，即可得到原方程的解：</p>
<script type="math/tex; mode=display">
\boldsymbol{x}=\left(\begin{array}{cc}
-2 & 2 \\
1 & 0 \\
0 & -2 \\
0 & 1
\end{array}\right)</script><p>这是零空间解的一种简便算法，即通过行变换得到(必要时需要交换列，当然最后还要交换回来)得到$\boldsymbol{I, F}$后可直接写出零解。</p>
<h4 id="8-4-秩Rank"><a href="#8-4-秩Rank" class="headerlink" title="8.4 秩Rank"></a>8.4 秩Rank</h4><p>假设矩阵的shape为$m \times n$，如果矩阵的秩为$r$，则必有$r \leq m, r \leq n$。</p>
<h5 id="8-4-1-列满秩-r-n-n-leq-m"><a href="#8-4-1-列满秩-r-n-n-leq-m" class="headerlink" title="8.4.1 列满秩$r = n(n \leq m)$"></a>8.4.1 列满秩$r = n(n \leq m)$</h5><p>零空间$N(\boldsymbol A)$内只有零向量。原因：每列都有主元，即也可以认为每列都是线性无关的，$\boldsymbol x$的每个分量都是主变量，没有自由变量。方程$\boldsymbol{Ax = b}$无解或者有唯一解$\boldsymbol x_p$。</p>
<h5 id="8-4-2-行满秩-r-m-m-leq-n"><a href="#8-4-2-行满秩-r-m-m-leq-n" class="headerlink" title="8.4.2 行满秩$r = m(m \leq n)$"></a>8.4.2 行满秩$r = m(m \leq n)$</h5><p>每行都有主元，无论$\boldsymbol b$取何值，方程$\boldsymbol{Ax = b}$都有解(因为$\boldsymbol A$是行满秩，所以$\boldsymbol A$的列向量能够线性组合充满整个$\mathbb{R}^{m \times m}$空间，而$\boldsymbol b$一定在$\mathbb{R}^{m \times m}$空间中)。主变量$r = m$个，自由变量$n-r = n-m$个，即也一定存在零空间解。</p>
<h5 id="8-4-3-满秩-r-n-m"><a href="#8-4-3-满秩-r-n-m" class="headerlink" title="8.4.3 满秩$r = n = m$"></a>8.4.3 满秩$r = n = m$</h5><p>满秩，矩阵可逆。零空间只有零向量(因为矩阵$\boldsymbol A$的列都是线性无关的，不可能组合出零向量)，无论$\boldsymbol b$取何值，方程$\boldsymbol{Ax = b}$都有唯一解。$\boldsymbol{R = I}$。</p>
<h4 id="8-5-小结"><a href="#8-5-小结" class="headerlink" title="8.5 小结"></a>8.5 小结</h4><p><img src="https://pic.imgdb.cn/item/62ac497509475431293c9580.jpg"></p>
<p>简单来说，$\boldsymbol R$的倒数行是否为零行决定了是否有解。如果没有零行，则一定有解。秩决定了方程组解的数量。</p>
<h3 id="9-线性无关，基和维度"><a href="#9-线性无关，基和维度" class="headerlink" title="9. 线性无关，基和维度"></a>9. 线性无关，基和维度</h3><p>向量的线性无关意味着什么？如何用线性无关的概念来帮助我们描述包括零空间在内的子空间。</p>
<p>首先我们需要注意的是，线性无关是针对向量组而言的，而不是对矩阵而言的。重要概念：线性无关(线性相关)、张成空间、基、维度。</p>
<h4 id="9-1-复习"><a href="#9-1-复习" class="headerlink" title="9.1 复习"></a>9.1 复习</h4><p>假设矩阵$\boldsymbol R$的shape为$m \times n$，并且$m &lt; n$，其中$m$表示的是方程组的个数，而$n$表示的是未知数的个数。那么$\boldsymbol{Ax = 0}$一定包含非零解。其中解存在的原因在于一定存在自由变量，其中自由变量个数最少为$n - m$。</p>
<h4 id="9-2-线性无关-Independence"><a href="#9-2-线性无关-Independence" class="headerlink" title="9.2 线性无关 Independence"></a>9.2 线性无关 Independence</h4><p>若$c_1 \boldsymbol x_1 + c_2 \boldsymbol x_2 + \cdots + c_n \boldsymbol x_n = \boldsymbol 0$仅仅在$c_1 = c_2 = \cdots = c_n = 0$时成立，则称$\boldsymbol x_1, \boldsymbol x_2, \cdots, \boldsymbol x_n$是线性无关的。若这些向量作为列向量构成矩阵$\boldsymbol A$，则方程$\boldsymbol{A x = 0}$只有零解$\boldsymbol x = \boldsymbol 0$，或称矩阵$\boldsymbol A$的零空间只有零向量。换而言之，若存在非零向量$\boldsymbol c$，使得$\boldsymbol{Ac = 0}$，则这个矩阵的列向量线性相关。</p>
<ul>
<li><strong>思考：</strong>零向量和另外一个向量是线性相关还是线性无关呢？<br>答案是线性相关的。也就是说只要向量组中包含一个零向量，那么一定是线性相关的。</li>
</ul>
<p>在$\mathbb{R}^2$中，两个向量只要不共线就是线性无关的。（在$\mathbb{R}^3$中，三个向量线性无关的条件是它们不在一个平面上）若选定空间$\mathbb{R}^2$中的三个向量，则他们必然是线性相关的。例如，如下的三个向量线性相关的：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\begin{array}{lll}
\boldsymbol{v}_{1} & \boldsymbol{v}_{2} & \boldsymbol{v}_{3}
\end{array}\\
&\left(\begin{array}{ccc}
2 & 1 & 2.5 \\
1 & 2 & -1
\end{array}\right)
\end{aligned}</script><p>此矩阵构成的方程$\boldsymbol{Ax = 0}$必有非零解，即三个向量线性相关。</p>
<p>向量组线性无关等价于将该向量组构成的矩阵$\boldsymbol A$的零空间中只有零向量。如果是线性相关的话，存在非零向量$\boldsymbol c$使得$\boldsymbol{Ac=0}$。<br>如果矩阵$\boldsymbol A$的列向量为线性无关，则$\boldsymbol A$所有的列均为主元列，没有自由列，$\text{rank}(\boldsymbol A) = n$。若$\boldsymbol A$的列向量为线性相关，则$\text{rank}(\boldsymbol A) &lt; n$，并且存在自由列。其中自由列的本质是主列的一种组合。</p>
<p>总结：向量组的线性相关性可转换成计算矩阵的零空间。</p>
<h4 id="9-3-张成空间-Span-a-space"><a href="#9-3-张成空间-Span-a-space" class="headerlink" title="9.3 张成空间 Span a space"></a>9.3 张成空间 Span a space</h4><p>当一个空间是由向量$\boldsymbol v_1, \boldsymbol v_2, \cdots, \boldsymbol v_k$的所有线性组合组成时，我们称这些向量张成了这个空间。例如矩阵的列向量张成了该矩阵的列空间。<br>如果向量$\boldsymbol v_1, \boldsymbol v_2, \cdots, \boldsymbol v_k$张成空间$\boldsymbol S$，则$\boldsymbol S$是包含这些向量的最小空间。</p>
<h4 id="9-4-基-Basis"><a href="#9-4-基-Basis" class="headerlink" title="9.4 基 Basis"></a>9.4 基 Basis</h4><p>向量空间的基是具有如下两个性质的一组向量$\boldsymbol v_1, \boldsymbol v_2, \cdots, \boldsymbol v_d$：</p>
<ul>
<li>$\boldsymbol v_1, \boldsymbol v_2, \cdots, \boldsymbol v_d$线性无关；</li>
<li>$\boldsymbol v_1, \boldsymbol v_2, \cdots, \boldsymbol v_d$张成该向量空间；</li>
</ul>
<p>在$\mathbb{R}^3$空间中，其中一组基为：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{l}
1 \\
0 \\
0
\end{array}\right)\left(\begin{array}{l}
0 \\
1 \\
0
\end{array}\right)\left(\begin{array}{l}
0 \\
0 \\
1
\end{array}\right)</script><p>若以$\mathbb{R}^n$空间中的$n$个向量为列向量构成的矩阵为可逆矩阵，则这些向量可以构成$\mathbb{R}^n$空间中的一组基。</p>
<p><strong>(一) 子空间的基 Basis for a subspace</strong></p>
<p>向量$\left[\begin{array}{c}1 \\ 1 \\ 0 \end{array}\right]$、$\left[\begin{array}{c}0 \\ 1 \\ 1 \end{array}\right]$构成$\mathbb{R}^3$中的一个平面，但是它们无法成为$\mathbb{R}^3$空间的一组基。空间中的基并不是唯一的。</p>
<p><strong>(二) 维度 Dimension</strong></p>
<p>空间的每一组基都具有相同的向量数，这个数值就是空间的维度(dimension)。所以$\mathbb{R}^n$空间的每组基都包含$n$个向量。简单来说，向量空间的维度就是基向量的个数。对于一个向量空间而言，基向量可以是不同的，但是维度是相同的。</p>
<p><strong>(三) 列空间的基</strong></p>
<script type="math/tex; mode=display">
\boldsymbol{A}=\left(\begin{array}{cccc}
1 & 2 & 3 & 1 \\
1 & 1 & 2 & 1 \\
1 & 2 & 3 & 1 
\end{array}\right)</script><script type="math/tex; mode=display">
\text{rank} (\boldsymbol A) =  \text{pivot numbers} = \text{dimension } C(\boldsymbol A) = 2</script><p>注意：矩阵具有秩rank而不是维数dimension，而空间有维数而不是秩。当知道了列空间的维数，可以从矩阵列向量中随意选取足够数量的线性无关的向量，它们每一组都可以构成列空间的一组基。其中一组基是第一列与第二列</p>
<p><strong>(四) 零空间的基</strong></p>
<p>本例中矩阵的列向量不是线性无关的，因此其零空间$N(\boldsymbol A)$不止包含零向量。因为可以看出第3列是第1列和第2列的和。所以向量$\left[\begin{array}{c}-1 \\ -1 \\ 1 \\ 0 \end{array}\right]$必然在零空间$N(\boldsymbol A)$之内。由于第1列和第4列相等，从而得到$\left[\begin{array}{c}1 \\ 0 \\ 0 \\ -1 \end{array}\right]$也在零空间之内。它们就是的两个特解。</p>
<p><strong>零空间的维数=自由列的数目=$n - r$(列数减去秩)</strong>，因此本例中$N(\boldsymbol A)$的维数为$4-2=2$。这两个特解就构成了零空间的一组基。</p>
<h3 id="10-四个基本子空间"><a href="#10-四个基本子空间" class="headerlink" title="10 四个基本子空间"></a>10 四个基本子空间</h3><h4 id="10-1-四个子空间-Four-subspaces"><a href="#10-1-四个子空间-Four-subspaces" class="headerlink" title="10.1 四个子空间 Four subspaces"></a>10.1 四个子空间 Four subspaces</h4><p>任意的$m \times n$矩阵$\boldsymbol A$都定义了四个子空间。</p>
<h5 id="10-1-1-列空间Column-space"><a href="#10-1-1-列空间Column-space" class="headerlink" title="10.1.1 列空间Column space"></a>10.1.1 列空间Column space</h5><p>矩阵$\boldsymbol A$的列空间是$\boldsymbol A$的列向量的线性组合在空间中构成的子空间。如何表示列空间中的任意向量呢？很显然是$\boldsymbol{Ax = b}$。</p>
<h5 id="10-1-2-零空间-Nullspace"><a href="#10-1-2-零空间-Nullspace" class="headerlink" title="10.1.2 零空间 Nullspace"></a>10.1.2 零空间 Nullspace</h5><p>矩阵$\boldsymbol A$的零空间$\boldsymbol{Ax = 0}$是的所有解$\boldsymbol x$在$\mathbb{R}^n$空间中成的子空间。</p>
<h5 id="10-1-3-行空间-Row-space"><a href="#10-1-3-行空间-Row-space" class="headerlink" title="10.1.3 行空间 Row space"></a>10.1.3 行空间 Row space</h5><p>矩阵$\boldsymbol A$的行空间是$\boldsymbol A$的行向量的线性组合在$\mathbb{R}^n$空间中构成的子空间，也就是矩阵$\boldsymbol A^{\mathrm T}$的列空间。</p>
<h5 id="10-1-4-左零空间-Left-nullspace"><a href="#10-1-4-左零空间-Left-nullspace" class="headerlink" title="10.1.4 左零空间 Left nullspace"></a>10.1.4 左零空间 Left nullspace</h5><p>我们称矩阵$\boldsymbol A^{\mathrm T}$的零空间为矩阵$\boldsymbol A$的左零空间，它是$\mathbb{R}^m$空间中的子空间。</p>
<h4 id="10-2-基和维度-Basis-amp-Dimension"><a href="#10-2-基和维度-Basis-amp-Dimension" class="headerlink" title="10.2 基和维度 Basis&amp; Dimension"></a>10.2 基和维度 Basis&amp; Dimension</h4><h5 id="10-2-1-列空间"><a href="#10-2-1-列空间" class="headerlink" title="10.2.1 列空间"></a>10.2.1 列空间</h5><p>矩阵$\boldsymbol A$的个主元列(pivot columns)构成了列空间$C(\boldsymbol A)$的一组基。</p>
<script type="math/tex; mode=display">\dim C(\boldsymbol A) = \text{rank}(\boldsymbol A) = r</script><h5 id="10-2-2-零空间"><a href="#10-2-2-零空间" class="headerlink" title="10.2.2 零空间"></a>10.2.2 零空间</h5><p>$\boldsymbol{Ax = 0}$的一组特解对应于矩阵$\boldsymbol A$的$n - r$个自由列，并构成了零空间的一组基。个人理解：自由列分别进行one-hot处理。</p>
<script type="math/tex; mode=display">\dim N(\boldsymbol A) = n - r</script><h5 id="10-2-3-行空间"><a href="#10-2-3-行空间" class="headerlink" title="10.2.3 行空间"></a>10.2.3 行空间</h5><p>我们用矩阵$\boldsymbol A$的化简的行阶梯矩阵$\boldsymbol R$。</p>
<p>矩阵$\boldsymbol A$和矩阵$\boldsymbol R$的列空间不同$C(\boldsymbol A) \neq C(\boldsymbol R)$，但两者行空间相同。$\boldsymbol R$的行向量来自于$\boldsymbol A$的行向量的线性组合，因为<strong>消元操作是可逆的</strong>，所以$\boldsymbol A$的向量也可以表示为$\boldsymbol R$行向量的线性组合。</p>
<p>$\boldsymbol R$的前$r$行向量就是矩阵$\boldsymbol A$行空间$C(\boldsymbol A^{\mathrm T})$的一组基。以$\boldsymbol A$为例，其中一组基是$\boldsymbol R$中的前两行。</p>
<script type="math/tex; mode=display">\dim C(\boldsymbol A^{\mathrm T}) = r</script><p>为什么$\dim C(\boldsymbol A^{\mathrm T}) = r$，可以重点关注中$\boldsymbol R$的$\boldsymbol I$。</p>
<h5 id="10-2-4-左零空间"><a href="#10-2-4-左零空间" class="headerlink" title="10.2.4 左零空间"></a>10.2.4 左零空间</h5><p>左零空间矩阵$\boldsymbol A^{\mathrm T}$有$m$列，而其秩为$r$，因此其自由列数目为$m-r$，故$\dim N(\boldsymbol A^{\mathrm T}) = m - r$，左零矩阵是满足$\boldsymbol A^{\mathrm T} \boldsymbol y = \boldsymbol 0$的所有向量$\boldsymbol y$的集合。称之为左零矩阵是因为该式可写作$\boldsymbol y^{\mathrm T} \boldsymbol A = \boldsymbol 0^{\mathrm T}$此时右边为行向量，而$\boldsymbol y$出现在矩阵$\boldsymbol A$左侧。</p>
<p>为找到左零空间的基，我们应用增广矩阵：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
\boldsymbol A_{m \times n} & \boldsymbol I_{m \times n}
\end{array}\right] \rightarrow\left[\begin{array}{ll}
\boldsymbol R_{m \times n} & \boldsymbol E_{m \times n}
\end{array}\right]</script><p>我们将$\boldsymbol A$通过消元得到矩阵$\boldsymbol R$，其消元矩阵记为$\boldsymbol E$，即$\boldsymbol{EA = R}$。若为$\boldsymbol A$方阵，且$\boldsymbol{R = I}$，则有$\boldsymbol{E = A}^{-1}$</p>
<p><img src="https://pic.imgdb.cn/item/62ac8c5b0947543129aa9d0d.jpg" style="zoom:80%"></p>
<p>以行操作的观点来看矩阵$\boldsymbol E$和$\boldsymbol A$的乘法，则矩阵$\boldsymbol E$最下面的$m -r$个行向量使得矩阵$\boldsymbol A$的行向量线性组合成为$\boldsymbol 0$，也就是矩阵$\boldsymbol R$最下面的$m-r$个零向量。本例中，$m -r = 1$。</p>
<p>矩阵$\boldsymbol E$的这$m-r$个行向量满足$\boldsymbol{y}^{\mathrm T} \boldsymbol{A} = \boldsymbol{0}^{\mathrm T}$，它组成了矩阵$\boldsymbol A$左零空间的一组基，在本例中的左零空间的一组基为$\left[\begin{array}{c}-1 \\ 0 \\ 1 \end{array}\right]$。即上图中左边的部分所示的内容。</p>
<h4 id="10-3-新向量空间-New-vector-space"><a href="#10-3-新向量空间-New-vector-space" class="headerlink" title="10.3 新向量空间 New vector space"></a>10.3 新向量空间 New vector space</h4><p>所有$3 \times 3$矩阵构成的集合是一个矩阵空间，符合对线性运算封闭，称之为$\boldsymbol M$。$\boldsymbol M$的子空间包括：</p>
<ul>
<li>所有的上三角阵</li>
<li>所有的对称阵</li>
<li>所有的对角阵</li>
</ul>
<p>对角阵是前两个子空间的交集，其维度为3，其中一组基为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{lll}
1 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 0
\end{array}\right]\left[\begin{array}{lll}
0 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 0
\end{array}\right]\left[\begin{array}{lll}
0 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 1
\end{array}\right]</script><blockquote>
<p>矩阵空间的概念参考链接：<a href="https://blog.csdn.net/suyimin2010/article/details/90338886">矩阵空间、秩1矩阵 - Luckie stone - CSDN</a></p>
<p>讨论：当最初告诉我说，矩阵的列秩等于主元数，并且主元列构成了列空间的一组基时，其实我是拒绝的。主元这个东西不是行变换消元得来的么，消元过程列空间不是已经改变了么，为什么所得出U的主元数和主元列的位置还能够反映出矩阵A列空间的状态呢？</p>
<p>这里需要说明的是两点，其一是关于秩的定义有很多在数学上等价但是描述差异很大的说法，在这里我们把“秩”理解为行（列）向量中最大的线性无关向量组的向量数即可，在矩阵A行变换消元成梯形阵后，很容易看到行空间内极大无关组之一就是主元所在的那前r行，这r个行向量可以张成行空间，因此行空间的维数与主元数相等都是r，并且前r行构成了行空间的一组基。</p>
<p>但是为什么列空间的维数也是r，并且主元列可以构成列空间的一组基呢？这就是要说明的第二点，初等行变换不会改变列向量的线性相关性。为了叙述方便起见，我们假定矩阵A列向量的极大无关组就是A前r’列的向量（若否可以通过列交换而达成，列交换不会改变线性关系）。<a href="https://zhuanlan.zhihu.com/p/45826349">MIT—线性代数笔记10 四个基本子空间 - 三少爷的键的文章 - 知乎</a></p>
</blockquote>
<h3 id="11-矩阵空间、秩1矩阵和小世界图"><a href="#11-矩阵空间、秩1矩阵和小世界图" class="headerlink" title="11 矩阵空间、秩1矩阵和小世界图"></a>11 矩阵空间、秩1矩阵和小世界图</h3><h4 id="11-1-3∗3矩阵空间-3-by-3-matrices"><a href="#11-1-3∗3矩阵空间-3-by-3-matrices" class="headerlink" title="11.1 3∗3矩阵空间 3 by 3 matrices"></a>11.1 3∗3矩阵空间 3 by 3 matrices</h4><p>空间$\boldsymbol M$是所有$3 \times 3$矩阵所构成的空间，$\boldsymbol M$的部分子空间包括：</p>
<ul>
<li>所有的上三角阵 </li>
<li>所有的对称阵 </li>
<li>所有的对角阵</li>
</ul>
<p>对于矩阵空间而言，矩阵空间的维度是基矩阵的个数。它的一组基即为多个基矩阵。空间$\boldsymbol M$的维数为9，与$\mathbb{R}^9$空间很类似。我们可以选定它的一组基：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{lll}
1 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 1 & 0 \\
0 & 0 & 0 \\
0 & 0 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 0 & 1 \\
0 & 0 & 0 \\
0 & 0 & 0
\end{array}\right],
\cdots
,\left[\begin{array}{lll}
0 & 0 & 0 \\
0 & 0 & 0 \\
0 & 1 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 1
\end{array}\right]</script><p>对称阵构成的子空间$\boldsymbol S$维数为6，它的一组基为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{lll}
1 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 1
\end{array}\right],\left[\begin{array}{lll}
0 & 1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 0 & 1 \\
0 & 0 & 0 \\
1 & 0 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 0 & 0 \\
0 & 0 & 1 \\
0 & 1 & 0
\end{array}\right]</script><p>上三角阵构成的子空间$\boldsymbol U$维数也为6，它的一组基为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{lll}
1 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 1
\end{array}\right],\left[\begin{array}{lll}
0 & 1 & 0 \\
0 & 0 & 0 \\
0 & 0 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 0 & 1 \\
0 & 0 & 0 \\
0 & 0 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 0 & 0 \\
0 & 0 & 1 \\
0 & 0 & 0
\end{array}\right]</script><p>对角阵构成的子空间$\boldsymbol D$维数为3，可以选定$\boldsymbol S$和$\boldsymbol U$的基的交集为$\boldsymbol D$的基，具体为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{lll}
1 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 0
\end{array}\right],\left[\begin{array}{lll}
0 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 1
\end{array}\right]</script><p>$\boldsymbol S$和$\boldsymbol U$的并集，即$3 \times 3$矩阵中或为上三角阵或为对称阵的矩阵，构成$\boldsymbol M$的子空间么？答案是否定的。如下列矩阵加法所示：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{lll}
1 & -1 & 0 \\
-1 & 1 & 0 \\
0 & 0 & 1
\end{array}\right] + \left[\begin{array}{lll}
0 & 3 & 3 \\
0 & 0 & 4 \\
0 & 0 & 0
\end{array}\right] = \left[\begin{array}{lll}
1 & 2 & 3 \\
-1 & 1 & 4 \\
0 & 0 & 1
\end{array}\right]</script><p>显然最终结果并不在两者的并集中。这就如同在$\mathbb{R}^2$空间中找出两条直线，询问它们的并集是否构成一个子空间。如果我们将$\boldsymbol S$和$\boldsymbol U$中所有元素可能构成的加和作为一个集合，可以称为和集$\boldsymbol{S+U}$，它是$\boldsymbol M$的一个子空间。实际上$\boldsymbol{S+U}$就是$\boldsymbol M$本身，其维数为9。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\operatorname{dim}(S)+\operatorname{dim}(U)=\operatorname{dim}(S \cap U)+\operatorname{dim}(S+U) \\
&\operatorname{dim}(S+U)=\operatorname{dim}(S)+\operatorname{dim}(U)-\operatorname{dim}(S \cap U)
\end{aligned}</script><h4 id="11-2-微分方程-Differential-equations"><a href="#11-2-微分方程-Differential-equations" class="headerlink" title="11.2 微分方程 Differential equations"></a>11.2 微分方程 Differential equations</h4><p>对于给定的微分方程$\dfrac{\text{d}^2y}{\text{d}x^2}$，求解该方程可以视为求它的零空间。可以得到解为：$y = \cos(x), y = \sin(x), y = e^{ix}$，事实上通解为$y = c_1\cos(x) + c_2\sin(x)$，其中$c_1, c_2$可以取任意实数。也将解的线性组合构成的空间称为解空间，其维数为2。$\cos(x), \sin(x)$可以成为解空间的一组基。它们是函数，而不是向量，但是可以对其进行线性运算，在线性代数的范畴内讨论之。</p>
<h4 id="11-3-子空间的交，和与维数定理"><a href="#11-3-子空间的交，和与维数定理" class="headerlink" title="11.3 子空间的交，和与维数定理"></a>11.3 子空间的交，和与维数定理</h4><p>接下来到关键的地方了，建议先阅读<a href="https://zhuanlan.zhihu.com/p/76674347">《线性代数-线性空间的知识梳理3》</a>中子空间的<strong>交</strong>、<strong>和</strong>和<strong>维数定理</strong>等小节。</p>
<p>接下来我们研究矩阵空间$\boldsymbol M$的子空间$\boldsymbol S$和$\boldsymbol U$的交，即$\boldsymbol S \cap \boldsymbol U$，这个比较简单，易知$\boldsymbol S \cap \boldsymbol U$即对角矩阵，其维数明显为3。</p>
<p>但若要直接研究$\boldsymbol S$和$\boldsymbol U$ 的和，即$\boldsymbol S + \boldsymbol U$ ，这个就没有$\boldsymbol S \cap \boldsymbol U$那么直观了：</p>
<p><strong>一种方法</strong>是通过定义，即</p>
<script type="math/tex; mode=display">
\boldsymbol S + \boldsymbol U = \begin{Bmatrix} \boldsymbol \alpha + \boldsymbol \beta \mid \boldsymbol \alpha \in \boldsymbol S, \boldsymbol \beta \in \boldsymbol U \end{Bmatrix}</script><p>那么可以发现，对于任何一个$3 \times 3$矩阵，它是可以表示成一个对称矩阵和一个上三角矩阵的和：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{lll}
a_{11} & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23} \\
a_{31} & a_{32} & a_{33}
\end{array}\right]=\left[\begin{array}{ccc}
a_{11} & a_{21} & a_{31} \\
a_{21} & a_{22} & a_{32} \\
a_{31} & a_{32} & a_{33}
\end{array}\right]+\left[\begin{array}{ccc}
0 & a_{12}-a_{21} & a_{13}-a_{31} \\
0 & 0 & a_{23}-a_{32} \\
0 & 0 & 0
\end{array}\right]</script><p>所以$\boldsymbol S + \boldsymbol U = \boldsymbol M$ ，因此$\dim(\boldsymbol S + \boldsymbol U) = 9$ 。</p>
<p><strong>另一种方法</strong>，为了确定$\boldsymbol S + \boldsymbol U$的维数，可以利用维数定理，即：</p>
<script type="math/tex; mode=display">
\dim(\boldsymbol S + \boldsymbol U) = \dim(\boldsymbol S) + \dim(\boldsymbol U) - \dim(\boldsymbol S \cap \boldsymbol U)</script><p>这个公式中，$\dim(\boldsymbol S \cap \boldsymbol U) = 3$ ，所以$\dim(\boldsymbol S + \boldsymbol U)  = 9$ ，而由$\boldsymbol S + \boldsymbol U$的定义可知，其本身就是$\boldsymbol M$的一个子空间，且$\dim(\boldsymbol M) = 9$，所以$\boldsymbol S + \boldsymbol U = \boldsymbol M$ ，即$\boldsymbol S$和$\boldsymbol U$的和刚好覆盖了整个矩阵空间$\boldsymbol M$。</p>
<p>这就是维数定理一个很好的应用，有时候直接分析两个子空间的和不容易，那么可以考虑通过维数定理先分别分析这两个子空间，再分析其交，这样就能得到$\dim(\boldsymbol S + \boldsymbol U)$，<strong>一旦我们知道一个子空间的维数</strong>$n$<strong>，那么只要找到这个子空间中</strong>$n$<strong>个线性无关的向量，那么这</strong>$n$<strong>个向量就是子空间的一个基</strong>。</p>
<p>本小节除了介绍子空间的交，和和维数定理，另一方面是给出线性空间中元素一般性的例子，当然课堂中，老师还讲到了线性微分方程的解空间也是一个线性空间，这里不做具体介绍。</p>
<h4 id="11-4-秩1矩阵"><a href="#11-4-秩1矩阵" class="headerlink" title="11.4 秩1矩阵"></a>11.4 秩1矩阵</h4><p>对秩为1的矩阵，也可以进行研究，比如秩为1的矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol A=\left(\begin{array}{ccc}
1 & 4 & 5 \\
2 & 8 & 10
\end{array}\right)</script><p>我们从行向量的角度分解，可以等价表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol A=\left(\begin{array}{ccc}
1 & 4 & 5 \\
2 & 8 & 10
\end{array}\right)=\left(\begin{array}{l}
1 \\
2
\end{array}\right)\left(\begin{array}{lll}
1 & 4 & 5
\end{array}\right)</script><p>我们有所有<strong>秩为1的矩阵可以表示为一列乘以一行的形式</strong>，即：$\boldsymbol A = \boldsymbol{uv}^{\mathrm T}$。</p>
<p>之后的学习中，我们会认识到秩1矩阵行列式和特征值都会很简单。再讨论一下几个问题：</p>
<h5 id="11-4-1-问题1"><a href="#11-4-1-问题1" class="headerlink" title="11.4.1 问题1"></a>11.4.1 问题1</h5><p>比如，一个$s \times n$ 的矩阵的秩为$r$，我们可以将其表示成$r$个秩1矩阵的组合，所以秩1矩阵很有用，它就像搭建其他矩阵的积木一样。</p>
<p>举个简单例子：</p>
<script type="math/tex; mode=display">
\boldsymbol A=\left[\begin{array}{cccc}
1 & 2 & 2 & 2 \\
2 & 4 & 6 & 8 \\
3 & 6 & 8 & 10
\end{array}\right]=\left(\vec{a}_{1}, \vec{a}_{2}, \vec{a}_{3}, \vec{a}_{4}\right)</script><p>通过初等行变换：</p>
<script type="math/tex; mode=display">
\boldsymbol A=\left[\begin{array}{cccc}
1 & 2 & 2 & 2 \\
2 & 4 & 6 & 8 \\
3 & 6 & 8 & 10
\end{array}\right] \sim\left[\begin{array}{cccc}
1 & 2 & 2 & 2 \\
0 & 0 & 2 & 4 \\
0 & 0 & 0 & 0
\end{array}\right] \sim\left[\begin{array}{cccc}
1 & 2 & 0 & -2 \\
0 & 0 & 1 & 2 \\
0 & 0 & 0 & 0
\end{array}\right]</script><p>所以$\text{rank}(\boldsymbol A) = 2$ ，$\boldsymbol A$的1和3列是列空间的一个基，其零空间：</p>
<script type="math/tex; mode=display">
N_{n \times(n-r)}=\left[\begin{array}{c}
-F_{r \times(n-r)} \\
I_{n-r}
\end{array}\right]=N_{4 \times 2}=\left[\begin{array}{cc}
-2 & 2 \\
1 & 0 \\
0 & -2 \\
0 & 1
\end{array}\right]</script><p>由原始$\boldsymbol A$第一列可知$\vec{a}_{2}=2 \vec{a}_{1}, \vec{a}_{4}=-2 \vec{a}_{1}+2 \vec{a}_{3}$，则：</p>
<script type="math/tex; mode=display">
A=\left(\vec{a}_{1}, 2 \vec{a}_{1}, \vec{a}_{3},-2 \vec{a}_{1}+2 \vec{a}_{3}\right)=\left(\vec{a}_{1}, 2 \vec{a}_{1}, \overrightarrow{0},-2 \vec{a}_{1}\right)+\left(\overrightarrow{0}, \overrightarrow{0}, \vec{a}_{3}, 2 \vec{a}_{3}\right)</script><p>即：</p>
<script type="math/tex; mode=display">
\boldsymbol A=\left[\begin{array}{cccc}
1 & 2 & 0 & -2 \\
2 & 4 & 0 & -4 \\
3 & 6 & 0 & -6
\end{array}\right] + \left[\begin{array}{cccc}
0 & 0 & 2 & 4 \\
0 & 0 & 6 & 12 \\
0 & 0 & 8 & 16
\end{array}\right]</script><p>这就将$\boldsymbol A$ 分解成了两个秩1矩阵的和。</p>
<h5 id="11-4-2-问题2"><a href="#11-4-2-问题2" class="headerlink" title="11.4.2 问题2"></a>11.4.2 问题2</h5><p>但$s \times n$型矩阵所有秩1矩阵所构成的子集显然不是一个子空间。</p>
<h5 id="11-4-3-问题3"><a href="#11-4-3-问题3" class="headerlink" title="11.4.3 问题3"></a>11.4.3 问题3</h5><p>我们来看这样一个定义在数域$\boldsymbol K$上的列向量的集合$\boldsymbol W$：</p>
<script type="math/tex; mode=display">
\left\{\left[v_{1}, v_{2}, v_{3}, v_{4}\right]^{\mathrm T} \mid v_{1}+v_{2}+v_{3}+v_{4}=0, \quad v_{1}, v_{2}, v_{3}, v_{4} \in \boldsymbol K\right\}</script><p>它是$\boldsymbol K^4(\mathbb{K}^4)$的子空间吗？</p>
<p>我们很容易验证它对加法和数乘运算都封闭，所以$\boldsymbol W$是$\boldsymbol K^4$的一个子空间。</p>
<p>那么，这个子空间结构是什么样子，换句话说，它的基和维数又是什么？</p>
<p>观察到$v_{1}+v_{2}+v_{3}+v_{4}=0$，这很像求解$\boldsymbol{Ax = 0}$ 时将化成的列向量组的形式，那么可以构造一个$\boldsymbol A = [1, 1,1, 1]$。这样，求$\boldsymbol W$的维数就变成了求 $\boldsymbol A$的零空间的维数。而$\text{rank}(\boldsymbol A) = 1$所以 $\text{rank }N(\boldsymbol A) = 3$ ，即$\text{rank}(\boldsymbol W) = 3$。同理，我们可以求出$\boldsymbol W$ 的一个基，即$N(\boldsymbol A)$的一个基为：</p>
<script type="math/tex; mode=display">
N_{n \times(n-r)}=\left[\begin{array}{c}
-F_{r \times(n-r)} \\
I_{n-r}
\end{array}\right]=N_{4 \times 3}=\left[\begin{array}{ccc}
-1 & -1& -1 \\
1 & 0 & 0\\
0 & 1 & 0 \\
0 & 0 & 1
\end{array}\right]</script><h4 id="11-5小世界图-Small-world-graphs"><a href="#11-5小世界图-Small-world-graphs" class="headerlink" title="11.5小世界图 Small world graphs"></a>11.5小世界图 <strong>Small world graphs</strong></h4><p>介绍小世界图主要是引出<strong>图论和线性代数</strong>的联系。</p>
<p>在这里，“图”G是结点和边的集合$G = \begin{Bmatrix} \text{node}, \text{edge} \end{Bmatrix}​$ ：                </p>
<p><img src="https://pic.imgdb.cn/item/62ad3a680947543129628128.jpg" style="zoom:30%"></p>
<p>此图包含5个结点和6条边，我们可以利用一个$5 \times 6$矩阵完全描述它。</p>
<p>我们可以用图来描述一个实际问题，如果每个人是一个结点，两个人互相认识为一个边，那么整个美国可以以此构成一张大图。我们可以通过这张图来确认两个人之间的最短距离是多少，即两个人需要通过最少几个朋友才能建立联系。G本人和克林顿之间的距离为2，他的一个朋友是参议员，他认识这个参议员朋友，那个人认识克林顿。班里的学生跟克林顿的距离因此不会大于3。还可以继续算希拉里和莱温斯基之间的距离，哈哈。</p>
<p>所谓“六度分割理论”（six degrees of separation）猜想一个人和陌生人之间间隔的点不会超过六个。因此当陌生的两人聊起这种联系都会感叹：“世界真小啊！”这也是“小世界图”这个名字的由来。</p>
<h3 id="12-图、网络、关联矩阵"><a href="#12-图、网络、关联矩阵" class="headerlink" title="12 图、网络、关联矩阵"></a>12 图、网络、关联矩阵</h3><p>本讲讨论线性代数在物理系统中的应用。可参考链接为：</p>
<h4 id="12-1-图和网络-Graphs-amp-Networks"><a href="#12-1-图和网络-Graphs-amp-Networks" class="headerlink" title="12.1 图和网络 Graphs &amp; Networks"></a>12.1 <strong>图和网络</strong> Graphs &amp; Networks</h4><p>图是结点(node)和边(edge)的一个集合。</p>
<p><img src="https://pic.imgdb.cn/item/62ad3be8094754312964443f.jpg" style="zoom:70%"></p>
<p>边线上的箭头代表从结点流出的正方向。上图里包含4个结点，5条边，我们可以将每条边都指定参考方向用于区分正负，比如一个电路网络。在此例子中，将使用电势、回路、电流之类的词汇（当然这个模型还可以表示为液压系统、建筑结构等）。我们通过构造一个incidence matrix关联矩阵来解析这个图的含义。</p>
<h4 id="12-2-关联矩阵（Incidence-matrices）"><a href="#12-2-关联矩阵（Incidence-matrices）" class="headerlink" title="12.2 关联矩阵（Incidence matrices）"></a>12.2 关联矩阵（Incidence matrices）</h4><p>构造一个矩阵来表示图的内在含义，此矩阵称为关联矩阵，图中每个结点代表一列，每边代表一行。则上图为$5 \times 4$矩阵。反过来从这个矩阵出发我们也能画出图。</p>
<center><img src="https://pic.imgdb.cn/item/62ad3c83094754312964ed92.jpg" style="zoom:40%"></center>

<p>第1行代表边①，从结点1流出记为-1，从结点2流入记为 1。也就是从结点1流向了结点2。</p>
<p>边①、边②和边③构成了一个回路，称为<strong>环</strong>（loop）。反映在矩阵上是这三个行向量线性相关。</p>
<p>源于现实问题的关联矩阵，通常描述了问题的结构。如果我们研究一个很大的图，则会构建一个很大的矩阵，但这个矩阵会是<strong>稀疏矩阵</strong>。</p>
<h5 id="12-2-1-零空间"><a href="#12-2-1-零空间" class="headerlink" title="12.2.1 零空间"></a>12.2.1 零空间</h5><p>考察矩阵的零空间，即求$\boldsymbol{Ax = 0}$的解。零空间告诉我们列向量线性组合的状态。这里$\boldsymbol x$的分量表示的是每个节点。</p>
<script type="math/tex; mode=display">
\boldsymbol{A x}=\left[\begin{array}{l}
x_{2}-x_{1} \\
x_{3}-x_{2} \\
x_{3}-x_{1} \\
x_{4}-x_{1} \\
x_{4}-x_{3}
\end{array}\right]=\left[\begin{array}{l}
0 \\
0 \\
0 \\
0 \\
0
\end{array}\right]</script><p>如果$\boldsymbol x$为结点上的电势，则$\boldsymbol{Ax}$给出了每个边上的电势差。求解可以得到零空间为一维$\dim N(\boldsymbol A) = 1$，它的基就是$\left(\begin{array}{l}1 \\1 \\1 \\1 \end{array}\right)$，解集则是$\boldsymbol x = c \left(\begin{array}{l}1 \\1 \\1 \\1 \end{array}\right)$代表等电势，说明等电势条件下不会有电流产生。常数$c$的确定需要边界条件，比如我们将结点4接地，则$x_4 = 0$ 。</p>
<h5 id="12-2-2-列空间"><a href="#12-2-2-列空间" class="headerlink" title="12.2.2 列空间"></a>12.2.2 列空间</h5><p>若求$\boldsymbol{Ax = b}$的解，则相当于在给定了电压$\boldsymbol b$的情况下，求各点的电势，但实际上我们得不到电势的准确值，因为零空间有常数解$c$ ，各点得到的电势需要加上常数$c$，这很类似于求积分要加上常函数，常数值需要边界条件来确定。</p>
<p>矩阵的列数为4，而其零空间的维数为1，则矩阵的秩为3，矩阵第1列、第2列和第4列的列向量线性无关。</p>
<p>考察矩阵列空间，一个重要的问题就是对于什么样的$\boldsymbol b$，$\boldsymbol{Ax = b}$有解。边①、边②和边③构成了环，这三个行向量线性相关，同样的情况还有边④、边⑤和边③构成的环。</p>
<p>我们沿着第一幅图中的一个环边$(1, 3, -2)$对电势差求和：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\left(x_{2}-x_{1}\right)+\left(x_{3}-x_{2}\right)-\left(x_{3}-x_{1}\right)=0 \\
&x_{2}-x_{1}=b_{1}, x_{3}-x_{2}=b_{3}, x_{3}-x_{1}=b_{2}
\end{aligned}</script><p>所以$\boldsymbol b$的分量满足$b_1+b_3-b_2 = 0$和$b_3-b_4+b_5 = 0$。如果把边①、边②、边④、边⑤构成的大环也表示出来则还可以得到一个等式$b_1-b_2+b_4-b_5 = 0$，但实际上这个等式就是之前这两个等式的组合。这两个等式就是<strong>基尔霍夫电压定律</strong>(Kirchhoff’s Voltage law)，即环路电势差之和为零。</p>
<h5 id="12-2-3-左零空间"><a href="#12-2-3-左零空间" class="headerlink" title="12.2.3 左零空间"></a>12.2.3 左零空间</h5><p>矩阵的左零空间是满足$\boldsymbol A^{\mathrm T} \boldsymbol y = 0$的向量$\boldsymbol y$的集合。其中$\boldsymbol y$的每个分量表示的是每个边。因为矩阵$\boldsymbol A^{\mathrm T} $有5列，且矩阵的秩为3，因此矩阵的左零空间维数为2。这反应了行向量的线性关系，整个“图”中，环数为2。</p>
<script type="math/tex; mode=display">
\boldsymbol{A}^{T} \boldsymbol{y}=\left[\begin{array}{ccccc}
-1 & 0 & -1 & -1 & 0 \\
1 & -1 & 0 & 0 & 0 \\
0 & 1 & 1 & 0 & -1 \\
0 & 0 & 0 & 1 & 1
\end{array}\right]\left[\begin{array}{l}
y_1 \\
y_2 \\
y_3 \\
y_4 \\
y_5
\end{array}\right]=\left[\begin{array}{l}
0 \\
0 \\
0 \\
0
\end{array}\right]</script><p>其中$\boldsymbol y$的分量的值为“边”上的电流。在电势差和电流之间建立联系就是<strong>欧姆定律</strong>(Ohm’s Law)。</p>
<p><img src="https://pic.imgdb.cn/item/62ad40a609475431296a5750.jpg" style="zoom:50%"></p>
<p>我们求解$\boldsymbol A^{\mathrm T} \boldsymbol y = 0$就是在求5个满足基尔霍夫电流定律(Kirchhoff’s Law)的电流值。</p>
<p>$\boldsymbol A^{\mathrm T} \boldsymbol y = 0$的方程形式$\left\{\begin{array}{r}-y_{1}-y_{3}-y_{4}=0 \\ y_{1}-y_{2}=0 \\ y_{2}+y_{3}-y_{5}=0 \\ y_{4}+y_{5}=0\end{array}\right.$，每一个方程关于一个结点，方程表示结点电流值为0，即流入等于流出。</p>
<p>从图上解方程，而不是采用消元法解方程。如果我们设定$y_1 = 1$组成的回路的“环流“为0，则有$y_2 = 1, y_3 = -1$可解得$\boldsymbol y =\left[\begin{array}{c} 1 \\ 1 \\ -1 \\ 0 \\ 0\end{array}\right]$。取另一个回路的环流为0，则有$y_3 = 1, y_4 = -1, y_5 = 1$可解得$\boldsymbol y =\left[\begin{array}{c} 0 \\ 0 \\ 1 \\ -1 \\ 1\end{array}\right]$。如果设定$y_1, y_2, y_3, y_4, y_5$组成的大回路环流为0，则可以得到另一个向量$\boldsymbol y$，而该向量在零空间内，是前两个向量的线性组合。 </p>
<h5 id="12-2-4-行空间——对应边"><a href="#12-2-4-行空间——对应边" class="headerlink" title="12.2.4 行空间——对应边"></a>12.2.4 行空间——对应边</h5><p>考察矩阵的行空间，因为矩阵秩$r = 3$，所以存在3个线性无关的向量。第1行、第2行和第4行为线性无关，在“图”中，边①、边②和边④构成了一张小图，这三个边没有形成回路。线性相关问题等价于形成回路。没有回路的小图包含4个结点和3条边，再添加一条边就会产生回路，在矩阵里表现为在第1行、第2行和第4行之上再添加一个行向量就会变为线性相关。<strong>没有回路的图称为“树”</strong>。</p>
<p>思考一下维数公式的在“图”中的意义：</p>
<ul>
<li>左零空间维数$\dim N(\boldsymbol A^{\mathrm T}) = m - r$</li>
<li>等价于“环”数量 = “边”数量-(“结点”数量-1)</li>
</ul>
<p>即<strong><font color="red">Eular公式</font></strong>：</p>
<script type="math/tex; mode=display">
“结点” − “边” + “环” = 1</script><p>对所有图都成立。$矩阵的秩r = 结点 − 1$，因为r表示了线性无关的边的数目，也就是“树”中“边”的数目。</p>
<p><img src="https://pic.imgdb.cn/item/62ad44f209475431296fc86b.jpg" style="zoom:50%"></p>
<p>之前的讨论都是针对于一个无源的电场，如果加入电源则情况又不同，例如加入电流源相当于将基尔霍夫定律的方程变为$\boldsymbol A^{\mathrm T} \boldsymbol y = f$，$f$就是外部流入的电流。将$\boldsymbol{e = Ax}, \boldsymbol y = c \boldsymbol e, \boldsymbol A^{\mathrm T} \boldsymbol y = f$ ，三个等式结合得到应用数学中的基本方程$\boldsymbol A^{\mathrm T}c\boldsymbol A \boldsymbol x = f$。</p>
<p>关于方程$\boldsymbol A^{\mathrm T}c\boldsymbol A \boldsymbol x = f$的更多内容可以阅读GS老先生08的书“Computational science and engineering”的第二章。</p>
<h3 id="13-习题课1"><a href="#13-习题课1" class="headerlink" title="13 习题课1"></a>13 习题课1</h3><p>具体内容参考：<a href="https://zhuanlan.zhihu.com/p/45855579">MIT—线性代数笔记13 复习一 - 三少爷的键的文章 - 知乎</a></p>
<hr>
<p>资料链接：<a href="https://www.zhihu.com/column/c_1029672383375949824">三少爷的MIT笔记</a>，超强数学笔记！！！</p>
<p>资料链接：<a href="https://blog.csdn.net/xhf0374/article/details/63250083">MIT 公开课：Gilbert Strang《线性代数》课程笔记（汇总）</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>数学基础</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>本质问题</tag>
        <tag>线代</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵相关计算</title>
    <url>/2024/04/07/Matrix-Calculation/</url>
    <content><![CDATA[<h3 id="1-矩阵乘法的五种理解方式"><a href="#1-矩阵乘法的五种理解方式" class="headerlink" title="1 矩阵乘法的五种理解方式"></a>1 矩阵乘法的五种理解方式</h3><h4 id="1-1-定义的角度"><a href="#1-1-定义的角度" class="headerlink" title="1.1 定义的角度"></a>1.1 定义的角度</h4><p>设$\boldsymbol{C = AB}$，则矩阵$\boldsymbol A$的$(i,j)$处的元素为$\boldsymbol A$的第$i$行与$\boldsymbol B$的第$j$列的各元素相乘之和，即：</p>
<script type="math/tex; mode=display">
c_{i j}=a_{i 1} b_{1 j}+a_{i 2} b_{2 j}+\cdots+a_{i n} b_{n j}=\sum_{k=1}^{n} a_{i k} b_{k j}</script><p>也即是$\boldsymbol A$的第$i$行与$\boldsymbol B$的第$j$列点乘所得到的结果。</p>
<h4 id="1-2-列的角度"><a href="#1-2-列的角度" class="headerlink" title="1.2 列的角度"></a>1.2 列的角度</h4><p>设矩阵$\boldsymbol B$为$\boldsymbol B = (\boldsymbol \beta_1, \boldsymbol \beta_2, \cdots, \boldsymbol \beta_n)$则：</p>
<script type="math/tex; mode=display">
\boldsymbol{AB} = \boldsymbol A (\boldsymbol \beta_1, \boldsymbol \beta_2, \cdots, \boldsymbol \beta_n) = (\boldsymbol A \boldsymbol \beta_1, \boldsymbol A \boldsymbol \beta_2, \cdots, \boldsymbol A \boldsymbol \beta_n)</script><p>因此，从列的角度来看，矩阵$\boldsymbol B$右乘矩阵$\boldsymbol A$所得到的矩阵的每一列都是$\boldsymbol A$的列的线性组合，线性组合的系数分别是$\boldsymbol B$的各列的分量。</p>
<h4 id="1-3-行的角度"><a href="#1-3-行的角度" class="headerlink" title="1.3 行的角度"></a>1.3 行的角度</h4><p>设矩阵$\boldsymbol A$为：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}=\left(\begin{array}{c}
\boldsymbol{a}_{1}^{\mathrm{T}} \\
\boldsymbol{\alpha}_{2}^{\mathrm{T}} \\
\vdots \\
\boldsymbol{\alpha}_{n}^{\mathrm{T}}
\end{array}\right)</script><p>则有：</p>
<script type="math/tex; mode=display">
\boldsymbol{AB}=\left(\begin{array}{c}
\boldsymbol{a}_{1}^{\mathrm{T}} \boldsymbol B\\
\boldsymbol{\alpha}_{2}^{\mathrm{T}} \boldsymbol B\\
\vdots \\
\boldsymbol{\alpha}_{n}^{\mathrm{T}} \boldsymbol B
\end{array}\right)</script><p>因此，从行的角度来看，矩阵$\boldsymbol A$左乘矩阵$\boldsymbol B$所得到的矩阵的每一行都是$\boldsymbol B$的行的线性组合，线性组合的系数分别是$\boldsymbol A$的各行的分量。</p>
<h4 id="1-4-从列乘以行的角度"><a href="#1-4-从列乘以行的角度" class="headerlink" title="1.4 从列乘以行的角度"></a>1.4 从列乘以行的角度</h4><p>设矩阵$\boldsymbol A$、$\boldsymbol B$分别为：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}=\left(\boldsymbol{\alpha}_{1}, \boldsymbol{\alpha}_{2} \cdots, \boldsymbol{\alpha}_{n}\right),  \quad \boldsymbol{B}=\left(\begin{array}{c}
\boldsymbol{\beta}_{1}^{\mathrm{T}} \\
\boldsymbol{\beta}_{2}^{\mathrm{T}} \\
\vdots \\
\boldsymbol{\beta}_{n}^{\mathrm{T}}
\end{array}\right)</script><p>则有：</p>
<script type="math/tex; mode=display">
\boldsymbol{A B}=\boldsymbol{\alpha}_{1} \boldsymbol{\beta}_{1}^{\mathrm{T}}+\boldsymbol{\alpha}_{2} \boldsymbol{\beta}_{2}^{\mathrm{T}}+\cdots+\boldsymbol{\alpha}_{n} \boldsymbol{\beta}_{n}^{\mathrm{T}}=\sum_{k=1}^{n} \boldsymbol{\alpha}_{k} \boldsymbol{\beta}_{k}^{\mathrm{T}}</script><p>由于列向量乘以行向量得到的是一个矩阵，因此从列乘以行的角度来看，矩阵$\boldsymbol A$乘以$\boldsymbol B$得到的是$n$个矩阵之和，其中第$i$个矩阵由$\boldsymbol A$的第$i$列乘以$\boldsymbol B$的第$j$行得到。</p>
<h4 id="1-5-分块乘法-block-multiplication"><a href="#1-5-分块乘法-block-multiplication" class="headerlink" title="1.5 分块乘法(block multiplication)"></a>1.5 分块乘法(block multiplication)</h4><p>矩阵乘法同样可以分块来乘，只要分块的大小能够使乘法有意义即可(分块的大小要相互匹配)如</p>
<script type="math/tex; mode=display">
\boldsymbol{A B}=\left(\begin{array}{ll}
\boldsymbol{A}_{1} & \boldsymbol{A}_{2} \\
\boldsymbol{A}_{3} & \boldsymbol{A}_{4}
\end{array}\right)\left(\begin{array}{ll}
\boldsymbol{B}_{1} & \boldsymbol{B}_{2} \\
\boldsymbol{B}_{3} & \boldsymbol{B}_{4}
\end{array}\right)=\left(\begin{array}{ll}
\boldsymbol{A}_{1} \boldsymbol{B}_{1}+\boldsymbol{A}_{2} \boldsymbol{B}_{3} & \boldsymbol{A}_{1} \boldsymbol{B}_{2}+\boldsymbol{A}_{2} \boldsymbol{B}_{4} \\
\boldsymbol{A}_{3} \boldsymbol{B}_{1}+\boldsymbol{A}_{4} \boldsymbol{B}_{3} & \boldsymbol{A}_{3} \boldsymbol{B}_{2}+\boldsymbol{A}_{4} \boldsymbol{B}_{4}
\end{array}\right)</script><p><img src="https://pic.imgdb.cn/item/66125bc168eb935713ed1845.png" alt="image.png"></p>
<h3 id="2-矩阵迹、F范数与内积"><a href="#2-矩阵迹、F范数与内积" class="headerlink" title="2 矩阵迹、F范数与内积"></a>2 矩阵迹、F范数与内积</h3><h4 id="2-1-基本定义"><a href="#2-1-基本定义" class="headerlink" title="2.1 基本定义"></a>2.1 基本定义</h4><p>矩阵的迹 ：就是矩阵的主对角线上所有元素的和，对于矩阵$\boldsymbol A \in \mathbb K^{N \times N}$或$\boldsymbol A \in \mathbb K^{N \times N}$定义式为：</p>
<script type="math/tex; mode=display">
\text{Tr}(\boldsymbol A) = \sum_{i=1}^N a_{ii}</script><p>对于矩阵$\boldsymbol A \in \mathbb K^{M \times N}$乘$\boldsymbol B \in \mathbb K^{N \times M}$的迹： </p>
<script type="math/tex; mode=display">
\text{Tr}(\boldsymbol{AB}) = \sum_{i=1}^M \sum_{j=1}^N a_{ij}b_{ji}</script><p>其中，$\mathbb K$表示实数域$\mathbb R$或者复数域$\mathbb C$均可。</p>
<p>矩阵$\boldsymbol A \in \mathbb K^{M \times N}$的F范数定义式为：</p>
<script type="math/tex; mode=display">
\| \boldsymbol A \|_F = \sqrt{\sum_{i=1}^M \sum_{j=1}^N |a_{ij}|^2}</script><p>F范数与迹的关系：</p>
<script type="math/tex; mode=display">
\| \boldsymbol A \|^2_F = \text{Tr}(\boldsymbol A \boldsymbol A^T) = \text{Tr}(\boldsymbol A^T \boldsymbol A) \\
\| \boldsymbol A \|^2_F = \text{Tr}(\boldsymbol A \boldsymbol A^H) = \text{Tr}(\boldsymbol A^H \boldsymbol A)</script><p>对于矩阵$\boldsymbol A \in \mathbb K^{M \times N}$乘$\boldsymbol B \in \mathbb K^{M \times N}$的内积定义式为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \langle \boldsymbol A , \boldsymbol B \rangle = \text{Tr}(\boldsymbol A^T \boldsymbol B)= \text{Tr}(\boldsymbol B \boldsymbol A^T)  = \text{Tr}(\boldsymbol B^T \boldsymbol A) = \text{Tr}(\boldsymbol A \boldsymbol B^T)  \\
& \langle \boldsymbol A , \boldsymbol B \rangle = \text{Tr}(\boldsymbol A^H \boldsymbol B) = \text{Tr}(\boldsymbol B \boldsymbol A^H )
\end{aligned}</script><p>注意到，两个矩阵求内积必须维度是相同的。此外，特别的对于复数域，有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\langle \boldsymbol A , \boldsymbol B \rangle &= \text{Tr}(\boldsymbol A^H \boldsymbol B) = \text{Tr}(\boldsymbol B \boldsymbol A^H ) \\
&= \overline{\text{Tr}(\boldsymbol B^H \boldsymbol A)} = \overline{\text{Tr}(\boldsymbol A \boldsymbol B^H)} \\
& = \text{Tr}(\overline{\boldsymbol B^H \boldsymbol A}) = \text{Tr}(\overline{\boldsymbol A \boldsymbol B^H})

\end{aligned}</script><p>其中，上划线表示取共轭。</p>
<p>F范数与内积的关系：</p>
<script type="math/tex; mode=display">
\| \boldsymbol A \|^2_F = \langle \boldsymbol A , \boldsymbol A \rangle</script><h4 id="2-2-矩阵迹的运算"><a href="#2-2-矩阵迹的运算" class="headerlink" title="2.2 矩阵迹的运算"></a>2.2 矩阵迹的运算</h4><ul>
<li><strong>性质1：</strong>不论是实数域还是复数域矩阵$\boldsymbol A$的迹和其转置的迹相等</li>
</ul>
<script type="math/tex; mode=display">
\text{Tr}(\boldsymbol A) = \text{Tr}(\boldsymbol A^T)</script><blockquote>
<p>但注意在复数域要取共轭转置时候有：$\text{Tr}(\boldsymbol A) =\overline{ \text{Tr}(\boldsymbol A^H)}$。</p>
</blockquote>
<ul>
<li><strong>性质2：</strong>矩阵迹的循环交替性质(在复数域也是成立的)</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
& \text{Tr}(\boldsymbol{AB}) = \text{Tr}(\boldsymbol{BA}) \\
& \text{Tr}(\boldsymbol{ABC}) = \text{Tr}(\boldsymbol{CAB)} = \text{Tr}(\boldsymbol{BCA)} \\
& \text{Tr}(\boldsymbol{ABCD}) = \text{Tr}(\boldsymbol{DABC)} = \text{Tr}(\boldsymbol{CDAB)} = \text{Tr}(\boldsymbol{BCDA)} \\
& \quad  \vdots \\
& \text{Tr}(\boldsymbol{AB}^H) = \text{Tr}(\boldsymbol{B}^H \boldsymbol A) \\
& \text{Tr}(\boldsymbol{ABC}^H) = \text{Tr}(\boldsymbol{C}^H\boldsymbol{AB)} = \text{Tr}(\boldsymbol{B}\boldsymbol{C}^H\boldsymbol{A)} \\
& \quad  \vdots
\end{aligned}</script><ul>
<li><strong>性质3：</strong>数乘性质，若$a$为一个实数 </li>
</ul>
<script type="math/tex; mode=display">
\text{Tr}(a\boldsymbol A) = a\text{ Tr}(\boldsymbol A)</script><ul>
<li><strong>性质4：</strong>矩阵求和的迹和矩阵的迹的和相等 </li>
</ul>
<script type="math/tex; mode=display">
\text{Tr}(\boldsymbol A +\boldsymbol B + \boldsymbol C ) = \text{Tr}(\boldsymbol A) + \text{Tr}(\boldsymbol B) + \text{Tr}(\boldsymbol C)</script><p>注意，上述性质可以<strong>相互组合</strong>使用。</p>
<h3 id="3-矩阵的求导"><a href="#3-矩阵的求导" class="headerlink" title="3 矩阵的求导"></a>3 矩阵的求导</h3><h4 id="3-1-纯向量-矩阵求导"><a href="#3-1-纯向量-矩阵求导" class="headerlink" title="3.1 纯向量/矩阵求导"></a>3.1 纯向量/矩阵求导</h4><h5 id="3-1-1-实向量求导"><a href="#3-1-1-实向量求导" class="headerlink" title="3.1.1 实向量求导"></a>3.1.1 实向量求导</h5><p>实向量$\boldsymbol x \in \mathbb R^{N \times 1}$</p>
<script type="math/tex; mode=display">
\frac{\partial \boldsymbol x}{\partial \boldsymbol x} = \boldsymbol I, \qquad \frac{\partial \boldsymbol {Ax}}{\partial \boldsymbol x} = \boldsymbol A^{\text{T}}, \qquad \frac{\partial \boldsymbol {x}^{\mathrm T} \boldsymbol{A}}{\partial \boldsymbol x} = \boldsymbol A, \qquad \frac{\partial \boldsymbol {x}^{\mathrm T} \boldsymbol{Ax}}{\partial \boldsymbol x} = (\boldsymbol{A} + \boldsymbol {A}^{\mathrm T}) \boldsymbol {x} \overset{若A为对称阵}{=}2\boldsymbol{Ax}</script><h5 id="3-1-2-复向量求导"><a href="#3-1-2-复向量求导" class="headerlink" title="3.1.2 复向量求导"></a>3.1.2 复向量求导</h5><p>复向量$\boldsymbol w \in \mathbb{C}^{N \times 1}$</p>
<script type="math/tex; mode=display">
\dfrac{\text{d} \boldsymbol w^T}{\text{d} \boldsymbol w} = \boldsymbol I_{N \times N}, \quad \dfrac{\text{d} \boldsymbol w^H}{\text{d} \boldsymbol w^*} = \dfrac{\text{d} (\boldsymbol w^*)^T}{\text{d} \boldsymbol w^*} = \boldsymbol I_{N \times N} , \quad \dfrac{\text{d} \boldsymbol w^H}{\text{d} \boldsymbol w} = \dfrac{\text{d} (\boldsymbol w^*)^T}{\text{d} \boldsymbol w} = \boldsymbol O_{N \times N}, \quad \dfrac{\text{d} \boldsymbol w^T}{\text{d} \boldsymbol w^*} = \boldsymbol O_{N \times N}</script><script type="math/tex; mode=display">
\dfrac{\partial \boldsymbol b^H \boldsymbol w}{\partial \boldsymbol w} = \left(\dfrac{\partial \boldsymbol w^H \boldsymbol b}{\partial \boldsymbol w^*}\right)^* = \boldsymbol b^* \quad \Longrightarrow \quad \dfrac{\partial \boldsymbol w^H \boldsymbol b}{\partial \boldsymbol w^*} = \boldsymbol b</script><script type="math/tex; mode=display">
\dfrac{\partial \boldsymbol b^H \boldsymbol w}{\partial \boldsymbol w^*} = \left(\dfrac{\partial \boldsymbol w^H \boldsymbol b}{\partial \boldsymbol w}\right)^* = \boldsymbol 0 \quad \Longrightarrow \quad \dfrac{\partial \boldsymbol w^H \boldsymbol b}{\partial \boldsymbol w} = \boldsymbol 0</script><script type="math/tex; mode=display">
\dfrac{\partial \boldsymbol w^H \boldsymbol R \boldsymbol w}{\partial \boldsymbol w} = \boldsymbol R^T \boldsymbol w^*, \quad \dfrac{\partial \boldsymbol w^H \boldsymbol R \boldsymbol w}{\partial \boldsymbol w^*} = \boldsymbol R \boldsymbol w, \quad \dfrac{\partial \boldsymbol w^H \boldsymbol R \boldsymbol w^*}{\partial \boldsymbol w^*} = (\boldsymbol R +\boldsymbol R^T ) \boldsymbol w</script><h4 id="3-2-矩阵迹的求导"><a href="#3-2-矩阵迹的求导" class="headerlink" title="3.2 矩阵迹的求导"></a>3.2 矩阵迹的求导</h4><script type="math/tex; mode=display">
\frac{\partial  \text{Tr}(\boldsymbol {AB})}{\partial \boldsymbol A} = \boldsymbol B^{\text{T}}, \quad \frac{\partial  \text{Tr}(\boldsymbol {AB})}{\partial \boldsymbol B} = \boldsymbol A^{\text{T}}, \quad \frac{\partial  \text{Tr}(\boldsymbol A^H \boldsymbol B)}{\partial \boldsymbol A} = \boldsymbol O_{M \times N}, \quad \frac{\partial  \text{Tr}(\boldsymbol {AB}^H)}{\partial \boldsymbol B} = \boldsymbol O_{N \times M}</script><script type="math/tex; mode=display">
\frac{\partial  \text{Tr}(\boldsymbol {AA}^H)}{\partial \boldsymbol A} = \boldsymbol A^*</script><script type="math/tex; mode=display">
\frac{\partial  \text{Tr}(\boldsymbol {ABB}^H \boldsymbol A^H)}{\partial \boldsymbol B} = (\boldsymbol A^{\text{H}}\boldsymbol A)^T \boldsymbol B^*</script><h4 id="3-3-矩阵行列式的求导"><a href="#3-3-矩阵行列式的求导" class="headerlink" title="3.3 矩阵行列式的求导"></a>3.3 矩阵行列式的求导</h4><p><img src="https://pic.imgdb.cn/item/6612500a68eb935713dc6eda.png" alt="9e3ff6571c61cb9bb0b978202a6e45ce_r.png"></p>
<h4 id="3-4-特殊的矩阵求导"><a href="#3-4-特殊的矩阵求导" class="headerlink" title="3.4 特殊的矩阵求导"></a>3.4 特殊的矩阵求导</h4><p>设矩阵$\boldsymbol A$的元素是$t$的函数$\boldsymbol A = [a_{ij}(t)]$，则关于$t$的导数为：</p>
<script type="math/tex; mode=display">
\frac{\mathrm{d}|\boldsymbol A|}{\mathrm{d t}}=|\boldsymbol {A} |\mathrm{Tr}\left(\boldsymbol {A}^{-1}\frac{\mathrm{d} \boldsymbol A}{\mathrm{d t}}\right)</script><p>其逆矩阵关于$t$的导数为：</p>
<script type="math/tex; mode=display">
\frac{\mathrm{d} \boldsymbol A^{-1}}{\mathrm{dt}} = -\boldsymbol {A}^{-1} \frac{\mathrm{d} \boldsymbol A}{\mathrm{d t}} \boldsymbol {A}^{-1}</script><h4 id="3-5-关于矩阵求导的相关资料链接"><a href="#3-5-关于矩阵求导的相关资料链接" class="headerlink" title="3.5 关于矩阵求导的相关资料链接"></a>3.5 关于矩阵求导的相关资料链接</h4><p>链接1：<a href="https://zhuanlan.zhihu.com/p/24709748">矩阵求导术：上篇 - 知乎</a>和<a href="https://zhuanlan.zhihu.com/p/24863977">下篇</a> —— 本文基本上是这两篇文章内容的重新整理<br>链接2：<a href="https://www.cnblogs.com/pinard/p/10750718.html">刘建平Pinard系列博客</a> —— 这个博客主要用于查缺补漏<br>链接3：<a href="https://wzbtech.com/tech/matrix-derivatives2.html">矩阵求导总结 - 个人博客</a><br>链接4：<a href="https://blog.csdn.net/DengTseng/article/details/111059204">矩阵行列式求导以及矩阵的逆的求导 - CSDN</a><br>链接5：<a href="https://blog.csdn.net/Lyn_S/article/details/110502548">复数 标量/向量/矩阵 求导_复数矩阵求导-CSDN博客</a><br>链接6：<a href="https://emrys365.github.io/post/xin-hao-chu-li-zhong-de-fu-shu-ju-zhen-qiu-dao-chu-tan/#%E5%A4%8D%E6%A2%AF%E5%BA%A6%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8">信号处理中的复数矩阵求导 - Speech 101的博客</a><br>链接7：<a href="https://www.zhihu.com/question/43657719/answer/96307949">复数矩阵求导的转置和共轭转置问题？（MMSE预编码器推导） - null的回答- 知乎</a></p>
<p>此外，若碰到实在无法理解的求导，也可应借助下面两个工具：</p>
<p>工具1：<a href="https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf">The Matrix Cookbook - 矩阵烹饪书 </a><br>工具2：<a href="https://www.matrixcalculus.org/">Matrix Calculus</a> —— 超级强大的在线矩阵求导工具</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>数学基础</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>矩阵运算</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数_Part2</title>
    <url>/2022/04/05/LinearAlgebra2/</url>
    <content><![CDATA[<h3 id="第十四讲-正交向量与正交子空间"><a href="#第十四讲-正交向量与正交子空间" class="headerlink" title="第十四讲 正交向量与正交子空间"></a>第十四讲 正交向量与正交子空间</h3><p><img src="https://pic.imgdb.cn/item/625423a7239250f7c5047658.jpg" style="zoom:70%"></p>
<h4 id="14-1-正交向量-Orthogonal-vectors"><a href="#14-1-正交向量-Orthogonal-vectors" class="headerlink" title="14.1 正交向量 Orthogonal vectors"></a>14.1 正交向量 Orthogonal vectors</h4><p><img src="https://pic.imgdb.cn/item/625423c4239250f7c504af7f.jpg"></p>
<p>正交就是垂直(perpendicular)的另一种说法。两向量正交的判据之一是其点积$\boldsymbol x^{\text T} \boldsymbol y = \boldsymbol y^{\text T} \boldsymbol x = 0$。当两个向量的夹角为90度时，按照毕达哥拉斯定理，$\boldsymbol {x,y}$ 满足：</p>
<script type="math/tex; mode=display">
||\boldsymbol x||^2 + ||\boldsymbol y||^2 = ||\boldsymbol{x+y }||^2,其中||\boldsymbol x||^2 = \boldsymbol x^{\text T} \boldsymbol x</script><p>例如<script type="math/tex">\boldsymbol  x=\left(\begin{array}{l} 1 \\ 2 \\ 3 \end{array}\right), \boldsymbol  y=\left(\begin{array}{l} 2 \\ -1 \\ 0 \end{array}\right)</script>，则<script type="math/tex">\boldsymbol  {x+y}=\left(\begin{array}{l} 3 \\ 1 \\ 3 \end{array}\right), ||\boldsymbol x||^2=14,  ||\boldsymbol y||^2=5, ||\boldsymbol{x+y }||^2 = 19</script>。</p>
<p>将勾股定理展开进行计算，则有</p>
<script type="math/tex; mode=display">
\boldsymbol x^{\text T} \boldsymbol x + \boldsymbol y^{\text T} \boldsymbol y = (\boldsymbol x + \boldsymbol y)^{\text T} (\boldsymbol x + \boldsymbol y) = \boldsymbol x^{\text T} \boldsymbol x + \boldsymbol y^{\text T} \boldsymbol y +\boldsymbol x^{\text T} \boldsymbol y + \boldsymbol y^{\text T} \boldsymbol x</script><p>得到$\boldsymbol x^{\text T} \boldsymbol y =0$。</p>
<p>零向量与所有向量都正交。 </p>
<h4 id="14-2-正交子空间-Orthogonal-subspaces"><a href="#14-2-正交子空间-Orthogonal-subspaces" class="headerlink" title="14.2 正交子空间 Orthogonal subspaces"></a>14.2 正交子空间 Orthogonal subspaces</h4><p>子空间$\boldsymbol S$与子空间$\boldsymbol T$正交，则$\boldsymbol S$中的任意一个向量都和$\boldsymbol T$中的任意向量正交。黑板所在的平面和地板所在平面不是正交关系，沿两者的交线方向的向量同时属于两个平面，但并不与自己正交。<font color="green"><strong>所以如果两个平面的交点（交线）如果不是零向量，则它们就不是正交的。</strong></font></p>
<p>如果在平面内(二维空间)讨论正交子空间，平面的子空间包括只包含零向量的0空间、过原点的直线以及整个平面。经过原点的直线不会和整个空间正交(二维空间限制下过原点的直线在平面内，不要想成3维空间了)；0空间和过原点的直线正交(<strong>0空间与任意空间正交</strong>)；经过原点的两条直线若夹角为直角则互相正交。</p>
<h4 id="14-3-零空间与行空间正交-Nullspace-is-perpendicular-to-row-space"><a href="#14-3-零空间与行空间正交-Nullspace-is-perpendicular-to-row-space" class="headerlink" title="14.3 零空间与行空间正交 Nullspace is perpendicular to row space"></a>14.3 零空间与行空间正交 Nullspace is perpendicular to row space</h4><p>矩阵$\boldsymbol  A$的行空间和它的零空间正交。若在零空间内，则有$\boldsymbol {Ax} = \boldsymbol 0$，将$\boldsymbol A$表示为行向量的格式：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
\operatorname{row}_{1} \\
\operatorname{row}_{2} \\
\vdots \\
\text { row }_{m}
\end{array}\right][\boldsymbol x]=\left[\begin{array}{c}
\operatorname{row}_{1} \cdot \boldsymbol x \\
\operatorname{row}_{2} \cdot\boldsymbol  x \\
\vdots \\
\operatorname{row}_{m} \cdot \boldsymbol x
\end{array}\right]=\left[\begin{array}{c}
0 \\
0 \\
\vdots \\
0
\end{array}\right]</script><p>$\boldsymbol x$与矩阵$\boldsymbol A$的行向量点积都等于0，则它和矩阵$\boldsymbol A$行向量的线性组合进行点积也为 0，所以$\boldsymbol x$与矩阵$\boldsymbol A$的行空间正交。$\boldsymbol x$为零空间内的任意向量，所以零空间与行空间正交。（一vs多-&gt;多vs多）</p>
<p>同理可以证明列空间与左零空间正交。</p>
<p>行空间和零空间实际上把$R^n$空间分割成了两个正交的子空间。例如对于矩阵：</p>
<script type="math/tex; mode=display">
A=\left[\begin{array}{lll}
1 & 2 & 5 \\
2 & 4 & 10
\end{array}\right]</script><p>则其行空间是1维的，向量<script type="math/tex">\left(\begin{array}{l} 1 \\ 2 \\ 5 \end{array}\right)</script> 是它的基向量，而其零空间是垂直于<script type="math/tex">\left(\begin{array}{l} 1 \\ 2 \\ 5 \end{array}\right)</script> 并穿过原点的2维平面。其中零空间的法向量为<script type="math/tex">\left(\begin{array}{l} 1 \\ 2 \\ 5 \end{array}\right)</script>。</p>
<h4 id="14-4-正交补Orthogonal-Complements"><a href="#14-4-正交补Orthogonal-Complements" class="headerlink" title="14.4 正交补Orthogonal Complements"></a>14.4 正交补Orthogonal Complements</h4><p>行空间和零空间不仅仅是正交，并且其维数之和等于$n$，我们称行空间和零空间为$R^n$空间内的<font color="red"><strong>正交补(orthogonal complements)</strong></font>。</p>
<script type="math/tex; mode=display">
\dim N(\boldsymbol A) + \dim C(\boldsymbol A^{\text T}) = n</script><p>正交补的概念很重要，它表明$R^n$中的任何一个向量$\boldsymbol x$都可以<font color="blue">拆分为互为正交补的子空间的向量之和</font>。以$\boldsymbol {Ax = b}$的解$\boldsymbol x$为例，$\boldsymbol x$是$R^n$中的向量，$\boldsymbol x$可以拆分为在行空间的分量$\boldsymbol x_r$和零空间中的分量$\boldsymbol x_n$，即$\boldsymbol x = \boldsymbol x_r + \boldsymbol x_n$，$\boldsymbol {Ax=b}$可以进行如下拆解</p>
<script type="math/tex; mode=display">
零空间分量：\boldsymbol {Ax}_n = \boldsymbol 0 \\
行空间分量：\boldsymbol {Ax}_r = \boldsymbol b</script><p>这表示零空间包含所有和行空间正交的向量，反之亦然。 想想我们之前提到的黑板和地板平面不是正交子空间的例子，二者都在 3 维空间中，分别为 2 维空间，因此不可能正交。<font color="red">一个空间中正交子空间的维数之和不可能超过原空间的维数</font>。</p>
<p><strong>我们可以称目前讨论的这部分内容是线性代数基本定理的第二部分。第一部分是给出四个子空间和它们的维数，第二部分说明它们是两两互为正交补，第三部分讨论子空间的正交基。 这些内容都反映在了本讲座开始的那幅图上。</strong></p>
<h4 id="14-5-矩阵-boldsymbol-A-text-T-boldsymbol-A"><a href="#14-5-矩阵-boldsymbol-A-text-T-boldsymbol-A" class="headerlink" title="14.5 矩阵$\boldsymbol A^{\text T} \boldsymbol A$"></a>14.5 矩阵$\boldsymbol A^{\text T} \boldsymbol A$</h4><p>下面讨论如何求解一个<strong>无解</strong>方程组$\boldsymbol {Ax} = \boldsymbol b$的解($\boldsymbol b$不在$\boldsymbol A$的列空间中)。如果$\boldsymbol A$是长方形矩阵，$m$大于$n$(方程数大于未知数)。当左侧方程数特别多的时候，容易混入“坏”数据，方程变得无解。但是对于数据的可信度我们无从判断，线性代数要做的就是在这种条件下求一个方程的“最优解”（把好数据筛选出来）。其中一种求解方法是删掉一些方程，使得矩阵变成可逆的方阵，然后进行求解。但是由于无法判断哪些数据是好数据，哪些是坏数据。希望利用所有测量值求出最优解，从而得到最完整的信息。</p>
<p>矩阵$\boldsymbol A^{\text T} \boldsymbol A$会发挥重要作用，它是一个$n \times n$方阵，并且是对称阵，$(\boldsymbol A^{\text T} \boldsymbol A)^{\text T} = \boldsymbol A^{\text T} \boldsymbol A$。本章的核心内容就是当$\boldsymbol {Ax} = \boldsymbol b$无解的时候，求解$\boldsymbol A^{\text T}\boldsymbol A \hat {\boldsymbol x}= \boldsymbol A^{\text T} \boldsymbol b$得到<strong>最优解</strong>。<br><img src="https://pic.imgdb.cn/item/6254d8cd239250f7c5e5984d.jpg"></p>
<p>实际上$N(\boldsymbol A^{\text T} \boldsymbol A) = N(\boldsymbol A)$，并且矩阵$\boldsymbol A^{\text T} \boldsymbol A$的秩等于$\boldsymbol A$的秩。因此矩阵$\boldsymbol A^{\text T} \boldsymbol A$可逆要求$\boldsymbol A$的零空间只有零向量，即$\boldsymbol A$的列向量线性无关(或者说$\boldsymbol A$列满秩)。</p>
<h3 id="第十五讲-子空间投影"><a href="#第十五讲-子空间投影" class="headerlink" title="第十五讲 子空间投影"></a>第十五讲 子空间投影</h3><h4 id="15-1-投影-射影-Projections"><a href="#15-1-投影-射影-Projections" class="headerlink" title="15.1 投影(射影)Projections"></a>15.1 投影(射影)Projections</h4><p>简单来说，两个向量之间的投影是将其中一个向量转换到另外一个向量的方向上，然后求内积。 </p>
<p><img src="https://pic.imgdb.cn/item/6254ea45239250f7c5fe5d00.jpg" style="zoom:70%"></p>
<p><strong>投影问题的几何解释就是：如何在向量$\boldsymbol a$的方向上寻找与向量$\boldsymbol b$距离最近的一点</strong>。从图中可以看出，这个距离最近的点$\boldsymbol p$就位于穿过$\boldsymbol b$点并与向量$\boldsymbol a$正交的直线与向量$\boldsymbol a$所在直线的交点上。这就是$\boldsymbol b$在$\boldsymbol a$上的投影。如果我们将向量$\boldsymbol p$视为$\boldsymbol b$的一种近似，则长度$\boldsymbol {e = b-p}$就是这一近似的误差。</p>
<p>因为在向量$\boldsymbol a$的方向上，因此可以令$\boldsymbol p = x \boldsymbol a$，而因为它和$\boldsymbol e$正交，我们可以得到方程：$\boldsymbol a^{\text T}(\boldsymbol b - x \boldsymbol a) = 0$。（该结果是把$\boldsymbol p$与$\boldsymbol e$正交转换成了$\boldsymbol a$与$\boldsymbol e$正交，本质上只是两边同除了个数）。</p>
<p>解得： $x = \dfrac{\boldsymbol a^{\text T} \boldsymbol b}{\boldsymbol a^{\text T} \boldsymbol a}$，$\boldsymbol p = x \boldsymbol a = \boldsymbol a x = \boldsymbol a \dfrac{\boldsymbol a^{\text T} \boldsymbol b}{\boldsymbol a^{\text T} \boldsymbol a}$</p>
<p>如果$\boldsymbol b$变为原来的2倍，则$\boldsymbol  p$也变为原来的2倍。 而如果$\boldsymbol  a$变为原来的2倍，$\boldsymbol p$不发生变化。从几何上和计算中都会得到验证。</p>
<h4 id="15-2-投影矩阵"><a href="#15-2-投影矩阵" class="headerlink" title="15.2 投影矩阵"></a>15.2 投影矩阵</h4><p>我们将投影问题用投影矩阵的方式进行描述，即为$\boldsymbol p = \boldsymbol {Pb}$，其中$\boldsymbol P$为投影矩阵。</p>
<p>Q：为什么是$\boldsymbol p = \boldsymbol {Pb}$，而不是$\boldsymbol p = \boldsymbol {bP}$呢？   </p>
<p>A：一来是由于上述的推导，二来可以通过反证法，$\boldsymbol p = \boldsymbol {Pb}$很显然的是$\boldsymbol p$的维度和$\boldsymbol b$的是一致的（维度相同的列向量）。而反之不成立。 </p>
<p>$\boldsymbol p = \boldsymbol a x = \boldsymbol a \dfrac{\boldsymbol a^{\text T} \boldsymbol b}{\boldsymbol a^{\text T} \boldsymbol a}$，则有$\boldsymbol P = \dfrac{\boldsymbol a \boldsymbol a^{\text T} }{\boldsymbol a^{\text T} \boldsymbol a}$，其分子$\boldsymbol a  \boldsymbol a^{\text T}$ 是一个矩阵，而分母是一个数。</p>
<p>观察这个矩阵可知，矩阵$\boldsymbol P$的列空间就是向量$\boldsymbol a$所在的直线，矩阵的秩是1。投影矩阵$\boldsymbol P$是一个对称矩阵。另一方面，如果做两次投影则有第二次投影还在原来的位置。因此矩阵$\boldsymbol P$有如下性质：</p>
<ul>
<li>$\boldsymbol P^{\text T} = \boldsymbol P$</li>
<li>$\boldsymbol P^2 = \boldsymbol P$</li>
</ul>
<h4 id="15-3-为什么要投影-Why-Project"><a href="#15-3-为什么要投影-Why-Project" class="headerlink" title="15.3 为什么要投影 Why Project"></a>15.3 为什么要投影 Why Project</h4><p>如前所述，方程$\boldsymbol {Ax} = \boldsymbol b$有可能无解，我们需要得到方程的“最优解”。这里的题在于向量$\boldsymbol {Ax}$一定在矩阵$\boldsymbol b$的列空间之内，但是$\boldsymbol b$不一定，因此我们希望将$\boldsymbol b$投影到$\boldsymbol A$的列空间得到$\boldsymbol p$，将问题转化为求解$\boldsymbol {A \hat x} = \boldsymbol p$。</p>
<h4 id="15-4-在高维投影-Projection-in-higher-dimensions"><a href="#15-4-在高维投影-Projection-in-higher-dimensions" class="headerlink" title="15.4 在高维投影 Projection in higher dimensions"></a>15.4 在高维投影 Projection in higher dimensions</h4><p>在$R^3$空间内，如何将向量$\boldsymbol b$投影到它距离平面最近的一点$\boldsymbol p$？<br><img src="https://pic.imgdb.cn/item/6257cb08239250f7c5c15905.jpg"></p>
<p>如果$\boldsymbol a_1$和$\boldsymbol a_2$构成了平面的一组基，则平面就是矩阵$\boldsymbol A = [\boldsymbol a_1; \boldsymbol a_2]$的列空间。</p>
<p>已知向量$\boldsymbol p$在平面内，则有$\boldsymbol p = \hat x_1 \boldsymbol a_1 + \hat x_2 \boldsymbol a_2 = \boldsymbol {A \hat x}$。$\boldsymbol e = \boldsymbol{b-p}$与投影平面正交（<strong>重点</strong>），因此 $\boldsymbol e$与$\boldsymbol {a_1,a_2}$均正交，因此可以得到： $\boldsymbol a_1^{\text T}(\boldsymbol b - \boldsymbol {A \hat x})=0$并且$\boldsymbol a_2^{\text T}(\boldsymbol b - \boldsymbol {A \hat x})=0$。因为$\boldsymbol a_1$和$\boldsymbol a_2$分别为矩阵$\boldsymbol A$的列向量，即$\boldsymbol a_1^{\text T}$和$\boldsymbol a_2^{\text T}$分别为矩阵$\boldsymbol A^{\text T}$的行向量，所以将两个方程式写成矩阵形式即为 $\boldsymbol A^{\text T }(\boldsymbol b-\boldsymbol {A \hat x}) = \boldsymbol 0$。这与一维投影的方程形式相同。 </p>
<p>向量 $\boldsymbol e = \boldsymbol b - \boldsymbol {A \hat x}$存在于矩阵 $\boldsymbol A^{\text T}$的零空间$N(\boldsymbol A^{\text T})$里，从上一讲讨论子空间的正交性可知，向量$\boldsymbol e$与矩阵$\boldsymbol A$的列空间正交，这也正是方程的意义。</p>
<p>将方程$\boldsymbol A^{\text T}(\boldsymbol b - \boldsymbol{A \hat x})= \boldsymbol 0$改写，可得$\boldsymbol A^{\text T} \boldsymbol{A \hat x} = \boldsymbol A^{\text T} \boldsymbol b$</p>
<script type="math/tex; mode=display">
\begin{gathered}
\hat{\boldsymbol x}=\left(\boldsymbol A^{\text T} \boldsymbol A\right)^{-1} \boldsymbol A^{\text T} \boldsymbol b \\
\boldsymbol p=\boldsymbol A \hat{\boldsymbol x}=\boldsymbol A\left(\boldsymbol A^{\text T} \boldsymbol A\right)^{-1} \boldsymbol A^{\text T} \boldsymbol b \\
\boldsymbol P=\boldsymbol A\left( \boldsymbol A^{\text T}  \boldsymbol A\right)^{-1} \boldsymbol A^{\text T}
\end{gathered}</script><blockquote>
<p>注意：这里由于考虑矩阵$\boldsymbol A$是列满秩的，因此$\boldsymbol A^{\text T} \boldsymbol A$一定是方阵可逆。</p>
</blockquote>
<p>因为矩阵$\boldsymbol A$不是方阵，无法简单的用$\left(\boldsymbol A^{\text T} \boldsymbol A\right)^{-1}=\boldsymbol A^{-1}\left(\boldsymbol A^{\text T}\right)^{-1}$对投影矩阵公式进行化简。若$\boldsymbol A$是可逆方阵，则化简得到$\boldsymbol{P = I}$。此时$\boldsymbol A$的列空间就是整个$R^n$ 空间，$\boldsymbol b$到这个空间的投影就是其本身，投影矩阵等于单位阵。</p>
<p>对$\boldsymbol P=\boldsymbol A\left( \boldsymbol A^{\text T}  \boldsymbol A\right)^{-1} \boldsymbol A^{\text T}$用矩阵乘法的结合律和矩阵乘积的转置公式，可以证明投影矩阵的性质： </p>
<ul>
<li>$\boldsymbol P^{\text T} = \boldsymbol P$</li>
<li>$\boldsymbol P^2 = \boldsymbol P$</li>
</ul>
<h4 id="15-5-最小二乘法"><a href="#15-5-最小二乘法" class="headerlink" title="15.5 最小二乘法"></a>15.5 最小二乘法</h4><p><img src="https://pic.imgdb.cn/item/6257d401239250f7c5cf756d.jpg"></p>
<p>应用投影矩阵求方程组最优解的方法，最常用于“最小二乘法”拟合曲线。 </p>
<p>有三个数据点$(1,1), (2,2), (3,2)$，求直线方程$b = C + Dt $，要求直线尽量接近于三个点。把三个点的数据代入方程则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&C+D=1 \\
&C+2 D=2 \\
&C+3 D=2
\end{aligned}</script><p>矩阵形式为</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
1 & 1 \\
1 & 2 \\
1 & 3
\end{array}\right]\left[\begin{array}{l}
C \\
D
\end{array}\right]=\left[\begin{array}{l}
1 \\
2 \\
2
\end{array}\right]</script><p>这个的方程$\boldsymbol {Ax=b}$是无解的，解决办法就是求其最优解，即方程$\boldsymbol A^{\text T} \boldsymbol {Ax=A^{\text T}b}$的解。</p>
<h3 id="第十六讲-投影矩阵和最小二乘法"><a href="#第十六讲-投影矩阵和最小二乘法" class="headerlink" title="第十六讲 投影矩阵和最小二乘法"></a>第十六讲 投影矩阵和最小二乘法</h3><h4 id="16-1-投影-射影-Projections"><a href="#16-1-投影-射影-Projections" class="headerlink" title="16.1 投影(射影)Projections"></a>16.1 投影(射影)Projections</h4><p>上一讲介绍了投影矩阵$\boldsymbol P = \boldsymbol{A(A^{\text T}A)^{-1}A^{\text T}}$，当它作用于向量$\boldsymbol b$，相当于把$\boldsymbol b$投影到矩阵$\boldsymbol A$的列空间中。其中$\boldsymbol p = \boldsymbol{Pb}$，$\boldsymbol p$为投影后的向量。</p>
<p>如果向量$\boldsymbol b$本身就在$\boldsymbol A$列空间之内，即存在$\boldsymbol x$使得$\boldsymbol {Ax = b}$，则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{P} \boldsymbol{b} &=\boldsymbol{A}\left(\boldsymbol{A}^{\mathrm{T}} \boldsymbol{A}\right)^{-1} \boldsymbol{A}^{\mathrm{T}} \boldsymbol{b}(\text { 将 } \boldsymbol{A} \boldsymbol{x}=\boldsymbol{b} \text { 代入 }) \\
&=\boldsymbol{A}\left(\boldsymbol{A}^{\mathrm{T}} \boldsymbol{A}\right)^{-1} \boldsymbol{A}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{x} \\
&=\boldsymbol{A}\left(\left(\boldsymbol{A}^{\mathrm{T}} \boldsymbol{A}\right)^{-1}\left(\boldsymbol{A}^{\mathrm{T}} \boldsymbol{A}\right)\right) \boldsymbol{x} \\
&=\boldsymbol{A} \boldsymbol{x}
\end{aligned}</script><p>如果向量$\boldsymbol b$与$\boldsymbol A$的列空间正交，即向量$\boldsymbol b$在矩阵$\boldsymbol A$的左零空间$N(\boldsymbol A^{\text T})$中，则有</p>
<script type="math/tex; mode=display">
\boldsymbol {Pb}=\boldsymbol{A}\left(\boldsymbol{A}^{\mathrm{T}} \boldsymbol{A}\right)^{-1} \boldsymbol{A}^{\mathrm{T}} \boldsymbol{b} = \boldsymbol{A}\left(\boldsymbol{A}^{\mathrm{T}} \boldsymbol{A}\right)^{-1} (\boldsymbol{A}^{\mathrm{T}} \boldsymbol{b}) = \boldsymbol{A}\left(\boldsymbol{A}^{\mathrm{T}} \boldsymbol{A}\right)^{-1} \boldsymbol 0 = \boldsymbol 0</script><p>向量之间的关系图如下： </p>
<p><img src="https://pic.imgdb.cn/item/62593a42239250f7c5c2f83d.jpg"></p>
<p>从图我们可以总结出：</p>
<ul>
<li>$\boldsymbol {p+e=b}$，说明$\boldsymbol b$由两部分组成；</li>
<li>$\boldsymbol {p=Pb}$为$\boldsymbol {A}$的列空间的部分；</li>
<li>$\boldsymbol {e=(I-P)b}$为$\boldsymbol {A}$的左零空间中的部分；</li>
<li>$\boldsymbol{I-P}$为左零空间的投影矩阵，可以验证$\boldsymbol{(I-P)}^{\mathrm T} = (\boldsymbol {I-P})$，并且$\boldsymbol {(I-P)}^2 = (\boldsymbol {I-P})$。</li>
</ul>
<h4 id="16-2-最小二乘法-Least-Squares"><a href="#16-2-最小二乘法-Least-Squares" class="headerlink" title="16.2 最小二乘法 Least Squares"></a>16.2 最小二乘法 Least Squares</h4><p>应用投影矩阵求方程组最优解的方法，最常用于“最小二乘法”拟合曲线。 </p>
<p><img src="https://pic.imgdb.cn/item/62593c43239250f7c5c64e48.jpg" style="zoom:80%"></p>
<p>有三个数据点$(1,1), (2,2), (3,2)$，求直线方程$b = C + Dt $，要求直线尽量接近于三个点。把三个点的数据代入方程则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&C+D=1 \\
&C+2 D=2 \\
&C+3 D=2
\end{aligned}</script><p>矩阵形式为</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
1 & 1 \\
1 & 2 \\
1 & 3
\end{array}\right]\left[\begin{array}{l}
C \\
D
\end{array}\right]=\left[\begin{array}{l}
1 \\
2 \\
2
\end{array}\right]</script><p>这个的方程$\boldsymbol {Ax=b}$是无解的，解决办法就是求其最优解，即误差最小，这里误差是指每个方程误差值的平方和$||\boldsymbol e||^2 = ||\boldsymbol {Ax-b}||^2$（误差平方相加），因此就是寻找具有最小误差平方和的解$\boldsymbol x$，这就是所谓的“最小二乘”问题。其中最接近的解为将$\boldsymbol b$投影到$\boldsymbol A$矩阵的系数$\boldsymbol x$。</p>
<script type="math/tex; mode=display">
\min \|\boldsymbol{A x-b}\|^{2}=\|\boldsymbol e\|^{2}=\left\|e_{1}\right\|^{2}+\left\|e_{2}\right\|^{2}+\left\|e_{3}\right\|^{2}</script><p>误差即为数据点到直线距离的平方和。这部分工作可称为线性回归，在数据点中没有“<strong>离群值</strong>” 时，这是非常有用的方法。 </p>
<p><img src="https://pic.imgdb.cn/item/62593d85239250f7c5c871e3.jpg"></p>
<p>从几何上讨论求解过程，就是试图寻找数据点到直线距离的平方和$e_1^2+e_2^2+e_3^2$最小的情况，此时得到的$C+Dt $分别为$p_1,p_2,p_3$ ，它们是满足方程并最接近于$\boldsymbol b$的结果。另一种看法是，对于$R^3$空间上的向量$\boldsymbol b$，它投影到矩阵$\boldsymbol A$的列空间中会得到向量$\boldsymbol p = [p_1,p_2,p_3]^{\mathrm T}$，投影到矩阵$\boldsymbol A$的零空间中则为$\boldsymbol e$。</p>
<p>现在求解$\hat {\boldsymbol x} =  \left(\begin{array}{l} \hat C \\ \hat D \end{array}\right)$和$\boldsymbol p$。</p>
<p>老师称为统计上最重要的方程式： </p>
<script type="math/tex; mode=display">
\boldsymbol {A^{\mathrm T}A \hat x} = \boldsymbol {A^{\mathrm T} b}</script><script type="math/tex; mode=display">
\left[\begin{array}{lll}
1 & 1 & 1 \\
1 & 2 & 3
\end{array}\right]\left[\begin{array}{ll:l}
1 & 1 & 1 \\
1 & 2 & 2 \\
1 & 3 & 2
\end{array}\right]=\left[\begin{array}{rr:r}
3 & 6 & 5 \\
6 & 14 & 11
\end{array}\right] \text {,则有 }\left[\begin{array}{cc}
3 & 6 \\
6 & 14
\end{array}\right]\left[\begin{array}{l}
\hat{C} \\
\hat{D}
\end{array}\right]=\left[\begin{array}{c}
5 \\
11
\end{array}\right]</script><p>得到解为$\hat C = \dfrac{2}{3}, \hat D = \dfrac{1}{2}$。</p>
<p>还可以从误差最小的角度出发求解： </p>
<script type="math/tex; mode=display">
e_{1}^{2}+e_{2}^{2}+e_{3}^{2}=(C+D-1)^{2}+(C+2 D-2)^{2}+(C+3 D-2)^{2}</script><p>对等号右边的表达式求偏导数，极值出现在偏导数为0的位置。<font color="red"><strong>求偏导最终会得到相同的线性方程组和相同的解</strong></font>。展开结果为</p>
<script type="math/tex; mode=display">
\|e\|^{2}=3 C^{2}+14 D^{2}+9-10 C-22 D+12 C D</script><p>求偏导可得到和$\boldsymbol {A^{\mathrm T}A \hat x} = \boldsymbol {A^{\mathrm T} b}$的结果相同。</p>
<p>得到直线表达式$y=2/3+t/2$。将$t=1、2、3$分别代入可得：</p>
<script type="math/tex; mode=display">
\boldsymbol{p}=\left(\begin{array}{c}
\dfrac{7}{6} \\
\dfrac{5}{3} \\
\dfrac{13}{6}
\end{array}\right), \boldsymbol{e}=\left(\begin{array}{c}
-\dfrac{1}{6} \\
\dfrac{1}{3} \\
-\dfrac{1}{6}
\end{array}\right)</script><p>投影向量$\boldsymbol p$与误差向量$\boldsymbol e$是正交的：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
\boldsymbol {A^{T} A \hat{x}=A^{T} b \\
p=A \hat{x}}
\end{array}\right.</script><h4 id="16-3-矩阵-boldsymbol-A-mathrm-T-A"><a href="#16-3-矩阵-boldsymbol-A-mathrm-T-A" class="headerlink" title="16.3 矩阵$\boldsymbol {A^{\mathrm T}A}$"></a>16.3 矩阵$\boldsymbol {A^{\mathrm T}A}$</h4><p>证明：若$\boldsymbol A$的列向量线性无关时，矩阵$\boldsymbol {A^{\mathrm T}A}$为可逆矩阵。$\boldsymbol A$的各列线性无关，是最小二乘法成立的前提。</p>
<p>假设存在$\boldsymbol x$使得$\boldsymbol {A^{\mathrm T}Ax = 0}$。则有$\boldsymbol {x^{\mathrm T}A^{\mathrm T}Ax = 0}$(两边同乘以$\boldsymbol x^{\mathrm T}$)，则有</p>
<script type="math/tex; mode=display">
\boldsymbol {x^{\mathrm T}A^{\mathrm T}Ax = (Ax)^{\text T}(Ax)=0}</script><p>因此$\boldsymbol {Ax = 0}$，因为$\boldsymbol A$的列向量线性无关，所以只有当$\boldsymbol {x = 0}$时有$\boldsymbol{Ax = 0}$，因此只有当$\boldsymbol {x = 0}$时有$\boldsymbol {A^{\mathrm T}Ax = 0}$。即矩阵$\boldsymbol {A^{\mathrm T}A = 0}$为可逆矩阵。</p>
<p>如果矩阵的列向量是互相垂直的单位向量，则它们一定是线性无关的。我们将这种向量称之为标准正交组（orthonormal）。 </p>
<script type="math/tex; mode=display">
\text { 例如 : }\left[\begin{array}{l}
1 \\
0 \\
0
\end{array}\right],\left[\begin{array}{l}
0 \\
1 \\
0
\end{array}\right],\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right] \text { ;  还有 }\left[\begin{array}{c}
\cos \theta \\
\sin \theta
\end{array}\right] \text { 和 }\left[\begin{array}{c}
\cos \theta \\
\sin \theta
\end{array}\right]</script><blockquote>
<p>本小节我还有一个问题就是最小二乘法中误差$\boldsymbol e$为什么不是做垂直线而是竖直线，不是很明白。【MIT线性代数—-投影矩阵和最小二乘 - August的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/45351889">https://zhuanlan.zhihu.com/p/45351889</a> 】【线性代数视角下的最小二乘法 - 孙孙的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/62694878">https://zhuanlan.zhihu.com/p/62694878</a> 】这两篇文章有评论里面有一个解释，可以好好理解一下。</p>
</blockquote>
<h3 id="第十七讲-正交矩阵和施密特正交化"><a href="#第十七讲-正交矩阵和施密特正交化" class="headerlink" title="第十七讲 正交矩阵和施密特正交化"></a>第十七讲 正交矩阵和施密特正交化</h3><p>本节是“正交”部分的最后内容。Gram-Schmidt 过程可以将原空间的一组基转变为标准正交基。 </p>
<h4 id="17-1-标准正交向量-Orthonormal-vectors"><a href="#17-1-标准正交向量-Orthonormal-vectors" class="headerlink" title="17.1 标准正交向量 Orthonormal vectors"></a>17.1 标准正交向量 Orthonormal vectors</h4><p>满足如下条件的向量$\boldsymbol{q_1, q_2, \dots, q_n}$为标准正交向量：</p>
<script type="math/tex; mode=display">
\boldsymbol{q_{i}^{T} q_{j}}=\left\{\begin{array}{l}
0, i \neq j \\
1, i=j
\end{array}\right.</script><p>换而言之，它们都具有单位长度 1，并且彼此正交。标准正交向量是线性无关的。很多线性代数的计算都建立在标准正交基础上，它让一切变得简单可控(从来不上溢或者下溢)。 </p>
<h4 id="17-2-标准正交矩阵-Orthonormal-matrix"><a href="#17-2-标准正交矩阵-Orthonormal-matrix" class="headerlink" title="17.2 标准正交矩阵 Orthonormal matrix"></a>17.2 标准正交矩阵 Orthonormal matrix</h4><p>如果矩阵$\boldsymbol Q$的列向量为标准正交向量，则$\boldsymbol{Q^{\mathrm T} Q = I}$为单位阵。</p>
<p><img src="https://pic.imgdb.cn/item/6269dc7b239250f7c52e5f8e.jpg" style="zoom:70%"></p>
<p>注意这里的矩阵$\boldsymbol Q$可以不是方阵。我们已经学过了一系列矩阵，包括三角阵、对角阵、置换矩阵、对称矩阵、行最简梯形矩阵、投影矩阵等等，现在有了“标准正交”矩阵。</p>
<p>一个<strong>标准正交的方阵</strong>称之为“正交矩阵”（orthogonal matrix）。如果$\boldsymbol Q$为方阵，因为$\boldsymbol{Q^{\mathrm T} Q = I}$，所以$\boldsymbol{Q^{\mathrm T} = Q^{-1}}$ 。 注意必须是方阵，必须是标准正交，而不只是正交。</p>
<p>例如，置换矩阵 <script type="math/tex">\boldsymbol Q=\left[\begin{array}{lll} 0 & 0 & 1 \\ 1 & 0 & 0 \\ 0 & 1 & 0\end{array}\right]</script>，则有<script type="math/tex">\boldsymbol Q^T=\left[\begin{array}{lll} 0 & 1 & 0 \\ 0 & 0 & 1 \\ 1 & 0 & 0\end{array}\right]</script>，两者皆为正交矩阵，并且两者乘积为单位阵。 </p>
<p>例如， <script type="math/tex">\boldsymbol Q=\left[\begin{array}{lll} \cos x & -\sin x  \\ \sin x & \cos x \end{array}\right]</script>为正交矩阵。 </p>
<p>例如， <script type="math/tex">\boldsymbol Q=\dfrac{1}{2}\left[\begin{array}{cccc} 1 & 1 & 1 & 1 \\ 1 & -1 & 1 & -1 \\ 1 & 1 & -1 & -1 \\ 1 & -1 & -1 & 1\end{array}\right]</script>是由-1 和+1 组成的正交矩阵，这种类型的矩阵称之为阿达玛Hadamard矩阵，不同阶数矩阵性质不同并且没有规律，无从判断几阶的阿达玛矩阵为正交阵。</p>
<h4 id="17-3-标准正交列向量的优势-Orthonormal-columns-are-good"><a href="#17-3-标准正交列向量的优势-Orthonormal-columns-are-good" class="headerlink" title="17.3 标准正交列向量的优势 Orthonormal columns are good"></a>17.3 标准正交列向量的优势 Orthonormal columns are good</h4><p>若$\boldsymbol Q$的列向量为标准正交向量，且我们已知投影到$\boldsymbol Q$的列空间的投影矩阵为：</p>
<script type="math/tex; mode=display">
\boldsymbol {P = Q(Q^{\mathrm T}Q)^{-1}Q^{\mathrm T}}</script><p>证明过程略，可以参考笔记。此时根据$\boldsymbol{Q^{\mathrm T} Q = I}$可得：$\boldsymbol{P = QQ^{\mathrm T}}$，这会降低很多运算量。 </p>
<p>更特殊一点，若$\boldsymbol Q$为方阵，则$\boldsymbol {P=I}$，因为$\boldsymbol Q$的列向量线性无关，$\boldsymbol Q$的列向量张成了整个空间，投影过程不会对向量有任何改变。当$\boldsymbol Q$为方阵时，$\boldsymbol {Q^{-1} = Q^{\mathrm T}}$ 。</p>
<p>投影矩阵的性质为：投影矩阵为对称矩阵$\boldsymbol {P^{\mathrm T} = P}$；如果投影两次，还会在原有的位置$\boldsymbol {P^{2} = P}$，代入即为$\boldsymbol {(QQ^{\mathrm T})(QQ^{\mathrm T}) = (QQ^{\mathrm T})}$。这是由于$\boldsymbol{Q^{\mathrm T} Q = I}$。</p>
<p>在很多复杂问题中使用标准正交向量之后都变得简单。如果基为标准正交，则方程</p>
<script type="math/tex; mode=display">
\boldsymbol{A^{\mathrm T}A \hat x = A^{\mathrm T}b} {\longrightarrow} \boldsymbol{Q^{\mathrm T}Q \hat x = Q^{\mathrm T}b}</script><p>的解变为$\boldsymbol {\hat x = Q^{\mathrm T}b}$，$\boldsymbol {\hat x}$的分量$\hat x_i = \boldsymbol {q^{\mathrm T}_i b}$</p>
<h4 id="17-4-施密特正交化-Gram-Schmidt-A-gt-Q"><a href="#17-4-施密特正交化-Gram-Schmidt-A-gt-Q" class="headerlink" title="17.4 施密特正交化 Gram-Schmidt(A-&gt;Q)"></a>17.4 施密特正交化 Gram-Schmidt(A-&gt;Q)</h4><p>从两个线性无关的向量$\boldsymbol a$和$\boldsymbol b$开始，它们张成了一个空间，我们的目标是希望找到两个标准正交的向量$\boldsymbol {q_1, q_2}$能张成同样的空间。Schmidt 给出的结论是如果我们有一组正交基$\boldsymbol A$和$\boldsymbol B$，那么令它们除以自己的长度就得到标准正交基：</p>
<script type="math/tex; mode=display">
\boldsymbol{q_{1}=\frac{A}{\|A\|}, q_{2}=\frac{B}{\|B\|}}</script><p>Gram做了重要的工作，令$\boldsymbol {A = a}$，在向量$\boldsymbol a$和$\boldsymbol b$张成的空间中，取与$\boldsymbol A$正交向量做成标准正交基，方法就是将$\boldsymbol b$投影到$\boldsymbol a$的方向，然后取$\boldsymbol {B=b-p}$($\boldsymbol B$就是之前谈论过的误差$\boldsymbol e$的方向）<br><img src="https://pic.imgdb.cn/item/6269e662239250f7c53b67b8.jpg"></p>
<script type="math/tex; mode=display">
\boldsymbol{B=b-\frac{A^{T} b}{A^{T} A} A}</script><p>如果从等式两端左乘$\boldsymbol A^{\mathrm T}$，可以得到$\boldsymbol{A^{\mathrm T}B = 0}$。</p>
<p>从三个线性无关的向量$\boldsymbol {a, b, c}$出发，则可以通过从$\boldsymbol c$中减去其在$\boldsymbol A$和$\boldsymbol B$两个方向的投影来得到$\boldsymbol C$。 </p>
<script type="math/tex; mode=display">
\boldsymbol {C=c-\frac{A^{T} c}{A^{T} A} A-\frac{B^{T} c}{B^{T} B} B}</script><p>例如：<script type="math/tex">\boldsymbol a = \left(\begin{array}{l} 1 \\ 1 \\ 1 \end{array}\right)</script>，<script type="math/tex">\boldsymbol b = \left(\begin{array}{l} 1 \\ 0 \\ 2 \end{array}\right)</script> ，则有$\boldsymbol {A = a}$，<script type="math/tex">\boldsymbol B=\left[\begin{array}{l} 1 \\ 0 \\ 2 \end{array}\right]-\dfrac{3}{3}\left[\begin{array}{l} 1 \\  1 \\ 1 \end{array}\right]=\left[\begin{array}{l} 0 \\ 1 \\ -1\end{array}\right]</script> ，验证计算得到$\boldsymbol{A^{\mathrm T}B = 0}$。</p>
<p>写出$\boldsymbol q_1, \boldsymbol q_2$ 所组成的矩阵为：</p>
<script type="math/tex; mode=display">
\boldsymbol Q=\left[\begin{array}{ll}
\boldsymbol q_{1} & \boldsymbol q_{2}
\end{array}\right]=\left[\begin{array}{cc}
\frac{1}{\sqrt{3}} & 0 \\
\frac{1}{\sqrt{3}} & \frac{-1}{\sqrt{2}} \\
\frac{1}{\sqrt{3}} & \frac{1}{\sqrt{2}}
\end{array}\right]</script><p>$\boldsymbol Q$列向量的空间就是向量$\boldsymbol a$和$\boldsymbol b$张成的空间。 因此矩阵$\boldsymbol Q$和矩阵<script type="math/tex">\boldsymbol W = \boldsymbol{[a,b]} = \left[\begin{array}{ll} 1 & 1 \\ 1 & 0 \\ 1 & 2\end{array}\right]</script>有相同的列空间。</p>
<p>在消元过程中，可以对矩阵进行分解得到$\boldsymbol {W = LU}$，而在对$\boldsymbol  W$做施密特正交化的过程也可以用矩阵运算的方式表示为$\boldsymbol {W = QR}$。此处$\boldsymbol R$为上三角阵。</p>
<p><img src="https://pic.imgdb.cn/item/6269f252239250f7c551223b.jpg"></p>
<p>$\boldsymbol R$为上三角阵，则$\boldsymbol {a^{\mathrm T}_1q_2} = 0$。这是因为$\boldsymbol a^{\mathrm T}_1$就是$\boldsymbol q_1$的方向，而$\boldsymbol q_1$和$\boldsymbol q_2$为标准正交向量，因此$\boldsymbol q_2$的方向与$\boldsymbol a_1$ 垂直，因此内积为 0。$\boldsymbol R$在$\boldsymbol Q$右侧相当于对$\boldsymbol Q$做列操作，即$\boldsymbol W$的列向量是$\boldsymbol Q$列向量的线性组合，而$\boldsymbol Q$为列空间的$\boldsymbol W$一组标准正交基，则$\boldsymbol R$的元素实际上是$\boldsymbol W$的列向量基于$\boldsymbol Q$这组标准正交基的权。</p>
<p>左下角为0，但需要注意的是右上角并不一定为0。</p>
<ul>
<li>采用矩阵的QR分解来帮助求解$\boldsymbol{Ax = b}$的问题，最大的优势是提高了数值的稳定性。<ul>
<li>QR分解可以改善矩阵条件数，从而提高数值稳定</li>
<li>参考1：<a href="https://zhuanlan.zhihu.com/p/84415000">https://zhuanlan.zhihu.com/p/84415000</a></li>
</ul>
</li>
</ul>
<h3 id="第十八讲-行列式及其性质"><a href="#第十八讲-行列式及其性质" class="headerlink" title="第十八讲 行列式及其性质"></a>第十八讲 行列式及其性质</h3><p>之前学习了大量长方形矩阵的性质，现在我们集中讨论方阵的性质，行列式和特征值将我们的又一个重点，求行列式则与特征值息息相关。 </p>
<h4 id="18-1-行列式-Determinants"><a href="#18-1-行列式-Determinants" class="headerlink" title="18.1 行列式 Determinants"></a>18.1 行列式 Determinants</h4><p>行列式是一个每个方阵都具有的数值，我们将矩阵$\boldsymbol A$的行列式记作$\det(\boldsymbol A) = |\boldsymbol A|$。它将尽可能多的矩阵信息压缩在这一个数里。例如矩阵不可逆或称奇异与矩阵的行列式等于0等价，因此可以用行列式来判定矩阵是否可逆。</p>
<h4 id="18-2-性质-Properties"><a href="#18-2-性质-Properties" class="headerlink" title="18.2 性质 Properties"></a>18.2 性质 Properties</h4><p>直接给出$n$阶行列式的公式，则一下子代入了大量信息，并不利于接受这个概念，我们从行列式的三个基本性质开始讲起。</p>
<ul>
<li><p><strong>性质1：</strong> $|\boldsymbol I| = 1$</p>
</li>
<li><p><strong>性质2：</strong> 如果交换行列式的两行，则行列式的数值会反号。从前两条可以推知置换矩阵的行列式是+1 或者-1（交换的次数是奇数还是偶数决定了正负号）。</p>
</li>
<li><p><strong>性质3：</strong></p>
<ul>
<li>a. 如果在矩阵的一行乘上$t$，则行列式的值就要乘上$t$，<script type="math/tex">\left|\begin{array}{cc} t a & t b \\ c & d\end{array}\right|=t\left|\begin{array}{ll} a & b \\ c & d \end{array}\right|</script>；</li>
<li>b. 行列式是“矩阵的行”的线性函数，<script type="math/tex">\left|\begin{array}{cc} a+a^{\prime} & b+b^{\prime} \\ c & d \end{array}\right|=\left|\begin{array}{cc} a & b \\ c & d \end{array}\right|+\left|\begin{array}{cc} a^{\prime} & b^{\prime} \\ c & d \end{array}\right|</script></li>
</ul>
<blockquote>
<ol>
<li>行列式本身是有显式的，但是直接给出显式真的无益于理解行列式，我觉得G.Strang这里做了一个类似公理化的办法来给出行列式，是一个比较高明的办法。如他所言，很少有人用公式进行行列式计算，计算机也是用<strong>消元法</strong>来求解的。窃以为把大量时间花在“逆序”这一概念上对学习线代帮助并不大。 </li>
<li>通过高斯消元法(初等行变换)可以计算矩阵的行列式：<ul>
<li>第一类初等变换（交换矩阵的两行）：行列式值变号；</li>
<li>第二类初等变换（以一个非零数k乘矩阵的某一行所有元素）：行列式值变k倍；</li>
<li>第三类初等变换（把矩阵的某一行所有元素乘以一个数k后加到另一行对应的元素）：行列式值不变。</li>
</ul>
</li>
<li>为什么行列式的某一行的各元素乘以同一个数，然后加到另一行元素上，行列式的值不变？<ul>
<li>根据行列式按行裂项性质，而裂项根据乘法对加法分配律 </li>
<li>即利用了行列式的性质2和性质3.a和性质3.b，也就是<strong>性质5</strong>。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
<p><strong>更多的性质可以从以上的三条性质中推导出来：</strong></p>
<ul>
<li><p><strong>性质4：</strong>如果矩阵的两行是完全相同的，则它的行列式为0。</p>
<blockquote>
<p>这可以从第二条性质推导出来，因为交换这个相同的两行，行列式应该变号；但是新生成的矩阵跟原矩阵没有区别，因此行列式应该不变，所以有det=-det，所以det等于0。 </p>
</blockquote>
</li>
<li><p><strong>性质5：</strong>从矩阵的某行$k$减去另一行$i$的倍数，并不改变行列式的数值，也就是说行/列变换不改变行列式的值，以二阶为例： </p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/626a023d239250f7c5751f1d.jpg"></p>
<ul>
<li><p><strong>性质6：</strong>如矩阵$\boldsymbol A$的某一行都是0，则其行列式为0。可以应用<strong>性质3.a</strong>，取$t=0$证明。</p>
</li>
<li><p><strong>性质7：</strong>三角阵的行列式的值等于其对角线上数值（主元）的乘积。 </p>
<p><img src="https://pic.imgdb.cn/item/626a02bb239250f7c576089b.jpg"></p>
<blockquote>
<p>性质5告诉我们三角阵通过行消元法得到对角阵的过程中，行列式的数值没有发生变化。性质3(a)告诉我们对角阵的行列式等于其主元的乘积再乘以单位阵的行列式。而性质1表明单位阵行列式为1。 </p>
</blockquote>
</li>
<li><p><strong>性质8：</strong>当且仅当矩阵$\boldsymbol A$为奇异矩阵时，其行列式为0。 </p>
<blockquote>
<p>如果矩阵$\boldsymbol A$为奇异阵，则必可通过消元法使得矩阵的某行全等于零，则按照性质6，$\boldsymbol A$的行列式为0。</p>
<p>如果其不是奇异阵，则通过消元可以得到一个上三角矩阵，且其主元均不为0，则按照性质7，行列式的数值等于主元的乘积也不等于0。</p>
<p>计算非奇异矩阵的行列式有确切的公式，但通常计算机是靠消元的方法来转化为三角阵，然后将主元相乘来进行计算的。</p>
</blockquote>
</li>
<li><p><strong>性质9：</strong>$\det(\boldsymbol {AB})=\det(\boldsymbol A) \det(\boldsymbol B) $</p>
<blockquote>
<p>尽管矩阵的和的行列式不等于行列式的和，但矩阵乘积的行列式等于矩阵行列式的乘积。 </p>
<p>如果$\boldsymbol A$为可逆矩阵，则$\boldsymbol {A^{-1}A = I}$ ，所以有$\det(\boldsymbol A^{-1}) = \dfrac{1}{\det(\boldsymbol A)}$</p>
<p>此外，$\det(\boldsymbol A^2) = \det(\boldsymbol A)^2$并且有。$\det(\boldsymbol 2A) = 2^n\det(\boldsymbol A)$后一个公式让我们容易联想到体积，当长宽高都倍增之后，体积变成了原来的$2^3=8$倍。</p>
</blockquote>
</li>
<li><p><strong>性质10</strong>：$\det(\boldsymbol {A^{\mathrm T}})=\det(\boldsymbol A) $</p>
<blockquote>
<p>证明： 矩阵消元可得$\boldsymbol {A = LU}$，则$\boldsymbol {A^T = L^TU^T}$，由性质9可知$\det(\boldsymbol {A})=\det(\boldsymbol L) \det(\boldsymbol U)$，$\det(\boldsymbol {A^T})=\det(\boldsymbol L^T) \det(\boldsymbol U^T)$，根据性质7可知 $\det(\boldsymbol {L^T})=\det(\boldsymbol L)$，$\det(\boldsymbol {U^T})=\det(\boldsymbol U)$，则二者乘积相等。</p>
<p>因为性质10成立，所以性质2,3,4,5,6可以用在行列式的列性质上。</p>
<p>行列式的性质2中隐藏着一个内容，这就是置换隐藏着奇偶性，一个矩阵不可能经过奇数次置换得到和偶数次置换相同的方阵。</p>
</blockquote>
</li>
</ul>
<h3 id="第十九讲-行列式公式和代数余子式与伴随矩阵"><a href="#第十九讲-行列式公式和代数余子式与伴随矩阵" class="headerlink" title="第十九讲 行列式公式和代数余子式与伴随矩阵"></a>第十九讲 行列式公式和代数余子式与伴随矩阵</h3><p>我们已经认识到了行列式的性质，应该推导出其公式了。</p>
<h4 id="19-1-行列式公式-Formula-for-the-determinant"><a href="#19-1-行列式公式-Formula-for-the-determinant" class="headerlink" title="19.1 行列式公式 Formula for the determinant"></a>19.1 行列式公式 Formula for the determinant</h4><p>根据上节可知，由三条基本性质可以推导出后续的七条性质，从这十个性质出发可以得到二阶方阵的行列式公式： </p>
<script type="math/tex; mode=display">
\begin{aligned}
\left|\begin{array}{ll}
a & b \\
c & d
\end{array}\right| &=\left|\begin{array}{ll}
a & 0 \\
c & d
\end{array}\right|+\left|\begin{array}{ll}
0 & b \\
c & d
\end{array}\right| \\
&=\left|\begin{array}{ll}
a & 0 \\
c & 0
\end{array}\right|+\left|\begin{array}{ll}
a & 0 \\
0 & d
\end{array}\right|+\left|\begin{array}{ll}
0 & b \\
c & 0
\end{array}\right|+\left|\begin{array}{ll}
0 & b \\
0 & d
\end{array}\right| \\
&=0+a d-b c+0 \\
&=a d-b c
\end{aligned}</script><p>通过性质3对n阶矩阵的行列式进行拆分，我们可以得到所有只包含n个非零元素的行列式，对于二阶行列式我们从1个拆分为2个，然后拆分成4个。而对于三阶矩阵我们从1个拆分成3个，然后拆分成9个，最后要拆分成27个。但最终这些行列式中有很大一部分等于0。 </p>
<script type="math/tex; mode=display">
\begin{aligned}
\left|\begin{array}{lll}
a_{11} & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23} \\
a_{31} & a_{32} & a_{33}
\end{array}\right| &=\left|\begin{array}{ccc}
a_{11} & 0 & 0 \\
0 & a_{22} & 0 \\
0 & 0 & a_{33}
\end{array}\right|+\left|\begin{array}{ccc}
a_{11} & 0 & 0 \\
0 & 0 & a_{23} \\
0 & a_{32} & 0
\end{array}\right|+\left|\begin{array}{ccc}
0 & a_{12} & 0 \\
a_{21} & 0 & 0 \\
0 & 0 & a_{33}
\end{array}\right| \\
&+\left|\begin{array}{ccc}
0 & a_{12} & 0 \\
0 & 0 & a_{23} \\
a_{31} & 0 & 0
\end{array}\right|+\left|\begin{array}{ccc}
0 & 0 & a_{13} \\
a_{21} & 0 & 0 \\
0 & a_{32} & 0
\end{array}\right|+\left|\begin{array}{ccc}
0 & 0 & a_{13} \\
0 & a_{22} & 0 \\
a_{31} & 0 & 0
\end{array}\right| \\
&=a_{11} a_{22} a_{33}-a_{11} a_{23} a_{33}-a_{12} a_{21} a_{33} \\
&+a_{12} a_{23} a_{31}+a_{13} a_{21} a_{32}-a_{13} a_{22} a_{31}
\end{aligned}</script><p>每一个拆分出来的非0行列式都是在每行每列都有且只有一个元素，就如同置换矩阵的元素分布。应用性质3可以将元素从行列式中提出来，而置换矩阵的行列式值为+1或者-1，因此可以给出行列式的公式。n阶拆分矩阵非0行列式的个数的计算方法就如同计算置换矩阵的个数一样，第一行放置一个非0元素的位置有n个选择，第二行为n-1个……。最后得到共n!个矩阵。</p>
<p>对于拆分得到的三阶矩阵，元素从上至下朝向右侧方向的，其行列式的数值为正，朝向左侧方向的则为负。但是这个规律只适用于三阶矩阵，不适用于高阶矩阵。</p>
<p><img src="https://pic.imgdb.cn/item/626a0d14239250f7c58d3ad9.jpg"></p>
<p>行列式的公式： </p>
<script type="math/tex; mode=display">
\operatorname{det}(\boldsymbol{A})=\sum_{n !} \pm a_{1 \alpha} a_{2 \beta} a_{3 \gamma} \cdots a_{n \omega}</script><p>其中列标号$(\alpha, \beta, \gamma, \dots)$是列标号$(1, 2, 3, \dots, n)$的某个排列。比如说对于单位阵而言，只有$\alpha = 1, \beta = 2, \dots, \omega = n$所得到的行列式为+1，其它都为零，所以单位阵的行列式为1。 </p>
<p>例如： </p>
<script type="math/tex; mode=display">
\left|\begin{array}{llll}
0 & 0 & 1 & 1 \\
0 & 1 & 1 & 0 \\
1 & 1 & 0 & 0 \\
1 & 0 & 0 & 1
\end{array}\right|=\left|\begin{array}{llll}
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0 \\
0 & 1 & 0 & 0 \\
1 & 0 & 0 & 0
\end{array}\right|+\left|\begin{array}{llll}
0 & 0 & 1 & 0 \\
0 & 1 & 0 & 0 \\
1 & 0 & 0 & 0 \\
0 & 0 & 0 & 1
\end{array}\right|</script><p>列标号取$(4,3,2,1)$得到第一个拆分行列式，符号为正，因为只要经两次交换就能变为$(1,2,3,4)$。第二个为$(3,2,1,4)$，因为只需交换一次就可变为正序，所以符号为负。因此本行列式为0。 </p>
<h4 id="19-2-代数余子式-Cofactor-formula"><a href="#19-2-代数余子式-Cofactor-formula" class="headerlink" title="19.2 代数余子式 Cofactor formula"></a>19.2 代数余子式 Cofactor formula</h4><p> <strong>代数余子式是用较小的矩阵的行列式来写出$n$阶行列式的公式</strong>。 </p>
<script type="math/tex; mode=display">
\begin{aligned}
&\operatorname{det}(\boldsymbol{A})=a_{11}\left(a_{22} a_{33}-a_{23} a_{32}\right)+a_{12}\left(-a_{21} a_{33}+a_{23} a_{31}\right)+a_{13}\left( a_{21} a_{32}-a_{22} a_{31}\right) \\
&=\left|\begin{array}{ccc}
a_{11} & 0 & 0 \\
0 & a_{22} & a_{23} \\
0 & a_{32} & a_{33}
\end{array}\right|+\left|\begin{array}{ccc}
0 & a_{12} & 0 \\
a_{21} & 0 & a_{23} \\
a_{31} & 0 & a_{33}
\end{array}\right|+\left|\begin{array}{ccc}
0 & 0 & a_{13} \\
a_{21} & a_{22} & 0 \\
a_{31} & a_{32} & 0
\end{array}\right|
\end{aligned}</script><p>将原公式中属于矩阵第一行的$a_{1j}$提出来，其系数即为代数余子式，是一个低阶行列式的值。这个低阶行列式是由原矩阵去掉$a_{1j}$所在的行和列组成的。</p>
<p><strong><font color="red">对矩阵中任意元素$a_{ij}$而言，其代数余子式$C_{ij}$就是矩阵的行列式的公式中$a_{ij}$的系数。$C_{ij}$等于原矩阵移除第$i$行和第$j$列后剩余元素组成的$n-1$阶矩阵的行列式数值乘以$(-1)^{i+j}$。（$C_{ij}$在$i+j$为偶数时为正，奇数时为负数。）</font></strong></p>
<p>对于$n$阶方阵，其行列式的代数余子式公式为：</p>
<script type="math/tex; mode=display">
\operatorname{det}(\boldsymbol{A})=a_{11} \mathrm{C}_{11}+a_{12} \mathrm{C}_{12}+\cdots+a_{1 \mathrm{n}} \mathrm{C}_{1 \mathrm{n}}</script><p>对于二阶矩阵，按照代数余子式公式则有： <script type="math/tex">\left|\begin{array}{ll} a & b \\ c & d\end{array}\right|=a d+b(-c)</script></p>
<p>对于矩阵行列式的计算，消元的得到主元是一个很好的方法，与之相比行列式的展开公式较为复杂，而代数余子式的方法介于两者之间，它的核心想法是通过降阶来将原来的行列式展开成更简单的行列式。</p>
<p>举”三对角阵”（tridiagonal matrix）为例，它除了对角线和对角线两侧相邻的元素之外，其它元素均为0。例如由1组成的4阶三对角阵为： <script type="math/tex">\boldsymbol{A}_{4}=\left[\begin{array}{llll} 1 & 1 & 0 & 0 \\ 1 & 1 & 1 & 0 \\ 0 & 1 & 1 & 1 \\ 0 & 0 & 1 & 1\end{array}\right]</script></p>
<p>由1组成的$n$阶三对角阵的行列式等于多少？</p>
<p>从矩阵的特殊结构我们可以得到： <script type="math/tex">\left|\boldsymbol{A}_{\mathrm{n}}\right|=\left|\boldsymbol{A}_{\mathrm{n}-1}\right|-1\left|\boldsymbol{A}_{\mathrm{n}-2}\right|</script></p>
<p>由1组成的$n$阶三对角阵的行列式从1阶开始按照$1，0，-1，-1，0，1$进行循环。 </p>
<h4 id="19-3-伴随矩阵-adjoint-matrix"><a href="#19-3-伴随矩阵-adjoint-matrix" class="headerlink" title="19.3 伴随矩阵 adjoint matrix"></a>19.3 伴随矩阵 adjoint matrix</h4><p><img src="https://pic.imgdb.cn/item/627e0a0709475431296a2889.jpg" style="zoom:50%"></p>
<p>上图中，$\boldsymbol A^<em>$即为矩阵$\boldsymbol A$的伴随矩阵，伴随矩阵$\boldsymbol A^</em>$的元素计算方法为：</p>
<ul>
<li>$a_{11}$的代数余子式为$\boldsymbol A_{11}$，$a_{12}$的代数余子式为$\boldsymbol A_{12}$，$a_{1n}$的代数余子式为$\boldsymbol A_{1n}$；</li>
<li>原矩阵的行对应伴随矩阵的列。</li>
</ul>
<h3 id="第二十讲-行列式应用：克莱默法则、逆矩阵、体积"><a href="#第二十讲-行列式应用：克莱默法则、逆矩阵、体积" class="headerlink" title="第二十讲 行列式应用：克莱默法则、逆矩阵、体积"></a>第二十讲 行列式应用：克莱默法则、逆矩阵、体积</h3><h4 id="20-1-逆矩阵的公式"><a href="#20-1-逆矩阵的公式" class="headerlink" title="20.1 逆矩阵的公式"></a>20.1 逆矩阵的公式</h4><p>我们已经知道二阶矩阵的逆矩阵公式为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
a & b \\
c & d
\end{array}\right] \stackrel{逆矩阵}\Longrightarrow \frac{1}{a d-b c}\left[\begin{array}{cc}
d & -b \\
-c & a
\end{array}\right]</script><p>那么我们能写出三阶甚至高阶的公式么？通过观察二阶矩阵逆矩阵的公式，我们可以用同样的策略来构造高阶矩阵的求逆公式，为： </p>
<script type="math/tex; mode=display">
\boldsymbol{A}^{-1}=\frac{1}{\operatorname{det}(\boldsymbol{A})} \boldsymbol{C}^{T}</script><p>等式右侧矩阵外的因子，其分母是矩阵的行列式的值，而矩阵$\boldsymbol C$是“代数余子式矩阵”的转置矩阵，又称<strong>伴随矩阵</strong>($\boldsymbol C$矩阵的值是由行列式组成的)。</p>
<p>矩阵$\boldsymbol A$的行列式的计算中包含的都是$n$个元素的乘积： </p>
<script type="math/tex; mode=display">
\operatorname{det} \boldsymbol{A}=\sum_{n} \pm a_{1 \alpha} a_{2 \beta} a_{3 \gamma} \cdots a_{n \omega}</script><p>而伴随矩阵中的元素都是$n-1$阶行列式，它的运算中出现的是$n-1$个矩阵$\boldsymbol A$中元素的乘积。所以矩阵$\boldsymbol A$与两者相乘才能完全消去，而得到单位矩阵。下面我们就用矩阵$\boldsymbol A$与矩阵$\boldsymbol C^{\mathrm T}$相乘来验证$\boldsymbol {AC}^{\mathrm T} = \det(\boldsymbol A) \boldsymbol I$ ，并且理解逆矩阵的构造策略。 </p>
<script type="math/tex; mode=display">
\boldsymbol{A} \boldsymbol{C}^{T}=\left[\begin{array}{ccc}
a_{11} & \ldots & a_{1 n} \\
\vdots & \ddots & \vdots \\
a_{n 1} & \cdots & a_{n n}
\end{array}\right]\left[\begin{array}{ccc}
C_{11} & \ldots & C_{n 1} \\
\vdots & \ddots & \vdots \\
C_{1 n} & \cdots & C_{n n}
\end{array}\right]</script><p>矩阵$\boldsymbol {AC}^{\mathrm T}$第一行第一列的元素等于矩阵$\boldsymbol A$第一行和矩阵$\boldsymbol {C}^{\mathrm T} $第一列进行点积，计算可得： </p>
<script type="math/tex; mode=display">
\sum_{j=1}^{n} a_{1 j} C_{1 j}=\operatorname{det}(\boldsymbol{A})</script><p>点积的算式本身就是矩阵$\boldsymbol A$的计算公式，因此结果为$\boldsymbol A$行列式的值。而矩阵$\boldsymbol {AC}^{\mathrm T}$对角线上所有的元素都是如此，因此其对角戏上的元素都等于$\det(\boldsymbol A)$，即：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{llll}
\operatorname{det}(A) & & & \\
& \operatorname{det}(A) & \\
& & \ddots & \\
& & & \operatorname{det}(A)
\end{array}\right]</script><p>而对于非对角线元素，我们以第二行第一列的元素为例，其计算公式为：</p>
<script type="math/tex; mode=display">
\sum_{j=1}^{n} a_{2 j} C_{1 j}=\operatorname{det}\left(\boldsymbol{A}_{s}\right)</script><p>这可以视为矩阵$\boldsymbol A_s$的行列式数值，各个代数余子式的形式不变，但是与代数余子式相乘的变为了矩阵$\boldsymbol A$第二行第$j$列元素。因此$\boldsymbol A_s$的形式相当于用矩阵$\boldsymbol A$第二行的元素替代第一行的元素得到的矩阵。因为该矩阵中前两行完全相同，因此按照行列式性质4，$\det(\boldsymbol A_s) = 0$（G.Strang在课堂上是用二阶矩阵为例），其他列类似，所以有：</p>
<script type="math/tex; mode=display">
\boldsymbol{A} \boldsymbol{C}^{T}=\left[\begin{array}{rrrrrr}
\operatorname{det} \boldsymbol{A} & 0 & 0 & \cdots & 0 \\
0 & \operatorname{det} \boldsymbol{A} & 0 & \cdots & 0 \\
0 & 0 & \ddots & & 0 \\
\vdots & & & \ddots & \vdots \\
0 & 0 & 0 & \cdots & \operatorname{det} \boldsymbol{A}
\end{array}\right]=\operatorname{det}(\boldsymbol{A}) \boldsymbol{I}</script><p>即<script type="math/tex">\boldsymbol{A} \dfrac{1}{\operatorname{det}(\boldsymbol{A})} \boldsymbol{C}^{T}=\boldsymbol{I}</script> ，因此有 </p>
<script type="math/tex; mode=display">
\boldsymbol{A}^{-1}=\frac{1}{\operatorname{det}(\boldsymbol{A})} \boldsymbol{C}^{T}</script><p>逆矩阵公式的一个好处就是，我们从中可以看到，当改变原矩阵中的一个元素时，给逆矩阵带来了怎样的变化。</p>
<h4 id="20-2-克莱默法则"><a href="#20-2-克莱默法则" class="headerlink" title="20.2 克莱默法则"></a>20.2 克莱默法则</h4><p>对于可逆矩阵$\boldsymbol A$，方程$\boldsymbol {Ax = b}$必然有解<script type="math/tex">\boldsymbol {x = A^{-1}b}</script>，将逆矩阵的公式带入其中，则有： </p>
<script type="math/tex; mode=display">
\boldsymbol {x}=\boldsymbol{A}^{-1} \boldsymbol {b}=\frac{1}{\operatorname{det}(\boldsymbol{A})} \boldsymbol{C}^{T} \boldsymbol{b}</script><p>克莱姆法则是从另一个角度来看待这个公式。实际上$\boldsymbol x$的分量<script type="math/tex">x_{j}=\dfrac{\operatorname{det}\left(\boldsymbol{B}_{j}\right)}{\operatorname{det}(\boldsymbol{A})}</script></p>
<p>其中我们需要思考一下矩阵<script type="math/tex">\boldsymbol{B}_{j}</script>是什么，由于<script type="math/tex">\boldsymbol{C}^{\mathrm T}</script>由<script type="math/tex">\boldsymbol{A}</script>的代数余子式构成，那么<script type="math/tex">\boldsymbol{C}^{\mathrm T}*\boldsymbol b</script>可以视为用向量<script type="math/tex">\boldsymbol{b}</script>替换矩阵<script type="math/tex">\boldsymbol A</script>的第<script type="math/tex">j</script>列所得到的新矩阵，这就是<strong>克莱默发现的规律</strong>——矩阵<script type="math/tex">\boldsymbol{B}_{j}</script>的构成规律，例如： </p>
<script type="math/tex; mode=display">
\boldsymbol{B}_{1}=\left[\begin{array}{ccccc}
b_{1} & a_{12} & \cdots & \cdots & a_{1 n} \\
b_{2} & a_{22} & \cdots & \cdots & a_{2 n} \\
b_{3} & a_{32} & \ddots & & a_{3 n} \\
\vdots & & & \ddots & \vdots \\
b_{n} & a_{n 2} & \cdots & \cdots & a_{n n}
\end{array}\right]</script><script type="math/tex; mode=display">
\boldsymbol{B}_{n}=\left[\begin{array}{rrrrr}
a_{11} & \cdots & \cdots & a_{1 n-1} & b_{1} \\
a_{21} & \cdots & \cdots & a_{2 n-1} & b_{2} \\
\vdots & & \ddots & \vdots & \vdots \\
\vdots & & & a_{n-1 n-1} & b_{n-1} \\
a_{n 1} & a_{n 2} & \cdots & a_{n n-1} & b_{n}
\end{array}\right]</script><p>矩阵$\boldsymbol{B}_{j}$的行列式的数值从第$j$列用代数余子式进行展开计算，正好是伴随矩阵$\boldsymbol{C}^{\mathrm T}$的第$j$行与向量$\boldsymbol{b}$点积的结果。此处我们用到了行列式的<strong>性质10</strong>。</p>
<p>相比于消元法，采用克莱姆法则计算方程的解，效率较低。</p>
<h4 id="20-3-体积-面积"><a href="#20-3-体积-面积" class="headerlink" title="20.3  体积/面积"></a>20.3  体积/面积</h4><p>为什么行列式等价于空间“箱子”的体积，老师的证明思路是证明空间“箱子”体积满足行列式的三条基本性质。</p>
<p>矩阵$\boldsymbol A$行列式的绝对值等于以矩阵$\boldsymbol A$行（列）向量为边所构成的平行六面体的体积。行列式的正负对应左手系和右手系。</p>
<ul>
<li>如果矩阵$\boldsymbol A$是单位矩阵，则其构成的是三个边长均为1且互相垂直的立方体，其体积为1，这与上面的结论相符。这也是行列式的性质1。</li>
<li>而如果矩阵$\boldsymbol A$为正交矩阵$\boldsymbol Q$，则其构成的也是三个边边长为1且三边互相垂直的立方体，其体积也为1只是取向与单位阵不同。这也与上面的结论相符，因为$\boldsymbol{Q^{\mathrm T} Q = I}$，且$\operatorname{det}(\boldsymbol{Q})=\operatorname{det}\left(\boldsymbol{Q}^{T}\right)$，所以$\det(\boldsymbol Q)=1$。 </li>
</ul>
<p>交换矩阵$\boldsymbol A$中的行并不会改变其行列式的绝对值，显然也不会改变向量围成的体积，因此这也和体积理论相符。这是行列式的性质2。 </p>
<p><img src="https://pic.imgdb.cn/item/626a544b239250f7c53692a2.jpg"></p>
<p>对于长方体，也非常直观，当你将其中一条边的边长增加2倍时，平行六面体的体积也会增加2倍，这相当于性质3a。</p>
<p>对于性质3b，实际上是要求体积理论摆脱角度的限制（之前几条完全都是在直角的背景下讨论得），我们可以在二维条件下简单证明。</p>
<ul>
<li><strong>证明二阶行列式是平行四边形的面积</strong>：</li>
</ul>
<p>如图所示，向量$\boldsymbol a$和$\boldsymbol b$围成的平行四边形的面积，就等于向量$\boldsymbol a$和高$\boldsymbol h$的长度之积，就等于两个互相垂直的向量$\boldsymbol a$和高$\boldsymbol h$围成的长方形的面积，按照前面所述即为 <script type="math/tex">\left|\begin{array}{ll} a_{1} & a_{2} \\ h_{1} & h_{2}\end{array}\right|</script> 。根据行列式运算法则有：</p>
<script type="math/tex; mode=display">
\left|\begin{array}{ll}
a_{1} & a_{2} \\
h_{1} & h_{2}
\end{array}\right|=\left|\begin{array}{ll}
a_{1} & a_{2} \\
b_{1} & b_{2}
\end{array}\right|-\left|\begin{array}{ll}
a_{1} & a_{2} \\
p_{1} & p_{2}
\end{array}\right|</script><p>而$\boldsymbol p$和$\boldsymbol a$同方向因此第二项为0，因此平行四边形的面积等于<script type="math/tex">\left|\begin{array}{ll} a_{1} & a_{2} \\ b_{1} & b_{2}\end{array}\right|</script>结果可以推广到高维。 </p>
<p>二阶行列式的值等于平行四边形的面积，同时其一半也是{(a,b),(c,d),(0,0)}围成的三角形的面积。</p>
<p>若三角形不过原点，为<script type="math/tex">{(x_1,y_1),(x_2,y_2),(x_3,y_3)}</script>围成，则其面积等于<script type="math/tex">\dfrac{1}{2}\left|\begin{array}{lll} x_{1} & y_{1} & 1 \\ x_{2} & y_{2} & 1 \\ x_{3} & y_{3} & 1\end{array}\right|</script></p>
<p>这个公式可以从第三列用代数余子式展开，所得结果可以看做是从一个过原点的大三角形中减去两个过原点的小三角形。 </p>
<p>除以上各条之外性质4也比较直观，当有两条边重合时，平行六面体或平行四边形被压扁，体积或者面积为0。 </p>
<h3 id="第二十一讲-特征值与特征向量"><a href="#第二十一讲-特征值与特征向量" class="headerlink" title="第二十一讲 特征值与特征向量"></a>第二十一讲 特征值与特征向量</h3><p>本单元后面的课程主要围绕特征值和特征向量。在这个议题下讨论得都是<font color="red"><strong>方阵</strong></font>。 </p>
<h4 id="21-1-特征向量和特征值-Eigenvectors-and-eigenvalues"><a href="#21-1-特征向量和特征值-Eigenvectors-and-eigenvalues" class="headerlink" title="21.1 特征向量和特征值 Eigenvectors and eigenvalues"></a>21.1 特征向量和特征值 Eigenvectors and eigenvalues</h4><p>将矩阵$\boldsymbol A$与向量$\boldsymbol x$相乘当做是对向量的一种操作或者函数，输入$\boldsymbol x$而输出$\boldsymbol {Ax}$。特征向量即在特定的向量$\boldsymbol x$ 方向上输出的$\boldsymbol {Ax}$平行于$\boldsymbol x$，即为： </p>
<script type="math/tex; mode=display">
\boldsymbol {Ax} = \lambda \boldsymbol x</script><p>其中$\boldsymbol x$为矩阵$\boldsymbol A$的特征向量，而$\lambda$为$\boldsymbol A$的特征值。 </p>
<p>如果0是矩阵的特征值，则有$\boldsymbol{Ax = 0x = 0}$。特征值0所对应的向量生成了矩阵的零空间。如果矩阵为$\boldsymbol A$不可逆矩阵，则0是其特征值之一。 </p>
<p><strong>例1：</strong>矩阵$\boldsymbol P$是朝向一个平面的投影矩阵。对于这个平面之内的$\boldsymbol x$，均有$\boldsymbol{Px=x}$，因此$\boldsymbol x$是特征向量而1为特征值。垂直于该平面的向量$\boldsymbol x$经投影得到$\boldsymbol {Px=0}$，这个$\boldsymbol x$也是矩阵的特征向量而0为特征值。矩阵$\boldsymbol P$的所有特征向量张成了整个空间。 </p>
<p><strong>例2：</strong>矩阵<script type="math/tex">\boldsymbol A=\left[\begin{array}{ll} 0 & 1 \\ 1 & 0\end{array}\right]</script>，具有特征向量 <script type="math/tex">\boldsymbol  x=\left[\begin{array}{l} 1 \\ 1\end{array}\right]</script> ，对应的特征向量为1；另一个特征向量为<script type="math/tex">\boldsymbol  x=\left[\begin{array}{l} 1 \\ -1\end{array}\right]</script>，对应的特征向量为-1。这些特征向量张成了整个空间。<strong>因为是<font color="red">对称矩阵</font>，其特征向量互相<font color="red">垂直</font></strong> </p>
<h4 id="21-2-特征值计算与性质"><a href="#21-2-特征值计算与性质" class="headerlink" title="21.2 特征值计算与性质"></a>21.2 特征值计算与性质</h4><p>方程$\boldsymbol {Ax} = \lambda \boldsymbol x$中特征值和特征向量均未知，没法直接求解。因此我们做如下数学处理： $\boldsymbol {Ax} - \lambda \boldsymbol x = (\boldsymbol A - \lambda \boldsymbol I)\boldsymbol x = 0$，此时可知$(\boldsymbol A - \lambda \boldsymbol I)$为奇异阵，也就是</p>
<script type="math/tex; mode=display">
\det(\boldsymbol A - \lambda \boldsymbol I) = 0</script><p>在这个没有$\boldsymbol x$的方程中，可以解得$n$个特征值，但是有可能方程有重根，则会得到重复的特征值。 </p>
<p>得到特征值之后，可以用消元法解$(\boldsymbol A - \lambda \boldsymbol I)$这一矩阵零空间中的向量为矩阵的$\boldsymbol A$特征向量。 </p>
<ul>
<li><strong>性质1:</strong></li>
</ul>
<p><strong><font color="green"> 任意$n \times n$矩阵具$\boldsymbol A$有$n$个特征值，并且它们的和等于矩阵对角线上的元素之和，这个数值为矩阵的迹(trace) </font></strong>。对于二阶矩阵，在已知一个特征值的条件下，可以据此得到另一个特征值。 </p>
<script type="math/tex; mode=display">
\text{trace}(\boldsymbol A) = 对角元素和 = \lambda_1+ \lambda_2+ \dots +\lambda_n</script><ul>
<li><strong>性质2：</strong></li>
</ul>
<p><strong><font color="green"> 矩阵$\boldsymbol A$的特征值的乘积等于矩阵的行列式 </font></strong></p>
<script type="math/tex; mode=display">
\det(\boldsymbol A) = \lambda_1 \lambda_2 \dots \lambda_n</script><ul>
<li><strong>性质3：</strong></li>
</ul>
<p><strong><font color="green"> 对称矩阵的特征向量正交  </font></strong></p>
<p><img src="https://pic.imgdb.cn/item/626c8dc7239250f7c590bdca.jpg" style="zoom:70%"></p>
<blockquote>
<p>证明：<a href="https://zhuanlan.zhihu.com/p/83669028">https://zhuanlan.zhihu.com/p/83669028</a></p>
</blockquote>
<ul>
<li><strong>性质4：</strong></li>
</ul>
<p><strong><font color="green">对称矩阵永远具有实数的特征值，而反对称矩阵（antisymmetric matrices），即满足$\boldsymbol A^{\mathrm T} = - \boldsymbol A$的矩阵，具有纯虚数的特征值</font></strong>。 <em>实数特征值让特征向量<strong>伸缩</strong>而虚数让其<strong>旋转</strong></em>。</p>
<ul>
<li><strong>性质5：</strong></li>
</ul>
<p><strong><font color="green">三角阵特征值就是矩阵对角线上的元素。 </font></strong>重特征值 Triangular matrices and repeated eigenvalues</p>
<ul>
<li><strong>性质6：</strong></li>
</ul>
<p><strong><font color="green">矩阵$\boldsymbol A^2$的特征向量与$\boldsymbol A$的相同，但是特征值变为$\lambda^2$ </font></strong></p>
<script type="math/tex; mode=display">
\boldsymbol {A^2x} = \boldsymbol A(\boldsymbol {Ax}) = \boldsymbol A (\lambda \boldsymbol x) = \lambda \boldsymbol{Ax} = \lambda ( \lambda\boldsymbol x ) = \lambda^2 \boldsymbol x</script><p>这个性质可以进一步推广到$\boldsymbol A^n$。这个性质是计算矩阵幂的一种方式。</p>
<blockquote>
<p>需要注意的是，两个矩阵的和的特征值不是两特征值直接相加之和，因为特征向量并不相同。 </p>
</blockquote>
<h3 id="第二十二讲-对角化和矩阵乘幂"><a href="#第二十二讲-对角化和矩阵乘幂" class="headerlink" title="第二十二讲 对角化和矩阵乘幂"></a>第二十二讲 对角化和矩阵乘幂</h3><p>本讲中我们学习如何对角化含有n个线性无关特征向量的矩阵，以及对角化是怎样简化计算的。 </p>
<h4 id="22-1-对角化矩阵-Diagonalizing-a-matrix-boldsymbol-S-1-boldsymbol-A-boldsymbol-S-boldsymbol-Lambda"><a href="#22-1-对角化矩阵-Diagonalizing-a-matrix-boldsymbol-S-1-boldsymbol-A-boldsymbol-S-boldsymbol-Lambda" class="headerlink" title="22.1 对角化矩阵 Diagonalizing a matrix $\boldsymbol{S}^{-1} \boldsymbol{A} \boldsymbol{S}=\boldsymbol{\Lambda}$"></a>22.1 对角化矩阵 Diagonalizing a matrix $\boldsymbol{S}^{-1} \boldsymbol{A} \boldsymbol{S}=\boldsymbol{\Lambda}$</h4><p>如果矩阵$\boldsymbol A$具有$n$个线性无关的特征向量，将它们作为列向量可以组成一个可逆方阵$\boldsymbol S$(这是前提，因为特征向量组成的方阵不一定是可逆的)，并且有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{A} \boldsymbol{S} &=\boldsymbol{A}\left[\begin{array}{llll}
\boldsymbol{x}_{1} & \boldsymbol{x}_{2} & \cdots & \boldsymbol{x}_{\mathrm{n}}
\end{array}\right] \\
&=\left[\begin{array}{lllll}
\lambda_{1} \boldsymbol{x}_{1} & \lambda_{2} \boldsymbol{x}_{2} & \cdots & \lambda_{\mathrm{n}} \boldsymbol{x}_{\mathrm{n}}
\end{array}\right] \\
&=\boldsymbol{S}\left[\begin{array}{cccc}
\lambda_{1} & 0 & \cdots & 0 \\
0 & \lambda_{2} & & 0 \\
\vdots & & \ddots & \vdots \\
0 & \cdots & 0 & \lambda_{\mathrm{n}}
\end{array}\right] \\
&=\boldsymbol{S} \boldsymbol{\Lambda}
\end{aligned}</script><p>这里的矩阵$\boldsymbol{\Lambda}$为对角阵，它的非零元素就是矩阵$\boldsymbol{A}$的特征值。因为矩阵$\boldsymbol{S}$中的列向量线性无关，因此逆矩阵$\boldsymbol{S}^{-1}$存在。在等式两侧左乘逆矩阵，得到$\boldsymbol{S}^{-1} \boldsymbol{A} \boldsymbol{S}=\boldsymbol{\Lambda}$，同样地， $\boldsymbol{A}=\boldsymbol{S} \boldsymbol{\Lambda} \boldsymbol{S}^{-1}$。</p>
<p>对于消元法而言，矩阵有$\boldsymbol{LU}$分解，对于施密特正交法，矩阵有$\boldsymbol{QR}$分解，而上面的推导是一种新的矩阵分解。 </p>
<blockquote>
<p>之前曾经提到过消元进行行操作和列操作最后会得到“相抵标准型”。现在我们得到的是矩阵的“相似标准形”,它还保有矩阵操作的基本性质——特征值，而相抵标准型只剩下最内核的秩信息还保留着。 </p>
</blockquote>
<h4 id="22-2-矩阵的幂-Powers-of-boldsymbol-A"><a href="#22-2-矩阵的幂-Powers-of-boldsymbol-A" class="headerlink" title="22.2 矩阵的幂 Powers of $\boldsymbol{A}$"></a>22.2 矩阵的幂 Powers of $\boldsymbol{A}$</h4><p>参考第二十一讲<strong>性质6</strong>。</p>
<p>如果矩阵$\boldsymbol{A}$具有$n$个线性无关的特征向量，如果所有的特征值均满足$|\lambda_i|&lt;1$，则当$k \to \infty$ 时，$\boldsymbol{A}^k \to \boldsymbol 0$。</p>
<h4 id="22-3-重特征值-Repeated-eigenvalues"><a href="#22-3-重特征值-Repeated-eigenvalues" class="headerlink" title="22.3 重特征值 Repeated eigenvalues"></a>22.3 重特征值 Repeated eigenvalues</h4><p> 如果矩阵$\boldsymbol{A}$没有重特征值，则其一定具有$n$个线性无关的特征向量。</p>
<p>如果矩阵$\boldsymbol{A}$有重特征值，它有可能具有$n$个线性无关的特征向量，也可能没有。比如单位阵的特征值为重特征值1，但是其具有$n$个线性无关的特征向量。</p>
<p>对于如 <script type="math/tex">\boldsymbol{A}=\left[\begin{array}{ll} 2 & 1 \\ 0 & 2\end{array}\right]</script>的三角矩阵，特征值就是矩阵对角线上的元素2。其特征向量在$(\boldsymbol A - \lambda \boldsymbol I)$的零空间中，满足</p>
<script type="math/tex; mode=display">
(\boldsymbol{A}-\lambda \boldsymbol{I}) \boldsymbol{x}=\left[\begin{array}{ll}
0 & 1 \\
0 & 0
\end{array}\right] \mathbf{x}=\mathbf{0}</script><p>求解可得<script type="math/tex">\boldsymbol x=\left[\begin{array}{l} 1 \\ 0\end{array}\right]</script>，而没有第二个特征向量。 </p>
<h4 id="22-4-差分方程-Difference-equations"><a href="#22-4-差分方程-Difference-equations" class="headerlink" title="22.4 差分方程 Difference equations"></a>22.4 差分方程 Difference equations</h4><p>从给定的一个向量<strong><em>u</em></strong>0出发，我们可以通过对前一项乘以矩阵得到下一项的方式，得到一个向量序列：</p>
<script type="math/tex; mode=display">
\boldsymbol u_{k+1}=\boldsymbol{Au}_k</script><p>上式为一个一阶差分方程，易知</p>
<script type="math/tex; mode=display">
\boldsymbol u_{k+1}=\boldsymbol{A}^k {\boldsymbol u}_0</script><p>是方程的解。但这种简洁形式并没有给出足够的信息，我们需要通过特征向量和矩阵的幂运算给出真实解的结构。 </p>
<p>将<strong><em>u</em></strong>0写成特征向量的线性组合： </p>
<script type="math/tex; mode=display">
\begin{aligned}
&\boldsymbol{u}_{0}=c_{1} \boldsymbol{x}_{1}+c_{2} \boldsymbol{x}_{2}+\ldots+c_{n} \boldsymbol{x}_{n}=\boldsymbol{S c} \\
&\boldsymbol{A} \boldsymbol{u}_{0}=c_{1} \lambda_{1} \boldsymbol{x}_{1}+c_{2} \lambda_{2} \boldsymbol{x}_{2}+\ldots+c_{n} \lambda_{n} \boldsymbol{x}_{n} \\
&\boldsymbol{u}_{k}=\boldsymbol{A}^{k} \boldsymbol{u}_{0}=c_{1} \lambda_{1}^{k} \boldsymbol{x}_{1}+c_{2} \lambda_{2}^{k} \boldsymbol{x}_{2}+\ldots+c_{n} \lambda_{n}^{k} \boldsymbol{x}_{n}= \boldsymbol{S} \boldsymbol{\Lambda}^{k} \boldsymbol{c}
\end{aligned}</script><blockquote>
<p>很多人会问矩阵的特征值特征向量为什么这么神奇，可以把矩阵的操作变成一个简单的参数。还有人会问道为什么特征值在物理中出现非常频繁。对此我只能简单解释一下，物理中常见的被研究物体都有一个自身的内禀结构，这个内在结构的方向往往和观察者也就是外场的坐标有区别。当我们给物体施加一个外场刺激的时候，比如说外力或者电场极化等等，物体沿着其内在结构的取向来响应外场，但是观察者从外场坐标下采集反馈。实际上矩阵在不同坐标之间实现变换，特征向量显示了物体内结构的方向，特征值则是在这个主方向上物体对外场的响应参数。在有的领域直接将特征值称为伸缩系数，实际上它反应了在其所对应的特征向量方向上，内结构与外场之间的相互关系。 特征值还有一个应用是作为降维的判据，比如在图像压缩过程中，极小的特征值会被赋值为0，以此节省存储空间，也便于其它操作。反应在图像上，降维后的图像基本轮廓依旧清晰，图像细节有所牺牲。 </p>
</blockquote>
<h3 id="第二十三讲-微分方程和-e-boldsymbol-A-t"><a href="#第二十三讲-微分方程和-e-boldsymbol-A-t" class="headerlink" title="第二十三讲 微分方程和$e^{\boldsymbol A t}$"></a>第二十三讲 微分方程和$e^{\boldsymbol A t}$</h3><p>本讲将面对微分方程，将一阶常系数微分方程转化为线性代数问题进行处理。主要思路基于常系数线性方程的解是指数形式，而寻找其指数和系数就是线代主要研究的问题。这里会涉及到矩阵型指数的运算$e^{\boldsymbol A t}$。</p>
<h4 id="23-1-微分方程-Differential-equations"><a href="#23-1-微分方程-Differential-equations" class="headerlink" title="23.1 微分方程 Differential equations"></a>23.1 微分方程 Differential equations</h4><p>例： <script type="math/tex">\begin{aligned} &\frac{\mathrm d u_{1}}{\mathrm d t}=-u_{1}+2 u_{2} \\ &\frac{\mathrm d u_{2}}{\mathrm d t}=u_{1}-2 u_{2}\end{aligned}</script>，初值条件$u_1(0)=1，u_2(0)=0$</p>
<p>则有<script type="math/tex">\dfrac{\mathrm d \mathbf{u}}{\mathrm d t}=\boldsymbol{A} \boldsymbol{u}</script>，<script type="math/tex">\boldsymbol{A}=\left[\begin{array}{cc} -1 & 2 \\ 1 & -2\end{array}\right], \boldsymbol{u}(0)=\left[\begin{array}{l} 1 \\ 0\end{array}\right]</script></p>
<p>分析矩阵$\boldsymbol{A}$的目的是要追踪$\boldsymbol{u}$随时间的变化，而首先要做的是找到矩阵的特征值和特征向量。矩阵$\boldsymbol{A}$为奇异矩阵，因此存在一个特征值$\lambda_1 = 0$ ，而矩阵的迹为-3，因此还有一个特征值为$\lambda_2 = -3$。</p>
<p>一阶线性微分方程的解的形式是$e^{\boldsymbol \lambda t}$。两个特征值中，0会使结果达到稳态，而-3所对应的$e^{\boldsymbol -3 t}$会随时间增大而变小。 </p>
<p>方程的通解为<script type="math/tex">\boldsymbol{u}(\mathrm{t})=c_{1} e^{\lambda_{1} t} \boldsymbol{x}_{1}+c_{2} e^{\lambda_{2} t} \boldsymbol{x}_{2}</script></p>
<blockquote>
<p>尽管直接代入可以验证。。。</p>
</blockquote>
<p>将<script type="math/tex">\lambda_{1}=0, \quad \lambda_{2}=-3</script>代入<script type="math/tex">(\boldsymbol{A}-\lambda \boldsymbol{I}) \boldsymbol{x}=\boldsymbol{0}</script>，分别求得对应的特征向量<script type="math/tex">\boldsymbol x_1=\left[\begin{array}{l} 2 \\ 1\end{array}\right], \boldsymbol x_2=\left[\begin{array}{l} 1 \\ -1\end{array}\right]</script>，即解为：</p>
<script type="math/tex; mode=display">
\mathbf{u}(\boldsymbol{t})=c_{1} e^{\lambda_{1} t} \boldsymbol {x}_{1}+c_{2} e^{\lambda_{2} t} \boldsymbol {x}_{2}=c_{1} e^{0}\left[\begin{array}{l}
2 \\
1
\end{array}\right]+c_{2} e^{-3 t}\left[\begin{array}{c}
1 \\
-1
\end{array}\right]</script><p>由初始条件得</p>
<script type="math/tex; mode=display">
\boldsymbol{u}(0)=c_{1}\left[\begin{array}{l}
2 \\
1
\end{array}\right]+c_{2}\left[\begin{array}{c}
1 \\
-1
\end{array}\right]=\left[\begin{array}{l}
1 \\
0
\end{array}\right]</script><p> 解为$c_1 = c_2 = \dfrac{1}{3}$，因此 </p>
<script type="math/tex; mode=display">
\boldsymbol{u}(\mathrm{t})=\frac{1}{3}\left[\begin{array}{l}
2 \\
1
\end{array}\right]+\frac{1}{3} e^{-3 t}\left[\begin{array}{c}
1 \\
-1
\end{array}\right]</script><p>前一项为稳态状态，后一项随着时间衰减。 </p>
<p>稳定性：并不是所有的系统都会达到稳态，矩阵的特征值会告诉我们$\boldsymbol u(t)$的发展趋势。</p>
<ul>
<li><strong>Stability(稳定性)：</strong>$\mathrm{Re}(\lambda) &lt; 0$，则有$\boldsymbol u(t) \to 0$（支配稳定性的是实部，虚部的作用是在单位圆上转圈。）</li>
<li><strong>Steady State(稳态)：</strong>有一个特征值为0，并且其它所有的特征值实部为负数$\mathrm{Re}(\lambda) &lt; 0$。</li>
<li><strong>Bolw Up(不收敛)：</strong>至少有一个特征值满足$\mathrm{Re}(\lambda) &gt; 0$，则发散。</li>
</ul>
<p>如果二阶矩阵<script type="math/tex">\boldsymbol{A}=\left[\begin{array}{ll} a & b \\ c & d\end{array}\right]</script>的两个特征值实部为负数，则矩阵的迹$a+d$也是负数。反之并不一定成立，例如矩阵<script type="math/tex">\left[\begin{array}{cc} -2 & 0 \\ 0 & 1\end{array}\right]</script>的迹为-1，但是一个特征值为1。如果二阶矩阵的行列式为正而迹为负，则解为收敛的。 </p>
<p>在方程<script type="math/tex">\dfrac{\mathbf d \boldsymbol {u}}{\mathbf d \boldsymbol t}=\boldsymbol{A} \boldsymbol {u}</script>中，是矩阵$\boldsymbol A$使得不同分量之间相互耦合(<font color="red">我们的方程表明两个变量相互耦合，特征值和特征向量的作用就在于可以实现<strong>解耦</strong>（又称对角化）</font> )。令$\boldsymbol {u=Sv}$其中$\boldsymbol S$是由矩阵$\boldsymbol A$的特征向量组成。则有： </p>
<script type="math/tex; mode=display">
\boldsymbol{S} \frac{\mathrm d \boldsymbol{v}}{\mathrm d t}=\boldsymbol{A} \boldsymbol{S} \boldsymbol{v} \Rightarrow \frac{\mathrm d \boldsymbol{v}}{\mathrm d t}=\boldsymbol{S}^{-1} \boldsymbol{A} \boldsymbol{S} \boldsymbol{v}=\boldsymbol{\Lambda} \boldsymbol{v}</script><p>新的方程不再耦合，则方程组的对角线为： <script type="math/tex">\dfrac{\mathrm d v_{i}}{\mathrm d t}=\lambda_{i} v_{i}</script>，方程组的通解为： </p>
<script type="math/tex; mode=display">
\boldsymbol{v}(t)=e^{\boldsymbol{\Lambda} t} \boldsymbol{v}(0), \quad \boldsymbol{u}(t)=\boldsymbol{S} e^{\boldsymbol{\Lambda} t} \boldsymbol{S}^{-1} \boldsymbol{u}(0)=e^{\boldsymbol{A} t} \boldsymbol{u}(0)</script><h4 id="23-2-矩阵指数函数-Matrix-exponential-e-boldsymbol-At"><a href="#23-2-矩阵指数函数-Matrix-exponential-e-boldsymbol-At" class="headerlink" title="23.2 矩阵指数函数 Matrix exponential $e^{\boldsymbol At}$"></a>23.2 矩阵指数函数 Matrix exponential $e^{\boldsymbol At}$</h4><p>我们可以用幂级数的公式： </p>
<script type="math/tex; mode=display">
e^{x}=\sum_{n=0}^{\infty} \frac{x^{n}}{n !}=1+x+\frac{x^{2}}{2}+\frac{x^{3}}{6}+\cdots</script><p>来定义矩阵型指数运算$e^{\boldsymbol At}$：</p>
<script type="math/tex; mode=display">
e^{\boldsymbol{A} t}=I+\boldsymbol{A} t+\frac{(\boldsymbol{A} t)^{2}}{2}+\frac{(\boldsymbol{A} t)^{3}}{6}+\cdots</script><p>如果$\boldsymbol At$的特征值很小，满足收敛条件$|\lambda({\boldsymbol At})|&lt;1$，则可以用几何级数来定义矩阵型指数： </p>
<script type="math/tex; mode=display">
\frac{1}{1-x}=\sum_{n=0}^{\infty} x^{n} \rightarrow(I-\boldsymbol{A} t)^{-1}=I+\boldsymbol{A} t+(\boldsymbol{A} t)^{2}+(\boldsymbol{A} t)^{3}+\cdots</script><p>前文中我们已经写出了矩阵指数函数的公式$e^{\boldsymbol At} = \boldsymbol {Se^{\Lambda t}S^{-1}}$。如果矩阵$\boldsymbol A$具有$n$个线性无关的特征向量，我们可以从幂级数定义的矩阵指数公式来再次验证： </p>
<script type="math/tex; mode=display">
\begin{aligned}
e^{\boldsymbol{A} t} &=I+\boldsymbol{A} t+\frac{(\boldsymbol{A} t)^{2}}{2}+\frac{(\boldsymbol{A} t)^{3}}{6}+\cdots \\
&=\boldsymbol{S} \boldsymbol{S}^{-1}+\boldsymbol{S} \boldsymbol{\Lambda} \boldsymbol{S}^{-1} t+\frac{\boldsymbol{S \Lambda}^{2} \boldsymbol{S}^{-1}}{2} t^{2}+\frac{\boldsymbol{S} \boldsymbol{\Lambda}^{3} \boldsymbol{S}^{-1}}{6} t^{3}+\cdots \\
&=\boldsymbol{S}\left(I+\boldsymbol{\Lambda} t+\frac{\Lambda^{2}}{2} t^{2}+\frac{\Lambda^{3}}{6} t^{3}+\cdots\right) \boldsymbol{S}^{-1} \\
&=\boldsymbol{S} e^{\boldsymbol{\Lambda} t} \boldsymbol{S}^{-1}
\end{aligned}</script><p>能够对角化的矩阵都可以表示为上式。 </p>
<script type="math/tex; mode=display">
e^{\boldsymbol{\Lambda} t}=\left[\begin{array}{cccc}
e^{\lambda_{1} t} & 0 & \cdots & 0 \\
0 & e^{\lambda_{2} t} & & 0 \\
\vdots & & \ddots & \vdots \\
0 & \cdots & 0 & e^{\lambda_{n} t}
\end{array}\right]</script><p><img src="https://pic.imgdb.cn/item/62709bcb239250f7c5026d84.jpg" style="zoom:50%"></p>
<p><img src="https://pic.imgdb.cn/item/62709c1d239250f7c503214b.jpg" style="zoom:55%"></p>
<h4 id="23-3-二阶微分方程-Second-order-differential-equations"><a href="#23-3-二阶微分方程-Second-order-differential-equations" class="headerlink" title="23.3 二阶微分方程 Second order differential equations"></a>23.3 二阶微分方程 Second order differential equations</h4><p>我们可以将二阶微分方程$y’’ + by’ + ky = 0$转化为$2\times2$的一阶问题进行处理，构造方法类似于我们对斐波那契数列的处理方法。 </p>
<p> 令<script type="math/tex">\boldsymbol {u}=\left[\begin{array}{l} y^{\prime} \\ y\end{array}\right]</script>，则有</p>
<script type="math/tex; mode=display">
\boldsymbol{u}^{\prime}=\left[\begin{array}{l}
y^{\prime \prime} \\
y^{\prime}
\end{array}\right]=\left[\begin{array}{cc}
-b & -k \\
1 & 0
\end{array}\right]\left[\begin{array}{l}
y^{\prime} \\
y
\end{array}\right]</script><p>如果是$k$阶微分方程，那么需要一个$k \times k$矩阵，除了第一行和对角线下面一排斜线上的元素之外，这个系数矩阵其它元素均为0。 </p>
<h3 id="第二十四-马尔可夫矩阵和傅里叶级数"><a href="#第二十四-马尔可夫矩阵和傅里叶级数" class="headerlink" title="第二十四 马尔可夫矩阵和傅里叶级数"></a>第二十四 马尔可夫矩阵和傅里叶级数</h3><p><font color="red"><strong>两者是关于特征值和投影矩阵的应用</strong></font>。</p>
<h4 id="24-1-马尔可夫矩阵-Markov-matrices"><a href="#24-1-马尔可夫矩阵-Markov-matrices" class="headerlink" title="24.1 马尔可夫矩阵 Markov matrices"></a>24.1 马尔可夫矩阵 Markov matrices</h4><h5 id="一-定义"><a href="#一-定义" class="headerlink" title="(一) 定义"></a>(一) 定义</h5><p>若某一矩阵$\boldsymbol A$，其所有元素非负，且每列的元素加和为1的矩阵被称为马尔可夫矩阵。马尔可夫矩阵主要应用在概率领域。将一个马尔可夫矩阵进行方幂运算得到的矩阵仍旧是马尔可夫矩阵。例如：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}=\left[\begin{array}{ccc}
0.1 & 0.01 & 0.3 \\
0.2 & 0.99 & 0.3 \\
0.7 & 0 & 0.4
\end{array}\right]</script><p>由23讲可知：当处理一个微分方程问题时，特征值0意味着得到一个稳态。但当进行矩阵的方幂运算时，特征值给出稳态的条件包括： </p>
<ul>
<li><strong>条件1：</strong>$\lambda_1 = 1$是矩阵的特征值之一</li>
<li><strong>条件2：</strong>$|\lambda_i| &lt; 1$其它特征值的绝对值都比1小 </li>
</ul>
<p><strong>条件1和条件2 是马尔可夫矩阵的特征值的特点。</strong></p>
<p>如果矩阵具有$n$个线性无关的特征向量，则有： </p>
<script type="math/tex; mode=display">
\boldsymbol{u}_{k}=\boldsymbol{A}^{k} \boldsymbol{u}_{0}=c_{1} \lambda_{1}{ }^{k} \boldsymbol{x}_{1}+c_{2} \lambda_{2}{ }^{k} \boldsymbol{x}_{2}+\ldots+c_{n} \lambda_{n}{ }^{k} \boldsymbol{x}_{n}</script><p>如果$\lambda_1 = 1$并且其他的特征值都小于1，则系统在$k$增大过程中趋近于$\boldsymbol u_0$的分量$c_1 \boldsymbol x_1$，即给出了一个稳态状况。这里特征向量$\boldsymbol x_1$的每一分量都是正的，因此若初始值为正，则最终的稳态也是正的。</p>
<p>Markov矩阵每一列的元素加和为1这个条件，保证了矩阵具有1这个特征值。</p>
<script type="math/tex; mode=display">
\boldsymbol{A}-\boldsymbol{I}=\left[\begin{array}{rrr}
-0.9 & 0.01 & 0.3 \\
0.2 & -0.01 & 0.3 \\
0.7 & 0 & -0.6
\end{array}\right]</script><p>从每一列减去1，则每列的加和都从1变为0。这时候行向量相加的结构就是$\boldsymbol 0$向量，因此行向量线性相关，矩阵为奇异矩阵。矩阵$\boldsymbol A$有特征向量在$\boldsymbol{A-I}$的零空间中，其对应的特征值为1。回代计算可得<script type="math/tex">\boldsymbol {x}_1=\left[\begin{array}{l} 0.6 \\ 33 \\ 0.7\end{array}\right]</script>。</p>
<p><strong>转置矩阵的特征值：</strong>转置矩阵$\boldsymbol A^{\mathrm T}$具有和原矩阵$\boldsymbol A$相同的特征值。 </p>
<script type="math/tex; mode=display">
(\boldsymbol A - \lambda \boldsymbol I)^{\mathrm T} = \boldsymbol A^{\mathrm T} -  \lambda \boldsymbol I</script><p>则由行列式的性质10可知：$\det(\boldsymbol A - \lambda \boldsymbol I) = \det(\boldsymbol A^{\mathrm T} -  \lambda \boldsymbol I)$。如果$\lambda$是矩阵$\boldsymbol A$的特征值，则其满足$\det(\boldsymbol A^{\mathrm T} -  \lambda \boldsymbol I) = 0$，因此它也是转置矩阵$\boldsymbol A^{\mathrm T}$的特征值。但是两者特征向量有所区别，<strong>零空间不等同于左零空间</strong>。</p>
<h5 id="二-例子——人口流动"><a href="#二-例子——人口流动" class="headerlink" title="(二) 例子——人口流动"></a>(二) 例子——人口流动</h5><p>用马尔可夫矩阵来研究人口流动问题：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
u_{\text {Cal }} \\
u_{\text {Mass }}
\end{array}\right]_{t=k+1}=\left[\begin{array}{cc}
0.9 & 0.2 \\
0.1 & 0.8
\end{array}\right]\left[\begin{array}{c}
u_{\text {Cal }} \\
u_{\text {Mass }}
\end{array}\right]_{t=k}</script><p>方程中$\boldsymbol u$的分量分别代表加州和麻省的人口，矩阵中的每一列中元素代表着人口去留比例，比如第一列$0.9$表示留在加州的人口占加州人口的$90\%$，而$10\%$进入麻省，第二列中由麻省进入加州的人口占麻省的$20\%$，而$80\%$选择留在麻省。如果取初值<script type="math/tex">\left[\begin{array}{c} u_{\text {Cal }} \\ u_{\text {Mass }} \end{array}\right]_{0}=\left[\begin{array}{c} 0 \\ 1000\end{array}\right]</script>，则经过一次迁徙<script type="math/tex">\left[\begin{array}{c} u_{\text {Cal }} \\ u_{\text {Mass }} \end{array}\right]_{1}=\left[\begin{array}{cc} 0.9 & 0.2 \\ 0.1 & 0.8\end{array}\right]\left[\begin{array}{c} 0 \\ 1000\end{array}\right] = \left[\begin{array}{c} 200 \\ 800\end{array}\right]</script>。</p>
<p>为了获取长时间后的人口分布，我们需要了解矩阵的特征值和特征向量。因为这是马尔可夫矩阵，所以有一个特征值1，则另一个特征值为$0.9+0.8-1=0.7$。可以求得<script type="math/tex">\boldsymbol {x}_1=\left[\begin{array}{l} 2 \\ 1 \end{array}\right], \boldsymbol {x}_2=\left[\begin{array}{l} 1 \\ -1 \end{array}\right]</script>，从$\boldsymbol x_1$可知最后的稳态为加州人口$2/3$，麻省人口$1/3$。 通解为： </p>
<script type="math/tex; mode=display">
\boldsymbol{u}_{k}=c_{1}\left[\begin{array}{l}
2 \\
1
\end{array}\right]+c_{2}(0.7)^{k}\left[\begin{array}{c}
-1 \\
1
\end{array}\right]</script><p>可以从$\boldsymbol u_0$解得$c1=1000/3$、$c2=2000/3$。 </p>
<h4 id="24-2-傅里叶级数和投影矩阵-Fourier-series-amp-Projections"><a href="#24-2-傅里叶级数和投影矩阵-Fourier-series-amp-Projections" class="headerlink" title="24.2 傅里叶级数和投影矩阵 Fourier series &amp; Projections"></a>24.2 傅里叶级数和投影矩阵 Fourier series &amp; Projections</h4><p>如果有一组标准正交基为$\boldsymbol q_1，\boldsymbol q_2, \dots, \boldsymbol q_n$，则任意向量$\boldsymbol v$可以写成： </p>
<script type="math/tex; mode=display">
\boldsymbol{v}=x_{1} \boldsymbol{q}_{1}+x_{2} \boldsymbol{q}_{2}+\ldots+x_{n} \boldsymbol{q}_{n}</script><p>因为当$i，j$不相等时有$\boldsymbol q_1^{\mathrm T}\boldsymbol q_2$。因此有</p>
<script type="math/tex; mode=display">
\boldsymbol{q}_{i}^{T} \boldsymbol{v}=x_{1} \boldsymbol{q}_{i}^{T} \boldsymbol{q}_{1}+x_{2} \boldsymbol{q}_{i}^{T} \boldsymbol{q}_{2}+\ldots+x_{n} \boldsymbol{q}_{i}^{T} \boldsymbol{q}_{n}=x_{i}</script><p>我们得到了分量$x_i$的公式：$x_i = \boldsymbol q_i^{\mathrm T} \boldsymbol v$。</p>
<p>因为<script type="math/tex">\boldsymbol{v}=\left[\begin{array}{lll} \boldsymbol{q}_{1} & \cdots & \boldsymbol{q}_{n} \end{array}\right]\left[\begin{array}{c} x_{1} \\ \vdots \\x_{n}\end{array}\right]</script>，即$\boldsymbol v = \boldsymbol {Qx}$，所以$\boldsymbol x = \boldsymbol Q^{-1} \boldsymbol v$，<strong>因为$\boldsymbol Q$为<font color="red">正交矩阵</font>，所以有</strong>$\boldsymbol Q^{-1} = \boldsymbol Q^{\mathrm T}$，可得$\boldsymbol x = \boldsymbol Q^{\mathrm T} \boldsymbol v$ 。这与我们之前得到的$x_i = \boldsymbol q_i^{\mathrm T} \boldsymbol v$完全相同。这里给出了求分量的思路就是用空间的一组标准正交基去点乘目标向量，利用其标准正交的性质得到所求。</p>
<p>标准正交是此处的核心概念。而傅里叶级数也是在这个概念上构建的。我们可以对任意函数做傅里叶展开，得到表达式： </p>
<script type="math/tex; mode=display">
f(x)=a_{0}+a_{1} \cos x+b_{1} \sin x+a_{2} \cos 2 x+b_{2} \sin 2 x+\cdots</script><p>与之前的有限个标准正交向量组成的正交矩阵不同，这个空间是无限维，它的一组基是：</p>
<script type="math/tex; mode=display">
1, \cos x, \sin x, \cos 2x, \sin 2x, \dots</script><p>此处的正交概念与$R^n$空间不同，点积的概念也不同。 </p>
<ul>
<li>向量正交：<script type="math/tex">\boldsymbol{v}^{T} \boldsymbol{w}=v_{1} w_{1}+v_{2} w_{2}+\ldots+v_{n} w_{n}</script></li>
<li>函数正交：$f^{T} g=\int_{0}^{2 \pi} f(x) g(x) d x$</li>
</ul>
<p>计算基$\sin x$和$\cos x$的点积可以验证其正交性。 </p>
<p>采用和标准正交基相同的策略可以得到傅里叶变换的参数。 </p>
<script type="math/tex; mode=display">
\begin{aligned}
\int_{0}^{2 \pi} f(x) \cos x d x &=\int_{0}^{2 \pi}\left(a_{0}+a_{1} \cos x+b_{1} \sin x+a_{2} \cos 2 x+\cdots\right) \cos x d x \\
&=0+\int_{0}^{2 \pi} a_{1} \cos ^{2} x d x+0+0 \cdots \\
&=a_{1} \pi
\end{aligned}</script><p>可以得到：</p>
<script type="math/tex; mode=display">
a_{1}=\frac{1}{\pi} \int_{0}^{2 \pi} f(x) \cos x d x</script><p>同理可以求得其它参数。 </p>
<hr>
<p>参考笔记：<a href="https://blog.csdn.net/herosunly?type=blog">https://blog.csdn.net/herosunly?type=blog</a></p>
<p>笔记链接：<a href="https://blog.csdn.net/qq_16829085/article/details/102908029">https://blog.csdn.net/qq_16829085/article/details/102908029</a></p>
<p>MIT 公开课：Gilbert Strang《线性代数》课程笔记（汇总）<a href="https://blog.csdn.net/xhf0374/article/details/63250083">https://blog.csdn.net/xhf0374/article/details/63250083</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>数学基础</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>本质问题</tag>
        <tag>线代</tag>
      </tags>
  </entry>
  <entry>
    <title>我的观影</title>
    <url>/2022/02/12/MyFilm/</url>
    <content><![CDATA[<h3 id="一、鬼子来了【22-02-11】"><a href="#一、鬼子来了【22-02-11】" class="headerlink" title="一、鬼子来了【22-02-11】"></a>一、鬼子来了【22-02-11】</h3><p><a target="_blank" href="https://movie.douban.com/subject/1291858/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">鬼子来了 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/1291858/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1Wx41157LP" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/69b07d9131be3f5dcd1fc1ea0bf33e44ce3e4613.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:20:54</span>
            </div>
            <div class="bvideo-info">
                <p class="title">细读经典 20: 真正的抗日神片《鬼子来了》</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>134.5万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>7937</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">电影最TOP</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<p><strong>转载影评：</strong></p>
<p>终于看了姜文被禁止公映的《鬼子来了》，很多人都将这部片子的禁止公映解说为该片中绝口不提共产党抗日，自始至终未出现一个党员形象，因此而引起不满。但看了这部片子才知道决不是因为这个原因。</p>
<p>《鬼子来了》讲的是川北抗战的故事，在那个叫挂甲台的小村落里老百姓无知的固守着自己的善良，却悲惨的被鬼子集体屠杀。而且这场大屠杀发生在日本天皇发表投降诏书之后！中国的农民是淳朴而且安于现状的，他们被诸多的势力欺压了两千年，形成的秉性却温顺贤良。可以想见，当小鬼子们没有进行烧杀戮掠的时候，老百姓虽然会心有不甘，但真的是尚不至于奋起以命相搏（并不是说老百姓就不爱国，而是在那样一个自给自足、封闭且未开化的时期里，“爱国”还是一个虚幻的理念）。片中有大量的这样的痕迹，在那个被日军牢牢把持的小地方，因为没有国军和共军的争夺而显得相对安宁，小日本对当地人进行着和平的奴役。习惯了被压迫的老百姓已经对于尊严的事情麻木了，为了生计这样的眼前利益而过分乐观的活着。小镇上唱曲的在集市上宣扬着皇道乐土，教育众人中日“八百年前是一家”，村落里老百姓见了鬼子一口一个“森塞”的叫着。固执的不肯杀人的村民们为了结果被俘的鬼子，费尽周折请刀斧手，最终得到的结论是这鬼子命不该绝。并最终同意了鬼子用人换粮的建议。</p>
<p>烧杀掳掠外加奸淫妇女，这是鬼子留在中国人心目中固有的形象。但在这部片中的开始，虽然老百姓见了鬼子依然是战战兢兢有着被杀的危险，但小鬼子们仅是打骂并未随意杀人。不过，小鬼子们的武士道精神和对中国人的残忍施暴的一面却被生动形象的刻画出来。两个场景就可以进行完全的阐释： </p>
<ul>
<li>一、炮楼里的两个鬼子溜出来想吃鸡，老兵教新兵如何粗暴的对待中国人，如何利用自己手中的刺刀，并说“对付支那猪就只有用这种办法”； </li>
<li>二、被囚半年兽性冷却后的小三郎在所谓的鬼子＋百姓的联欢中得意忘形，对中国人大声说着“大哥大嫂过年好，你是我的爷，我是你的儿”，但明显喝高了的他在队长一番激励下，兽性大发对养活了他半年的村民们举起了屠刀。</li>
</ul>
<p>凡中国人与外族的殊死争斗，敌阵中必有我国人！这简直是个千古不变的道理！汉武帝征讨匈奴，有前宫人在匈奴王帐中出谋划策；抗日战争中更是伪军比日寇数量都多！这部片子中着重刻画了翻译这个角色，这个懂日本话的东北人几乎没有一句是在“直译”，国人对国人的欺瞒才是最可悲的事情。而且这个翻译在被村民释放后居然给鬼子队长出主意让鬼子爽约，结果招来一句奚落：“我们日本人不像你们中国人那样不讲信用。”这句话对我来说真的是太刺耳了。</p>
<p>悲剧就是把美好的东西打碎给人看。这部片子的结局是挂甲台整个村落在大火中消失在鬼子的屠刀下，而国军的抗战将领又让斧劈日本战俘的三儿受戮于已经被俘的小鬼子。这就是中国人的悲哀。为什么这样一个国土辽阔人口众多的民族被一个岛国践踏了整整八年，这部片子给了我们一定的启示。很多时候，不是别人的凶残和强大，而是我们自己的愚昧和自残。</p>
<p>从联合早报网上看到消息，东京举行了一个反华游行，理由是中国还没有对去年4月份爆发的反日游行向日本人道歉。不明白为什么这个世界上还有如此不讲道理的人种，但是毕竟有这样的邻居，有惨痛的教训，我们只能用《霍元甲》中的那句震撼的台词一样——“自强不息”！ </p>
<blockquote>
<p>作者：豆瓣用户——俩飞</p>
<p>原文链接：<a href="https://movie.douban.com/review/1045537/">https://movie.douban.com/review/1045537/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="二、爆裂鼓手【22-02-15】"><a href="#二、爆裂鼓手【22-02-15】" class="headerlink" title="二、爆裂鼓手【22-02-15】"></a>二、爆裂鼓手【22-02-15】</h3><p><a target="_blank" href="https://movie.douban.com/subject/25773932/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">爆裂鼓手 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/25773932/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1XK4y1a7gC" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/d383ead9dc036edb5b562e10ae2bd7b1ab0d8147.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:31:21</span>
            </div>
            <div class="bvideo-info">
                <p class="title">细读经典 103: 豆瓣8.7，暗黑励志神作《爆裂鼓手》</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>136.2万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>1.1万</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">电影最TOP</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<p><strong>转载影评：</strong></p>
<p>作为今年圣丹斯的获奖影片和奥斯卡热门，影片的上佳口碑主要来自于紧凑的剪辑、优质的表演和对于师徒关系非常规的刻画。诚然，影片的剪辑凌厉而准确，除结尾处有少许松懈，整部电影更像是一部动作悬疑片，节奏一再加快，冲突一再升级，影片结束，107分钟不知不觉中过去。影片对于音乐的处理也相当不马虎，体现了对于细节的重视和专业精神。</p>
<p>然而，如果将电影解读为描绘师徒关系，以及少年经历魔鬼训练，超越极限，从而实现自我的励志电影，大概是个误会。片中鼓手和指挥从始至终是纯粹的互相利用关系。鼓手其实从未得到特殊待遇——他始终是乐队中和其他乐手一样微不足道的一员，随时被指挥予取予求，玩弄于鼓掌之间。在鼓手坦陈指挥对于乐队的虐待，间接导致指挥离职之后，酒吧相遇，看似一番肺腑之言，实际上指挥已暗暗设计陷害，如若没有鼓手最后的破釜沉舟，一个乐手的生涯就要万劫不复（影片一再强调在卡内基演出对于音乐生涯的决定性作用）。即使仇人之间，若有一丁点原则和不忍，做事尚不会如此残忍，何况师徒。</p>
<p>鼓手本身也并非传统的善良天才少年。一定的才华和逼迫自己到极限的决心也许天才少年皆有，但是本片主角个性中的偏执和阴暗才是他一直被指挥吸引，也是指挥最后透露出欣赏的主因——鼓手一定程度是年轻版本的指挥，同样为达目的不择手段。影片中有诸多巧合，其中鼓手丢失首席鼓手让他代为保管的乐谱一节，其实颇值得思量。鼓手是否真的如观众期待那样无辜？未必。台词给出许多暗示：首席为自己辩解时说自己因身体有恙不能记谱，指挥早就知晓（那么其他乐手自然也知道）。鼓手在事发之后毫无愧疚，也从未想过补偿。键盘手似开玩笑让鼓手不要动自己的谱子，未必不是防人之心，等等。鼓手在争夺首席位置、与女友分手和佯作无辜答应指挥帮助演出时也同样毫无愧怍。因为同样认同追求卓越就要牺牲自我、他人，以至阻碍道路的一切，鼓手才会被指挥一番话吸引从而上钩，因为指挥的人生哲学实际道出了鼓手的心声。整部影片细述了鼓手从安德鲁到弗莱彻的渐变，最后一幕父亲在后台观看鼓手的独奏，眼神中惊恐多于欣慰，因为眼前的少年早已不是曾经一起吃爆米花开玩笑的儿子，技术上的提升和人性的嬗变相比已经显得次要。</p>
<p>本片导演说结尾实际是悲剧，主要媒体的影评也多少在这一点达到共识，大概正是为此。片中固然有励志的成分，但是成功的代价是少年纯真的丧失，如果本来尚有纯真的话。结尾高潮处影院中的观众畅然拊掌，其实是庆祝这种扭曲哲学的胜利——鼓手大概经此洗礼，从此更加坚定目标，不顾旁人，不择手段，从而一帆风顺。更可怕的是，等他自己成为别人的老师，恐怕也要把这样的哲学传递下去了。相对于严师是否定出高徒、学艺之路如何逼迫自我突破极限这类常规主题，影片提出的问题更集中于追求极致（无论目标是艺术的完美还是名利的丰收，也无论是否关于音乐）和葆有灵魂的平衡取舍。</p>
<blockquote>
<p>作者：豆瓣用户——Z</p>
<p>原文链接：<a href="https://movie.douban.com/review/7265093/">https://movie.douban.com/review/7265093/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="三、寻梦环游记【22-02-17】"><a href="#三、寻梦环游记【22-02-17】" class="headerlink" title="三、寻梦环游记【22-02-17】"></a>三、寻梦环游记【22-02-17】</h3><p><a target="_blank" href="https://movie.douban.com/subject/20495023/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">寻梦环游记 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/20495023/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1pW411e7oF" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/a4840b6079f876e0e31075471d2f9c7e3fca0148.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:15:49</span>
            </div>
            <div class="bvideo-info">
                <p class="title">【木鱼微剧场】《寻梦环游记》</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>115.9万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>4647</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">木鱼水心</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<p><strong>转载影评：</strong></p>
<p>5星推荐，片子真的好看，适合全年龄层。孩子们可以看到梦想，看到童趣，看到动画乐园一般的亡灵世界。大人可以看到亲情，看到爱情，看到梦想与责任，看到人性善恶。老年人会更感动吧，家人就是要生活在一起，要互相体谅，互相扶持。</p>
<p>最令我感动的一幕是，小孩回到家，他的太奶奶要去世了，忘记了亲人。小孩弹吉他唱起了“请记住我”，歌声响起，我的眼泪跟着落下。老奶奶眼睛亮起，跟着唱出来，亲人还在我们心里。</p>
<p>电影构建的死后世界很华丽，美轮美奂，就象一个巨大的游乐场。亡灵们很萌，白骨间的随意组合带来各种意料之外的笑点，不恐怖反倒很有趣。这个世界建立在另一个活人世界的记忆上，凡是在世的人记得的有照片的人，就可以在亡灵世界存在，反之就彻底消亡。所以一个家族代代传承的记念和供奉，会让家族中死去的人在另一个世界快乐的永生。</p>
<p>鲁迅说，亲人或余悲，他人亦已歌。确实，当人们不再记得一个人，他就真的消失了。如果世界的规律真是如此，我们活着的时候就应该更善意，更有责任感，更关爱家庭，关爱亲人，大家更团结，影响更多的人，这样当我们死去时，才会被人纪念，才会一直活在亲人和世人的心里。</p>
<p>看了电影，很希望亡灵世界就是这样的，我们的亲人也快乐的在。</p>
<p>另：这个逻辑基础下，还是当名人划算，你看电影里那个歌手，明明是个坏人，死后几十年了，还有无数的歌迷送无数的礼物，可以在亡灵世界风生水起。按这个设想一下，大魔头类的，会不会也因为被无数人记住而永生呢。</p>
<blockquote>
<p>作者：豆瓣用户——雪</p>
<p>原文链接：<a href="https://movie.douban.com/review/8999006/">https://movie.douban.com/review/8999006/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="四、催眠大师【22-02-23】"><a href="#四、催眠大师【22-02-23】" class="headerlink" title="四、催眠大师【22-02-23】"></a>四、催眠大师【22-02-23】</h3><p><a target="_blank" href="https://movie.douban.com/subject/24743711/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">催眠大师 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/24743711/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1ut411X7cR" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/14aea911bef6e21f58ee7a71b81da29234ccc59e.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:25:21</span>
            </div>
            <div class="bvideo-info">
                <p class="title">【木鱼微剧场】优秀国产悬疑电影《催眠大师》</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>134.3万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>7770</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">木鱼水心</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<p><strong>转载影评：</strong></p>
<p>今天电影催眠大师上映了，凑了个热闹，第一时间看到这部电影的公映，以国产电影的水准，应该算得上一部‘好电影’了，悬疑+惊悚，不仔细推敲的话，应该是勉强达到了观众的期待值。同时，电影里运用了大量的催眠理论和催眠技术，并且做了艺术的夸张，相信一定让很多观众迷惑，怀疑，不解，让人感觉玄之又玄，虚之又虚。本文，笔者就根据所学的有限的催眠知识，免费给这部电影做一次答疑解惑，也尽自己的一份力解除电影对于催眠术的误导。解释过程尽量做到不剧透吧，免得被喷！</p>
<p>首先科普一下催眠的几个深度，最广泛接受的划分方法是将催眠程度分为六个等级：</p>
<p>第一级催眠深度：小肌群受到暗示被操控，如暗示被催眠对象眼皮睁不开或嘴唇张不开，被催眠者受到暗示无法睁开，被催眠者不感觉被催眠，觉得完全清醒，这阶段已经可以做到减肥、戒烟等心理治疗了。</p>
<p>第二级催眠深度：大的肌群受到暗示，如手臂无法抬起或无法落下。此时被催眠者更加放松，也更加专注与催眠师的指令。</p>
<p>第三级催眠深度：可以完全控制所有的肌肉系统，产生数字阻滞。如无法从椅子上站起来，无法走路，无法说出某个数字，但并不是忘了那个数字，临床催眠师的大部分工作，一般在这前三个等级之内。</p>
<p>第四级催眠深度：开始有失忆现象，被催眠者可以遗忘掉自己的名字，地址，某个数字，并可以产生痛觉阻断，可以做一些手术，拔牙、开刀等。</p>
<p>第五级催眠深度：开始产生梦游状态，产生正性幻觉，可以看到不存在的东西（是真的看到，而不是想象出来的）。 </p>
<p>第六级催眠深度：更新的梦游状态，可以产生负性幻觉，看不见，听不见，确实存在的事物或声音，如暗示被催眠者看不见别人的身体，只能看到头部，那么他就只能看到一个的头。</p>
<p>在影片《催眠大师》中到底达到那个深度，也有人在争议，有人说三级，有人说四级；我认为，至少达到了第五级催眠深度，甚至是第六级，因为被催眠者已经完全不认识自己很熟悉的人（具体情节电影中会交待，此处不详细说的话要剧透），用自己的幻觉代替了现实，这已经完全超出了想像的范畴了。但大多情节中出现的现象达到前三个等级就可以完成，如回忆起以前自己想不起来的事情，跟想象中的人进行对话交流（这在催眠治疗中十分常用，实质是跟自己的潜意识在交流）等，另外，演员在在催眠状态下的表现也符合催眠的状态，如，莫文蔚在催眠状态下产生的眼皮跳动，快速动眼活动，肢体放松，泪水增加，眼白部分变红等等，说明剧组确实注意到了催眠状态下的细节，大家在观看的时候可以留意一下。</p>
<p>最意思是影片中使用的各种催眠技术，种类繁多，甚至可以作为了解催眠技术的一个入门教学了。</p>
<p>先说直接催眠法的技术，首先是眼睛凝视法，影片中使用的道具是怀表，用它的好处是让被催眠者不仅可以凝视重复的摆动，还可以听到单调重复的滴答声， 从而快速导入催眠。影片中的用的凝视法并不限于盯着看怀表，还包括催眠师的眼睛，烟头，笔尘（沈医生在试图催眠徐瑞宁时所用到的）等等，让观众感觉处处有催眠，防不胜防。  </p>
<p>其次是联想法导入催眠的运用，通过让被催眠对象在头脑中产生想象的画面，进而引导他进入更深的催眠状态，这个想像的画面，既可以是对象凭空创造的一个形象或场景，也可以是过去记忆中的的一个场景，这种方法在影片中使用的次数也非常多，如果有兴趣，大家在观影过程中也可以注意一下。</p>
<p>再次是反复加深技术，这种技术的做法就是不断引发被催眠对象唤醒，再不断地导入催眠，从而让对象进入更深的催眠状态，影片中徐峥和莫文蔚不断的互相催眠，又不断的唤醒，再不断的进入催眠……实质上确实使用了这种反复加深技术，不知道是剧情的需要，还是编剧越催眠技术的特意安排。这也是我很喜欢用的一个技术，效果很好，在催眠中，把对象唤醒调整下身体的姿势，反馈一下感受，接着再导入催眠，可以避免被催眠对象长时间保持一个姿势造成的肌肉疲劳。</p>
<p>然后再说一下间接催眠，这是影片中让观众感觉比较玄乎的地方，在影片中叫做清醒催眠，也有人叫做隐性催眠；就是让人在清醒状态下，通过交流谈话或者环境暗示，让对象在不知不觉中进入催眠状态。整个影片框架也是在这种理论的基础上搭建的，为了让观众了解这种催眠技术，影片还特意让主人公对这种理论做了一个讲解，给剧情的勾画做了一个铺垫。如，影片中多次用到了环境的暗示，通过水，声音、光线等，或某一个词语（如影片中用到的“船长”），让对象不知不觉中产生联想和回忆，从而再进一步导入催眠。</p>
<p>另外，影片中有这样的一个比较的高级催眠技术是：混乱技术。该技术的原理是，通过一些异乎寻常的语言，动作，表情等，让被催眠对象短时间内接受大量的信息，造成信息过载，引发神经失衡，触发战斗或逃跑反应（Fight-or-flight response），绕过对象的意识评判区，从而导入催眠。仔细分析一下，影片中一直在使用这种技术，如，影片中心理咨询室故意布置得非常怪异，无形中给予被催眠对象一些混乱；催眠师故意把怀表掉在地上，也是一种混乱；来访者任小妍怪异的心理行为本身就是一种混乱，突然去拨弄钟表指针，突然把水泼出来等都是一种混乱技术的应用，以及从其他咨询师传来的大量信息，也加强了这种混乱，所以，对象没有理由不进入催眠状态了。</p>
<p>当然，能把这种隐性催眠技术运用的如此娴熟，绝非等闲之辈所能及，我想，即使催眠大师艾瑞克森还在世的话，也未必能做到。</p>
<p>现在问题来了，现实中，到底有没有可能做到影片中那样的催眠？我的答案是，有可能。但前期必须做大量的铺垫工作，我不可能在一次咨询过程中做到这样的效果。说到这里，不得不提及另外一种心理技术技术，这就是“心锚”的建立。所谓“心锚”，就是人的内心某一心理状态或行与另外某一动作或表情之间的锚定，它的基础是条件反射。比如开车时看到红灯就不自觉的踩刹车，这就是一种“心锚”。影片中，被催眠对象，一看到有节律的“一，二，三”运动形式就会被催眠，如听到数数123，看烟头有节律的3次一熄一灭，三次晃动水杯，拨动三下钟表针等都能迅速地导入催眠状态，要实现这种简单的瞬间催眠，一般就需要“心锚”的建立，而建立这样的“心锚” 一般还得在催眠状态下，所以这样的“心锚”又称为“催眠后暗示”。</p>
<p>看完影片后，观众还可能有一个担忧，担心自己会不会像影片中那样，某一天被不知不觉的被催眠、被控制，从而说出自己不愿说出的事情，作出自己不愿做的事。其实，大可不必担心，首先，能做到这样快速隐性催眠的催眠师少之又少，凤毛麟角，即使有，也早忙着去某个商业机构都赚大钱去了，恐怕也没有时间闲的蛋疼催眠你玩吧；其次，人在催眠状态下，潜意识的自我保护能力是非常强的，一旦有人要求你做违背个人意愿的事情，很快就能从催眠状态下次苏醒过来。</p>
<p>调查显示，很多普通大众对催眠有很深的误解，认为催眠可以控制人或者让人失去意识进入昏睡状态。因为催眠术早期多用于巫术和宗教等，让它蒙上了一层迷信和神秘的色彩，影片的播出，也可能让许多人加深了这种误解，所以普及和了解一下催眠知识，还是非常有必要的。其实，任何一种催眠状态在平常生活中都出现过，如在睡觉即将清醒或快睡着的时候，突然身体无法动弹，出现‘鬼压床’的现象，就是一种催眠状态；人在某个极度的悲伤或恐惧情绪状态下，眼前突然浮现某个人，就是一种正性幻觉；又如某小美女穿着超短裙去玩，回到家发现青一块，紫一块，什么时候碰的都不知道，这就是一种催眠麻醉状态；有时候时候拿着钥匙找钥匙，拿着电话找手机，或某个东西明明就在桌子上就是找不到，看不见，这就是催眠状态下的一种负性幻觉；所以说催眠一点儿也不神奇。  　　最后再回答一个问题，催眠术可不可能被用于犯罪？答案是可能的！任何一种技术都是一把双刃剑，历史上也确实出现过催眠犯罪的案例，如着名的“海德堡事件”，所以不要轻易找不熟悉的催眠师进行催眠，进行催眠之前最好对催眠师进行一个调查了解，既有利于对催眠师产生信任更好地进入催眠状态，也是一种自我保护。</p>
<p>写这篇文章的过程中，我被催眠了，不知不觉中时间都这么晚了，哈哈哈！有些东西可能说的还不是太清楚，大家有什么问题可以在下面留言，也可以加我QQ：315678525。（吕艳朋，2014年4月29日，于济南宝华苑。） </p>
<blockquote>
<p>作者：豆瓣用户——吕艳朋</p>
<p>原文链接：<a href="https://movie.douban.com/review/6653031/">https://movie.douban.com/review/6653031/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="五、记忆大师【22-02-24】"><a href="#五、记忆大师【22-02-24】" class="headerlink" title="五、记忆大师【22-02-24】"></a>五、记忆大师【22-02-24】</h3><p><a target="_blank" href="https://movie.douban.com/subject/25884801/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">记忆大师 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/25884801/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1Rx411n7He" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/b1c145efca0651dbf279a3ee081504e0d1ea14a6.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:05:00</span>
            </div>
            <div class="bvideo-info">
                <p class="title">【片片】五分钟看懂《记忆大师》，影帝黄渤的“杀人回忆”</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>40.1万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>576</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">小片片说大片</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<p><strong>转载影评：</strong></p>
<p>故事一开始的设定就是和现实不太关联的另外一个国度，我感觉抽取记忆出来的技术就像未来一段时间或许可以发生的，但是后面很多场景又让自己感觉这个又是很接地气的画面，可能是交错未来与现在的交错吧，一些场景选的还是很不错的。</p>
<p>在电影里，可以感觉一个人的记忆对一个人性格影响太大了，在江丰记忆弄错之后，一些举动就变得怪异许多，一个植入的记忆对于一个人的行为的影响是否过大？这个需要推敲一下。朋友们有的说这部电影是比较烧脑的，一路猜测，最后回归到自己第一感觉，沈警官。</p>
<p>故事从零碎的记忆开始，穿插了两段故事，在现实中江丰与妻子有矛盾起冲突，慢慢铺展开来，这一部电影感觉又带有对家暴现象的评价，沈警官对于保护那些避免到家暴女性的态度太过于偏执，最开始怀疑他的原因，来自于去警察局找他的男子他一直不愿意去面对，另外就是去找那个女孩调查时，女孩对他的态度和对他徒弟的态度有点差异。</p>
<p>高潮大概是从被设计之后的江丰怀疑陈姗姗开始，故事开始紧张起来，这里相对来讲精彩了，将所有人的目光吸引到这个凶手可能是女性，又有一点疑问，就是录像中从背影看挺像一个女子，但是从电话到最后，都未再提及这个。</p>
<p>最后是一个美好结局，算是一部烧脑的但又不能细究的悬疑电影吧，还是推荐看看的。对于记忆是否影响人的行为，通过记忆找出凶手，还是保持一个探究之心。 </p>
<blockquote>
<p>作者：豆瓣用户——不懂相负</p>
<p>原文链接：<a href="https://movie.douban.com/review/8536325/">https://movie.douban.com/review/8536325/</a></p>
<p>侵删</p>
</blockquote>
<p> <strong>从狼人杀角度分析记忆大师</strong></p>
<p>先盘狼坑：沈sir金刚狼，拿了警徽，最后时刻发言爆炸；沈sir他爸深水狼；李航发言爆炸的冲锋狼，被沈sir卖了做自己身份。 陈姗姗平民钻了狼坑，又被狼队作为完美抗推位，最后没被推出去晚上被狼人给刀了；李惠兰，首夜吃刀的平民；张代晨划水民但最后跳出来帮女巫挡刀。 江丰女巫，吃夜里信息但是逻辑不行没盘出狼坑，差点把毒撒到被狼人污了一手的陈姗姗身上，还好最后时刻抓住沈sir的发言漏洞又站对了边；徒弟原本是铁站边陈sir的猎人，最后因为沈sir他爸的发言漏洞看出了沈sir是只狼一枪把沈sir给崩了；沈sir他妈，离线预言家。。。</p>
<blockquote>
<p>作者：豆瓣用户——Turkey is done</p>
<p>原文链接：<a href="https://movie.douban.com/review/8510215/">https://movie.douban.com/review/8510215/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="六、我是山姆【22-02-27】"><a href="#六、我是山姆【22-02-27】" class="headerlink" title="六、我是山姆【22-02-27】"></a>六、我是山姆【22-02-27】</h3><p><a target="_blank" href="https://movie.douban.com/subject/1306861/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">我是山姆 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/1306861/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1pA411P7wh" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/7a5f1453a3d4948a8ba5f099886956caa63d7665.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:11:18</span>
            </div>
            <div class="bvideo-info">
                <p class="title">这个父亲只有7岁智商，却治愈了无数正常人，泪点低的请一个人看</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>604.7万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>678</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">贰哥电影</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<p>大概是深夜了，我从手中挑了挑盘，打算安静的找个剧情片看，我挑了一会。衡量再三，选了一部讲述弱智，不健全、低能父亲的这部《我是山姆》放进了DVD机当中。</p>
<p>山姆是一个快乐的人。生活在美国，工作在星巴克，他是一个小时工，拿时薪。那天突然来了一个电话，告诉他马上就快有了，速来医院认领。于是他快乐的飞奔而去。</p>
<p>是一个女孩，他如获至宝，他想这比什么都珍贵，那应该是天上掉下来的钻石，于是他给孩子取名“露西”（《天空中拥有钻石的露西》：披头四的一首曲子）。办完手续，他携子带母出了医院的大门，孩子他妈对山姆说，快看，外星人。山姆一愣，那孩子他妈仓皇的飞奔而去。</p>
<p> 山姆独自拉扯女孩的日子就这么开始了，这日子很惨，惨过1939年的《飘》，但一步步的，他也明白了很多东西：例如婴儿两个小时要喝一次奶；每周例行的电影会，谈心会将要改成不定期的了；苏斯博士的《绿蛋和火腿》是不能给孩子读一辈子的。同时他也获得了很多疑惑，例如为什么有的男人是光头，天空的尽头在哪，夏时令中少的那一个小时去了哪里，露西长的到底是像他还是像孩子他妈？</p>
<p>有一天露西问山姆，我妈还回来吗？山姆冥思后带着苦相答，保罗麦卡特尼（披头四成员）从小就没妈，约翰列侬（同样是披头四成员）也是，所以你注定是一个不平凡的小孩。露西又问，爸，那你是不平凡的吗？是从小就这样？山姆很茫然，可能明白了露西的一语双关。他带着愧意对露西说，对不起。而露西说，这没什么，我们都是幸运的。</p>
<p>当露西7岁的时候，她已经比山姆显得成熟和聪明了，她会读different，而山姆不能。露西要上小学，同时也快过生日了，山姆想，要给她举办一个聚会，在这个聚会他想给露西一个礼物：一张披头四的唱片。</p>
<p>但惊喜终究是没有到来，那场聚会搞砸了，露西看到慌里慌张的山姆瘫在地上，伤心的飞奔而去。</p>
<p>这个家庭面临困境，露西要被别人托管，美国政府的维权组织切入了进来，法庭也来了，他们要剥夺山姆的抚养权，山姆没见过这阵势，又一次陷入了慌张。</p>
<p>还好，他有一群智囊班子，由一群和他一样有一些缺陷的人员组成的智囊班子。他们合伙给山姆推荐了一个本市最牛逼的律师，是600多页的大黄页中筛选的结果，他们甚至细心的告诉了山姆那律师的地址，这让山姆为之一振，兴奋的飞奔而去。</p>
<p>看到这里我想，如果这个故事没有这一刻的神奇，那这就不是戏剧，而是人生了。</p>
<p>这个牛逼律师是一名女性，招牌服饰是高档职业装，高档眼镜压在高鼻梁上面，是极品女强人，当然她个子也不矮。</p>
<p>电影在这一阶段显示出了诡异的蓝，连那个律师的杯子都是蓝蓝的，让人冷峻不已。这个女律师显得很忙，时间就是金钱，一天办八个案子（都收费），甚至忙的亲儿子的电话都必须排在第二线，山姆看到这个情景，不仅一阵慌张，他想，钱怎么办？我不能再当小时工了，我要学个技术，我要学会调卡布奇诺。</p>
<p>在这期间，山姆又飞奔了很多次（在去律师楼和去看露西的路上），有一次看他去看露西的时候，他没有飞好，滑倒了，那手中的蛋糕塌陷了一地，但露西躺在山姆身边，丝毫不会在意，笑得很甜。</p>
<p>一次次山姆的到来，让女律师被同事的白眼和自己的势利心打动了，他对山姆说，好吧 我义务（pro bono）一次，当你律师。山姆很茫然的样子。女律师又换了一个简单词汇，免费（free）。山姆大喜。 接下来就是很诡异地开了很多次庭，电影的底色还是蓝蓝的，也十分冷峻。镜头中大量使用了近角的特写，照在山姆那茫然的额头上，但是山姆挺住了，没有看到汗水顺着他的额头滴落下来，这应该是一种抗争，但天真的山姆应该不能体会到生活何常不是一种抗争呢？</p>
<p>又一次开庭结束，山姆慷慨邀请女律师吃了一顿便饭，他说这顿饭，我来，我义务（pro bono）一次，看山姆学的多快。</p>
<p>人心是肉长的，女律师在一次次与山姆的交流中也学会了很多，例如耐性和聆听。 她发现在这次义务当中，她得到的比山姆还多，他送给了山姆一套西服和一条领带，山姆很开心，要知道当山姆在法庭上看到他的智囊团中的傻小伙A带着一条红领巾一样的蹩脚领带是多么神往。女律师发现当她和山姆在一起的时候，他确实放下了什么叫成功和高档，甚至有一次她哭着告诉山姆，他丈夫泡上了一个比她还要高档完美的女人，她很痛苦。她当着山姆的面，真的是什么都敢说了。</p>
<p>就这么着，日子过去了，露西暂时被一家人收养。在这期间，女律师还是在和不公正的法律抗争，同时也办了离婚；而山姆同时也是在和生活抗争。但好的方向是，山姆升了职，去调卡布奇诺了。</p>
<p>山姆还找了两份兼职，一份是溜狗，这是为了能够离露西近一些。另一份是去必胜客薄饼店当店员，为了多练习一下算数的实际应用，因为最终在法庭上，法官会考山姆，他要证明山姆脑子够用，是一个能精打细算过日子的人。</p>
<p>山姆开始背很多数据，然后一一串联起来，他知道露西暂时住在九号屋，而约翰.列侬是10月9日生的，约翰.列侬的儿子也是10月9号生的，约翰.列侬他妈住在利物浦纽卡斯尔大街9号。他知道这一切不是巧合，他和露西的相遇也不是巧合，天上掉下的钻石就是他的。    </p>
<p>电影就在此刻伴随着山姆的坚持也慢慢的融化了，那冷峻的蓝色调变成了橙色的暖色调，阳光大量的照射在了草地上，木吉他轻松的和弦带出了一场愉快的足球比赛，而最终的胜利者是山姆，露西回到了他的身边。</p>
<p>最后要说的是，1电影原声很好听，很多大牌乐队或歌手翻唱了披头四的经典歌曲作为这个电影的配乐。我个人最喜欢“across the universe”这首。  2 星巴克和必胜客给我的印象彻底改变，我终于知道，其实那只是美国的牛肉面馆子 </p>
<blockquote>
<p>作者：豆瓣用户——饭忒稀</p>
<p>原文链接：<a href="https://movie.douban.com/review/1631458/">https://movie.douban.com/review/1631458/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="七、禁闭岛【22-03-09】"><a href="#七、禁闭岛【22-03-09】" class="headerlink" title="七、禁闭岛【22-03-09】"></a>七、禁闭岛【22-03-09】</h3><p><a target="_blank" href="https://movie.douban.com/subject/2334904/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">禁闭岛 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/2334904/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1zx411879" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration"></span>
            </div>
            <div class="bvideo-info">
                <p class="title">出错了！</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span></span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span></span></span></p>
                <div class="partition">
                    <label class="card-label"></label>
                    <label class="up-label"></label>
                    <label class="up-name"></label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<p>一个相同的事情，两个完全不同的故事。</p>
<p>故事一： Marshal Teddy Daniels 的妻子和孩子因为一场由Andrew Laeddis引起的火灾而致死，他深爱着自己的妻子，深爱着自己的孩子。通过对Andrew Laeddis的调查，他了解到一个叫Ashecliff的精神病院，在shutter island上。随着调查的深入Teddy开始怀疑在这个岛上有不可告人的秘密。  </p>
<p>Teddy 的直觉是对的，shutter island 是一个秘密的思维控制的实验室，他们利用有严重精神问题的病人，企图试验对他们的大脑进行手术，让他们没有感觉，没有记忆，在军事上利用他们。  </p>
<p>实验室需要一个新的病人，他们通过调查发现Teddy Daniels心中有trauma. 这正是Teddy的精神弱点。 他们制造了一个假的病人Rachel的失踪，以调查的名义让Teddy来这个精神病院。 他身边还跟着假装Teddy调查助手的心理学家，Dr. Sheehan，目的是观察他的行为，倾听他的描述，了解他，然后和岛上的主精神分析师Dr. John Cawley从心里上摧毁他。  </p>
<p>上了岛以后，岛上的人让Teddy吃谎称阿斯匹林的药丸，吃他们的烟，从生理上加剧Teddy的幻觉问题。  </p>
<p>Dr Cawley 说Rachel是个精神病人，他淹死了自己的三个孩子，却始终觉得他们还活着。通过仔细的调查，Teddy的失踪根本是不可能的，他开始认识到Rachel的失踪也许是什么阴谋。当他审问一个较“清醒”的病人时，这个女病人故意让Dr. Sheehan，那个假装Teddy助手的帮凶心理学家，去倒水。然后趁这个机会马上写给他“快跑”。 …慢慢的他开始怀疑起自己的助手。  </p>
<p>在牢房里，他偶遇到了自己曾经认识的人George Noyce，他告诉Teddy在灯塔里正进行可怕的脑部实验，告诉他要摆脱自己的幻觉，摆脱trauma, 不能相信自己的助手，不然就永远走不出这个岛～  </p>
<p>从牢房里出来后，Teddy第一时间想去那个Geoge提到的灯塔，Dr. Sheehan以助手的理由跟随。去灯塔的路很有危险，Dr. Sheehan借口离开Teddy跑回去告诉全部人Teddy要发现他们的阴谋了。Teddy 没有去成灯塔，却在一个隐蔽的山洞里遇到了真正的Rachel, 她以前是这里的医生，那些心理学家也曾经想把她变成精神病人，然后进行手术。Rachel告诉了Teddy所有的真相，Teddy意识到他们的阴谋就让自己成为第67号精神病人，可是他仍然相信自己的助手。  </p>
<p>回到精神病院，Teddy的助手消失了，Teddy怀疑岛上的人把他带到灯塔里做脑部手术。Teddy要去救助手。当Teddy到灯塔的时候，Dr Cawley 早以在那里等候他。 故事到达了高潮。  </p>
<p>Dr. Sheehan现身和 Dr. Cawley用各种伪造文件，理性分析说服Teddy他自己本来就是精神病人，已经在这里两年了，在这里不断重复自己来这里是调查Rachel的幻觉。 诱导Teddy相信自己杀害了妻子。因为药物的作用，Rachel的故事结合Dr. Cawley的捏造，Teddy产生了幻觉，自己的妻子杀害了三个孩子，然后自己杀了心爱的妻子。  Teddy为了避免立刻的被lobotomize，暂时承认自己是凶手，是精神病人。 可是最后他无法让自己像一个怪物一样活着，还是决定了一死… 电影以象征脑手术的灯塔作为结束…   </p>
<p>故事二： Teddy其实是第66号病人， 他曾经是一个Marshal, 是的他很爱自己的妻子。 可是周六的一天当他发现得了忧郁症的妻子淹死了自己的孩子时，他心里产生了极大的痛苦，一枪把他的妻子杀死了。  </p>
<p>可是正如一个像弗洛伊德的心理学家Dr. Naehring所说的，Teddy心里有很强的defense mechanism (弗洛伊德术语语境下). 于是Marshal 疯了，被送到了shutter island.  </p>
<p>Marshal 是如此爱自己的妻子，他天天带着那个她送的tie，他经常梦见自己的妻子，和她拥抱在一起。他内心无法接受自己就是杀害心爱妻子的人，于是他幻想出Andrew Laeddis这么个凶手，要追寻他报仇，把自己从一个杀人犯变成了一个追查凶手的英雄。</p>
<p> [对应于 弗洛伊德语境下的 reaction formation]  </p>
<p>Teddy 还将妻子杀害三个孩子的记忆transform到一个幻想出来的病人Rachel身上，其实不是Rachel不想承认自己杀孩子的事实而是Teddy本身就不想承认是妻子淹死了自己的孩子。 </p>
<p>[对应于 弗洛伊德语境下的 projection]  </p>
<p>Teddy还经常梦到原来的纳粹集中营，梦见了杀人，梦见了痛苦，梦见了死亡～ </p>
<p>Teddy 通过对 Rachel和Laeddis的追寻和调查去缓和对妻子的爱，不可杀人的道德，和自己杀妻之间的强烈的矛盾。爱，否定，追忆，痛苦在一个失去理智的心中不断的纠缠和升级。构成电影最感人，怜悯而细腻的一面。  </p>
<p>在这期间Teddy还产生了各种幻觉让自己的追寻和调查合理化。  </p>
<p>Dr. Sheehan两年来一直Teddy的心理医师，希望通过role play慢慢的帮助Teddy 从幻觉中走出来。  </p>
<p>当Teddy 的追寻和调查伤害到岛上的人安全时，在灯塔上，Dr. Sheehan和 Dr Cawley试图把他曾杀妻的真相告诉他。 Teddy被说服了，回忆起了那痛苦的杀妻的一幕。  不久后, Teddy又重新回到自己的幻觉当中，岛上的精神分析师怕他的defense mechanism再对别人造成伤害，于是带他去lobotomize…    </p>
<p>故事一是一个充满了阴谋的惊悚片，Teddy以一个刚强执着的探员的形象，一步步探险。故事的高潮发生在对深刻问题的追问：当所有的理性的分析和证据都导向自己是疯子时，你是相信自己的记忆还是相信“现实”的证据？记忆是什么？判断证据是否应该依靠自己的记忆？  </p>
<p>故事二是一个充满悲悯和柔情的故事。对妻子深深的爱，残酷的杀妻事实，令Teddy在幻觉和现实中苦苦的挣扎。 故事二的美在于用精心设计的梦境去深刻分析和表达Teddy的内心，去诠释弗洛伊德关于defense mechanism，dream，hallucination,trauma的理论。    </p>
<p>而shutter island电影最美的地方在于一个电影，根据不同的“相信”，可以是两个完全不同的冲突的故事。 电影对两个故事平衡的表述，用如此多的事实去支持每个故事使得没有哪个故事才是真正的“真相”。  或者两个故事原本都是“真相”，通过观众的主观介入，才使两个真相绝对成一个故事。  而这一切，双向的，绝对的相对只能发生在一个孤立的岛上，任何局外人都能使“真相”暴露。 以shutter island作为电影的题目，可以说再贴切不过。  </p>
<p>我一直觉得如何讲故事才是电影的灵魂，而shutter island这种双向引导故事的叙事方法就好象电影史的一个奇迹，通过创造“两个故事”间的冲突和矛盾重新开拓出新的电影的美  </p>
<p>远远不仅如此，电影中竟然多次出现Mahler的”Quartet for Strings and Piano in A minor”来描述弗洛伊德式的“回忆”或“幻觉”，Mahler和弗洛伊德同是20世纪初奥地利人，音乐不仅仅在内容上和叙事内容吻合(Mahler的七个姐妹死于童年，且从未从自己失去四岁爱女儿Maria的痛苦中恢复过来)，而且时间和地点相吻合， 电影的原创不仅对故事的表述，心理学有认识，而且对古典音乐也有很深入的理解，真是让人赞叹。  </p>
<p>还有电影中的几幕都非常经典： </p>
<p>Teddy梦见自己的妻子在家中，忘出窗外，“妻子死于火灾”（故事一的视角），他紧紧抱着妻子，天上掉着灰，而妻子像一张纸一样，慢慢的烧为灰烬。不舍，爱恋，温情，烧死的信息暗示以一种唯美的方式表达。  </p>
<p>Teddy 幻想到在Dr. Naehring的office, Rachel满身是血，杀害三个孩子前的一幕。 </p>
<p>Teddy周围弥漫的烟雾突然凝固，不仅创造了一种静止的对比，而且还有空间上深度的对比。  …  </p>
<p>还有Leonardo DiCaprio 出色的表演… </p>
<p>还有Dr. Naehring 的办公室那充满十九世纪维也纳风格的室内装饰…  </p>
<p>这个电影越是回味，越有味道。    </p>
<p> 最后我想追问的是，是的正如shakespeare所说 All the world ‘s a stage, and all the men and women merely players. They have their exits and their entrances; And one man in his time plays many parts 即使一个人在生命中的一个时期只有一个角色，那他是否仅仅在上演一个故事呢？  一个相同的事情，两个完全不同的故事。 </p>
<blockquote>
<p>作者：豆瓣用户——resurrection</p>
<p>原文链接：<a href="https://movie.douban.com/review/3043968/">https://movie.douban.com/review/3043968/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="八、蜘蛛侠：英雄无归【22-04-01】"><a href="#八、蜘蛛侠：英雄无归【22-04-01】" class="headerlink" title="八、蜘蛛侠：英雄无归【22-04-01】"></a>八、蜘蛛侠：英雄无归【22-04-01】</h3><p><a target="_blank" href="https://movie.douban.com/subject/26933210/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">蜘蛛侠：英雄无归 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/26933210/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV13Y411p7sf" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/bb5f0713766f18055c5b852271392fe77037b30a.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:09:47</span>
            </div>
            <div class="bvideo-info">
                <p class="title">吐槽《蜘蛛侠：英雄无归》：系列最降智！除了三蛛同框几乎一无是处</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>107.6万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>5532</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">阿德LBG</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<p>这篇影评我就自己随便简单写一两句吧，一方面是因为漫威电影这个价值不是很大，更多的是看一下特效剧情，二一方面是因为这一步感觉也太差了，没有什么好的看点，除了一些情怀包括三代蜘蛛侠同现、前几代的怪物以及奇异博士和一些特效。</p>
<p>然后想吐槽一下剧情，这剧情设计的太无聊无趣而且强行降智，蜘蛛侠还想要拯救这些人，想要逆天改命，无语了，本来就是每个人的命运，他这一改感觉造成了很多物理以及哲学上的矛盾。</p>
<p>大概就写着点吧，反正满是槽点。</p>
<h3 id="九、叫我第一名【22-04-06】"><a href="#九、叫我第一名【22-04-06】" class="headerlink" title="九、叫我第一名【22-04-06】"></a>九、叫我第一名【22-04-06】</h3><p><a target="_blank" href="https://movie.douban.com/subject/4798888/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">叫我第一名 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/4798888/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1Nv411A7BH" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/8380cd7928b413e11e707816dfe0e5a271af9204.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:06:59</span>
            </div>
            <div class="bvideo-info">
                <p class="title">经典高分励志电影！数十万人无一差评！——《叫我第一名》</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>122.9万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>452</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">大本有剧</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<p>这部影片改编自真实事件，男主布莱德是一名妥瑞氏症患者，这是一种非常严重的痉挛疾病，患者会不由自主且无法控制抽搐、做鬼脸、发出怪叫。 通过电影，我的感受是男主一路成长来肯定是不容易，毕竟发出怪叫总会引起别人的注意，而且日常生活肯定十分不方便，不论是上课还是听音乐、甚至是交谈都有极大的不变；此外更重要的会引起别人的嘲讽、歧视等，心里需要承受极大的压力（要我估计早放弃了。。。），但是男主不仅没有放弃，反而却要克服这该死的疾病，确实佩服（我做不到）。此外幸亏男主一路上还遇到许多好人，给了他很多帮助和勇气，这其中最重要的是他的妈妈——一直没有放弃他，另外就是他的小学校长——给了他自信，并成为了他的人生目标，这也是他为什么将来要做一名教师的原因。</p>
<p>总之吧，给我的感受就是——努力、奋进可以完成很多看似完不成的事情，可能做不到天赋异禀那样的高度，但是至少能完成最基本，甚至如果你做到足够努力，也可以比大部分人做的足够好。</p>
<hr>
<h3 id="2023年观影记录"><a href="#2023年观影记录" class="headerlink" title="2023年观影记录"></a>2023年观影记录</h3><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>生活休闲</category>
        <category>书-音-影</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>观影</tag>
        <tag>听音乐</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>我的阅读</title>
    <url>/2023/01/15/MyBook/</url>
    <content><![CDATA[<h3 id="一、《南京大屠杀》-【2023-01-09-】"><a href="#一、《南京大屠杀》-【2023-01-09-】" class="headerlink" title="一、《南京大屠杀》 【2023/01/09 】"></a>一、《南京大屠杀》 【2023/01/09 】</h3><p><a target="_blank" href="https://book.douban.com/subject/26545308/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">南京大屠杀 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://book.douban.com/subject/26545308/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1ET411E7Ln" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration"></span>
            </div>
            <div class="bvideo-info">
                <p class="title">出错了！</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span></span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span></span></span></p>
                <div class="partition">
                    <label class="card-label"></label>
                    <label class="up-label"></label>
                    <label class="up-name"></label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<p><strong>转载书评</strong></p>
<p>The Rape of Nanking ，张纯如女士的这本书虽然存在瑕疵（张纯如不懂得中文和日语，所以她得到的材料既有限又有很多瑕疵。该书中有一百多处比如人名地名时间之类史料上的错误。藤原章等日本左派学者向她提出这些错误，日本右翼也因此攻击她。日本出版商“柏书房”让她修改这些错误，但她拒绝更正，其原因是南京大屠杀已从学术上的讨论变得被政治化了——王选），但是它对中国的南京大屠杀史实研究具有极大的贡献，它们体现在：</p>
<ul>
<li>1、历史研究的态度必须严谨，必须运用现代历史研究的方法和手段，因为历史是记叙给全人类了，应该获得最广泛的认同；</li>
<li>2、历史研究的意义是获得共同记忆，必须还原历史绝大部分的真实面貌，才能使后代获得真实的记忆，而这种记忆就是一个民族或国家赖以延续的根本；</li>
<li>3、书名的深刻含义，rape，直译为“强奸”，意译为“浩劫”“梦魇”“暴行”，更多的是将 the rape of nanking 整译为“南京大屠杀”。</li>
</ul>
<p>我个人理解，张纯如使用“rape”一词，体现了她对南京事件的两个认识：第一，南京事件不是单纯的屠杀，而是涉及到对整个城市和人民的各个层面进行了强制的毁坏，是绝对丰富的犯罪；第二，“强奸”作为人类社会中的一种强制侵犯行为，它的发生是比较隐蔽的，通常只有加害人和被害人才了解整个真相，而往往是双方都会向第三人否认并尽量遗忘此事，所以副标题是“The Forgotten Holocaust of World War II”，指出它是被整个世界遗忘的，与犹太人被屠杀同等重要的人类记忆。</p>
<p>忘记就是第二次被施以暴行，这是张纯如的核心观点，也应该是我们的共识。 　　 </p>
<p>在新千年里，中国人在南京大屠杀事件上至少需要进行三个方面的努力：</p>
<ul>
<li>1、事件本身的深入研究，发掘、收集、考证史实，使对该事件的表述更接近真相。</li>
<li>2、重视日本国内对该事件的研究，系统的整理已出版的学术层面的日文专著、论文，侵华日军日记、回忆录等一手历史资料；以严谨和开放的史学态度，增加与日本研究人员的交流，无论其抱有承认或者否定的观点，中日之间这种以史实证据为基础的学术激辩，将促进更多史料被举证和公开，会有力推动中国的研究；不主观排斥日本的任何观点，并依据中日两国都无争议的史实证据进行逐一的验证和辩驳，从而修正中国方面的史料瑕疵。以求同存异的原则，中日共同出版南京大屠杀史实研究专著，贡献给世界史学界。</li>
<li>3、第三，让世界上更多的人知道南京大屠杀事件，正如世人知道德国人曾对犹太人所做的，他们也应该知道日本人曾对中国人做过什么。这样的人类记忆，才是第二次世界大战的完整历史。</li>
</ul>
<p>纪念南京大屠杀，纪念张纯如。 </p>
<blockquote>
<p>作者：豆瓣用户——<a href="https://www.douban.com/people/1112943/">Sweet M</a>  </p>
<p>原文链接：<a href="https://book.douban.com/review/1258849/">https://book.douban.com/review/1258849/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="二、《尼罗河上的惨案》-【2023-01-09-】"><a href="#二、《尼罗河上的惨案》-【2023-01-09-】" class="headerlink" title="二、《尼罗河上的惨案》 【2023/01/09 】"></a>二、《尼罗河上的惨案》 【2023/01/09 】</h3><p><a target="_blank" href="https://book.douban.com/subject/25697546/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">尼罗河上的惨案 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://book.douban.com/subject/25697546/</span>&lt;/span&gt;&lt;/span&gt;</span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1FW411P7ae" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/499d48432159e1b92b99cd4035d02ff55d81a6df.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:31:23</span>
            </div>
            <div class="bvideo-info">
                <p class="title">【木鱼微剧场】《尼罗河上的惨案》阿加莎克里斯蒂名篇</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>217.0万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>9663</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">木鱼水心</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<p><strong>转载书评</strong></p>
<p>看阿加莎总会觉得不太过瘾，一是人物多而杂，有点晕晕乎乎，直到后面才慢慢搞清楚谁是谁，这时候书的一半篇幅已经过去了；二是波洛总是走后门，能掌握读者不知道的许多幕后信息，灵机一动就了然于胸，而你就算每个字都用放大镜来照，前前后后地读上他好几遍，想破了脑袋也找不到破案的线索，这种感觉就像看柯南一样，不好，非常不好。每次闪电劈过柯南的时候，我总是还一愣一愣的，这小子咋又想通了捏。。难道人与人的智商差距真的那么大么。。不能不说是一种折磨。看《尼罗河》是这样，看《无人生还》也是这样，后者的结局更是牵强。就是《罗杰疑案》让人称道，结局真正出乎意料之外又合情合理，你想不出来是因为没好好看书，受惯性思维所囿，作者真是探案故事的个中高手。 </p>
<blockquote>
<p>作者：豆瓣用户——<a href="https://www.douban.com/people/1756537/">petitspois</a> </p>
<p>原文链接：<a href="https://book.douban.com/review/5421091/#comments">看阿加莎总会觉得不太过瘾（尼罗河上的惨案）书评 (douban.com)</a> </p>
<p>侵删</p>
</blockquote>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>生活休闲</category>
        <category>书-音-影</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>观影</tag>
        <tag>听音乐</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>我的音乐</title>
    <url>/2022/06/26/MyMusic/</url>
    <content><![CDATA[<h4 id="1-中文歌曲"><a href="#1-中文歌曲" class="headerlink" title="1 中文歌曲"></a>1 中文歌曲</h4><p>《北京东路的日子》《化身孤岛的鲸》《明天，你好》《演员》《悟空》《一次就好》《小小》《有点甜》《小星星》《追光者》《万有引力》《专属味道》《不分手的恋爱》《巴赫旧约》《海阔天空》《十年》《后来》《蓝莲花》《千千阕歌》《刀剑如梦》《吻别》《我们的明天》《甜蜜蜜》《上海滩》《懂你》《我相信》《西海情歌》《爱是你我》《粉红色的回忆》《爱拼才会赢》《烟火里的尘埃》《南屏晚钟》《画船记》《手心里的温柔》《情人》《2002年第一场雪》《喀什噶尔胡杨》《我们都一样》《他不懂》《逆战》《逆态度》《看月亮爬上来》《天下》《最美的太阳》《明天过后》《这就是爱》《爱》《青苹果乐园》《蝴蝶飞呀》《红蜻蜓》《孤勇者》《好久不见》《浮夸》《富士山下》《因为爱情》《单车》《最佳损友》《夜曲》《青花瓷》《稻香》《七里香》《花海》《夜的第七章》《大鱼》《雪落下的声音》《起风了》《玫瑰与小鹿》《生活总该迎着光亮》《钟无艳》《最初的梦想》《走着走着就散了》《刚好遇见你》《我的天空》《勋章》《生如夏花》《偏爱》《此生不换》《成都》《阿刁》《水中花》《以后的以后》《遇见》《逆光》《作曲家》《年轮》《渡红尘》《如果一切都没有发生过》《南山南》《你的样子》《求佛》《大海》《夜空中最亮的星》《去年夏天》《光辉岁月》《漂洋过海来看你》《可他爱着这个世界》《来不及勇敢》《倒数》《飘向远方》《风筝误》《你好不好》《醉千年》《等一分钟》《回忆总想哭》《说散就散》《怀念青春》《白月光》《野子》《荣耀》《成全》《冲动的惩罚》《暗里着迷》《丑八怪》《爱如潮水》《信仰》《爱就一个字》《时间都去哪了》《都选C》《断桥残雪》《有何不可》《如果当时》《千百度》《弹指一挥间》《灰色头像》《你若成风》《清明雨上》《城府》《国王与乞丐》《红尘来去一场空》《黄昏》《胡广生》《江湖再见》《老街》《老男孩》《木兰》《和你一样》《蜀绣》《平凡之路》《千古》《千年游》《情人》《囚鸟》《最美的期待》《笔记》《岁月神偷》《路过人间》《离人》《若不是那次夜空》《十七岁》《童话》《同桌的你》《我的楼兰》《无期》《喜欢你》《笑看风云》《一百万个可能》《樱花草》《映山红》《一万次悲伤》《直到世界尽头》《着魔》《祝你一路顺风》《小情歌》《曹操》《修炼爱情》《背对背拥抱》《江南》《飞云之下》《小酒窝》《醉赤壁》《可惜没如果》《将故事写成我们》《讲不出再见》《像我这样的人》《牧马城市》《消愁》《沉默是金》《棉花糖》《怒放的生命》《大约在冬季》《不让我的眼泪陪我过夜》《恰好》《卷珠帘》《水手》《万疆》《翱翔》《最后一次的温柔》《难念的经》《月亮代表我的心》《车上的人》《再见只是陌生人》《特别的爱给特别的你》《爱要怎么说出口》《我终于失去了你》《我很丑可是我很温柔》《勇敢一点》《雨蝶》《花火》《洋葱》《光年之外》《来自天堂的魔鬼》《你不是真正的快乐》《红豆》《秋天不回来》《伤心太平洋》《心太软》《在我的歌声里》《真的爱你》《鼓楼》《曾经的你》《单身情歌》《如愿》《匆匆那年》《一剪梅》《男儿当自强》《小苹果》《沧海一声笑》《时间煮雨》《知否知否》《花田错》《需要人陪》《大城小爱》《缘分一道桥》《我的未来不是梦》《在他乡》《千千万万》《寂寞沙洲冷》《很受伤》《甘心情愿》《一路生花》《如果云知道》《那些年》《处处吻》《胆小鬼》《无名之辈》《慢慢喜欢你》《凉凉》《体面》《说好不哭》《给我一首歌的时间》《舞女泪》《小幸运》《天使的翅膀》《笑红尘》《年少有为》《老鼠爱大米》《丁香花》《月亮惹的祸》《单恋一枝花》《给你们》《趁早》《死了都要爱》《隐形的翅膀》《Super Star》《花心》《往事只能回味》《有多少爱可以重来》《可惜不是你》《魔鬼中的天使》《再回首》《该死的温柔》《小薇》《微微》《只是没有如果》《终于等到你》《唯一》《爱江山更爱美人》《水星记》《为你写诗》《爱转角》《最近》《痴心绝对》《独家记忆》《过火》《当你孤单你会想起谁》《白狐》《春泥》《纪念》《窗外》《暗香》《向全世界宣布爱你》《远走高飞》《情人咒》《我的少女时代》《爱你AINI》《情花》《那女孩对我说》《日不落》《欧若拉》《为情所伤》《不是因为寂寞才想你》《至少还有你》《再度重相逢》《天堂》《后来我们会怎样》《为你我受冷风吹》《让我欢喜让我忧》《这世界那么多人》《盛夏的果实》《如果没有你》《真的好想你》《梦里水乡》《口是心非》《空城》《羞答答的玫瑰静悄悄地开》《当》《遇上你是我的缘》《我曾》《这一生关于你的风景》《梦醒时分》《你怎么舍得我难过》《是不是这样的夜晚你才会这样的想起我》《愿得一人心》《飘向北方》《纸短情长》《地球上最浪漫的一首歌》《守着你到永久》《想见你想见你想见你》《再见烟火》《缺口》《不过失去了一点点》《独角戏》《风雨无阻》《明天会更好》《直到遇见了你我只喜欢你》《一剪梅》《醉千年》《燕归巢》《泡沫》《其实都沒有》《太多》《问》《余香》《有一种爱叫做放手》《浪子回头》《答案》《再见》《再也没有》《夏天的风》《我们的纪念》《落在生命里的光》《黄梅戏》《血腥爱情故事》《不再犹豫》《曲终人散》《太想爱你》《红日》《这条街》《勇气》《爱的哲学》《你是人间四月天》《飞舞》《菊花台》《无赖》《撕夜》《手放开》《外滩十八号》《老人与海》《爱死了昨天》《七月七日晴》《千年泪》《花香》《纷飞》《忘记你我做不到》《慢慢》《值得》《友情岁月》《掌心》《我的心太乱》《挪威的森林》《爱的故事上集》《一万个理由》《犯错》《不要在我寂寞的时候说爱我》《心醉》《丁香花》《不要再来伤害我》《香水有毒》《错错错》《你到底你爱谁》《只对你有感觉》《一个像夏天一个像秋天》《三国恋》《像风一样自由》《认真的雪》《放生》《为爱停留》《千里之外》《第一次》《分飞》《一直很安静》《下一个天亮》《雪人》《爱情错觉》《关不上的窗》《千年之恋》《青花》《铁血丹心》《敢爱敢做》《谁明浪子心》《只想一生跟你走》《偏偏喜欢你》《记事本》《出卖》《画心》《类似爱情》《猜不透》《爱丫爱丫》《越长大越孤单》《痴情换情深》《一千年以后》《不得不爱》《美丽的神话》《伤心1999》《雨一直下》《最熟悉的陌生人》《月牙湾》《谢谢你的温柔》《亲爱的那不是爱情》《感动天感动地》《会呼吸的痛》《我怀念的》《挥着翅膀的女孩》《当你》《青春纪念册》《孤单北半球》《断点》《下一站天后》《离歌》《加速度》《开始懂了》《温柔》《暖暖》《如果爱下去》《桃花朵朵开》《梁山伯与茱丽叶》《奔跑》《感谢你曾经来过》《情非得已》《我很快乐》《一生有你》《FLY》《星星点灯》《不要怕》《桥边姑娘》《珊瑚海》《最美的瞬间》《护花使者》《有没有那么一首歌会让你突然想起我》《一笑而过》《天亮了》《第一时间》《绿光》《流星雨》《鸽子情缘》《不浪漫罪名》《k歌之王》《下个路口见》《冬天的秘密》《心痛2009》《没那么简单》《我的好兄弟》《爱情买卖》《我爱他》《红色高跟鞋》《心墙》《说谎》《相思》《风雨无阻》《让我欢喜让我忧》《神话情话》 《是非题》《我想更懂你》 《守护着我的光》《空》《须尽欢》《恋人心》《晚风心里吹》《听闻远方有你》《爸爸妈妈》《夜航星》《把悲伤留给自己》《天上人间》《海浪》《逍遥叹》 《重生之我在异乡为异客》</p>
<h4 id="2-英文歌曲"><a href="#2-英文歌曲" class="headerlink" title="2 英文歌曲"></a>2 英文歌曲</h4><p>《Yesterday Once More》《Let Her Go》《See You Again》《We Don’t Talk Any More》《Rain On Me》《Take Me Hand》《That Girl》《Stronger》《Dream It Possible》《Fight Song》《Try》《Lonely》《Stop!Stop!Stop》《Axel f》《Faded》《Lean on》《Closer》《Rockabye》《This is what you came for》<br>《Last Christmas》</p>
<h4 id="3-日韩歌曲"><a href="#3-日韩歌曲" class="headerlink" title="3 日韩歌曲"></a>3 日韩歌曲</h4><p>《曾经我也想过一了百了》《Planet》《有彩虹》《清新的小女孩》《Trap》</p>
<h4 id="4-纯音乐"><a href="#4-纯音乐" class="headerlink" title="4 纯音乐"></a>4 纯音乐</h4><p>《天空之城》《和兰花在一起》《城南花已开》《Senbonzakura》</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>生活休闲</category>
        <category>书-音-影</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>观影</tag>
        <tag>听音乐</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数_Part3</title>
    <url>/2022/05/04/LinearAlgebra3/</url>
    <content><![CDATA[<h3 id="第二十五讲-正交向量与正交子空间"><a href="#第二十五讲-正交向量与正交子空间" class="headerlink" title="第二十五讲 正交向量与正交子空间"></a>第二十五讲 正交向量与正交子空间</h3><p>进入第三单元学习，主题是正定矩阵及其应用。<strong>对称矩阵是其中最重要的矩阵之一，对称矩阵的特征值为实数并且拥有一套正交特征向量</strong>。正定矩阵的性质则比对称矩阵更好更好。 </p>
<h4 id="25-1-实对称矩阵-Symmetric-matrices-boldsymbol-A-mathrm-T-A"><a href="#25-1-实对称矩阵-Symmetric-matrices-boldsymbol-A-mathrm-T-A" class="headerlink" title="25.1 实对称矩阵 Symmetric matrices $\boldsymbol{A^{\mathrm T} = A}$"></a>25.1 实对称矩阵 Symmetric matrices $\boldsymbol{A^{\mathrm T} = A}$</h4><p>包含特殊性质的矩阵，例如Markov矩阵，其特征值和特征向量往往拥有一定特性。对于对称矩阵来说有两个待证明性质：</p>
<ul>
<li>实对称矩阵的特征值也是实数 </li>
<li>有完全正交的特征向量<ul>
<li>如果特征值互不相同，那么每个特征值的特征向量是在单独的一条线上，那些线是垂直正交的；如果特征值重复，那就有一整个平面的特征向量，在那个平面上可以选择垂直的向量</li>
<li>可以将这组特征向量转化为标准正交向量。</li>
</ul>
</li>
</ul>
<p>例如：<strong>单位矩阵</strong>，单位矩阵是对称矩阵，特征值都为1，每一个向量都是特征向量。</p>
<p>如果$\boldsymbol A$具有$n$个线性无关的特征向量，可以对角化得到：</p>
<script type="math/tex; mode=display">
\boldsymbol A = \boldsymbol{S \Lambda S}^{-1}</script><p>而对于对称矩阵，由于其特征向量是正交的，所以有：</p>
<script type="math/tex; mode=display">
\boldsymbol A = \boldsymbol{Q \Lambda Q}^{-1} = \boldsymbol{Q \Lambda Q}^{\mathrm T}</script><p>上式$\boldsymbol Q$表示标准正交矩阵，这里是方阵，因为对称矩阵的$\boldsymbol S$是垂直正交的，所以可转化为$\boldsymbol Q$，同时标准正交矩阵$\boldsymbol Q$有：$\boldsymbol Q^{-1} = \boldsymbol Q^{\mathrm T}$ ，所以以上式子是对称矩阵的分解形式，分解成特征向量和特征值的组合。等式右边取转置又得到自己，所以A是对称矩阵。 </p>
<ul>
<li>数学上叫这个为<font color="blue"><strong>谱定理</strong></font>，谱就是指矩阵的特征值集合，一些纯东西组合。</li>
<li>力学上叫这个为<font color="blue"><strong>主轴定理</strong></font>，从几何图形上看，它意味着如果给定某种材料，在合适的轴上来看，它就变成对角化的，方向就不会重复。</li>
</ul>
<p><strong>问题1：为什么实对称矩阵的特征值是实数</strong> </p>
<p>先假设特征值中存在复数。矩阵$\boldsymbol A$具有特征值$\lambda$和特征向量$\boldsymbol x$，则有：</p>
<script type="math/tex; mode=display">
\boldsymbol {Ax} = \lambda \boldsymbol x {\Longrightarrow} \overline{\boldsymbol {Ax}} = \overline{ \lambda \boldsymbol {x}} \Longrightarrow \overline{\boldsymbol A} \overline{\boldsymbol x} = \overline{\lambda}\overline{\boldsymbol x} \Longrightarrow  \boldsymbol A \overline{\boldsymbol x} = \overline{\lambda}\overline{\boldsymbol x}</script><p>上式说明实对称矩阵有特征值$\lambda$和特征向量$\boldsymbol x$，那该矩阵必然有另一特征值$\overline \lambda$和特征向量$\overline{\boldsymbol x}$。将上式最后部分$\boldsymbol A \overline{\boldsymbol x} = \overline{\lambda}\overline{\boldsymbol x}$转置可得：</p>
<script type="math/tex; mode=display">
\overline{\boldsymbol x}^{\mathrm T} \boldsymbol A^{\mathrm T} = \overline{\lambda}\overline{\boldsymbol x}^{\mathrm T}</script><p>将上式从右边乘$\boldsymbol x$取内积：</p>
<script type="math/tex; mode=display">
\overline{\boldsymbol x}^{\mathrm T} \boldsymbol A^{\mathrm T}{\boldsymbol x} = \overline{\lambda}\overline{\boldsymbol x}^{\mathrm T}{\boldsymbol x}</script><p>再对上述长式子中前面部分$\boldsymbol {Ax} = \lambda \boldsymbol x$左边乘$\overline{\boldsymbol x}^{\mathrm T}$取内积：</p>
<script type="math/tex; mode=display">
\overline{\boldsymbol x}^{\mathrm T} \boldsymbol {Ax} = \lambda \overline{\boldsymbol x}^{\mathrm T}\boldsymbol x</script><p>上面两个式子一对比可知：等式左侧相同，因此右端也相等：</p>
<script type="math/tex; mode=display">
\overline{\lambda}\overline{\boldsymbol x}^{\mathrm T}{\boldsymbol x} = \lambda \overline{\boldsymbol x}^{\mathrm T}\boldsymbol x</script><p>所以有$\overline{\lambda} = \lambda$，所以实对称阵的特征值为实数。</p>
<blockquote>
<p>注意：上面推导的最后一步要保证$\overline{\boldsymbol x}^{\mathrm T}\boldsymbol x$不等于0。这里我们简单带入数据可知$\overline{\boldsymbol x}^{\mathrm T}\boldsymbol x$不等于0且为正数。( 一个向量为复向量，那么它乘以其共轭复向量得到实部的平方加上虚部的平方，为其长度平方 )</p>
</blockquote>
<p><strong>问题1延伸：性质好矩阵</strong></p>
<p>本节中性质好矩阵是指<font color="red">“特征值为实数”、”特征向量正交垂直”</font>。</p>
<p>那么什么矩阵是好的呢？</p>
<ul>
<li>如果一个矩阵是实数矩阵，那么<strong>“性质好”</strong>的矩阵就是<strong>“实对称矩阵”</strong>，$\boldsymbol{A^{\mathrm T} = A}$</li>
<li>如果一个矩阵是复数矩阵，那么<strong>“性质好”</strong>的矩阵就是<strong>“复对称矩阵”</strong>，$\overline{\boldsymbol A}^{\mathrm T} = \boldsymbol A$<ul>
<li>因为可以类比实矩阵的推导过程进行推导，这时可以发现对复数矩阵来说，只有当$\overline{\boldsymbol A}^{\mathrm T} = \boldsymbol A$成立时才可以推导出该复数矩阵”特征值为实数”。也就是说假设矩阵原来是复数矩阵，对称的等价条件是$\overline{\boldsymbol A}^{\mathrm T} = \boldsymbol A$；</li>
<li>这里就是想说：若给定一复矩阵，想让它和实对称矩阵有一样的性质，那该复矩阵就需要满足$\overline{\boldsymbol A}^{\mathrm T} = \boldsymbol A$。</li>
</ul>
</li>
</ul>
<p>对于对称矩阵，$\boldsymbol A = \boldsymbol{Q \Lambda Q}^{-1} = \boldsymbol{Q \Lambda Q}^{\mathrm T}$，可以写作： </p>
<script type="math/tex; mode=display">
\begin{aligned}
&\boldsymbol{A}=\boldsymbol{Q} \boldsymbol{\Lambda} \boldsymbol{Q}^{-1}=\left[\begin{array}{llll}
\boldsymbol{q}_{1} & \boldsymbol{q}_{2} & \cdots & \boldsymbol{q}_{\mathrm{n}}
\end{array}\right]\left[\begin{array}{llll}
\lambda_{1} & & & \\
& \lambda_{2} & & \\
& & \ddots & \\
& & & \lambda_{\mathrm{n}}
\end{array}\right]\left[\begin{array}{c}
\boldsymbol{q}_{1}^{T} \\
\boldsymbol{q}_{2}^{T} \\
\vdots \\
\boldsymbol{q}_{\mathbf{n}}
\end{array}\right]\\
&=\lambda_{1} \boldsymbol{q}_{1} \boldsymbol{q}_{1}^{T}+\lambda_{2} \boldsymbol{q}_{2} \boldsymbol{q}_{2}{ }^{T}+\cdots+\lambda_{\mathrm{n}} \boldsymbol{q}_{\mathrm{n}} \boldsymbol{q}_{\mathrm{n}}{ }^{T}
\end{aligned}</script><p>矩阵<script type="math/tex">\boldsymbol q_k \boldsymbol q_k^{\mathrm T}</script>朝向向量<script type="math/tex">\boldsymbol q_k</script>的投影矩阵，所以<strong>每一个对称矩阵都是正交投影矩阵的线性组合(每一个对称矩阵都是一些相互垂直的投影矩阵的组合)</strong>。这是理解谱定理的另一种方法。</p>
<p>当确认矩阵特征值为实数后，下一个要考虑的问题就是它是正还是负数，因为这影响着微分方程中体系的稳定与否。但是对于大型矩阵通过计算$|(\boldsymbol A -\lambda \boldsymbol I)| = 0$ 得到特征值进行判定难以实现，即使用MATLAB求解结果也不一定可靠，但MATLAB可以得到矩阵的主元，而<font color="green"><strong>对称阵的主元中正负数的个数与特征值相同</strong></font>，即正主元的数目等于正特征值的数目。 </p>
<blockquote>
<p>注意：课程中老师并没有说“主元正负个数等于特征值正负个数”这个性质是如何证明的，可以不做深究。</p>
<p>但是简要证明可以参考：<a href="https://zhuanlan.zhihu.com/p/46023045">https://zhuanlan.zhihu.com/p/46023045</a></p>
<p>(对于对称阵主元与特征值符号相匹配这件事情，通常是用合同矩阵的惯性定理加以证明)</p>
</blockquote>
<p>矩阵$\boldsymbol A + b \boldsymbol I$的特征值比矩阵的$\boldsymbol A$特征值大$b$，可以通过$\boldsymbol A + b \boldsymbol I$的主元来了解矩阵$\boldsymbol A$的特征值与$b$的大小关系，因此利用这个性质可以估计特征值的状态。 </p>
<h4 id="25-2-正定矩阵-Positive-definite-matrices"><a href="#25-2-正定矩阵-Positive-definite-matrices" class="headerlink" title="25.2 正定矩阵 Positive definite matrices"></a>25.2 正定矩阵 Positive definite matrices</h4><p>正定矩阵是对称阵的一个子类，如果一个实对称矩阵的特征值都是正数，那么它是正定矩阵。其性质比普通对称阵更好一点，即其性质为：</p>
<ul>
<li>① 特征值都为正数的对称矩阵，它的主元也均为正数。 </li>
<li>② 正定矩阵的所有子行列式都是正数 </li>
</ul>
<p><strong>正定矩阵将方阵特征值，主元，行列式融为一体</strong>。 </p>
<p>若将行列式作为正定的判据，则要求$n$阶矩阵左上角的所有$k \times k,(1 \leq k \leq n)$子行列式（subdeterminant）数值均为正，矩阵确定为正定矩阵。</p>
<p>本讲的内容将之前教授的主元、行列式和特征值的概念结合在了一起，对于正定矩阵这些都是正的，当完全掌握了它们的性质后会推广到非对称矩阵，甚至非方阵。</p>
<h3 id="第二十六讲-复数矩阵和快速傅里叶变换"><a href="#第二十六讲-复数矩阵和快速傅里叶变换" class="headerlink" title="第二十六讲 复数矩阵和快速傅里叶变换"></a>第二十六讲 复数矩阵和快速傅里叶变换</h3><p>实矩阵也可能有复特征值，因此无法避免在矩阵运算中碰到复数，本讲学习处理复数矩阵和复向量。</p>
<p>最重要的复矩阵是傅里叶矩阵，它用于傅里叶变换。而对于大数据处理快速傅里叶变换（FFT）显得更为重要，它将矩阵乘法的运算次数从$n^2$降到$n \log_2 n$次。 </p>
<h4 id="26-1-复向量-Complex-vectors"><a href="#26-1-复向量-Complex-vectors" class="headerlink" title="26.1 复向量 Complex vectors"></a>26.1 复向量 Complex vectors</h4><p>对于给定的复向量<script type="math/tex">\boldsymbol{z}=\left[\begin{array}{c} z_{1} \\ z_{2} \\ \vdots \\ z_{\mathrm{n}}\end{array}\right] \in \mathbf{C}^{n}</script>，其元素中有复数，因此$\boldsymbol z^{\mathrm T}\boldsymbol z$无法给出向量的长度。例如：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ll}
1 & i
\end{array}\right]\left[\begin{array}{l}
1 \\
i
\end{array}\right]=0</script><p>因此对于复向量而言，需要定义其模长为：</p>
<script type="math/tex; mode=display">
|\boldsymbol{z}|^{2}=\overline{\boldsymbol{z}}^{T} \boldsymbol{z}=\left|z_{1}\right|^{2}+\left|z_{1}\right|^{2}+\cdots+\left|z_{1}\right|^{2}</script><p>将复矩阵的<strong>“共轭转置”</strong>记为$\overline{\boldsymbol{z}}^{\mathrm T} = {\boldsymbol{z}}^{\mathrm H}$(H来自于“Hermite”)。</p>
<p>与之相似，内积的定义也变为：</p>
<script type="math/tex; mode=display">
\boldsymbol{y}^{\mathrm H} \boldsymbol{x}=\overline{\boldsymbol{y}}^{\mathrm T} \boldsymbol{x}=\bar{y}_{1} x_{1}+\bar{y}_{2} x_{2}+\cdots+\bar{y}_{n} x_{n}</script><h4 id="26-2-复矩阵-Complex-matrices"><a href="#26-2-复矩阵-Complex-matrices" class="headerlink" title="26.2 复矩阵 Complex matrices"></a>26.2 复矩阵 Complex matrices</h4><p> 上一讲中讲到了对于复矩阵$\boldsymbol A$，若有$\overline{\boldsymbol A}^{\mathrm T} = \boldsymbol A$则复矩阵$\boldsymbol A$的特征值为实数。这种复矩阵被称为埃尔米特矩阵(Hermitian matrixes)。转置共轭记作$\overline{\boldsymbol{A}}^{\mathrm T} = {\boldsymbol{A}}^{\mathrm H}$</p>
<p> 例如矩阵<script type="math/tex">\left[\begin{array}{cc} 2 & 3+i \\ 3-i & 5\end{array}\right]</script> 为埃尔米特矩阵。它具有实数特征值和正交的特征向量。由性质可知埃尔米特矩阵对角线均为实数。 </p>
<p>此处向量标准正交的意思是：</p>
<script type="math/tex; mode=display">
\overline{\boldsymbol{q}}_{j}^{T} \boldsymbol{q}_{k}= \begin{cases}0 & j \neq k \\ 1 & j=k\end{cases}</script><p>用$n$个标准正交的复向量作为列向量可以构造一个矩阵$\boldsymbol Q$，则有</p>
<script type="math/tex; mode=display">
\boldsymbol Q^{\mathrm H}\boldsymbol Q  = \boldsymbol Q \boldsymbol Q^{\mathrm H} = \boldsymbol I</script><script type="math/tex; mode=display">
\boldsymbol Q^{\mathrm T}\boldsymbol Q = \boldsymbol I = \boldsymbol Q^{\mathrm H}\boldsymbol Q</script><p>这个复空间的正交矩阵$\boldsymbol Q$称为<font color="red"><strong>酉矩阵</strong>（unitary matrix）</font>，换句话说，酉矩阵的逆矩阵，就是其共轭转置： </p>
<script type="math/tex; mode=display">
\boldsymbol Q^{-1} = \boldsymbol Q^{\mathrm H}</script><p>酉矩阵是实数上的正交矩阵在复数的推广。 </p>
<h4 id="26-3-酉矩阵的性质"><a href="#26-3-酉矩阵的性质" class="headerlink" title="26.3 酉矩阵的性质"></a>26.3 酉矩阵的性质</h4><ul>
<li><strong>性质1：</strong>$\boldsymbol Q^{\mathrm H}\boldsymbol Q  = \boldsymbol Q \boldsymbol Q^{\mathrm H} = \boldsymbol I$</li>
<li><strong>性质2：</strong>酉矩阵亦必定可逆，且逆矩阵等于其共轭转置：$\boldsymbol Q^{-1} = \boldsymbol Q^{\mathrm H}$</li>
<li><strong>性质3：</strong>酉矩阵的所有特征值，都是绝对值等于1的复数：$|\lambda_i| = 1$</li>
<li><strong>性质4：</strong>由性质3可知，酉矩阵行列式的绝对值也是 1： $\det(\boldsymbol Q) = 1$</li>
<li><strong>性质5：</strong>酉矩阵不会改变两个复向量$\boldsymbol x$和$\boldsymbol y$的点积：$(\boldsymbol{Qx}) \cdot (\boldsymbol{Qy}) = \boldsymbol{x \cdot y}$ </li>
</ul>
<h4 id="26-3-傅里叶变换Fourier-transform"><a href="#26-3-傅里叶变换Fourier-transform" class="headerlink" title="26.3 傅里叶变换Fourier transform"></a>26.3 傅里叶变换Fourier transform</h4><p><strong>傅里叶矩阵</strong>：最著名的“酉矩阵”。 </p>
<p>傅里叶级数是将周期函数或者信号变换为不同频率的三角函数的和函数。 </p>
<script type="math/tex; mode=display">
f(x)=a_{0}+a_{1} \cos x+b_{1} \sin x+a_{2} \cos 2 x+b_{2} \sin 2 x+\cdots</script><p>在电子工程或者计算机科学中，矩阵的行和列从第0行和第0列开始计数，最后到第$n-1$行和第$n-1$列。我们在讨论傅里叶矩阵的时候遵从这种习惯。 $n$阶傅里叶矩阵：全矩阵，是一个酉矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol{F}_{n}=\left[\begin{array}{rrrrr}
1 & 1 & 1 & \cdots & 1 \\
1 & \omega & \omega^{2} & & \omega^{(n-1)} \\
1 & \omega^{2} & \omega^{2} & & \omega^{2(n-1)} \\
\vdots & & & \ddots & \\
1 & \omega^{n-1} & \omega^{2(n-1)} & & \omega^{(n-1)^{2}}
\end{array}\right]</script><p>也就是<script type="math/tex">(\boldsymbol F_n)_{jk} = \omega^{jk}</script>，且傅里叶矩阵为对称矩阵<script type="math/tex">\boldsymbol F_n \boldsymbol F_n^{\mathrm T}</script> 。矩阵中的元素是<script type="math/tex">\omega</script>的幂，且<script type="math/tex">\omega^n=1</script>($n$是矩阵阶数)，在复平面内，<script type="math/tex">\omega</script>落在单位圆上：</p>
<script type="math/tex; mode=display">
\omega = e^{i \frac{2\pi}{n}}</script><p>矩阵的列向量正交。的方次分布在复平面的单位元上，只是幅角不同。当$n=4$时有</p>
<script type="math/tex; mode=display">
\omega^4=1, \omega = e^{i \frac{2\pi}{4}} = i</script><script type="math/tex; mode=display">
\boldsymbol{F}_{4}=\left[\begin{array}{cccc}
1 & 1 & 1 & 1 \\
1 & i & i^{2} & i^{3} \\
1 & i^{2} & i^{4} & i^{6} \\
1 & i^{3} & i^{6} & i^{9}
\end{array}\right]=\left[\begin{array}{rrrr}
1 & 1 & 1 & 1 \\
1 & i & -1 & -i \\
1 & -1 & 1 & -1 \\
1 & -i & -1 & i
\end{array}\right]</script><p>从矩阵可以得到一个四点(离散的)傅里叶变换，它的逆矩阵就是反傅里叶变换。逆矩阵很容易计算，因为傅里叶矩阵列向量正交。实际上这个矩阵可以分解成一系列稀疏矩阵，并且它们的逆矩阵都很容易得到。 </p>
<p>计算可知列向量的模不是1，矩阵除以2之后，向量标准正交： </p>
<script type="math/tex; mode=display">
\dfrac{1}{4}\boldsymbol F_n^{\mathrm H}\boldsymbol F_n =\boldsymbol I</script><p>它的逆矩阵就是共轭转置。 一个很好的性质：可以把傅里叶矩阵分解为一些列“稀疏矩阵”。 </p>
<h4 id="26-4-快速傅里叶变换-Fast-Fourier-transform"><a href="#26-4-快速傅里叶变换-Fast-Fourier-transform" class="headerlink" title="26.4 快速傅里叶变换 Fast Fourier transform"></a>26.4 快速傅里叶变换 Fast Fourier transform</h4><p>对于64阶傅里叶矩阵<script type="math/tex">\boldsymbol F_{64}</script>中的<script type="math/tex">\omega_{64}</script>与32阶傅里叶矩阵<script type="math/tex">\boldsymbol F_{32}</script>的元素<script type="math/tex">\omega_{32}</script>相比，幅角是其一半，<script type="math/tex">\omega_{64}^2 = \omega_{32}</script>。可以从分块矩阵运算找到两者的联系：</p>
<script type="math/tex; mode=display">
\left[\boldsymbol{F}_{64}\right]=\left[\begin{array}{rr}
\boldsymbol{I} & \boldsymbol{D} \\
\boldsymbol{I} & -\boldsymbol{D}
\end{array}\right]\left[\begin{array}{rr}
\boldsymbol{F}_{32} & 0 \\
0 & \boldsymbol{F}_{32}
\end{array}\right][\boldsymbol{P}]</script><p> 其中$\boldsymbol P​$是置换矩阵，而$\boldsymbol D​$为对角矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol{P}=\left[\begin{array}{cccccccc}
1 & 0 & 0 & 0 & \cdots & \cdots & 0 & 0 \\
0 & 0 & 1 & 0 & & & 0 & 0 \\
& & & \vdots & & & & \\
0 & 0 & 0 & 0 & \cdots & \cdots & 1 & 0 \\
0 & 1 & 0 & 0 & \cdots & \cdots & 0 & 0 \\
0 & 0 & 0 & 1 & \cdots & \cdots & 0 & 0 \\
& & & \vdots & & & & \\
0 & 0 & 0 & 0 & \cdots & \cdots & 0 & 1
\end{array}\right]</script><script type="math/tex; mode=display">
\boldsymbol{D}=\left[\begin{array}{lllll}
1 & & & & \\
& \omega & & & \\
& & \omega^{2} & & \\
& & & \ddots & \\
& & & & \\
& & & & \omega^{31}
\end{array}\right]</script><p>$\boldsymbol P$的效果是使得所乘的向量$\boldsymbol x$序数为奇数的分量如$x_1，x_3，x_5$等提到前面，而偶数分量$x_2，x_4$等放到后面。</p>
<p>计算$64$阶傅里叶变换（傅里叶矩阵乘以向量）的计算量是$64 \times 64$，而等式右侧的计算量是$2 \times 32 \times 32$（两个$32$阶）再加上一些修正项，修正项主要来自于与对角矩阵$\boldsymbol D$的乘法，大约为$32$次。继续对$\boldsymbol F_{32}$进行分解，计算的运算量再一次下降变为$2 (2 \times 16 \times 16+16)+32$。分解到最后，仅剩修正项的运算，$32 \times \log_2 64$次。对于$n$阶矩阵，即将$n^2$次计算降至$\dfrac{n}{2}\log_2 n$次。例如对于$1024$阶矩阵，运算量从$1024 \times 1024$降至$5 \times 1024$。 </p>
<h3 id="第二十七讲-正定矩阵和最小值"><a href="#第二十七讲-正定矩阵和最小值" class="headerlink" title="第二十七讲 正定矩阵和最小值"></a>第二十七讲 正定矩阵和最小值</h3><p>本讲学习正定矩阵，这部分内容将本课程之前的知识点：主元、行列式、特征值以及方程的稳定性融为一体。本讲介绍如何判定一个矩阵是否正定矩阵，以及当一个矩阵是正定矩阵时，其内涵和矩阵操作的效果有何特别之处。此外还有正定矩阵与几何的关系：椭圆和正定有关，双曲线与正定无关。 </p>
<h4 id="27-1-正定矩阵-Positive-definite-matrices"><a href="#27-1-正定矩阵-Positive-definite-matrices" class="headerlink" title="27.1 正定矩阵 Positive definite matrices"></a>27.1 正定矩阵 Positive definite matrices</h4><p>给定一个$2\times 2$对称矩阵<script type="math/tex">\boldsymbol A=\left[\begin{array}{ll} a & b \\ b & c\end{array}\right]</script>，有四个途径判定矩阵是否正定矩阵： </p>
<ul>
<li>特征值： 所有特征值均大于0——$\lambda_1 &gt; 0$，$\lambda_2 &gt; 0$</li>
<li>行列式：所有子行列式均大于0——$a&gt;0$，$ac-b^2&gt;0$</li>
<li>主元： 主元要均大于0——$a&gt;0$，$\dfrac{ac-b^2}{a} &gt;0$</li>
<li>表达式 ：$\boldsymbol x^{\mathrm T} \boldsymbol A \boldsymbol x &gt; 0, (\boldsymbol x 为任意向量，但是\boldsymbol x \neq  0)$——<strong>通常这就是正定的定义，而前三条是用来验证正定性的条件</strong></li>
</ul>
<p>给定矩阵<script type="math/tex">\boldsymbol A=\left[\begin{array}{ll} 2 & 6 \\ 6 & c\end{array}\right]</script>，从判据(行列式)可知矩阵为正定阵的条件是$2c-36&gt;0$，即$c&gt;18$。 </p>
<ul>
<li><strong>当$c = 18$时：</strong></li>
</ul>
<p>矩阵<script type="math/tex">\left[\begin{array}{ll} 2 & 6 \\ 6 & 18\end{array}\right]</script>正好处在判定为正定矩阵的临界点上，称之为<strong>半正定(positive semidefinite)矩阵</strong>，它具有一个特征值0，是奇异矩阵，只有一个主元，而行列式为0。<strong>半正定矩阵特征值大于等于0。</strong> </p>
<p>再观察$\boldsymbol x^{\mathrm T} \boldsymbol A \boldsymbol x &gt; 0$判据： </p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{x}^{\mathrm T} \boldsymbol{A} \boldsymbol{x} &=\left[\begin{array}{ll}
x_{1} & x_{2}
\end{array}\right]\left[\begin{array}{cc}
2 & 6 \\
6 & 18
\end{array}\right]\left[\begin{array}{l}
x_{1} \\
x_{2}
\end{array}\right] \\
&=2 x_{1}^{2}+12 x_{1} x_{2}+18 x_{2}^{2}
\end{aligned}</script><p>之前讨论得都是线性方程$\boldsymbol {Ax}$(展开方程次数为一阶)，现在引入$\boldsymbol x^{\mathrm T}$变成二次，如果对于任意$x,y$，这种二次型(quadratic form)$ax^2+2bxy+cy^2$均大于零，则矩阵为正定矩阵。</p>
<p>在本例的半正定矩阵中，当$x_1=3, x_2=-1$时，带入可知：<script type="math/tex">\boldsymbol{x}^{\mathrm T} \boldsymbol{A} \boldsymbol{x} = 0</script></p>
<ul>
<li><strong>当$c = 7$时：</strong></li>
</ul>
<p>矩阵变为<script type="math/tex">\left[\begin{array}{ll} 2 & 6 \\ 6 & 7\end{array}\right]</script>，其二次型为<script type="math/tex">f(x,y) = \boldsymbol{x}^{\mathrm T} \boldsymbol{A} \boldsymbol{x} = 2 x_{1}^{2}+12 x_{1} x_{2}+ 7 x_{2}^{2}</script>，从图像上看无最小值点，在原点处有一<strong>鞍点</strong>。鞍点在某个方向上看是极大值点，在另一方向上是极小值点，实际上最佳观测角度是<strong>特征向量的方向</strong>。 </p>
<ul>
<li><strong>当$c = 20$时：</strong></li>
</ul>
<p>矩阵变为<script type="math/tex">\left[\begin{array}{ll} 2 & 6 \\ 6 & 20\end{array}\right]</script>，主元为正；特征值之积为行列式的值4，特征值和为矩阵的迹22，因此特征值为正；子行列式均为正。矩阵为正定矩阵。 </p>
<p>其二次型<script type="math/tex">f(x,y) = \boldsymbol{x}^{\mathrm T} \boldsymbol{A} \boldsymbol{x} = 2 x_{1}^{2}+12 x_{1} x_{2}+ 20 x_{2}^{2}</script>，其图像最小值点为原点，一阶偏导数为0，二阶偏导数大于0。 </p>
<p><img src="https://pic.imgdb.cn/item/62731bf60947543129a804f5.jpg" style="zoom:80%"></p>
<blockquote>
<p>当年上课时候老师讲双曲面的鞍点，画的图不好，有个篮球队的哥们理解不了，于是下了课跑去问老师，老师指着他的热身篮球裤说，就你这种裤腿两侧能撕开的篮球裤，全部打开，拎起来，裤裆地方就是鞍点……算了，反正GS画图真心不行，看看Lay的吧： </p>
<p><img src="https://pic.imgdb.cn/item/62731c620947543129a8977a.jpg" style="zoom:80%"></p>
</blockquote>
<p>微积分中判定最小值点的判据【海森矩阵（Hessian Matrix）？】：</p>
<ul>
<li>一阶导数等于零：$\dfrac{\mathrm du}{\mathrm d x} = 0$</li>
<li>二阶导数为正：$\dfrac{\mathrm d^2u}{\mathrm d x^2} &gt; 0$</li>
</ul>
<p>线性代数中判据为二阶导数矩阵正定。</p>
<p>对于二次型我们可以用配方的办法来验证其是否具有最小值：</p>
<script type="math/tex; mode=display">
f(x,y) = \boldsymbol{x}^{\mathrm T} \boldsymbol{A} \boldsymbol{x} = 2 x^{2}+12 xy+ 20 y^{2} = 2(x+3y^2)+2y^2</script><p>配方使得$x^2$的系数和交叉项$xy$的系数配合形成完全平方的形式，这个时候用到的$y^2$的系数正好是18，即判定正定的临界点。在此例中如果实际的系数$c&gt;18$，则还剩余$(c-18)y^2$，二次型在原点之外一定大于零，若$c&lt;18$则二次型可以小于等于0。 </p>
<p>对于$f(x,y) = \boldsymbol{x}^{\mathrm T} \boldsymbol{A} \boldsymbol{x} = 2 x^{2}+12 xy+ 20 y^{2} = 2(x+3y^2)+2y^2$，其几何图像为碗型的曲面，如果我们用$f=1$的截面横截曲面，得到的就是$2(x+3y^2)+2y^2 = 1$的椭圆。而对于双曲面进行切割就得到双曲线。</p>
<p>配方法其实就是消元：</p>
<p><img src="https://pic.imgdb.cn/item/62731ff60947543129ad7ba2.jpg"></p>
<p>主元就是平方项系数，$\boldsymbol L$矩阵中的行操作数$l_{21}$ 就是配方项内$y$的系数。因为主元是每一个完全平方项的系数，因此这就是为什么矩阵的主元为正则该矩阵为正定矩阵。本例中二次型表达式的配方说明了二维的情形，而线代的理论可以将之推广到$n$维。 </p>
<blockquote>
<p>PS：虽然知道配方和消元数字上是的对上的，但我还是不太明白消元和配方过程上有啥联系…… </p>
<p>消元和配方都是在去耦合吧，调配成最简略的关系 </p>
</blockquote>
<p>二阶导数的矩阵记为<script type="math/tex">\left[\begin{array}{ll} f_{x x} & f_{x y} \\ f_{y x} & f_{y y}\end{array}\right]</script>【海森矩阵（Hessian Matrix）？】，矩阵对称代表交叉二阶偏导数与求导顺序无关，即<script type="math/tex">f _ {xy} = f _ {yx}</script>。在微积分中我们学到的判据<script type="math/tex">f _ {xx}f _ {yy} > f _ {xy}^2</script>，和<strong>二阶矩阵判定正定是等价的</strong>，并且线代可以推广到$n$维。 </p>
<script type="math/tex; mode=display">
f_{xx}f_{yy}>f_{xy}^2 \stackrel{等价于}\Longleftrightarrow 二阶矩阵判定正定</script><p>3阶矩阵<script type="math/tex">\boldsymbol A=\left(\begin{array}{ccc} 2 & -1 & 0 \\ -1 & 2 & -1 \\ 0 & -1 & 2\end{array}\right)</script>，它是正定矩阵。计算子行列式得到</p>
<script type="math/tex; mode=display">
|2| = 2, \left|\begin{array}{rr}
2 & -1 \\
-1 & 2
\end{array}\right|=3, 
\left|\begin{array}{rrr}
1 & 2 & 1 \\ 0 & 2 & -2 \\ 0 & 4 & 1
\end{array}\right|=4</script><p>主元是$2，3/2，4/3$。特征值是$2-\sqrt2, 2, 2+\sqrt2$。</p>
<blockquote>
<p>PS：这是G. Strang最爱的矩阵之一，可以用来把二阶微分方程变成离散问题，因为它每一行都是差分方程 <script type="math/tex">f_{n+1}-2f_n+f_{n-1}</script></p>
</blockquote>
<p>其二次型为：</p>
<script type="math/tex; mode=display">
f(x,y) = \boldsymbol{x}^{\mathrm T} \boldsymbol{A} \boldsymbol{x} = 2 x_{1}^{2}+2 x_{2}^{2}+2 x_{3}^{2}-2 x_{1} x_{2}-2 x_{2} x_{3}</script><p>是一四维图像，三个维度<script type="math/tex">x_1，x_2，x_3</script>加函数<script type="math/tex">f</script>，若用<script type="math/tex">f=1</script>切割，则有<script type="math/tex">2 x_{1}^{2}+2 x_{2}^{2}+2 x_{3}^{2}-2 x_{1} x_{2}-2 x_{2} x_{3} = 1</script> 。这是一个椭球体，<font color="green"><strong>三个特征值不同，因此椭球的三个长轴长度不同。三个轴的方向就是特征向量的方向，轴长度就是特征值</strong></font>，矩阵的分解<script type="math/tex">\boldsymbol{A = Q \Lambda Q}^{\mathrm T}</script>很好的说明了这件事，这就是所谓的“主轴定理”。 </p>
<h4 id="27-2-小说明"><a href="#27-2-小说明" class="headerlink" title="27.2 小说明"></a>27.2 小说明</h4><p>对于三条判据可以判定正定：$\boldsymbol x^{\mathrm T} \boldsymbol A \boldsymbol x &gt; 0, (\boldsymbol x 为任意向量，但是\boldsymbol x \neq  0)$。已经分析了判据3主元要大于零的原因，因为它是配方后的参数，只有都大于零才能保证正定。以下对于判据1和2做简要说明。  </p>
<ul>
<li><strong>判据1：所有特征值大于0</strong></li>
</ul>
<p>对称矩阵$\boldsymbol A$，其正交的特征向量可以张成整个空间，因此任意向量$\boldsymbol x$均可表示成特征向量的线性组合</p>
<script type="math/tex; mode=display">
\boldsymbol x = c_1\boldsymbol x_1+c_2\boldsymbol x_2+\dots + c_n\boldsymbol x_n</script><p>代入得：</p>
<script type="math/tex; mode=display">
\boldsymbol x^{\mathrm T} \boldsymbol A \boldsymbol x = c_1^2 \lambda_1 + c_2^2 \lambda_2 + \dots + c_n^2 \lambda_n</script><p>当特征值都大于零且$\boldsymbol x \neq  0)$时，才能保证$\boldsymbol x^{\mathrm T} \boldsymbol A \boldsymbol x &gt; 0$。因此条件1与正定性等价。 </p>
<ul>
<li><strong>判据2：所有子行列式大于0</strong></li>
</ul>
<p>记$\boldsymbol A_k$ 为矩阵$\boldsymbol A$左上角$k$阶方块，取特殊向量<script type="math/tex">x=\left[\begin{array}{l} \boldsymbol x_k \\ \boldsymbol 0 \end{array}\right]</script>即后$n-k$个元素为0，则有：</p>
<script type="math/tex; mode=display">
\boldsymbol{x}^{T} \boldsymbol{A} \boldsymbol{x}=\left[\begin{array}{ll}
\boldsymbol x_{k} & \boldsymbol 0
\end{array}\right]\left[\begin{array}{cc}
\boldsymbol A_{k} & * \\
* & *
\end{array}\right]\left[\begin{array}{c}
\boldsymbol x_{k} \\
\boldsymbol 0
\end{array}\right]=\boldsymbol{x}_{k}^{T} \boldsymbol{A}_{k} \boldsymbol{x}_{k}</script><p>若矩阵$\boldsymbol A$满足正定性，则所有$\boldsymbol A_k$均满足正定性。已证明正定性等价于特征值均为正，而矩阵行列式等于特征值之积，因此可知子行列式均大于零。反之亦成立，两命题等价。 </p>
<h3 id="第二十八讲-相似矩阵和若尔当标准型"><a href="#第二十八讲-相似矩阵和若尔当标准型" class="headerlink" title="第二十八讲 相似矩阵和若尔当标准型"></a>第二十八讲 相似矩阵和若尔当标准型</h3><p>本讲介绍相似矩阵，这些内容以及奇异值分解是线性代数最核心的概念。 </p>
<blockquote>
<p>Strang 老师说了, Jordan标准型不再是线性代数的核心，现代线性代数尤其是AI也不怎么用到他，所以此节略去Jordan型的内容。这一讲重点讲解相似矩阵 </p>
</blockquote>
<h4 id="28-1-正定矩阵-boldsymbol-A-mathrm-T-boldsymbol-A"><a href="#28-1-正定矩阵-boldsymbol-A-mathrm-T-boldsymbol-A" class="headerlink" title="28.1 正定矩阵 $\boldsymbol A^{\mathrm T} \boldsymbol A$"></a>28.1 正定矩阵 $\boldsymbol A^{\mathrm T} \boldsymbol A$</h4><p>若矩阵$\boldsymbol A$满足对任意向量$\boldsymbol x_0$均有$\boldsymbol x^{\mathrm T} \boldsymbol A \boldsymbol x &gt; 0$，则称矩阵为正定矩阵，可以通过特征值、主元和行列式的办法来判断矩阵的正定性。</p>
<p><strong>正定矩阵来自于最小二乘问题</strong>。有大量的实际问题用到了长方形矩阵，而最小二乘问题中用到了长方形矩阵的积$\boldsymbol A^{\mathrm T} \boldsymbol A$，它是正定矩阵。</p>
<p>正定矩阵$\boldsymbol A$是对称矩阵，它的逆矩阵$\boldsymbol A^{-1}$也是正定矩阵，逆矩阵的特征值是原矩阵的倒数，因此也都是正数。若矩阵$\boldsymbol A$和$\boldsymbol B$都是正定矩阵，则$\boldsymbol {A+B}$也是正定矩阵：$\boldsymbol x^{\mathrm T} \boldsymbol A \boldsymbol x &gt; 0$，$\boldsymbol x^{\mathrm T} \boldsymbol B \boldsymbol x &gt; 0$，则有$\boldsymbol x^{\mathrm T} (\boldsymbol {A+B}) \boldsymbol x &gt; 0$ 。</p>
<p>如果$\boldsymbol A$是一个$m \times n$长方形矩阵，则$\boldsymbol A^{\mathrm T} \boldsymbol A$是对称方阵。通过讨论$\boldsymbol x^{\mathrm T} (\boldsymbol A^{\mathrm T} \boldsymbol A) \boldsymbol x &gt; 0$的正负可以确认它是正定矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol x^{\mathrm T} (\boldsymbol A^{\mathrm T} \boldsymbol A) \boldsymbol x = (\boldsymbol A \boldsymbol x)^{\mathrm T} (\boldsymbol A \boldsymbol x) = |\boldsymbol A \boldsymbol x|^2 \geq 0</script><p>当且仅当$\boldsymbol A \boldsymbol x = \boldsymbol 0$时，上面表达式取等号为0。当矩阵$\boldsymbol A$的各列线性无关时，即矩阵为列满秩$r=n$，$\boldsymbol A$的零空间只有零向量，即此条件下仅有零向量，满足$\boldsymbol x^{\mathrm T} (\boldsymbol A^{\mathrm T} \boldsymbol A) \boldsymbol x = 0$。因此矩阵列满秩时，$\boldsymbol A^{\mathrm T} \boldsymbol A$是正定矩阵。正定矩阵将之前的知识点串联起来。</p>
<h4 id="28-2-相似矩阵-Similar-matrices"><a href="#28-2-相似矩阵-Similar-matrices" class="headerlink" title="28.2 相似矩阵 Similar matrices"></a>28.2 相似矩阵 Similar matrices</h4><p>$\boldsymbol A$和$\boldsymbol B$均是$n \times n$方阵，若存在可逆矩阵$\boldsymbol M$，使得$\boldsymbol B = \boldsymbol {M^{-1}AM}$，则$\boldsymbol A$和$\boldsymbol B$为相似矩阵。 </p>
<h5 id="一-特征值互不相同-Distinct-eigenvalues"><a href="#一-特征值互不相同-Distinct-eigenvalues" class="headerlink" title="(一) 特征值互不相同 Distinct eigenvalues"></a>(一) 特征值互不相同 Distinct eigenvalues</h5><p>若矩阵$\boldsymbol A$具有$n$个线性无关的特征向量，可以对角化得到$\boldsymbol {S^{-1}AS} = \boldsymbol \Lambda$，则$\boldsymbol A$相似于$\boldsymbol \Lambda$，这里的$\boldsymbol M$是特征向量矩阵$\boldsymbol S$。如果将$\boldsymbol M$取其它可逆矩阵，可以得到和$\boldsymbol A$相似的另一矩阵$\boldsymbol B$，实际上这样可以定义一类矩阵，$\boldsymbol \Lambda$是其中最简洁的一个。 </p>
<p>例： <script type="math/tex">\boldsymbol A=\left[\begin{array}{ll} 2 & 1 \\ 1 & 2\end{array}\right]</script>，则<script type="math/tex">\boldsymbol \Lambda = \left[\begin{array}{ll} 3 & 0 \\ 0 & 1\end{array}\right]</script>，而取另一$\boldsymbol M$，则有：</p>
<script type="math/tex; mode=display">
\boldsymbol B = \boldsymbol {M^{-1}AM} =
\left[\begin{array}{cc}
1 & -4 \\
0 & 1
\end{array}\right]\left[\begin{array}{ll}
2 & 1 \\
1 & 2
\end{array}\right]\left[\begin{array}{ll}
1 & 4 \\
0 & 1
\end{array}\right]=\left[\begin{array}{cc}
-2 & -15 \\
1 & 6
\end{array}\right]</script><p>相似矩阵最重要的特性是：<font color="red"><strong>相似矩阵具有相同的特征值</strong></font>。事实上，所有特征值为3和1的二阶矩阵都是$\boldsymbol A$的相似矩阵。</p>
<p><strong>证明</strong>：矩阵$\boldsymbol A$的相似矩阵$\boldsymbol B = \boldsymbol {M^{-1}AM}$具有和矩阵$\boldsymbol A$相同的特征值：</p>
<p>矩阵$\boldsymbol A$具有的特征值$\lambda$ ，即存在特征向量$\boldsymbol x$满足$\boldsymbol {Ax} = \lambda \boldsymbol x$ 。则有： </p>
<script type="math/tex; mode=display">
\boldsymbol{A M M}^{-1} \boldsymbol{x} =\lambda \boldsymbol{x} \\
\Downarrow  \\
\boldsymbol M^{-1}\boldsymbol{A M M}^{-1} \boldsymbol{x} =\lambda \boldsymbol M^{-1} \boldsymbol{x} \\
\Downarrow \\
\boldsymbol{B} (\boldsymbol M^{-1} \boldsymbol{x}) =\lambda (\boldsymbol M^{-1} \boldsymbol{x})</script><p>即矩阵$\boldsymbol B$具有特征值$\lambda$，且特征向量为$\boldsymbol M^{-1} \boldsymbol{x}$。</p>
<p>因此，相似矩阵具有相同的特征值，并且线性无关的特征向量的个数相同，但是特征向量往往不同。如果矩阵$\boldsymbol A$的特征值互不相等$\lambda_1 \neq \lambda_2 \neq \dots \neq \lambda_n$，且与另一个矩阵$\boldsymbol B$的特征值完全相同，则它们与相同的对角矩阵$\boldsymbol \Lambda$相似。</p>
<h5 id="二-重特征值-Repeated-eigenvalues"><a href="#二-重特征值-Repeated-eigenvalues" class="headerlink" title="(二) 重特征值 Repeated eigenvalues"></a>(二) 重特征值 Repeated eigenvalues</h5><p> 如果矩阵有重特征值，则可能无法进行对角化。 </p>
<p>例：二阶矩阵有重特征值$\lambda_1 = \lambda_2 = 4$</p>
<ul>
<li>第一类： 只与自己相似——<script type="math/tex">\left[\begin{array}{cc} 4 & 0 \\ 0 & 4\end{array}\right]</script></li>
</ul>
<script type="math/tex; mode=display">
\boldsymbol{M}^{-1}\left[\begin{array}{ll}
4 & 0 \\
0 & 4
\end{array}\right] \boldsymbol{M}=4 \boldsymbol{M}^{-1} \boldsymbol{I} \boldsymbol{M}=\left[\begin{array}{ll}
4 & 0 \\
0 & 4
\end{array}\right]</script><p>这个系列的相似矩阵仅包含其自身。 </p>
<ul>
<li>第二类：包含其它所有的重特征值为4的矩阵，其中最简洁的是 —— <script type="math/tex">\left[\begin{array}{cc} 4 & 1 \\ 0 & 4\end{array}\right]</script></li>
</ul>
<p>元素1的位置换上其它数值仍然是相似矩阵。这个最优形式称为<strong>若尔当(Jordan form)标准型</strong>。有了这个理论，就可以处理不可对角化的矩阵，完成近似的“对角化”转化为若尔当标准型进行处理。 </p>
<p>与<script type="math/tex">\left[\begin{array}{cc} 4 & 1 \\ 0 & 4\end{array}\right]</script>相似的矩阵，迹为8，行列式为16，因此我们可以构造出很多相似矩阵：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cc} 5 & 1 \\ -1 & 3\end{array}\right], \left[\begin{array}{cc} 4 & 0 \\ 17 & 4\end{array}\right], \left[\begin{array}{cc} a & * \\ * & 8-a\end{array}\right]</script><p>它们都不能对角化(因为若可以对角化则按照特征值可知结果为$4 \boldsymbol I$，而只$4 \boldsymbol I$与自己相似）。 </p>
<h5 id="三-若尔当标准型-Jordan-form"><a href="#三-若尔当标准型-Jordan-form" class="headerlink" title="(三) 若尔当标准型 Jordan form"></a>(三) 若尔当标准型 Jordan form</h5><p>更复杂的情况，一个四阶矩阵具有重特征值0：$\lambda_1 = \lambda_2 = \lambda_3 = \lambda_4 = 0$。如下面的例子所示。</p>
<p>矩阵<script type="math/tex">\boldsymbol A=\left(\begin{array}{cccc} 0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0\end{array}\right)</script>，它的秩为2，因此其零空间的维数为$4-2=2$，而零空间的向量就是矩阵的特征向量，满足$\boldsymbol{Ax} = 0\boldsymbol{x} $，所以矩阵$\boldsymbol{A}$只有两个特征向量。若尔当指出上对角线每增加一个1，矩阵就减掉一个特征向量，本例中特征向量数为$4-2=2$。 </p>
<p> 矩阵<script type="math/tex">\boldsymbol B=\left(\begin{array}{cccc} 0 & 1 & 7 & 0\\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0\end{array}\right)</script>与矩阵<script type="math/tex">\boldsymbol A=\left(\begin{array}{cccc} 0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0\end{array}\right)</script>为相似矩阵。 </p>
<p>但矩阵<script type="math/tex">\boldsymbol C=\left(\begin{array}{cccc} 0 & 1 & 0 & 0\\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0\end{array}\right)</script>与矩阵<script type="math/tex">\boldsymbol A=\left(\begin{array}{cccc} 0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0\end{array}\right)</script>并不是相似矩阵，两者具有不同的若尔当块。 </p>
<p>若尔当块形如：</p>
<script type="math/tex; mode=display">
\boldsymbol J_i=\left[\begin{array}{ccccc}
\lambda_{i} & 1 & 0 & \cdots & 0 \\
0 & \lambda_{i} & 1 & \ddots & \vdots \\
0 & 0 & \ddots & \ddots & 0 \\
\vdots & \vdots & \ddots & \ddots & 1 \\
0 & 0 & \cdots & 0 & \lambda_{i}
\end{array}\right]</script><p>对角线上为重特征值$\lambda_i$，上对角线为1，其它位置的元素均为0，每个若尔当块只有1个特征向量。若干个若尔当块可以拼成一个若尔当矩阵。</p>
<script type="math/tex; mode=display">
\boldsymbol{J}=\left[\begin{array}{cccc}
\boldsymbol{J}_{1} & 0 & \cdots & 0 \\
0 & \boldsymbol{J}_{2} & \cdots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
0 & 0 & \cdots & \boldsymbol{J}_{d}
\end{array}\right]</script><p>两个矩阵具有相同的特征值和特征向量个数，但是其若尔当块的尺寸不同，两者也并不是相似矩阵。如前述矩阵$\boldsymbol A$与并$\boldsymbol C$不相似。</p>
<p>若尔当理论：任意$n$阶矩阵$\boldsymbol A$都与一个若尔当矩阵$\boldsymbol J$相似。若尔当矩阵中的每一个若尔当块对应一个特征向量。若矩阵具有$n$个不同的特征向量，则可以对角化，此时其若尔当标准型$\boldsymbol J$就是对角矩阵$\boldsymbol \Lambda$。若出现重特征值，则特征向量个数变少。</p>
<blockquote>
<p>说到了$\boldsymbol A^{\mathrm T} \boldsymbol A$和最小二乘问题就要解释一下G.Strang举的曲线拟合的例子，都是线性公式$y=ax+b$，但实际上最小二乘法也处理非线性方程，因为这里所谓的非线性是对$x$而言，而只要对于所求的参数是线性方程就可以。比如下面的例子中$x$的方幂组成的矩阵$\boldsymbol X$只是一个系数矩阵，对于所求的参数$β$这仍是个线性方程组。</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/627378b509475431296c80fa.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/627378c809475431296ca597.jpg"></p>
<ul>
<li><strong>相似矩阵拥有相同的特征值，但是特向量一般不相等(如果特征向量也相等那估计就是同一个矩阵了)</strong></li>
<li><strong>如果两个矩阵拥有n个相同的特征值，那么他们必然相似于某个对角矩阵。</strong></li>
</ul>
<h3 id="第二十九讲-奇异值分解SVD"><a href="#第二十九讲-奇异值分解SVD" class="headerlink" title="第二十九讲 奇异值分解SVD"></a>第二十九讲 奇异值分解SVD</h3><p><img src="https://pic.imgdb.cn/item/6279aad50947543129d3b40d.jpg" style="zoom:70%"></p>
<h4 id="29-1-简介"><a href="#29-1-简介" class="headerlink" title="29.1 简介"></a>29.1 简介</h4><p>本讲介绍奇异值分解（Singular value decomposition），简称SVD。这是矩阵最终也是最好的分解，任意矩阵可分解为$\boldsymbol {A = U Σ V}^{\mathrm T}$，分解结果为正交矩阵$\boldsymbol U$，对角阵$\boldsymbol Σ$和正交矩阵$\boldsymbol V$ 。</p>
<p>如果矩阵$\boldsymbol A$是正定矩阵，它的奇异值分解就是$\boldsymbol {A = Q \Lambda Q}^{\mathrm T}$，一个正交矩阵$\boldsymbol Q$就可以满足分解，而不需要两个。而对于可对角化的矩阵有$\boldsymbol {A = S \Lambda S}^{-1}$，但特征向量矩阵$\boldsymbol S$并不是正交矩阵，而SVD中的$\boldsymbol U$和$\boldsymbol V$都是正交矩阵。</p>
<h4 id="29-2-对矩阵进行SVD分解"><a href="#29-2-对矩阵进行SVD分解" class="headerlink" title="29.2 对矩阵进行SVD分解"></a>29.2 对矩阵进行SVD分解</h4><p>可将矩阵$\boldsymbol A$视为一种线性变换操作，将其行空间的一个向量$\boldsymbol v_1$,变为其列空间中的向量$\boldsymbol u_1 = \boldsymbol{Av}_1$ 。奇异值分解就是要在行空间中寻找一组正交基，将其通过矩阵$\boldsymbol A$线性变换生成列空间中的一组正交基$\boldsymbol{Av}_i = \sigma_i \boldsymbol u_i$。 </p>
<p><img src="https://pic.imgdb.cn/item/6279ad7e0947543129d7d307.jpg" style="zoom:70%"></p>
<p>找出矩阵$\boldsymbol A$行空间中的正交基很容易，Gram-Schmidt正交化过程就可以做到，但是随便的一组正交基经过矩阵矩阵$\boldsymbol A$变换得到的向量并不一定正交，因此满足此要求的行空间的正交基非常特殊。而矩阵$\boldsymbol A$零空间的向量所对应的是矩阵$\boldsymbol Σ$对角线上的0元素，因此很容易处理。 </p>
<ul>
<li>问题的核心就是找到行空间中一组特殊的正交基： </li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{A}\left[\begin{array}{llll}
\boldsymbol{v}_{1} & \boldsymbol{v}_{2} & \cdots & \boldsymbol{v}_{r}
\end{array}\right] &=\left[\begin{array}{lllll}
\sigma_{1} \boldsymbol{u}_{1} & \sigma_{2} \boldsymbol{u}_{2} & \cdots & \sigma_{r} \boldsymbol{u}_{r}
\end{array}\right] \\
&=\left[\begin{array}{lllll}
\boldsymbol{u}_{1} & \boldsymbol{u}_{2} & \cdots & \boldsymbol{u}_{r}
\end{array}\right]\left[\begin{array}{ccc}
\sigma_{1} & & \\
& \sigma_{2} & & \\
& & \ddots & \\
& & & \sigma_{r}
\end{array}\right]
\end{aligned}</script><p>如果加入零空间的部分，等式就变为$\boldsymbol {AV = U Σ}$，其中<script type="math/tex">\boldsymbol V = \boldsymbol V_行 + \boldsymbol V_零</script>。</p>
<ul>
<li><p>选取的行空间的一组基向量为：<script type="math/tex">\boldsymbol V_行 = \boldsymbol v_1, \boldsymbol v_2,  \cdots  ,\boldsymbol{v}_{r}</script></p>
</li>
<li><p>零空间对应的正交基<script type="math/tex">\boldsymbol V_零 = \boldsymbol v_{r+1}, \dots ,\boldsymbol v_{n}</script>，经过线性变换得到<script type="math/tex">\boldsymbol {AV_零 = 0}</script>，对应矩阵$\boldsymbol Σ$中对角线最后的特征值<script type="math/tex">\sigma_{r+1} = \sigma_{r+2} = \dots = \sigma_{n} = 0</script>。</p>
</li>
</ul>
<p>在等式<script type="math/tex">\boldsymbol {AV = U Σ}</script>两侧右乘<script type="math/tex">\boldsymbol V^{-1}</script>得到<script type="math/tex">\boldsymbol{A = U Σ V}^{-1} = \boldsymbol{U Σ V}^{\mathrm T}</script>。</p>
<p>现在的问题就是怎么找到符合要求的向量$\boldsymbol v_i, \boldsymbol u_i$。</p>
<p>为了得到这两个正交矩阵，考虑首先解决其中的一个，在等式$\boldsymbol {A = U Σ V}^{\mathrm T}$两侧分别乘上等式$\boldsymbol A^{\mathrm T} = \boldsymbol{VΣ}^{\mathrm T}\boldsymbol{U}^{\mathrm T}$ 两侧的项：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol{A}^{T} \boldsymbol{A} &=\boldsymbol{V} \boldsymbol{\Sigma}^{T} \boldsymbol{U}^{T} \boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^{T} \\
&=\boldsymbol{V} \boldsymbol{\Sigma}^{T} \boldsymbol{\Sigma} \boldsymbol{V}^{T} \\
&=\boldsymbol{V}\left[\begin{array}{llll}
\sigma_{1}{ }^{2} & & & \\
& \sigma_{2}{ }^{2} & & \\
& & \ddots & \\
& & & \sigma_{r}{ }^{2}
\end{array}\right] \boldsymbol{V}^{T}
\end{aligned}</script><p>注意到$\boldsymbol {A}^{\mathrm T} \boldsymbol {A}$是一个对称方阵，并且符合正定矩阵正交分解的形式，上式其实就是正定矩阵$\boldsymbol {A}^{\mathrm T} \boldsymbol {A}$的正交分解，$\boldsymbol v_i$就是矩阵$\boldsymbol {A}^{\mathrm T} \boldsymbol {A}$的特征向量，$\sigma_i^2$就是矩阵$\boldsymbol {A}^{\mathrm T} \boldsymbol {A}$的特征值，奇异值$\sigma_i$要取正平方根。用同样的办法也可以求得$\boldsymbol U$，它的列向量就是矩阵$\boldsymbol {A} \boldsymbol {A}^{\mathrm T}$的的特征向量。 </p>
<blockquote>
<p>注意：上述求$\boldsymbol V$或者$\boldsymbol U$即——两侧分别乘上等式$\boldsymbol A^{\mathrm T} = \boldsymbol{VΣ}^{\mathrm T}\boldsymbol{U}^{\mathrm T}$ 的方法只能用于$\boldsymbol V$或者$\boldsymbol U$求解某一个，不能将$\boldsymbol V$和$\boldsymbol U$都用这种方法求解，这是因为确定特征向量的过程中，特征向量反向仍然符合要求，通过现在的方法无法确认向量的符号，但是一旦我们确认的$\boldsymbol V$方向之后，$\boldsymbol U$的方向也就随之确定，将$\boldsymbol V$代入<script type="math/tex">\boldsymbol {AV = U Σ}</script>计算$\boldsymbol U$可以避免这种问题。$\boldsymbol V$和$\boldsymbol U$之间的符号联系在进行$\boldsymbol {A}^{\mathrm T} \boldsymbol {A}$的计算时被切断了，而用<script type="math/tex">\boldsymbol {AV = U Σ}</script>计算可以避免此问题。 </p>
<p>我们注意到，如果$\boldsymbol U$的一个向量反向，$\boldsymbol U$中的两个向量仍然是正交向量，且此时可以完成奇异值分解，这是因为在奇异值分解的过程中，一旦确认了$\boldsymbol V$中向量的方向之后，$\boldsymbol U$中向量的方向也一起被限定了，而在本例中，我们用一种和$\boldsymbol V$无关的方式求得了$\boldsymbol U$，而这种方法并不一定总是有效，需要尝试改变向量的方向。通过将$\boldsymbol V$代入<script type="math/tex">\boldsymbol {AV = U Σ}</script>求得$\boldsymbol U$，可以避免这个问题。  </p>
</blockquote>
<h4 id="29-3-小结语"><a href="#29-3-小结语" class="headerlink" title="29.3 小结语"></a>29.3 小结语</h4><p>做奇异值分解就是在矩阵的四个子空间中寻找到合适的基：</p>
<ul>
<li>$\boldsymbol v_1, \boldsymbol v_2, \dots, \boldsymbol v_r$为行空间的标准正交基</li>
<li>$\boldsymbol u_1, \boldsymbol u_2, \dots, \boldsymbol u_r$为列空间的标准正交基</li>
<li><script type="math/tex">\boldsymbol v_{r+1}, \boldsymbol v_{r+2}, \dots, \boldsymbol v_n</script>为零空间的标准正交基</li>
<li><script type="math/tex">\boldsymbol u_{r+1}, \boldsymbol u_{r+2}, \dots, \boldsymbol u_m</script>为左零空间的标准正交基</li>
</ul>
<blockquote>
<p>奇异值分解在最小二乘法问题中有重要应用，因为在实际问题中常碰到矩阵$\boldsymbol A$不是列满秩的状态，因此$\boldsymbol {A}^{\mathrm T} \boldsymbol {A}$不可逆，无法用之前的方法求最优解。即使是列满秩的情况当矩阵是超大型矩阵时，$\boldsymbol {A}^{\mathrm T} \boldsymbol {A}$的计算量太大，用奇异值分解的办法会降低计算量。</p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/6279b8280947543129f1ef20.jpg"></p>
<blockquote>
<p>图为G.Strang给出的二阶方阵SVD的几何意义</p>
<p>关于该图的解释、奇异阵的意义、以及奇异阵为什么能丢掉请看一下链接：</p>
<p>【SVD的数学涵义及其应用实例 - 钱默吟的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/57803955">https://zhuanlan.zhihu.com/p/57803955</a> 】</p>
<p>【奇异值的物理意义是什么？ - 知乎 <a href="https://www.zhihu.com/question/22237507">https://www.zhihu.com/question/22237507</a> 】</p>
<p>【为什么PCA中奇异值分解（SVD）和特征分解可以降低数据维度 <a href="https://blog.csdn.net/qq_41987033/article/details/81211574】">https://blog.csdn.net/qq_41987033/article/details/81211574】</a></p>
</blockquote>
<h3 id="第三十讲-线性变换及对应矩阵"><a href="#第三十讲-线性变换及对应矩阵" class="headerlink" title="第三十讲 线性变换及对应矩阵"></a>第三十讲 线性变换及对应矩阵</h3><p>本讲介绍线性变换。在传统的线代课程中，线性变换会出现在的比矩阵还要早的位置，实际上可以在脱离坐标和具体数值的情况下讨论线性变换。但是面对科学计算的课题，还是要回到坐标上来。每个线性变换都对应于一个矩阵，矩阵概念的背后就是线性变换的概念。 </p>
<blockquote>
<p>无论是“线性变换”还是“矩阵”，对于初学者来说都是陌生而且突兀的概念。矩阵看起来直观，但是其运算规则总让人摸不着头脑；线性变换的概念显得抽象一些，但其实也可以描述得很朴素。G.Strang是从矩阵的概念出发，往求解线性方程组的方向引导大家，他最成功的地方是引入了列图像以及矩阵乘法的行操作、列操作,将矩阵运算变得不那么“没头没脑”。而之前推荐过的《线性代数应该这样学》是从线性变换的角度出发，用朴素的描述在更高的抽象层面讨论，很多原理与法则就变得比较简洁。个人认为两者都优于从行列式出发进入线性代数的路线。在《理解矩阵》中，作者写到矩阵的背后就是线性变换，相似矩阵描述的实际上是同一种线性变换。G.Strang说理解线性变换的本质就是找到它背后的矩阵。这实际上是一个意思，只是出发点和看问题的角度不同。当具体的矩阵和抽象的线性变换在大脑中合二为一的时候，才是对线代最本质的理解。 线性变换和矩阵的关系还可以参考以下课程，在2D空间中这个关系更容易描述： </p>
</blockquote>
<h4 id="30-1-几个小例子"><a href="#30-1-几个小例子" class="headerlink" title="30.1 几个小例子"></a>30.1 几个小例子</h4><ul>
<li><strong>正例1：投影 Projection</strong></li>
</ul>
<p>抛开矩阵，从线性变换的概念来讨论“投影”。通过线性变换使得平面内的一个向量变为平面内的另一个向量，这种变换关系通常称之为“映射”（mapping）。</p>
<p>$T：R^2→R^2$</p>
<p>$T(\boldsymbol v)$就像一个函数，给一个”输入”，进行线性变换后得到一个”输出”。比如将二维平面的向量投影到一条直线上。</p>
<p>线性代数只讨论线性变换，而线性变换符合如下规则：</p>
<p>对于任意向量$\boldsymbol v，\boldsymbol w$和标量$c$，有</p>
<script type="math/tex; mode=display">
T(\boldsymbol{v+w})=T(\boldsymbol v)+T(\boldsymbol w); T(c\boldsymbol v)=cT(\boldsymbol v)</script><p>将两者结合就得到：</p>
<script type="math/tex; mode=display">
T(c\boldsymbol v+d\boldsymbol w)=cT(\boldsymbol v)+dT(\boldsymbol w)</script><ul>
<li><strong>正例2：旋转45度 Rotation by 45</strong></li>
</ul>
<p>这个变换$T：R^2→R^2$，是一个线性变换，数乘和加法均符合。</p>
<ul>
<li><strong>反例1：平面平移 Shift whole plane</strong></li>
</ul>
<p>沿着某方向$\boldsymbol v_0$平移一个平面。这就不是一个线性变换。两条法则都违反。更简单的验证方法是线性运算规则的特例$T(\boldsymbol 0) = \boldsymbol 0$，“平移”不符合这个规则特例。</p>
<ul>
<li><strong>反例2：求长度$T(\boldsymbol v) = ||\boldsymbol v||$</strong></li>
</ul>
<p>这个变换，输入一个三维向量，得到一个数值(或者说一维向量)，即$T：R^3→R^1$。该变换可以满足$T(\boldsymbol 0) = \boldsymbol 0$，但是数乘负数就不符合规则。</p>
<h4 id="30-2-线性变换"><a href="#30-2-线性变换" class="headerlink" title="30.2 线性变换"></a>30.2 线性变换</h4><p>对二维平面的图像做线性变换的操作示意图。 </p>
<p><img src="https://pic.imgdb.cn/item/627a09500947543129e7ee9f.jpg"></p>
<p>矩阵$T(\boldsymbol v) = \boldsymbol{Av}$，矩阵乘法是一个线性变换：</p>
<script type="math/tex; mode=display">
\boldsymbol {A(v+w)} = \boldsymbol {Av} + \boldsymbol {Aw}; \boldsymbol A c \boldsymbol v = c \boldsymbol {Av}</script><p>整个平面可以通过矩阵的乘法完成变换。</p>
<p>例如，对上图的房子图像施加矩阵<script type="math/tex">\boldsymbol A=\left(\begin{array}{cc} 1 & 0 \\ 0 & -1\end{array}\right)</script> ，则输出的是上下颠倒的房子。</p>
<p><strong><font color="red">理解线性变换的本质就是确定它背后的矩阵</font></strong>。</p>
<p><strong>例：</strong>对某一线性变换$T：R^3→R^2$，输入一个三维向量而输出是一个二维向量。变成矩阵的形式$T(\boldsymbol v) = \boldsymbol{Av}$，则矩阵$\boldsymbol A$是一个$2 \times 3$矩阵。</p>
<h4 id="30-3-描述线性变换-Describing-T-v"><a href="#30-3-描述线性变换-Describing-T-v" class="headerlink" title="30.3 描述线性变换 Describing T(v)"></a>30.3 描述线性变换 Describing T<strong>(</strong>v)</h4><p>在平面内，如果我们已经了解两个线性无关的向量$\boldsymbol v_1$和$\boldsymbol v_2$经过线性变换的结果$T(\boldsymbol v_1)$和$T(\boldsymbol v_1)$，我们实际上可以通过其线性组合，了解平面内所有的向量线性变换的结果。因此如果我们想了解线性变换对整个输入空间的影响，只需要确定它的一组基$\boldsymbol v_1, \boldsymbol v_2, \dots, \boldsymbol v_n$线性变换的结果。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\boldsymbol{v}=c_{1} \boldsymbol{v}_{1}+c_{2} \boldsymbol{v}_{2}+\ldots+c_{n} \boldsymbol{v}_{n} \\
&\boldsymbol{T}(\boldsymbol{v})=c_{1} \boldsymbol{T}\left(\boldsymbol{v}_{1}\right)+c_{2} \boldsymbol{T}\left(\boldsymbol{v}_{2}\right)+\ldots+c_{n} \boldsymbol{T}\left(\boldsymbol{v}_{n}\right)
\end{aligned}</script><p><strong><font color="green">线性变换与坐标无关，而矩阵是与坐标有关的</font></strong>。选定一组基，则对于一个向量而言$c_1, c_2$等等就是一组坐标值，给定了将向量表示为基向量线性组合的唯一的表达式。因此可以说坐标源自于一组基，$c_1, c_2, \dots, c_n$就是向量的一组坐标值。通常给出空间的坐标是标准坐标，即一组标准基。例如：</p>
<script type="math/tex; mode=display">
\boldsymbol{v}=\left[\begin{array}{l}
3 \\
2 \\
4
\end{array}\right]=3\left[\begin{array}{l}
1 \\
0 \\
0
\end{array}\right]+2\left[\begin{array}{l}
0 \\
1 \\
0
\end{array}\right]+4\left[\begin{array}{l}
0 \\
0 \\
1
\end{array}\right]</script><p>如果用矩阵$\boldsymbol A$来表示线性变换$T：R^n→R^m$。则需要两组基，即输入空间的一组基和输出空间的一组基，来分别确认输入向量与输出向量的坐标。设$\boldsymbol v_1，\boldsymbol v_2, \dots ,\boldsymbol v_n$为输入空间的基，而为输出$\boldsymbol w_1，\boldsymbol w_2, \dots ,\boldsymbol w_n$空间的基，用矩阵来表示线性变换就是将向量的坐标乘以矩阵得到它在输出空间的坐标。</p>
<ul>
<li><strong>例：投影</strong></li>
</ul>
<p>将二维平面内的向量投影到一条直线，选择输入空间基向量为$\boldsymbol v_1$和$\boldsymbol v_2$，其中$\boldsymbol v_1$沿着投影方向，$\boldsymbol v_2$垂直于投影方向，输出空间基选择$\boldsymbol w_1 = \boldsymbol v_1, \boldsymbol w_2 = \boldsymbol v_2$。对于输入空间中任意向量$\boldsymbol v$有$\boldsymbol v = c_1 \boldsymbol v_1 + c_2 \boldsymbol v_2$，输出为$T(\boldsymbol v) = c_1 \boldsymbol v_1$。 </p>
<p>因此这个线性变换的矩阵就是<script type="math/tex">\boldsymbol A=\left(\begin{array}{cc} 1 & 0 \\ 0 & 0\end{array}\right)</script>，输入<script type="math/tex">\left[\begin{array}{l} c_1 \\ c_2\end{array}\right]</script>得到<script type="math/tex">\left[\begin{array}{cc} 4 & 0 \\ 0 & 4\end{array}\right] \left[\begin{array}{l} c_1 \\ c_2\end{array}\right] = \left[\begin{array}{l} c_1 \\ 0 \end{array}\right]</script>。这组例子中实际上我们以投影矩阵的特征向量为基，因此得到的矩阵$\boldsymbol A$是对角阵。对角线上就是投影矩阵的特征值1和0。</p>
<p>而如果我们以标准坐标为基，即<script type="math/tex">\boldsymbol w_1 = \boldsymbol v_1 = \left[\begin{array}{l} 1 \\ 0\end{array}\right]</script>，<script type="math/tex">\boldsymbol w_2 = \boldsymbol v_2 = \left[\begin{array}{l} 0 \\ 1\end{array}\right]</script> 。对应的投影矩阵就是之前学到的投影矩阵$\boldsymbol P = \dfrac{\boldsymbol {aa}^{\mathrm T}}{\boldsymbol a^{\mathrm T} \boldsymbol a}$对于投影到斜率45度的直线，<script type="math/tex">\boldsymbol P=\left(\begin{array}{cc} \dfrac{1}{2} & \dfrac{1}{2} \\ \dfrac{1}{2} & \dfrac{1}{2}\end{array}\right)</script></p>
<h4 id="30-4-如何确定矩阵A-Rule-to-find-A"><a href="#30-4-如何确定矩阵A-Rule-to-find-A" class="headerlink" title="30.4 如何确定矩阵A Rule to find A"></a>30.4 如何确定矩阵A Rule to find A</h4><p>矩阵$\boldsymbol A$的列实际上是描述输入原空间的基向量得到的列空间线性组合的系数：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\boldsymbol{T}\left(\boldsymbol{v}_{1}\right)=a_{11} \boldsymbol{w}_{1}+a_{21} \boldsymbol{w}_{2}+\ldots+a_{m 1} \boldsymbol{w}_{m} \\
&\boldsymbol{T}\left(\boldsymbol{v}_{2}\right)=a_{12} \boldsymbol{w}_{1}+a_{22} \boldsymbol{w}_{2}+\ldots+a_{m 2} \boldsymbol{w}_{m} \\
& \dots
\end{aligned}</script><p>这样矩阵$\boldsymbol A$就满足“$\boldsymbol A [输入向量的坐标]=[输出空间的坐标]$”。</p>
<p>例如：<script type="math/tex">\boldsymbol{A}\left[\begin{array}{c} 1 \\ 0 \\ \vdots \\ 0 \end{array}\right]=\left[\begin{array}{c}a_{11} \\ a_{21} \\ \vdots \\ a_{m 1} \end{array}\right]</script>，所得结果就是输出空间的坐标，也就是输出空间的基进行线性组合所需要的系数。</p>
<ul>
<li>介绍一个特别的线性变换——求导，$T = \dfrac{\mathrm{d}}{\mathrm d x}$<ul>
<li>输入：$c_1 + c_2 x + c_3 x^2$ ，基：$1, x, x^2$</li>
<li>输出：$c_2 + 2c_3 x$ ，基：$1, x$</li>
</ul>
</li>
</ul>
<p>这是一个$T:R^3 \to R^2$的线性变换。</p>
<p>矩阵$\boldsymbol A$满足：<script type="math/tex">\boldsymbol{A}\left[\begin{array}{c} c_1 \\ c_2 \\ c_3 \end{array}\right]=\left[\begin{array}{c} c_2 \\ 2c_3 \end{array}\right]</script>，可求得矩阵<script type="math/tex">\boldsymbol A=\left(\begin{array}{ccc} 0& 1 & 0 \\ 0 & 0 & 2\end{array}\right)</script> 。</p>
<p><strong>更普遍的来讲，矩阵的逆矩阵就是线性变换的逆变换，矩阵的乘积就是线性变换的乘积，矩阵乘法源自于线性变换。</strong></p>
<h3 id="第三十一讲-基变换和图像压缩"><a href="#第三十一讲-基变换和图像压缩" class="headerlink" title="第三十一讲 基变换和图像压缩"></a>第三十一讲 基变换和图像压缩</h3><p>本讲介绍基变换。选择合适的基向量会给计算制造便利。基变换的一个重要应用就是压缩，图像、影像、音频和其它一些数据都会因为基变换而得到更高效的压缩储存。本讲的主题仍旧是线性变换和矩阵的关联。 </p>
<h4 id="31-1-图像压缩-Compression-of-images"><a href="#31-1-图像压缩-Compression-of-images" class="headerlink" title="31.1 图像压缩 Compression of images"></a>31.1 图像压缩 Compression of images</h4><p>本讲涉及的压缩过程是有损压缩。例如一幅像素是$512 \times 512$的静态黑白图像，图像用一个向量来表示，向量的分量xi表示像素的灰度，变化范围$0 \leq x_i \leq 255$，占8bits。该向量属于$R^n$空间，$n=(512) \times (512)$。彩色图像描述每个点的像素需要三个数据，向量长度是黑白图像的3倍。</p>
<p>图像的标准压缩方式为<strong>JPEG</strong>(联合图像专家组 Joint Photographic Experts Group)。<strong>图像压缩的本质就是基变换</strong>。</p>
<p>压缩前图像采用的基向量是标准基。但是在图像中离得很近的区域，颜色是非常接近的，比如教学视频中黑板的一个区域，这些区域像素的灰度值很接近，但是用标准基来存储并没有利用上这一特点，这就给了我们压缩的空间。</p>
<p>标准基就是：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{c}
1 \\
0 \\
\vdots \\
0 \\
0
\end{array}\right],\left[\begin{array}{c}
0 \\
1 \\
\vdots \\
0 \\
0
\end{array}\right], \cdots , \left[\begin{array}{c}
0 \\
0 \\
\vdots \\
1 \\
0
\end{array}\right], \left[\begin{array}{c}
0 \\
0 \\
\vdots \\
0 \\
1
\end{array}\right]</script><p>而显然对于灰度很接近的情况(即一幅图像的灰度基本都是一个值)，<script type="math/tex">\left[\begin{array}{c} 1 \\ 1 \\ \vdots \\ 1 \\1 \end{array}\right]</script>是一个很好的基（代表低频信号，频率为0，平滑。在图像压缩后经常会存在，因为其系数通常很大），在一组基中有一个这样的向量能解决很大的问题，可以处理像素灰度接近一致的情况。但图像不是灰度完全一致的，因此接下来的问题是跟它相配合的基要选择哪些。极端的情况包括选择<script type="math/tex">\left[\begin{array}{c} +1 \\ -1 \\ +1 \\ -1 \\ \vdots \end{array}\right]</script>，它可以给出类似国际象棋盘那种黑白相间的状态（最高频信号，噪音、扰动……在图像压缩后很少存在），还有图像一半图像暗一半图像亮，可以选择<script type="math/tex">\left[\begin{array}{c} +1 \\ \vdots \\ +1 \\ -1 \\ \vdots \\ -1 \end{array}\right]</script>。</p>
<ul>
<li><strong>傅里叶基 Fourier basis</strong></li>
</ul>
<p>在JPEG中，将$512 \times 512$的区域划分为$8 \times 8$的区块进行处理，所用到的基是傅里叶基向量。</p>
<p>以$R^8$中的基举例：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
1 \\
1 \\
1 \\
1 \\
1 \\
1 \\
1 \\
1
\end{array}\right],\left[\begin{array}{c}
1 \\
\omega \\
\omega^{2} \\
\omega^{3} \\
\omega^{4} \\
\omega^{5} \\
\omega^{6} \\
\omega^{7}
\end{array}\right],\left[\begin{array}{c}
1 \\
\omega^{2} \\
\omega^{4} \\
\omega^{6} \\
\omega^{8} \\
\omega^{10} \\
\omega^{12} \\
\omega^{14}
\end{array}\right], \cdots, \left[\begin{array}{c}
1 \\
\omega^{7} \\
\omega^{14} \\
\omega^{21} \\
\omega^{28} \\
\omega^{35} \\
\omega^{42} \\
\omega^{49}
\end{array}\right]</script><p><img src="https://pic.imgdb.cn/item/627a1f5c0947543129253f77.jpg"></p>
<p>傅里叶基（Fourier basis）就是之前讲过的傅里叶矩阵的列向量，每个元素为复数的幂。在8x8区块中有64个系数，64个基向量，在这个64维空间中做基变换。</p>
<script type="math/tex; mode=display">
信号\boldsymbol x \stackrel{无损}\Longrightarrow 系数c \stackrel{有损}\Longrightarrow 系数 \hat c(很多0) \Longrightarrow \hat{\boldsymbol x} = \sum \hat c_i \boldsymbol v_i</script><p>首先对输入的信号$\boldsymbol x$，从标准基变换为傅里叶基，得到系数$c$，这一步是无损的过程。之后设置阀值进行压缩，超过阀值的认定为肉眼无法分辨的信号。在数学上表现为某些基向量的系数很小，这部分可以丢弃，随之得到新的系数$\hat c$。将新的系数赋值在傅里叶基上求和得到$\hat{\boldsymbol x} = \sum \hat c_i \boldsymbol v_i$。此时求和项已经不是64项，可能只剩下两三项，这就是压缩。</p>
<p>视频文件可以视为图像的序列，一幅一幅进行图像压缩即可。但这样做没有利用好视频的性质，因为视频是连续的，一幅图像和下一幅图像非常接近，因此可以存储一幅基础图像，随后只存储下一幅图像对它的修正部分。</p>
<ul>
<li><strong>小波 Wavelets</strong></li>
</ul>
<p>下面介绍另一组和傅里叶竞争的基向量——小波。</p>
<p>以$R^8$中的基举例：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
1 \\
1 \\
1 \\
1 \\
1 \\
1 \\
1 \\
1
\end{array}\right],\left[\begin{array}{c}
1 \\
1 \\
1 \\
1 \\
-1 \\
-1 \\
-1 \\
-1
\end{array}\right],\left[\begin{array}{c}
1 \\
1 \\
-1 \\
-1 \\
0 \\
0 \\
0 \\
0
\end{array}\right],\left[\begin{array}{c}
0 \\
0 \\
0 \\
0 \\
1 \\
1 \\
-1 \\
-1
\end{array}\right],\left[\begin{array}{c}
1 \\
-1 \\
0 \\
0 \\
0 \\
0 \\
0 \\
0
\end{array}\right], \cdots, \left[\begin{array}{c}
0 \\
0 \\
0 \\
0 \\
0 \\
0 \\
1 \\
-1
\end{array}\right]</script><p>这个只是一个小波选择，还有很多更精细的选择，这一组基中有太多从+1跳转到-1的变化。线性代数要做的基变换，就是将标准基下的向量$\boldsymbol p = [p_1, p_2, \cdots, p_8]$表示为小波基的线性组合，求出线性组合的参数$\boldsymbol c$满足$\boldsymbol p = c_1 \boldsymbol w_1 + c_2 \boldsymbol w_2+ \cdots + c_8 \boldsymbol w_8$，即$\boldsymbol{p = Wc}$。$\boldsymbol W$即以小波基向量为列向量的小波矩阵。因此有$\boldsymbol c = \boldsymbol W^{-1} \boldsymbol p$ 。</p>
<p>好的基向量组要求：第一，可以快速求逆矩阵，例如快速傅里叶变换，这里也存在快速小波变换，因为小波矩阵列向量正交，因此可以转置得到逆矩阵；第二，要少量基向量就可以近似信号，可压缩的比例就比较高。</p>
<h4 id="31-2-基变换-Change-of-basis"><a href="#31-2-基变换-Change-of-basis" class="headerlink" title="31.2 基变换 Change of basis"></a>31.2 基变换 Change of basis</h4><p>$\boldsymbol W$的列向量是一组新的基向量。在旧基向量体系下的向量$\boldsymbol x$和新基向量下的$\boldsymbol c$的关系是：$\boldsymbol {x = Wc}$。</p>
<ul>
<li><strong>变换矩阵</strong></li>
</ul>
<p>已知一个线性变换$T：R^8 \to R^8$。当使用空间的一组基时$\boldsymbol v_1，\boldsymbol v_2, \dots ,\boldsymbol v_8$，线性变换对应的矩阵为$\boldsymbol A$；当使用一组新的基$\boldsymbol u_1，\boldsymbol u_2, \dots ,\boldsymbol u_8$时，线性变换对应的矩阵为矩阵$\boldsymbol B$。两个矩阵对应的是同一个线性变换，只是使用了不同的基向量。那么$\boldsymbol A$和$\boldsymbol B$为<strong>相似矩阵</strong>——$\boldsymbol B = \boldsymbol{M^{-1} A M}$，$\boldsymbol M$是基变换矩阵（相似矩阵就是通过不同的基表示同一个向量）。</p>
<p>复习一下线性变换的内容：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\boldsymbol{x}=c_{1} \boldsymbol{v}_{1}+c_{2} \boldsymbol{v}_{2}+\ldots+c_{8} \boldsymbol{v}_{8} \\
&\boldsymbol{T}(\boldsymbol{x})=c_{1} \boldsymbol{T}\left(\boldsymbol{v}_{1}\right)+c_{2} \boldsymbol{T}\left(\boldsymbol{v}_{2}\right)+\ldots+c_{8} \boldsymbol{T}\left(\boldsymbol{v}_{8}\right) \\
&\boldsymbol{T}\left(\boldsymbol{v}_{1}\right)=a_{11} \boldsymbol{v}_{1}+a_{21} \boldsymbol{v}_{2}+\ldots+a_{81} \boldsymbol{v}_{8} \\
&\boldsymbol{T}\left(\boldsymbol{v}_{2}\right)=a_{12} \boldsymbol{v}_{1}+a_{22} \boldsymbol{v}_{2}+\ldots+a_{82} \boldsymbol{v}_{8} \\
& \cdots
\end{aligned}</script><p>矩阵$\boldsymbol A$就是$a_{ij}$组成的矩阵。</p>
<p>如果我们使用的基向量就是特征向量$T(\boldsymbol v_I = \lambda_i \boldsymbol v_i)$，矩阵$\boldsymbol A$就变成对角阵$\boldsymbol \Lambda$。找出特征向量是压缩最理想的结果，但是找出图像的特征向量代价太大，因此我们找到代价小但是接近理想状态的基向量（例如小波基）进行基变换，完成压缩过程。</p>
<blockquote>
<p>之前我在线性变换和基变换这两讲后面留了很多具体文字，希望帮助大家理解和区分这些概念，但是有的小伙伴貌似反而被误导，所以我把另一门课程的几何描述放在这里，希望大家看了之后可以完全明白，基变换是在同一个空间中，改变对一个东西的描述方式而已。</p>
</blockquote>
<h4 id="31-3-线性变换与基变换的区别与联系"><a href="#31-3-线性变换与基变换的区别与联系" class="headerlink" title="31.3 线性变换与基变换的区别与联系"></a>31.3 线性变换与基变换的区别与联系</h4><p>我们可以将基变换理解为特殊的线性变换，因为基变换其实是可逆线性变换，也就是说，始终是可逆矩阵。 </p>
<ul>
<li>线性变换：</li>
</ul>
<p>将一个向量变换为另一个向量，是在同一个坐标系(基向量)下的两个不同向量，其中矩阵的列可以看为标准基变换后的基，从这个变换中我们能看出这个矩阵对应什么变换。</p>
<ul>
<li>基变换：</li>
</ul>
<p>基变换在变换前后描述的都是一个向量，它表示一个向量在原来的基下的表示(系数)变换为另一组基下的表示(系数)。其中基变换矩阵的列表示原来的基在新的基下的坐标。</p>
<p>。但是变换前的向量是在原来的基下的表示，变换后的向量的表示在新的基下的表示</p>
<p>线性代数的本质09 基变换 - 三少爷的键的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/110975625">https://zhuanlan.zhihu.com/p/110975625</a> </p>
<h3 id="第三十二讲-第三部分小结"><a href="#第三十二讲-第三部分小结" class="headerlink" title="第三十二讲 第三部分小结"></a>第三十二讲 第三部分小结</h3><p><strong>主要内容</strong></p>
<ul>
<li>特征值和特征向量$\boldsymbol{Ax} = \lambda \boldsymbol x$</li>
<li>微分方程$\dfrac{\mathrm d \boldsymbol u}{\mathrm d t} = \boldsymbol{Au}$和矩阵指数形式$e^{\boldsymbol At}$</li>
<li>对称矩阵$\boldsymbol A = \boldsymbol A^{\mathrm T}$的特征值永远为实数，总有足够的特征向量实现矩阵的对角化$\boldsymbol{A = Q \Lambda Q}^{\mathrm T}$。</li>
<li>正定矩阵</li>
<li>相似矩阵$\boldsymbol B = \boldsymbol M^{-1} \boldsymbol{AM}$，两矩阵具有相同的特征值，但是特征向量不同，矩阵的乘方形式很接近$\boldsymbol B = \boldsymbol M^{-1} \boldsymbol A^k \boldsymbol M$。</li>
<li>奇异值分解SVD$\boldsymbol A = \boldsymbol{U Σ V}^{\mathrm T}$。</li>
</ul>
<p>几个知识点：</p>
<p>矩阵$\boldsymbol A$的特征向量相互正交的条件：</p>
<script type="math/tex; mode=display">
\boldsymbol A \boldsymbol A^{\mathrm T} = \boldsymbol A^{\mathrm T} \boldsymbol A</script><p>对称阵、反对称阵、正交阵都满足上面条件。</p>
<p>投影矩阵的特征值等于0或者1，因为$\boldsymbol P^2 = \boldsymbol P \Longrightarrow \lambda^2 = \lambda$。</p>
<p>例题参考：<a href="https://zhuanlan.zhihu.com/p/46124814">https://zhuanlan.zhihu.com/p/46124814</a></p>
<h3 id="第三十三讲-左右逆和伪逆"><a href="#第三十三讲-左右逆和伪逆" class="headerlink" title="第三十三讲 左右逆和伪逆"></a>第三十三讲 左右逆和伪逆</h3><p>【MIT—线性代数笔记33 左右逆和伪逆 - 三少爷的键的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/46124893">https://zhuanlan.zhihu.com/p/46124893</a> 】</p>
<hr>
<p>参考笔记：<a href="https://zhuanlan.zhihu.com/p/355960334">https://zhuanlan.zhihu.com/p/355960334</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>数学基础</category>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>本质问题</tag>
        <tag>线代</tag>
      </tags>
  </entry>
  <entry>
    <title>最优化方法_Part1</title>
    <url>/2022/05/15/Optimization-method1/</url>
    <content><![CDATA[<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1m7411u72b" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/1c52998c22ddf8d0088e8d58f0eb97f5553d5c16.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">01:20:50</span>
            </div>
            <div class="bvideo-info">
                <p class="title">最优化理论与方法-第一讲：最优化问题概述</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>22.7万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>960</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">superfatseven</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<h3 id="第一讲-最优化问题概述"><a href="#第一讲-最优化问题概述" class="headerlink" title="第一讲 最优化问题概述"></a>第一讲 最优化问题概述</h3><h4 id="1-1-什么是最优化问题"><a href="#1-1-什么是最优化问题" class="headerlink" title="1.1 什么是最优化问题"></a>1.1 什么是最优化问题</h4><p>最优化问题是<strong>决策问题</strong>，选择一些可以执行的策略来使得目标最优，一个最优化问题包括：</p>
<ul>
<li>决策变量</li>
<li>一个或多个目标函数</li>
<li>一个由可行策略纽成的集合，可由等式或者不等式刻画</li>
</ul>
<h4 id="1-2-基本形式"><a href="#1-2-基本形式" class="headerlink" title="1.2 基本形式"></a>1.2 基本形式</h4><h5 id="一-视频中的形式"><a href="#一-视频中的形式" class="headerlink" title="(一) 视频中的形式"></a>(一) 视频中的形式</h5><script type="math/tex; mode=display">
\begin{cases}\text { min or max } & f(\boldsymbol x) \\ 
\text{ s.t.} & g_{i}(\boldsymbol x) \leq 0, \text{  } i=1, \cdots, m \\ 
& h_{i}(\boldsymbol x) = 0, \text{  } i=1, \cdots, l\end{cases}</script><p>其中，<script type="math/tex">\boldsymbol x = (x_1, x_2, \cdots, x_n)^{\mathrm T} \in \boldsymbol X</script>是<strong>决策变量</strong>，$\boldsymbol X$表示给定的集合，比如<script type="math/tex">\mathbb{R}_+^n、 \mathbb{Z}n</script>等。</p>
<ul>
<li>$f(\boldsymbol x)$即目标函数，$g_i(\boldsymbol x) \leq 0, h_i(\boldsymbol x)=0$分别为不等式约束和等式约束</li>
<li>集合<script type="math/tex">\boldsymbol S = \begin{Bmatrix} \boldsymbol x \in X \mid g_{i}(\boldsymbol x) \leq 0, \text{  } i=1, \cdots, m,  h_{i}(\boldsymbol x) = 0, \text{  } i=1, \cdots, l \end{Bmatrix}</script>称为最优化问题的<strong>可行集(可行域)</strong></li>
</ul>
<h5 id="二-参考其他文献的形式"><a href="#二-参考其他文献的形式" class="headerlink" title="(二) 参考其他文献的形式"></a>(二) 参考其他文献的形式</h5><script type="math/tex; mode=display">
\begin{cases}\text { min } & f(\boldsymbol x) \\ 
\text{ s.t.} & \boldsymbol x \in \mathcal{X} \end{cases}</script><p>其中，$\boldsymbol x = (x_1, x_2, ··· , x_n)^{\mathrm T} ∈ \mathbb{R}^n ​$是<strong>决策变量</strong>，$f : \mathbb{R}^n → \mathbb{R}​$ 是<strong>目标函数</strong>，$\mathcal{X} ⊆ \mathbb{R}^n​$是<strong>约束集合或可行域</strong>，可行域包含的点称为<strong>可行解或可行点</strong>。记号 <code>s.t.</code>是 “subject to”的缩写，专指<strong>约束条件</strong>。当$\mathcal{X} = \mathbb{R}^n​$时，上式称为<strong>无约束优化问题</strong>。集合$\mathcal{X}​$通常可以由约束函数$c_i( \boldsymbol x): \mathbb{R}^n → \mathbb{R} ,i = 1, 2,··· ,m + l ​$表达为如下具体形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathcal{X}=\left\{x \in \mathbb{R}^{n} \mid c_{i}(x) \leqslant 0,\right.& i=1,2, \cdots, m \\
c_{i}(x)=0, &i=m+1, m+2 \cdots, m+l\}
\end{aligned}</script><blockquote>
<p> 参考资料1：<a href="https://bicmr.pku.edu.cn/~wenzw/optbook/opt1.pdf">课本——最优化：建模、算法与理论</a></p>
<p> 参考资料2：<a href="https://blog.csdn.net/jbb0523/article/details/50596387">最优化问题简介 - jbb0523 - CSDN</a></p>
</blockquote>
<h4 id="1-3-最优化问题分类"><a href="#1-3-最优化问题分类" class="headerlink" title="1.3 最优化问题分类"></a>1.3 最优化问题分类</h4><h5 id="一-无约束优化-约束优化"><a href="#一-无约束优化-约束优化" class="headerlink" title="(一) 无约束优化/约束优化"></a>(一) 无约束优化/约束优化</h5><ul>
<li>无约束优化问题：没有约束条件<ul>
<li>常见求解方法：梯度下降法(最速下降法)、牛顿法、共轭梯度法等等</li>
</ul>
</li>
<li>约束优化问题：在一定约束条件下求解目标函数的<code>min OR max</code></li>
</ul>
<blockquote>
<p>易知，实际中最碰见的是约束优化问题，但是我们在课程中却要大量研究无约束优化问题，这个有两方面的原因：一是无约束优化问题求解相对简单；二是可以通过一定的变换将有约束转变为无约束优化。</p>
</blockquote>
<h5 id="二-线性-非线性优化"><a href="#二-线性-非线性优化" class="headerlink" title="(二) 线性/非线性优化"></a>(二) 线性/非线性优化</h5><ul>
<li>线性优化问题的一般形式</li>
</ul>
<script type="math/tex; mode=display">
\begin{cases}\text { min } & \boldsymbol{Cx} \\ 
\text{ s.t.} &  \boldsymbol{Ax = b}\end{cases}</script><p><strong>单纯形方法：</strong>在数学优化领域中常用于<strong>线性规划问题</strong>的数值求解。由线性规划问题的可行集的特征来决定的(线性规划最优解存在时，那么最优解一定存在与问题可行集的<strong>顶点位置</strong>)，单纯性方法就是关注这些顶点。</p>
<blockquote>
<p>参考资料：<a href="https://oi-wiki.org/math/simplex/">单纯形算法</a></p>
</blockquote>
<ul>
<li>非线性优化(例子说明)：<strong>均值-方差模型</strong></li>
</ul>
<h5 id="三-连续优化-离散优化"><a href="#三-连续优化-离散优化" class="headerlink" title="(三) 连续优化/离散优化"></a>(三) 连续优化/离散优化</h5><ul>
<li>连续优化：$\boldsymbol x = (x_1, x_2, \cdots, x_n)^{\mathrm T} \in \boldsymbol X$中每一个$x_n$的取值是连续的</li>
<li>离散优化：$\boldsymbol x = (x_1, x_2, \cdots, x_n)^{\mathrm T} \in \boldsymbol X$中每一个$x_n$的取值是离散的，比如$0-1$规划</li>
</ul>
<h5 id="四-单目标优化-多目标优化"><a href="#四-单目标优化-多目标优化" class="headerlink" title="(四) 单目标优化/多目标优化"></a>(四) 单目标优化/多目标优化</h5><ul>
<li>单目标优化</li>
<li>多目标优化(均值-方差模型)常采用的办法：<ul>
<li>法1：转化为单目标，即可以将某些目标经过一定形式转化到约束条件中去。</li>
<li>法2：想办法将多个目标融合为单个目标</li>
</ul>
</li>
</ul>
<h5 id="五-动态规划"><a href="#五-动态规划" class="headerlink" title="(五) 动态规划"></a>(五) 动态规划</h5><h5 id="六-随机规划"><a href="#六-随机规划" class="headerlink" title="(六) 随机规划"></a>(六) 随机规划</h5><p>参数中有不确定系数的优化问题。</p>
<h5 id="七-鲁棒优化"><a href="#七-鲁棒优化" class="headerlink" title="(七) 鲁棒优化"></a>(七) 鲁棒优化</h5><h4 id="1-4-最优化方法主要讲解内容"><a href="#1-4-最优化方法主要讲解内容" class="headerlink" title="1.4 最优化方法主要讲解内容"></a>1.4 最优化方法主要讲解内容</h4><ul>
<li>凸优化理论：凸集，凸函数，凸优化问题；</li>
<li>无约束优化问题的算法；</li>
<li>约束优化的最优性条件及对偶理论；</li>
<li>线性规划、二次规划算法；</li>
<li>约束优化的罚函数方法；</li>
<li>优化软件：CVX，CPLEX</li>
</ul>
<h4 id="1-5-预备知识"><a href="#1-5-预备知识" class="headerlink" title="1.5 预备知识"></a>1.5 预备知识</h4><ul>
<li>向量、矩阵、二次型等知识；</li>
<li>微积分知识；</li>
<li>简单的概率知识。</li>
</ul>
<p>课后小问题：</p>
<ul>
<li>$n$元二次函数$f(\boldsymbol x)=\boldsymbol x^{\mathrm T} \boldsymbol H \boldsymbol x ＋\boldsymbol c^{\mathrm T} \boldsymbol x$,其中$\boldsymbol H$为$n$阶对称矩阵，$\boldsymbol c$为$n$维向量；给出$f(\boldsymbol x)$的梯度和hesse炬阵?</li>
<li>设随机向量服从联合正态分布：$\epsilon = (\epsilon_1, \epsilon_2, \cdots, \epsilon_n) \sim N(\mu, \sigma^2)$，令$η = x_1\epsilon_1 + \cdots + x_n\epsilon_n$，给出$η$的$c$分位数。</li>
</ul>
<h3 id="第二讲-凸集"><a href="#第二讲-凸集" class="headerlink" title="第二讲 凸集"></a>第二讲 凸集</h3><p>在最优化范畴里面，凸优化问题是一类常见的且性质很好的(很多时候可以帮助我们解决非凸优化问题)。</p>
<p>如果目标函数<script type="math/tex">f(\boldsymbol x)</script>是一个凸函数，可行集<script type="math/tex">\boldsymbol S</script>或者<script type="math/tex">\mathcal{X}</script>是凸集，通常来讲就是凸优化问题。</p>
<ul>
<li>为什么凸优化问题具有比较好的性质呢？<ul>
<li>例子1：一元最小化问题：<script type="math/tex">\text{min } f(x), \text{  s.t.  } x\in[a, b]</script></li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">凸函数</th>
<th style="text-align:center">非凸函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://pic.imgdb.cn/item/6281062209475431293471f6.jpg"></td>
<td style="text-align:center"><img src="https://pic.imgdb.cn/item/6281064f0947543129351608.jpg"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><ul>
<li>例子2：二元最小化问题：<script type="math/tex">\text{min } f(x_1, x_2) = x_1^2 + x_2^2, \text{  s.t.  } x\in S</script></li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">凸集</th>
<th>非凸集</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://pic.imgdb.cn/item/6281115109475431295d3252.jpg" style="zoom:40%"></td>
<td><img src="https://pic.imgdb.cn/item/6281153d09475431296e05df.jpg"></td>
</tr>
<tr>
<td style="text-align:center">梯度：<script type="math/tex">- \bigtriangledown f(\boldsymbol x^*)</script></td>
<td>梯度：<script type="math/tex">- \bigtriangledown f(\boldsymbol x^*)</script></td>
</tr>
<tr>
<td style="text-align:center">优化问题等价为：<script type="math/tex">\theta > 90° \Leftrightarrow - \bigtriangledown f(\boldsymbol x^*) (\boldsymbol{x-x^*}) \leq 0, \forall \boldsymbol x \in S</script></td>
<td>优化问题等价为：<script type="math/tex">\theta > 90° \Leftrightarrow - \bigtriangledown f(\boldsymbol x^*) (\boldsymbol{x-x^*}) \leq 0, \forall \boldsymbol x \in S</script></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>凸集：</strong>集合中的任意两点连线的点都在该集合中，则称该集合为凸集；凹集为非凸集。 </p>
</blockquote>
<h4 id="2-1-凸集的定义"><a href="#2-1-凸集的定义" class="headerlink" title="2.1 凸集的定义"></a>2.1 凸集的定义</h4><h5 id="一-凸集定义的数学表示"><a href="#一-凸集定义的数学表示" class="headerlink" title="(一) 凸集定义的数学表示"></a>(一) 凸集定义的数学表示</h5><p>凸集：对于任意的$x, y \in \boldsymbol C$与任意$\lambda \in [0,1]$，有</p>
<script type="math/tex; mode=display">
\lambda x + (1-\lambda)y \in \boldsymbol C</script><p>那么$\boldsymbol C$为凸集。凸集中任意两点连线的点都在该集合中。</p>
<p><img src="https://pic.imgdb.cn/item/62819d5909475431296cc326.jpg" style="zoom:60%"></p>
<ul>
<li><strong>推广表示方法：</strong></li>
</ul>
<script type="math/tex; mode=display">
\lambda_1 x_1 + \cdots + \lambda_k x_k \in  \boldsymbol C, \text{  }\forall x_1, \cdots, x_k \in \boldsymbol C</script><p>其中，$\lambda_i \geq 0, \lambda_1 + \cdots + \lambda_k = 1$。</p>
<h5 id="二-凸组合："><a href="#二-凸组合：" class="headerlink" title="(二) 凸组合："></a>(二) 凸组合：</h5><p>凸组合是指，假设$x_1, x_2, \cdots , x_n$是一组对象（要根据讨论问题的背景来确定），$\lambda_1, \lambda_2, \cdots, \lambda_k$是$k$个常数，并且满足$\lambda_i \geq 0, \lambda_1 + \cdots + \lambda_k = 1$，那么这些点的凸组合即一个这样的点：</p>
<script type="math/tex; mode=display">
\lambda_1 x_1 + \cdots + \lambda_k x_k \</script><p>就称为$x_1, x_2, \cdots , x_n$的凸组合。注意区分<a href="https://zhuanlan.zhihu.com/p/348388306">线性组合,仿射组合,非负组合,凸组合</a>。</p>
<blockquote>
<p>通常你看到凸组合只意味着一个意思：<strong>线性组合，系数和为一</strong> </p>
<p>任意两个点的凸组合都在它们之间的线段上。</p>
</blockquote>
<h5 id="三-凸包："><a href="#三-凸包：" class="headerlink" title="(三) 凸包："></a>(三) 凸包：</h5><p>凸包是针对一个集合来说的。任意一个集合(不一定是凸集)$\boldsymbol C$，其中的点的凸组合构成的集合就称为凸包。</p>
<blockquote>
<p>点集的<a href="https://zh.m.wikipedia.org/wiki/%E5%87%B8%E5%8C%85">凸包</a>等价于该点集的所有凸组合。 </p>
<p>凸包一定是凸集合，通过凸包操作能够将非凸集合转变为凸集合。</p>
</blockquote>
<h4 id="2-2-常见凸集"><a href="#2-2-常见凸集" class="headerlink" title="2.2 常见凸集"></a>2.2 常见凸集</h4><h5 id="一-超平面"><a href="#一-超平面" class="headerlink" title="(一) 超平面"></a>(一) 超平面</h5><ul>
<li><p><strong>定义：</strong>$n$维线性空间中维度为$n−1$的子空间，它可以把线性空间分割为不相交的两部分。 </p>
<blockquote>
<p>这里的$n$必须大于$3$，其子空间才能称之为超平面。</p>
<p>更直观理解超平面：其实就是平面中的直线、空间中的平面的推广。在三维坐标系，XoY平面把三维坐标系”分割”成两个空间，这个分割平面引申到一维，二维，四维空间…来，他就是一个超平面。</p>
</blockquote>
</li>
<li><p><strong>超平面方程推导：</strong> </p>
</li>
</ul>
<script type="math/tex; mode=display">
\boldsymbol H = \begin{Bmatrix} \boldsymbol x |\boldsymbol a^{\mathrm T} \boldsymbol x = \boldsymbol b ,(\boldsymbol a \neq \boldsymbol 0) \end{Bmatrix}</script><p>式中，$\boldsymbol a^{\mathrm T}$垂直于超平面$\boldsymbol x$。</p>
<blockquote>
<p>参考资料1：<a href="https://blog.csdn.net/qiyedetianfu/article/details/113113703?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-113113703-blog-53074100.pc_relevant_default&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4">机器学习01-超平面理解</a></p>
<p>参考资料2：<a href="https://blog.csdn.net/dengheCSDN/article/details/77313758?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-77313758-blog-113113703.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-77313758-blog-113113703.pc_relevant_antiscanv2&amp;utm_relevant_index=6">超平面是什么？——理解超平面（SVM开篇之超平面详解）</a></p>
</blockquote>
<h5 id="二-半空间："><a href="#二-半空间：" class="headerlink" title="(二) 半空间："></a>(二) 半空间：</h5><script type="math/tex; mode=display">
\boldsymbol H^+ = \begin{Bmatrix} \boldsymbol x |\boldsymbol a^{\mathrm T} \boldsymbol x \geq \boldsymbol b ,(\boldsymbol a \neq \boldsymbol 0) \end{Bmatrix}</script><script type="math/tex; mode=display">
\boldsymbol H^- = \begin{Bmatrix} \boldsymbol x |\boldsymbol a^{\mathrm T} \boldsymbol x \leq \boldsymbol b ,(\boldsymbol a \neq \boldsymbol 0) \end{Bmatrix}</script><p><img src="https://pic.imgdb.cn/item/6281b42509475431299ca586.jpg"></p>
<h5 id="三-多面体："><a href="#三-多面体：" class="headerlink" title="(三) 多面体："></a>(三) 多面体：</h5><ul>
<li><strong>定义：</strong>多个线性不等式所刻画的集合</li>
</ul>
<script type="math/tex; mode=display">
\begin{Bmatrix} \boldsymbol x \mid \boldsymbol a_i^{\mathrm T} \boldsymbol x \leq \boldsymbol b_i , i = 1, \cdots, m \end{Bmatrix}</script><blockquote>
<p>注意：线性等式刻画的集合也是多面体，因为等式约束可以转换为不等式约束，如</p>
<script type="math/tex; mode=display">
a_{i}^{T} x=b_{i} \Leftrightarrow\left\{\begin{array}{l}
a_{i}^{T} x \leq b_{i} \\
-a_{i}^{T} x \leq-b_{i}
\end{array}\right.</script></blockquote>
<h5 id="四-球体：（Euclidean）ball-with-center-boldsymbol-x-c-and-radius-r"><a href="#四-球体：（Euclidean）ball-with-center-boldsymbol-x-c-and-radius-r" class="headerlink" title="(四) 球体：（Euclidean）ball with center $\boldsymbol x_c$and radius r"></a>(四) 球体：（Euclidean）ball with center $\boldsymbol x_c$and radius r</h5><script type="math/tex; mode=display">
B\left(\boldsymbol x_{c}, r\right)=\left\{ \boldsymbol x \mid \left\| \boldsymbol x - \boldsymbol x_{c}\right\|_{2} \leq r\right\}=\left\{\boldsymbol x_{c}+r\boldsymbol u  \mid \| \boldsymbol u \|_{2} \leq 1\right\}</script><p>式中，$\boldsymbol x_c$为球心，$r$为半径，$\boldsymbol u$表示某一距离长度范围。</p>
<h5 id="五-椭球（Ellipsoid）"><a href="#五-椭球（Ellipsoid）" class="headerlink" title="(五) 椭球（Ellipsoid）"></a>(五) 椭球（Ellipsoid）</h5><script type="math/tex; mode=display">
\left\{\boldsymbol x \mid\left(\boldsymbol x - \boldsymbol x_{c}\right)^{T} \boldsymbol P^{-1}\left(\boldsymbol x- \boldsymbol x_{c}\right) \leq 1\right\}</script><p>其中$\boldsymbol P$为<strong>正定矩阵</strong>；椭球的半轴长为$\sqrt \lambda_i$($\lambda_i$为正定矩阵的特征值)。</p>
<h5 id="六-二阶-次-锥-：Second-order-cone-ice-cream-cone"><a href="#六-二阶-次-锥-：Second-order-cone-ice-cream-cone" class="headerlink" title="(六) 二阶(次)锥 ：Second-order cone, ice-cream cone"></a>(六) 二阶(次)锥 ：Second-order cone, ice-cream cone</h5><p>假设有一个$n+1$维的锥，其前面$n$维写为$\boldsymbol x$，最后第$n+1$维分量记为$t$。</p>
<script type="math/tex; mode=display">
\left\{(\boldsymbol x, t) \mid ||\boldsymbol x||_2 \leq t\right\}</script><p><img src="https://pic.imgdb.cn/item/6281c0db0947543129bd2b92.jpg" style="zoom:50%"></p>
<blockquote>
<p>什么是锥：</p>
<p>如果<script type="math/tex">\boldsymbol x \in \boldsymbol C</script>，那么若有<script type="math/tex">\lambda \boldsymbol x \in \boldsymbol C, \forall \lambda \geq 0</script>，此时就称为锥。</p>
</blockquote>
<h5 id="七-半定矩阵锥"><a href="#七-半定矩阵锥" class="headerlink" title="(七) 半定矩阵锥"></a>(七) 半定矩阵锥</h5><ol>
<li><script type="math/tex">\boldsymbol S^n</script>：所有$n$阶<strong>对称矩阵</strong>组成的集合；</li>
<li><script type="math/tex; mode=display">\boldsymbol  S _ +^n = \begin{Bmatrix} \boldsymbol X \in \boldsymbol S^n \mid \boldsymbol X \geq  0\end{Bmatrix} $$：所有**半正定矩阵**组成的集合，其中：$$\boldsymbol X \geq  0 \Leftrightarrow \boldsymbol z^T \boldsymbol X \boldsymbol z \geq 0, \forall \boldsymbol z</script></li>
<li><script type="math/tex; mode=display">\boldsymbol S _ {++}^n = \begin{Bmatrix} \boldsymbol X \in \boldsymbol S^n \mid \boldsymbol X >  0\end{Bmatrix}$$：所有**正定矩阵**的集合，其中：$$\boldsymbol X >  0 \Leftrightarrow \boldsymbol z^T \boldsymbol X \boldsymbol z > 0, \forall \boldsymbol z</script></li>
</ol>
<p>半定矩阵锥常用于半定规划里面(一种常见的凸优化问题)。</p>
<ul>
<li>例子：<script type="math/tex">\left[\begin{array}{cc} x & y \\ y & x\end{array}\right] \in \boldsymbol S_+^2</script>，如下图所示。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/628200f009475431297bfaed.jpg" style="zoom:50%"></p>
<blockquote>
<p>小问题：</p>
<p>线性规划</p>
<script type="math/tex; mode=display">
\min \begin{Bmatrix} \boldsymbol{c^Tx} \mid \boldsymbol A \boldsymbol x = \boldsymbol b , \boldsymbol x \geq 0 \end{Bmatrix}</script><p>的最优解组成的集合为<script type="math/tex">\boldsymbol S</script>，<script type="math/tex">\boldsymbol S</script>是凸集合吗？【答案——<script type="math/tex">\boldsymbol S</script>是凸集合】 </p>
<p>证明：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\forall \boldsymbol x_{1}, \boldsymbol x_{2} \in\boldsymbol  S,有\boldsymbol c^{T} \boldsymbol x_{1}=\boldsymbol c^{T} \boldsymbol x_{2}=\boldsymbol v^* \\
\\
&\forall \lambda \in[0,1], 验证\lambda \boldsymbol x_{1}+(1-\lambda) \boldsymbol x_{2} 是否属于\boldsymbol  S\\
\\
&c^{T}\left(\lambda \boldsymbol x_{1}+(1-\lambda) \boldsymbol x_{2} \right) \\
&=\lambda c^{T}\boldsymbol x_{1}+(1-\lambda) c^{T} \boldsymbol x_{2} \\
&=\boldsymbol v^* \in \boldsymbol  S
\end{aligned}</script></blockquote>
<h4 id="2-3-保持集合凸性的运算"><a href="#2-3-保持集合凸性的运算" class="headerlink" title="2.3 保持集合凸性的运算"></a>2.3 保持集合凸性的运算</h4><h5 id="一-第一种"><a href="#一-第一种" class="headerlink" title="(一) 第一种"></a>(一) 第一种</h5><p>设$\boldsymbol C_1, \boldsymbol C_2 ⊂  \mathbb{R}^n$是凸集，$a \in \mathbb{R}$则</p>
<ul>
<li>（1）<script type="math/tex">\boldsymbol C_{1} \cap \boldsymbol C_{2}=\left\{\boldsymbol x \mid \boldsymbol x \in \boldsymbol C_{1}, \boldsymbol x \in \boldsymbol C_{2}\right\}</script>是凸集</li>
<li>（2）<script type="math/tex">\boldsymbol C_{1} \pm \boldsymbol C_{2}=\left\{\boldsymbol{x \pm y} \mid \boldsymbol x \in \boldsymbol C_{1}, \boldsymbol y \in \boldsymbol C_{2}\right\}</script>是凸集</li>
</ul>
<blockquote>
<p>问题：<script type="math/tex">\boldsymbol S=\left\{\boldsymbol x \in \mathbb{R}^n \mid |p(t)|\leq 1,| t \mid \leq \pi / 3\right\}</script>，其中<script type="math/tex">p(t) = \sum_{i=1}^{n}x_i \cos it</script>是否为凸集？</p>
<p>答：带入<script type="math/tex">p(t)</script>得到：<script type="math/tex">-1 \leq x_{1} \cos t+x_{2} \cos 2 t+\cdots+x_{n} \cos n t \leq 1</script></p>
<p>上不等式表示两个半空间交集。如果$t$只有两种取值，那么就是两个上不等式刻画的集合的交；事实上$t$无穷多取值，那么就是无穷多个上不等式刻画的集合的交，即结果仍然是凸集。</p>
<p><img src="https://pic.imgdb.cn/item/6282072a09475431298dfd61.jpg" style="zoom:50%"></p>
</blockquote>
<h5 id="二-仿射变换"><a href="#二-仿射变换" class="headerlink" title="(二) 仿射变换"></a>(二) 仿射变换</h5><p>线性变换是特殊的仿射变换。或者说<strong><font color="red">仿射变换就是线性变换加平移</font></strong>。 </p>
<p>假设$f: \mathbb R^n \to \mathbb R^m$是仿射函数，即$f(\boldsymbol x) = \boldsymbol{Ax +b}, \boldsymbol A \in \mathbb R^{m \times n}, \boldsymbol b \in \mathbb R^m $</p>
<ul>
<li><script type="math/tex">\boldsymbol C</script>为<strong>凸集</strong><script type="math/tex">\Rightarrow f(\boldsymbol C) = \left\{f(\boldsymbol x) \mid \boldsymbol x \in \boldsymbol C \right\}</script>是<strong>凸集</strong></li>
<li><script type="math/tex">\boldsymbol C</script>为<strong>凸集</strong><script type="math/tex">\Rightarrow f^{-1}(\boldsymbol C) = \left\{\boldsymbol x \mid f(\boldsymbol x) \in \boldsymbol C \right\}</script>是<strong>凸集</strong></li>
</ul>
<blockquote>
<p><strong>特殊仿射变换：</strong></p>
<ul>
<li>放缩scaling：<script type="math/tex">\alpha \boldsymbol C = \left\{\alpha \boldsymbol x \mid \boldsymbol x \in \boldsymbol C \right\}</script></li>
<li>平移translation：<script type="math/tex">\boldsymbol x_0 + \boldsymbol C = \left\{\boldsymbol x_0 + \boldsymbol x \mid \boldsymbol x \in \boldsymbol C \right\}</script></li>
<li>投影projection：<script type="math/tex">\left\{x^{1} \mid\left(\begin{array}{l} x^{1} \\ x^{2} \end{array}\right) \in \boldsymbol C\right\}</script></li>
</ul>
</blockquote>
<h4 id="2-4-凸集的基本性质——投影定理"><a href="#2-4-凸集的基本性质——投影定理" class="headerlink" title="2.4 凸集的基本性质——投影定理"></a>2.4 凸集的基本性质——投影定理</h4><h5 id="一-投影定理概念"><a href="#一-投影定理概念" class="headerlink" title="(一) 投影定理概念"></a>(一) 投影定理概念</h5><p>设$\boldsymbol C ⊂  \mathbb{R}^n$是一个非空闭凸集，$\boldsymbol y \in  \mathbb{R}^n, \boldsymbol y \notin \boldsymbol C$，则：</p>
<p>（1）存在唯一的一点$\overline{\boldsymbol x} \in \boldsymbol C$，使得$\overline{\boldsymbol x}$是$\boldsymbol y$到$\boldsymbol C$的距离最小的点(即<strong>投影点</strong>)，即有</p>
<script type="math/tex; mode=display">
|| \overline{\boldsymbol x} - \boldsymbol y || = \inf \begin{Bmatrix} ||\boldsymbol x - \boldsymbol y|| \mid \boldsymbol x \in \boldsymbol C \end{Bmatrix} > 0</script><p>（2）$\overline{\boldsymbol x}$是$\boldsymbol y$到$\boldsymbol C$的投影点(最小距离点)的充要条件是：</p>
<script type="math/tex; mode=display">
(\boldsymbol x - \overline{\boldsymbol x})^{\mathrm T} (\boldsymbol y - \overline{\boldsymbol x}) \leq 0 , \forall \boldsymbol x \in \boldsymbol C</script><h5 id="二-投影定理的证明"><a href="#二-投影定理的证明" class="headerlink" title="(二) 投影定理的证明"></a>(二) 投影定理的证明</h5><p>不妨设，$\overline{\boldsymbol x}、\boldsymbol x’$都是投影点，则：$|| \overline{\boldsymbol x} - \boldsymbol y || = || \boldsymbol x’ - \boldsymbol y ||$</p>
<p>存在$\hat{\boldsymbol x}$在$\overline{\boldsymbol x}、\boldsymbol x’$两点之间，并作为连接三角形的中垂线，而小于其他两条边，从而小于投影点距离，矛盾！</p>
<p>因此投影点是唯一的。</p>
<p><img src="https://pic.imgdb.cn/item/628211980947543129abeb1c.jpg" style="zoom:50%"></p>
<h5 id="三-点与凸集的分离"><a href="#三-点与凸集的分离" class="headerlink" title="(三) 点与凸集的分离"></a>(三) 点与凸集的分离</h5><ul>
<li><strong>分离</strong></li>
</ul>
<p>设$\boldsymbol C_1, \boldsymbol C_2 ⊂  \mathbb{R}^n$是两个非空凸集，若非零$\boldsymbol a \in \mathbb{R}^n$和$\boldsymbol b$使得：</p>
<script type="math/tex; mode=display">
\boldsymbol{a^{\mathrm T}x} \geq \boldsymbol b, \forall \boldsymbol x \in \boldsymbol C_1, \boldsymbol{a^{\mathrm T}z} \leq \boldsymbol b, \forall \boldsymbol z \in \boldsymbol C_2 \\
\Updownarrow \\
\boldsymbol{a^{\mathrm T}x} \geq \boldsymbol{a^{\mathrm T}z}, \forall \boldsymbol x \in \boldsymbol C_1,\forall \boldsymbol z \in \boldsymbol C_2</script><p>则称超平面$\boldsymbol H = \begin{Bmatrix} \boldsymbol x \mid \boldsymbol{a^{\mathrm T}} \boldsymbol x = \boldsymbol b \end{Bmatrix}$<strong>分离</strong>集合$\boldsymbol C_1, \boldsymbol C_2$。</p>
<ul>
<li><strong>严格分离</strong></li>
</ul>
<p>设$\boldsymbol C_1, \boldsymbol C_2 ⊂  \mathbb{R}^n$是两个非空凸集，若非零$\boldsymbol a \in \mathbb{R}^n$和$\boldsymbol b$使得：</p>
<script type="math/tex; mode=display">
\boldsymbol{a^{\mathrm T}x} > \boldsymbol b, \forall \boldsymbol x \in \boldsymbol C_1, \boldsymbol{a^{\mathrm T}z} < \boldsymbol b, \forall \boldsymbol z \in \boldsymbol C_2 \\
\Updownarrow \\
\boldsymbol{a^{\mathrm T}x} > \boldsymbol{a^{\mathrm T}z}, \forall \boldsymbol x \in \boldsymbol C_1,\forall \boldsymbol z \in \boldsymbol C_2</script><p>则称超平面$\boldsymbol H = \begin{Bmatrix} \boldsymbol x \mid \boldsymbol{a^{\mathrm T}} \boldsymbol x = \boldsymbol b \end{Bmatrix}$<strong>严格分离</strong>集合$\boldsymbol C_1, \boldsymbol C_2$。</p>
<blockquote>
<p>小问题1：两个不相交的非空凸集一定能分离吗？</p>
<p>答：一定能分离。</p>
<p>小问题2：设$\boldsymbol C ⊂  \mathbb{R}^n$是两个非空闭凸集，$\boldsymbol y \notin \boldsymbol C$，是否存在超平面分离$\boldsymbol y$ 和$\boldsymbol C$？</p>
<p>答：存在</p>
</blockquote>
<h4 id="2-5-支撑超平面定理"><a href="#2-5-支撑超平面定理" class="headerlink" title="2.5 支撑超平面定理"></a>2.5 支撑超平面定理</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\partial \boldsymbol C$</td>
<td style="text-align:left">集合<script type="math/tex">\boldsymbol C</script>的边界</td>
</tr>
<tr>
<td style="text-align:center">$\text{int } \boldsymbol C$</td>
<td style="text-align:left">集合<script type="math/tex">\boldsymbol C</script>所有内点表示的集合</td>
</tr>
<tr>
<td style="text-align:center">$\boldsymbol {c</td>
<td style="text-align:left">C}$</td>
<td>闭包，集合<script type="math/tex">\boldsymbol C</script>内点、边界点放在一起组成的集合(有界闭集合)</td>
</tr>
</tbody>
</table>
</div>
<p>设$\boldsymbol C ⊂  \mathbb{R}^n$是非空凸集，$\overline{\boldsymbol x} \in \partial \boldsymbol C $(意思是$\overline{\boldsymbol x}$是$\boldsymbol C$的边界点)，则存在非零向量$\boldsymbol a \in \mathbb{R}^n$使得：</p>
<script type="math/tex; mode=display">
\boldsymbol{a^{\mathrm T}x} \leq \boldsymbol{a^{\mathrm T}} \overline{\boldsymbol x}, \forall \boldsymbol x \in \boldsymbol {c|C}</script><p>其中，$\boldsymbol {c|C}$是凸集$\boldsymbol C$的全域，称为<strong>闭包</strong>，包括内部和边界。当$\boldsymbol C$不是紧的的时候，$\boldsymbol {c|C}$也是指$\boldsymbol {C}$的全域，即包括$\boldsymbol {C}$不包括的边界。</p>
<p>此时，也称超平面$\boldsymbol H = \begin{Bmatrix} \boldsymbol x \in \mathbb{R}^n \mid \boldsymbol{a^{\mathrm T}} \boldsymbol x =\boldsymbol{a^{\mathrm T}} \overline{\boldsymbol x} \end{Bmatrix}$是集合$\boldsymbol C$在$\overline{\boldsymbol x}$处的<strong>支撑超平面</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/628218a80947543129bfd828.jpg" style="zoom:50%"></p>
<blockquote>
<p>通俗来说，该定理描述为：在凸集$\boldsymbol C$的边界一点$\overline{\boldsymbol x}$寻找一个超平面$\boldsymbol H$，将凸集$\boldsymbol C$放在超平面<strong>负半空间</strong>中。</p>
</blockquote>
<ul>
<li><strong>证明：</strong></li>
</ul>
<p>由于$\overline{\boldsymbol x} \in \partial \boldsymbol C $，则$\boldsymbol x_k \to \overline{\boldsymbol x}$(点列，<strong>收敛</strong>到$\overline{\boldsymbol x}$)，且$\boldsymbol x_k \notin \boldsymbol {c|C}$</p>
<p>因为$\boldsymbol x_k \notin \boldsymbol {c|C}​$，则存在$\boldsymbol a_k(\neq \boldsymbol 0)​$（边界点法向量），使得：</p>
<script type="math/tex; mode=display">
\boldsymbol{a_k^{\mathrm T}x} \leq \boldsymbol{a_k^{\mathrm T}} \boldsymbol x_k, \forall \boldsymbol x \in \boldsymbol {c|C}</script><p>不妨设，$||\boldsymbol a_k|| = 1$，则$\begin{Bmatrix} \boldsymbol a_k \end{Bmatrix}$存在收敛子列。</p>
<p>令上式中$k \to \infty$得：</p>
<script type="math/tex; mode=display">
\boldsymbol{a^{\mathrm T}x} \leq \boldsymbol{a^{\mathrm T}} \overline{\boldsymbol x}, \forall \boldsymbol x \in \boldsymbol {c|C}</script><blockquote>
<p>参考链接：<a href="https://blog.csdn.net/qq_42518956/article/details/113943943">最优化理论与方法-第二讲-凸集 - skycrygg - CSDN</a></p>
</blockquote>
<h4 id="2-6-凸集之Farkas引理"><a href="#2-6-凸集之Farkas引理" class="headerlink" title="2.6 凸集之Farkas引理"></a>2.6 凸集之Farkas引理</h4><p><strong>Farkas引理好像可以用于<font color="red">升维度</font>。</strong></p>
<h5 id="一-Farkas引理定义"><a href="#一-Farkas引理定义" class="headerlink" title="(一) Farkas引理定义"></a>(一) Farkas引理定义</h5><p>给定矩阵$\boldsymbol A_{m \times n}$以及$n$维向量$\boldsymbol c$，则以下两个问题<strong>有且只有一个有解</strong>：</p>
<ul>
<li>问题1——<script type="math/tex">\boldsymbol{Ax \leq 0}, \boldsymbol{c^Tx > 0}</script></li>
<li>问题2——<script type="math/tex">\boldsymbol{A^Ty = c}, \boldsymbol{y \geq 0}</script></li>
</ul>
<p>Farkas引理在几何上讨论矩阵$\boldsymbol A​$的行向量与向量$\boldsymbol c​$的<strong>位置关系</strong>。</p>
<p>矩阵</p>
<script type="math/tex; mode=display">
\boldsymbol{A}=\left[\begin{array}{cccc}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{m1} & a_{m2} & \cdots & a_{mn}
\end{array}\right] 
=\left[\begin{array}{c} \boldsymbol a_{1}^{\mathrm T} \\ \boldsymbol a_{2}^{\mathrm T} \\ \vdots \\ \boldsymbol a_{m}^{\mathrm T} \end{array}\right]</script><p>其中，$\boldsymbol a_i$为$n$维列向量，将其带入问题1、2可得：</p>
<ul>
<li>问题1——<script type="math/tex">\boldsymbol{a_i^Tx \leq 0}(i = 1,2, \cdots, m), \boldsymbol{c^Tx >0}</script></li>
<li>问题2——<script type="math/tex">\boldsymbol{A^Ty} = (\boldsymbol a_1, \boldsymbol a_2, \cdots, \boldsymbol a_m) \left[\begin{array}{c} y_1 \\ y_2 \\ \vdots \\ y_{m} \end{array}\right] = \boldsymbol c,  y_i \geq 0(i = 1,2, \cdots, m)</script></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">情况1</th>
<th style="text-align:center">情况2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://pic.imgdb.cn/item/6282f96d094754312968a721.jpg"></td>
<td style="text-align:center"><img src="https://pic.imgdb.cn/item/6282f9a70947543129696635.jpg"></td>
</tr>
</tbody>
</table>
</div>
<h5 id="二-Farkas引理证明"><a href="#二-Farkas引理证明" class="headerlink" title="(二) Farkas引理证明"></a>(二) Farkas引理证明</h5><ul>
<li><strong>证明方法1：</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6282fcf9094754312973a43c.jpg" style="zoom:50%"></p>
<ul>
<li><strong>证明方法2：利用线性规划对偶理论</strong></li>
</ul>
<h5 id="三-Farkas引理的推论"><a href="#三-Farkas引理的推论" class="headerlink" title="(三) Farkas引理的推论"></a>(三) Farkas引理的推论</h5><ul>
<li><strong>Gordan定理：</strong>给定矩阵$\boldsymbol A_{m \times n}$，则以下两个问题<strong>有且只有一个有解</strong>：<ul>
<li>问题1——<script type="math/tex">\boldsymbol{Ax < 0}</script></li>
<li>问题2——<script type="math/tex">\boldsymbol{A^Ty = 0}, \boldsymbol{y \geq 0}, \boldsymbol{y \neq 0}</script></li>
</ul>
</li>
<li>给定矩阵$\boldsymbol A_{m \times n}$以及$n$维向量以及$n$维向量$\boldsymbol c$，则以下两个问题<strong>有且只有一个有解</strong>：<ul>
<li>问题1——<script type="math/tex">\boldsymbol{Ax \leq 0}, \boldsymbol{x \geq 0}, \boldsymbol{c^Tx > 0}</script></li>
<li>问题2——<script type="math/tex">\boldsymbol{A^Ty \geq c}, \boldsymbol{y \geq 0}</script></li>
</ul>
</li>
<li>其他还有好几个推论。。。</li>
</ul>
<h3 id="第三讲-凸函数"><a href="#第三讲-凸函数" class="headerlink" title="第三讲 凸函数"></a>第三讲 凸函数</h3><h4 id="3-1-凸函数与凹函数定义"><a href="#3-1-凸函数与凹函数定义" class="headerlink" title="3.1 凸函数与凹函数定义"></a>3.1 凸函数与凹函数定义</h4><h5 id="一-凸函数"><a href="#一-凸函数" class="headerlink" title="(一) 凸函数"></a>(一) 凸函数</h5><p>设$\boldsymbol C$为非空凸集，$f$是定义在$\boldsymbol C$上的函数，如果对任意的$\boldsymbol x, \boldsymbol y \in \boldsymbol C, \alpha \in (0,1)$，均有：</p>
<script type="math/tex; mode=display">
f(\alpha \boldsymbol x + (1-\alpha)\boldsymbol y) \leq \alpha f(\boldsymbol x) + (1-\alpha)f\boldsymbol (y)</script><p>则称$f$为$\boldsymbol C$上的<strong>凸函数</strong>。</p>
<h5 id="二-严格凸函数"><a href="#二-严格凸函数" class="headerlink" title="(二) 严格凸函数"></a>(二) 严格凸函数</h5><script type="math/tex; mode=display">
f(\alpha \boldsymbol x + (1-\alpha)\boldsymbol y) < \alpha f(\boldsymbol x) + (1-\alpha)f\boldsymbol (y)</script><h5 id="三-凹函数"><a href="#三-凹函数" class="headerlink" title="(三) 凹函数"></a>(三) 凹函数</h5><p>设$\boldsymbol C$为非空凸集，$f$是定义在$\boldsymbol C$上的函数，如果对任意的$\boldsymbol x, \boldsymbol y \in \boldsymbol C, \alpha \in (0,1)$，均有：</p>
<script type="math/tex; mode=display">
f(\alpha \boldsymbol x + (1-\alpha)\boldsymbol y) \geq \alpha f(\boldsymbol x) + (1-\alpha)f\boldsymbol (y)</script><p>则称$f$为$\boldsymbol C$上的凹<strong>函数</strong>。</p>
<h5 id="四-严格凹函数"><a href="#四-严格凹函数" class="headerlink" title="(四) 严格凹函数"></a>(四) 严格凹函数</h5><script type="math/tex; mode=display">
f(\alpha \boldsymbol x + (1-\alpha)\boldsymbol y) > \alpha f(\boldsymbol x) + (1-\alpha)f\boldsymbol (y)</script><blockquote>
<p>若$-f$是凸函数，那么$f$为凹函数。</p>
<p>如果原来要求解一个凹函数$f(x)$的最大值，则可以转换为凸函数的最小值：</p>
<script type="math/tex; mode=display">
\max f(x)  \Longleftrightarrow \min -f(x)</script></blockquote>
<h4 id="3-2-常见凸函数"><a href="#3-2-常见凸函数" class="headerlink" title="3.2 常见凸函数"></a>3.2 常见凸函数</h4><h5 id="一-线性函数"><a href="#一-线性函数" class="headerlink" title="(一) 线性函数"></a>(一) 线性函数</h5><script type="math/tex; mode=display">
f(\boldsymbol x) = \boldsymbol a^{\mathrm T} \boldsymbol x + b</script><p>该函数很特殊，它既<strong>唯一一类</strong>是凸函数又是凹函数。</p>
<h5 id="二-二次函数"><a href="#二-二次函数" class="headerlink" title="(二) 二次函数"></a>(二) 二次函数</h5><script type="math/tex; mode=display">
f(\boldsymbol x) =  \boldsymbol x^{\mathrm T} \boldsymbol Q \boldsymbol x + \boldsymbol a^{\mathrm T} \boldsymbol x + b, \boldsymbol Q \in \boldsymbol S_+^n</script><p>其中$\boldsymbol Q \in \boldsymbol S_+^n$是指$\boldsymbol Q$为<strong><font color="blue">半正定</font></strong>矩阵。该式子涉及<strong><font color="red">二次型</font></strong>的知识。</p>
<h5 id="三-最小二乘函数"><a href="#三-最小二乘函数" class="headerlink" title="(三) 最小二乘函数"></a>(三) 最小二乘函数</h5><script type="math/tex; mode=display">
f(\boldsymbol x) = ||\boldsymbol{Ax - b}||_2^2</script><h5 id="四-p-范数"><a href="#四-p-范数" class="headerlink" title="(四) $p$范数"></a>(四) $p$范数</h5><script type="math/tex; mode=display">
f(\boldsymbol x) = \left( \sum_{i = 1}^n |x_i|^p\right)^{\frac{1}{p}}, p \geq 1</script><blockquote>
<p>0范数：$f(\boldsymbol x) = ||\boldsymbol x||_0$表示向量$\boldsymbol x$中<strong>0元素的个数</strong>。</p>
</blockquote>
<h4 id="3-3-凸函数的性质"><a href="#3-3-凸函数的性质" class="headerlink" title="3.3 凸函数的性质"></a>3.3 凸函数的性质</h4><h5 id="一-连续性"><a href="#一-连续性" class="headerlink" title="(一)连续性"></a>(一)连续性</h5><p>一个函数若是凸函数，那么该函数一定是连续函数。</p>
<h5 id="二-性质2"><a href="#二-性质2" class="headerlink" title="(二) 性质2"></a>(二) 性质2</h5><p>$f(\boldsymbol x)$为凸函数，等价于对任意的$\boldsymbol{x,y} \in \mathbb{R}^n$，一元函数：</p>
<script type="math/tex; mode=display">
\varphi(\alpha) = f(\boldsymbol x + \alpha \boldsymbol y)</script><p>为凸函数。相当于把函数竖着切一下得到的切面？？？</p>
<h5 id="三-性质3——判定凸函数的一阶条件"><a href="#三-性质3——判定凸函数的一阶条件" class="headerlink" title="(三) 性质3——判定凸函数的一阶条件"></a>(三) 性质3——判定凸函数的一阶条件</h5><p>$f(\boldsymbol x)$为$\boldsymbol C$上的凸函数的充要条件为：</p>
<script type="math/tex; mode=display">
f(\boldsymbol y) \geq f(\boldsymbol x) + \bigtriangledown f(\boldsymbol x)^{\mathrm T}(\boldsymbol y - \boldsymbol x), \forall \boldsymbol {x, y \in C}</script><p>几何上的意义就是$f(\boldsymbol x)$要在经过某一点的切面的上方，注意到上式中右式为函数在点处的一阶泰勒展开，在$n = 1$情形下的几何意义如下图：</p>
<p><img src="https://pic.imgdb.cn/item/628c479d09475431292ef5f0.jpg" style="zoom:50%"></p>
<p> 对应的切线方程为：$g(y) =  f(x) + \bigtriangledown f(x)^{\mathrm T}(y - x)$</p>
<p>证明：参考网络上的一些博客/b站视频。</p>
<h5 id="四-性质4——判定凸函数的二阶条件"><a href="#四-性质4——判定凸函数的二阶条件" class="headerlink" title="(四) 性质4——判定凸函数的二阶条件"></a>(四) 性质4——判定凸函数的二阶条件</h5><p>一阶条件在工作中很少被使用，我们往往使用的是二阶条件来判定函数的凸性。</p>
<blockquote>
<p>二阶条件涉及到了Hessian matrix，它是这样定义的。 </p>
<p>在数学中，海森矩阵（Hessian matrix 或 Hessian）是一个多变量实值函数的二阶偏导数组成的方块矩阵，假设有一实数函数$f (x_1 , x_2 , . . . , x_n )$ ，如果$f$所有的二阶偏导数都存在，那么$f$的海森矩阵是长下面这样：</p>
<p><img src="https://pic.imgdb.cn/item/628c49750947543129314633.jpg" style="zoom:70%"></p>
</blockquote>
<p>设$\boldsymbol C \in \mathbb{R}^n$是非空开凸集，$f(\boldsymbol x)$在$\boldsymbol C$上二阶连续可微，则$f(\boldsymbol x)$是$\boldsymbol C$上的凸函数，等价于$f(\boldsymbol x)$的二阶Hessian matrix：</p>
<script type="math/tex; mode=display">
\bigtriangledown^2 f(\boldsymbol x) \geq 0, \forall \boldsymbol x \in C</script><p>即函数的二阶Hessian matrix需要是<strong>半正定的</strong>。</p>
<p>对于$\boldsymbol C \in \mathbb{R}$上的函数, 上式退化为$ \dfrac{\mathrm d}{\mathrm d x} \left( \dfrac{\mathrm d f}{\mathrm d x} \right) = f′′(x) ⩾ 0$. 该条件表明函数$f$的导数非减，从几何上解释就是函数$f$在点$x$处具有向上(正)的曲率。</p>
<h4 id="3-4-保持函数凸性的运算"><a href="#3-4-保持函数凸性的运算" class="headerlink" title="3.4 保持函数凸性的运算"></a>3.4 保持函数凸性的运算</h4><h5 id="一-Perspective-function"><a href="#一-Perspective-function" class="headerlink" title="(一) Perspective function"></a>(一) Perspective function</h5><p>若$f(\boldsymbol x)$为凸函数，则：</p>
<script type="math/tex; mode=display">
g(\boldsymbol x, t) = t f(\dfrac{\boldsymbol x}{t}), t > 0</script><p>为凸函数，设$f(x) = x^2$，则$g(x,t)$的可视化如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/628c4da7094754312936a3c5.jpg" style="zoom:70%"></p>
<h5 id="二-非负组合"><a href="#二-非负组合" class="headerlink" title="(二) 非负组合"></a>(二) 非负组合</h5><p>设有一组凸函数：$f_1(\boldsymbol x), f_2(\boldsymbol x), \cdots, f_m(\boldsymbol x)$，则有：</p>
<script type="math/tex; mode=display">
g(\boldsymbol x) = w_1  f_1(\boldsymbol x) + w_2 f_2(\boldsymbol x) + \cdots + w_m f_m(\boldsymbol x), w_i \geq 0</script><p>为凸函数。</p>
<h5 id="三-凸函数求最大"><a href="#三-凸函数求最大" class="headerlink" title="(三) 凸函数求最大"></a>(三) 凸函数求最大</h5><p>设有一组凸函数：$f_1(\boldsymbol x), f_2(\boldsymbol x), \cdots, f_m(\boldsymbol x)$，则有：</p>
<script type="math/tex; mode=display">
g(\boldsymbol x) = \max \begin{Bmatrix} f_1(\boldsymbol x), f_2(\boldsymbol x), \cdots, f_m(\boldsymbol x) \end{Bmatrix}</script><p>为凸函数。</p>
<h4 id="3-5-凸集与凸函数的关系"><a href="#3-5-凸集与凸函数的关系" class="headerlink" title="3.5 凸集与凸函数的关系"></a>3.5 凸集与凸函数的关系</h4><p>讨论凸集和凸函数的两个工具：<strong>凸集</strong>，<strong>上(镜)图Epigraph</strong></p>
<h5 id="一-水平集"><a href="#一-水平集" class="headerlink" title="(一) 水平集"></a>(一) 水平集</h5><p>任意一个函数(不一定是凸函数)$f(\boldsymbol x)$的<strong>水平集</strong>：</p>
<script type="math/tex; mode=display">
\boldsymbol L_a = \begin{Bmatrix} \boldsymbol x \mid f(\boldsymbol x) \leq a, \boldsymbol x \in C \end{Bmatrix}</script><p>其中$a$为给定的水平值。</p>
<p>$f(\boldsymbol x)​$是凸函数，则其水平集均为凸集。反之，则不成立，即函数不是凸函数时，其水平集也可能是凸集。</p>
<h5 id="二-上-镜-图Epigraph"><a href="#二-上-镜-图Epigraph" class="headerlink" title="(二) 上(镜)图Epigraph"></a>(二) 上(镜)图Epigraph</h5><p>函数$f(\boldsymbol x)$的Epigraph定义为：</p>
<script type="math/tex; mode=display">
\text{epi} (f) = \begin{Bmatrix} (\boldsymbol x, \boldsymbol y)^{\mathrm T} \mid f(\boldsymbol x) \leq \boldsymbol y, \boldsymbol x \in \boldsymbol C \end{Bmatrix}</script><script type="math/tex; mode=display">
f(\boldsymbol x)是凸函数为凸集  \Longleftrightarrow \text{epi} (f)为凸集合</script><p><img src="https://pic.imgdb.cn/item/628c55cb094754312940ee44.jpg" style="zoom:50%"></p>
<p>小问题：给定非空闭凸集$\boldsymbol C$，证明距离函数$f(\boldsymbol y)$是凸函数，其中：</p>
<script type="math/tex; mode=display">
f(\boldsymbol y) = \min \begin{Bmatrix}||\boldsymbol{y-x}||_2 \mid  \boldsymbol x \in \boldsymbol C \end{Bmatrix}</script><h3 id="第四讲-凸优化问题"><a href="#第四讲-凸优化问题" class="headerlink" title="第四讲 凸优化问题"></a>第四讲 凸优化问题</h3><h4 id="4-1-凸优化问题通式"><a href="#4-1-凸优化问题通式" class="headerlink" title="4.1 凸优化问题通式"></a>4.1 凸优化问题通式</h4><p>考虑最优化问题（P）：</p>
<script type="math/tex; mode=display">
\begin{cases}\text { min } & f(\boldsymbol x) \\ 
\text{ s.t. } & g_{i}(\boldsymbol x) \leq 0, \text{  } i=1, \cdots, m \\ 
& h_{i}(\boldsymbol x) = 0, \text{  } i=1, \cdots, l\end{cases}</script><p>记P的可行域为<script type="math/tex">\boldsymbol S = \begin{Bmatrix} \boldsymbol x \in \mathbb{R}^n \mid g_{i}(\boldsymbol x) \leq 0, \text{  } i=1, \cdots, m,  h_{i}(\boldsymbol x) = 0, \text{  } i=1, \cdots, l \end{Bmatrix}</script>，则<font color="blue">当<script type="math/tex">f(\boldsymbol x), g_{i}(\boldsymbol x)</script>是凸函数</font>，<font color="green"><script type="math/tex">h_{i}(\boldsymbol x)</script>是线性函数时</font>，问题（P）称为<strong><font color="red">凸优化问题</font></strong>。</p>
<ul>
<li>为什么特别强调不等式约束条件<script type="math/tex">g_{i}(\boldsymbol x)</script>是凸函数呢？</li>
</ul>
<p>首先，<script type="math/tex">g_{i}(\boldsymbol x) \leq 0</script>刻画的是水平值取0时的一个<strong>水平集</strong>；又知当函数为凸函数时，其水平集均为凸集合。</p>
<ul>
<li>为什么特别强调等式约束条件<script type="math/tex">h_{i}(\boldsymbol x)</script>是线性函数呢？</li>
</ul>
<p>等式约束当为线性函数是，就相当于<script type="math/tex">h_{i}(\boldsymbol x) = \boldsymbol a^{\mathrm T} \boldsymbol x + \boldsymbol b = 0</script>，这种形式所刻画的集合是一个超平面，而超平面也是一个凸集合。</p>
<p>由以上两个小问题分析可知，在上面的条件下，由不等式约束和等式约束所刻画的集合<script type="math/tex">\boldsymbol S</script>也是一个凸集合，这是凸优化问题的一个特点。</p>
<p><img src="https://pic.imgdb.cn/item/628d92730947543129dd4af1.jpg" style="zoom:50%"></p>
<h4 id="4-2-区分凸优化与非凸优化"><a href="#4-2-区分凸优化与非凸优化" class="headerlink" title="4.2 区分凸优化与非凸优化"></a>4.2 区分凸优化与非凸优化</h4><p>区分凸优化与非凸优化是一个非常重要的事情，若是我们能够判断出该问题为凸优化问题，那么就能利用凸优化很多很好的性质进行求解分析问题。下面介绍凸优化问题的两个比较好的性质。</p>
<h5 id="一-局部最优即全局最优"><a href="#一-局部最优即全局最优" class="headerlink" title="(一) 局部最优即全局最优"></a>(一) 局部最优即全局最优</h5><p>对于凸优化问题，其局部最优解就是全局最优解。</p>
<ul>
<li><strong>局部最优解</strong></li>
</ul>
<p>设现在有一个问题可行解为<script type="math/tex">\overline{\boldsymbol x}</script>满足：<script type="math/tex">f(\overline{\boldsymbol x}) \leq f(\boldsymbol x), \forall \boldsymbol x \in \boldsymbol S \cap \boldsymbol N_{\epsilon}(\overline{\boldsymbol x})</script>即在<script type="math/tex">\overline{\boldsymbol x}</script>很小的范围内的函数值都要大于<script type="math/tex">\overline{\boldsymbol x}</script>处的函数值，此时<script type="math/tex">\overline{\boldsymbol x}</script>为局部最优解。</p>
<ul>
<li><strong>全局最优解</strong></li>
</ul>
<p>设现在有一个问题可行解为<script type="math/tex">\overline{\boldsymbol x}^*</script>满足：<script type="math/tex">f(\overline{\boldsymbol x}^*) \leq f(\boldsymbol x), \forall \boldsymbol x \in \boldsymbol S</script>即在整个可行域范围内的函数值都要大于<script type="math/tex">\overline{\boldsymbol x}^*</script>处的函数值，此时<script type="math/tex">\overline{\boldsymbol x}^*</script>为全局最优解。</p>
<p><strong>证明：</strong></p>
<p>设对于凸优化，<script type="math/tex">\overline{\boldsymbol x}</script>是局部最优解，但不是全局最优，即存在<script type="math/tex">{\boldsymbol x}^*</script>使得<script type="math/tex">f({\boldsymbol x}^*) < f(\overline{\boldsymbol x}), \forall \boldsymbol x \in \boldsymbol S</script>，取<script type="math/tex">\lambda \in (0,1)</script>，则有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f\left(\overline{\boldsymbol{x}}+\lambda\left(\boldsymbol{x}^{*}-\overline{\boldsymbol{x}}\right)\right) &\left.=f\left(\lambda \boldsymbol{x}^{*}+(1-\lambda) \overline{\boldsymbol{x}}\right)\right) \\
& \leq \lambda f\left(\boldsymbol{x}^{*}\right)+(1-\lambda) f(\overline{\boldsymbol{x}}) \\
&<f(\overline{\boldsymbol{x}})
\end{aligned}</script><p>当$\lambda \to 0$时，$\left(\overline{\boldsymbol{x}}+\lambda\left(\boldsymbol{x}^{*}-\overline{\boldsymbol{x}}\right)\right) $就非常趋近与<script type="math/tex">\overline{\boldsymbol x}</script>，即在<script type="math/tex">\overline{\boldsymbol x}</script>的邻域里面。那么就可以得出结论：凸优化的局部最优一定时全局最优，不然后产生矛盾。</p>
<h5 id="二-凸优化问题最优性条件"><a href="#二-凸优化问题最优性条件" class="headerlink" title="(二) 凸优化问题最优性条件"></a>(二) 凸优化问题最优性条件</h5><p>最优性条件其实就是在讨论优化问题的最优解要满足的条件：充分条件、必要条件、充要条件。</p>
<p>设<script type="math/tex">\overline{\boldsymbol x}^* \in \boldsymbol S</script>为某一最优化问题的最优解，则等价于(<strong>充要条件</strong>)：</p>
<script type="math/tex; mode=display">
\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}(\boldsymbol x - \overline{\boldsymbol x}^*) \geq 0, \forall  \boldsymbol x \in \boldsymbol S</script><p><strong>证明——充分性：</strong>已知<script type="math/tex">\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}(\boldsymbol x - \overline{\boldsymbol x}^*) \geq 0, \forall  \boldsymbol x \in \boldsymbol S</script>，求证此时<script type="math/tex">\overline{\boldsymbol x}^* \in \boldsymbol S</script>为某一最优化问题的最优解。</p>
<p>首先<script type="math/tex">f(\overline{\boldsymbol x}^*) + \triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}(\boldsymbol x - \overline{\boldsymbol x}^*)</script>是一个经过<script type="math/tex">(\overline{\boldsymbol x}^*, f(\overline{\boldsymbol x}^*))</script>点的切平面，因为目标函数<script type="math/tex">f</script>是凸函数，则函数在其切平面的上方，即满足：</p>
<script type="math/tex; mode=display">
f(\boldsymbol x) \geq f(\overline{\boldsymbol x}^*) + \triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}(\boldsymbol x - \overline{\boldsymbol x}^*) \geq f(\overline{\boldsymbol x}^*)  , \forall \boldsymbol x \in \boldsymbol S</script><p>即，对于任意<script type="math/tex">\boldsymbol x</script>都有<script type="math/tex">f(\boldsymbol x) \geq  f(\overline{\boldsymbol x}^*)</script>，即<script type="math/tex">\overline{\boldsymbol x}^* \in \boldsymbol S</script>为最优化问题的最优解。</p>
<p><strong>证明——必要性：</strong>已知<script type="math/tex">\overline{\boldsymbol x}^* \in \boldsymbol S</script>为某一最优化问题的最优解，求证<script type="math/tex">\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}(\boldsymbol x - \overline{\boldsymbol x}^*) \geq 0, \forall  \boldsymbol x \in \boldsymbol S</script>。</p>
<p>(反证法)：设存在<script type="math/tex">\overline{\boldsymbol x} \in \boldsymbol S</script>使得<script type="math/tex">\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}(\overline{\boldsymbol x} - \overline{\boldsymbol x}^*) < 0</script>，<script type="math/tex">\lambda \in (0,1)</script></p>
<script type="math/tex; mode=display">
f(\overline{\boldsymbol{x}}^*+\lambda(\overline{\boldsymbol{x}}-\overline{\boldsymbol{x}}^*))\overset{泰勒展开}{=} f(\overline{\boldsymbol{x}}^*) + \lambda \triangledown f (\overline{\boldsymbol{x}}^*)(\boldsymbol x - \overline{\boldsymbol x}^*) + o(\lambda||\boldsymbol x - \overline{\boldsymbol x}^*)||)</script><p>整理可得：</p>
<script type="math/tex; mode=display">
\frac{f(\overline{\boldsymbol{x}}^*+\lambda(\overline{\boldsymbol{x}}-\overline{\boldsymbol{x}}^*))-f(\overline{\boldsymbol{x}}^*)}{\lambda} = \triangledown f (\overline{\boldsymbol{x}}^*)(\boldsymbol x - \overline{\boldsymbol x}^*) + \frac{o(\lambda||\boldsymbol x - \overline{\boldsymbol x}^*)||)}{\lambda}</script><p>当<script type="math/tex">\lambda \to 0</script>时，<script type="math/tex">\dfrac{o(\lambda||\boldsymbol x - \overline{\boldsymbol x}^*)||)}{\lambda} \to 0</script>，<script type="math/tex">\triangledown f (\overline{\boldsymbol{x}}^*)(\boldsymbol x - \overline{\boldsymbol x}^*) < 0</script>，则：</p>
<script type="math/tex; mode=display">
\triangledown f (\overline{\boldsymbol{x}}^*)(\boldsymbol x - \overline{\boldsymbol x}^*) + \dfrac{o(\lambda||\boldsymbol x - \overline{\boldsymbol x}^*)||)}{\lambda} < 0</script><p>此时等式左边<script type="math/tex">\dfrac{f(\overline{\boldsymbol{x}}^*+\lambda(\overline{\boldsymbol{x}}-\overline{\boldsymbol{x}}^*))-f(\overline{\boldsymbol{x}}^*)}{\lambda} < 0</script>，即我们找到比<script type="math/tex">f(\overline{\boldsymbol x}^*)</script>函数值更小的，即与<script type="math/tex">\overline{\boldsymbol x}^*</script>是最优解矛盾。</p>
<p><strong>几何解释：</strong></p>
<script type="math/tex; mode=display">
\overline{\boldsymbol x}^* \in \boldsymbol S是最优解 \\
\Updownarrow \\
\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}(\boldsymbol x - \overline{\boldsymbol x}^*) \geq 0, \forall  \boldsymbol x \in \boldsymbol S \\
\Updownarrow \\
-\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}\overline{\boldsymbol x}^* \geq -\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T} \boldsymbol x, \forall  \boldsymbol x \in \boldsymbol S \\
\Updownarrow  \\
令\boldsymbol \alpha = -\triangledown f(\overline{\boldsymbol x}^*) \\
\Updownarrow  \\
\boldsymbol \alpha^{\mathrm T} \overline{\boldsymbol x}^* \geq \boldsymbol \alpha^{\mathrm T} {\boldsymbol x}, \forall  \boldsymbol x \in \boldsymbol S</script><p>由上面的等价表达可知，若<script type="math/tex">\boldsymbol \alpha \neq \boldsymbol 0(\triangledown f(\overline{\boldsymbol x}^*) \neq \boldsymbol 0)</script>，则就找到了一个<strong>支撑超平面</strong>，该支撑超平面经过<script type="math/tex">\overline{\boldsymbol x}^*</script>，在该点处恰好支撑整个凸集合<script type="math/tex">\boldsymbol S</script>。</p>
<p><img src="https://pic.imgdb.cn/item/628f2d8e0947543129edcef9.jpg" style="zoom:35%"></p>
<p><strong>几类特殊凸问题的最优性条件：</strong></p>
<ul>
<li><p>无约束凸优化<script type="math/tex">\min f(\boldsymbol x) \text{ over } \mathbb{R}^n</script>：<script type="math/tex">\overline{\boldsymbol x}^*最优 \Longleftrightarrow  \triangledown f(\overline{\boldsymbol x}^*) = \boldsymbol 0</script></p>
<ul>
<li>根据前面的条件，可知：<script type="math/tex">\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}(\boldsymbol x - \overline{\boldsymbol x}^*) \geq 0</script>，由于没有约束条件，即<script type="math/tex">(\boldsymbol x - \overline{\boldsymbol x}^*)</script>可以取遍<script type="math/tex">\mathbb{R}^n</script>中的所有向量，那么此时<script type="math/tex">\triangledown f(\overline{\boldsymbol x}^*) = \boldsymbol 0</script>。</li>
</ul>
</li>
<li><p>等式约束凸问题<script type="math/tex">\min \begin{Bmatrix} f(\boldsymbol x) \mid \boldsymbol{Ax = b}\end{Bmatrix}</script>：<script type="math/tex">\overline{\boldsymbol x}^*最优 \Longleftrightarrow  ∃\boldsymbol \mu,使得 \triangledown f(\overline{\boldsymbol x}^*) + \boldsymbol A^{\mathrm T} \boldsymbol \mu= \boldsymbol 0, \boldsymbol A \overline{\boldsymbol x}^* = \boldsymbol b</script></p>
<ul>
<li>根据前面的条件，可知：<script type="math/tex">\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}(\boldsymbol x - \overline{\boldsymbol x}^*) \geq 0</script>，满足<script type="math/tex">\boldsymbol{Ax = b}, \boldsymbol{A\overline{\boldsymbol x}^* = b}</script>，令向量<script type="math/tex">\boldsymbol d = \boldsymbol x - \overline{\boldsymbol x}^*</script>，那么将满足等式约束的两个式子相减：<script type="math/tex">\boldsymbol{A(x - \overline{x}^*) = \boldsymbol{Ad}= 0}</script>，即向量<script type="math/tex">\boldsymbol d</script>在<script type="math/tex">\boldsymbol A</script>的<strong>零空间</strong>中。又由于向量<script type="math/tex">\boldsymbol d</script>在<script type="math/tex">\boldsymbol A</script>的零空间中，那么<script type="math/tex">-\boldsymbol d</script>同样在<script type="math/tex">\boldsymbol A</script>的零空间中，因此向量<script type="math/tex">\boldsymbol d</script>和<script type="math/tex">-\boldsymbol d</script>都是<script type="math/tex">\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}(\boldsymbol x - \overline{\boldsymbol x}^*) = \triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T} \boldsymbol d\geq 0</script>的解，也就是该不等式添加负号不等号不变方向，也就等价于<script type="math/tex">\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}(\boldsymbol x - \overline{\boldsymbol x}^*) = \triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T} \boldsymbol d = 0</script>。由于<script type="math/tex">\boldsymbol d</script>在<script type="math/tex">\boldsymbol A</script>的<strong>零空间</strong>中，而<script type="math/tex">\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T} \boldsymbol d = 0</script>，所以<script type="math/tex">\triangledown f(\overline{\boldsymbol x}^*)^{\mathrm T}</script>在<script type="math/tex">\boldsymbol A</script>的正交补空间中，也就是<script type="math/tex">\boldsymbol A</script>的行空间，所以<script type="math/tex">\triangledown f(\overline{\boldsymbol x}^*)</script>可以表示成<script type="math/tex">\boldsymbol A^{\mathrm T}</script>的线性组合：</li>
</ul>
<script type="math/tex; mode=display">
∃\boldsymbol \mu,使得 \triangledown f(\overline{\boldsymbol x}^*) + \boldsymbol A^{\mathrm T} \boldsymbol \mu= \boldsymbol 0, \boldsymbol A \overline{\boldsymbol x}^* = \boldsymbol b</script><ul>
<li>这个就是<strong>KKT条件</strong>在本问题中的具体表现形式。</li>
</ul>
</li>
<li><p>非负约束凸优化<script type="math/tex">\min \begin{Bmatrix} f(\boldsymbol x) \mid \boldsymbol{x \geq 0}\end{Bmatrix}</script>：<script type="math/tex">\overline{\boldsymbol x}^*最优 \Longleftrightarrow  \triangledown f(\overline{\boldsymbol x}^*)_i  \overline{\boldsymbol x}^*_i= \boldsymbol 0, \overline{\boldsymbol x}^*>\boldsymbol 0, \triangledown f(\overline{\boldsymbol x}^*) \geq \boldsymbol 0</script></p>
<ul>
<li>证明暂略，比较复杂，看视频吧</li>
</ul>
</li>
</ul>
<h4 id="4-3-常见凸优化问题分类"><a href="#4-3-常见凸优化问题分类" class="headerlink" title="4.3 常见凸优化问题分类"></a>4.3 常见凸优化问题分类</h4><h5 id="一-线性规划-Linear-Programming-LP"><a href="#一-线性规划-Linear-Programming-LP" class="headerlink" title="(一) 线性规划 (Linear Programming, LP)"></a>(一) 线性规划 (Linear Programming, LP)</h5><p><strong>1 线性规划的标准形式</strong></p>
<script type="math/tex; mode=display">
\begin{cases}\text { min } & \boldsymbol c^{\mathrm T}\boldsymbol x + d \\ 
\text{ s.t.} & \boldsymbol{Gx = b}, \\ 
& \boldsymbol{Hx \leq e}. \end{cases}</script><p>一言以蔽之，目标函数和约束条件都是<strong>仿射函数</strong>。 </p>
<p>注意，凸优化问题中很多形式可以通过转换变为标准形式的！！！如下面几种情况：</p>
<ul>
<li><strong>线性分式规划</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/628f8221094754312973562a.jpg" style="zoom:40%"></p>
<ul>
<li><strong>最小化绝对值函数</strong></li>
</ul>
<script type="math/tex; mode=display">
\min  \begin{Bmatrix}|\boldsymbol a^{\mathrm T} \boldsymbol x + \boldsymbol c| \boldsymbol{AX = b}  \end{Bmatrix}</script><p><img src="https://pic.imgdb.cn/item/628f83b1094754312976493f.jpg" style="zoom:40%"></p>
<ul>
<li><strong>最小化多面体函数</strong></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/628f85720947543129793020.jpg" style="zoom:40%"></p>
<p><strong>2 标准解法——单纯形法</strong></p>
<p>单纯形法的基本思想是——基于线性规划的可行集是一个多面体，目标函数是线性的，绘制其等值面的时候是一组平行的线/面，找到多面体的支撑超平面。所以说，如果线性规划存在最优解，则可在<strong>极点</strong>(多面体的顶点)达到。</p>
<p>若<script type="math/tex">\overline{\boldsymbol x}</script>是一个极点，则需判断<script type="math/tex">\overline{\boldsymbol x}</script>是否是最优解：</p>
<ul>
<li>若是最优解，则求解完成；</li>
<li>若不是最优解，则需从<script type="math/tex">\overline{\boldsymbol x}</script>出发，找一个更优的极点。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/628f40da09475431290aaad7.jpg" style="zoom:50%"></p>
<blockquote>
<p>详细参见：<a href="https://blog.csdn.net/whn19980801/article/details/115741791?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-115741791-blog-105621647.pc_relevant_default&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4">线性规划问题（LP问题）</a>， <a href="https://www.zhihu.com/question/308189306">解决线性规划问题为什么要加入松弛变量？</a></p>
</blockquote>
<h5 id="二-凸二次规划-Quadratic-Programming-QP"><a href="#二-凸二次规划-Quadratic-Programming-QP" class="headerlink" title="(二) 凸二次规划 (Quadratic Programming, QP)"></a>(二) 凸二次规划 (Quadratic Programming, QP)</h5><p><strong>1 凸二次规划基本形式</strong></p>
<script type="math/tex; mode=display">
\begin{cases}\text { min } & \frac{1}{2} \boldsymbol x^{\mathrm T} \boldsymbol Q \boldsymbol x +  \boldsymbol c^{\mathrm T}  \boldsymbol x \\ 
\text{ s.t.} & \boldsymbol{Ax = b}, \\ 
& \boldsymbol{x \geq 0}. \end{cases}</script><p>其中，<script type="math/tex">\boldsymbol Q \geq \boldsymbol 0</script>。</p>
<p><strong>2 标准解法——有效集法</strong></p>
<blockquote>
<p>后面讲解。</p>
</blockquote>
<p><strong>3 示例</strong></p>
<ul>
<li>均值-方差模型</li>
<li>最小二乘模型</li>
</ul>
<h5 id="三-带凸二次约束的二次规划-Quadraticlly-Constrained-Quadratic-Program-QCQP"><a href="#三-带凸二次约束的二次规划-Quadraticlly-Constrained-Quadratic-Program-QCQP" class="headerlink" title="(三) 带凸二次约束的二次规划(Quadraticlly Constrained Quadratic Program, QCQP)"></a>(三) 带凸二次约束的二次规划(Quadraticlly Constrained Quadratic Program, QCQP)</h5><p><strong>1 基本形式</strong></p>
<script type="math/tex; mode=display">
\begin{cases}\text { min } & \frac{1}{2} \boldsymbol x^{\mathrm T} \boldsymbol Q_0 \boldsymbol x +  \boldsymbol c_0^{\mathrm T}  \boldsymbol x \\ 
\text{ s.t.} & \frac{1}{2} \boldsymbol x^{\mathrm T} \boldsymbol Q_i \boldsymbol x +  \boldsymbol c_i^{\mathrm T}  \boldsymbol x + b_i \leq 0, \text{ } i = 1,2, \cdots, k \\ 
& \boldsymbol{Ax \leq d}. \end{cases}</script><p>其中，<script type="math/tex">\boldsymbol Q_i \geq \boldsymbol 0, i = 0, 1, \cdots, k.</script>。</p>
<h5 id="四-二阶锥规划-Second-Order-Cone-Program-SOCP"><a href="#四-二阶锥规划-Second-Order-Cone-Program-SOCP" class="headerlink" title="(四) 二阶锥规划 (Second-Order Cone Program, SOCP)"></a>(四) 二阶锥规划 (Second-Order Cone Program, SOCP)</h5><p><strong>1 基本形式</strong></p>
<script type="math/tex; mode=display">
\begin{cases}\text { min } & \boldsymbol f^{\mathrm T}\boldsymbol x \\ 
\text{ s.t.} & \|\boldsymbol{A_i x + b_i}  \|_2 \leq \boldsymbol c_i^{\mathrm T}\boldsymbol x + \boldsymbol d_i,  \text{ } i = 1,2, \cdots, k \\ 
& \boldsymbol{Hx \leq e}. \end{cases}</script><p>当$k = 0$时，为LP问题；当所有$\boldsymbol {c_i = 0}$时，为QCQP问题。</p>
<h5 id="五-半定规划-Semidefinite-Program-SDP"><a href="#五-半定规划-Semidefinite-Program-SDP" class="headerlink" title="(五) 半定规划 (Semidefinite Program, SDP)"></a>(五) 半定规划 (Semidefinite Program, SDP)</h5><p><strong>1 半定规划标准形式</strong></p>
<script type="math/tex; mode=display">
\begin{cases}\text { min } & \text{tr}(\boldsymbol C\boldsymbol X) \\ 
\text{ s.t.} & \text{tr}(\boldsymbol Q_i\boldsymbol X) = b_i,  \text{ } i = 1,2, \cdots, m \\ 
& \boldsymbol{x \geq 0}. \end{cases}</script><p>其中，<script type="math/tex">\boldsymbol C, \boldsymbol Q_i</script>均为对称矩阵。</p>
<p><strong>转化为：线性矩阵不等式形式(LMI)：</strong></p>
<script type="math/tex; mode=display">
\begin{cases}\text { min } & \boldsymbol c^{\mathrm T}\boldsymbol x \\ 
\text{ s.t.} & \sum\limits_{i=1}^{n} {\boldsymbol {x_iQ_i}} \leq \boldsymbol Q_0 \\ 
& \boldsymbol{Ax \geq b}. \end{cases}</script><blockquote>
<p>注意：若矩阵<script type="math/tex">\boldsymbol {Q_1 \leq Q_2}</script>，则有<script type="math/tex">\boldsymbol {Q_2 - Q_1}</script>是半正定矩阵。</p>
</blockquote>
<h5 id="六-几何规划-Geometric-Programming-GP"><a href="#六-几何规划-Geometric-Programming-GP" class="headerlink" title="(六) 几何规划  (Geometric Programming, GP)"></a>(六) 几何规划  (Geometric Programming, GP)</h5><p><strong>1 例子：切比雪夫中心(集合中心)</strong></p>
<ul>
<li>给定<strong>有界</strong>的集合<script type="math/tex">\boldsymbol C, \boldsymbol x \in \boldsymbol C</script>的深度定义为：</li>
</ul>
<script type="math/tex; mode=display">
\text{depth}(\boldsymbol x, \boldsymbol C) = \text{dist}(\boldsymbol x, \mathbb{R}^n(去除 \boldsymbol C) )</script><p>可以理解为集合<script type="math/tex">\boldsymbol C</script>中的点到集合<script type="math/tex">\boldsymbol C</script>边界的距离。</p>
<ul>
<li>集合<script type="math/tex">\boldsymbol C</script>的中心(chebyshev center)定义为具有最大深度的点：</li>
</ul>
<script type="math/tex; mode=display">
\boldsymbol x_{\text{center}}(\boldsymbol C) = \arg \max_{\boldsymbol x \in \boldsymbol C} \text{dist}(\boldsymbol x, \mathbb{R}^n(去除 \boldsymbol C) )</script><ul>
<li>集合的中心即包含于该集合的最大球体的球心。</li>
</ul>
<p><strong>2 凸集合的中心问题为凸优化问题</strong></p>
<p>(1) 假设<script type="math/tex">\boldsymbol S = \begin{Bmatrix} \boldsymbol x \mid f_{i}(\boldsymbol x) \leq 0, \text{  } i=1, \cdots, m \end{Bmatrix}</script>，其中<script type="math/tex">f_{i}(\boldsymbol x)</script>是凸函数，寻找包含<script type="math/tex">\boldsymbol S</script>的最大球体。</p>
<p>设该球体球心为<script type="math/tex">\boldsymbol x</script>，半径为<script type="math/tex">r</script>，该球可以表示为：<script type="math/tex">\boldsymbol B =  \begin{Bmatrix} \boldsymbol x+r \boldsymbol u \mid \| \boldsymbol u \|_2 \leq 1 \end{Bmatrix}</script></p>
<script type="math/tex; mode=display">
\begin{cases}\text { max } &\text { } \text { } r \\ 
\text{ s.t.} & \sup\limits_{\| \boldsymbol u \|_2 \leq 1} f_i(\boldsymbol x+r \boldsymbol u) \leq 0 , \text{  } i=1, \cdots, m\\ 
 \end{cases}</script><blockquote>
<p>注意：<a href="https://blog.csdn.net/hyl1181/article/details/111029319">max/sup、min/inf辨析</a>，<a href="https://blog.csdn.net/robert_chen1988/article/details/81233738">sup, inf 与 min, max</a></p>
<p>使用 inf 或 sup 总能保证一个函数的 inf 或 sup 存在，而函数的 min 或 max 有时候不存在。 </p>
</blockquote>
<p>(2) 多面体的中心：假设多面体<script type="math/tex">\boldsymbol P = \begin{Bmatrix} \boldsymbol x \in \R ^n\mid \boldsymbol a_i^{\mathrm T} \boldsymbol x \leq \boldsymbol b_i, \text{  } i=1, \cdots, m \end{Bmatrix}</script>，寻找包含<script type="math/tex">\boldsymbol P</script>的最大球体，其球心即为集合<script type="math/tex">\boldsymbol P</script>的中心。</p>
<p>通过题目，可将优化问题抽象如下：(球体可以表示为：<script type="math/tex">\boldsymbol B =  \begin{Bmatrix} \boldsymbol x+r \boldsymbol u \mid \| \boldsymbol u \|_2 \leq 1 \end{Bmatrix}</script>)</p>
<script type="math/tex; mode=display">
\begin{cases}\text { max } &\text { } \text { } r \\ 
\text{ s.t.} &  \boldsymbol a_i^{\mathrm T} \boldsymbol x + \|\boldsymbol a_i  \|_2 r \leq \boldsymbol b_i, \text{  } i=1, \cdots, m\\ 
 \end{cases}</script><p><img src="https://pic.imgdb.cn/item/62902b2809475431293274b3.jpg" style="zoom:65%"></p>
<p>(3) 椭球交集的中心：假设<script type="math/tex">\boldsymbol S = \begin{Bmatrix} \boldsymbol x \in \R ^n \mid \boldsymbol x^{\mathrm T}\boldsymbol A_i \boldsymbol x + 2\boldsymbol b_i^{\mathrm T}\boldsymbol x + c_i \leq 0, \text{  } i=1, \cdots, m \end{Bmatrix}</script>，其中<script type="math/tex">\boldsymbol A_i \geq \boldsymbol 0</script>，寻找包含<script type="math/tex">\boldsymbol S</script>的最大球体和球心。</p>
<p>通过问题描述，可将该问题建模为：</p>
<script type="math/tex; mode=display">
\begin{cases} \max & r \\

\text { s.t. } & \left(\begin{array}{ccc}
\boldsymbol A_{i}^{-1} & r l & -\left( \boldsymbol x+\boldsymbol A_{i}^{-1} \boldsymbol b_{i} \right) \\
r l & \lambda_{i} l & 0 \\
-\left( \boldsymbol x+\boldsymbol A_{i}^{-1}\boldsymbol  b_{i}\right)^{T} & 0 & -\lambda_{i}-c_{i}+\boldsymbol b_{i}^{T} \boldsymbol A_{i}^{-1}\boldsymbol b_{i}
\end{array}\right) \geq 0,
 \end{cases}</script><p>本问题涉及两个小知识点：</p>
<ul>
<li>S-Procedure：<ul>
<li>$x^{\top} F_{1} x+2 b_{1}^{\top} x+c_{1} \leq 0 \Rightarrow x^{\top} F_{2} x+2 b_{2}^{\top} x+c_{2} \leq 0$，当且仅当$\exist \lambda \geq 0$使得$\left(\begin{array}{ll} F_{1} &amp; b_{1} \\ b_{1}^{T} &amp; c_{1} \end{array}\right)-\left(\begin{array}{ll} F_{2} &amp; b_{2} \\ b_{2}^{T} &amp; c_{2} \end{array}\right) \geq 0$</li>
</ul>
</li>
<li>Schur complement 对称分块矩阵：<ul>
<li>如<script type="math/tex">X=\left(\begin{array}{cc} A & B \\ B^{T} & C \end{array}\right)</script>，若<script type="math/tex">\boldsymbol A \geq \boldsymbol 0</script>，则<script type="math/tex">\boldsymbol X \geq \boldsymbol 0</script>当且仅当<script type="math/tex">C-B^{\top} A^{-1} B \geq0</script></li>
</ul>
</li>
</ul>
<hr>
<p>参考资料：</p>
<p>【1】<a href="https://zhuanlan.zhihu.com/p/32926848">为啥要知道一个对称方阵是否为各种定呢</a></p>
<p>【2】<a href="https://zhuanlan.zhihu.com/p/44860862">浅谈「正定矩阵」和「半正定矩阵」</a></p>
<p>【3】<a href="https://zhuanlan.zhihu.com/p/62589178">正定(positive definite)与半正定(semi-positive definite)</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>数学基础</category>
        <category>最优化方法</category>
      </categories>
      <tags>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title>最优化方法_part2</title>
    <url>/2022/05/27/Optimization-method2/</url>
    <content><![CDATA[<h3 id="第五讲-无约束优化问题（壹）"><a href="#第五讲-无约束优化问题（壹）" class="headerlink" title="第五讲 无约束优化问题（壹）"></a>第五讲 无约束优化问题（壹）</h3><h4 id="5-1-无约束优化问题"><a href="#5-1-无约束优化问题" class="headerlink" title="5.1 无约束优化问题"></a>5.1 无约束优化问题</h4><h5 id="一-无约束优化问题：-min-f-boldsymbol-x"><a href="#一-无约束优化问题：-min-f-boldsymbol-x" class="headerlink" title="(一) 无约束优化问题：$ \min f(\boldsymbol x)$"></a>(一) 无约束优化问题：$ \min f(\boldsymbol x)$</h5><ul>
<li>最小二乘问题：<script type="math/tex">\min \| \boldsymbol{Ax-b} \|</script>；</li>
<li>采用适当的方法可将约束优化问题转换为无约束优化问题；</li>
<li>最优解的定义：<ul>
<li>局部最优解<script type="math/tex">\overline{\boldsymbol x}</script>：<script type="math/tex">\forall \boldsymbol x \in \boldsymbol N_{\epsilon}(\overline{\boldsymbol x}), f({\boldsymbol x}) \geq f(\overline{\boldsymbol x})</script></li>
<li>全局最优解<script type="math/tex">\boldsymbol x^*</script>：<script type="math/tex">\forall \boldsymbol x \in \mathbb{R}^n, f({\boldsymbol x}) \geq f(\boldsymbol x^*)</script></li>
<li>严格局部/全局最优解：即上面式子提到的<script type="math/tex">\geq \to ></script></li>
</ul>
</li>
</ul>
<h5 id="二-无约束优化问题最优性条件"><a href="#二-无约束优化问题最优性条件" class="headerlink" title="(二) 无约束优化问题最优性条件"></a>(二) 无约束优化问题最优性条件</h5><p>考虑无约束优化问题：<script type="math/tex">\min f(\boldsymbol x)</script>：</p>
<ul>
<li>若<script type="math/tex">f(\boldsymbol x)</script>为凸函数，则<script type="math/tex">\boldsymbol x^*</script>是最优解等级于<script type="math/tex">\triangledown f(\boldsymbol x^*) = \boldsymbol 0</script></li>
<li>若<script type="math/tex">f(\boldsymbol x)​</script>为一般函数(即不一定是凸函数)：<ul>
<li>必要条件：若<script type="math/tex">\boldsymbol x^*</script>是最优解，则<script type="math/tex">\triangledown f(\boldsymbol x^*) = \boldsymbol 0</script>；<script type="math/tex">\triangledown^2 f(\boldsymbol x^*) \succeq  \boldsymbol 0, (即黑塞矩阵半正定)</script><ul>
<li>上面两条分别对应<strong>“一阶必要条件”</strong>、<strong>“二阶必要条件”</strong></li>
<li><a href="https://zhuanlan.zhihu.com/p/370959560">泰勒展开形式</a></li>
</ul>
</li>
<li>充分条件：若<script type="math/tex">\triangledown f(\boldsymbol x^*) = \boldsymbol 0</script>且<script type="math/tex">\triangledown^2 f(\boldsymbol x^*) \succ \boldsymbol 0, (即黑塞矩阵半正定)</script>，则<script type="math/tex">\boldsymbol x^*</script>是<strong>严格最优解</strong>(局部？)</li>
</ul>
</li>
</ul>
<blockquote>
<p>修改：判定(半)正定矩阵的特殊大于(等于)简写符号为：<script type="math/tex">\succ, \succeq</script>，并不是<script type="math/tex">>, \geq</script></p>
</blockquote>
<h4 id="5-2-无约束优化算法概要"><a href="#5-2-无约束优化算法概要" class="headerlink" title="5.2 无约束优化算法概要"></a>5.2 无约束优化算法概要</h4><h5 id="一-迭代下降算法"><a href="#一-迭代下降算法" class="headerlink" title="(一) 迭代下降算法"></a>(一) 迭代下降算法</h5><p>给定初始点<script type="math/tex">\boldsymbol x_0</script>，产生点列<script type="math/tex">\begin{Bmatrix} \boldsymbol x_k \end{Bmatrix}_{k=1}^{\infty}</script>，并且<script type="math/tex">f(\boldsymbol x_{k+1}) < f(\boldsymbol x_k)</script>。</p>
<ul>
<li><p>如何从当前点<script type="math/tex">\boldsymbol x_k</script>得到下一个迭代点<script type="math/tex">\boldsymbol x_{k+1}</script>？</p>
<ul>
<li><p><strong>策略1：线搜索方法</strong></p>
<ul>
<li>当前点<script type="math/tex">\boldsymbol x_k</script>，从这个点出发，先找到某一个下降方向<script type="math/tex">\boldsymbol d_k</script>(即沿着该方向函数值减小)，然后需要设置在下降方向走多远(步长)<script type="math/tex">\alpha_k</script>，最终，得到下一个点为：<script type="math/tex">\boldsymbol x_{k+1} = \boldsymbol x_{k} + \alpha_k \boldsymbol d_k</script></li>
</ul>
</li>
<li><p><strong>策略2：信赖域方法</strong></p>
<ul>
<li><p>该方法有点和线搜索步骤反过来的意味，即先确定好需要前进的区域，然后选择前进的方向。</p>
</li>
<li><p>设前进区域设为<script type="math/tex">\boldsymbol p</script>，给定其约束为<script type="math/tex">\Delta</script>，可以表述为</p>
</li>
<li><script type="math/tex; mode=display">
\begin{cases}\text { min } & f(\boldsymbol x_{k} + \boldsymbol p) \\ 
\text{ s.t.} & \| \boldsymbol p \|_2 \leq \Delta \end{cases}</script><blockquote>
<p>注意：在线搜索方法中，选择步长是一个<strong>一元/一维</strong>的问题；但信赖域方法是一个<strong>N维</strong>问题($f$可能是一个比较复杂的函数)，因此信赖域方法直接求解复杂度较大。所以信赖域方法在求解时并不是直接求解上述优化，而是需要<strong><font color="blue">先用一个简单的函数$m_k(\boldsymbol p)$对$f$在$\boldsymbol x_k$点进行近似</font></strong>，比如用泰勒展开等方法。</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{cases}\text { min } & m_k(\boldsymbol p) \\ 
\text{ s.t.} & \| \boldsymbol p \|_2 \leq \Delta \end{cases}</script><blockquote>
<p>信赖域方法有几点需要考虑：</p>
<p>(1) <script type="math/tex">\Delta</script>如何确定；(2) <script type="math/tex">m_k(\boldsymbol p)</script>如何选择，误差较大怎么办。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="二-基于线搜索-下降算法基本思路"><a href="#二-基于线搜索-下降算法基本思路" class="headerlink" title="(二) (基于线搜索)下降算法基本思路"></a>(二) (基于线搜索)下降算法基本思路</h5><ul>
<li>STEP1：给定初始点<script type="math/tex">\boldsymbol x_0, k=0</script></li>
<li>STEP2：判断<script type="math/tex">\boldsymbol x_k</script>是否满足终止条件；是则终止</li>
<li>STEP3：否则寻找<script type="math/tex">\boldsymbol x_k</script>处的下降方向<script type="math/tex">\boldsymbol d_k</script></li>
<li>STEP4：设置步长<script type="math/tex">\alpha_k</script>，使得<script type="math/tex">f(\boldsymbol x_{k} + \alpha_k \boldsymbol d_k) < f(\boldsymbol x_{k+1})</script></li>
<li>STEP5：令<script type="math/tex">\boldsymbol x_{k+1} = \boldsymbol x_k + \alpha_k \boldsymbol d_k</script>；令<script type="math/tex">k=k+1</script>，转STEP1。</li>
</ul>
<p><strong>1 终止条件</strong></p>
<p>常用的终止条件：</p>
<script type="math/tex; mode=display">
\| \triangledown f(\boldsymbol x_k) \|_2 \leq \varepsilon</script><p>其中，<script type="math/tex">\varepsilon</script>理论上取0，但在实际编程中一般取一个量级很小的数。此外要注意对与凸函数，此条件一定是最优解，但是非凸函数该终止条件找到的点就不一定是最优解了。</p>
<p>其他终止条件：</p>
<script type="math/tex; mode=display">
\|\boldsymbol x_k - \boldsymbol x_{k-n} \|_2 \leq \varepsilon</script><script type="math/tex; mode=display">
f(\boldsymbol x_k) - f(\boldsymbol x_{k-n}) \leq \varepsilon</script><p><strong>2 下降方向</strong></p>
<p>常用的下降方向——<strong>负梯度方向</strong></p>
<script type="math/tex; mode=display">
\boldsymbol d_k = -\triangledown f(\boldsymbol x_k)</script><p>该方法又称<strong>最速下降法</strong>（Steepest descent）是梯度<strong>下降法</strong>的一种更具体实现形式。</p>
<p>其他下降方向选择：牛顿方向、共轭梯度方向等。</p>
<p><strong>3 步长</strong></p>
<p>令<script type="math/tex">\phi(\alpha) :=  f(\boldsymbol x_{k} + \alpha \boldsymbol d_k)</script>，为一元函数。则可建模为：</p>
<script type="math/tex; mode=display">
\min \text{ }\phi(\alpha)</script><p>在确定$\alpha_k$的过程称为<strong>一维线搜索</strong>。</p>
<p><strong>4 点列收敛性/收敛速度</strong></p>
<p>我们的算法会产生一个点列<script type="math/tex">\begin{Bmatrix} \boldsymbol x_k \end{Bmatrix}_{k=1}^{\infty}</script>，若点列不收敛，则可认为该算法不好。另外，收敛速度越快，算法越好。</p>
<h5 id="三-求解步长——线搜索方法详解"><a href="#三-求解步长——线搜索方法详解" class="headerlink" title="(三) 求解步长——线搜索方法详解"></a>(三) 求解步长——线搜索方法详解</h5><p>求解一元问题：</p>
<script type="math/tex; mode=display">
\begin{cases}\text { min } & \phi(\alpha) :=  f(\boldsymbol x_{k} + \alpha \boldsymbol d_k) \\ 
\text{ s.t.} & \alpha > 0 \end{cases}</script><p>其解记为<script type="math/tex">\alpha^*</script>。</p>
<p><strong>1 <script type="math/tex">f(\boldsymbol x)</script>为一个简单函数</strong></p>
<p>若<script type="math/tex">f(\boldsymbol x)</script>为一个简单函数，如二次函数：<script type="math/tex">f(\boldsymbol x) = \dfrac{1}{2} \boldsymbol x^{\mathrm T} \boldsymbol H \boldsymbol x + \boldsymbol c^{\mathrm T} \boldsymbol x + b, \text{} \boldsymbol H(黑塞矩阵) \succ 0</script>。黑塞矩阵正定则$f$为凸函数，则<script type="math/tex">\phi(\alpha)</script>也是凸函数。代入可得：</p>
<script type="math/tex; mode=display">
\begin{align*}
  \phi(\alpha) & = \dfrac{1}{2} {(\boldsymbol x_{k} + \alpha \boldsymbol d_k)}^{\mathrm T} \boldsymbol H {(\boldsymbol x_{k} + \alpha \boldsymbol d_k)} + \boldsymbol c^{\mathrm T} {(\boldsymbol x_{k} + \alpha \boldsymbol d_k)} + b \\
    &= \dfrac{1}{2} (\boldsymbol d_k^{\mathrm T} \boldsymbol H {\boldsymbol d_k})\alpha^2 +(\boldsymbol d_k^{\mathrm T} \boldsymbol H {\boldsymbol x_k} + \boldsymbol c^{\mathrm T}\boldsymbol d_k) \alpha + b \\
\end{align*}</script><p>对于开口向上的二次函数，求最小，即导数为零即可。</p>
<script type="math/tex; mode=display">
\phi(\alpha)' = 0</script><p><strong>2 <script type="math/tex">f(\boldsymbol x)</script>为一个复杂非线性函数</strong></p>
<p>若<script type="math/tex">f(\boldsymbol x)</script>为一个复杂非线性函数，则<script type="math/tex">\min \phi(\alpha)</script>问题就变得复杂起来了。下面简单介绍几种常见的处理方法：</p>
<ul>
<li><p><strong>基于搜索区间的直接搜索法</strong></p>
<ul>
<li>首先找到一个搜索区间，想办法缩小搜索区间(注意缩小时不用吧$\alpha^*$扔掉)，缩小到一定程度时，则可将区间内的一点作为最优解的近似。</li>
<li>搜索区间<script type="math/tex">[ a_0, b_0]</script>：需要包含<script type="math/tex">\alpha^*</script>；<strong>单谷</strong>(即在搜索区间内，函数只有一个下凸，且要注意以下推导都基于此前提)</li>
<li>方法：选取<script type="math/tex">\lambda, \mu \in (a_0, b_0)</script>且满足<script type="math/tex">\lambda < \mu</script><ul>
<li>若<script type="math/tex">\phi(\lambda) < \phi(\mu)</script>，则得到新的搜索区间为<script type="math/tex">[ a_1, b_1] = [ a_0, \mu]</script></li>
<li>若<script type="math/tex">\phi(\lambda) > \phi(\mu)</script>，则得到新的搜索区间为<script type="math/tex">[ a_1, b_1] = [ \lambda, b_0]</script></li>
</ul>
</li>
<li><strong>常见的直接搜索法：</strong><ul>
<li><strong>均匀搜索法：</strong><ul>
<li>令<script type="math/tex">\delta = (b_0 - a_0)/N, \alpha_i = a_0 + i \delta, \text{ } i=1,2, \cdots, N-1</script></li>
<li>比较相邻3个点对应的函数值，若对于某个<script type="math/tex">i</script>，有<script type="math/tex">\phi(\alpha_{i-1})>\phi(\alpha_i)<\phi(\alpha_{i+1})</script>，则<script type="math/tex">\alpha^* \in [\alpha_{i-1}, \alpha_{i+1}]</script>；</li>
<li>得到新的搜索区间<script type="math/tex">[ a_1, b_1] =  [\alpha_{i-1}, \alpha_{i+1}]</script></li>
</ul>
</li>
<li><strong>黄金区间法(0.618法)：</strong><ul>
<li>令<script type="math/tex">\tau = (\sqrt 5 - 1)/2 =0.618, \text{ }\lambda = a_0 + (1 - \tau)(b_0-a_0), \text{ } \mu = a_0 + \tau (b_0 - a_0)</script></li>
<li>若<script type="math/tex">\phi(\lambda) < \phi(\mu)</script>，则<script type="math/tex">\alpha^* \in [a_0, \mu]</script>，即新的搜索区间；</li>
</ul>
</li>
<li><strong>基于导数信息的二分法</strong><ul>
<li>记区间中点<script type="math/tex">\lambda = \dfrac{b_0+a_0}{2}</script>，计算该点的导数值<script type="math/tex">\phi'(\lambda)</script>；</li>
<li>若<script type="math/tex">\phi'(\lambda) = 0</script>，则<script type="math/tex">\alpha^* = \lambda</script>；</li>
<li>若<script type="math/tex">\phi'(\lambda) < 0</script>，则<script type="math/tex">\alpha^* \in[\lambda, b_0]</script>；</li>
<li>若<script type="math/tex">\phi'(\lambda) > 0</script>，则<script type="math/tex">\alpha^* \in [a_0, \lambda]</script>；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>非精确线搜索</strong></p>
<blockquote>
<p>实际下降算法中，步长的选取除了直接搜索法以外，还有其他一下方法，我们认为只要<script type="math/tex">\alpha</script>满足一定的准则，此时即使<script type="math/tex">\alpha</script>不是精确解也可以作为最终解的近似解。</p>
</blockquote>
<ul>
<li><strong>Armijo条件：</strong><script type="math/tex">\phi(\alpha) \leq \phi(0) + c_1\alpha \phi'(0), \text{ } 0 \leq c_1 \leq 1</script></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/629197cf0947543129174487.jpg" style="zoom:50%"></p>
<ul>
<li><strong>Goldstein法则：</strong>除Armijo条件外还要去<script type="math/tex">\mu</script>满足：<script type="math/tex">\phi(\alpha) > \phi(0) + c_2\alpha \phi'(0), \text{ } 0 \leq c_1 \leq c_2\leq 1</script></li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/629198a00947543129183707.jpg" style="zoom:45%"></p>
<h5 id="四-补充：收敛性"><a href="#四-补充：收敛性" class="headerlink" title="(四) 补充：收敛性"></a>(四) 补充：收敛性</h5><p>基于线搜索的迭代下降算法</p>
<ul>
<li>为保证全局收敛，步长<script type="math/tex">\alpha_k​</script>和下降方向<script type="math/tex">\boldsymbol d_k​</script>的选取均需满足定的条件：<ul>
<li>记当前点<script type="math/tex">\boldsymbol x_k</script>处所选取下降方向<script type="math/tex">\boldsymbol d_k</script>与负梯度方向<script type="math/tex">-\triangledown f(\boldsymbol x_k)</script>的夹角为<script type="math/tex">\theta_k</script>：</li>
<li><script type="math/tex; mode=display">\cos \theta_k = \dfrac{-\triangledown f(\boldsymbol x_k)^{\mathrm T}\boldsymbol d_k}{\|\triangledown f(\boldsymbol x_k) \| \| \boldsymbol d_k\|}</script></li>
<li></li>
</ul>
</li>
</ul>
<p>Zoutendijk定理说明：</p>
<blockquote>
<p>为了保证全局收敛，需要在选取步长和下降方向时候注意满足一定的条件</p>
<p>此外注意区分：全局收敛与收敛到全局最优解的区别</p>
<p>(1) 全局收敛是指在迭代下降算法初始点选取时，任意随机选取初始点都能保证所产生的点列满足收敛性；</p>
<p>(2) 收敛到全局最优解</p>
</blockquote>
<ul>
<li><p>在<strong>适当条件</strong>下，迭代点列<script type="math/tex">\boldsymbol x_k</script>满足：<script type="math/tex">\sum\limits_{k=1}^{\infty} \cos^2 \theta_k \|\triangledown f(\boldsymbol x_k) \|^2 < \infty</script>，点列收敛</p>
</li>
<li><p>当每次选取<script type="math/tex">\boldsymbol d_k</script>时均保证<script type="math/tex">\theta_k</script>满足<script type="math/tex">\cos \theta_k \geq \delta, \delta>0</script>，则：<script type="math/tex">\|\triangledown f(\boldsymbol x_k) \| \to 0</script></p>
<blockquote>
<p>通俗讲就是不要让下降方向<script type="math/tex">\boldsymbol d_k</script>与负梯度方向<script type="math/tex">-\triangledown f(\boldsymbol x_k)</script>的夹角太接近<script type="math/tex">\dfrac{\pi}{2}</script>，夹角尽量小。</p>
</blockquote>
</li>
</ul>
<p>Zoutendijk定理中的适当条件和证明：</p>
<p>假设函数<script type="math/tex">f(\boldsymbol x)</script>有下界(保证有解存在)，且<script type="math/tex">\triangledown f(\boldsymbol x)</script>是Lipschitz连续的，即存在<script type="math/tex">L>0</script>使得：</p>
<script type="math/tex; mode=display">
\|\triangledown f(\boldsymbol x) - \triangledown f(\tilde{\boldsymbol x})  \| \leq L \|\boldsymbol x -  \tilde{\boldsymbol x} \|, \forall \boldsymbol x, \tilde{\boldsymbol x}</script><p>记迭代过程为<script type="math/tex">\boldsymbol x_{k+1} = \boldsymbol x_k + \alpha_k \boldsymbol d_k</script>，则</p>
<script type="math/tex; mode=display">
\sum\limits_{k=1}^{\infty} \cos^2 \theta_k \|\triangledown f(\boldsymbol x_k) \|^2 < \infty</script><p>证明部分没有细看，太复杂了。。。！！！</p>
<blockquote>
<p>此外，这里感觉很难理解，找了一些参考材料，有时间看看吧</p>
<p><a href="https://blog.csdn.net/u010182633/article/details/76554599">漫步最优化二十一——全局收敛</a>、<a href="https://blog.csdn.net/qq_36342854/article/details/103737901">约束优化方法_1_——Zoutendijk可行方向法</a>、<a href="https://zhuanlan.zhihu.com/p/121001066">数值优化|笔记整理（2）——线搜索：步长选取条件的收敛性 - 学弱猹的文章 - 知乎</a></p>
</blockquote>
<h3 id="第六讲-无约束优化问题（贰）"><a href="#第六讲-无约束优化问题（贰）" class="headerlink" title="第六讲 无约束优化问题（贰）"></a>第六讲 无约束优化问题（贰）</h3><p><img src="https://pic.imgdb.cn/item/629311dc09475431290ae7c7.jpg" style="zoom:50%"></p>
<h4 id="6-1-收敛速度"><a href="#6-1-收敛速度" class="headerlink" title="6.1 收敛速度"></a>6.1 收敛速度</h4><p>设序列<script type="math/tex">\begin{Bmatrix} \boldsymbol x_k \end{Bmatrix}_{k=1}^{\infty}</script>收敛到<script type="math/tex">\boldsymbol x^*</script>，若存在极限：</p>
<script type="math/tex; mode=display">
\lim_{k \to \infty} \dfrac{\|\boldsymbol x_{k+1} - \boldsymbol x^* \|}{\|\boldsymbol x_{k} - \boldsymbol x^* \|} = \beta</script><ul>
<li>当<script type="math/tex">0 < \beta < 1</script>时，则称<script type="math/tex">\begin{Bmatrix} \boldsymbol x_k \end{Bmatrix}_{k=1}^{\infty}</script>为线性收敛；</li>
<li>当<script type="math/tex">\beta = 0</script>时，则称<script type="math/tex">\begin{Bmatrix} \boldsymbol x_k \end{Bmatrix}_{k=1}^{\infty}</script>为超线性收敛。</li>
</ul>
<p>若存在某个 <script type="math/tex">p \geq 1</script>，有：</p>
<script type="math/tex; mode=display">
\lim_{k \to \infty} \dfrac{\|\boldsymbol x_{k+1} - \boldsymbol x^* \|}{\|\boldsymbol x_{k} - \boldsymbol x^* \|^p} = \beta < +\infty</script><p>则称<script type="math/tex">\begin{Bmatrix} \boldsymbol x_k \end{Bmatrix}_{k=1}^{\infty}</script>为<script type="math/tex">p</script>阶收敛。当<script type="math/tex">p > 1</script>时，<script type="math/tex">p</script>阶收敛必定为超线性收敛，但反之不一定成立。</p>
<p> 评价一个算法除了收敛速度，还可以考虑把一个算法用于求解一个简单问题，如果该算法在求解简单问题时都会有较大的计算成本，那么说明该算法可能存在问题。一般用<strong>凸二次函数</strong>作为简单问题：</p>
<script type="math/tex; mode=display">
\min \frac{1}{2} \boldsymbol x^{\mathrm T} \boldsymbol Q \boldsymbol x + \boldsymbol c^{\mathrm T} \boldsymbol x,  \boldsymbol Q \succeq 0</script><p>如果算法用于求解该凸二次函数能够在有限步内找到最优解，那么称该算法具有<strong>“二次终止性”</strong>。</p>
<h4 id="6-2-坐标轴交替下降法"><a href="#6-2-坐标轴交替下降法" class="headerlink" title="6.2 坐标轴交替下降法"></a>6.2 坐标轴交替下降法</h4><h5 id="一-基本思想"><a href="#一-基本思想" class="headerlink" title="(一)  基本思想"></a>(一)  基本思想</h5><p>给定初始点<script type="math/tex">\boldsymbol x_0</script>，依次沿着坐标轴<script type="math/tex">\boldsymbol e_1, \boldsymbol e_2, \cdots, \boldsymbol e_n</script>进行搜索。</p>
<h5 id="二-算法框架-流程"><a href="#二-算法框架-流程" class="headerlink" title="(二) 算法框架/流程"></a>(二) 算法框架/流程</h5><ul>
<li><p>STPE 1：给定初始点<script type="math/tex">\boldsymbol x_0, k:=0, \varepsilon>0</script>；</p>
</li>
<li><p>STPE 2：判断是否满足<script type="math/tex">\| \triangledown f(\boldsymbol x_k) \| \leq \varepsilon</script>，是，则终止算法；</p>
</li>
<li><p>STPE 3：记<script type="math/tex">\boldsymbol y_0 = \boldsymbol x_k</script>，令<script type="math/tex">\boldsymbol y_i = \boldsymbol y_{i-1} + \alpha_i \boldsymbol e_i</script></p>
<blockquote>
<p>其中，<script type="math/tex">\alpha_i := \arg \min f(\boldsymbol y_{i-1} + \alpha_i \boldsymbol e_i), i=1,2,\cdots, n</script></p>
<p>arg是argument（自变量、参数）的缩写，那么由此可知：</p>
<p>argmax F(x):使目标函数F(x)能够取到最大值时的变量x的值</p>
<p>argmin F(x):使目标函数F(x)能够取到最小值时的变量x的值</p>
<p>(只是用F(x)举个栗子，实际使用中的函数可能不止x这一个变量，不过意思还是这个意思~)</p>
</blockquote>
</li>
<li><p>STPE4：令<script type="math/tex">\boldsymbol x_{k+1} = \boldsymbol y_n, k:=k+1</script>，转STPE1。</p>
</li>
</ul>
<h5 id="三-优缺点"><a href="#三-优缺点" class="headerlink" title="(三) 优缺点"></a>(三) 优缺点</h5><p>优点：不需要成本即可得到搜索方向。当变量之间的交叉程度较小时非常有效(极端情况——可分离函数)；</p>
<p>缺点：对于一般问题所得到的点列未必收敛。</p>
<h5 id="四-改进方法"><a href="#四-改进方法" class="headerlink" title="(四) 改进方法"></a>(四) 改进方法</h5><p>比如：在交替下降过程中间每一步都加入一个线搜索。</p>
<p><img src="https://pic.imgdb.cn/item/6293758909475431299a817e.jpg" style="zoom:40%"></p>
<h4 id="6-3-梯度下降法-最速下降法"><a href="#6-3-梯度下降法-最速下降法" class="headerlink" title="6.3 梯度下降法(最速下降法)"></a>6.3 梯度下降法(最速下降法)</h4><h5 id="一-基本思想-1"><a href="#一-基本思想-1" class="headerlink" title="(一)  基本思想"></a>(一)  基本思想</h5><p>选择<script type="math/tex">\boldsymbol x_k</script>处负梯度作为搜索方向，即<script type="math/tex">\boldsymbol d_k = - \triangledown f(\boldsymbol x_k)</script>。</p>
<h5 id="二-优缺点"><a href="#二-优缺点" class="headerlink" title="(二) 优缺点"></a>(二) 优缺点</h5><p>优点：简单直观；收敛；搜索方向计算简单(即只需计算梯度)；</p>
<p>缺点：(1) 收敛速度慢(线性收敛)；(2) Zigzag现象(<strong>“之”字形</strong>)；(3) 不具备二次终止性(在有限步内求得凸二次函数的最优解)。</p>
<ul>
<li><p>缺点一：收敛速度慢(线性收敛)</p>
<ul>
<li><p>原因1：只利用了该点处的一阶导数，而没有利用二阶导数信息；</p>
</li>
<li><p>原因2：若迭代中步长<script type="math/tex">\alpha_k</script>是<script type="math/tex">\phi(\alpha):=f(\boldsymbol x_k + \alpha \boldsymbol d_k)</script>的精确最小点，则<script type="math/tex">\phi'(\alpha_k) = 0</script>，即</p>
<script type="math/tex; mode=display">\phi'(\alpha_k) = \triangledown f(\boldsymbol x_k + \alpha_k \boldsymbol d_k)^{\mathrm T}\boldsymbol d_k= -\triangledown f(\boldsymbol x_{k+1}) \triangledown f(\boldsymbol x_k) =  0</script><p>根据上式，可以看到前后两个点之间的<strong>梯度垂直，呈现“之”字形</strong>。示例如下图所示。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/629379520947543129a01147.jpg" style="zoom:40%"></p>
<h4 id="6-4-牛顿法"><a href="#6-4-牛顿法" class="headerlink" title="6.4 牛顿法"></a>6.4 牛顿法</h4><h5 id="一-基本思想-2"><a href="#一-基本思想-2" class="headerlink" title="(一) 基本思想"></a>(一) 基本思想</h5><p>当前点<script type="math/tex">\boldsymbol x_k</script>处选择<script type="math/tex">\boldsymbol d_k = - [\triangledown^2 f(\boldsymbol x_k)]^{-1} \triangledown f(\boldsymbol x_k)</script>作为下降方向，可以理解为：对<script type="math/tex">\boldsymbol x_k</script>处的二次逼近函数(<strong>泰勒展开式</strong>)进行最小化。</p>
<script type="math/tex; mode=display">
\min f(\boldsymbol x_k) + \triangledown f(\boldsymbol x_k)^{\mathrm T}(\boldsymbol x - \boldsymbol x_k) + \frac{1}{2}(\boldsymbol x - \boldsymbol x_k)^{\mathrm T} \triangledown^2 f(\boldsymbol x_k) (\boldsymbol x - \boldsymbol x_k)</script><p>令上式求导等于零，可以得到：</p>
<script type="math/tex; mode=display">
\triangledown f(\boldsymbol x_k) + \triangledown^2 f(\boldsymbol x_k) (\boldsymbol x - \boldsymbol x_k) = \triangledown f(\boldsymbol x_k) + \triangledown^2 f(\boldsymbol x_k)  \boldsymbol d_k = 0</script><ul>
<li><p><strong>纯牛顿法：</strong>步长<script type="math/tex">\alpha_k = 1</script></p>
<blockquote>
<p>因为<script type="math/tex">\boldsymbol d_k = - [\triangledown^2 f(\boldsymbol x_k)]^{-1} \triangledown f(\boldsymbol x_k)  \Longleftrightarrow \boldsymbol x_{k+1} = \boldsymbol x_k - [\triangledown^2 f(\boldsymbol x_k)]^{-1} \triangledown f(\boldsymbol x_k)</script></p>
</blockquote>
</li>
</ul>
<h5 id="二-算法框架-流程-1"><a href="#二-算法框架-流程-1" class="headerlink" title="(二) 算法框架/流程"></a>(二) 算法框架/流程</h5><ul>
<li>STPE 1：给定初始点<script type="math/tex">\boldsymbol x_0, k:=0, \varepsilon>0</script>；</li>
<li>STPE 2：判断是否满足<script type="math/tex">\| \triangledown f(\boldsymbol x_k) \| \leq \varepsilon</script>，是，则终止算法；</li>
<li>STPE 3：计算<script type="math/tex">\boldsymbol d_k = - [\triangledown^2 f(\boldsymbol x_k)]^{-1} \triangledown f(\boldsymbol x_k)</script></li>
<li>STPE4：令<script type="math/tex">\boldsymbol x_{k+1} = \boldsymbol x_{k} + \boldsymbol d_k, k:=k+1</script>，转STPE1。</li>
</ul>
<h5 id="三-优缺点-1"><a href="#三-优缺点-1" class="headerlink" title="(三) 优缺点"></a>(三) 优缺点</h5><p>优点：牛顿法同时考虑了一阶导数信息和和二阶导数信息(<strong>黑塞矩阵</strong>)；当初始点<script type="math/tex">\boldsymbol x_0</script>取得比较接近于收敛点<script type="math/tex">\boldsymbol x^*</script>，且<script type="math/tex">\triangledown^2 f(\boldsymbol x)</script>满足较好性质时，二阶收敛；二次终止性(一步终止)。</p>
<p>缺点：计算量大(需计算Hesse矩阵)；适用范围较窄。</p>
<p>此外，牛顿法还存在一个问题：二阶导数矩阵不一定是正定的，此时<script type="math/tex">\boldsymbol d_k</script>就不一定再是下降方向了。</p>
<p><img src="https://pic.imgdb.cn/item/62937f780947543129a94517.jpg" style="zoom:40%"></p>
<p><img src="https://pic.imgdb.cn/item/629380240947543129aa7197.jpg" style="zoom:40%"></p>
<h4 id="6-5-修正牛顿法"><a href="#6-5-修正牛顿法" class="headerlink" title="6.5 修正牛顿法"></a>6.5 修正牛顿法</h4><ul>
<li><strong>修改点1：步长</strong><ul>
<li>对于步长<script type="math/tex">\alpha_k​</script>的修正：首先判断<script type="math/tex">\alpha_k = 1​</script>是否让目标函数充分下降；否，则采用线搜索方法重新确定<script type="math/tex">\alpha_k​</script>;</li>
</ul>
</li>
<li><strong>修改点2：方向</strong><ul>
<li>对于方向(Hesse矩阵)的修正：选取<script type="math/tex">\boldsymbol d_k = - \boldsymbol B_k^{-1} \triangledown f(\boldsymbol x_k)</script><ul>
<li>若<script type="math/tex">\triangledown^2 f(\boldsymbol x_k) \succ 0</script>，则选取<script type="math/tex">\boldsymbol B_k = \triangledown^2 f(\boldsymbol x_k)</script></li>
<li>否则，采取修正方法(多种)：<ul>
<li><script type="math/tex">\boldsymbol B_k := \triangledown^2 f(\boldsymbol x_k) + \lambda \boldsymbol I</script>，其中，<script type="math/tex">\lambda</script>为适当正数保证<script type="math/tex">\boldsymbol b_k</script>正定。</li>
<li>考虑特征值分解：<script type="math/tex">\triangledown^2 f(\boldsymbol x_k) = \boldsymbol Q^{\mathrm T} \boldsymbol \Lambda \boldsymbol Q</script>，令<script type="math/tex">\boldsymbol b_k = \boldsymbol Q^{\mathrm T} \text{diag} (\tau_i) \boldsymbol Q</script><ul>
<li><script type="math/tex">\tau_{i}= \begin{cases}\lambda_{i}, & \text { if } \lambda_{i} \geq \delta \\ \delta, & \text { otherwise }\end{cases}</script>，其中<script type="math/tex">\delta</script>为一适当正数。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-6-拟牛顿法"><a href="#6-6-拟牛顿法" class="headerlink" title="6.6 拟牛顿法"></a>6.6 拟牛顿法</h4><h5 id="一-基本思想-3"><a href="#一-基本思想-3" class="headerlink" title="(一) 基本思想"></a>(一) 基本思想</h5><p>当前点<script type="math/tex">\boldsymbol x_k</script>处对<script type="math/tex">f(\boldsymbol x_k)</script>使用二次函数进行近似：</p>
<script type="math/tex; mode=display">
m_k(\boldsymbol x) := f(\boldsymbol x_k) + \triangledown f(\boldsymbol x_k)^{\mathrm T}(\boldsymbol x - \boldsymbol x_k) + \frac{1}{2}(\boldsymbol x - \boldsymbol x_k)^{\mathrm T} \boldsymbol B_k (\boldsymbol x - \boldsymbol x_k), \boldsymbol B_k \succ 0</script><p>利用<script type="math/tex">\min m_k(\boldsymbol x)</script>的搜索方向：<script type="math/tex">\boldsymbol d_k = - \boldsymbol B_k^{-1} \triangledown f(\boldsymbol x_k)</script>；我们希望<script type="math/tex">\boldsymbol B_k</script>尽量包含一些二阶信息，然后计算要相对简单。</p>
<p>$\boldsymbol B_k \succ 0$为正定矩阵时，<script type="math/tex">m_k(\boldsymbol x)</script>是一个凸二次函数，求其最小值即可让<script type="math/tex">m_k(\boldsymbol x)</script>的梯度为0即可，求解即可得到：</p>
<script type="math/tex; mode=display">
\boldsymbol x_{k+1} = \boldsymbol x = \boldsymbol x_k - \boldsymbol d_k = \boldsymbol x_k - \boldsymbol B_k^{-1} \triangledown f(\boldsymbol x_k)</script><h5 id="二-算法框架-流程-2"><a href="#二-算法框架-流程-2" class="headerlink" title="(二) 算法框架/流程"></a>(二) 算法框架/流程</h5><ul>
<li>STPE 1：给定初始点<script type="math/tex">\boldsymbol x_0, k:=0, \varepsilon>0, \boldsymbol B_0</script>；</li>
<li>STPE 2：判断是否满足<script type="math/tex">\| \triangledown f(\boldsymbol x_k) \| \leq \varepsilon</script>，是，则终止算法；</li>
<li>STPE 3：计算<script type="math/tex">\boldsymbol d_k = - \boldsymbol B_k^{-1} \triangledown f(\boldsymbol x_k)</script>；</li>
<li>STPE 4：使用线搜索法确定步长<script type="math/tex">\alpha_k</script>；</li>
<li>STPE 5：令<script type="math/tex">\boldsymbol x_{k+1} = \boldsymbol x_{k} + \alpha_k \boldsymbol d_k, k:=k+1</script>，确定<script type="math/tex">\boldsymbol B_{k+1}</script>，转STPE1。</li>
</ul>
<h5 id="三-boldsymbol-B-k-1-矩阵的确定方法"><a href="#三-boldsymbol-B-k-1-矩阵的确定方法" class="headerlink" title="(三) $\boldsymbol B_{k+1}$矩阵的确定方法"></a>(三) $\boldsymbol B_{k+1}$矩阵的确定方法</h5><p><strong>1 拟牛顿方程(基本要求)</strong></p>
<script type="math/tex; mode=display">
\triangledown f(\boldsymbol x_{k+1}) - \triangledown f(\boldsymbol x_k) = \boldsymbol B_{k+1} (\boldsymbol x_{k+1} - \boldsymbol x_{k})</script><blockquote>
<p>对上式的简单理解：</p>
<p>首先由中值定理可得：<script type="math/tex">\triangledown f(\boldsymbol x_{k+1}) - \triangledown f(\boldsymbol x_k) = \triangledown^2 f(\boldsymbol \xi ) (\boldsymbol x_{k+1} - \boldsymbol x_{k}) , \text{ }\xi = \lambda \boldsymbol x_k + (1-\lambda)\boldsymbol x_k, \text{ } \lambda \in (0,1)</script></p>
<p>对比发现：也就是我们希望<script type="math/tex">\boldsymbol B_{k+1}</script>能够体现<script type="math/tex">\triangledown^2 f(\boldsymbol \xi )</script>的作用。</p>
<p>分析易知，<script type="math/tex">\boldsymbol B_{k+1}</script>大小为<script type="math/tex">n \times n</script>，其中变量个数为<script type="math/tex">\dfrac{n(n+1)}{2}</script>(对称阵)，但是等式只要<script type="math/tex">n</script>个方程，因此<script type="math/tex">\boldsymbol B_{k+1}</script>会有<strong>多个</strong>满足条件。</p>
</blockquote>
<p>记<script type="math/tex">\boldsymbol y_k := \triangledown f(\boldsymbol x_{k+1}) - \triangledown f(\boldsymbol x_k)</script>，<script type="math/tex">\boldsymbol s_k := \boldsymbol x_{k+1} - \boldsymbol x_{k}</script>，则拟牛顿方程简记为：</p>
<script type="math/tex; mode=display">
\boldsymbol y_k = \boldsymbol B_{k+1} \boldsymbol s_k</script><p>此外，若记<script type="math/tex">\boldsymbol H_k = \boldsymbol B_k^{-1}</script>，拟牛顿方程也可以表示为：<script type="math/tex">\boldsymbol s_k = \boldsymbol H_{k+1} \boldsymbol y_k</script>。</p>
<p>下面我们将对利用已有信息具体获得<script type="math/tex">\boldsymbol B_{k+1}</script>或者<script type="math/tex">\boldsymbol H_{k+1}</script></p>
<p><strong>2 第一类方法</strong></p>
<p>选择满足拟牛顿方程且与<script type="math/tex">\boldsymbol B_k</script>近似的矩阵。</p>
<script type="math/tex; mode=display">
\begin{cases}\text { min } & \| \boldsymbol B - \boldsymbol B_k \| \\
\text{ s.t. } & \boldsymbol B \boldsymbol s_k = \boldsymbol y_k, \boldsymbol B = \boldsymbol B^T
\end{cases}</script><script type="math/tex; mode=display">
\begin{cases}\text { min } & \| \boldsymbol H - \boldsymbol H_k \| \\
\text{ s.t. } & \boldsymbol H \boldsymbol y_k = \boldsymbol s_k, \boldsymbol H = \boldsymbol H^T
\end{cases}</script><blockquote>
<p>矩阵范数小知识：<a href="https://zhuanlan.zhihu.com/p/35897775">向量范数与矩阵范数</a></p>
</blockquote>
<p><strong>3 第二类方法</strong></p>
<p>对<script type="math/tex">\boldsymbol B_k</script>、<script type="math/tex">\boldsymbol H_k</script>进行校正，如：令<script type="math/tex">\boldsymbol B_{k+1} = \boldsymbol B_k + \Delta \boldsymbol B</script>。</p>
<ul>
<li><p><strong>rank-1</strong>校正：要求<script type="math/tex">\Delta \boldsymbol B</script>的秩为1；</p>
<ul>
<li><p>SR-1方法：可以看作是对<script type="math/tex">\boldsymbol B_k</script>进行rank-1校正</p>
<ul>
<li><script type="math/tex; mode=display">\boldsymbol B_{k+1} = \boldsymbol B_k + \dfrac{(\boldsymbol y_k - \boldsymbol B_k \boldsymbol s_k) (\boldsymbol y_k - \boldsymbol B_k\boldsymbol s_k)^{\mathrm T}}{(\boldsymbol y_k - \boldsymbol B_k \boldsymbol s_k)^{\mathrm T} \boldsymbol s_k}</script></li>
<li><p>如何得到上式：</p>
</li>
<li><p><img src="https://pic.imgdb.cn/item/62941a5d09475431294eec76.jpg" style="zoom:40%"></p>
</li>
<li><p>该方法相对rank-2方法迭代公式更简单，但是不能保证正定性；适当条件下能达到$n$步超线性收敛。</p>
<blockquote>
<p>$n$步超线性收敛：</p>
<script type="math/tex; mode=display">\lim_{k \to \infty} = \dfrac{\| \boldsymbol x_{k+1+n} - \boldsymbol x^* \|}{\boldsymbol x_{k} - \boldsymbol x^*}</script></blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>rank-2</strong>校正：要求<script type="math/tex">\Delta \boldsymbol B</script>的秩为2；</p>
<ul>
<li><strong>DFP方法：</strong>可以看作是对<script type="math/tex">\boldsymbol H_k</script>进行rank-2校正<ul>
<li><script type="math/tex; mode=display">\boldsymbol H_{k+1} = \boldsymbol H_k + \dfrac{\boldsymbol H_k \boldsymbol y_k \boldsymbol y_k^{\mathrm T}\boldsymbol H_k}{\boldsymbol y_k^{\mathrm T}\boldsymbol H_k\boldsymbol y_k} +  \dfrac{\boldsymbol s_k \boldsymbol s_k^{\mathrm T}}{\boldsymbol y_k^{\mathrm T}\boldsymbol s_k}</script></li>
<li>如何得到上式：注意下面图中的证明用到了<strong>对称秩1矩阵<script type="math/tex">\boldsymbol A</script>的性质：</strong><script type="math/tex">\boldsymbol A = \boldsymbol {uv}^T = \boldsymbol {uu}^T</script></li>
<li><img src="https://pic.imgdb.cn/item/629416750947543129494abe.jpg" style="zoom:40%"></li>
</ul>
</li>
<li><strong>BFGS方法：</strong>可以看作是对<script type="math/tex">\boldsymbol B_k</script>进行rank-2校正<ul>
<li><script type="math/tex; mode=display">\boldsymbol B_{k+1} = \boldsymbol B_k + \dfrac{\boldsymbol B_k \boldsymbol s_k \boldsymbol s_k^{\mathrm T}\boldsymbol B_k}{\boldsymbol s_k^{\mathrm T}\boldsymbol B_k\boldsymbol s_k} +  \dfrac{\boldsymbol y_k \boldsymbol y_k^{\mathrm T}}{\boldsymbol y_k^{\mathrm T}\boldsymbol s_k}</script></li>
<li>如何得到上式：原理同上面DFP推导类似。</li>
<li>拟牛顿方向需要计算<script type="math/tex">\boldsymbol B_{k+1}^{-1}</script>，可以利用Sherman-Morrison公式显示写出；</li>
<li>BFGS方法是被认为最有效的拟牛顿法；(适当前提下可证明)超线性收敛。</li>
<li>Broyden族：DFP与BFGS的线性组合！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第七讲-无约束优化问题（叁）"><a href="#第七讲-无约束优化问题（叁）" class="headerlink" title="第七讲 无约束优化问题（叁）"></a>第七讲 无约束优化问题（叁）</h3><h4 id="7-1-共轭梯度法背景"><a href="#7-1-共轭梯度法背景" class="headerlink" title="7.1 共轭梯度法背景"></a>7.1 共轭梯度法背景</h4><p>1950年代，求解一类优化问题中：</p>
<script type="math/tex; mode=display">
\min \dfrac{1}{2} \boldsymbol x^{\mathrm T} \boldsymbol Q \boldsymbol x +  \boldsymbol c^{\mathrm T} \boldsymbol x, \boldsymbol Q \succ 0, \boldsymbol c \in \mathbb{R}^n</script><p>该类问题可直接通过求梯度然后令梯度为零即可：</p>
<script type="math/tex; mode=display">
\triangledown f(\boldsymbol x) = \boldsymbol Q \boldsymbol x + \boldsymbol c = \boldsymbol 0</script><p>可知，需要求解线性方程组。当矩阵比较大时候，计算复杂，因此有人提出使用迭代法求解方程组，因此就有了”(线性)共轭梯度法”。</p>
<p>1960年代，该方法推广到求解一般性优化问题，此时该方法也被称为”(非线性)共轭梯度法”。</p>
<h4 id="7-2-线性共轭梯度法"><a href="#7-2-线性共轭梯度法" class="headerlink" title="7.2 线性共轭梯度法"></a>7.2 线性共轭梯度法</h4><p>考虑以下优化问题：</p>
<script type="math/tex; mode=display">
\min \dfrac{1}{2} \boldsymbol x^{\mathrm T} \boldsymbol Q \boldsymbol x +  \boldsymbol c^{\mathrm T} \boldsymbol x, \boldsymbol Q \succ 0, \boldsymbol c \in \mathbb{R}^n</script><ul>
<li>当<script type="math/tex">\boldsymbol Q</script>特殊一点为对角矩阵时：</li>
</ul>
<script type="math/tex; mode=display">
f(\boldsymbol x) = \dfrac{1}{2} \boldsymbol x^{\mathrm T} \left[\begin{array}{ccc}
q_{1} & \cdots & 0 \\
\vdots & \ddots & 0 \\
0 & 0 & q_{n}
\end{array}\right] \boldsymbol x + \boldsymbol c^{\mathrm T}\boldsymbol x</script><p><img src="https://pic.imgdb.cn/item/629471ce0947543129c41093.jpg" style="zoom:50%"></p>
<ul>
<li>当<script type="math/tex">\boldsymbol Q</script>为一般情况(非对角矩阵)时：</li>
</ul>
<p>拿到一个普通二次型，就要想办法将其转换为标准二次型，即就是只有平方项没有交叉项。常用的方法有线性替换，最常见的线性替换又是：对<script type="math/tex">\boldsymbol Q</script>矩阵进行特征值和特征向量分解：</p>
<script type="math/tex; mode=display">
\boldsymbol Q = \boldsymbol S^{\mathrm T} \boldsymbol \Lambda \boldsymbol S</script><p>其中，<script type="math/tex">\boldsymbol S</script>是由标准正交化之后的特征向量组成。</p>
<p>将<script type="math/tex">\dfrac{1}{2} \boldsymbol x^{\mathrm T} \boldsymbol Q \boldsymbol x +  \boldsymbol c^{\mathrm T} \boldsymbol x</script>中<script type="math/tex">\boldsymbol x</script>用<script type="math/tex">\hat{\boldsymbol x} = \boldsymbol{Sx}</script>进行替换：</p>
<script type="math/tex; mode=display">
f(\hat{\boldsymbol x}) = \dfrac{1}{2} \hat{\boldsymbol x}^{\mathrm T} \boldsymbol \Lambda \hat{\boldsymbol x} +  \boldsymbol{(Sc)}^{\mathrm T} \hat{\boldsymbol x}</script><p>此时就可以像对角矩阵情况类似，求解变得简单。求解得到<script type="math/tex">\hat{\boldsymbol x}^*</script>后即可得到最终解：<script type="math/tex">\boldsymbol x^* = \boldsymbol P^{-1} \hat{\boldsymbol x}^* = \boldsymbol P^{\mathrm T} \hat{\boldsymbol x}^*</script></p>
<p>一定要记住，线性共轭梯度法被设计出来就是用来求解线性方程组。</p>
<h5 id="一-共轭方向"><a href="#一-共轭方向" class="headerlink" title="(一) 共轭方向"></a>(一) 共轭方向</h5><p>考虑正定矩阵<script type="math/tex">\boldsymbol Q</script>和非零向量<script type="math/tex">\boldsymbol d_i, \boldsymbol d_j</script>，若：</p>
<script type="math/tex; mode=display">
\boldsymbol d_i^{\mathrm T} \boldsymbol Q \boldsymbol d_j = \boldsymbol 0</script><p>则称<script type="math/tex">\boldsymbol d_i, \boldsymbol d_j</script>关于矩阵<script type="math/tex">\boldsymbol Q</script>共轭。</p>
<p>向量组<script type="math/tex">\boldsymbol d_0, \boldsymbol d_1, \cdots,  \boldsymbol d_k</script>关于矩阵<script type="math/tex">\boldsymbol Q</script>共轭，两两共轭。</p>
<h5 id="二-共轭-VS-正交"><a href="#二-共轭-VS-正交" class="headerlink" title="(二) 共轭 VS 正交"></a>(二) 共轭 VS 正交</h5><ul>
<li><p>若向量组<script type="math/tex">\boldsymbol d_0, \boldsymbol d_1, \cdots,  \boldsymbol d_k</script>关于<script type="math/tex">\boldsymbol I</script>共轭，则向量组<script type="math/tex">\boldsymbol d_0, \boldsymbol d_1, \cdots,  \boldsymbol d_k</script>是正交向量组；</p>
</li>
<li><p>若向量组<script type="math/tex">\boldsymbol d_0, \boldsymbol d_1, \cdots,  \boldsymbol d_k</script>关于正定矩阵<script type="math/tex">\boldsymbol Q</script>共轭，令<script type="math/tex">\boldsymbol{Q = P}^2</script>，则有：</p>
<ul>
<li><script type="math/tex">\boldsymbol d_i^{\mathrm T} \boldsymbol Q \boldsymbol d_j  = \boldsymbol d_i^{\mathrm T} \boldsymbol P^{\mathrm T} \boldsymbol P \boldsymbol d_j = (\boldsymbol P \boldsymbol d_i)^{\mathrm T}  (\boldsymbol P \boldsymbol d_j) = \boldsymbol 0</script>正交</li>
</ul>
<blockquote>
<p>涉及小知识点：</p>
<p>一个正定矩阵一定能分解为另一个正定矩阵的平方：<script type="math/tex">\boldsymbol{Q = P}^2</script>；</p>
<p>共轭向量组线性无关。</p>
</blockquote>
</li>
</ul>
<h5 id="三-共轭方向法"><a href="#三-共轭方向法" class="headerlink" title="(三) 共轭方向法"></a>(三) 共轭方向法</h5><script type="math/tex; mode=display">
\min \text{ } \dfrac{1}{2} \boldsymbol x^{\mathrm T} \boldsymbol Q \boldsymbol x +  \boldsymbol c^{\mathrm T} \boldsymbol x, \boldsymbol Q \succ 0, \boldsymbol c \in \mathbb{R}^n</script><p>给定初始点<script type="math/tex">\boldsymbol x_0</script>以及一组关于<script type="math/tex">\boldsymbol Q</script>共轭方向<script type="math/tex">\boldsymbol d_0, \boldsymbol d_1, \cdots,  \boldsymbol d_{n-1}</script>，令：</p>
<script type="math/tex; mode=display">
\boldsymbol x_{k+1} := \boldsymbol x_k + \alpha_k \boldsymbol d_k, \text{ } k = 0, 1, \cdots, n-1</script><p>其中，<script type="math/tex">\alpha_k = \arg \min \phi(\alpha) := f(\boldsymbol x_k + \alpha \boldsymbol d_{k})</script>。计算可得<strong>步长</strong>为：</p>
<script type="math/tex; mode=display">
\phi'(\alpha_k) = 0 \Longrightarrow \alpha_k = -\dfrac{(\boldsymbol Q \boldsymbol x_k + \boldsymbol c)^{\mathrm T}\boldsymbol d_k}{\boldsymbol d_k^{\mathrm T}\boldsymbol Q \boldsymbol d_k} = -\dfrac{\triangledown f(\boldsymbol x)^{\mathrm T} \boldsymbol d_k}{\boldsymbol d_k^{\mathrm T}\boldsymbol Q \boldsymbol d_k}</script><p><img src="https://pic.imgdb.cn/item/6294a4bf0947543129090093.jpg" style="zoom:50%"></p>
<p><strong>共轭方向法为一类方法，不同的选取共轭方向的方式就对应不同的共轭方向法，<font color="red">共轭梯度法</font>是其中一种</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/6294a9d909475431290f59c5.jpg" style="zoom:50%"></p>
<h5 id="四-共轭方向法具备的特征"><a href="#四-共轭方向法具备的特征" class="headerlink" title="(四) 共轭方向法具备的特征"></a>(四) 共轭方向法具备的特征</h5><p>以下特征均是基于问题：<script type="math/tex">\min \dfrac{1}{2} \boldsymbol x^{\mathrm T} \boldsymbol Q \boldsymbol x +  \boldsymbol c^{\mathrm T} \boldsymbol x, \boldsymbol Q \succ 0, \boldsymbol c \in \mathbb{R}^n</script></p>
<p>点列<script type="math/tex">\begin{Bmatrix} \boldsymbol x_k \end{Bmatrix}_{k=1}^{\infty}</script>具有如下特征：</p>
<ul>
<li>特征1：<script type="math/tex">\triangledown f(\boldsymbol x_k )^{\mathrm T} \boldsymbol d_i = 0, i = 0, 1, \cdots, k-1</script></li>
<li>特征2：<script type="math/tex">\boldsymbol x_k := \arg \min \begin{Bmatrix} \dfrac{1}{2} \boldsymbol x^{\mathrm T} \boldsymbol Q \boldsymbol x +  \boldsymbol c^{\mathrm T} \boldsymbol x \mid \boldsymbol x \in \boldsymbol X_k \end{Bmatrix}</script><ul>
<li>其中，<script type="math/tex">\boldsymbol X_k =  \begin{Bmatrix} \boldsymbol x_ 0 + \sum\limits_{i=0}^{k-1} a_i \boldsymbol d_i \mid a_i \in \mathbb{R}, i = 1, 2, \cdots, k-1 \end{Bmatrix}</script></li>
</ul>
</li>
</ul>
<p>证明：参考视频。</p>
<h4 id="7-3-共轭梯度法具体"><a href="#7-3-共轭梯度法具体" class="headerlink" title="7.3 共轭梯度法具体"></a>7.3 共轭梯度法具体</h4><h5 id="一-基本思想-4"><a href="#一-基本思想-4" class="headerlink" title="(一)  基本思想"></a>(一)  基本思想</h5><p>在迭代下降过程中，借助当前点<script type="math/tex">\boldsymbol x_k</script>处的梯度信息构造共轭方向。</p>
<h5 id="二-算法框架-流程-3"><a href="#二-算法框架-流程-3" class="headerlink" title="(二) 算法框架/流程"></a>(二) 算法框架/流程</h5><ul>
<li>STPE 1：给定初始点<script type="math/tex">\boldsymbol x_0, k:=0, \varepsilon>0</script>，记<script type="math/tex">\boldsymbol d_0 := -\triangledown f(\boldsymbol x_0)</script></li>
<li>STPE 2：判断是否满足<script type="math/tex">\| \triangledown f(\boldsymbol x_k) \| \leq \varepsilon</script>，是，则终止算法；</li>
<li>STPE 3：计算<script type="math/tex">\alpha_k = -\dfrac{\triangledown f(\boldsymbol x)^{\mathrm T} \boldsymbol d_k}{\boldsymbol d_k^{\mathrm T}\boldsymbol Q \boldsymbol d_k}</script>；</li>
<li>STPE4：令<script type="math/tex">\boldsymbol x_{k+1} = \boldsymbol x_{k} + \alpha_k \boldsymbol d_k</script>，计算方向<script type="math/tex">\boldsymbol d_{k+1} = -\triangledown f(\boldsymbol x_{k+1}) + \text{some-term}</script>，<script type="math/tex">k:=k+1</script>转STPE1。<ul>
<li>其中，<script type="math/tex">\boldsymbol d_{k+1} = -\triangledown f(\boldsymbol x_{k+1}) + \beta_k \boldsymbol d_k</script>，<script type="math/tex">\beta_k  = \dfrac{\triangledown f(\boldsymbol x_{k+1}) \boldsymbol Q \boldsymbol d_k}{\boldsymbol d_k^{\mathrm T}\boldsymbol Q \boldsymbol d_k}</script></li>
</ul>
</li>
</ul>
<h5 id="三-公式简化"><a href="#三-公式简化" class="headerlink" title="(三) 公式简化"></a>(三) 公式简化</h5><p>简化的目的：将这些表达式与目标函数的梯度比较直观地表现出来。</p>
<p>共轭梯度法的步长公式：</p>
<script type="math/tex; mode=display">
\alpha_k = -\dfrac{\triangledown f(\boldsymbol x)^{\mathrm T} \boldsymbol d_k}{\boldsymbol d_k^{\mathrm T}\boldsymbol Q \boldsymbol d_k}</script><p>可简化为：</p>
<script type="math/tex; mode=display">
\alpha_k = \dfrac{\triangledown f(\boldsymbol x)^{\mathrm T}\triangledown f(\boldsymbol x)}{\boldsymbol d_k^{\mathrm T}\boldsymbol Q \boldsymbol d_k}</script><p>共轭梯度法的步长公式中的系数：</p>
<script type="math/tex; mode=display">
\beta_k  = \dfrac{\triangledown f(\boldsymbol x_{k+1}) \boldsymbol Q \boldsymbol d_k}{\boldsymbol d_k^{\mathrm T}\boldsymbol Q \boldsymbol d_k}</script><p>可简化为：</p>
<script type="math/tex; mode=display">
\beta_k  = \dfrac

{\triangledown f(\boldsymbol x_{k+1})^{\mathrm T}[\triangledown f(\boldsymbol x_{k+1}) -  \triangledown f(\boldsymbol x_{k+1})]}

{\triangledown f(\boldsymbol x_k)^{\mathrm T}\triangledown f(\boldsymbol x_k)}</script><p>进一步简化为：</p>
<script type="math/tex; mode=display">
\beta_k  = \dfrac

{\triangledown f(\boldsymbol x_{k+1})^{\mathrm T} \triangledown f(\boldsymbol x_{k+1}) }

{\triangledown f(\boldsymbol x_k)^{\mathrm T}\triangledown f(\boldsymbol x_k)}</script><h4 id="7-4-非线性共轭梯度法"><a href="#7-4-非线性共轭梯度法" class="headerlink" title="7.4 非线性共轭梯度法"></a>7.4 非线性共轭梯度法</h4><p>注意注意注意：上述推导全部是建立在线性共轭梯度法，基本函数是二次函数。</p>
<ul>
<li>STPE 1：给定初始点<script type="math/tex">\boldsymbol x_0, k:=0, \varepsilon>0</script>，记<script type="math/tex">\boldsymbol d_0 := -\triangledown f(\boldsymbol x_0)</script></li>
<li>STPE 2：判断是否满足<script type="math/tex">\| \triangledown f(\boldsymbol x_k) \| \leq \varepsilon</script>，是，则终止算法；</li>
<li>STPE 3：利用线性搜索计算<script type="math/tex">\alpha_k</script>；</li>
<li>STPE4：令<script type="math/tex">\boldsymbol x_{k+1} = \boldsymbol x_{k} + \alpha_k \boldsymbol d_k</script>，计算方向<script type="math/tex">\boldsymbol d_{k+1} = -\triangledown f(\boldsymbol x_{k+1}) + \beta_k \boldsymbol d_k</script>，<script type="math/tex">k:=k+1</script>转STPE1。<ul>
<li>PRP方法：<script type="math/tex">\beta_k  = \dfrac{\triangledown f(\boldsymbol x_{k+1})^{\mathrm T}[\triangledown f(\boldsymbol x_{k+1}) -  \triangledown f(\boldsymbol x_{k+1})]} {\triangledown f(\boldsymbol x_k)^{\mathrm T}\triangledown f(\boldsymbol x_k)}</script></li>
<li>FR方法：<script type="math/tex">\beta_k  = \dfrac{\triangledown f(\boldsymbol x_{k+1})^{\mathrm T} \triangledown f(\boldsymbol x_{k+1}) }{\triangledown f(\boldsymbol x_k)^{\mathrm T}\triangledown f(\boldsymbol x_k)}</script></li>
</ul>
</li>
</ul>
<h4 id="7-5-一些说明"><a href="#7-5-一些说明" class="headerlink" title="7.5 一些说明"></a>7.5 一些说明</h4><ul>
<li><p>在实践中，为保证每次产生的方向为下降方向，可能会对<script type="math/tex">\beta_k</script>进行调整；</p>
</li>
<li><p>具有二次终止性；</p>
</li>
<li><p>实现过程中常采用$n$步重启策略，可达到$n$步二阶收敛；</p>
<blockquote>
<p>n步二阶收敛：<script type="math/tex">\lim\limits_{k \to \infty}\dfrac{\| \boldsymbol x_{k+n} - \boldsymbol x^*\|}{\| \boldsymbol x_{k+n} - \boldsymbol x^*\|^2} = 某一有限值 \gamma</script></p>
</blockquote>
<ul>
<li>原因1：较远的点对当前点贡献很小，可以忽略，因此重启；</li>
<li>原因2：可能会将非线性共轭转变为线性共轭梯度法；</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6294c6a309475431293567f4.jpg" style="zoom:60%"></p>
<h3 id="第八讲-约束优化理论-壹-—最优性条件"><a href="#第八讲-约束优化理论-壹-—最优性条件" class="headerlink" title="第八讲 约束优化理论(壹)—最优性条件"></a>第八讲 约束优化理论(壹)—最优性条件</h3><p>本讲要讨论的约束优化问题为：</p>
<script type="math/tex; mode=display">
(P) \text{ }\begin{cases}\text { min } & f(\boldsymbol x) \\ 
\text{ s.t.} & g_{i}(\boldsymbol x) \leq 0, \text{  } i=1, \cdots, m \\ 
& h_{i}(\boldsymbol x) = 0, \text{  } i=1, \cdots, l\end{cases}</script><p>记问题(P)的可行集为集合<script type="math/tex">\boldsymbol S = \begin{Bmatrix} \boldsymbol x \mid g_{i}(\boldsymbol x) \leq 0, \text{  } i=1, \cdots, m,  h_{i}(\boldsymbol x) = 0, \text{  } i=1, \cdots, l \end{Bmatrix}</script>。</p>
<p>本讲讨论问题的基本假设/前提：</p>
<ul>
<li><p>问题(P)中函数<script type="math/tex">f(\boldsymbol x), g_i(\boldsymbol x), h_i(\boldsymbol x)</script>均为连续可微函数；</p>
<blockquote>
<p>注意，有几类特殊的非光滑函数存在不可微点，但是可以将其转化，例如：</p>
<script type="math/tex; mode=display">f(x) = \max  \begin{Bmatrix} x, x^2 \end{Bmatrix} $$，绘图易知该函数存在两个不可微的点，那么优化问题：</script><p>\min f( x)</p>
<script type="math/tex; mode=display">
可以转化为：令$$t = f(\boldsymbol x) $$：</script><p>\min f( x) \\<br>\Downarrow \\<br>\begin{cases}\text { min } &amp;t \\<br>\text{ s.t.} &amp; f( x) \leq t\end{cases} \\<br>\Downarrow \\<br>\begin{cases}\text { min } &amp;t \\<br>\text{ s.t.} &amp;  x \leq t\\<br>&amp; x^2\leq t\end{cases}<br><script type="math/tex">推广来看：</script>f(x) = \max \begin{Bmatrix} a_i x + b_i \end{Bmatrix}$$这一类函数可以进行转换。</p>
</blockquote>
<p>&gt;</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/629560260947543129c8f1f8.jpg" style="zoom:40%"></p>
<h4 id="8-1-最优解的一阶必要条件-KKT条件"><a href="#8-1-最优解的一阶必要条件-KKT条件" class="headerlink" title="8.1 最优解的一阶必要条件(KKT条件)"></a>8.1 最优解的一阶必要条件(KKT条件)</h4><h5 id="一-KKT条件的内容"><a href="#一-KKT条件的内容" class="headerlink" title="(一) KKT条件的内容"></a>(一) KKT条件的内容</h5><p>假设<script type="math/tex">\boldsymbol x^*</script>是问题(P)的局部最优解，且<script type="math/tex">\boldsymbol x^*</script>处某个“适当条件”成立，则存在<script type="math/tex">\boldsymbol \lambda \in \mathbb{R}^m, \boldsymbol \mu \in \mathbb{R}^l</script>(<script type="math/tex">m</script>是不等式约束个数，<script type="math/tex">l</script>是等式约束个数)使得：</p>
<script type="math/tex; mode=display">
\triangledown f(\boldsymbol x^*) + \sum_{i=1}^{m}\lambda_i \triangledown g_i(\boldsymbol x^*) + \sum_{i=1}^{l} \mu_i \triangledown h_i(\boldsymbol x^*) = 0 \\
\lambda_i > 0, i = 1,2, \cdots, m \\
g_i(\boldsymbol x^*) \leq 0,  i = 1,2, \cdots, m \\
h_i(\boldsymbol x^*) = 0,  i = 1,2, \cdots, l \\
\lambda_i g_i(\boldsymbol x^*) = 0,  i = 1,2, \cdots, m</script><p>其中，以上5个条件就是著名的<strong><font color="red">KKT条件</font></strong>。<script type="math/tex">\lambda_i, \mu_i</script>是两组系数，又称为<font color="blue">“拉格朗日乘子”</font>。</p>
<p>针对非凸问题设计优化算法时，如果能证明算法收敛到一个KKT点，那么就说明算法达到了一个基本要求，<em><u>KKT点相当于无约束优化问题中的梯度为零的作用</u></em>。</p>
<h5 id="二-证明KKT必要条件"><a href="#二-证明KKT必要条件" class="headerlink" title="(二) 证明KKT必要条件"></a>(二) 证明KKT必要条件</h5><p><strong>1 几个概念</strong></p>
<ul>
<li><p>对于<script type="math/tex">\boldsymbol x^* \in \boldsymbol S</script>，若点列<script type="math/tex">\begin{Bmatrix} \boldsymbol x_k \end{Bmatrix} ⊂ \boldsymbol S</script>满足所有<script type="math/tex">\boldsymbol x_k \neq \boldsymbol x^*, \lim\limits_{k \to \infty} \boldsymbol x_k  = \boldsymbol x^*</script>，则称为<strong>可行点列</strong>。</p>
</li>
<li><p>基本思路：若<script type="math/tex">\boldsymbol x^* \in \boldsymbol S</script>是局部最优解，则沿着任意可行点列目标函数不会下降(即当<script type="math/tex">k</script>充分大时，有<script type="math/tex">f(\boldsymbol x_k) > f(\boldsymbol x^*)</script>)。</p>
</li>
<li><p>考虑<script type="math/tex">\boldsymbol x^*</script>处集合<script type="math/tex">\boldsymbol D(\boldsymbol x^*) = \begin{Bmatrix} \boldsymbol d \mid \triangledown f(\boldsymbol x^*)^{\mathrm T} \boldsymbol d < 0 \end{Bmatrix} : \forall \boldsymbol d \in \boldsymbol D</script>均为<script type="math/tex">f(\boldsymbol x_k)</script>是<script type="math/tex">\boldsymbol x^*</script>处的下降方向。</p>
</li>
<li><p>考虑<script type="math/tex">\boldsymbol x^*</script>处集合<script type="math/tex">\boldsymbol T(\boldsymbol x^*) = \begin{Bmatrix} \alpha \boldsymbol d \mid \alpha > 0, \boldsymbol d = \lim\limits_{k \to \infty}\dfrac{\boldsymbol x_k- \boldsymbol x^*}{\| \boldsymbol x_k- \boldsymbol x^* \|} , \boldsymbol x_k \to \boldsymbol x^*, \boldsymbol x_k \neq \boldsymbol x^*, \boldsymbol x_k \in \boldsymbol S \end{Bmatrix}</script>，该集合称为<script type="math/tex">\boldsymbol x^*</script>处的<strong>切锥</strong>。切锥里面包含的方向可以告诉我们：从<script type="math/tex">\boldsymbol x^*</script>点可以验证哪一些方向/曲线可以移动，示意图如下： </p>
<blockquote>
<p><img src="https://pic.imgdb.cn/item/62957f4e0947543129e80269.jpg" style="zoom:40%"></p>
<p>上图中，红色箭头夹住部分为切锥包含的可行方向。</p>
</blockquote>
</li>
</ul>
<p><strong>2 最优解的必要条件</strong></p>
<p>若<script type="math/tex">\boldsymbol x^*</script>是问题(P)的局部最优解，则有：</p>
<script type="math/tex; mode=display">
\boldsymbol D(\boldsymbol x^*) ∩ \boldsymbol T(\boldsymbol x^*) = \boldsymbol \emptyset</script><p>只要证明上述表达式中描述的两个集合交集为空，等价于：任取<script type="math/tex">\alpha \boldsymbol d \in \boldsymbol T(\boldsymbol x^*)</script>，都有<script type="math/tex">\triangledown f(\boldsymbol x^*)^{\mathrm T} \boldsymbol d \geq 0</script></p>
<p><img src="https://pic.imgdb.cn/item/629586160947543129efd126.jpg" style="zoom:50%"></p>
<h5 id="三-与切锥关系紧密的两个集合"><a href="#三-与切锥关系紧密的两个集合" class="headerlink" title="(三) 与切锥关系紧密的两个集合"></a>(三) 与切锥关系紧密的两个集合</h5><ul>
<li><strong>可行方向集合</strong>：<ul>
<li><script type="math/tex; mode=display">\boldsymbol F(\boldsymbol x^*) = \begin{Bmatrix} \boldsymbol d \mid \boldsymbol x^* + \lambda \boldsymbol d \in \boldsymbol S, \forall \lambda \in (0, \delta), \text{ some } \delta > 0 \end{Bmatrix}</script></li>
<li>易知：<script type="math/tex">\boldsymbol F(\boldsymbol x^*) ⊆ \boldsymbol T(\boldsymbol x^*)</script>，即可行方向一定在<strong>切锥</strong>中。</li>
</ul>
</li>
<li><p>集合2：记<script type="math/tex">\boldsymbol x^*</script>处的<strong>有效指标集</strong><script type="math/tex">\boldsymbol I =  \begin{Bmatrix} i \mid g_i(\boldsymbol x^*)=0 \end{Bmatrix}</script>，定义下面集合</p>
<ul>
<li><script type="math/tex; mode=display">\boldsymbol F_1(\boldsymbol x^*) = \begin{Bmatrix} \boldsymbol d \mid \triangledown g_i(\boldsymbol x^*)^{\mathrm T} \boldsymbol d \leq 0, i \in \boldsymbol I, \triangledown h_j(\boldsymbol x^*)^{\mathrm T} \boldsymbol d = 0, j = 1,2,\cdots, l \end{Bmatrix}</script></li>
<li>易知：<script type="math/tex">\boldsymbol T(\boldsymbol x^*) ⊆ \boldsymbol F_1(\boldsymbol x^*)</script></li>
<li>证明：<ul>
<li><img src="https://pic.imgdb.cn/item/629586dc0947543129f0b2bc.jpg" style="zoom:40%"></li>
</ul>
</li>
</ul>
</li>
<li><p>综上：<script type="math/tex">\boldsymbol F(\boldsymbol x^*) ⊆ \boldsymbol T(\boldsymbol x^*) ⊆ \boldsymbol F_1(\boldsymbol x^*)</script></p>
</li>
</ul>
<h5 id="二-适当条件：约束规范-constrain-qualification"><a href="#二-适当条件：约束规范-constrain-qualification" class="headerlink" title="(二) 适当条件：约束规范(constrain qualification)"></a>(二) 适当条件：约束规范(constrain qualification)</h5><p>上文KKT条件描述中提到的<strong>适当条件</strong>就是此处要讨论的<strong>约束规范</strong>。在适当条件(约束规范下)：<script type="math/tex">\boldsymbol T(\boldsymbol x^*) = \boldsymbol F_1(\boldsymbol x^*)</script></p>
<ul>
<li>常用的约束规范有：<ul>
<li>函数——<script type="math/tex">g_i(\boldsymbol x^*), i \in \boldsymbol I, h_j(\boldsymbol x^*), j = 1,2,\cdots, l</script>均为线性函数；</li>
<li>向量组——<script type="math/tex">\triangledown g_i(\boldsymbol x^*), i \in \boldsymbol I, \triangledown h_j(\boldsymbol x^*), j = 1,2,\cdots, l</script>线性无关(LICQ)；</li>
<li>Slater Condition</li>
<li>……</li>
</ul>
</li>
</ul>
<p>若<script type="math/tex">\boldsymbol x^* \in \boldsymbol S</script>是问题(P)的局部最优解，在满足上述某一种约束条件下，有：</p>
<script type="math/tex; mode=display">
\boldsymbol D(\boldsymbol x^*) ∩ \boldsymbol T(\boldsymbol x^*) = \boldsymbol D(\boldsymbol x^*) ∩ \boldsymbol F_1(\boldsymbol x^*) = \boldsymbol \emptyset</script><p>即KKT条件的一种形式。</p>
<p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p>
<p>若<script type="math/tex">\boldsymbol x^* \in \boldsymbol S</script>是问题(P)的局部最优解，在满足上述某一种约束条件下，则KKT条件成立。</p>
<p>因为：根据Farkas引理，<script type="math/tex">\boldsymbol D(\boldsymbol x^*) ∩ \boldsymbol F_1(\boldsymbol x^*) = \boldsymbol \emptyset</script>当且仅当KKT条件成立。</p>
<p>证明：观看视频，太难了。。。</p>
<p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p>
<h4 id="8-2-KKT条件的解释说明"><a href="#8-2-KKT条件的解释说明" class="headerlink" title="8.2 KKT条件的解释说明"></a>8.2 KKT条件的解释说明</h4><h5 id="一-KKT条件中各部分的名字"><a href="#一-KKT条件中各部分的名字" class="headerlink" title="(一) KKT条件中各部分的名字"></a>(一) KKT条件中各部分的名字</h5><script type="math/tex; mode=display">
\triangledown f(\boldsymbol x^*) + \sum_{i=1}^{m}\lambda_i \triangledown g_i(\boldsymbol x^*) + \sum_{i=1}^{l} \mu_i \triangledown h_i(\boldsymbol x^*) = 0 \\
\lambda_i > 0, i = 1,2, \cdots, m \\
g_i(\boldsymbol x^*) \leq 0,  i = 1,2, \cdots, m \\
h_i(\boldsymbol x^*) = 0,  i = 1,2, \cdots, l \\
\lambda_i g_i(\boldsymbol x^*) = 0,  i = 1,2, \cdots, m</script><p>各部分组合的名字如下：</p>
<script type="math/tex; mode=display">
(\text{对偶可行(Dual Feasible, DF)}) \text{ }\begin{cases} & \triangledown f(\boldsymbol x^*) + \sum_{i=1}^{m}\lambda_i \triangledown g_i(\boldsymbol x^*) + \sum_{i=1}^{l} \mu_i \triangledown h_i(\boldsymbol x^*) = 0 \\ 
& \lambda_i > 0, i = 1,2, \cdots, m \end{cases}</script><script type="math/tex; mode=display">
(\text{原问题可行(Primal Feasible, PF)}) \text{ }\begin{cases} & g_i(\boldsymbol x^*) \leq 0,  i = 1,2, \cdots, m \\
& h_i(\boldsymbol x^*) = 0,  i = 1,2, \cdots, l \end{cases}</script><script type="math/tex; mode=display">
(\text{互补松弛条件(Complementary Slack, CS)})  ) \text{ }\begin{cases} & \lambda_i g_i(\boldsymbol x^*) = 0,  i = 1,2, \cdots, m \end{cases}</script><blockquote>
<p>不知道前面有没有说互补松弛的作用：保证那些不起作用的不等式约束在第一行中对应的乘子为零；</p>
<p>传统的互补问题就是：两个向量都是非负的，求内积等于0，其要求为对应分量相乘为0。</p>
</blockquote>
<h5 id="二-KKT条件中拉格朗日乘子意义"><a href="#二-KKT条件中拉格朗日乘子意义" class="headerlink" title="(二) KKT条件中拉格朗日乘子意义"></a>(二) KKT条件中拉格朗日乘子意义</h5><p>KKT条件中拉格朗日乘子可反映约束条件右端项发生扰动时最优目标函数值的变化情况。</p>
<p>设<script type="math/tex">\boldsymbol x^*</script>是问题(P)的局部最优解，且设<script type="math/tex">\boldsymbol x^*</script>满足KKT条件：</p>
<script type="math/tex; mode=display">
(P) \text{ }\begin{cases}\text { min } & f(\boldsymbol x) \\ 
\text{ s.t.} & g_{i}(\boldsymbol x) \leq 0, \text{  } i=1, \cdots, m \\ 
& h_{i}(\boldsymbol x) = 0, \text{  } i=1, \cdots, l\end{cases}</script><h5 id="三-KKT条件充分性"><a href="#三-KKT条件充分性" class="headerlink" title="(三) KKT条件充分性"></a>(三) KKT条件充分性</h5><p>以上好像都是在讨论KKT条件的必要性，即已经知道<script type="math/tex">\boldsymbol x^*</script>是局部最优解，那么在满足某一种约束条件下，KKT条件成立。</p>
<p>但我们也想知道什么时候会变成充分条件，即一个点满足KKT条件，则该点是问题(P)的最优解。</p>
<ul>
<li><p>当问题(P)中满足：</p>
<ul>
<li>(1) <script type="math/tex">f(\boldsymbol x), g_i(\boldsymbol x), i =1,2,\cdots, m</script>均为凸函数；</li>
<li>(2) <script type="math/tex">h_i(\boldsymbol x), i =1,2,\cdots, l</script>为线性函数；</li>
</ul>
</li>
<li><p>则满足条件的KKT点也是问题(P)(此两条条件限制下，问题P就是<strong>凸问题</strong>)的局部(全局)最优解。</p>
<blockquote>
<p>注意2点：</p>
<p>一、凸问题局部最优解即为全局最优解；</p>
<p>二、可能在一些其他问题，不满足上述两条条件(即问题P非凸)，KKT点也有可能是局部最优解，但判断方法需要借助<strong>黑塞矩阵</strong>，下面会讲到。</p>
</blockquote>
</li>
</ul>
<h3 id="第九讲-约束优化理论-贰-—最优性条件—二阶充分条件"><a href="#第九讲-约束优化理论-贰-—最优性条件—二阶充分条件" class="headerlink" title="第九讲 约束优化理论(贰)—最优性条件—二阶充分条件"></a>第九讲 约束优化理论(贰)—最优性条件—二阶充分条件</h3><h4 id="9-1-本讲基础"><a href="#9-1-本讲基础" class="headerlink" title="9.1  本讲基础"></a>9.1  本讲基础</h4><p>由<strong>第八讲(三)KKT条件充分性</strong>部分内容可知：</p>
<ul>
<li>当问题(P)中满足：<ul>
<li>(1) <script type="math/tex">f(\boldsymbol x), g_i(\boldsymbol x), i =1,2,\cdots, m</script>均为凸函数；</li>
<li>(2) <script type="math/tex">h_i(\boldsymbol x), i =1,2,\cdots, l</script>为线性函数；</li>
</ul>
</li>
<li>则满足条件的KKT点也是问题(P)(此两条条件限制下，问题P就是<strong>凸问题</strong>)的局部(全局)最优解。</li>
</ul>
<p>本将要解决的问题是，若通过验证，发现上面的条件(1)或者(2)不满足，那么还有没有什么其他条件说明当<script type="math/tex">\boldsymbol x^*</script>满足KKT条件时，KKT点<script type="math/tex">\boldsymbol x^*</script>是问题(P)的最优解。</p>
<p>假设<script type="math/tex">\boldsymbol x^*</script>满足KKT条件：</p>
<script type="math/tex; mode=display">
\triangledown f(\boldsymbol x^*) + \sum_{i=1}^{m}\lambda_i \triangledown g_i(\boldsymbol x^*) + \sum_{i=1}^{l} \mu_i \triangledown h_i(\boldsymbol x^*) = 0 \\
\lambda_i > 0, i = 1,2, \cdots, m \\
g_i(\boldsymbol x^*) \leq 0,  i = 1,2, \cdots, m \\
h_i(\boldsymbol x^*) = 0,  i = 1,2, \cdots, l \\
\lambda_i g_i(\boldsymbol x^*) = 0,  i = 1,2, \cdots, m</script><p>令：</p>
<script type="math/tex; mode=display">
L(\boldsymbol x) = f(\boldsymbol x) + \sum_{i=1}^{m}\lambda_i g_i(\boldsymbol x) + \sum_{i=1}^{l} \mu_i  h_i(\boldsymbol x)</script><script type="math/tex; mode=display">L(\boldsymbol x)$$称为**<font color=red>拉格朗日函数</font>**。

简单分析$$L(\boldsymbol x)$$可知其具备几个特征：

- **(1) 梯度为0**：$$\triangledown L(\boldsymbol x^*)  = \triangledown f(\boldsymbol x^*) + \sum_{i=1}^{m}\lambda_i \triangledown g_i(\boldsymbol x^*) + \sum_{i=1}^{l} \mu_i \triangledown h_i(\boldsymbol x^*) = 0</script><ul>
<li><strong>(2)</strong>：<script type="math/tex">L(\boldsymbol x^*)  = f(\boldsymbol x^*) + \sum_{i=1}^{m}\lambda_i g_i(\boldsymbol x^*) + \sum_{i=1}^{l} \mu_i h_i(\boldsymbol x^*) = f(\boldsymbol x^*)</script></li>
<li>(3)：<script type="math/tex">L(\boldsymbol x)  = f(\boldsymbol x) + \sum_{i=1}^{m}\lambda_i g_i(\boldsymbol x) + \sum_{i=1}^{l} \mu_i h_i(\boldsymbol x) \leq f(\boldsymbol x), \forall \boldsymbol x \in  \boldsymbol S</script></li>
</ul>
<p>由上面(2)、(3)可知：若<script type="math/tex">\boldsymbol x^*</script>是<script type="math/tex">L(\boldsymbol x)</script>的最优解(局部或者全局最优解都可以)，则<script type="math/tex">\boldsymbol x^*</script>是问题(P)的最优解。</p>
<blockquote>
<p>若<script type="math/tex">\boldsymbol x^*</script>是<script type="math/tex">L(\boldsymbol x)</script>的局部最优解，则<script type="math/tex">\boldsymbol x^*</script>是问题(P)的局部最优解；</p>
<p>若<script type="math/tex">\boldsymbol x^*</script>是<script type="math/tex">L(\boldsymbol x)</script>的全局最优解，则<script type="math/tex">\boldsymbol x^*</script>是问题(P)的全局最优解。</p>
<p>小证明：</p>
<p>局部最优解情况：<script type="math/tex">f(\boldsymbol x^*)  = L(\boldsymbol x^*) = L(\boldsymbol x)  = f(\boldsymbol x), \forall \boldsymbol x \in \boldsymbol S ∩ \boldsymbol N_\delta(\boldsymbol x^*)</script></p>
<p>全局最优解情况：<script type="math/tex">f(\boldsymbol x^*)  = L(\boldsymbol x^*) = L(\boldsymbol x)  = f(\boldsymbol x), \forall \boldsymbol x \in \boldsymbol S</script></p>
</blockquote>
<p>假设<script type="math/tex">\boldsymbol x^*</script>满足KKT条件，则有：</p>
<ul>
<li>(1)：若<script type="math/tex">\triangledown^2 L(\boldsymbol x)  \succeq 0, \forall \boldsymbol x \in \boldsymbol S</script>，则<script type="math/tex">L(\boldsymbol x)</script>在集合<script type="math/tex">\boldsymbol S</script>上是凸函数，则<script type="math/tex">\boldsymbol x^*</script>是问题(P)的全局最优解；</li>
<li>(2)：若<script type="math/tex">\triangledown^2 L(\boldsymbol x)  \succeq 0, \forall \boldsymbol x \in \boldsymbol S ∩ \boldsymbol N_\delta(\boldsymbol x^*)</script>，则<script type="math/tex">L(\boldsymbol x)</script>在上<script type="math/tex">\boldsymbol x^*</script>某一邻域是凸函数，则<script type="math/tex">\boldsymbol x^*</script>是问题(P)的局部最优解；</li>
<li>(3)：若<script type="math/tex">\triangledown^2 L(\boldsymbol x^*)  \succ 0</script>，则<script type="math/tex">\boldsymbol x^*</script>是问题(P)的严格局部最优解；</li>
</ul>
<blockquote>
<p>视频课程中这里有一部分分析推导，有时间记录</p>
</blockquote>
<h4 id="9-2-二阶充分条件"><a href="#9-2-二阶充分条件" class="headerlink" title="9.2 二阶充分条件"></a>9.2 二阶充分条件</h4><p>下面是本讲内容的核心：</p>
<h5 id="一-二阶充分条件定义"><a href="#一-二阶充分条件定义" class="headerlink" title="(一) 二阶充分条件定义"></a>(一) 二阶充分条件定义</h5><p>假设<script type="math/tex">\boldsymbol x^*</script>是KKT点，易知：</p>
<ul>
<li><script type="math/tex; mode=display">\triangledown L(\boldsymbol x^*)  = 0</script></li>
<li><script type="math/tex; mode=display">\boldsymbol d^T \triangledown^2 L(\boldsymbol x^*) \boldsymbol d > 0, \forall \boldsymbol d \in F_2(\boldsymbol x^*)</script></li>
</ul>
<p>则<script type="math/tex">\boldsymbol x^*</script>是问题(P)的严格局部最优解。</p>
<h5 id="二-证明"><a href="#二-证明" class="headerlink" title="(二) 证明"></a>(二) 证明</h5><p>反证：假设<script type="math/tex">\boldsymbol x^*​</script>是KKT点，但<script type="math/tex">\boldsymbol x^*​</script>不是问题(P)的严格局部最优解。则能找到一个点<script type="math/tex">\boldsymbol x_k \to \boldsymbol x^* ​</script>，使得：</p>
<script type="math/tex; mode=display">
f(\boldsymbol x_k) \leq f(\boldsymbol x^*), \forall \boldsymbol x_k \in \boldsymbol S</script><p>记<script type="math/tex">\boldsymbol d_k = \dfrac{\boldsymbol x_k- \boldsymbol x^*}{\| \boldsymbol x_k- \boldsymbol x^* \|}</script>，<script type="math/tex">\alpha_k = {\| \boldsymbol x_k- \boldsymbol x^* \|}</script>，则会得到两个点列：<script type="math/tex">\begin{Bmatrix} \boldsymbol d_k \end{Bmatrix}</script>，<script type="math/tex">\begin{Bmatrix} \alpha_k \end{Bmatrix}</script>，易得：</p>
<ul>
<li>因为<script type="math/tex">\boldsymbol x_k \to \boldsymbol x^*</script>，因此<script type="math/tex">\begin{Bmatrix} \alpha_k \end{Bmatrix} \to 0</script></li>
<li><script type="math/tex; mode=display">\begin{Bmatrix} \boldsymbol d_k \end{Bmatrix}$$是有界的，因此必然存在收敛子列，设最终$$\begin{Bmatrix} \boldsymbol d_k \end{Bmatrix} \to \boldsymbol d</script></li>
</ul>
<p>则有：<script type="math/tex">\boldsymbol x_k = \boldsymbol x^* + \alpha_k \boldsymbol d_k</script>，</p>
<script type="math/tex; mode=display">
f(\boldsymbol x_k) - f(\boldsymbol x^*) \xlongequal{泰勒展开} \triangledown f(\boldsymbol x^*)^{\mathrm T}(\boldsymbol x_k - \boldsymbol x^*) +\dfrac{\alpha_k^2}{2} \boldsymbol d_k^{\mathrm T}\triangledown f(\boldsymbol x^*)\boldsymbol d_k+\text{o}(\alpha_k^2) \\= \alpha_k \triangledown f(\boldsymbol x^*)^{\mathrm T} \boldsymbol d_k +\dfrac{\alpha_k^2}{2} \boldsymbol d_k^{\mathrm T}\triangledown f(\boldsymbol x^*)\boldsymbol d_k+\text{o}(\alpha_k^2) \leq 0</script><script type="math/tex; mode=display">
g_i(\boldsymbol x_k) - g_i(\boldsymbol x^*) \xlongequal{泰勒展开} \triangledown g_i(\boldsymbol x^*)^{\mathrm T}(\boldsymbol x_k - \boldsymbol x^*) +\dfrac{\alpha_k^2}{2} \boldsymbol d_k^{\mathrm T}\triangledown g_i(\boldsymbol x^*)\boldsymbol d_k+\text{o}(\alpha_k^2) \\= \alpha_k \triangledown g_i(\boldsymbol x^*)^{\mathrm T} \boldsymbol d_k +\dfrac{\alpha_k^2}{2} \boldsymbol d_k^{\mathrm T}\triangledown g_i(\boldsymbol x^*)\boldsymbol d_k+\text{o}(\alpha_k^2) \leq 0</script><script type="math/tex; mode=display">
h_i(\boldsymbol x_k) - h_i(\boldsymbol x^*) \xlongequal{泰勒展开} \triangledown h_i(\boldsymbol x^*)^{\mathrm T}(\boldsymbol x_k - \boldsymbol x^*) +\dfrac{\alpha_k^2}{2} \boldsymbol d_k^{\mathrm T}\triangledown h_i(\boldsymbol x^*)\boldsymbol d_k+\text{o}(\alpha_k^2) \\= \alpha_k \triangledown h_i(\boldsymbol x^*)^{\mathrm T} \boldsymbol d_k +\dfrac{\alpha_k^2}{2} \boldsymbol d_k^{\mathrm T}\triangledown h_i(\boldsymbol x^*)\boldsymbol d_k+\text{o}(\alpha_k^2) = 0</script><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>数学基础</category>
        <category>最优化方法</category>
      </categories>
      <tags>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title>先验概率与后验概率</title>
    <url>/2022/01/22/Prior-and-Posterior-Probabilities/</url>
    <content><![CDATA[<h4 id="1-先验概率"><a href="#1-先验概率" class="headerlink" title="1. 先验概率"></a>1. 先验概率</h4><p>事情还没有发生，根据以往的经验来判断事情发生的概率，是“由因求果”。(根据统计和规律得出得概率 )</p>
<blockquote>
<p>扔一个硬币，在扔之前就知道正面向上的概率为0.5。这是根据我们之前的经验得到的。这个0.5就是先验概率。</p>
</blockquote>
<h4 id="2-后验概率"><a href="#2-后验概率" class="headerlink" title="2. 后验概率"></a>2. 后验概率</h4><p>事情已发生，有多种原因，判断事情的发生是由哪一种原因引起的，是“由果求因”。(根据贝叶斯公式可以得到) </p>
<blockquote>
<p>今天上学迟到了，有两个原因，一个是自行车坏了，一个是生病了。后验概率就是根据结果（迟到）来计算原因（生病/自行车坏了）的概率。</p>
</blockquote>
<p><strong><font color="red"> 数学表达上，后验概率和条件概率有相同的形式</font></strong></p>
<p><strong><font color="red">贝叶斯公式就是由先验概率求后验概率的公式</font></strong></p>
<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>先验概率是对某一件事情发生可能性的预先客观评估，而后验概率是对事情发生是由某一个原因导致的概率。</p>
<p>先验概率是以全事件为背景下A事件发生的概率$P(A|\Omega)$，后验概率是以新事件B为背景下A事件发生的概率$P(A|B)$全事件一般是统计获得的，所以称为先验概率，没有实验前的概率。新事件一般是实验，如试验B，此时的事件背景从全事件变成了B，该事件B可能对A的概率有影响，那么需要对A现在的概率进行一个修正，从$P(A|Ω)$变成$P(A|B)$，所以称 $P(A|B)$为后验概率，也就是试验(事件B发生)后的概率。</p>
<p>后验概率分布是条件概率的一个例子。 后验概率告诉我们，在我们观察到一组特定数据的情况下，参数值的可能性有多大。 当然，条件概率不需要描述参数和数据，所以后验概率是条件概率的一个特例。</p>
<h4 id="4-补充-条件概率与后验概率"><a href="#4-补充-条件概率与后验概率" class="headerlink" title="4. 补充-条件概率与后验概率"></a>4. 补充-条件概率与后验概率</h4><p>后验概率就是一种条件概率，但是与其它条件概率的不同之处在于，它限定了目标事件为隐变量取值，而其中的条件为观测结果。 一般的条件概率，条件和事件都可以是任意的。</p>
<p><strong>举例区分普通条件概率与后验概率的区别</strong>：</p>
<blockquote>
<p>1）那么如果我们出门之前我们听到新闻说今天路上出了个交通事故，那么我们想算一下堵车的概率，这个就叫做条件概率 。也就是P(堵车|交通事故)。这是有因求果。</p>
<p>2）如果我们已经出了门，然后遇到了堵车，那么我们想算一下堵车时由交通事故引起的概率有多大，那这个就叫做后验概率 （其实也是条件概率，但是通常习惯这么说） 。也就是P(交通事故|堵车)。这是有果求因。</p>
</blockquote>
<p> 从上述例子可知道，后验概率就是在已知某B事件发生的情况下，求解其中A事件发生的概率是多少，而A事件正是B事件发生的一个隐状态事件，所以A与B是有前后关联的。在利用贝叶斯进行文本分类的时候也是这个意思：</p>
<script type="math/tex; mode=display">
P(\frac{c}{d})=\frac{p(\frac{d}{c})p(c)}{p(d)}</script><p>d文档分为c类的概率，$p(c)$就是先验概率，$p(c/d)$就是后验概率，所以贝叶斯就是用先验概率估计后验概率。</p>
<p>而一般的条件概率，目标事件A和条件事件B，是可以没有任何关系的。</p>
<hr>
<p>概率论老师说：</p>
<p>A的概率——$P(A)$</p>
<p>A在条件C下的概率——$P(A|C)$</p>
<p>统计学老师说：</p>
<p>A事件发生的先验概率——$P(A)$</p>
<p>知道C事件发生后，A事件发生的后验概率——$P(A|C)$</p>
<p><strong>小结</strong></p>
<p>条件概率和后验概率理论上是没区别，唯一的区别在于后验概率来自后验概率分布上。后验概率按理应该是在贝叶斯推论框架下，在这个框架下，必须将后验概率分布和后验概率结合来看。</p>
<p>综上，后验概率是贝叶斯推论中的概念，而条件概率在频率学派和贝叶斯学派中都有使用，注意这两个学派的区别后，应该能能理解这两者的区别。</p>
<h4 id="相关链接："><a href="#相关链接：" class="headerlink" title="相关链接："></a>相关链接：</h4><p>参考链接1：<a href="https://www.zhihu.com/question/20587681">贝叶斯学派与频率学派有何不同？ - 知乎</a></p>
<p>参考链接2：<a href="https://zhuanlan.zhihu.com/p/27006631">用贝叶斯 计算后验概率(一) - 住奥马哈的张校长的文章 - 知乎</a></p>
<p>参考链接3：<a href="https://www.zhihu.com/question/27398304">贝叶斯推断如何更新后验概率？ - 知乎</a></p>
<p>参考链接4：<a href="https://blog.csdn.net/FWing/article/details/4850068?utm_source=app&amp;app_version=5.0.0">概率与似然 - CSDN</a> </p>
<p>参考链接5：<a href="https://blog.csdn.net/songyu0120/article/details/85059149?utm_source=app&amp;app_version=5.0.0">似然(likelihood)和概率(probability)的区别与联系 - CSDN</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>数学基础</category>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>概率基础系统学习</title>
    <url>/2022/02/12/Probabilistic-Basic-Systems-Learning/</url>
    <content><![CDATA[<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1ot411y7mU" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/0ccbc2307d31f9fe6d0877ac025a729333823ed8.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">70:26:57</span>
            </div>
            <div class="bvideo-info">
                <p class="title">《概率论与数理统计》教学视频全集（宋浩）</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>5010.0万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>106.7万</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">宋浩老师官方</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<h2 id="第一章-随机事件及其概率"><a href="#第一章-随机事件及其概率" class="headerlink" title="第一章 随机事件及其概率"></a>第一章 随机事件及其概率</h2><h3 id="1-1-随机事件"><a href="#1-1-随机事件" class="headerlink" title="1.1 随机事件"></a>1.1 随机事件</h3><h4 id="1-1-1-随机试验与随机事件"><a href="#1-1-1-随机试验与随机事件" class="headerlink" title="1.1.1 随机试验与随机事件"></a>1.1.1 随机试验与随机事件</h4><ul>
<li><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5></li>
</ul>
<p><strong>随机实验：</strong>① 在相同条件下可重复；② 实验结果不只有一个；③ 无法预测。</p>
<p><strong>事件：</strong>随机实验的每一种结果就称为一个事件。</p>
<p><strong>基本事件：</strong>相对于实验目的不可以再分的事件称为基本事件。</p>
<p><strong>复合事件：</strong>几个基本事件的复合。</p>
<p><strong>必然事件：</strong>一定会发生的事件，使用符号$\Omega$表示(全集)。</p>
<p><strong>不可能事件：</strong>一定不会发生的事件，使用符号$\phi$表示(空集)。</p>
<h4 id="1-1-2-样本空间与事件的集合表示"><a href="#1-1-2-样本空间与事件的集合表示" class="headerlink" title="1.1.2 样本空间与事件的集合表示"></a>1.1.2 样本空间与事件的集合表示</h4><ul>
<li><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5></li>
</ul>
<p><strong>样本空间：</strong>所有基本事件的集合，用$\Omega$表示(把样本点是看作一个整体，就可以说样本空间在每次试验中都出现了，因而<strong>样本空间是随机试验的必然事件</strong> )</p>
<p><strong>样本点：</strong>样本空间的元素，使用$\omega$表示。</p>
<h4 id="1-1-3-事件间的关系"><a href="#1-1-3-事件间的关系" class="headerlink" title="1.1.3 事件间的关系"></a>1.1.3 事件间的关系</h4><h5 id="一、事件之间的关系"><a href="#一、事件之间的关系" class="headerlink" title="一、事件之间的关系"></a>一、事件之间的关系</h5><p>1、包含——$\boldsymbol {\subseteq}$</p>
<p>$A \subseteq B$：A发生必然导致B发生。</p>
<p>一定存在的包含关系：$\phi \subseteq A \subseteq \Omega$</p>
<p>2、相等——$\boldsymbol  =$</p>
<p>$A = B$：A事件和B事件相等，即$A \subseteq  B$ AND $B \subseteq A$。</p>
<p>3、并/和——$\boldsymbol  \cup $</p>
<p>$A \cup B = A+B$：A、B中至少有一个发生。</p>
<p>4、交/积——$\boldsymbol \cap$</p>
<p>$A \cap B = AB$：A、B同时发生。</p>
<p>5、差——$\boldsymbol  -$</p>
<p>$A-B$：A发生而B不发生。</p>
<p>$A - B = A - AB = A \bar B$</p>
<p>6、互不相容事件</p>
<p>$AB = \phi$：A、B不会同时发生。</p>
<p>7、对立事件</p>
<p>$A = \bar B$：A、B互不相容$AB = \phi$，且$A \cup B = \Omega$。</p>
<p>8、完备事件组</p>
<p>$A_1,A_2,…,A_n$两两互不相容，且$\bigcup\limits_{i=1}^n = \Omega$</p>
<h5 id="二、集合的运算关系"><a href="#二、集合的运算关系" class="headerlink" title="二、集合的运算关系"></a>二、集合的运算关系</h5><p>1、交换律：$A \cup B = B \cup A$，$A \cap B = B \cap A$</p>
<p>2、结合律：$(A \cup B) \cup C = A \cup (B \cup C)$，$(A \cap B) \cap C = A \cap (B \cap C)$</p>
<p>3、分配率：$(A\cup B) \cap C = (A \cap C) \cup (B \cap C)$，$(A \cap B) \cup C = (A \cup C) \cap (B \cup C)$</p>
<p>4、对偶率：$\overline{A \cup B} = \bar A \cap \bar B$，$\overline{A \cap B} = \bar A \cup \bar B$</p>
<p>$\overline{A_1 \cup A_2 \cup \cdots \cup A_n} = \bar A_1 \cap \bar A_2 \cap \cdots \cap A_n$，$\overline{A_1 \cap A_2 \cap \cdots \cap A_n} = \bar A_1 \cup \bar A_2 \cup \cdots \cup A_n$</p>
<h3 id="1-2-事件的概率"><a href="#1-2-事件的概率" class="headerlink" title="1.2 事件的概率"></a>1.2 事件的概率</h3><h4 id="1-2-1-概率的初等描述"><a href="#1-2-1-概率的初等描述" class="headerlink" title="1.2.1 概率的初等描述"></a>1.2.1 概率的初等描述</h4><p><strong>概率：</strong>随机事件出现的可能性大小。 常用$P(A)$ 表示A事件出现的概率。</p>
<h4 id="1-2-2-古典概率模型"><a href="#1-2-2-古典概率模型" class="headerlink" title="1.2.2 古典概率模型"></a>1.2.2 古典概率模型</h4><h5 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h5><p>古典概率模型要求：有限个样本点(e.g. 掷一枚骰子只有有六种可能)且所有样本点出现的可能性是<strong>相等的</strong>，则古典概率中事件A的概率为：</p>
<script type="math/tex; mode=display">
P(A) = \frac{A中包含的基本事件个数}{\Omega中包含的基本事件个数}</script><h5 id="二、排列组合的基础知识"><a href="#二、排列组合的基础知识" class="headerlink" title="二、排列组合的基础知识"></a>二、排列组合的基础知识</h5><p>……</p>
<h5 id="三、古典概率模型的性质"><a href="#三、古典概率模型的性质" class="headerlink" title="三、古典概率模型的性质"></a>三、古典概率模型的性质</h5><p>1、非负性：$0 \leq P(A) \leq 1$；</p>
<p>2、规范性：$P(\Omega) = 1，P(\phi) = 0$；</p>
<p>3、有限可加：$A_1, A_2, \cdots ,A_n $互不相容，则有$P(A_1+A_2+ \cdots +A_n) = P(A_1)+P(A_2)+ \cdots +P(A_n) $；</p>
<h4 id="1-2-3-几何概率模型"><a href="#1-2-3-几何概率模型" class="headerlink" title="1.2.3 几何概率模型"></a>1.2.3 几何概率模型</h4><h5 id="一、定义-1"><a href="#一、定义-1" class="headerlink" title="一、定义"></a>一、定义</h5><p>几何概型是一种概率模型。在这个模型下，随机实验所有可能的结果是无限的，并且每个基本结果发生的概率是相同的。例如一个人到单位的时间可能是8:00~9:00之间的任意一个时刻；往一个方格中投一个石子，石子落在方格中任何一点上……这些试验出现的结果都是无限多个，属于几何概型。一个试验是否为几何概型在于这个试验是否具有几何概型的两个特征——无限性和等可能性，只有同时具备这两个特点的概型才是几何概型。 </p>
<h5 id="二、性质"><a href="#二、性质" class="headerlink" title="二、性质"></a>二、性质</h5><p>1、完全可加性：<script type="math/tex">A_1, A_2, \cdots ,A_n</script>互不相容，则有<script type="math/tex">P(\bigcup\limits_{i=1}^{\infty}A_i) = \sum\limits_{i=1}^{\infty}A_i</script>；</p>
<h5 id="三、古典概率模型与几何概率模型的区别"><a href="#三、古典概率模型与几何概率模型的区别" class="headerlink" title="三、古典概率模型与几何概率模型的区别"></a>三、古典概率模型与几何概率模型的区别</h5><p>古典概型的基本事件都是有限的，概率为事件所包含的基本事件除以总基本事件个数。 几何概型的基本事件通常不可计数，只能通过一定的测度，像长度，面积，体积的的比值来表示。 </p>
<h5 id="四、随机模拟-蒙特卡洛法："><a href="#四、随机模拟-蒙特卡洛法：" class="headerlink" title="四、随机模拟/蒙特卡洛法："></a>四、随机模拟/蒙特卡洛法：</h5><p>1、基本思想</p>
<p>蒙特卡罗方法是一种计算方法。原理是通过大量随机样本，去了解一个系统，进而得到所要计算的值。 </p>
<p>蒙特卡洛法的基本思想是：为了求解问题，首先建立一个概率模型或随机过程，使它的参数或数字特征等于问题的解；然后通过对模型或过程的观察或抽样试验来计算这些参数或数字特征，最后给出所求解的近似值。解的精确度用估计值的标准误差来表示。蒙特卡洛法的主要理论基础是概率统计理论，主要手段是随机抽样、统计试验。 </p>
<p>2、求解问题的基本步骤 </p>
<ul>
<li>根据实际问题的特点，构造简单而又便于实现的概率统计模型，使所求的解恰好是所求问题的概率分布或数学期望；</li>
<li>给出模型中各种不同分布随机变量的抽样方法；</li>
<li>统计处理模拟结果，给出问题解的统计估计值和精度估计值。</li>
</ul>
<p>3、例子：$\pi$的计算</p>
<p>正方形内部有一个相切的圆，它们的面积之比是$\dfrac{\pi}{4}$。 </p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9naW1nL2Fzc2V0LzIwMTUvYmcyMDE1MDcyNjExLmpwZw?x-oss-process=image/format,png" style="zoom:70%"></p>
<p>现在，在这个正方形内部，随机产生10000个点（即10000个坐标对 (x, y)），计算它们与中心点的距离，从而判断是否落在圆的内部。 </p>
<p><img src="https://pic.imgdb.cn/item/620cb0fe2ab3f51d910c4f91.jpg" style="zoom:40%"></p>
<p>如果这些点均匀分布，那么圆内的点应该占到所有点的$\dfrac{\pi}{4}$，因此将这个比值乘以4，就是π的值。通过R语言脚本随机模拟30000个点，π的估算值与真实值相差0.07%。 </p>
<h4 id="1-2-4-频率与概率"><a href="#1-2-4-频率与概率" class="headerlink" title="1.2.4 频率与概率"></a>1.2.4 频率与概率</h4><h5 id="一、频率"><a href="#一、频率" class="headerlink" title="一、频率"></a>一、频率</h5><p>1、定义：做了n次实验，事件A发生了m次，则定义频率为$\omega_n(A) = \dfrac{m}{n}$。</p>
<p>2、性质：</p>
<ul>
<li>非负性——$0 \leq \omega_n(A) \leq 1$；</li>
<li>规范性——$\omega_n(必然事件) = \omega_n(\Omega) = 1$，$\omega_n(不可能事件) = \omega_n(\phi) = 0$；</li>
<li>可加性——设事件$A_1, \cdots, A_k$两两互不相容，则有$\omega_n(A_1 + \cdots +A_k) = \omega_n(A_1)+\cdots + \omega_n(A_k)$；</li>
</ul>
<h5 id="二、概率"><a href="#二、概率" class="headerlink" title="二、概率"></a>二、概率</h5><p>(PS：这里主要是讲频率与概率的关系)</p>
<p>概率可以视为事件的一个属性，先于实验而存在，不随实验的变换而变化，随着实验次数的增加，频率逐渐接近概率。</p>
<h4 id="1-2-5-概率的公理化"><a href="#1-2-5-概率的公理化" class="headerlink" title="1.2.5 概率的公理化"></a>1.2.5 概率的公理化</h4><h5 id="一、概率的定义方法"><a href="#一、概率的定义方法" class="headerlink" title="一、概率的定义方法"></a>一、概率的定义方法</h5><p>描述概率定义、古典概率定义、几何概率定义、统计概率定义</p>
<p>以上这四种定义的概率都有公共的3种性质：① 非负性；② 规范性；③ 可加性；</p>
<h5 id="二、概率的公理化定义"><a href="#二、概率的公理化定义" class="headerlink" title="二、概率的公理化定义"></a>二、概率的公理化定义</h5><p>1、首先提炼出3条公理</p>
<p><strong>公理1(非负性)：</strong>$0 \leq P(A) \leq 1$</p>
<p><strong>公理2(规范性)：</strong>$P(\Omega) = 1$，注意——公理2中没有定义$P(\phi) = 0$</p>
<p><strong>公理3(完全可加性)：</strong>若事件$A_1, A_2, \cdots $不相容，则$P(A_1+A_2+ \cdots) = P(A_1)+P(A_2)+ \cdots$</p>
<blockquote>
<p><strong>可加性性质：有限可加性，可列可加性，完全可加性</strong></p>
<p>其中：可列可加性=完全可加性</p>
<p>可列可加性的理解可能要深入<strong>测度论</strong>的学习</p>
</blockquote>
<p>2、从3条公理推导其他性质</p>
<p><strong>性质1：</strong>$P(\phi) = 0$</p>
<blockquote>
<p>证明：将$\Omega$写为$\Omega = \Omega + \phi + \phi + \phi + \cdots$，易知它们之间互不相容，则有<br>$P(\Omega) = P(\Omega + \phi + \phi + \phi + \cdots) = P(\Omega) + P(\phi) + P(\phi) + \cdots$<br>两边同时减去$P(\Omega)$，则有$0 = P(\phi) + P(\phi) + \cdots$<br>又知$0 \leq P(A) \leq 1$，故$P(\phi) = 0$，得证！</p>
</blockquote>
<p><strong>性质2：</strong>有限可加性——本性质说明完全可加性可以推出有限可加性</p>
<p>若事件$A_1, A_2, \cdots ,A_n$不相容，则$P(A_1+A_2+ \cdots +A_n) = P(A_1)+P(A_2)+ \cdots + P(A_n)$</p>
<blockquote>
<p>证明：$A_1, A_2, \cdots, A_n, \phi + \phi + \phi + \cdots$，易知它们之间互不相容，则有<br>$P(A_1 + A_2 + \cdots + A_n) = P(A_1 + A_2 + \cdots + A_n + \phi + \phi + \phi + \cdots) = P(A_1) + P(A_2) + \cdots + P(A_n)+P(\phi) + P(\phi) + \cdots$<br>又由性质1可知$P(\phi) = 0$，则有$P(A_1 + A_2 + \cdots + A_n) =P(A_1) + P(A_2) + \cdots + P(A_n)$</p>
</blockquote>
<p><strong>性质3：</strong>$P(\bar A) = 1 - P(A)$</p>
<p><strong>性质4：</strong></p>
<p>—— ① $P(A-B) = P(A) - P(AB)$</p>
<p>—— ② $B \subset A, P(A-B) = P(A) - P(B) ,且P(A) \geq P(B)$</p>
<blockquote>
<p>证明①：易知$A = (A-B) \cup AB$，$A-B$与$AB$是互不相容的，则有<br>$P(A) = P(A-B) + P(AB)$，移项得证。</p>
<p>证明②：略</p>
</blockquote>
<p><strong>性质5(加法性质)：</strong>$P(A + B) = P(A) + P(B) - P(AB)$</p>
<blockquote>
<p>证明：略</p>
</blockquote>
<h3 id="1-3-条件概率与乘法公式"><a href="#1-3-条件概率与乘法公式" class="headerlink" title="1.3 条件概率与乘法公式"></a>1.3 条件概率与乘法公式</h3><h4 id="1-3-1-条件概率"><a href="#1-3-1-条件概率" class="headerlink" title="1.3.1 条件概率"></a>1.3.1 条件概率</h4><h5 id="一、定义-2"><a href="#一、定义-2" class="headerlink" title="一、定义"></a>一、定义</h5><p>样本空间为$\Omega$，A、B两个事件，$P(B) &gt; 0$，在B已经发生的条件下A发生的概率叫做A对B的条件概率，记为：$P(A|B)$</p>
<h5 id="二、计算"><a href="#二、计算" class="headerlink" title="二、计算"></a>二、计算</h5><p>$P(A|B) = \dfrac{P(AB)}{P(B)}$</p>
<h4 id="1-3-2-乘法公式"><a href="#1-3-2-乘法公式" class="headerlink" title="1.3.2 乘法公式"></a>1.3.2 乘法公式</h4><p>由条件概率可以推导得：</p>
<p>$P(AB) = P(B)P(A|B) = P(A)P(B|A)$</p>
<p><strong>推广：</strong><script type="math/tex">P(A_1 A_2 \cdots A_n) = P(A_1)P(A_2|A_1)P(A_3|A_1 A_2) \cdots P(A_n | A_1 A_2 \cdots A_{n-1})</script></p>
<h3 id="1-4-全概率公式与贝叶斯公式"><a href="#1-4-全概率公式与贝叶斯公式" class="headerlink" title="1.4 全概率公式与贝叶斯公式"></a>1.4 全概率公式与贝叶斯公式</h3><h4 id="1-4-1-全概率公式"><a href="#1-4-1-全概率公式" class="headerlink" title="1.4.1 全概率公式"></a>1.4.1 全概率公式</h4><h5 id="一、定义-3"><a href="#一、定义-3" class="headerlink" title="一、定义"></a>一、定义</h5><p>假设$A_1, A_2, \cdots, A_n$是实验E的完备事件组(实际中不一定是完备的，只要能把事件B全部包括进去就行)，则对于某一事件B有：</p>
<script type="math/tex; mode=display">
P(B) = \sum_{i=1}^{n}P(A_i)P(B|A_i)</script><p><img src="https://pic.imgdb.cn/item/620f368d2ab3f51d919636fb.jpg" style="zoom:40%"></p>
<h4 id="1-4-2-贝叶斯公式"><a href="#1-4-2-贝叶斯公式" class="headerlink" title="1.4.2 贝叶斯公式"></a>1.4.2 贝叶斯公式</h4><h5 id="一、定义-4"><a href="#一、定义-4" class="headerlink" title="一、定义"></a>一、定义</h5><p>假设$A_1, A_2, \cdots, A_n$是实验E的完备事件组，则对于某一事件B有：</p>
<script type="math/tex; mode=display">
P(A_k | B) = \frac{P(A_k B)}{P(B)} = \frac{P(A_k B)的乘法公式}{P(B)的全概率公式} = \frac{P(A_k)P(B|A_k)}{\sum\limits_{i = 1}^{n}P(A_i)P(B|A_i)}</script><p>其中，$P(A_i)$称为<font color="red"><strong>先验概率</strong></font>，$P(A_i | B)$称为<font color="red"><strong>后验概率</strong></font> </p>
<h5 id="二、与全概率公式的辨析"><a href="#二、与全概率公式的辨析" class="headerlink" title="二、与全概率公式的辨析"></a>二、与全概率公式的辨析</h5><p>全概率公式是<font color="red"><strong>由因求果</strong></font></p>
<p>贝叶斯公式是<font color="red"><strong>由果溯因</strong></font></p>
<h3 id="1-5-事件的独立性与伯努利概型"><a href="#1-5-事件的独立性与伯努利概型" class="headerlink" title="1.5 事件的独立性与伯努利概型"></a>1.5 事件的独立性与伯努利概型</h3><h4 id="1-5-1-事件的独立性"><a href="#1-5-1-事件的独立性" class="headerlink" title="1.5.1 事件的独立性"></a>1.5.1 事件的独立性</h4><h5 id="一、定义-5"><a href="#一、定义-5" class="headerlink" title="一、定义"></a>一、定义</h5><p>A事件发生的概率不受B事件发生与否的影响，用公式可以表述为：$P(A|B) = P(A)$，或者说：</p>
<script type="math/tex; mode=display">
P(AB) = P(A)P(B)</script><p><strong>推论：</strong></p>
<p>① $\phi,\Omega$与任意事件均独立；</p>
<p>② 若A与B相互独立，则$\bar A 与 B$、$A 与 \bar B$、$\bar A 与 \bar B$也相互独立；</p>
<p>③ 若事件A满足$P(A) = 0 或 P(A) = 1$，则事件A与任意事件都独立；(注意：事件的概率等于0或者1不一定就是空集$\phi$或者全集$\Omega$) </p>
<p>证明略。。。</p>
<h5 id="二、独立与互不相容-互斥-辨析"><a href="#二、独立与互不相容-互斥-辨析" class="headerlink" title="二、独立与互不相容(互斥)辨析"></a>二、独立与互不相容(互斥)辨析</h5><p>1、从定义来讲：</p>
<p>A与B不相容，是$P(AB) = \phi$</p>
<p>A与B独立，是$P(AB) = P(A)P(B)$</p>
<p>2、通俗来讲：</p>
<p>A、B不相容是A发生了，B就一定不能发生，反之亦然；</p>
<p>A、B相互独立是A是否发生并不影响事件A发生的概率，所以A发生了B也可能会发生。 </p>
<p>3、推论：</p>
<p>当$P(A) &gt; 0$、$P(B) &gt; 0$时，互不相容与独立不会同时发生。</p>
<h5 id="三、补充知识——对立"><a href="#三、补充知识——对立" class="headerlink" title="三、补充知识——对立"></a>三、补充知识——对立</h5><p>最后再说一下对立事件，对立是指A、B必然发生一个且仅有一个发生，比如今天下雨或者不下雨，<strong>对立一定互不相容(互斥)，但是互不相容不一定对立</strong></p>
<h4 id="1-5-2-伯努利模型"><a href="#1-5-2-伯努利模型" class="headerlink" title="1.5.2 伯努利模型"></a>1.5.2 伯努利模型</h4><h5 id="一、几个相关概念"><a href="#一、几个相关概念" class="headerlink" title="一、几个相关概念"></a>一、几个相关概念</h5><p>1、独立实验序列：实验$E_1,E_2, \cdots, E_n$相互独立；</p>
<p>2、N重独立实验：把一个实验做N次，每次都是相互独立的；</p>
<p>3、伯努利实验：实验结果只有两种的实验(e.g. 硬币的正反)</p>
<p>4、N重伯努利实验：重复做N次实验，每次实验都相互独立，且实验的结果只有两种的实验。</p>
<h5 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h5><p>在伯努利实验模型中，事件A发生的概率是$P$，则$\bar A$的概率为$1-P$，那么在N重伯努利实验中，事件A发生k次的概率为：</p>
<script type="math/tex; mode=display">
P_N(k) = C_N^k P^k (1-P)^{N-k}</script><p>上面的公式又称为二项概率公式。</p>
<h2 id="第二章-随机变量及其分布"><a href="#第二章-随机变量及其分布" class="headerlink" title="第二章 随机变量及其分布"></a>第二章 随机变量及其分布</h2><h3 id="2-1-随机变量的概念"><a href="#2-1-随机变量的概念" class="headerlink" title="2.1 随机变量的概念"></a>2.1 随机变量的概念</h3><h5 id="一、定义-6"><a href="#一、定义-6" class="headerlink" title="一、定义"></a>一、定义</h5><p><strong><font color="red">重点：随机变量的本质是函数——样本点的函数</font></strong></p>
<p>设$X(w)$是定义在概率空间$(\Omega, \mathscr{F}, P)$上的单值实函数(也就是说它的自变量就是一个个的样本点，因变量是实函数)，如果对直线上任意一博雷尔点集$B$，有$\begin{Bmatrix} \omega, X(\omega) \in B \end{Bmatrix} \subset \mathscr{F}$则称$X(\omega)$为随机变量(r.v.)。</p>
<h5 id="二、表示"><a href="#二、表示" class="headerlink" title="二、表示"></a>二、表示</h5><p>有了随机变量的概念，我们就可以将一个事件表示为：$\begin{Bmatrix} \omega | X(\omega) = a \end{Bmatrix}$，简记为$\begin{Bmatrix} X = a \end{Bmatrix}$，此时事件的概率可表示为：</p>
<script type="math/tex; mode=display">
P(X=a)</script><p>为了理解其本质，我将上面的简写形式的完整形式写在下面：</p>
<script type="math/tex; mode=display">
P(X=a) = P(\begin{Bmatrix} \omega | X(\omega) = a \end{Bmatrix})</script><h5 id="三、分类"><a href="#三、分类" class="headerlink" title="三、分类"></a>三、分类</h5><p>1、离散型随机变量：变量是离散的，且满足<strong>个数有限</strong>或者<strong>无限但可列</strong>；</p>
<p>2、连续性随机变量：变量是连续的。</p>
<h3 id="2-2-随机变量的分布"><a href="#2-2-随机变量的分布" class="headerlink" title="2.2 随机变量的分布"></a>2.2 随机变量的分布</h3><h4 id="2-2-1-离散型随机变量及其概率分布"><a href="#2-2-1-离散型随机变量及其概率分布" class="headerlink" title="2.2.1 离散型随机变量及其概率分布"></a>2.2.1 离散型随机变量及其概率分布</h4><h5 id="一、定义-7"><a href="#一、定义-7" class="headerlink" title="一、定义"></a>一、定义</h5><p>离散随机变量X的取值为$x_k(k = 1,2, \cdots)$，其概率为$P(X = x_k) = p_k$，则其称为随机变量的概率分布。</p>
<h4 id="2-2-2-连续型随机变量及其概率密度函数"><a href="#2-2-2-连续型随机变量及其概率密度函数" class="headerlink" title="2.2.2 连续型随机变量及其概率密度函数"></a>2.2.2 连续型随机变量及其概率密度函数</h4><p>关于概率分布与概率密度的具体细节，参见自己的博客文章<strong>“概率基础概念本质的辨析理解_三、概率函数P(x)、概率分布函数F(x)、概率密度函数f(x)”部分</strong></p>
<h4 id="2-2-3-随机变量的分布函数"><a href="#2-2-3-随机变量的分布函数" class="headerlink" title="2.2.3 随机变量的分布函数"></a>2.2.3 随机变量的分布函数</h4><p>关于概率分布与概率密度的具体细节，参见自己的博客文章<strong>“概率基础概念本质的辨析理解_三、概率函数P(x)、概率分布函数F(x)、概率密度函数f(x)”部分</strong></p>
<h3 id="2-3-常见随机变量的分布"><a href="#2-3-常见随机变量的分布" class="headerlink" title="2.3 常见随机变量的分布"></a>2.3 常见随机变量的分布</h3><h4 id="2-3-1-常见离散型随机变量的分布"><a href="#2-3-1-常见离散型随机变量的分布" class="headerlink" title="2.3.1 常见离散型随机变量的分布"></a>2.3.1 常见离散型随机变量的分布</h4><h5 id="一、0-1分布"><a href="#一、0-1分布" class="headerlink" title="一、0-1分布"></a>一、0-1分布</h5><p>0-1分布是指随机变量X的取值只有0或1，其用公式表示为：</p>
<script type="math/tex; mode=display">
P(X = k) = p^k (1-p)^{1-k},(k = 0, 1)</script><h5 id="二、几何分布"><a href="#二、几何分布" class="headerlink" title="二、几何分布"></a>二、几何分布</h5><p>设事件A的发生概率是$P(A) = p$，则重复做实验，在第k次的时候<strong>A首次发生</strong>的概率即为几何分布，记为$X \sim G(p)$</p>
<script type="math/tex; mode=display">
P(X=k) = (1-p)^{k-1}p</script><h5 id="三、二项分布"><a href="#三、二项分布" class="headerlink" title="三、二项分布"></a>三、二项分布</h5><p>设事件A的发生概率是$P(A) = p$，则重复做n次实验事件A发生k次的概率即为二项分布，记为$X \sim B(n, p)$</p>
<script type="math/tex; mode=display">
P(X = k) = C_n^k p^k (1-p)^{n-k}</script><h5 id="四、泊松分布"><a href="#四、泊松分布" class="headerlink" title="四、泊松分布"></a>四、泊松分布</h5><p>假设在一定时间间隔 (interval)中一个事件可能会发生0,1,2,…次，在一个间隔中平均发生事件的次数由$λ$决定，  $\lambda$ 是事件发生比率 (event rate)。在一定时间间隔中发生k次事件的概率如下，记为$X \sim P(\lambda)$</p>
<script type="math/tex; mode=display">
P(X=k) = \frac{\lambda^k}{k!}e^{-\lambda},(\lambda > 0, k = 0,1,2,\cdots)</script><p><strong>泊松定理：</strong>n重伯努利实验中，如果$n→\infty，np→\lambda$。</p>
<ul>
<li><strong>二项分布可以用泊松分布来近似</strong><ul>
<li>条件：当二项分布中n比较大，p比较小，np的值适中，则可以用泊松分布来近似计算二项分布；</li>
<li>具体：$n \geq 100, np \leq 10$，此时泊松分布中$\lambda = np$。</li>
</ul>
</li>
</ul>
<h5 id="五、超几何分布"><a href="#五、超几何分布" class="headerlink" title="五、超几何分布"></a>五、超几何分布</h5><p>假设N个元素，其中$N_1$个属于第一类，$N_2$个属于第二类，那么从中任意取n个则其中属于第一类的个数为k的概率为超几何分布，</p>
<script type="math/tex; mode=display">
P(X = k) = \frac{C_{N_1}^k C_{N_2}^{n-k}}{C_N^n},(k = 0,1,2, \cdots, \min \begin{Bmatrix} n, N_1 \end{Bmatrix})</script><blockquote>
<p>① 超几何分布有一个比较明显的特征：<strong>实验只有两种情况/两类</strong>；</p>
<p>② 超几何分布可以用来描述不放回抽样实验；</p>
<p>③ 当不放回抽样中总体数量巨大，抽出的数量相对于总体数量远远小于，则超几何分布可以使用二项分布来近似</p>
</blockquote>
<h5 id="六、均匀分布"><a href="#六、均匀分布" class="headerlink" title="六、均匀分布"></a>六、均匀分布</h5><p> 定义式为：</p>
<script type="math/tex; mode=display">
f(x)=\left\{
\begin{aligned}
\frac{1}{b-a}, &a \leq x \leq b \\
0, &x<a,x>b
\end{aligned}
\right.</script><p>记为$X \sim U[a, b]$，其分布函数为：</p>
<script type="math/tex; mode=display">
F(x) = \left\{
\begin{aligned}
0, &x<a \\
\frac{x-a}{b-a}, &a \leq x \leq b \\
1, &x>b
\end{aligned}
\right.</script><h5 id="七、指数分布"><a href="#七、指数分布" class="headerlink" title="七、指数分布"></a>七、指数分布</h5><p>定义式为：</p>
<script type="math/tex; mode=display">
f(x)=\left\{
\begin{aligned}
\lambda e^{-\lambda x}, &x > 0 \\
0, &x \leq 0
\end{aligned}
\right.</script><p>其中$\lambda &gt; 0$，记为$X \sim \text{Exp}(\lambda)$，其分布函数为：</p>
<script type="math/tex; mode=display">
F(x) = \left\{
\begin{aligned}
1-e^{-\lambda x}, &x>0 \\
0, &x \leq 0
\end{aligned}
\right.</script><p>指数分布有一个特性：<strong>无记忆性</strong></p>
<script type="math/tex; mode=display">
P(X>s+t|X>s) = P(X>t),s>0,t>0</script><h5 id="八、正态分布"><a href="#八、正态分布" class="headerlink" title="八、正态分布"></a>八、正态分布</h5><p>定义式为：</p>
<script type="math/tex; mode=display">
\phi(x) = \frac{1}{\sqrt{2 \pi} \sigma} e^{-\frac{(x- \mu)^2}{2 \sigma^2}}, -\infty < x < \infty</script><p>记为$X \sim N(\mu, \sigma^2)$，其分布函数为：</p>
<script type="math/tex; mode=display">
\Phi(x) = \frac{1}{\sqrt{2\pi}\sigma}\int_{-\infty}^x e^{-\frac{(t- \mu)^2}{2 \sigma^2}}dt</script><ul>
<li><strong>正态分布的性质：</strong><ul>
<li>① 其密度函数$\phi(x)$是以$x = \mu$为对称轴，且在$x = \mu$处取得最大值；</li>
<li>② 其密度函数$\phi(x)$是以x轴为渐近线；</li>
<li>③ $\sigma$固定$\mu$变化，则$\phi(x)$左右移动，$\mu$固定$\sigma$变化，则$\phi(x)$窄宽变化；</li>
</ul>
</li>
</ul>
<p><strong>标准正太分布</strong>：$\mu = 0, \sigma = 1$，其密度函数$\phi_0(x)$为：</p>
<script type="math/tex; mode=display">
\phi_0(x) = \frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}, -\infty < x < \infty</script><p>记为$X \sim N(0,1)$，其分布函数$\Phi_0(x)$为：</p>
<script type="math/tex; mode=display">
\Phi(x) = \frac{1}{\sqrt{2\pi}}\int_{-\infty}^x e^{-\frac{t^2}{2}}dt</script><p>一个一般的正态分布转换为标准正态分布：$x \to \dfrac{x-\mu}{\sigma}$。</p>
<h4 id="2-3-2-随机变量函数的分布"><a href="#2-3-2-随机变量函数的分布" class="headerlink" title="2.3.2 随机变量函数的分布"></a>2.3.2 随机变量<font color="red">函数</font>的分布</h4><p>本节要研究的内容可以简单概况为——已知X是某分布，求Y = aX+b的分布。</p>
<h5 id="一、离散型"><a href="#一、离散型" class="headerlink" title="一、离散型"></a>一、离散型</h5><h5 id="二、连续型"><a href="#二、连续型" class="headerlink" title="二、连续型"></a>二、连续型</h5><p>设X的概率密度为$f_X(x)​$，令$Y = g(X)​$，求Y的密度函数$f_Y(x)​$。求解方法步骤：</p>
<ul>
<li>① $F_Y(x) \to F_X(x)$</li>
<li>② $f_Y(x) \leftarrow f_X(x)$</li>
</ul>
<h2 id="第三章-多维随机变量及其分布"><a href="#第三章-多维随机变量及其分布" class="headerlink" title="第三章 多维随机变量及其分布"></a>第三章 多维随机变量及其分布</h2><h3 id="3-1-二维随机变量"><a href="#3-1-二维随机变量" class="headerlink" title="3.1 二维随机变量"></a>3.1 二维随机变量</h3><h4 id="3-1-1-二维随机变量及其分布函数"><a href="#3-1-1-二维随机变量及其分布函数" class="headerlink" title="3.1.1 二维随机变量及其分布函数"></a>3.1.1 二维随机变量及其分布函数</h4><h5 id="一、二维随机变量定义"><a href="#一、二维随机变量定义" class="headerlink" title="一、二维随机变量定义"></a>一、二维随机变量定义</h5><p>实验E的样本空间为$\Omega$，X、Y是$\Omega$内的两个变量，则称$(X,Y)$为二维随机变量。</p>
<h5 id="二、二维随机变量的分布函数"><a href="#二、二维随机变量的分布函数" class="headerlink" title="二、二维随机变量的分布函数"></a>二、二维随机变量的分布函数</h5><p>1、定义</p>
<p>二维随机变量$(X,Y)$的联合分布函数为：</p>
<script type="math/tex; mode=display">
F(X,Y) = P(X \leq x , Y \leq y)</script><p>2、性质</p>
<h5 id="三、边缘分布"><a href="#三、边缘分布" class="headerlink" title="三、边缘分布"></a>三、边缘分布</h5><p>1、定义</p>
<p>X的边缘分布为：</p>
<script type="math/tex; mode=display">
F_X(x) = P(X \leq x) = F(x, +\infty) = P(X \leq x, Y<+\infty)</script><p>Y的边缘分布为：</p>
<script type="math/tex; mode=display">
F_Y(y) = P(Y \leq y) = F(+\infty, y) = P(X \leq +\infty, Y \leq y)</script><h4 id="3-1-2-二维离散型随机变量的联合概率分布及其边缘概率分布"><a href="#3-1-2-二维离散型随机变量的联合概率分布及其边缘概率分布" class="headerlink" title="3.1.2 二维离散型随机变量的联合概率分布及其边缘概率分布"></a>3.1.2 二维离散型随机变量的联合概率分布及其边缘概率分布</h4><h5 id="一、定义-8"><a href="#一、定义-8" class="headerlink" title="一、定义"></a>一、定义</h5><p>设$(X,Y)$的所有可能的取值为$(x_i, y_j)$，则称</p>
<script type="math/tex; mode=display">
P(X = x_i, Y = y_j) = p_{ij}</script><p>为二维离散型随机变量的联合概率分布。</p>
<h5 id="二、联合概率分布函数"><a href="#二、联合概率分布函数" class="headerlink" title="二、联合概率分布函数"></a>二、联合概率分布函数</h5><p>由定义可知：</p>
<script type="math/tex; mode=display">
F(x,y) = P(X \leq x, Y \leq y) = \sum\limits_{x_i \leq x}\sum\limits_{y_j \leq y}p_{ij}</script><h5 id="三、边缘分布-1"><a href="#三、边缘分布-1" class="headerlink" title="三、边缘分布"></a>三、边缘分布</h5><p>离散型随机变量X ,Y的概率分布,称为随机向量$(X, Y)$的边缘概率分布。</p>
<p>X和Y的边缘分布，就是一维随机变量X和Y的分布，之所以称其为边缘分布是相对于$(X,Y)$的联合分布而言的。</p>
<script type="math/tex; mode=display">
P(X = x_i) = P(X = x_i, -\infty \leq Y \leq \infty) = \sum\limits_j p_{ij}</script><h4 id="3-1-3-二维连续型的联合概率密度函数及边缘概率密度函数"><a href="#3-1-3-二维连续型的联合概率密度函数及边缘概率密度函数" class="headerlink" title="3.1.3 二维连续型的联合概率密度函数及边缘概率密度函数"></a>3.1.3 二维连续型的联合概率密度函数及边缘概率密度函数</h4><h5 id="一、联合概率分布"><a href="#一、联合概率分布" class="headerlink" title="一、联合概率分布"></a>一、联合概率分布</h5><p>由概率分布的定义易知：</p>
<script type="math/tex; mode=display">
F(x, y) = P(X \leq x, Y \leq y) = \int_{-\infty}^x \int_{-\infty}^y f(s , t)dsdt</script><p>称$F(x,y)$为二维连续型随机的联合概率分布，式中，我们定义其联合概率密度函数为$f(x,y)$，即$F(x, y)$与$f(x,y)$的关系为：</p>
<script type="math/tex; mode=display">
f(x, y) = \frac{\partial^2 F(x,y)}{\partial x \partial y}</script><h5 id="二、边缘分布"><a href="#二、边缘分布" class="headerlink" title="二、边缘分布"></a>二、边缘分布</h5><p>由定义易知：</p>
<script type="math/tex; mode=display">
F_X(x) = \lim_{y \to \infty} F(x, y)</script><script type="math/tex; mode=display">
F_Y(y) = \lim_{x \to \infty} F(x, y)</script><h5 id="三、边缘密度函数"><a href="#三、边缘密度函数" class="headerlink" title="三、边缘密度函数"></a>三、边缘密度函数</h5><p>由上一节可知，二维连续型随机变量的边缘分布：</p>
<script type="math/tex; mode=display">
F_X(x) = F(x, \infty) = \int_{-\infty}^x \int_{-\infty}^{\infty} f(s, t)ds dt</script><p>则边缘密度函数就是边缘分布的导数：</p>
<script type="math/tex; mode=display">
f_X(x) = \int_{-\infty}^{\infty} f(x ,t) dt = \int_{-\infty}^{\infty} f(x ,y) dy</script><script type="math/tex; mode=display">
f_Y(y) = \int_{-\infty}^{\infty} f(s ,y) dy = \int_{-\infty}^{\infty} f(x ,y) dx</script><blockquote>
<p><strong>补充：变上限积分求导</strong></p>
<p>$\int_a^{f(x)} g(t)dt = g(f(x)) ×\dfrac{d}{dx}f(x)$</p>
</blockquote>
<p>二维正态分布的边缘分布也是正态分布；两个边缘分布是正太的，其二维随机变量并不一定是正态分布。</p>
<h3 id="3-2-条件分布与随机变量的独立性"><a href="#3-2-条件分布与随机变量的独立性" class="headerlink" title="3.2 条件分布与随机变量的独立性"></a>3.2 条件分布与随机变量的独立性</h3><h4 id="3-2-1-条件分布的概念"><a href="#3-2-1-条件分布的概念" class="headerlink" title="3.2.1 条件分布的概念"></a>3.2.1 条件分布的概念</h4><h5 id="一、定义-9"><a href="#一、定义-9" class="headerlink" title="一、定义"></a>一、定义</h5><p>条件分布是指在事件A发生的条件下随机变量的分布：</p>
<script type="math/tex; mode=display">
F(x | A) = P(X \leq x | A)</script><h4 id="3-2-2-离散型随机变量条件分布"><a href="#3-2-2-离散型随机变量条件分布" class="headerlink" title="3.2.2 离散型随机变量条件分布"></a>3.2.2 离散型随机变量条件分布</h4><h5 id="一、定义式"><a href="#一、定义式" class="headerlink" title="一、定义式"></a>一、定义式</h5><script type="math/tex; mode=display">
P(X = x_i | Y = y_i) = \frac{p_{ij}}{p_j^{(2)}}</script><h4 id="3-2-3-连续型随机变量条件分布"><a href="#3-2-3-连续型随机变量条件分布" class="headerlink" title="3.2.3 连续型随机变量条件分布"></a>3.2.3 连续型随机变量条件分布</h4><h5 id="一、定义-10"><a href="#一、定义-10" class="headerlink" title="一、定义"></a>一、定义</h5><p>二维随机变量$(X, Y)$，其联合概率密度函数为$f(x, y)$，边缘分布为$f_X(x),f_Y(y)$，在$Y = y$的条件下，其条件分布：</p>
<script type="math/tex; mode=display">
F(x | y) = \int_{-\infty}^x \frac{f(u, y)}{f_Y(y)} du</script><script type="math/tex; mode=display">
F(y | x) = \int_{-\infty}^y \frac{f(x, v)}{f_X(x)} dv</script><h5 id="二、条件密度函数"><a href="#二、条件密度函数" class="headerlink" title="二、条件密度函数"></a>二、条件密度函数</h5><script type="math/tex; mode=display">
f(x | y) = \frac{f(x,y)}{f_Y(y)}</script><script type="math/tex; mode=display">
f(y | x) = \frac{f(x,y)}{f_X(x)}</script><script type="math/tex; mode=display">
P(X \leq x | Y = y) = \dfrac{P(X \leq x, Y = y)}{P(Y = y)}</script><p>由于对于连续型随机变量而言，其在一点$Y = y$的概率为零，所以此处应该将分母修改为：</p>
<script type="math/tex; mode=display">
P(X \leq x | Y = y) = \lim\limits_{\epsilon \to 0}\dfrac{P(X \leq x, y \leq Y \leq y+\epsilon )}{P(y \leq Y \leq y+\epsilon )} = \lim\limits_{\epsilon \to 0} \dfrac{\int_{-\infty}^{x} \frac{1}{\epsilon} \int_y^{y+\epsilon}f(u,v)dvdu}{\frac{1}{\epsilon}\int_y^{y+\epsilon}f_Y(v)dv}</script><p>由积分中值定理可知，上式等于<script type="math/tex">=\int_{-\infty}^{x} \dfrac{f(u, y)}{f_Y(y)} \mathrm du</script>。</p>
<h4 id="3-2-4-随机变量的独立性"><a href="#3-2-4-随机变量的独立性" class="headerlink" title="3.2.4 随机变量的独立性"></a>3.2.4 随机变量的独立性</h4><h5 id="一、定义-11"><a href="#一、定义-11" class="headerlink" title="一、定义"></a>一、定义</h5><p>结合上一节的条件分布的概念，可以定义两个随机变量独立满足：</p>
<script type="math/tex; mode=display">
f(x | y) = f_X(x)</script><p>带入条件分布的公式，整理可得：</p>
<script type="math/tex; mode=display">
f(x, y) = f_X(x)f_Y(y)</script><p>同理，也可以使用分布来定义：</p>
<script type="math/tex; mode=display">
F(x, y) = F_X(x)F_Y(y)</script><p>同时，还可以使用概率来判断：</p>
<script type="math/tex; mode=display">
P(x \in S_x, y \in S_y) = P(x \in S_x)P(y \in S_y)</script><h5 id="二、二维离散型随机变量的独立性"><a href="#二、二维离散型随机变量的独立性" class="headerlink" title="二、二维离散型随机变量的独立性"></a>二、二维离散型随机变量的独立性</h5><p>根据定义易知：</p>
<script type="math/tex; mode=display">
P(X = x_i, Y = y_j) = P(X= x_i)P(Y = y_j)</script><h5 id="三、二维连续型随机变量的独立性"><a href="#三、二维连续型随机变量的独立性" class="headerlink" title="三、二维连续型随机变量的独立性"></a>三、二维连续型随机变量的独立性</h5><p>根据定义，判断两个二维连续型随机变量的独立性通过：</p>
<script type="math/tex; mode=display">
f(x, y) = f_X(x)f_Y(y)</script><h5 id="四、变量函数独立"><a href="#四、变量函数独立" class="headerlink" title="四、变量函数独立"></a>四、变量函数独立</h5><p>若X、Y变量是相互独立的，那么由变量构造的函数$g_1(X), g_2(Y)$也是相互独立的。</p>
<h3 id="3-3-二维随机变量函数的分布"><a href="#3-3-二维随机变量函数的分布" class="headerlink" title="3.3 二维随机变量函数的分布"></a>3.3 二维随机变量函数的分布</h3><h4 id="3-3-1-二维离散型随机变量函数的分布"><a href="#3-3-1-二维离散型随机变量函数的分布" class="headerlink" title="3.3.1 二维离散型随机变量函数的分布"></a>3.3.1 二维离散型随机变量函数的分布</h4><p>略。。。</p>
<p>泊松分布具有可加性！</p>
<h4 id="3-3-2-二维连续型随机变量函数的分布"><a href="#3-3-2-二维连续型随机变量函数的分布" class="headerlink" title="3.3.2 二维连续型随机变量函数的分布"></a>3.3.2 二维连续型随机变量函数的分布</h4><p>已知二维连续型随机变量$(X, Y)$，我们设由其构造一新函数$Z = g(X, Y)$，求Z的分布。</p>
<p>求解步骤：</p>
<ul>
<li>① 求<script type="math/tex">F_Z(z) = P(Z \leq z) = P(g(X, Y) \leq z) = \int\int\limits_{Dz} f(x, y)dxdy</script>，其中<script type="math/tex">D_z = \begin{Bmatrix} (x, y) | g(x, y) \leq z \end{Bmatrix}</script>；</li>
<li>② 对$F_Z(z)$求导，得到$f_Z(z)$。</li>
</ul>
<h2 id="第四章-随机变量的数字特征"><a href="#第四章-随机变量的数字特征" class="headerlink" title="第四章 随机变量的数字特征"></a>第四章 随机变量的数字特征</h2><h3 id="4-1-数学期望"><a href="#4-1-数学期望" class="headerlink" title="4.1 数学期望"></a>4.1 数学期望</h3><h4 id="4-1-1-离散型随机变量的数学期望"><a href="#4-1-1-离散型随机变量的数学期望" class="headerlink" title="4.1.1 离散型随机变量的数学期望"></a>4.1.1 离散型随机变量的数学期望</h4><h5 id="一、定义-12"><a href="#一、定义-12" class="headerlink" title="一、定义"></a>一、定义</h5><p>若<script type="math/tex">P(X = x_k) = p_k</script>，当<script type="math/tex">\sum\limits_{k = 1}^{\infty} x_k p_k</script>绝对收敛时，离散型随机变量的数学期望为$E(X)$：</p>
<script type="math/tex; mode=display">
E(X) = \sum\limits_{k = 1}^{\infty} x_k p_k</script><h4 id="4-1-2-连续型随机变量的数学期望"><a href="#4-1-2-连续型随机变量的数学期望" class="headerlink" title="4.1.2 连续型随机变量的数学期望"></a>4.1.2 连续型随机变量的数学期望</h4><h5 id="一、定义-13"><a href="#一、定义-13" class="headerlink" title="一、定义"></a>一、定义</h5><p>随机变量X的密度函数为$f(x)$，当$\int_{-\infty}^{\infty} xf(x)dx$绝对收敛时，连续型随机变量的数学期望为$E(X)$：</p>
<script type="math/tex; mode=display">
E(X) = \int_{-\infty}^{\infty} xf(x)dx</script><h4 id="4-1-3-随机变量函数的数学期望"><a href="#4-1-3-随机变量函数的数学期望" class="headerlink" title="4.1.3 随机变量函数的数学期望"></a>4.1.3 随机变量函数的数学期望</h4><h5 id="一、一维情况"><a href="#一、一维情况" class="headerlink" title="一、一维情况"></a>一、一维情况</h5><p>由随机变量构造的新函数$Y = g(X)$，求Y的数学期望$E(Y)$。根据定义易得：</p>
<ul>
<li>离散型</li>
</ul>
<script type="math/tex; mode=display">
E(Y) = \sum_{i = 1}^{\infty} g(x_i)p_i</script><ul>
<li>连续型</li>
</ul>
<script type="math/tex; mode=display">
E(Y) = \int_{-\infty}^{\infty} g(x)f(x)dx</script><h5 id="二、二维情况"><a href="#二、二维情况" class="headerlink" title="二、二维情况"></a>二、二维情况</h5><p>由二维随机变量$(X, Y)$构成的函数$Z = g(X, Y)$，求Z的数学期望$E(Z)$。根据定义易得：</p>
<ul>
<li>离散型</li>
</ul>
<script type="math/tex; mode=display">
E(Z) = \sum_i \sum_j g(x_i, y_j) p_{ij}</script><ul>
<li>连续型</li>
</ul>
<script type="math/tex; mode=display">
E(Z) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} g(x, y)f(x, y) dxdy</script><h4 id="4-1-4-数学期望的性质"><a href="#4-1-4-数学期望的性质" class="headerlink" title="4.1.4 数学期望的性质"></a>4.1.4 数学期望的性质</h4><p><strong>性质1：常数的数学期望等于其本身</strong></p>
<script type="math/tex; mode=display">
E(C) = C</script><p><strong>性质2：线性关系</strong></p>
<script type="math/tex; mode=display">
E(kX+b) = kE(X) + b</script><p><strong>性质3：</strong></p>
<script type="math/tex; mode=display">
E(X \pm Y) = E(X) \pm E(Y)</script><p><strong>性质4：</strong></p>
<script type="math/tex; mode=display">
E(\sum_i C_i X_i) =  \sum_i C_i E(X_i)</script><p><strong>性质5：</strong>当X、Y相互独立时</p>
<script type="math/tex; mode=display">
E(XY) = E(X)E(Y)</script><h4 id="4-1-5-条件期望"><a href="#4-1-5-条件期望" class="headerlink" title="4.1.5 条件期望"></a>4.1.5 条件期望</h4><h5 id="一、定义-14"><a href="#一、定义-14" class="headerlink" title="一、定义"></a>一、定义</h5><p>一个变量取定值的条件下，另一个变量的数学期望。</p>
<h5 id="二、离散型"><a href="#二、离散型" class="headerlink" title="二、离散型"></a>二、离散型</h5><p>直接由定义可得：</p>
<script type="math/tex; mode=display">
E(X | Y = y_j) = \sum x_i p(X = x_i | Y = y_j)</script><h5 id="三、连续型"><a href="#三、连续型" class="headerlink" title="三、连续型"></a>三、连续型</h5><p>直接由定义可得：</p>
<script type="math/tex; mode=display">
E(X | Y = y) = \int_{-\infty}^{\infty} x f(x | y) dx</script><h3 id="4-2-方差"><a href="#4-2-方差" class="headerlink" title="4.2 方差"></a>4.2 方差</h3><h4 id="4-2-1-方差的概念"><a href="#4-2-1-方差的概念" class="headerlink" title="4.2.1 方差的概念"></a>4.2.1 方差的概念</h4><h5 id="一、方差的基本概念"><a href="#一、方差的基本概念" class="headerlink" title="一、方差的基本概念"></a>一、方差的基本概念</h5><p>方差是在概率论和统计方差衡量随机变量或一组数据时离散程度的度量。概率论中方差用来度量随机变量和其数学期望（即均值）之间的偏离程度。统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数。</p>
<p>方差在统计描述和概率分布中各有不同的定义，并有不同的公式。 </p>
<h5 id="二、概率分布中的定义"><a href="#二、概率分布中的定义" class="headerlink" title="二、概率分布中的定义"></a>二、概率分布中的定义</h5><p>在概率分布中，设X是一个离散型随机变量，若$E((X-E(X))^2)$存在，则称$E((X-E(X))^2)$为X的方差，记为$D(X)$。将其开根号后即为标准差$\sigma = \sqrt{D(X)}$，可以保证量纲不变。</p>
<p>离散型随机变量方差计算公式：</p>
<script type="math/tex; mode=display">
D(X) = E((X - E(X))^2) = E(X^2) - E(X)^2</script><p>对于连续型随机变量X，若其定义域为$(a, b)$，概率密度函数为$f(x)$，则连续型随机变量方差为：</p>
<script type="math/tex; mode=display">
D(X) = \int_{-\infty}^{\infty}(x - E(X))^2 f(x) dx</script><h5 id="三、统计中的定义"><a href="#三、统计中的定义" class="headerlink" title="三、统计中的定义"></a>三、统计中的定义</h5><p>在统计描述中，方差用来计算每一个变量（观察值）与总体均数之间的差异。为避免出现离均差总和为零，离均差平方和受样本含量的影响，统计学采用平均离均差平方和来描述变量的变异程度。总体方差计算公式： </p>
<script type="math/tex; mode=display">
\sigma^2 = \frac{\sum(X - \mu)^2}{N}</script><p>$\sigma^2$为总体方差，$\mu$为总体均值，$N$为总体例数。</p>
<p>实际工作中，总体均数难以得到时，应用样本统计量代替总体参数，经校正后，样本方差计算公式： </p>
<script type="math/tex; mode=display">
S^2 = \frac{\sum(X-\bar X)^2}{n-1}</script><p>$S^2$为总体方差，$\bar X$为样本均值，$n$为样本例数。</p>
<h4 id="4-2-2-方差的性质"><a href="#4-2-2-方差的性质" class="headerlink" title="4.2.2 方差的性质"></a>4.2.2 方差的性质</h4><p><strong>性质1：常数的方差为零</strong></p>
<script type="math/tex; mode=display">
D(C) = 0</script><p><strong>性质2：设X是随机变量，是C常数，则有</strong></p>
<script type="math/tex; mode=display">
D(CX) = C^2 D(X), D(X+C) = D(X)</script><p><strong>性质3：设X与Y是两个随机变量，则</strong></p>
<script type="math/tex; mode=display">
D(X \pm Y) = D(X) + D(Y) \pm 2Cov(X, Y)</script><p>其中协方差$Cov(X, Y) = E((X - E(X))(Y - E(Y)))$</p>
<p>特别的，当X，Y是两个不相关<strong>(相互独立)</strong>的随机变量则 </p>
<script type="math/tex; mode=display">
D(X \pm Y) = D(X) + D(Y)</script><p><strong><font color="red">标准化</font></strong></p>
<p>构造一个新的随机变量：</p>
<script type="math/tex; mode=display">
X^* = \frac{X - E(X)}{\sqrt{D(X)}}</script><p>则<script type="math/tex">X^*</script>的数学期望<script type="math/tex">E(X^*) = 0</script>，方差为<script type="math/tex">D(X^*) = 1</script>。</p>
<h3 id="4-3-常见分布的数学期望与方差"><a href="#4-3-常见分布的数学期望与方差" class="headerlink" title="4.3 常见分布的数学期望与方差"></a>4.3 常见分布的数学期望与方差</h3><h4 id="4-3-1-常见离散型分布的数学期望和方差"><a href="#4-3-1-常见离散型分布的数学期望和方差" class="headerlink" title="4.3.1 常见离散型分布的数学期望和方差"></a>4.3.1 常见离散型分布的数学期望和方差</h4><p>略过了。。。</p>
<h4 id="4-3-2-常见连续型分布的数学期望和方差"><a href="#4-3-2-常见连续型分布的数学期望和方差" class="headerlink" title="4.3.2 常见连续型分布的数学期望和方差"></a>4.3.2 常见连续型分布的数学期望和方差</h4><p>略过了。。。</p>
<h3 id="4-4-协方差与相关系数"><a href="#4-4-协方差与相关系数" class="headerlink" title="4.4 协方差与相关系数"></a>4.4 协方差与相关系数</h3><h4 id="4-4-1-协方差"><a href="#4-4-1-协方差" class="headerlink" title="4.4.1 协方差"></a>4.4.1 协方差</h4><h5 id="一、定义-15"><a href="#一、定义-15" class="headerlink" title="一、定义"></a>一、定义</h5><p><strong>协方差</strong>（Covariance）在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。</p>
<p>协方差表示的是两个变量的总体的误差，这与只表示一个变量误差的方差不同。如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。</p>
<h5 id="二、计算-1"><a href="#二、计算-1" class="headerlink" title="二、计算"></a>二、计算</h5><p>期望值分别为$E[X]$与$E[Y]$的两个实随机变量$X$与$Y$之间的<strong>协方差</strong>Cov(X,Y)定义为： </p>
<script type="math/tex; mode=display">
Cov(X, Y) = E((X-E(X))(Y-E(Y))) = E(XY) - E(X)E(Y)</script><p>独立能推出协方差等于0，但是协方差等于0不能推出独立。</p>
<h5 id="三、协方差的性质"><a href="#三、协方差的性质" class="headerlink" title="三、协方差的性质"></a>三、协方差的性质</h5><p><strong>性质1：</strong></p>
<script type="math/tex; mode=display">
Cov(X, Y) = Cov(Y, X)</script><p><strong>性质2：</strong></p>
<script type="math/tex; mode=display">
Cov(aX, bY) = ab \times Cov(X,Y)</script><p><strong>性质3：</strong></p>
<script type="math/tex; mode=display">
Cov(X_1 + X_2, Y) = Cov(X_1, Y)+Cov(X_2, Y)</script><p><strong>性质4：</strong></p>
<script type="math/tex; mode=display">
Cov(C, X) = 0</script><p><strong>性质5：若X、Y相互独立则</strong></p>
<script type="math/tex; mode=display">
Cov(X, Y) = 0</script><h5 id="四、协方差矩阵"><a href="#四、协方差矩阵" class="headerlink" title="四、协方差矩阵"></a>四、协方差矩阵</h5><p>协方差主要反应的是两个随机变量的线性相关性，也就是他们是线性的还是非线性的</p>
<ul>
<li>针对一维样本集合时，求出的协方差其实就是方差，即方差是协方差的一种特殊情况，意义和方差一样，都是反应集合中各元素离散度的</li>
<li>针对二维样本集合时，求出的协方差反映的就是两维度之间的相关性，正相关性或负相关性，或无关</li>
<li>针对三维样本集合时，求出的是各个维度总体的相关性，针对各维度之间的关系，所以二维以上计算协方差，用的就是<font color="red"><strong>协方差矩阵</strong></font>。</li>
</ul>
<p>当出现多维数据时，若要对多维数据的相关性进行分析，那么就要用到协方差矩阵。其形式如下：</p>
<script type="math/tex; mode=display">
V=\left[\begin{array}{cccc}
\operatorname{Cov}\left(X_{1}, X_{1}\right) & \operatorname{Cov}\left(X_{1}, X_{2}\right) & \cdots & \operatorname{Cov}\left(X_{1}, X_{n}\right) \\
\operatorname{Cov}\left(X_{2}, X_{1}\right) & \operatorname{Cov}\left(X_{2}, X_{2}\right) & \cdots & \operatorname{Cov}\left(X_{2}, X_{n}\right) \\
\vdots & \vdots & \ddots & \vdots \\
\operatorname{Cov}\left(X_{n}, X_{1}\right) & \operatorname{Cov}\left(X_{n}, X_{2}\right) & \cdots & \operatorname{Cov}\left(X_{n}, X_{d}\right)
\end{array}\right]</script><h5 id="五、相关系数"><a href="#五、相关系数" class="headerlink" title="五、相关系数"></a>五、相关系数</h5><p><strong>协方差会受单位/量纲的影响</strong>，我们可以使用<font color="red"><strong>标准化</strong></font>方法去除单位的影响：</p>
<script type="math/tex; mode=display">
X^* = \frac{X - E(X)}{\sqrt{D(X)}},Y^* = \frac{Y - E(Y)}{\sqrt{D(Y)}}</script><p>此时$X^<em>,Y^</em>$的协方差为：</p>
<script type="math/tex; mode=display">
Cov(X^*, Y^*) = E(X^* Y^*) - E(X^*)E(Y^*)</script><p>带入化简得：</p>
<script type="math/tex; mode=display">
\rho = \frac{E((X-E(X))(Y-E(Y)))}{\sqrt{D(X)}\sqrt{D(Y)}} = \frac{Cov(X, Y)}{\sqrt{D(X)}\sqrt{D(Y)}}</script><p>定义$\rho$为相关系数，它不受单位的影响。</p>
<h4 id="4-4-2-相关系数"><a href="#4-4-2-相关系数" class="headerlink" title="4.4.2 相关系数"></a>4.4.2 相关系数</h4><h5 id="一、定义-16"><a href="#一、定义-16" class="headerlink" title="一、定义"></a>一、定义</h5><p>由上一节最后一部分我们知道，相关系数$\rho$的定义式为：</p>
<script type="math/tex; mode=display">
\rho = \frac{Cov(X, Y)}{\sqrt{D(X) D(Y)}}</script><h5 id="二、性质-1"><a href="#二、性质-1" class="headerlink" title="二、性质"></a>二、性质</h5><p>1、$|\rho| \leq 1$</p>
<p>2、$|\rho| = 1 \Longleftrightarrow X与Y以概率P=1呈线性关系$，即$P(Y = aX+b) = 1$</p>
<blockquote>
<p>由性质2，我们可以知道其实$\rho$衡量的是两个随机变量之间的<font color="red"><strong>线性相关关系</strong></font></p>
</blockquote>
<h5 id="三、-rho-的取值"><a href="#三、-rho-的取值" class="headerlink" title="三、$\rho$的取值"></a>三、$\rho$的取值</h5><ul>
<li>$\rho = 1$，则X、Y完全正相关；</li>
<li>$\rho = -1$，则X、Y完全负相关；</li>
<li>$|\rho| \to 0$，则X、Y线性关系很弱；</li>
<li>$|\rho| = 0$，则X、Y不存在线性关系。</li>
</ul>
<h5 id="四、相关与独立"><a href="#四、相关与独立" class="headerlink" title="四、相关与独立"></a>四、相关与独立</h5><p>注意本节所说的相关均是指<strong>线性相关</strong>，因此有以下关系：</p>
<ul>
<li>X、Y相互独立，则X、Y不相关；</li>
<li>X、Y不相关，X、Y不一定独立；</li>
</ul>
<p><strong>但是，有一个特例：二维正态分布$(X, Y)$，独立与不相关是等价的！！！</strong></p>
<h3 id="4-5-随机变量的矩——原点矩与中心矩"><a href="#4-5-随机变量的矩——原点矩与中心矩" class="headerlink" title="4.5 随机变量的矩——原点矩与中心矩"></a>4.5 随机变量的矩——原点矩与中心矩</h3><h5 id="一、原点矩定义"><a href="#一、原点矩定义" class="headerlink" title="一、原点矩定义"></a>一、原点矩定义</h5><p>1、在数理统计学中有一类数字特征称为矩。</p>
<p>原点矩：令k为正整数（或为0），a为任何实数，X为随机变量，则期望值$E((X - a)^k)$叫做随机变量X对a的k阶矩，或叫动差。如果$a=0$，则有$E(X^k)$，叫做<strong>k阶原点矩</strong>，记作$v_k(X)$，也叫k阶矩。</p>
<script type="math/tex; mode=display">
v_k(X) = E((X - a)^k), k = 1,2,\cdots</script><p>显然，<strong>一阶原点矩就是数学期望</strong>，即</p>
<script type="math/tex; mode=display">
v_1(X) = E(X)</script><p>2、原点矩计算</p>
<p>(1) 离散</p>
<script type="math/tex; mode=display">
v_k(X) = \sum x_i^kp_i</script><p>(2) 连续</p>
<script type="math/tex; mode=display">
v_k(X) = \int_{-\infty}^{\infty}x^k f(x) dx</script><h5 id="二、中心矩定义"><a href="#二、中心矩定义" class="headerlink" title="二、中心矩定义"></a>二、中心矩定义</h5><p>设随机变量X的函数$(X-E(X))^k,(k = 1, 2, \cdots)$的数学期望存在，则称$E((X - E(X))^k)$为X的k阶中心矩，记作$u_k(X)$：</p>
<script type="math/tex; mode=display">
u_k(X) = E((X - E(X))^k), k = 1, 2, \cdots</script><p>易知，<strong>一阶中心矩恒等于零</strong>，即$u_1(X) = 0$；二阶中心矩就是方差，即$u_2(X) = D(X)$。</p>
<p>2、中心矩的计算</p>
<p>(1) 离散</p>
<script type="math/tex; mode=display">
u_k(X) = \sum (x_i - E(X))^k p_i</script><p>(2) 连续</p>
<script type="math/tex; mode=display">
u_k(X) = \int_{-\infty}^{\infty}(x - E(X))^k f(x)dx</script><h2 id="第五章-大数定律与中心极限定理"><a href="#第五章-大数定律与中心极限定理" class="headerlink" title="第五章 大数定律与中心极限定理"></a>第五章 大数定律与中心极限定理</h2><h3 id="5-1-大数定律"><a href="#5-1-大数定律" class="headerlink" title="5.1 大数定律"></a>5.1 大数定律</h3><p><strong><font color="red">大数定律想揭示这样一个定律：大量重复实验的平均结果的稳定性</font></strong></p>
<h4 id="5-1-1-切比雪夫不等式"><a href="#5-1-1-切比雪夫不等式" class="headerlink" title="5.1.1 切比雪夫不等式"></a>5.1.1 切比雪夫不等式</h4><h5 id="一、定理"><a href="#一、定理" class="headerlink" title="一、定理"></a>一、定理</h5><p>假设X为一随机变量，X的数学期望$E(X)$与方差$D(X)$都存在，则对于$\forall \varepsilon &gt;0$，都有</p>
<script type="math/tex; mode=display">
P(|X - E(X)| \geq \varepsilon) \leq \frac{D(X)}{\varepsilon^2}</script><script type="math/tex; mode=display">
P(|X - E(X)| < \varepsilon) \geq 1-\frac{D(X)}{\varepsilon^2}</script><h4 id="5-1-2-切比雪夫大数定律"><a href="#5-1-2-切比雪夫大数定律" class="headerlink" title="5.1.2 切比雪夫大数定律"></a>5.1.2 切比雪夫大数定律</h4><h5 id="一、普通收敛的定义"><a href="#一、普通收敛的定义" class="headerlink" title="一、普通收敛的定义"></a>一、普通收敛的定义</h5><p>对于$\forall \varepsilon &gt;0, ∃ N &gt;0$，使得当$n &gt; N$时，有$|a_n - a| &lt; \varepsilon$。</p>
<h5 id="二、依概率收敛定义"><a href="#二、依概率收敛定义" class="headerlink" title="二、依概率收敛定义"></a>二、依概率收敛定义</h5><p>对于$\forall \varepsilon &gt;0, ∃  N &gt;0$，使得当$n &gt; N$时，有$\lim\limits_{n \to \infty}P(|x_n - a| &lt; \varepsilon) = 1$。</p>
<h5 id="三、伯努利大数定律"><a href="#三、伯努利大数定律" class="headerlink" title="三、伯努利大数定律"></a>三、伯努利大数定律</h5><p>假设做了n重伯努利实验，事件A发生了$m_n$次，p是事件A的概率，$\dfrac{m_n}{n}$是事件A的频率，则有</p>
<script type="math/tex; mode=display">
\lim\limits_{n \to \infty} P(|\frac{m_n}{n}-p| < \varepsilon) = 1</script><p>另一种表示：</p>
<script type="math/tex; mode=display">
\lim\limits_{n \to \infty} P(|\frac{m_n}{n}-p| \geq \varepsilon) = 0</script><p><strong>通俗的说，伯努利大数定律就是想表达：当实验次数足够多的时候，就能用频率近似代替概率 ，能用样本均值近似代替总体均值。</strong> </p>
<h5 id="四、辛钦大数定理"><a href="#四、辛钦大数定理" class="headerlink" title="四、辛钦大数定理"></a>四、辛钦大数定理</h5><p>设$X_1, X_2, \cdots$是<strong><font color="red">独立同分布(iid)</font></strong>的随机变量序列，且它们的期望值存在，记为$E(X_i)=μ$(同分布隐含条件即为期望相同)，则对于$\forall \varepsilon &gt;0$，有 </p>
<script type="math/tex; mode=display">
\lim _{n \rightarrow \infty} P\left\{\left|\frac{1}{n} \sum_{i=1}^{n} X_{i}- E\left(X_{i}\right)\right|<\varepsilon\right\}=1</script><p><strong>通俗的说，辛钦大数定律从理论上指出：用算术平均值来近似实际真值是合理的。</strong></p>
<p>当Xi为服从0-1分布的随机变量时，辛钦大数定律就是伯努利大数定律，故<strong>伯努利大数定律是辛钦伯努利大数定律的一个特例。</strong></p>
<h5 id="五、切比雪夫大数定律"><a href="#五、切比雪夫大数定律" class="headerlink" title="五、切比雪夫大数定律"></a>五、切比雪夫大数定律</h5><p>设$X_1, X_2, \cdots, X_n, \cdots$是(线性)不相关的随机变量序列，$E(X_i),D(X_i)$均存在，并且方差都是有界的$D(X_i) \leq M$，则有$\forall \varepsilon &gt;0$</p>
<script type="math/tex; mode=display">
\lim _{n \rightarrow+\infty} P\left\{\left|\frac{1}{n} \sum_{i=1}^{n} X_{i}-\frac{1}{n} \sum_{i=1}^{n} E(X_i)\right|<\varepsilon\right\}=1</script><p><strong>通俗的说，切比雪夫大数定律就是想表达：随机变量的均值依概率收敛于期望的均值。</strong> </p>
<h5 id="六、辛钦与切比雪夫大数定律的区别"><a href="#六、辛钦与切比雪夫大数定律的区别" class="headerlink" title="六、辛钦与切比雪夫大数定律的区别"></a>六、辛钦与切比雪夫大数定律的区别</h5><p>辛钦大数定理规定必须是独立同分布的</p>
<p>切比雪夫大数定律没规定同分布，但规定了方差存在。 </p>
<p>辛钦定律：序列${X_i}$的期望存在,则{Xi}服从大数定律</p>
<p>切比雪夫：序列{Xi}的方差存在,则${X_i}$服从大数定律</p>
<h5 id="七、总结——大数定律有这么几个版本"><a href="#七、总结——大数定律有这么几个版本" class="headerlink" title="七、总结——大数定律有这么几个版本"></a>七、总结——大数定律有这么几个版本</h5><p>1、<strong>伯努利大数定理：</strong>从定义概率的角度，<strong>揭示了概率与频率的关系</strong>，当N很大的时候，事件A发生的概率等于A发生的频率。</p>
<p>2、<strong>辛钦大数定理：揭示了算术平均值和数学期望的关系</strong> </p>
<p>3、<strong>切比雪夫大数定律：揭示了样本均值和真实期望的关系</strong> </p>
<p>伯努利大数定律是300年前瑞士数学家伯努利潜心研究20年证明出来的，是人类历史上第一个严格证明的大数定律。它是辛钦大数定律的特殊情况，不过由于它有一定的历史意义并且二项分布的大数定律在日常生活中最为常见，所以编教材的人喜欢把这个大数定律单独列出来。</p>
<p>切比雪夫大数定律和辛钦大数定律针对的是两种不同的情况，谁也不是谁的特例。切比雪夫大数定律说的是一列独立变量（可以不同分布）的均值收敛到一个常数，但前提是每个变量的期望和方差均存在且有限，并且满足方差的平均值是样本数n的高阶无穷小这一额外条件。辛钦大数定律是说一列独立同分布的随机变量的均值收敛到一个常数，条件是分布的绝对期望存在且有限就够了。</p>
<p>对两个大数定律做一总结，就是切比雪夫大数定律不要求随机变量有相同分布但是成立的条件更加严格，辛钦大数定律要求同分布不过是在比较弱的条件下就成立。</p>
<h3 id="5-2-中心极限定律"><a href="#5-2-中心极限定律" class="headerlink" title="5.2 中心极限定律"></a>5.2 中心极限定律</h3><p>一个随机现象是由大量相互独立的因素影响的，中心极限定理描述的是这样一个事情：</p>
<center>**<font color="blue">大量独立同分布(iid)的随机变量和的极限分布是正态分布</font>**</center> 

<p>设$X_1, X_2, \cdots$是<strong><font color="red">独立同分布(iid)</font></strong>的随机变量序列，$E(X_i) = \mu$ ，$D(X_i) = \sigma^2, 0&lt;\sigma^2&lt;\infty$，那么：</p>
<script type="math/tex; mode=display">
\lim_{n \to \infty}P \left(\frac{\sum\limits_{i =1}^{n} X_i - n\mu}{\sqrt n \sigma} \leq x \right) = \Phi_0(x)</script><p>上式也就是说，令$Y = \dfrac{\sum\limits_{i =1}^{n} X_i - n\mu}{\sqrt n \sigma} $，则Y可以近似为标准正态分布：$Y \sim N(0, 1)$。</p>
<h2 id="第六章-数理统计的基本概念"><a href="#第六章-数理统计的基本概念" class="headerlink" title="第六章 数理统计的基本概念"></a>第六章 数理统计的基本概念</h2><h3 id="6-1-总体与样本"><a href="#6-1-总体与样本" class="headerlink" title="6.1 总体与样本"></a>6.1 总体与样本</h3><h5 id="一、总体-population-和样本-sample"><a href="#一、总体-population-和样本-sample" class="headerlink" title="一、总体(population)和样本(sample)"></a>一、总体(population)和样本(sample)</h5><p>总体：研究对象的整个群体，就是一个<strong>概率分布</strong>。 </p>
<p>样本：从总体中选取的一部分。其中，<strong>样本具有和总体相同的分布，样本之间两两独立。</strong> </p>
<p>样本数量：有多少个样本。</p>
<p>样本大小（样本容量）：每个样本里包含多少个数据。</p>
<p>抽样分布：将样本平均值的分布可视化。</p>
<blockquote>
<p>1、总体是一个概率分布或服从这个概率分布的随机变量</p>
<p>2、如何理解一个总体就是一个具有确定概率分布的随机变量?</p>
<p>3、我感到奇怪的是，样本是从总体体里抽出来的，为什么样本和总体服从同样的分布？或者说，总体是随机变量，为什么从整体里抽出来的还叫随机变量。 </p>
</blockquote>
<h5 id="二、中心极限定理-central-limit-theorem"><a href="#二、中心极限定理-central-limit-theorem" class="headerlink" title="二、中心极限定理(central limit theorem)"></a>二、中心极限定理(central limit theorem)</h5><p>中心极限定理：样本平均值约等于总体平均值，且不管总体是什么分布，任意一个总体的样本平均值都会围绕在总体的平均值周围，并且呈正态分布。如下：</p>
<p><img src="https://pic.imgdb.cn/item/622579695baa1a80abcff1d7.jpg" style="zoom:80%"></p>
<p>中心极限定理的作用：</p>
<p>1）用样本来估计总体（民意调查）</p>
<p>2）根据总体信息，判断某个样本是否属于总体（3个标准差，概率97%）</p>
<h3 id="6-2-统计量"><a href="#6-2-统计量" class="headerlink" title="6.2 统计量"></a>6.2 统计量</h3><h5 id="一、统计量的定义"><a href="#一、统计量的定义" class="headerlink" title="一、统计量的定义"></a>一、统计量的定义</h5><p>不含任何未知参数的样本构造的函数。</p>
<p>e.g. 直接将样本相加$X_1+X_2+ \cdots + X_n$就是一个统计量。</p>
<h5 id="二、常见统计量"><a href="#二、常见统计量" class="headerlink" title="二、常见统计量"></a>二、常见统计量</h5><p><strong>1、样本均值</strong></p>
<script type="math/tex; mode=display">
\overline X = \frac{1}{n}\sum_{i =1}^{n} X_i</script><p><strong>2、未修正的样本方差/总体方差</strong></p>
<script type="math/tex; mode=display">
S_0^2 = \frac{1}{n}\sum_{i =1}^{n} (X_i - \overline X)</script><p><strong>3、(已修正的)样本方差</strong></p>
<script type="math/tex; mode=display">
S^2 = \frac{1}{n-1}\sum_{i =1}^{n} (X_i - \overline X)</script><p>为什么样本方差自由度(分母)为n-1？</p>
<p><a href="https://www.cnblogs.com/ohshit/p/5590629.html">https://www.cnblogs.com/ohshit/p/5590629.html</a></p>
<p><a href="https://blog.csdn.net/qq_39521554/article/details/79633207">https://blog.csdn.net/qq_39521554/article/details/79633207</a></p>
<p><a href="http://www.noobyard.com/article/p-emeczand-nh.html">http://www.noobyard.com/article/p-emeczand-nh.html</a></p>
<p><a href="https://benpaodewoniu.github.io/2018/06/15/math3/">https://benpaodewoniu.github.io/2018/06/15/math3/</a></p>
<p><a href="https://www.zhihu.com/question/30440035">https://www.zhihu.com/question/30440035</a></p>
<p><a href="https://www.zhihu.com/question/20099757">https://www.zhihu.com/question/20099757</a></p>
<p><a href="https://www.bilibili.com/video/BV183411r7tZ/?spm_id_from=333.788.recommend_more_video.4">https://www.bilibili.com/video/BV183411r7tZ/?spm_id_from=333.788.recommend_more_video.4</a></p>
<p><strong>4、样本的k阶原点矩</strong></p>
<script type="math/tex; mode=display">
A_k = \frac{1}{n}\sum_{i = 1}^{n} X_i^k</script><p><strong>5、样本的k阶中心矩</strong></p>
<script type="math/tex; mode=display">
B_k = \frac{1}{n}\sum_{i = 1}^{n} (X_i - \overline X)^k</script><p><strong>6、样本的协方差</strong></p>
<script type="math/tex; mode=display">
S_{12} = \frac{1}{n} \sum(X_i - \overline X)(Y_i - \overline Y)</script><p><strong>7、样本的相关系数</strong></p>
<script type="math/tex; mode=display">
R = \frac{S_{12}}{S_1 S_2}</script><p>式中$S_1、S_2$是样本的标准差。</p>
<h5 id="三、样本均值与样本方差的性质"><a href="#三、样本均值与样本方差的性质" class="headerlink" title="三、样本均值与样本方差的性质"></a>三、样本均值与样本方差的性质</h5><p>设总体X的均值为$E(X) = \mu$，方差为$D(X)  = \sigma^2$，样本$(X_1,X_2, \cdots, X_n)$来自总体X，则有</p>
<script type="math/tex; mode=display">
E(\overline X) = \mu</script><script type="math/tex; mode=display">
D(\overline X) = \frac{1}{n}\sigma^2</script><script type="math/tex; mode=display">
E(S^2) = \sigma^2</script><p>注意：这里样本均值还是一个随机变量。</p>
<h3 id="6-3-抽样分布"><a href="#6-3-抽样分布" class="headerlink" title="6.3 抽样分布"></a>6.3 抽样分布</h3><p>构造的统计量的分布就是抽样分布</p>
<h4 id="6-3-1-数理统计中的重要分布"><a href="#6-3-1-数理统计中的重要分布" class="headerlink" title="6.3.1 数理统计中的重要分布"></a>6.3.1 数理统计中的重要分布</h4><h5 id="一、正态分布"><a href="#一、正态分布" class="headerlink" title="一、正态分布"></a>一、正态分布</h5><p>略。。。</p>
<h5 id="二、卡方分布-chi-2-分布"><a href="#二、卡方分布-chi-2-分布" class="headerlink" title="二、卡方分布/$\chi ^2$分布"></a>二、卡方分布/$\chi ^2$分布</h5><p><strong>1、卡方分布的一些性质</strong></p>
<p>(1) $\chi^2(n)$：中n为自由度；</p>
<p>(2) $\chi^2(2)$：是$\lambda = \frac{1}{2}$的指数分布；</p>
<p>(3) $\chi ^2$分布是单峰曲线；，且在$n-2$处取得最大值；</p>
<p>(4) $\chi ^2$分布中当$n \to \infty$时，可以用正态分布近似。</p>
<p><strong>2、$\chi ^2$分布的定义</strong></p>
<p>若$X_1,X_2, \cdots, X_n$是相互独立的，并且都服从标准正态分布，那么有：</p>
<script type="math/tex; mode=display">
\sum_{i = 1}^{n}X_i^2 \sim \chi^2(n)</script><p><strong>3、$\chi ^2$分布的期望与方差</strong></p>
<script type="math/tex; mode=display">
E(X) = n;D(X) = 2n</script><p>由中心极限定理，$X \sim \chi^2(n)$，当n充分大的时候有：$\dfrac{X-n}{\sqrt{2n}} \sim N(0,1)$</p>
<p><strong>4、$\chi ^2$分布的和性质</strong></p>
<p>若$X \sim \chi^2(n), Y \sim \chi^2(m)$，且X、Y相互独立，则有$X+Y \sim \chi^2(n+m)$。</p>
<p><strong>5、$\chi ^2$分布的上$\alpha$分位数</strong></p>
<script type="math/tex; mode=display">
P(\chi^2 > \chi^2_\alpha(n)) = \alpha</script><h5 id="三、t分布"><a href="#三、t分布" class="headerlink" title="三、t分布"></a>三、t分布</h5><p> 如果$X \sim N(0, 1)；Y \sim \chi^2(n)$ ，且X、Y相互独立，那么：</p>
<script type="math/tex; mode=display">
\frac{X}{\sqrt{Y/n}} \sim t(n)</script><h5 id="四、F分布"><a href="#四、F分布" class="headerlink" title="四、F分布"></a>四、F分布</h5><p> 如果$X \sim \chi^2(n_1)；Y \sim \chi^2(n_2)$ ，且X、Y相互独立，那么：</p>
<script type="math/tex; mode=display">
\frac{X/n_1}{Y/n_2} \sim F(n_1, n_2)</script><p>我们由定义易得：若$F \sim F(n_1, n_2)$则$\dfrac{1}{F} \sim F(n_2, n_1)$。</p>
<h4 id="6-3-2-正态总体下的抽样分布"><a href="#6-3-2-正态总体下的抽样分布" class="headerlink" title="6.3.2 正态总体下的抽样分布"></a>6.3.2 正态总体下的抽样分布</h4><p>总体是正态分布，我们从里面抽取样本，由这些样本构造的统计量的分布</p>
<h5 id="一、一个正态总体"><a href="#一、一个正态总体" class="headerlink" title="一、一个正态总体"></a>一、一个正态总体</h5><p>$X \sim N(\mu, \sigma^2)$，$X_1, X_2, \cdots, X_n$是样本，则有以下结论：</p>
<p>(1) $\overline X \sim N(\mu, \dfrac{\sigma^2}{n})$</p>
<blockquote>
<p>证明：</p>
<p>$E(\overline X) = E(\dfrac{1}{n} \sum X_i) = \dfrac{1}{n} \sum E(X_i) = \dfrac{1}{n} n \times \mu = \mu$；</p>
<p>$D(\overline X) = D(\dfrac{1}{n} \sum X_i) = \dfrac{1}{n^2} \sum D(X_i) = \dfrac{1}{n^2} n\times \sigma^2 = \dfrac{\sigma^2}{n}$</p>
<p>证毕</p>
</blockquote>
<p>(2) $\dfrac{(n-1)S^2}{\sigma^2} = \dfrac{1}{\sigma^2} \sum\limits_{i = 1}^{n}(X_i-\overline X) \sim \chi^2(n-1)$</p>
<p>(3) $\overline X$与$S^2$相互独立</p>
<hr>
<p>$X \sim N(\mu, \sigma^2)$，$X_1, X_2, \cdots, X_n$是样本，则有以下结论：</p>
<p>(1) $\dfrac{1}{\sigma^2} \sum\limits_{i = 1}^{n}(X_i- \mu) \sim \chi^2(n)$</p>
<blockquote>
<p>此处与分割线上面的(2)式不同之处就是上面用的是$[\overline X——样本均值]$，而该处是$[\mu——总体期望]$。</p>
</blockquote>
<p>(2) $\dfrac{\overline X - \mu}{S}\sqrt n \sim t(n-1)$</p>
<h5 id="二、两个正态总体"><a href="#二、两个正态总体" class="headerlink" title="二、两个正态总体"></a>二、两个正态总体</h5><p>$X \sim N(\mu_1, \sigma_1^2), Y \sim N(\mu_2, \sigma_2^2)$，$X_1, X_2, \cdots, X_{n1}$、$Y_1, Y_2, \cdots, Y_{n2}$是样本，则有以下结论：</p>
<p>(1) $\dfrac{(\overline X - \overline Y) - (\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}} \sim N(0, 1)$</p>
<p>(2) $\dfrac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2} \sim F(n_1, n_2)$</p>
<p>(3) 当$\sigma_1^2 = \sigma_2^2 = \sigma$时，有$T = \dfrac{(\overline X - \overline Y) - (\mu_1-\mu_2)}{\sqrt{\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}}\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}} \sim t(n_1, n_2)$</p>
<h2 id="第七章-参数估计"><a href="#第七章-参数估计" class="headerlink" title="第七章 参数估计"></a>第七章 参数估计</h2><h3 id="7-1-参数的点估计"><a href="#7-1-参数的点估计" class="headerlink" title="7.1 参数的点估计"></a>7.1 参数的点估计</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">总体分布</th>
<th style="text-align:center">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">正态分布$X \sim N(\mu, \sigma^2)$</td>
<td style="text-align:center">$\mu, \sigma^2$</td>
</tr>
<tr>
<td style="text-align:center">泊松分布$X \sim P(\lambda)$</td>
<td style="text-align:center">$\lambda$</td>
</tr>
<tr>
<td style="text-align:center">均匀分布$X \sim U(a, b)$</td>
<td style="text-align:center">$a, b$</td>
</tr>
<tr>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center">$\cdots$</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>什么是参数估计？</strong></li>
</ul>
<p><strong>总体分布已知，但是分布中的参数不知道，所以需要通过取样本，然后根据样本构造一些函数/统计量来估计这些参数</strong>。</p>
<p>参数空间：参数的取值范围。</p>
<p>函数/统计量：$\hat\theta = \hat\theta(X_1, X_2, \cdots, X_n)$。</p>
<ul>
<li><strong>什么是点估计、区间估计</strong></li>
</ul>
<p>点估计就是将参数估计为一个值，而区间估计是将参数估计为一个区间。</p>
<h4 id="7-1-1-矩估计法"><a href="#7-1-1-矩估计法" class="headerlink" title="7.1.1 矩估计法"></a>7.1.1 矩估计法</h4><h5 id="一、矩估计的思想"><a href="#一、矩估计的思想" class="headerlink" title="一、矩估计的思想"></a>一、矩估计的思想</h5><p>用样本的矩来等效代替总体的矩。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">样本的矩</th>
<th style="text-align:center">等效于</th>
<th style="text-align:center">总体的矩</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">样本一阶原点矩$\overline X = \dfrac{1}{n}\sum X_i$</td>
<td style="text-align:center"></td>
<td style="text-align:center">样本一阶原点矩$E(X)$</td>
</tr>
<tr>
<td style="text-align:center">样本二阶原点矩$A_2 = \dfrac{1}{n}\sum X_i$</td>
<td style="text-align:center"></td>
<td style="text-align:center">样本二阶原点矩$E(X^2)$</td>
</tr>
<tr>
<td style="text-align:center">$\cdots$</td>
<td style="text-align:center"></td>
<td style="text-align:center">$\cdots$</td>
</tr>
</tbody>
</table>
</div>
<p>例题：</p>
<p><img src="https://pic.imgdb.cn/item/6226a2465baa1a80abe09222.jpg" style="zoom:70%"></p>
<h4 id="7-1-2-极大似然估计法（Maximum-Likelihood-Estimate，MLE）"><a href="#7-1-2-极大似然估计法（Maximum-Likelihood-Estimate，MLE）" class="headerlink" title="7.1.2 极大似然估计法（Maximum Likelihood Estimate，MLE）"></a>7.1.2 极大似然估计法（Maximum Likelihood Estimate，MLE）</h4><p>概率大的事件比概率小的事件更容易发生；</p>
<p>将使事件A发生的概率最大的参数值作为估计值（事件A是指样本中发生的事件）。</p>
<h5 id="一、-似然函数"><a href="#一、-似然函数" class="headerlink" title="一、 似然函数"></a>一、 似然函数</h5><p>我们来考察下面这个函数：</p>
<script type="math/tex; mode=display">
p(x|\theta)</script><p>输入有两个：$x$表示某一个具体的数据；$\theta$表示模型的参数。如果是$\theta$已知确定的，$x$是变量，这个函数叫做<strong>概率函数</strong>(probability function)，它描述对于不同的样本点$x$，其出现概率是多少。如果$x$是已知确定的，$\theta$是变量，这个函数叫做<strong>似然函数</strong>(likelihood function), 它描述对于不同的模型参数，出现$x$这个样本点的概率是多少。 </p>
<h5 id="二、-极大似然函数估计值一般步骤"><a href="#二、-极大似然函数估计值一般步骤" class="headerlink" title="二、 极大似然函数估计值一般步骤"></a>二、 极大似然函数估计值一般步骤</h5><ul>
<li><p>写出总体的概率(密度)函数<strong>（极大似然估计的前提一定是要假设数据总体的分布，如果不知道数据分布，是无法使用极大似然估计的）</strong>；</p>
</li>
<li><p>写出似然函数$L(参数)$；</p>
</li>
<li>对似然函数取对数，并整理；</li>
<li>求偏导令偏导为 0，得到似然方程；(注意，此处一个特例均匀分布，用求导的方法不行，需要通过思考分析)</li>
<li>解似然方程，得到的参数。 </li>
</ul>
<h5 id="三、极大似然估计总结"><a href="#三、极大似然估计总结" class="headerlink" title="三、极大似然估计总结"></a>三、极大似然估计总结</h5><p>① 多数情况下我们是根据已知条件来推算结果，而极大似然估计是已经知道了结果，然后寻求使该结果出现的可能性极大的条件，以此作为估计值。</p>
<p>② 极大似然估计，只是一种概率论在统计学的应用，它是参数估计的方法之一。</p>
<p>③ 已知某个随机样本满足某种概率分布，但是其中具体的参数不清楚，通过若干次试验，观察其结果，利用结果推出参数的大概值。</p>
<p>④ 极大似然估计是建立在这样的思想上：已知某个参数能使这个样本出现的概率极大，我们当然不会再去选择其他小概率的样本，所以干脆就把这个参数作为估计的真实值。</p>
<p>⑤ 极大似然估计可以看作是一个<font color="red"><strong>反推思想</strong></font>。 </p>
<h3 id="7-2-点估计的优良性准则"><a href="#7-2-点估计的优良性准则" class="headerlink" title="7.2 点估计的优良性准则"></a>7.2 点估计的优良性准则</h3><h5 id="一、无偏性"><a href="#一、无偏性" class="headerlink" title="一、无偏性"></a>一、无偏性</h5><p>估计的参数的值的期望是参数的真实值：</p>
<script type="math/tex; mode=display">
E(\hat \theta) = \theta</script><p><strong>无偏性保证没有系统误差，通俗说就是努力的大方向没错。</strong></p>
<p>一般将系统误差定义为：</p>
<script type="math/tex; mode=display">
E(\hat \theta) - \theta</script><p>1、总体X(<strong>任何分布均成立</strong>)，$E(X) = \mu,D(X) = \sigma^2$，样本为$X_1, X_2, \cdots, X_n$</p>
<ul>
<li>$\overline X$是$\mu$的无偏估计，因为$E(\overline X) = \mu$</li>
</ul>
<script type="math/tex; mode=display">
e_n = \dfrac{(x1+x2+...+xn)}{n}</script><script type="math/tex; mode=display">
E[e_n]=E\left[\frac{(x1+x2+...+xn)}{n}\right] =\frac{E(X1)+E(X2)+...+E(Xn)}{n} = E(X)</script><ul>
<li>(已修正)样本方差$S^2$是$\sigma^2$的无偏估计，这里可以大概解释为什么分母是$n-1$</li>
<li>(未修正)样本方差$S_0^2$是$\sigma^2$的有偏估计</li>
</ul>
<p>注意：$\hat \theta$是$\theta$的无偏估计，$g(\hat \theta)$不一定是$g(\theta)$的无偏估计</p>
<h5 id="二、有效性"><a href="#二、有效性" class="headerlink" title="二、有效性"></a>二、有效性</h5><p>估计的参数的值的方差越小就越有效</p>
<h5 id="三、相合性-一致性"><a href="#三、相合性-一致性" class="headerlink" title="三、相合性/一致性"></a>三、相合性/一致性</h5><p>也就是说样本取的越多，估计的参数的值与准确值也越近：</p>
<script type="math/tex; mode=display">
\lim_{n \to\infty} P(|\hat \theta - \theta| < \varepsilon) = 1, \forall \varepsilon > 0</script><h3 id="7-3-参数的区间估计"><a href="#7-3-参数的区间估计" class="headerlink" title="7.3 参数的区间估计"></a>7.3 参数的区间估计</h3><h4 id="7-3-1-置信区间、枢轴变量、区间估计的基本概念"><a href="#7-3-1-置信区间、枢轴变量、区间估计的基本概念" class="headerlink" title="7.3.1 置信区间、枢轴变量、区间估计的基本概念"></a>7.3.1 置信区间、枢轴变量、区间估计的基本概念</h4><h5 id="一、置信区间"><a href="#一、置信区间" class="headerlink" title="一、置信区间"></a>一、置信区间</h5><p>区间估计有两个重点——区间长度、以多大的概率落在该区间；这两个概念是相互矛盾的，区间长度越大，概率就越大，区间长度越小，概率就越小。</p>
<script type="math/tex; mode=display">
P(\hat \theta_1 \leq \theta \leq \hat \theta_2) = 1 - \alpha</script><p>上式表示，估计的区间为：$[\hat \theta_1 , \hat \theta_2]$，置信度为$1-\alpha$(置信度也就是通俗说的以多大的概率落在该区间)。</p>
<h5 id="二、枢轴变量"><a href="#二、枢轴变量" class="headerlink" title="二、枢轴变量"></a>二、枢轴变量</h5><p>1) 取$I = I(T, \theta)$，其中$\theta$是要估计的参数，$T$是已知的，$I$的分布F也要是已知的且与$\theta$无关；</p>
<p>2) 给定$1 - \alpha$，确定F的上$\dfrac{\alpha}{2}$分位数为$v_{\frac{\alpha}{2}}$，上$(1-\dfrac{\alpha}{2})$分位数为$v_{1-\frac{\alpha}{2}}$，则</p>
<script type="math/tex; mode=display">
P(v_{1-\frac{\alpha}{2}} \leq I(T, \theta) \leq v_{\frac{\alpha}{2}}) = 1-\alpha</script><h5 id="三、区间估计"><a href="#三、区间估计" class="headerlink" title="三、区间估计"></a>三、区间估计</h5><p>区间估计基本都是通过枢轴变量的方法来计算的。</p>
<h4 id="7-3-2-一个正态总体均值和方差的区间估计"><a href="#7-3-2-一个正态总体均值和方差的区间估计" class="headerlink" title="7.3.2 一个正态总体均值和方差的区间估计"></a>7.3.2 一个正态总体均值和方差的区间估计</h4><p>略。。。</p>
<h2 id="第八章-假设检验"><a href="#第八章-假设检验" class="headerlink" title="第八章 假设检验"></a>第八章 假设检验</h2><h3 id="8-1-假设检验的基本概念"><a href="#8-1-假设检验的基本概念" class="headerlink" title="8.1 假设检验的基本概念"></a>8.1 假设检验的基本概念</h3><h5 id="一、假设检验问题"><a href="#一、假设检验问题" class="headerlink" title="一、假设检验问题"></a>一、假设检验问题</h5><p>假设检验是<font color="red"><strong>统计推断</strong></font>的主要内容，统计推断有两大内容：</p>
<ul>
<li><strong>参数估计</strong>——点估计、区间估计</li>
<li><strong>假设检验</strong></li>
</ul>
<p>假设检验是解决这样一个问题：在数理统计中总体的分布通常是未知的，而这个未知包含两种情况【一是总体分布的类型未知】【二是总体分布已知但是参数未知】，然后我们对总体分布提出一种推断，就叫“假设”，根据上面的两种情况“假设”可分为【非参数假设】【参数假设】。假设完了之后我们要利用样本的信息检验假设是否正确，所以检验也分为两种【非参数假设检验】【参数假设检验】。总上就是“假设检验”。</p>
<p>提出假设：</p>
<ul>
<li>原/零假设$H_0$：不发生改变</li>
<li>备择假设$H_1$：发生改变的假设</li>
</ul>
<h5 id="二、假设检验的基本概念"><a href="#二、假设检验的基本概念" class="headerlink" title="二、假设检验的基本概念"></a>二、假设检验的基本概念</h5><p>1、我们对总体分布提出一种推断，就叫“假设”；</p>
<p>2、假设完了之后我们要利用样本的信息检验假设是否正确，就叫“假设检验”。</p>
<p>3、假设检验问题分为两种情况：</p>
<ul>
<li>显著性假设检验问题——只提出一个假设$H_0$，没有$H_1$；</li>
<li>$H_0$对$H_1$的假设问题。</li>
</ul>
<h5 id="三、假设检验的基本思想与步骤"><a href="#三、假设检验的基本思想与步骤" class="headerlink" title="三、假设检验的基本思想与步骤"></a>三、假设检验的基本思想与步骤</h5><p><strong>1、基本思想</strong></p>
<p>从样本出发，构造一个检验统计量T，用来检验$H_0$成立与否。假定$H_0$成立，那么T的(近似)分布就已知了，然后根据<font color="red"><strong>检验法则</strong></font>（小概率事件在一次抽样中不可能发生），可以表达为：</p>
<script type="math/tex; mode=display">
P\begin{Bmatrix}(X_1, X_2, \cdots, X_n) \sub W \end{Bmatrix} = \alpha</script><script type="math/tex; mode=display">
P\begin{Bmatrix}(X_1, X_2, \cdots, X_n) \sub \overline W \end{Bmatrix} =1- \alpha</script><p>若第一个式子成立，就说明小概率事件在一次抽样中发生了，说明我们要拒绝假设$H_0$，此时$W$就叫做$H_0$的拒绝域；</p>
<p>若第二个式子成立，就说明小概率事件在一次抽样中没有发生了，说明我们要接收假设$H_0$，此时$\overline W$就叫做$H_0$的接受域；</p>
<p><strong>2、步骤</strong></p>
<ul>
<li>提出假设$H_0、H_1$；</li>
<li>假定$H_0$成立，选取统计量T(T的分布已知)；</li>
<li>对于给定的$\alpha$，我们关注小概率事件；</li>
<li>由样本值求出统计量T的值，看是否发生小概率事件。</li>
</ul>
<blockquote>
<p>注意双侧检验与单侧检验</p>
</blockquote>
<h5 id="四、假设检验存在的两类错误"><a href="#四、假设检验存在的两类错误" class="headerlink" title="四、假设检验存在的两类错误"></a>四、假设检验存在的两类错误</h5><p>第一类错误：弃真——即实际上$H_0$为真，但却拒绝掉了；</p>
<p>犯第一类错误的概率：$P(拒绝H_0|H_0为真) = \alpha$ </p>
<p>第二类错误：取伪——即实际上$H_0$为假，但接受了；</p>
<p>犯第二类错误的概率：$P(接收H_0|H_0为假) = \beta$ </p>
<p><img src="https://pic.imgdb.cn/item/622718cf5baa1a80ab41bd2b.jpg"></p>
<h3 id="8-2-一个正态总体的参数假设检验"><a href="#8-2-一个正态总体的参数假设检验" class="headerlink" title="8.2 一个正态总体的参数假设检验"></a>8.2 一个正态总体的参数假设检验</h3><h2 id="第九章-我的问题"><a href="#第九章-我的问题" class="headerlink" title="第九章 我的问题"></a>第九章 我的问题</h2><h3 id="A-随机变化的量与随机变量"><a href="#A-随机变化的量与随机变量" class="headerlink" title="A. 随机变化的量与随机变量"></a>A. 随机变化的量与随机变量</h3><p>参考链接：<a href="https://blog.sciencenet.cn/blog-3418723-1317469.html">https://blog.sciencenet.cn/blog-3418723-1317469.html</a></p>
<h3 id="B-为什么总体和样本都是随机变量"><a href="#B-为什么总体和样本都是随机变量" class="headerlink" title="B. 为什么总体和样本都是随机变量"></a>B. 为什么总体和样本都是随机变量</h3><p>参考链接：<a href="https://www.zhihu.com/question/301826927">https://www.zhihu.com/question/301826927</a></p>
<h3 id="C-为什么样本可以看成是同分布的随机变量"><a href="#C-为什么样本可以看成是同分布的随机变量" class="headerlink" title="C. 为什么样本可以看成是同分布的随机变量"></a>C. 为什么样本可以看成是同分布的随机变量</h3><p>参考链接：<a href="https://wap.sciencenet.cn/blog-405700-573544.html?mobile=1">https://wap.sciencenet.cn/blog-405700-573544.html?mobile=1</a></p>
<h3 id="D-如何理解一个总体就是一个具有确定概率分布的随机变量"><a href="#D-如何理解一个总体就是一个具有确定概率分布的随机变量" class="headerlink" title="D. 如何理解一个总体就是一个具有确定概率分布的随机变量"></a>D. 如何理解一个总体就是一个具有确定概率分布的随机变量</h3><p>实际问题中的总体,都对应着具体的指标，而这一指标取值或取某一范围内的值的比例(或可能性)是客观存在且确定的，因此一个总体可以看成一个具有确定概率分布的随机变量。</p>
<h3 id="E-为什么样本方差自由度-分母-为-n-1"><a href="#E-为什么样本方差自由度-分母-为-n-1" class="headerlink" title="E. 为什么样本方差自由度(分母)为$n-1$"></a>E. 为什么样本方差自由度(分母)为$n-1$</h3><h5 id="1、什么是自由度"><a href="#1、什么是自由度" class="headerlink" title="1、什么是自由度"></a>1、什么是自由度</h5><p>要理解样本方差的自由度为什么是$n-1$，得先理解自由度的概念：</p>
<p>自由度，是指附加给独立的观测值的约束或限制的个数，即一组数据中可以自由取值的个数。所谓自由取值，是指抽样时选取样本，也就是说：只有当以样本的统计量来估计总体的参数时才有自由度的概念，直接统计总体参数时是没有自由度概念的。 </p>
<p>自由度概念，是为了在通过样本进行参数估计时，剔除系统误差，实现无偏估计。</p>
<p>设$\hat A = g(X_1, X_2, …, X_n)$是未知参数$A$的一个点估计量，若$\hat A$满足$E(\hat A）= A$ ，则称$E(\hat A)$是$A$的无偏估计量，否则为有偏估计量。所以，<strong>无偏估计就是系统误差为零的估计</strong>。</p>
<h5 id="2、详解自由度"><a href="#2、详解自由度" class="headerlink" title="2、详解自由度"></a>2、详解自由度</h5><p>当样本数据的个数为$n$时，若样本平均数$\overline X$ 确定后，则附加给$n$个观测值的约束个数就是1个，一次只有$n-1$个数据可以自由取值，其中必有一个数据不能自由取值。按照这一逻辑，如果对$n$个观测值附加的约束个数为$k$个，自由度则为$n-k$。</p>
<p>例如假设样本有3个值，即$x_1=2, x_2=4, x_3=9$，则当$\overline X =5$确定后，$x_1、x_2、x_3$只有两个数据可以自由取值，另一个则不能自由取值，比如$x_1=6, x_2=7$,那么$x_3$必然取2，而不能取其他值。</p>
<p>样本方差自由度为什么为$n-1$呢，因为在计算离差平方和 $∑(X_i -\overline X)^2$ 时，必须先求出样本平均数$\overline X$，而$\overline X$ 则是附加给 $∑(X_i -\overline X)^2$的一个约束，因此，计算离差平方和时只有$n-1$个独立的观测值，而不是$n$个。</p>
<p>参考链接：<a href="https://www.cnblogs.com/ohshit/p/5590629.html">https://www.cnblogs.com/ohshit/p/5590629.html</a></p>
<p>参考链接：<a href="https://www.zhihu.com/question/22983179/answer/404391738">https://www.zhihu.com/question/22983179/answer/404391738</a> </p>
<p>参考链接：<a href="https://www.matongxue.com/madocs/607/">https://www.matongxue.com/madocs/607/</a></p>
<p>参考链接：<a href="https://www.zhihu.com/question/30440035">https://www.zhihu.com/question/30440035</a></p>
<p>参考链接：<a href="https://www.zhihu.com/question/20099757">为什么样本方差（sample variance）的分母是 n-1？ - 知乎 (zhihu.com)</a> </p>
<p>参考链接：<a href="http://www.noobyard.com/article/p-emeczand-nh.html">http://www.noobyard.com/article/p-emeczand-nh.html</a></p>
<p>参考链接：<a href="https://www.hanspub.org/journal/PaperInformation.aspx?paperID=41815">https://www.hanspub.org/journal/PaperInformation.aspx?paperID=41815</a></p>
<p>参考链接：<a href="https://zhuanlan.zhihu.com/p/138136495">样本方差分母为n-1的看法</a>【重要】</p>
<h3 id="F-如何理解统计学中「自由度」这个概念？"><a href="#F-如何理解统计学中「自由度」这个概念？" class="headerlink" title="F. 如何理解统计学中「自由度」这个概念？"></a>F. 如何理解统计学中「自由度」这个概念？</h3><p>参考链接：<a href="https://www.zhihu.com/question/20983193">https://www.zhihu.com/question/20983193</a></p>
<p>参考链接：<a href="https://www.ltncg.com/info/%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E7%94%B1%E5%BA%A6%2C%E6%80%8E%E4%B9%88%E6%95%B0%E8%87%AA%E7%94%B1%E5%BA%A6.html">https://www.ltncg.com/info/%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E7%94%B1%E5%BA%A6%2C%E6%80%8E%E4%B9%88%E6%95%B0%E8%87%AA%E7%94%B1%E5%BA%A6.html</a></p>
<h3 id="G-为什么总是把样本方差计算公式中的分母n-1跟自由度扯上关系？"><a href="#G-为什么总是把样本方差计算公式中的分母n-1跟自由度扯上关系？" class="headerlink" title="G. 为什么总是把样本方差计算公式中的分母n-1跟自由度扯上关系？"></a>G. 为什么总是把样本方差计算公式中的分母n-1跟自由度扯上关系？</h3><p>样本方差计算公式中的分母n-1跟自由度可能是刚好相同，结果“自由度”就被用去解释n-1了。现在很多人能够说清楚分母用n是不对的，但是却说不清为什么用n-1，所以就往自由度上扯。</p>
<p>这里除以n-1大概率因为是因为这个能做出个无偏估计</p>
<p>但是这个n-1和那个关于变量的能自由变化的自由度n-1是否有关系?</p>
<p>感觉是有的，因为很多更复杂的统计量的无偏估计和自由度居然也有这么和谐的等同关系</p>
<p>集合测试：$\Omega = \begin{Bmatrix} 1, 2, 3 \end{Bmatrix}​$、$\begin{Bmatrix} 1, 2, 3 \end{Bmatrix}​$</p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p>[1]B站宋浩视频 <a href="https://www.bilibili.com/video/BV1ot411y7mU">https://www.bilibili.com/video/BV1ot411y7mU</a></p>
<p>[2]书籍目录 <a href="https://www.taobao.com/list/item/610183739684.htm">https://www.taobao.com/list/item/610183739684.htm</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>数学基础</category>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>概率基础</tag>
        <tag>概率论学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Python其他小知识</title>
    <url>/2022/04/25/Python-code-tips/</url>
    <content><![CDATA[<h2 id="一、编码格式规范"><a href="#一、编码格式规范" class="headerlink" title="一、编码格式规范"></a>一、编码格式规范</h2><h3 id="1-编码"><a href="#1-编码" class="headerlink" title="1 编码"></a>1 编码</h3><p>无特殊情况，建议Python脚本程序一律使用 UTF-8 编码，并且在文件头部必须加入<code>#-*-coding:utf-8-*-</code>标识，声明文件编码方式，程序文件编码要和声明编码保持一致。 </p>
<h3 id="2-代码格式"><a href="#2-代码格式" class="headerlink" title="2 代码格式"></a>2 代码格式</h3><ul>
<li>缩进： 统一使用 4 个空格进行缩进。（默认一个tab键就是4个空格，有时程序格式问题可能出现在这里，tab键不一定就是4个空格）</li>
<li>行宽： 每行代码尽量不超过 80 个字符(在特殊情况下可以略微超过 80 ，但最长不得超过 120)。如果代码过长，说明代码设计方面可能不合理。除此之外也方便在控制台查看代码(linux)以及通过对side-by-side的diff时有帮助。</li>
<li>引号：自然语言，也就是说一般使用双引号；机器标示使用单引号，例如字典中的key，正则表达式使用原生的双引号 r”…”；文档字符串 (docstring) 使用三个双引号 “”” ……”””。当然实际中需要灵活运用，毕竟三种引号使用是有区别的。</li>
<li><strong>空行：</strong><ul>
<li>模块级函数和类定义之间空两行；</li>
<li>类成员函数之间空一行；</li>
</ul>
</li>
</ul>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="comment"># one line</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># one line</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># one line</span></span><br><span class="line"><span class="comment"># one line</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">pass</span>   </span><br></pre></td></tr></table></figure>
<h3 id="3-import语句"><a href="#3-import语句" class="headerlink" title="3 import语句"></a>3 import语句</h3><ul>
<li>import 语句应该分行书写；</li>
<li>import语句应该放在文件头部，置于模块说明及docstring之后，于全局变量之前；</li>
<li>import语句应该按照顺序排列，每组之间用一个空行分隔(也就是说同一类型的在一块)；</li>
<li>导入其他模块的类定义时，可以使用相对导入；</li>
</ul>
<h3 id="4-空格使用"><a href="#4-空格使用" class="headerlink" title="4 空格使用"></a>4 空格使用</h3><h5 id="1-在二元运算符两边各空一格-gt-in-is-not-and"><a href="#1-在二元运算符两边各空一格-gt-in-is-not-and" class="headerlink" title="(1) 在二元运算符两边各空一格[=,-,+=,==,&gt;,in,is not, and]"></a>(1) 在二元运算符两边各空一格[=,-,+=,==,&gt;,in,is not, and]</h5><ul>
<li>函数的参数列表中，<code>,</code>之后要有空格</li>
<li>函数的参数列表中，默认值等号两边不要添加空格</li>
<li>左括号之后，右括号之前不要加多余的空格</li>
<li>字典对象的左括号之前不要多余的空格</li>
<li>不要为对齐赋值语句而使用的额外空格</li>
</ul>
<h3 id="5-换行"><a href="#5-换行" class="headerlink" title="5 换行"></a>5 换行</h3><p><strong>Python 支持括号内的换行</strong>。这时有两种情况，如下：</p>
<p><strong>(1) 第二行缩进到括号的起始处</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">foo = long_function_name(var_one, var_two,</span><br><span class="line">                         var_three, var_four)</span><br></pre></td></tr></table></figure>
<p><strong>(2) 第二行缩进 4 个空格，适用于起始括号就换行的情</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_function_name</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        var_one, var_two, var_three,</span></span></span><br><span class="line"><span class="params"><span class="function">        var_four</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(var_one)</span><br></pre></td></tr></table></figure>
<p><strong>(3) 使用反斜杠\换行</strong></p>
<p>二元运算符<code>+</code> 、<code>.</code>等应出现在行末；长字符串也可以用此法换行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">session.query(MyTable).\</span><br><span class="line">        filter_by(<span class="built_in">id</span>=<span class="number">1</span>).\</span><br><span class="line">        one()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Hello, &#x27;</span>\</span><br><span class="line">      <span class="string">&#x27;%s %s!&#x27;</span> %\</span><br><span class="line">      (<span class="string">&#x27;Harry&#x27;</span>, <span class="string">&#x27;Potter&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>(4) 禁止复合语句</strong></p>
<p> 即一行中包含多个语句： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正确的写法</span></span><br><span class="line">do_first()</span><br><span class="line">do_second()</span><br><span class="line">do_third()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不推荐的写法</span></span><br><span class="line">do_first();do_second();do_third();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-注释"><a href="#6-注释" class="headerlink" title="6 注释"></a>6 注释</h3><p><strong>块注释</strong> ：“#”号后空一格，段落件用空行分开（同样需要“#”号）</p>
<p><strong>行注释：</strong> 至少使用两个空格和语句分开，不要使用无意义的注释 </p>
<p><strong>补充：</strong> 在代码的关键部分(或比较复杂的地方), 能写注释的要尽量写注释；比较重要的注释段, 使用多个等号隔开, 可以更加醒目, 突出重要性。 </p>
<h3 id="7-命名规范"><a href="#7-命名规范" class="headerlink" title="7 命名规范"></a>7 命名规范</h3><p><strong>模块</strong>： 模块尽量使用小写命名，首字母保持小写，尽量不要用下划线(除非多个单词，且数量不多的情况)</p>
<p><strong>类名</strong>： 类名使用驼峰(CamelCase)命名风格，首字母大写，私有类可用一个下划线开头；将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Farm</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalFarm</span>(<span class="params">Farm</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_PrivateFarm</span>(<span class="params">Farm</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>函数名：</strong></p>
<p>函数名一律小写，如有多个单词，用<strong>下划线</strong>隔开；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_with_env</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><strong>变量名</strong></p>
<ul>
<li>变量名尽量小写, 如有多个单词，用下划线隔开</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    school_name = <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常量采用全大写，如有多个单词，使用下划线隔开</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MAX_CLIENT = <span class="number">100</span></span><br><span class="line">MAX_CONNECTION = <span class="number">1000</span></span><br><span class="line">CONNECTION_TIMEOUT = <span class="number">600</span></span><br></pre></td></tr></table></figure>
<p>【参考资料1】：<a href="https://blog.csdn.net/meiqi0538/article/details/104993760">【Python】编程代码书写规范！ -  科皮子菊 - CSDN</a></p>
<p>【参考资料2】：<a href="https://python.freelycode.com/contribution/detail/47">PEP8中文版 — Python编码风格指南</a></p>
<h2 id="二、深度学习的相关库"><a href="#二、深度学习的相关库" class="headerlink" title="二、深度学习的相关库"></a>二、深度学习的相关库</h2><p><img src="https://pic.imgdb.cn/item/66778500d9c307b7e9f7a3df.png"></p>
<p>① NumPy 包为Python 加上了关键的数组变量类型，弥补了Python 的不足；<br>② Pandas 包在NumPy 数组的基础上添加了与Excel 类似的行列标签；<br>③ Matplotlib 库借鉴Matlab，帮Python 具备了绘图能力，使其如虎添翼；<br>④ Scikit-learn 库是机器学习库，内含分类、回归、聚类、降维等多种算法；<br>⑤ TensorFlow 库是Google 公司开发的深度学习框架，于2015 年问世；<br>⑥ PyTorch 库是Facebook 公司开发的深度学习框架，于2017 年问世。</p>
<h3 id="2-1-Numpy学习"><a href="#2-1-Numpy学习" class="headerlink" title="2.1 Numpy学习"></a>2.1 Numpy学习</h3><div class="bvideo">
    <a href="//www.bilibili.com/video/BV1Wy4y1h7ii" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/ab719949488afaf673a171c1b2ae61f525450b12.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:08:44</span>
            </div>
            <div class="bvideo-info">
                <p class="title">一个10分钟的numpy入门教程</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>22.9万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>402</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">奇乐编程学院</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1Ym4y1U7at" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/6394a64929382e1451f20ed843a1091df68d121e.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">01:17:48</span>
            </div>
            <div class="bvideo-info">
                <p class="title">巨硬的Numpy：从小白到入门</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>3.5万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>13</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">二次元的Datawhale</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div> 
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1H84y1g7RE" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/244825726856d4162d887d1cb68d6daa7a86e188.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">01:15:19</span>
            </div>
            <div class="bvideo-info">
                <p class="title">Python深度学习：NumPy数组库</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>12.4万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>815</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">爆肝杰哥</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<h4 id="2-1-1-数组基础"><a href="#2-1-1-数组基础" class="headerlink" title="2.1.1 数组基础"></a>2.1.1 数组基础</h4><p>导入NumPy 时，通常给其一个别名“np”，即<code>import numpy as np</code>。<br>NumPy 库中的函数，要在函数名前加上导入的库名 np. 才能使用。</p>
<h5 id="Ⅰ数据类型"><a href="#Ⅰ数据类型" class="headerlink" title="Ⅰ数据类型"></a>Ⅰ数据类型</h5><p><strong>(1) 整数型数组与浮点型数组</strong></p>
<p>python中的列表存在缺点，列表内的每一个元素可以是不同的数据类型。为克服列表的缺点，一个NumPy数组只<strong>容纳一种数据类型</strong>，以节约内存。为方便起见，可将NumPy数组简单分为<strong>整数型数组</strong>与<strong>浮点型数组</strong>。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 利用np.array将python的list转化为Numpy数组，产生一个实例化类对象，如下面的arr1、arr2，</span></span><br><span class="line"><span class="comment"># 实例化对象里面有许多可以调用的成员方法，例如 .astype( )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建整数型数组：</span></span><br><span class="line">arr1 = np.array( [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] ) <span class="comment"># 元素若都是整数，则为整数型数组</span></span><br><span class="line"><span class="built_in">print</span>(arr1)	<span class="comment"># 输出 [1 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建浮点型数组：</span></span><br><span class="line">arr2 = np.array( [<span class="number">1.0</span>, <span class="number">2</span>, <span class="number">3</span>] ) <span class="comment"># 内含浮点数，则为浮点型数组</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># 输出 [1. 2. 3.]</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 整数型数组和浮点型数组相互转换</strong></p>
<p>规范的方法是使用<code>.astype( )</code>方法。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 整数型数组</span></span><br><span class="line">arr1 = np.array( [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] )</span><br><span class="line"><span class="built_in">print</span>(arr1)	<span class="comment"># 输出 [1 2 3]</span></span><br><span class="line"><span class="comment"># 整数型数组 ——&gt; 浮点型数组</span></span><br><span class="line">arr2 = arr1.astype(<span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># 输出 [1. 2. 3.]</span></span><br><span class="line"><span class="comment"># 浮点型数组 ——&gt; 整数型数组</span></span><br><span class="line">arr3 = arr2.astype(<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(arr3) <span class="comment"># 输出 [1 2 3]</span></span><br></pre></td></tr></table></figure>
<p>整数型数组在程序的运算中会很容易变成浮点型，但浮点型数组在运算过程中一般不会降级为整数型。</p>
<h5 id="Ⅱ-数组维度"><a href="#Ⅱ-数组维度" class="headerlink" title="Ⅱ 数组维度"></a>Ⅱ 数组维度</h5><p><strong>(1) 一维数组与二维数组</strong><br>考虑到深度学习中三维及其以上的数组出现次数少，后续主要讲解NumPy 中的一维数组和二维数组，学了一维和二维后，很好类推到三维。</p>
<ul>
<li>不同维度的数组之间，从外形上的本质区别是<ul>
<li>一维数组使用1层<strong>中括号</strong>表示；</li>
<li>二维数组使用2层<strong>中括号</strong>表示；</li>
<li>三维数组使用3层<strong>中括号</strong>表示。</li>
</ul>
</li>
<li>有些函数需要传入数组的形状参数，不同维度数组的形状参数为<ul>
<li>一维数组的形状参数形如： x 或 (x,) ；</li>
<li>二维数组的形状参数形如： (x,y) ；</li>
<li>三维数组的形状参数形如： (x,y,z) 。</li>
</ul>
</li>
<li>现在以同一个序列进行举例<ul>
<li>当数组有1 层中括号，如[1 2 3]，则其为一维数组，其形状是 3 或 (3,) ；</li>
<li>当数组有2 层中括号，如[[1 2 3]]，则其为二维数组，其形状是 (1,3) ；</li>
<li>当数组有3 层中括号，如[[[1 2 3]]]，则其为三维数组，其形状是 (1,1,3) ；</li>
</ul>
</li>
</ul>
<p>这里用后面要讲的<code>np.ones( )</code>函数进行演示，只因其刚好需要传入形状参数。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr1 = np.ones(<span class="number">3</span>) <span class="comment"># 传入形状3</span></span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># 造出一维数组 [1. 1. 1.]</span></span><br><span class="line"></span><br><span class="line">arr2 = np.ones((<span class="number">1</span>,<span class="number">3</span>)) <span class="comment"># 传入形状(1,3)</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># 造出二维数组 [[1. 1. 1.]]</span></span><br><span class="line"></span><br><span class="line">arr3 = np.ones((<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>)) <span class="comment"># 传入形状(1,1,3)</span></span><br><span class="line"><span class="built_in">print</span>(arr3) <span class="comment"># 造出三维数组 [[[1. 1. 1.]]]</span></span><br></pre></td></tr></table></figure>
<p>同时，我们还可以使用数组的<code>.shape</code> 属性查看arr1和arr2的形状。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>( arr1.shape ) <span class="comment"># 输出 (3,)</span></span><br><span class="line"><span class="built_in">print</span>( arr2.shape ) <span class="comment"># 输出(1, 3)</span></span><br><span class="line"><span class="built_in">print</span>( arr3.shape ) <span class="comment"># 输出(1, 1, 3)</span></span><br></pre></td></tr></table></figure>
<p>大家可以随时留意一下数组的维度（通过中括号的数量），后面有些函数（比如数组的拼接函数）需要两个数组是同维度的。</p>
<p><strong>(2) 不同维度数组之间的转换</strong><br>一维数组转二维数组，还是二维数组转一维数组，均要使用的是数组的重塑方法<code>.reshape( )</code> ，该方法需要传入重塑后的形状（shape）参数。<br>这个方法神奇的是，给定了其他维度的数值，剩下一个维度可以填-1，让它<strong>自己去计算</strong>。比如把一个5 行6 列的矩阵重塑为3 行10 列的矩阵，当列的参数10告诉它，行的参数直接可以用-1 来替代，它会自己去用30 除以10 来计算。</p>
<p>示例1：将一维数组升级为二维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一维数组</span></span><br><span class="line">arr1 = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># 输出[0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级为二维数组</span></span><br><span class="line">arr2 = arr1.reshape( (<span class="number">1</span>,-<span class="number">1</span>) )</span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [[0 1 2 3 4 5 6 7 8 9]]</span></span><br></pre></td></tr></table></figure>
<p>示例2：将二维数组降级为一维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建二维数组</span></span><br><span class="line">arr2 = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># 输出 [[0 1 2 3 4]</span></span><br><span class="line"><span class="comment">#       [5 6 7 8 9]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 降级为一维数组</span></span><br><span class="line">arr1 = arr2.reshape( -<span class="number">1</span> )</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="comment"># 输出 [0 1 2 3 4 5 6 7 8 9]</span></span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-数组的创建"><a href="#2-1-2-数组的创建" class="headerlink" title="2.1.2 数组的创建"></a>2.1.2 数组的创建</h4><h5 id="Ⅰ-创建指定数组"><a href="#Ⅰ-创建指定数组" class="headerlink" title="Ⅰ 创建指定数组"></a>Ⅰ 创建指定数组</h5><p>当明确知道数组每一个元素的具体数值时，可以使用<code>np.array( )</code>函数，将Python列表转化为NumPy数组。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一维数组——向量</span></span><br><span class="line">arr1 = np.array( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] )</span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [1 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建二维数组——行矩阵</span></span><br><span class="line">arr2 = np.array( [ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ] )</span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [[1 2 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建二维数组——列矩阵</span></span><br><span class="line">arr3 = np.array( [ [<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>] ] )</span><br><span class="line"><span class="built_in">print</span>(arr3)</span><br><span class="line"><span class="comment"># [[1]</span></span><br><span class="line"><span class="comment">#  [2]</span></span><br><span class="line"><span class="comment">#  [3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建二维数组——矩阵</span></span><br><span class="line">arr4 = np.array( [ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] ] )</span><br><span class="line"><span class="built_in">print</span>(arr4)</span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-创建递增数组"><a href="#Ⅱ-创建递增数组" class="headerlink" title="Ⅱ 创建递增数组"></a>Ⅱ 创建递增数组</h5><p>递增数组使用 <code>np.arange( )</code> 函数进行创建（arange 全称是array_range）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 递增数组</span></span><br><span class="line">arr1 = np.arange(<span class="number">10</span>) <span class="comment"># 从0 开始，到10 之前结束</span></span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递增数组</span></span><br><span class="line">arr2 = np.arange(<span class="number">10</span>, <span class="number">20</span>) <span class="comment"># 从10 开始，到20 之前结束</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [10 11 12 13 14 15 16 17 18 19]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递增数组</span></span><br><span class="line">arr3 = np.arange(<span class="number">1</span>,<span class="number">21</span>,<span class="number">2</span>) <span class="comment"># 从1 开始，到21 之前结束，步长为2</span></span><br><span class="line"><span class="built_in">print</span>(arr3) <span class="comment"># [1 3 5 7 9 11 13 15 17 19]</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅲ-创建同值数组"><a href="#Ⅲ-创建同值数组" class="headerlink" title="Ⅲ 创建同值数组"></a>Ⅲ 创建同值数组</h5><p>需要创建同值数组时，使用 <code>np.zeros( )</code> 函数以及 <code>np.ones( )</code> 函数，如示例。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全0 数组</span></span><br><span class="line">arr1 = np.zeros( <span class="number">3</span> ) <span class="comment"># 形状为3 的向量</span></span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [0. 0. 0.]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全1 数组</span></span><br><span class="line">arr2 = np.ones( (<span class="number">1</span>,<span class="number">3</span>) ) <span class="comment"># 形状为(1,3)的矩阵</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [[1. 1. 1.]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全3.14 数组</span></span><br><span class="line">arr3 = <span class="number">3.14</span> * np.ones( (<span class="number">2</span>,<span class="number">3</span>) ) <span class="comment"># 形状为(2,3)的矩阵</span></span><br><span class="line"><span class="built_in">print</span>(arr3)</span><br><span class="line"><span class="comment"># [[3.14 3.14 3.14]</span></span><br><span class="line"><span class="comment">#  [3.14 3.14 3.14]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Ⅳ-创建随机数组"><a href="#Ⅳ-创建随机数组" class="headerlink" title="Ⅳ 创建随机数组"></a>Ⅳ 创建随机数组</h5><p>有时需要创建随机数组，那么可以使用 <code>np.random</code> 系列函数，如示例所示。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0-1 均匀分布的浮点型随机数组</span></span><br><span class="line">arr1 = np.random.random( <span class="number">5</span> ) <span class="comment"># 形状为5 的向量</span></span><br><span class="line"><span class="built_in">print</span>( arr1 ) <span class="comment"># [0.59699399 0.89113584 0.00695752 0.49089431 0.32050609]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数型随机数组</span></span><br><span class="line">arr2 = np.random.randint( <span class="number">10</span>,<span class="number">100</span>,(<span class="number">1</span>,<span class="number">15</span>) ) <span class="comment"># 范围为10~100的形状为(1,15)的矩阵</span></span><br><span class="line"><span class="built_in">print</span>( arr2 ) <span class="comment"># [[17 65 54 48 82 57 52 26 28 27 53 36 61 92 13]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服从正态分布的随机数组</span></span><br><span class="line">arr3 = np.random.normal( <span class="number">0</span>,<span class="number">1</span>,(<span class="number">2</span>,<span class="number">3</span>) ) <span class="comment"># 均值为0、标准差为1的形状为(2,3)的二维高斯矩阵</span></span><br><span class="line"><span class="built_in">print</span>( arr3 )</span><br><span class="line"><span class="comment"># [[-0.43163964 -1.56817412 0.5460523 ]</span></span><br><span class="line"><span class="comment">#  [-2.93093358 0.42577899 -1.69842077]]</span></span><br></pre></td></tr></table></figure>
<h4 id="2-1-3-数组的索引"><a href="#2-1-3-数组的索引" class="headerlink" title="2.1.3 数组的索引"></a>2.1.3 数组的索引</h4><h5 id="Ⅰ-访问数组元素"><a href="#Ⅰ-访问数组元素" class="headerlink" title="Ⅰ 访问数组元素"></a>Ⅰ 访问数组元素</h5><p>与Python列表一致，访问NumPy数组元素时使用<strong>中括号</strong>，索引由0开始。</p>
<p><strong>(1) 访问向量(一维数组)</strong></p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建向量</span></span><br><span class="line">arr1 = np.arange( <span class="number">1</span>,<span class="number">10</span> )</span><br><span class="line"><span class="built_in">print</span>( arr1 ) <span class="comment"># [1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line"><span class="built_in">print</span>( arr1[<span class="number">3</span>] ) <span class="comment"># 正着访问 4</span></span><br><span class="line"><span class="built_in">print</span>( arr1[-<span class="number">1</span>] ) <span class="comment"># 倒着访问 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改数组元素</span></span><br><span class="line">arr1[<span class="number">3</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">print</span>( arr1 ) <span class="comment"># [1 2 3 100 5 6 7 8</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 访问矩阵</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建矩阵</span></span><br><span class="line">arr2 = np.array( [ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] ] )</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line"><span class="built_in">print</span>( arr2[<span class="number">0</span>,<span class="number">2</span>] ) <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>( arr2[<span class="number">1</span>,-<span class="number">2</span>] )<span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改元素</span></span><br><span class="line">arr2[<span class="number">1</span>,<span class="number">1</span>] = <span class="number">100.9</span></span><br><span class="line"><span class="built_in">print</span>( arr2 ) <span class="comment"># 浮点数100.9 插入到整数型数组时被截断了</span></span><br><span class="line"><span class="comment"># [[001 002 003]</span></span><br><span class="line"><span class="comment">#  [004 100 006]]</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-花式索引"><a href="#Ⅱ-花式索引" class="headerlink" title="Ⅱ 花式索引"></a>Ⅱ 花式索引</h5><p>花式索引（Fancy indexing）又名“花哨的索引”，上一小节访问单个元素时，向量用arr1[x]，矩阵用arr2[x,y]。逗号在矩阵里用于区分行与列，这一小节，逗号新增一个功能，且不会与矩阵里的逗号混淆。<br><strong>普通索引用一层中括号，花式索引用两层中括号</strong>。</p>
<p><strong>(1) 向量的花式索引</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建向量</span></span><br><span class="line">arr1 = np.arange(<span class="number">0</span>,<span class="number">90</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [ 0 10 20 30 40 50 60 70 80]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 花式索引</span></span><br><span class="line"><span class="built_in">print</span>( arr1[ [<span class="number">0</span>,<span class="number">2</span>] ] ) <span class="comment"># [0 20]</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 矩阵的花式索引</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建矩阵</span></span><br><span class="line">arr2 = np.arange(<span class="number">1</span>,<span class="number">17</span>).reshape(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># [[01 02 03 04]</span></span><br><span class="line"><span class="comment">#  [05 06 07 08]</span></span><br><span class="line"><span class="comment">#  [09 10 11 12]</span></span><br><span class="line"><span class="comment">#  [13 14 15 16]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 花式索引</span></span><br><span class="line"><span class="built_in">print</span>( arr2[ [<span class="number">0</span>,<span class="number">1</span>] , [<span class="number">0</span>,<span class="number">1</span>] ] ) <span class="comment"># [1 6]</span></span><br><span class="line"><span class="built_in">print</span>( arr2[ [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>] , [<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>] ] ) <span class="comment"># [3 6 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改数组元素</span></span><br><span class="line">arr2[ [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] , [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>] ] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># [[001 002 003 100]</span></span><br><span class="line"><span class="comment">#  [005006 100 008]</span></span><br><span class="line"><span class="comment">#  [009 100 011 012]</span></span><br><span class="line"><span class="comment">#  [100 014 015 016]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/667793a7d9c307b7e91154c9.png"></p>
<p>根据以上实例，花式索引输出的仍然是一个向量。</p>
<h5 id="Ⅲ-访问数组切片"><a href="#Ⅲ-访问数组切片" class="headerlink" title="Ⅲ 访问数组切片"></a>Ⅲ 访问数组切片</h5><p><strong>(1) 向量的切片</strong></p>
<p>向量与列表切片的操作完全一致，因此本页内容在Python 基础中均有涉及。</p>
<p><img src="https://pic.imgdb.cn/item/667793f2d9c307b7e911deb7.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr1 = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>( arr1 ) <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当明确知道从第x个元素切到第y个元素，如示例所示。</span></span><br><span class="line"><span class="built_in">print</span>( arr1[ <span class="number">1</span> : <span class="number">4</span> ] ) <span class="comment"># 从索引[1]开始，切到索引[4]之前 [1 2 3]</span></span><br><span class="line"><span class="built_in">print</span>( arr1[ <span class="number">1</span> : ] ) <span class="comment"># 从索引[1]开始，切到结尾 [1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"><span class="built_in">print</span>( arr1[ : <span class="number">4</span> ] ) <span class="comment"># 从数组开头开始，切到索引[4]之前 [0 1 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当明确切除数组的开头与结尾，如示例所示。</span></span><br><span class="line"><span class="built_in">print</span>( arr1[ <span class="number">2</span> : -<span class="number">2</span> ] ) <span class="comment"># 切除开头2个和结尾2个 [2 3 4 5 6 7]</span></span><br><span class="line"><span class="built_in">print</span>( arr1[ <span class="number">2</span> : ] ) <span class="comment"># 切除开头2个 [2 3 4 5 6 7 8 9]</span></span><br><span class="line"><span class="built_in">print</span>( arr1[ : -<span class="number">2</span> ] ) <span class="comment"># 切除结尾2个 [0 1 2 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当明确隔几个元素采样一次时，示例如下。</span></span><br><span class="line"><span class="built_in">print</span>( arr1[ : : <span class="number">2</span> ] ) <span class="comment"># 每2 个元素采样一次 [0 2 4 6 8]</span></span><br><span class="line"><span class="built_in">print</span>( arr1[ : : <span class="number">3</span> ] ) <span class="comment"># 每3 个元素采样一次 [0 3 6 9]</span></span><br><span class="line"><span class="built_in">print</span>( arr1[ <span class="number">1</span> : -<span class="number">1</span> : <span class="number">2</span> ] ) <span class="comment"># 切除一头一尾后，每2个元素采样一次 [1 3 5 7]</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 矩阵的切片</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr2 = np.arange(<span class="number">1</span>,<span class="number">21</span>).reshape(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>( arr2 )</span><br><span class="line"><span class="comment"># [[01 02 03 04 05]</span></span><br><span class="line"><span class="comment">#  [06 07 08 09 10]</span></span><br><span class="line"><span class="comment">#  [11 12 13 14 15]</span></span><br><span class="line"><span class="comment">#  [16 17 18 19 20]]</span></span><br><span class="line"><span class="built_in">print</span>( arr2[ <span class="number">1</span>:<span class="number">3</span> , <span class="number">1</span>:-<span class="number">1</span> ] )</span><br><span class="line"><span class="comment"># [[07 08 09]</span></span><br><span class="line"><span class="comment">#  [12 13 14]]</span></span><br><span class="line"><span class="built_in">print</span>( arr2[ ::<span class="number">3</span> , ::<span class="number">2</span> ] ) <span class="comment"># 跳跃采样</span></span><br><span class="line"><span class="comment"># [[01 03 05]</span></span><br><span class="line"><span class="comment">#  [16 18 20]]</span></span><br></pre></td></tr></table></figure>
<p><strong>(3) 提取矩阵的行</strong></p>
<p>基于矩阵的切片功能，我们可以提取其部分行，如示例所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr3 = np.arange(<span class="number">1</span>,<span class="number">21</span>).reshape(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>( arr3 )</span><br><span class="line"><span class="comment"># [[ 01 02 03 04 05]</span></span><br><span class="line"><span class="comment">#  [06 07 08 09 10]</span></span><br><span class="line"><span class="comment">#  [11 12 13 14 15]</span></span><br><span class="line"><span class="comment">#  [16 17 18 19 20]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr3[ <span class="number">2</span> , : ] ) <span class="comment"># 提取第2行</span></span><br><span class="line"><span class="comment"># [11 12 13 14 15]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr3[ <span class="number">1</span>:<span class="number">3</span> , : ] ) <span class="comment"># 提取1至2行</span></span><br><span class="line"><span class="comment"># [[06 07 08 09 10]</span></span><br><span class="line"><span class="comment">#  [11 12 13 14 15]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 考虑代码的简洁，当提取矩阵的某几行时可简写（但提取列的时候不可简写）。</span></span><br><span class="line"><span class="built_in">print</span>( arr3[ <span class="number">2</span> , : ] ) <span class="comment"># 规范的提取行 [11 12 13 14 15]</span></span><br><span class="line"><span class="built_in">print</span>( arr3[<span class="number">2</span>] ) <span class="comment"># 简便的提取行 [11 12 13 14 15]</span></span><br></pre></td></tr></table></figure>
<p>所以，有时你可能看到诸如 <code>arr[1][2]</code> 这样的语法，不必吃惊，其实这只是先提取了第1 行，再提取该行中第2 个元素。提一句，UP 并不推荐这样的写法。</p>
<p><strong>(4) 提取矩阵的列</strong></p>
<p>基于矩阵的切片功能，我们可以提取其部分列，如示例所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr4 = np.arange(<span class="number">1</span>,<span class="number">21</span>).reshape(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>( arr4 )</span><br><span class="line"><span class="comment"># [[ 01 02 03 04 05]</span></span><br><span class="line"><span class="comment">#  [06 07 08 09 10]</span></span><br><span class="line"><span class="comment">#  [11 12 13 14 15]</span></span><br><span class="line"><span class="comment">#  [16 17 18 19 20]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr4[ : , <span class="number">2</span> ] ) <span class="comment"># 提取第2列（注意，输出的是向量）</span></span><br><span class="line"><span class="comment"># [3 8 13 18]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr4[ : , <span class="number">1</span>:<span class="number">3</span> ] ) <span class="comment"># 提取1 至2 列</span></span><br><span class="line"><span class="comment"># [[ 02 03]</span></span><br><span class="line"><span class="comment">#  [07 08]</span></span><br><span class="line"><span class="comment">#  [12 13]</span></span><br><span class="line"><span class="comment">#  [17 18]]</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，提取某一个单独的列时，出来的结果是一个向量。其实这么做只是为了省空间，我们知道，列矩阵必须用两层中括号来存储，而形状为1000的向量，自然比形状为(1000,1)的列矩阵更省空间（节约了1000 对括号）。<br>如果你真的想要提取一个列矩阵出来，示例如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr5 = np.arange(<span class="number">1</span>,<span class="number">16</span>).reshape(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>( arr5 )</span><br><span class="line"><span class="comment"># [[ 01 02 03 04 05]</span></span><br><span class="line"><span class="comment">#  [06 07 08 09 10]</span></span><br><span class="line"><span class="comment">#  [11 12 13 14 15]]</span></span><br><span class="line"></span><br><span class="line">cut = arr5[ : , <span class="number">2</span> ] <span class="comment"># 提取第2列为向量</span></span><br><span class="line"><span class="built_in">print</span>( cut )</span><br><span class="line"><span class="comment"># [3 8 13]</span></span><br><span class="line"></span><br><span class="line">cut = cut.reshape( (-<span class="number">1</span>,<span class="number">1</span>) ) <span class="comment"># 升级为列矩阵</span></span><br><span class="line"><span class="built_in">print</span>(cut)</span><br><span class="line"><span class="comment"># [[ 3]</span></span><br><span class="line"><span class="comment"># [ 8]</span></span><br><span class="line"><span class="comment"># [13]]</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅳ-数组切片仅是视图"><a href="#Ⅳ-数组切片仅是视图" class="headerlink" title="Ⅳ 数组切片仅是视图"></a>Ⅳ 数组切片仅是视图</h5><p><strong>(1) 数组切片仅是视图</strong></p>
<p>与Python列表和Matlab不同，NumPy数组的<strong>切片仅仅是原数组的一个视图</strong>。换言之，<strong>NumPy切片并不会创建新的变量</strong>，示例如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.arange(<span class="number">10</span>) <span class="comment"># 创建原数组arr</span></span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line">cut = arr[ : <span class="number">3</span> ] <span class="comment"># 创建arr的切片cut</span></span><br><span class="line"><span class="built_in">print</span>(cut)</span><br><span class="line"><span class="comment"># [0 1 2]</span></span><br><span class="line"></span><br><span class="line">cut[<span class="number">0</span>] = <span class="number">100</span> <span class="comment"># 对切片的数值进行修改</span></span><br><span class="line"><span class="built_in">print</span>(cut)</span><br><span class="line"><span class="comment"># [100 1 2]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr) <span class="comment"># 原数组也被修改</span></span><br><span class="line"><span class="comment"># [100 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>习惯Matlab 的用户可能无法理解，但其实这正是NumPy 的精妙之处。试想一下，一个几百万条数据的数组，每次切片时都创建一个新变量，势必造成大量的内存浪费。因此，NumPy 的切片被设计为原数组的视图是极好的。<br>深度学习中为节省内存，将多次使用<code>arr[:] = &lt;表达式&gt;</code> 来替代<code>arr = &lt;表达式&gt;</code>。</p>
<p><strong>(2) 备份切片为新变量</strong></p>
<p>如果真的需要为切片创建新变量（这种情况很稀少），使用 <code>.copy( )</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.arange(<span class="number">10</span>) <span class="comment"># 创建一个0 到10 的向量arr</span></span><br><span class="line"><span class="built_in">print</span>(arr) <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line">copy = arr[ : <span class="number">3</span> ] .copy() <span class="comment"># 创建arr 的拷贝切片</span></span><br><span class="line"><span class="built_in">print</span>(copy) <span class="comment"># [0 1 2]</span></span><br><span class="line"></span><br><span class="line">copy [<span class="number">0</span>] = <span class="number">100</span> <span class="comment"># 对拷贝切片的数值进行修改</span></span><br><span class="line"><span class="built_in">print</span>(copy) <span class="comment"># [100 1 2]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr) <span class="comment"># 原数组不为所动 [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Ⅴ-数组赋值仅是绑定"><a href="#Ⅴ-数组赋值仅是绑定" class="headerlink" title="Ⅴ 数组赋值仅是绑定"></a>Ⅴ 数组赋值仅是绑定</h5><p><strong>(1) 数组赋值仅是绑定(不可变数据)</strong></p>
<p>与NumPy 数组的切片一样，NumPy 数组完整的赋值给另一个数组，也只是绑定。换言之，NumPy数组之间的赋值并不会创建新的变量，示例如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr1 = np.arange(<span class="number">10</span>) <span class="comment"># 创建一个0 到10 的数组变量arr</span></span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line">arr2 = arr1 <span class="comment"># 把数组1 赋值给另一个数组2</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">100</span> <span class="comment"># 修改数组2</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [100 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># 原数组也被修改 [100 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此特性的出现仍然是为了节约空间，破局的方法仍然与前面相同。</p>
<p><strong>(2) 复制数组为新变量</strong></p>
<p>如果真的需要赋给一个新数组，使用<code>.copy( )</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr1 = np.arange(<span class="number">10</span>) <span class="comment"># 创建一个0 到10 的数组变量arr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line">arr2 = arr1.copy() <span class="comment"># 把数组1 的拷贝赋值给另一个数组2</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">100</span> <span class="comment"># 修改数组2</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [100 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># 查看数组1 [0 1 2 3 4 5 6 7 8 9]</span></span><br></pre></td></tr></table></figure>
<h4 id="2-1-4-数组的变形"><a href="#2-1-4-数组的变形" class="headerlink" title="2.1.4 数组的变形"></a>2.1.4 数组的变形</h4><h5 id="Ⅰ-数组的转置"><a href="#Ⅰ-数组的转置" class="headerlink" title="Ⅰ 数组的转置"></a>Ⅰ 数组的转置</h5><p>数组的转置方法为<code>.T</code>，其只对矩阵有效，因此遇到向量要先将其转化为矩阵。</p>
<p><strong>(1) 向量的转置</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr1 = np.arange(<span class="number">1</span>,<span class="number">4</span>) <span class="comment"># 创建向量</span></span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [1 2 3]</span></span><br><span class="line"></span><br><span class="line">arr2 = arr1.reshape( (<span class="number">1</span>,-<span class="number">1</span>) ) <span class="comment"># 升级为矩阵</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [[1 2 3]]</span></span><br><span class="line"></span><br><span class="line">arr3 = arr2.T <span class="comment"># 行矩阵的转置</span></span><br><span class="line"><span class="built_in">print</span>(arr3)</span><br><span class="line"><span class="comment"># [[1]</span></span><br><span class="line"><span class="comment">#  [2]</span></span><br><span class="line"><span class="comment">#  [3]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>(2) 矩阵的转置</strong></p>
<p>行矩阵的转置刚演示了，列矩阵和普通矩阵的转置如示例所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr1 = np.arange(<span class="number">3</span>).reshape(<span class="number">3</span>,<span class="number">1</span>) <span class="comment"># 创建列矩阵</span></span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="comment"># [[0]</span></span><br><span class="line"><span class="comment">#  [1]</span></span><br><span class="line"><span class="comment">#  [2]]</span></span><br><span class="line"></span><br><span class="line">arr2 = arr1.T <span class="comment"># 列矩阵的转置</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># 结果为行矩阵</span></span><br><span class="line"><span class="comment"># [[0 1 2]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵的转置如示例所示。</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr1 = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># 创建矩阵</span></span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]]</span></span><br><span class="line"></span><br><span class="line">arr2 = arr1.T <span class="comment"># 矩阵的转置</span></span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># [[0 2]</span></span><br><span class="line"><span class="comment">#  [1 3]]</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-数组的翻转"><a href="#Ⅱ-数组的翻转" class="headerlink" title="Ⅱ 数组的翻转"></a>Ⅱ 数组的翻转</h5><p>数组的翻转方法有两个，一个是上下翻转的 <code>np.flipud( )</code> ，表示up-down；一个是左右翻转的 <code>np.fliplr( )</code>，表示left-right。其中，<strong>向量</strong>只能使用<code>np.flipud( )</code>，在数学中，向量并不是横着排的，而是竖着排的。</p>
<p><strong>(1) 向量的翻转</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建向量</span></span><br><span class="line">arr1 = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>( arr1 ) <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转向量</span></span><br><span class="line">arr_ud = np.flipud(arr1)</span><br><span class="line"><span class="built_in">print</span>( arr_ud ) <span class="comment">#[9 8 7 6 5 4 3 2 1 0]</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 矩阵的翻转</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建矩阵</span></span><br><span class="line">arr2 = np.arange(<span class="number">1</span>,<span class="number">21</span>).reshape(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>( arr2 )</span><br><span class="line"><span class="comment"># [[ 01 02 03 04 05]</span></span><br><span class="line"><span class="comment">#  [06 07 08 09 10]</span></span><br><span class="line"><span class="comment">#  [11 12 13 14 15]</span></span><br><span class="line"><span class="comment">#  [16 17 18 19 20]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 左右翻转</span></span><br><span class="line">arr_lr = np.fliplr(arr2)</span><br><span class="line"><span class="built_in">print</span>( arr_lr )</span><br><span class="line"><span class="comment"># [[05 04 03 02 01]</span></span><br><span class="line"><span class="comment">#  [10 09 08 07 06]</span></span><br><span class="line"><span class="comment">#  [15 14 13 12 11]</span></span><br><span class="line"><span class="comment">#  [20 19 18 17 16]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上下翻转</span></span><br><span class="line">arr_ud = np.flipud(arr2)</span><br><span class="line"><span class="built_in">print</span>( arr_ud )</span><br><span class="line"><span class="comment"># [[16 17 18 19 20]</span></span><br><span class="line"><span class="comment">#  [11 12 13 14 15]</span></span><br><span class="line"><span class="comment">#  [06 07 08 09 10]</span></span><br><span class="line"><span class="comment">#  [01 02 03 04 05]]</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅲ-数组的重塑"><a href="#Ⅲ-数组的重塑" class="headerlink" title="Ⅲ 数组的重塑"></a>Ⅲ 数组的重塑</h5><p>想要重塑数组的形状，需要用到 <code>.reshape( )</code> 方法。前面说过，给定了其他维度的数值，剩下一个维度可以填-1，让它自己去计算。比如把一个5 行6 列的矩阵重塑为3 行10 列的矩阵，当列的参数10 告诉它，行的参数直接可以用-1 来替代，它会自己去用30 除以10 来计算。</p>
<p><strong>(1) 向量的变形</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr1 = np.arange(<span class="number">1</span>,<span class="number">10</span>) <span class="comment"># 创建向量</span></span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line">arr2 = arr1.reshape(<span class="number">3</span>,<span class="number">3</span>) <span class="comment"># 变形为矩阵</span></span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]</span></span><br><span class="line"><span class="comment">#  [7 8 9]]</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 矩阵的变形</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr1 = np.array( [ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] ] ) <span class="comment"># 创建矩阵</span></span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"></span><br><span class="line">arr2 = arr1.reshape(<span class="number">6</span>) <span class="comment"># 变形为向量</span></span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># [1 2 3 4 5 6]</span></span><br><span class="line"></span><br><span class="line">arr3 = arr1.reshape(<span class="number">1</span>,<span class="number">6</span>) <span class="comment"># 变形为矩阵</span></span><br><span class="line"><span class="built_in">print</span>(arr3)</span><br><span class="line"><span class="comment"># [[1 2 3 4 5 6]]</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅳ-数组的拼接"><a href="#Ⅳ-数组的拼接" class="headerlink" title="Ⅳ 数组的拼接"></a>Ⅳ 数组的拼接</h5><p><strong>(1) 向量的拼接</strong></p>
<p>两个向量拼接，使用<code>np.concatenate( [arr1, arr2] )</code>，将得到一个新的加长版向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建向量1</span></span><br><span class="line">arr1 = np.array( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] )</span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [1 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建向量2</span></span><br><span class="line">arr2 = np.array( [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>] )</span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [4 5 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接</span></span><br><span class="line">arr3 = np.concatenate( [arr1, arr2] )</span><br><span class="line"><span class="built_in">print</span>(arr3) <span class="comment"># [1 2 3 4 5 6]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>(2) 矩阵的拼接</strong></p>
<p>两个矩阵可以按不同的维度进行拼接，但拼接时必须注意维度的吻合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建矩阵1</span></span><br><span class="line">arr1 = np.array( [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[ <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]] )</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建矩阵2</span></span><br><span class="line">arr2 = np.array( [[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]] )</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># [[07 08 09]</span></span><br><span class="line"><span class="comment">#  [10 11 12]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按第一个维度（行）拼接</span></span><br><span class="line">arr3 = np.concatenate( [arr1,arr2] ) <span class="comment"># 默认参数axis=0</span></span><br><span class="line"><span class="built_in">print</span>(arr3)</span><br><span class="line"><span class="comment"># [[01 02 03]</span></span><br><span class="line"><span class="comment">#  [04 05 06]</span></span><br><span class="line"><span class="comment">#  [07 08 09]</span></span><br><span class="line"><span class="comment">#  [10 11 12]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按第二个维度（列）拼接</span></span><br><span class="line">arr4 = np.concatenate( [arr1,arr2] ,axis=<span class="number">1</span> )</span><br><span class="line"><span class="built_in">print</span>(arr4)</span><br><span class="line"><span class="comment"># [[01 02 03 07 08 09]</span></span><br><span class="line"><span class="comment">#  [04 05 06 10 11 12]]</span></span><br></pre></td></tr></table></figure>
<p>最后要说明的是，<strong>向量和矩阵不能直接进行拼接</strong>，必须先把向量升级为矩阵。</p>
<h5 id="Ⅴ-数组的分裂"><a href="#Ⅴ-数组的分裂" class="headerlink" title="Ⅴ 数组的分裂"></a>Ⅴ 数组的分裂</h5><p><strong>(1) 向量的分裂</strong></p>
<p>向量分裂使用<code>np.split( )</code>，将得到若干个更短的向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建向量</span></span><br><span class="line">arr = np.arange(<span class="number">10</span>,<span class="number">100</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(arr) <span class="comment"># [10 20 30 40 50 60 70 80 90]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分裂数组</span></span><br><span class="line">arr1,arr2,arr3 = np.split( arr , [<span class="number">2</span>,<span class="number">8</span>] )</span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [10 20]</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [30 40 50 60 70 80]</span></span><br><span class="line"><span class="built_in">print</span>(arr3) <span class="comment"># [90]</span></span><br></pre></td></tr></table></figure>
<p><code>np.split( )</code>函数中，给出的第二个参数<code>[2,8]</code>表示在索引<code>[2]</code>和索引<code>[8]</code>的位置截断。</p>
<p><strong>(2) 矩阵的分裂</strong></p>
<p>矩阵的分裂同样可以按不同的维度进行，分裂出来的均为矩阵。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建矩阵</span></span><br><span class="line">arr = np.arange(<span class="number">1</span>,<span class="number">9</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># [[1 2 3 4]</span></span><br><span class="line"><span class="comment">#  [5 6 7 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按第一个维度（行）分裂</span></span><br><span class="line">arr1, arr2 = np.split(arr,[<span class="number">1</span>]) <span class="comment"># 默认参数axis=0</span></span><br><span class="line"><span class="built_in">print</span>(arr1 , <span class="string">&#x27;\n\n&#x27;</span> , arr2) <span class="comment"># 注意输出的是矩阵</span></span><br><span class="line"><span class="comment"># [[1 2 3 4]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[5 6 7 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按第二个维度（列）分裂</span></span><br><span class="line">arr1,arr2,arr3 = np.split( arr , [<span class="number">1</span>,<span class="number">3</span>] , axis=<span class="number">1</span> )</span><br><span class="line"><span class="built_in">print</span>( arr1 , <span class="string">&#x27;\n\n&#x27;</span> , arr2 , <span class="string">&#x27;\n\n&#x27;</span> , arr3 )</span><br><span class="line"><span class="comment"># [[1]</span></span><br><span class="line"><span class="comment">#  [5]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[2 3]</span></span><br><span class="line"><span class="comment">#  [6 7]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[4]</span></span><br><span class="line"><span class="comment">#  [8]]</span></span><br></pre></td></tr></table></figure>
<h4 id="2-1-5-数组的运算"><a href="#2-1-5-数组的运算" class="headerlink" title="2.1.5 数组的运算"></a>2.1.5 数组的运算</h4><h5 id="Ⅰ-数组与系数之间的运算"><a href="#Ⅰ-数组与系数之间的运算" class="headerlink" title="Ⅰ 数组与系数之间的运算"></a>Ⅰ 数组与系数之间的运算</h5><p>Python 基础中，常用的运算符如下表所示，NumPy的运算符与之相同。</p>
<p><img src="https://pic.imgdb.cn/item/6677d3d4d9c307b7e98ccf98.png"></p>
<p>这里仅以矩阵为例，向量与系数的操作与之相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建矩阵</span></span><br><span class="line">arr = np.arange(<span class="number">1</span>,<span class="number">9</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>( arr )</span><br><span class="line"><span class="comment"># [[1 2 3 4]</span></span><br><span class="line"><span class="comment">#  [5 6 7 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr + <span class="number">10</span> ) <span class="comment"># 加法</span></span><br><span class="line"><span class="comment"># [[11 12 13 14]</span></span><br><span class="line"><span class="comment">#  [15 16 17 18]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr - <span class="number">10</span> ) <span class="comment"># 减法</span></span><br><span class="line"><span class="comment"># [[-9 -8 -7 -6]</span></span><br><span class="line"><span class="comment">#  [-5 -4 -3 -2]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr * <span class="number">10</span> ) <span class="comment"># 乘法</span></span><br><span class="line"><span class="comment"># [[10 20 30 40]</span></span><br><span class="line"><span class="comment">#  [50 60 70 80]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr / <span class="number">10</span> ) <span class="comment"># 除法</span></span><br><span class="line"><span class="comment"># [[0.1 0.2 0.3 0.4]</span></span><br><span class="line"><span class="comment">#  [0.5 0.6 0.7 0.8]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr ** <span class="number">2</span>) <span class="comment"># 平方</span></span><br><span class="line"><span class="comment"># [[01 04 09 16]</span></span><br><span class="line"><span class="comment">#  [25 36 49 64]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr // <span class="number">6</span>) <span class="comment"># 取整</span></span><br><span class="line"><span class="comment"># [[0 0 0 0]</span></span><br><span class="line"><span class="comment">#  [0 1 1 1]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr % <span class="number">6</span>) <span class="comment"># 取余</span></span><br><span class="line"><span class="comment"># [[1 2 3 4]</span></span><br><span class="line"><span class="comment">#  [5 0 1 2]]</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-数组与数组之间的运算"><a href="#Ⅱ-数组与数组之间的运算" class="headerlink" title="Ⅱ 数组与数组之间的运算"></a>Ⅱ 数组与数组之间的运算</h5><p>同维度数组间的运算即对应元素之间的运算，这里仅以矩阵为例，向量与向量的操作与之相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建矩阵</span></span><br><span class="line">arr1 = np.arange(-<span class="number">1</span>,-<span class="number">9</span>,-<span class="number">1</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">arr2 = -arr1</span><br><span class="line"><span class="built_in">print</span>( arr1 )</span><br><span class="line"><span class="comment"># [[-1 -2 -3 -4]</span></span><br><span class="line"><span class="comment">#  [-5 -6 -7 -8]]</span></span><br><span class="line"><span class="built_in">print</span>( arr2 )</span><br><span class="line"><span class="comment"># [[1 2 3 4]</span></span><br><span class="line"><span class="comment">#  [5 6 7 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr1 + arr2 ) <span class="comment"># 加法</span></span><br><span class="line"><span class="comment"># [[0 0 0 0]</span></span><br><span class="line"><span class="comment">#  [0 0 0 0]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr1 - arr2 ) <span class="comment"># 减法</span></span><br><span class="line"><span class="comment"># [[ 0-2 0-4 0-6 0-8]</span></span><br><span class="line"><span class="comment">#  [-10 -12 -14 -16]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr1 * arr2 ) <span class="comment"># 乘法</span></span><br><span class="line"><span class="comment"># [[ -1 -4 -9 -16]</span></span><br><span class="line"><span class="comment">#  [-25 -36 -49 -64]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr1 / arr2 ) <span class="comment"># 除法</span></span><br><span class="line"><span class="comment"># [[-1. -1. -1. -1.]</span></span><br><span class="line"><span class="comment">#  [-1. -1. -1. -1.]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( arr1 ** arr2) <span class="comment"># 幂方</span></span><br><span class="line"><span class="comment"># [[ -1 4 -27 256]</span></span><br><span class="line"><span class="comment">#  [ -3125 46656 -823543 16777216]]</span></span><br></pre></td></tr></table></figure>
<p>上述示例中，乘法是遵循对应元素相乘的，你可以称之为<strong>“逐元素乘积/哈达玛积(<em>Hadamard</em> product) ”</strong>。</p>
<p>那么如何实现线性代数中的“矩阵级乘法”呢？6.1 会介绍到相关函数。</p>
<h5 id="Ⅲ-广播"><a href="#Ⅲ-广播" class="headerlink" title="Ⅲ 广播"></a>Ⅲ 广播</h5><p>Ⅱ是同形状数组之间的逐元素运算，本节讲解不同形状的数组之间的运算。本课件仅讨论二维数组之内的情况，不同形状的数组之间的运算有以下规则：</p>
<ul>
<li>如果是向量与矩阵之间做运算，向量自动升级为行矩阵；</li>
<li>如果某矩阵是行矩阵或列矩阵，则其被广播，以适配另一个矩阵的形状。</li>
</ul>
<p><strong>(1) 向量被广播</strong></p>
<p>当一个形状为(x,y)的矩阵与一个向量做运算时，要求该向量的形状必须为y，运算时向量会自动升级成形状为(1,y)的行矩阵，该形状为(1,y)的行矩阵再自动被广播为形状为(x,y)的矩阵，这样就与另一个矩阵的形状适配了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量</span></span><br><span class="line">arr1 = np.array([-<span class="number">100</span>,<span class="number">0</span>,<span class="number">100</span>])</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="comment"># [-100 0 100]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵</span></span><br><span class="line">arr2 = np.random.random( (<span class="number">10</span>,<span class="number">3</span>) )</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># [[0.60755301 0.47875215 0.70909527]</span></span><br><span class="line"><span class="comment">#  [0.12946037 0.78380689 0.7771824 ]</span></span><br><span class="line"><span class="comment">#  [0.2658308 0.34287368 0.21176781]</span></span><br><span class="line"><span class="comment">#  [0.93920876 0.73860266 0.32531675]</span></span><br><span class="line"><span class="comment">#  [0.92474339 0.97997977 0.98410076]</span></span><br><span class="line"><span class="comment">#  [0.52791609 0.17325381 0.04736612]</span></span><br><span class="line"><span class="comment">#  [0.8543378 0.707902 0.36518268]</span></span><br><span class="line"><span class="comment">#  [0.72053659 0.71830332 0.12972364]</span></span><br><span class="line"><span class="comment">#  [0.86540524 0.95537187 0.66062319]</span></span><br><span class="line"><span class="comment">#  [0.46449401 0.88824093 0.77800761]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 广播</span></span><br><span class="line"><span class="built_in">print</span>(arr1*arr2)</span><br><span class="line"><span class="comment"># [[-60.75530134 0. 70.90952713]</span></span><br><span class="line"><span class="comment">#  [-12.94603684 0. 77.71823953]</span></span><br><span class="line"><span class="comment">#  [-26.58307957 0. 21.17678114]</span></span><br><span class="line"><span class="comment">#  [-93.92087564 0. 32.53167491]</span></span><br><span class="line"><span class="comment">#  [-92.47433933 0. 98.41007632]</span></span><br><span class="line"><span class="comment">#  [-52.7916095 0. 4.73661185]</span></span><br><span class="line"><span class="comment">#  [-85.43377956 0. 36.51826765]</span></span><br><span class="line"><span class="comment">#  [-72.05365932 0. 12.97236352]</span></span><br><span class="line"><span class="comment">#  [-86.54052368 0. 66.06231879]</span></span><br><span class="line"><span class="comment">#  [-46.44940114 0. 77.80076055]]</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 列矩阵被广播</strong></p>
<p>当一个形状为(x,y)的矩阵与一个列矩阵做运算时，要求该列矩阵的形状必须为(x,1)，该形状为(x,1)的列矩阵再自动被广播为形状为(x,y)的矩阵，这样就与另一个矩阵的形状适配了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列矩阵</span></span><br><span class="line">arr1 = np.arange(<span class="number">3</span>).reshape(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="comment"># [[0]</span></span><br><span class="line"><span class="comment">#  [1]</span></span><br><span class="line"><span class="comment">#  [2]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵</span></span><br><span class="line">arr2 = np.ones( (<span class="number">3</span>,<span class="number">5</span>) )</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># [[1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1. 1. 1. 1.]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 广播</span></span><br><span class="line"><span class="built_in">print</span>(arr1*arr2)</span><br><span class="line"><span class="comment"># [[0. 0. 0. 0. 0.]</span></span><br><span class="line"><span class="comment">#  [1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="comment">#  [2. 2. 2. 2. 2.]]</span></span><br></pre></td></tr></table></figure>
<p><strong>(3) 行矩阵与列矩阵同时被广播</strong></p>
<p>当一个形状为(1,y)的行矩阵与一个形状为(x,1) 的列矩阵做运算时，这俩矩阵都会被自动广播为形状为(x,y)的矩阵，这样就互相适配了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向量</span></span><br><span class="line">arr1 = np.arange(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="comment"># [0 1 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列矩阵</span></span><br><span class="line">arr2 = np.arange(<span class="number">3</span>).reshape(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># [[0]</span></span><br><span class="line"><span class="comment">#  [1]</span></span><br><span class="line"><span class="comment">#  [2]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 广播</span></span><br><span class="line"><span class="built_in">print</span>(arr1*arr2)</span><br><span class="line"><span class="comment"># [[0 0 0]</span></span><br><span class="line"><span class="comment">#  [0 1 2]</span></span><br><span class="line"><span class="comment">#  [0 2 4]]</span></span><br></pre></td></tr></table></figure>
<h4 id="2-1-6-数组的函数"><a href="#2-1-6-数组的函数" class="headerlink" title="2.1.6 数组的函数"></a>2.1.6 数组的函数</h4><h5 id="Ⅰ-矩阵乘积"><a href="#Ⅰ-矩阵乘积" class="headerlink" title="Ⅰ 矩阵乘积"></a>Ⅰ 矩阵乘积</h5><ul>
<li>2.1.5 中的乘法都是“逐元素相乘”，这里介绍线性代数中的矩阵乘积，本节只需要使用 <code>np.dot( )</code> 函数。</li>
<li>当矩阵乘积中混有向量时，根据需求，其可充当行矩阵，也可充当列矩阵，但混有向量时输出结果必为向量。</li>
</ul>
<p><strong>(1) 向量与向量的乘积</strong></p>
<p>设两个向量的形状按前后顺序分别是 5 以及 5 。从矩阵乘法的角度，有$(1,5) \times (5,1) = (1,1)$，因此输出的应该是形状为 1 的向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建向量</span></span><br><span class="line">arr1 = np.arange(<span class="number">5</span>)</span><br><span class="line">arr2 = np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [0 1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [0 1 2 3 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵乘积</span></span><br><span class="line"><span class="built_in">print</span>( np.dot(arr1,arr2) )</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 向量与矩阵的乘积</strong></p>
<p>设向量的形状是5 ， 矩阵的形状是 (5,3) 。从矩阵乘法的角度， 有$(1,5)\times(5,3) = (1,3)$，因此输出的应该是形状为 3 的向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line">arr1 = np.arange(<span class="number">5</span>)</span><br><span class="line">arr2 = np.arange(<span class="number">15</span>).reshape(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [0 1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># [[00 01 02]</span></span><br><span class="line"><span class="comment">#  [03 04 05]</span></span><br><span class="line"><span class="comment">#  [06 07 08]</span></span><br><span class="line"><span class="comment">#  [09 10 11]</span></span><br><span class="line"><span class="comment">#  [12 13 14]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵乘积</span></span><br><span class="line"><span class="built_in">print</span>( np.dot(arr1,arr2) )</span><br><span class="line"><span class="comment"># [90 100 110]</span></span><br></pre></td></tr></table></figure>
<p><strong>(3) 矩阵与矩阵的乘积</strong></p>
<p>设两个矩阵的形状按前后顺序分别是$(5,2)$以及$(2,8)$ 。从矩阵乘法的角度，有$(5, 2)\times(2,8) = (5,8)$，因此输出的应该是形状为$(5,8)$的矩阵。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建数组1</span></span><br><span class="line">arr1 = np.arange(<span class="number">10</span>).reshape(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(arr1)</span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]</span></span><br><span class="line"><span class="comment">#  [4 5]</span></span><br><span class="line"><span class="comment">#  [6 7]</span></span><br><span class="line"><span class="comment">#  [8 9]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数组2</span></span><br><span class="line">arr2 = np.arange(<span class="number">16</span>).reshape(<span class="number">2</span>,<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br><span class="line"><span class="comment"># [[00 01 02 03 04 05 06 07]</span></span><br><span class="line"><span class="comment">#  [08 09 10 11 12 13 14 15]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵乘积</span></span><br><span class="line"><span class="built_in">print</span>( np.dot(arr1,arr2) )</span><br><span class="line"><span class="comment"># [[008 009 010 011 012 013 014 015]</span></span><br><span class="line"><span class="comment">#  [024 029 034 039 044 049 054 059]</span></span><br><span class="line"><span class="comment">#  [040 049 058 067 076 085 094 103]</span></span><br><span class="line"><span class="comment">#  [056 069 082 095 108 121 134 147]</span></span><br><span class="line"><span class="comment">#  [072 089 106 123 140 157 174 191]]</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-数学函数"><a href="#Ⅱ-数学函数" class="headerlink" title="Ⅱ 数学函数"></a>Ⅱ 数学函数</h5><p>NumPy 设计了很多数学函数，这里列举其中最重要、最常见的几个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绝对值函数</span></span><br><span class="line">arr_v = np.array( [-<span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>] )</span><br><span class="line">abs_v = np.<span class="built_in">abs</span>(arr_v)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;原数组是：&#x27;</span> , arr_v )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;绝对值是：&#x27;</span> , abs_v )</span><br><span class="line"><span class="comment"># 原数组是： [-10 0 10]</span></span><br><span class="line"><span class="comment"># 绝对值是： [10 0 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三角函数</span></span><br><span class="line">theta = np.arange(<span class="number">3</span>) * np.pi / <span class="number">2</span></span><br><span class="line">sin_v = np.sin(theta)</span><br><span class="line">cos_v = np.cos(theta)</span><br><span class="line">tan_v = np.tan(theta)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;原数组是：&#x27;</span> , theta )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;正弦值是：&#x27;</span> , sin_v )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;余弦值是：&#x27;</span> , cos_v )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;正切值是：&#x27;</span> , tan_v )</span><br><span class="line"><span class="comment"># 原数组是： [0. 1.57079633 3.14159265]</span></span><br><span class="line"><span class="comment"># 正弦值是： [0.0000000e+00 1.0000000e+00 1.2246468e-16]</span></span><br><span class="line"><span class="comment"># 余弦值是： [ 1.000000e+00 6.123234e-17 -1.000000e+00]</span></span><br><span class="line"><span class="comment"># 正切值是： [ 0.00000000e+00 1.63312394e+16 -1.22464680e-16]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指数函数</span></span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;x =&#x27;</span> , x )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;e^x =&#x27;</span> , np.exp(x) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;2^x =&#x27;</span> , <span class="number">2</span>**x )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;10^x = &#x27;</span> , <span class="number">10</span>**x )</span><br><span class="line"><span class="comment"># x = [1 2 3]</span></span><br><span class="line"><span class="comment"># e^x = [ 2.71828183 7.3890561 20.08553692]</span></span><br><span class="line"><span class="comment"># 2^x = [2 4 8]</span></span><br><span class="line"><span class="comment"># 10^x = [ 10 100 1000]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数函数</span></span><br><span class="line">x = np.array( [<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>] )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;x =&#x27;</span> , x )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;ln(x) =&#x27;</span> , np.log(x) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;log2(x) =&#x27;</span> , np.log(x) / np.log(<span class="number">2</span>) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;log10(x) =&#x27;</span> , np.log(x) / np.log(<span class="number">10</span>) )</span><br><span class="line"><span class="comment"># x = [ 1 10 100 1000]</span></span><br><span class="line"><span class="comment"># ln(x) = [0. 2.30258509 4.60517019 6.90775528]</span></span><br><span class="line"><span class="comment"># log2(x) = [0. 3.32192809 6.64385619 9.96578428]</span></span><br><span class="line"><span class="comment"># log10(x) = [0. 1. 2. 3.]</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅲ-聚合函数"><a href="#Ⅲ-聚合函数" class="headerlink" title="Ⅲ 聚合函数"></a>Ⅲ 聚合函数</h5><p>聚合很有用，这里用矩阵演示。向量与之一致，但没有<code>axis</code> 参数。以下在注释中介绍了6个最重要的聚合函数，其用法完全一致，仅演示其中3 个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大值函数np.max( )与最小值函数np.min( )</span></span><br><span class="line">arr = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>( arr )</span><br><span class="line"><span class="comment"># [[0.54312818 0.57067295 0.11898755]</span></span><br><span class="line"><span class="comment">#  [0.85857494 0.33915753 0.4742594 ]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;按维度一求最大值：&#x27;</span> , np.<span class="built_in">max</span>(arr,axis=<span class="number">0</span>) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;按维度二求最大值：&#x27;</span> , np.<span class="built_in">max</span>(arr,axis=<span class="number">1</span>) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;整体求最大值：&#x27;</span> , np.<span class="built_in">max</span>(arr) )</span><br><span class="line"><span class="comment"># 按维度一求最大值： [0.85857494 0.57067295 0.4742594 ]</span></span><br><span class="line"><span class="comment"># 按维度二求最大值： [0.57067295 0.85857494]</span></span><br><span class="line"><span class="comment"># 整体求最大值： 0.8585749445359108</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求和函数np.sum( )与求积函数np.prod( )</span></span><br><span class="line">arr = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>( arr )</span><br><span class="line"><span class="comment"># [[0 1 2 3 4]</span></span><br><span class="line"><span class="comment">#  [5 6 7 8 9]]</span></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;按维度一求和：&#x27;</span> , np.<span class="built_in">sum</span>(arr,axis=<span class="number">0</span>) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;按维度二求和：&#x27;</span> , np.<span class="built_in">sum</span>(arr,axis=<span class="number">1</span>) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;整体求和：&#x27;</span> , np.<span class="built_in">sum</span>(arr) )</span><br><span class="line"><span class="comment"># 按维度一求和： [ 5 7 9 11 13]</span></span><br><span class="line"><span class="comment"># 按维度二求和： [10 35]</span></span><br><span class="line"><span class="comment"># 整体求和： 45</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值函数np.mean( )与标准差函数np.std( )</span></span><br><span class="line">arr = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>( arr )</span><br><span class="line"><span class="comment"># [[0 1 2 3 4]</span></span><br><span class="line"><span class="comment">#  [5 6 7 8 9]]</span></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;按维度一求平均：&#x27;</span> , np.mean(arr,axis=<span class="number">0</span>) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;按维度二求平均：&#x27;</span> , np.mean(arr,axis=<span class="number">1</span>) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;整体求平均：&#x27;</span> , np.mean(arr) )</span><br><span class="line"><span class="comment"># 按维度一求平均： [2.5 3.5 4.5 5.5 6.5]</span></span><br><span class="line"><span class="comment"># 按维度二求平均： [2. 7.]</span></span><br><span class="line"><span class="comment"># 整体求平均： 4.5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当 <code>axis=0</code> 时，最终结果与每一行的元素个数一致；</li>
<li>当 <code>axis=1</code> 时，最终结果与每一列的元素个数一致。</li>
</ul>
<p>考虑到大型数组难免有缺失值，以上聚合函数碰到缺失值时会报错，因此出现了聚合函数的安全版本，即计算时忽略缺失值：<code>np.nansum( )</code>、<code>np.nanprod( )</code> 、<code>np.nanmean( )</code>、<code>np.nanstd( )</code>、<code>np.nanmax( )</code>、<code>np.nanmin( )</code>。</p>
<h4 id="2-1-7-布尔型数组"><a href="#2-1-7-布尔型数组" class="headerlink" title="2.1.7 布尔型数组"></a>2.1.7 布尔型数组</h4><p>除了整数型数组和浮点型数组，还有一种有用的数组类型——布尔型数组。</p>
<h5 id="Ⅰ-创建布尔型数组"><a href="#Ⅰ-创建布尔型数组" class="headerlink" title="Ⅰ 创建布尔型数组"></a>Ⅰ 创建布尔型数组</h5><p>由于NumPy 的主要数据类型是整数型数组或浮点型数组，因此布尔型数组的产生离不开：大于&gt;、大于等于&gt;=、等于==、不等号!=、小于&lt;、小于等于&lt;=。</p>
<p>首先，我们将数组与系数作比较，以产生布尔型数组，示例如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line">arr = np.arange(<span class="number">1</span>,<span class="number">7</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组与数字作比较</span></span><br><span class="line"><span class="built_in">print</span>( arr &gt;= <span class="number">4</span> )</span><br><span class="line"><span class="comment"># [[False False False]</span></span><br><span class="line"><span class="comment">#  [True True True]]</span></span><br></pre></td></tr></table></figure>
<p>其次，我们将同维数组作比较，以产生布尔型数组，示例如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建同维数组</span></span><br><span class="line">arr1 = np.arange(<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line">arr2 = np.flipud(arr1)</span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [1 2 3 4 5]</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [5 4 3 2 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同维度数组作比较</span></span><br><span class="line"><span class="built_in">print</span>( arr1 &gt; arr2)</span><br><span class="line"><span class="comment"># [False False False True True]</span></span><br></pre></td></tr></table></figure>
<p>最后，还可以同时比较多个条件。Python 基础里，同时检查多个条件使用的与、或、非是and、or、not。但NumPy 中使用的与、或、非是 &amp; 、 | 、 ~ 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line">arr = np.arange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># [1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个条件</span></span><br><span class="line"><span class="built_in">print</span>( (arr &lt; <span class="number">4</span>) | (arr &gt; <span class="number">6</span>) )</span><br><span class="line"><span class="comment"># [ True True True False False False True True True]</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-布尔型数组中True-的数量"><a href="#Ⅱ-布尔型数组中True-的数量" class="headerlink" title="Ⅱ 布尔型数组中True 的数量"></a>Ⅱ 布尔型数组中True 的数量</h5><p>有三个关于Ture 数量的有用函数，分别是<code>np.sum( )</code>、<code>np.any( )</code>、<code>np.all( )</code>。</p>
<p><code>np.sum( )</code>函数：统计布尔型数组里True 的个数。示例如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个形状为10000 的标准正态分布数组</span></span><br><span class="line">arr = np.random.normal( <span class="number">0</span>,<span class="number">1</span>,<span class="number">10000</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计该分布中绝对值小于1 的元素个数</span></span><br><span class="line">num = np.<span class="built_in">sum</span>( np.<span class="built_in">abs</span>(arr) &lt; <span class="number">1</span> )</span><br><span class="line"><span class="built_in">print</span>( num ) <span class="comment"># 6814</span></span><br></pre></td></tr></table></figure>
<p>上述示例里，<code>np.abs(arr) &lt; 1</code> 可以替换为 <code>(arr&gt;-1) &amp; (arr&lt;1)</code>。此外，最终统计的数量为6814，其概率近似为0.6827，这符合统计学中的3σ 准则。</p>
<p><code>np.any( )</code>函数：只要布尔型数组里含有一个及其以上的True，就返回True。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建同维数组</span></span><br><span class="line">arr1 = np.arange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">arr2 = np.flipud(arr1)</span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [9 8 7 6 5 4 3 2 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计这两个数组里是否有共同元素</span></span><br><span class="line"><span class="built_in">print</span>( np.<span class="built_in">any</span>( arr1 == arr2 ) )</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>从结果来看，arr1 与arr2 里含有共同元素，那就是5。</p>
<p><code>np.all( )</code>函数：当布尔型数组里全是True时，才返回True，示例如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟英语六级的成绩，创建100000 个样本</span></span><br><span class="line">arr = np.random.normal( <span class="number">500</span>,<span class="number">70</span>,<span class="number">100000</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否所有考生的分数都高于250</span></span><br><span class="line"><span class="built_in">print</span>( np.<span class="built_in">all</span>( arr &gt; <span class="number">250</span> ) )</span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>从结果来看，尽管3σ 准则告诉我们有99.73%的考生成绩高于290 分（290通过$500−3\times70$计算得到），但仍然有最终成绩低于 250 分的裸考者。</p>
<h5 id="Ⅲ-布尔型数组作为掩码"><a href="#Ⅲ-布尔型数组作为掩码" class="headerlink" title="Ⅲ 布尔型数组作为掩码"></a>Ⅲ 布尔型数组作为掩码</h5><p>若一个普通数组和一个布尔型数组的维度相同，可以将布尔型数组作为普通数组的掩码，这样可以对普通数组中的元素作筛选。给出两个示例。</p>
<p>第一个示例，筛选出数组中大于、等于或小于某个数字的元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数组</span></span><br><span class="line">arr = np.arange(<span class="number">1</span>,<span class="number">13</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># [[01 02 03 04]</span></span><br><span class="line"><span class="comment">#  [05 06 07 08]</span></span><br><span class="line"><span class="comment">#  [09 10 11 12]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组与数字作比较</span></span><br><span class="line"><span class="built_in">print</span>( arr &gt; <span class="number">4</span> )</span><br><span class="line"><span class="comment"># [[False False False False]</span></span><br><span class="line"><span class="comment">#  [ True True True True]</span></span><br><span class="line"><span class="comment">#  [ True True True True]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出 arr &gt; 4 的元素</span></span><br><span class="line"><span class="built_in">print</span>( arr[ arr &gt; <span class="number">4</span> ] )</span><br><span class="line"><span class="comment">#  [05 06 07 08 09 10 11 12]</span></span><br></pre></td></tr></table></figure>
<p>注意，这个矩阵进行掩码操作后，退化为了向量。</p>
<p>第二个示例，筛选出数组逐元素比较的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>] : <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建同维数组</span></span><br><span class="line">arr1 = np.arange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">arr2 = np.flipud(arr1)</span><br><span class="line"><span class="built_in">print</span>(arr1) <span class="comment"># [1 2 3 4 5 6 7 8 9]</span></span><br><span class="line"><span class="built_in">print</span>(arr2) <span class="comment"># [9 8 7 6 5 4 3 2 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同维度数组作比较</span></span><br><span class="line"><span class="built_in">print</span>( arr1 &gt; arr2)</span><br><span class="line"><span class="comment"># [False False False False False True True True True]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出 arr1 &gt; arr2 位置上的元素</span></span><br><span class="line"><span class="built_in">print</span>( arr1[ arr1 &gt; arr2 ] )</span><br><span class="line"><span class="comment"># [6 7 8 9]</span></span><br><span class="line"><span class="built_in">print</span>( arr2[ arr1 &gt; arr2 ] )</span><br><span class="line"><span class="comment"># [4 3 2 1]</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅳ-满足条件的元素所在位置"><a href="#Ⅳ-满足条件的元素所在位置" class="headerlink" title="Ⅳ 满足条件的元素所在位置"></a>Ⅳ 满足条件的元素所在位置</h5><p>现在我们来思考一种情况：假设一个很长的数组，我想知道满足某个条件的元素们所在的索引位置，此时使用<code>np.where( )</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>] : <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟英语六级成绩的随机数组，取10000 个样本</span></span><br><span class="line">arr = np.random.normal( <span class="number">500</span>,<span class="number">70</span>,<span class="number">1000</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出六级成绩超过650 的元素所在位置</span></span><br><span class="line"><span class="built_in">print</span>( np.where( arr &gt; <span class="number">650</span> ) )</span><br><span class="line"><span class="comment"># (array([127, 129, 317, 342, 484, 490, 634, 658, 677, 755, 763, 819, 820,</span></span><br><span class="line"><span class="comment">#   853, 926, 932, 982], dtype=int64),)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出六级成绩最高分的元素所在位置</span></span><br><span class="line"><span class="built_in">print</span>( np.where( arr == np.<span class="built_in">max</span>(arr) ) )</span><br><span class="line"><span class="comment"># (array([342], dtype=int64),)</span></span><br></pre></td></tr></table></figure>
<p><code>np.where( )</code>函数的输出看起来比较怪异，它是输出了一个<strong>元组</strong>。元组第一个元素是“满足条件的元素所在位置”；第二个元素是数组类型，可忽略掉。</p>
<h4 id="2-1-8-其他补充"><a href="#2-1-8-其他补充" class="headerlink" title="2.1.8 其他补充"></a>2.1.8 其他补充</h4><h5 id="Ⅰ-np-array和np-ndarry-的区别"><a href="#Ⅰ-np-array和np-ndarry-的区别" class="headerlink" title="Ⅰ np.array和np.ndarry 的区别"></a>Ⅰ np.array和np.ndarry 的区别</h5><p>np.array和np.ndarray都是NumPy中用于创建多维数组的函数。</p>
<p>np.ndarray是NumPy中的多维数组类，它是一种可变的数组，可以通过修改数组中的元素来改变其内容。使用np.ndarray创建的数组必须指定形状、元素类型和存储器位置等参数。例如，可以使用以下代码创建一个2x2的整数数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.ndarray(shape=(<span class="number">2</span>, <span class="number">2</span>), dtype=<span class="built_in">int</span>, buffer=np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure>
<p>np.array是用于创建多维数组的函数，它会将输入的数据转换为一个NumPy数组。与np.ndarray不同，使用np.array创建的数组不需要指定形状、元素类型和存储器位置等参数。例如，以下代码将一个Python列表转换为一个NumPy数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>在实际使用中，<strong>np.array更加常用，因为它可以从Python列表、元组、其他序列类型等对象自动推断形状和数据类型，并且不需要手动指定存储器位置</strong>。但如果你需要创建一些特定的数组，比如指定从已有的数据缓冲区中创建数组，或者指定存储器位置，那么np.ndarray可能更适合你的需求。</p>
<p>总之，np.ndarray是NumPy中的一个多维数组类，而np.array是一个用于创建多维数组的函数，两者的使用场景略有不同。</p>
<p>参考：<a href="https://www.cnblogs.com/joiln/p/17279249.html">np.array和np.ndarry 的区别 - 个人博客</a></p>
<h4 id="2-1-9-从数组到张量"><a href="#2-1-9-从数组到张量" class="headerlink" title="2.1.9 从数组到张量"></a>2.1.9 从数组到张量</h4><p>本视频中，numpy为1.21.5版本，torch为1.12.0版本。PyTorch不同版本的发行日志：<a href="https://pytorch.org/blog/。">https://pytorch.org/blog/。</a></p>
<h5 id="Ⅰ-数组与张量"><a href="#Ⅰ-数组与张量" class="headerlink" title="Ⅰ 数组与张量"></a>Ⅰ 数组与张量</h5><ul>
<li>本次课属于《Python 深度学习》系列视频，PyTorch 作为当前首屈一指的深度学习库，其将NumPy 的语法尽数吸收，作为自己处理数组的基本语法，且运算速度从使用CPU 的数组进步到使用GPU 的张量。</li>
<li><strong>NumPy 和PyTorch 的基础语法几乎一致</strong>，具体表现为：<ul>
<li>① np 对应torch；</li>
<li>② 数组array 对应张量tensor；</li>
<li>③ NumPy 的n 维数组对应着PyTorch 的n 阶张量。</li>
</ul>
</li>
<li>数组与张量之间可以相互转换：<ul>
<li>数组arr 转为张量ts：ts = torch.tensor(arr)；</li>
<li>张量ts 转为数组arr：arr = np.array(ts)。</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-语法不同点"><a href="#Ⅱ-语法不同点" class="headerlink" title="Ⅱ 语法不同点"></a>Ⅱ 语法不同点</h5><p>为找到NumPy 和PyTorch哪些语法不同，UP对本文档进行了替换操作，将np改为torch，将array改为tensor，并重新运行所有代码，得出结论：<strong>PyTorch只是少量修改了NumPy 的部分函数或方法</strong>，现对其中不同的地方进行罗列。</p>
<p><img src="https://pic.imgdb.cn/item/6677e61ed9c307b7e9b196e7.png"></p>
<h3 id="2-2-Tensor学习"><a href="#2-2-Tensor学习" class="headerlink" title="2.2 Tensor学习"></a>2.2 Tensor学习</h3><div class="bvideo">
    <a href="//www.bilibili.com/video/BV1dp4y1U7mD" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/94cd4d825559b6558f673ee5eef0500ad70a709f.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:31:03</span>
            </div>
            <div class="bvideo-info">
                <p class="title">02 轻松学 PyTorch 初识Tensor</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>1.7万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>75</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">唐国梁Tommy</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div> 
<div class="table-container">
<table>
<thead>
<tr>
<th>Tensor基本概念的理解</th>
</tr>
</thead>
<tbody>
<tr>
<td>我们都知道Numpy是支持大量维度数组与矩阵运算的常用扩展库(只能在cpu上跑numpy)。但是对于<br><strong>计算图，深度学习或者梯度</strong>，Numpy是有心无力，因为它的计算无法像Tensor一样在能用GPU加速。<br>Tensor是n维的数组，在概念上与numpy数组是一样的，但不同的是Tensor可以跟踪计算图和计算梯<br>度[<a href="https://zhuanlan.zhihu.com/p/142859846">参考链接1</a>]。</td>
</tr>
<tr>
<td>Tensor与Numpy没区别，就是多维数组而已，不是物理概念的张量。不用numpy是因为pytorch需要<br>支持额外的功能：① GPU等其它硬件的支持；② 自动的梯度计算和back propagation[<a href="https://www.zhihu.com/question/598278407/answer/3019708794">参考链接2</a>]。<br>不精确地说， 若numpy数据结构也支持GPU，现在深度学习里大概就都叫ndarray而不是Tensor了。</td>
</tr>
<tr>
<td>在PyTorch中，张量Tensor是最基础的运算单位，与NumPy中的NDArray类似，张量表示的是一个多维<br>矩阵。不同的是，PyTorch中的Tensor可以运行在GPU上，而NumPy的NDArray只能运行在CPU上。由<br>于Tensor能在GPU上运行，故大大加快了运算速度，tensor再怎么高级也只是一个数据结构而已。 <br><strong>一句话总结：一个可以运行在gpu上的多维数据而已</strong>[<a href="https://cloud.tencent.com/developer/article/1883945">参考链接3</a>]。</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-2-1-为什么要用tensor"><a href="#2-2-1-为什么要用tensor" class="headerlink" title="2.2.1  为什么要用tensor"></a>2.2.1  为什么要用tensor</h4><p>深度学习中的tensor指的是张量，相比于numpy中的数组，它有如下优点，</p>
<ul>
<li><strong>支持 GPU 加速</strong>：深度学习中，需要对大量数据进行计算，并且这些计算通常是高度并行化的。使用 tensor 可以方便地将计算放到 GPU 上进行加速，而 numpy 则通常只能在 CPU 上进行计算。</li>
<li><strong>支持自动求导</strong>：深度学习中，需要对模型参数进行优化，而优化通常需要求解参数的梯度。使用 tensor 可以方便地实现自动求导，而 numpy 则需要手动实现求导过程。</li>
<li><strong>支持动态计算图</strong>：深度学习中，通常需要构建复杂的计算图来描述模型结构和计算过程。使用 tensor 可以方便地构建动态计算图，而 numpy  则只能使用静态计算图。</li>
</ul>
<p>因此，使用 tensor 可以提高深度学习的计算效率和开发效率，并且方便实现自动求导和构建动态计算图。虽然 tensor  相对于numpy复杂一些，但是在深度学习中，使用 tensor 是非常普遍和必要的。</p>
<h4 id="2-2-2-Tensor属性"><a href="#2-2-2-Tensor属性" class="headerlink" title="2.2.2 Tensor属性"></a>2.2.2 Tensor属性</h4><h5 id="Ⅰ-Tensor属性概述"><a href="#Ⅰ-Tensor属性概述" class="headerlink" title="Ⅰ Tensor属性概述"></a>Ⅰ Tensor属性概述</h5><p>在 PyTorch 0.4.0 之前，<code>torch.autograd</code> 包中存在 Variable 这种数据类型，主要是用于封装 Tensor，进行自动求导。Variable 主要包含下面几种属性。 在 PyTorch 0.4.0之后，Variable 并入了 Tensor。在之后版本的 Tensor 中，除了具有上面 Variable 的 5 个属性，还有另外 3 个属性。 </p>
<p><img src="https://pic.imgdb.cn/item/6677f774d9c307b7e9d1966b.png"></p>
<ul>
<li>data：被包装的Tensor；</li>
<li>grad：data的梯度；</li>
<li>grad_fn：创建Tensor所使用的Function，是自动求导的关键，因为根据所记录的函数才能计算出导数。</li>
<li>requires_grad：指示是否需要梯度，并不是所有的张量都需要计算梯度。</li>
<li>is_leaf：指示是否为叶子节点（张量），叶子节点的概念在计算图中会用到，后面详细介绍。</li>
<li>dtype：张量的数据类型，如 torch.FloatTensor，torch.cuda.FloatTensor</li>
<li>shape：张量的形状。如 (64, 3, 224, 224)</li>
<li>device：张量所在设备 (CPU/GPU)，GPU 是加速计算的关键</li>
</ul>
<h5 id="Ⅱ-Tensor数据类型"><a href="#Ⅱ-Tensor数据类型" class="headerlink" title="Ⅱ Tensor数据类型"></a>Ⅱ Tensor数据类型</h5><p>torch.dtype属性标识了torch.Tensor的数据类型。PyTorch有八种不同的数据类型：</p>
<p><img src="https://pic.imgdb.cn/item/6677f829d9c307b7e9d32edf.png"></p>
<h5 id="Ⅲ-Tensor所在设备"><a href="#Ⅲ-Tensor所在设备" class="headerlink" title="Ⅲ Tensor所在设备"></a>Ⅲ Tensor所在设备</h5><p><img src="https://pic.imgdb.cn/item/6677f871d9c307b7e9d3c2a0.png"></p>
<p>如图所示，我们可以看到每种类型的数据都有一个CPU和一个GPU版本，因此我们对张量进行处理的时候需要指定一个设备，它要么是CPU要么是GPU，这是数据被分配的位置，这决定了给定张量的张量计算位置。</p>
<p>Pytorch支持多种设备的使用，我们可以用<code>torch.device</code>来创建一个设备，并指定索引，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device=torch.device(<span class="string">&#x27;cuda:0&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：<code>device(type=‘cuda’,index=0)</code>，可看到类型为<code>cuda</code>，即GPU，索引0表示为第一个GPU。</p>
<p>[<a href="https://blog.csdn.net/qq_29923461/article/details/121400160?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171910922016800227421466%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171910922016800227421466&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-121400160-null-null.142^v100^control&amp;utm_term=pytorch%20tensor&amp;spm=1018.2226.3001.4187">参考链接</a>]、[<a href="https://blog.csdn.net/xu1129005165/article/details/130727373?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171910922016800227421466%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171910922016800227421466&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-130727373-null-null.142^v100^control&amp;utm_term=pytorch%20tensor&amp;spm=1018.2226.3001.4187">参考链接</a>]。</p>
<h4 id="2-2-2-Tensor创建"><a href="#2-2-2-Tensor创建" class="headerlink" title="2.2.2 Tensor创建"></a>2.2.2 Tensor创建</h4><h5 id="Ⅰ-直接创建Tensor"><a href="#Ⅰ-直接创建Tensor" class="headerlink" title="Ⅰ 直接创建Tensor"></a>Ⅰ 直接创建Tensor</h5><p>直接创建Tensor的语法如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">data：数据，可以是list, numpy</span></span><br><span class="line"><span class="string">dtype：数据类型，默认与data对应</span></span><br><span class="line"><span class="string">device：张量所在的设备(cuda或cpu)</span></span><br><span class="line"><span class="string">requires_grad：是否需要梯度</span></span><br><span class="line"><span class="string">pin_memory：是否存于锁存内存</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">torch.tensor(data, dtype=<span class="literal">None</span>, device=<span class="literal">None</span>, requires_grad=<span class="literal">False</span>, pin_memory=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：pin_memory就是锁页内存，创建DataLoader时，设置pin_memory=True，</span></span><br><span class="line"><span class="comment"># 则意味着生成的Tensor数据最开始是属于内存中的锁页内存，这样将内存的Tensor</span></span><br><span class="line"><span class="comment"># 转义到GPU的显存就会更快一些。</span></span><br></pre></td></tr></table></figure>
<p>示例1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">arr = np.ones((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># [[1. 1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1. 1.]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ndarray的数据类型： float64</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ndarray的数据类型：&quot;</span>, arr.dtype)</span><br><span class="line"></span><br><span class="line">t= torch.tensor(arr)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([[1., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 1.]], dtype=torch.float64)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如需创建一个放在GPU的数据，则可做如下修改，运行结果同上。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">device= torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">arr = np.ones((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ndarray的数据类型：&quot;</span>, arr.dtype)</span><br><span class="line">t = torch.tensor(arr, device=device)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-从Numpy中创建"><a href="#Ⅱ-从Numpy中创建" class="headerlink" title="Ⅱ 从Numpy中创建"></a>Ⅱ 从Numpy中创建</h5><ul>
<li><code>torch.from_numpy()</code>是PyTorch提供的一个便捷函数，用于将NumPy数组转换为PyTorch张量。该函数在内部使用了NumPy的C接口，所以它保留了NumPy数组的形状和数据类型[<a href="https://blog.csdn.net/qq_41813454/article/details/129838551">参考链接-CSDN博客</a>]。<ul>
<li><strong>数据类型</strong>：<code>torch.from_numpy()</code>会保留NumPy数组的数据类型。如果NumPy数组是浮点数类型，转换后的张量也将是浮点数类型。</li>
<li><strong>不可变数据类型</strong>：通过<code>torch.from_numpy()</code>创建的张量默认是不可变的，这意味着你不能直接修改其内容。如果你需要修改张量，可以通过<code>.clone()</code>方法创建一个副本。</li>
<li><strong>内存共享</strong>：<code>torch.from_numpy()</code>创建的张量和原始NumPy数组共享相同的内存。这意味着对张量的修改将影响原始数组，反之亦然。如果你不希望共享内存，可以使用<code>.clone()</code>方法。</li>
</ul>
</li>
<li><code>torch.Tensor</code>是默认的tensor类型(torch.FloatTensor)的简称，它是一个类，也就是说使用它只能创建torch.FloatTensot类型</li>
<li><code>torch.tensor</code>是一个函数/方法，它根据参数data创建Tensor，Tensor类型根据数据进行推断，也就是说当我们没有指定dtype使用它创建的类型和data一致，</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">numpy_array= np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">torch_tensor1 = torch.from_numpy(numpy_array)</span><br><span class="line">torch_tensor2 = torch.Tensor(numpy_array) <span class="comment"># 实例化一个Tensor类的对象</span></span><br><span class="line">torch_tensor3 = torch.tensor(numpy_array) <span class="comment"># 函数返回一个Tensor数据</span></span><br></pre></td></tr></table></figure>
<p>在PyTorch中，<code>torch.Tensor</code>是主要的<strong>tensor类</strong>，所有的tensor都是<code>torch.Tensor</code>的实例。<code>torch.Tensor</code>是<code>torch.FloatTensor</code>的别名。  而<code>torch.tensor</code>是一个<strong>函数</strong>，返回的是一个tensor。</p>
<blockquote>
<p>区别1：</p>
<ul>
<li>torch.Tensor(data)：将输入的data转化torch.FloatTensor；</li>
<li>torch.tensor(data)：(当你未指定dype的类型时)将data转化为torch.FloatTensor、torch.LongTensor、torch.DoubleTensor等类型，转化类型依据于data的类型或者dtype的值；</li>
</ul>
<p>区别2：</p>
<ul>
<li>使用如下语句：<code>tensor_without_data = torch.Tensor()</code> 可以创建一个空的FloatTensor；</li>
<li>而当你使用<code>tensor_without_data = torch.tensor()</code>时候则会报错。</li>
</ul>
<p>[<a href="https://blog.csdn.net/Edisonleeee/article/details/90171442?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7EPaidSort-1-90171442-blog-135943835.235%5Ev43%5Epc_blog_bottom_relevance_base9&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7EPaidSort-1-90171442-blog-135943835.235%5Ev43%5Epc_blog_bottom_relevance_base9&amp;utm_relevant_index=1">参考链接</a>]</p>
</blockquote>
<h5 id="Ⅲ-从Python内置类型中创建"><a href="#Ⅲ-从Python内置类型中创建" class="headerlink" title="Ⅲ 从Python内置类型中创建"></a>Ⅲ 从Python内置类型中创建</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">torch_tensor1 = torch.tensor(a)</span><br><span class="line">a1 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">torch_tensor2  = torch.tensor(a1)</span><br></pre></td></tr></table></figure>
<h5 id="Ⅳ-其他方式"><a href="#Ⅳ-其他方式" class="headerlink" title="Ⅳ 其他方式"></a>Ⅳ 其他方式</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建相同元素的Tensor</span></span><br><span class="line">torch_tensor1  = torch.full([<span class="number">2</span>,<span class="number">3</span>],<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 创建全为1的Tensor</span></span><br><span class="line">torch_tensor2 = torch.ones([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 创建全为0的Tensor</span></span><br><span class="line">torch_tensor3 = torch.zeors([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 创建对角阵的Tensor</span></span><br><span class="line">torch_tensor4  = torch.eye(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 在区间[1,10]中随机创建Tensor</span></span><br><span class="line">torch_tensor5 = torch.randint(<span class="number">1</span>,<span class="number">10</span>,[<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 等等...</span></span><br></pre></td></tr></table></figure>
<p>创建Tensor时候也可指定数据类型和所存储的设备</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch_tensor= torch.zeros([<span class="number">2</span>,<span class="number">3</span>],dtype=torch.float64,device=torch.device(<span class="string">&#x27;cuda:0&#x27;</span>))</span><br><span class="line">torch_tensor.dtype <span class="comment">#torch.float64</span></span><br><span class="line">torch_tensor.device <span class="comment">#cuda:0</span></span><br><span class="line">torch_tensor.is_cuda <span class="comment">#True</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-Tensor加速"><a href="#2-2-3-Tensor加速" class="headerlink" title="2.2.3 Tensor加速"></a>2.2.3 Tensor加速</h4><p>我们可以使用以下两种方式使得Tensor在GPU上加速。</p>
<p>第一种方式是定义cuda数据类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dtype = torch.cuda.FloatTensor</span><br><span class="line">gpu_tensor = torch.randn(<span class="number">1</span>,<span class="number">2</span>).<span class="built_in">type</span>(dtype) <span class="comment">#把Tensor转换为cuda数据类型</span></span><br></pre></td></tr></table></figure>
<p>第二种方式是直接将Tensor放到GPU上(推荐)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gpu_tensor = torch.randn(<span class="number">1</span>,<span class="number">2</span>).cuda(<span class="number">0</span>)<span class="comment">#把Tensor直接放在第一个GPU上</span></span><br><span class="line">gpu_tensor = torch.randn(<span class="number">1</span>,<span class="number">2</span>).cuda(<span class="number">1</span>)<span class="comment">#把Tensor直接放在第二个GPU上</span></span><br></pre></td></tr></table></figure>
<p>而将Tensor放在CPU上也很简单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cpu_tensor = gpu_tensor.cpu()</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-查看Tensor属性"><a href="#2-2-4-查看Tensor属性" class="headerlink" title="2.2.4 查看Tensor属性"></a>2.2.4 查看Tensor属性</h4><h5 id="Ⅰ-查看Tensor类型属性"><a href="#Ⅰ-查看Tensor类型属性" class="headerlink" title="Ⅰ 查看Tensor类型属性"></a>Ⅰ 查看Tensor类型属性</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor1 = torch.ones([<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">tensor1.dtype <span class="comment"># torch.float32</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-查看Tensor尺寸属性"><a href="#Ⅱ-查看Tensor尺寸属性" class="headerlink" title="Ⅱ 查看Tensor尺寸属性"></a>Ⅱ 查看Tensor尺寸属性</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor1.shape <span class="comment"># 尺寸</span></span><br><span class="line">tenosr1.ndim <span class="comment">#维度</span></span><br></pre></td></tr></table></figure>
<p>关于Tensor的形状对应</p>
<p>在python中，会有标量，向量，矩阵等的区分。但在PyTorch中，这些统称为张量tensor，只是维度不同而已。</p>
<ul>
<li>标量就是0维张量，只有一个数字，没有维度。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66780640d9c307b7e9ecbb31.png" style="zoom:50%"></p>
<ul>
<li>向量就是1维张量，是有顺序的数字，但没有“行”或“列”的区分。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/667806f9d9c307b7e9edf7f5.png" style="zoom:60%"></p>
<ul>
<li>矩阵就是2维张量，有形状，行和列。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/667807dad9c307b7e9ef8f1b.png" style="zoom:60%"></p>
<ul>
<li>3维张量</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66780b34d9c307b7e9f57e7b.png" style="zoom:60%"></p>
<blockquote>
<p><strong>注：3维张量的大小输出为torch.Size(C=3, H=28, W=28)可以理解为：</strong></p>
<p>1张C=3(RGB)通道的28*28的图片。</p>
</blockquote>
<ul>
<li>4维张量</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66782071d9c307b7e9220dbc.png"></p>
<blockquote>
<p><strong>注：4维张量的大小输出为torch.Size(N=2, C=3, H=28, W=28)可以理解为：</strong></p>
<p>N=2张C=3(RGB)通道的28*28的图片。</p>
</blockquote>
<h5 id="Ⅲ-查看Tensor是否存储在GPU上"><a href="#Ⅲ-查看Tensor是否存储在GPU上" class="headerlink" title="Ⅲ 查看Tensor是否存储在GPU上"></a>Ⅲ 查看Tensor是否存储在GPU上</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor1.is_cuda <span class="comment">#False</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅳ-查看Tensor存储设备"><a href="#Ⅳ-查看Tensor存储设备" class="headerlink" title="Ⅳ 查看Tensor存储设备"></a>Ⅳ 查看Tensor存储设备</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor1.device <span class="comment"># cpu</span></span><br><span class="line">tensor1.cuda(<span class="number">0</span>)</span><br><span class="line">tensor1.device <span class="comment"># cuda:0</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅴ-查看Tensor梯度计算"><a href="#Ⅴ-查看Tensor梯度计算" class="headerlink" title="Ⅴ 查看Tensor梯度计算"></a>Ⅴ 查看Tensor梯度计算</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor1.grad</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5-Tensor操作"><a href="#2-2-5-Tensor操作" class="headerlink" title="2.2.5 Tensor操作"></a>2.2.5 Tensor操作</h4><h5 id="Ⅰ-形状重置"><a href="#Ⅰ-形状重置" class="headerlink" title="Ⅰ 形状重置"></a>Ⅰ 形状重置</h5><p>Tensor的shape可通过<code>torch.reshape</code>接口来改变。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">Tensor =torch.tensor([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">                        [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]],</span><br><span class="line">                      [[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">                        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>]],</span><br><span class="line">                      [[<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">                        [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>]]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the shape of Tensor:&quot;</span>, Tensor.shape)</span><br><span class="line"><span class="comment"># the shape of Tensor: torch.Size([3, 2, 5])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用reshape改变形状</span></span><br><span class="line">reshape_Tensor = torch.reshape(Tensor, [<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;After reshape:\n&quot;</span>, reshape_Tensor)</span><br><span class="line"><span class="comment"># tensor([[[ 1,  2,  3],</span></span><br><span class="line"><span class="comment">#           [ 4,  5,  6],</span></span><br><span class="line"><span class="comment">#           [ 7,  8,  9],</span></span><br><span class="line"><span class="comment">#           [10, 11, 12],</span></span><br><span class="line"><span class="comment">#           [13, 14, 15]],</span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment">#          [[16, 17, 18],</span></span><br><span class="line"><span class="comment">#           [19, 20, 21],</span></span><br><span class="line"><span class="comment">#           [22, 23, 24],</span></span><br><span class="line"><span class="comment">#           [25, 26, 27],</span></span><br><span class="line"><span class="comment">#           [28, 29, 30]]])</span></span><br></pre></td></tr></table></figure>
<p>在指定新的shape时存在一些技巧：</p>
<ul>
<li>-1 表示这个维度的值是从Tensor的元素总数和剩余维度自动推断出来的。因此，有且只有一个维度可以被设置为-1。</li>
<li>0 表示该维度的元素数量与原值相同，因此shape中0的索引值必须小于Tensor的维度（索引值从 0 开始计，如第 1 维的索引值是 0，第二维的索引值是 1）。</li>
</ul>
<h5 id="Ⅱ-索引和切片"><a href="#Ⅱ-索引和切片" class="headerlink" title="Ⅱ 索引和切片"></a>Ⅱ 索引和切片</h5><p>通过索引或切片方式可访问或修改Tensor。</p>
<p><strong>(1) 访问Tensor</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">ndim_2_Tensor = torch.tensor([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                               [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">                               [<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Origin Tensor:\n&quot;</span>, ndim_2_Tensor.numpy())</span><br><span class="line"><span class="comment"># Origin Tensor:</span></span><br><span class="line"><span class="comment">#  [[ 0  1  2  3]</span></span><br><span class="line"><span class="comment">#   [ 4  5  6  7]</span></span><br><span class="line"><span class="comment">#   [ 8  9 10 11]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#索引或切片的第一个值对应第 0 维，第二个值对应第 1 维，</span></span><br><span class="line"><span class="comment">#依次类推，如果某个维度上未指定索引，则默认为 :</span></span><br><span class="line"><span class="comment">#所以下面两种操作结果一样</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;First row:&quot;</span>, ndim_2_Tensor[<span class="number">0</span>].numpy())</span><br><span class="line"><span class="comment"># First row: [0 1 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;First row:&quot;</span>, ndim_2_Tensor[<span class="number">0</span>, :].numpy())</span><br><span class="line"><span class="comment"># First row: [0 1 2 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;First column:&quot;</span>, ndim_2_Tensor[:, <span class="number">0</span>].numpy())</span><br><span class="line"><span class="comment"># First column: [0 4 8]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Last column:&quot;</span>, ndim_2_Tensor[:, -<span class="number">1</span>].numpy())</span><br><span class="line"><span class="comment"># Last column: [ 3  7 11]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All element:\n&quot;</span>, ndim_2_Tensor[:].numpy())</span><br><span class="line"><span class="comment"># All element:</span></span><br><span class="line"><span class="comment">#  [[ 0  1  2  3]</span></span><br><span class="line"><span class="comment">#   [ 4  5  6  7]</span></span><br><span class="line"><span class="comment">#   [ 8  9 10 11]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;First row and second column:&quot;</span>, ndim_2_Tensor[<span class="number">0</span>, <span class="number">1</span>].numpy())</span><br><span class="line"><span class="comment"># First row and second column: 1</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 修改Tensor</strong></p>
<p>与访问张量类似，可以在单个或多个轴上通过索引或切片操作来修改张量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">ndim_2_Tensor = torch.ones([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">ndim_2_Tensor = ndim_2_Tensor.to(torch.float32)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Origin Tensor:\n &#x27;</span>, ndim_2_Tensor)</span><br><span class="line"><span class="comment"># Origin Tensor:</span></span><br><span class="line"><span class="comment">#   tensor([[1., 1., 1.],</span></span><br><span class="line"><span class="comment">#          [1., 1., 1.]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改第1维为0</span></span><br><span class="line">ndim_2_Tensor[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;change Tensor1:\n &#x27;</span>, ndim_2_Tensor)</span><br><span class="line"><span class="comment"># change Tensor1:</span></span><br><span class="line"><span class="comment">#   tensor([[0., 0., 0.],</span></span><br><span class="line"><span class="comment">#          [1., 1., 1.]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改第1维为2.1</span></span><br><span class="line">ndim_2_Tensor[<span class="number">0</span>:<span class="number">1</span>] = <span class="number">2.1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;change Tensor2:\n &#x27;</span>, ndim_2_Tensor)</span><br><span class="line"><span class="comment"># change Tensor2:</span></span><br><span class="line"><span class="comment">#   tensor([[2.1000, 2.1000, 2.1000],</span></span><br><span class="line"><span class="comment">#          [1.0000, 1.0000, 1.0000]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改全部Tensor</span></span><br><span class="line">ndim_2_Tensor[...] = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;change Tensor3:\n &#x27;</span>, ndim_2_Tensor)</span><br><span class="line"><span class="comment">#change Tensor3:</span></span><br><span class="line"><span class="comment">#   tensor([[3., 3., 3.],</span></span><br><span class="line"><span class="comment">#         [3., 3., 3.]])</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅲ-Tensor运算"><a href="#Ⅲ-Tensor运算" class="headerlink" title="Ⅲ Tensor运算"></a>Ⅲ Tensor运算</h5><p>张量支持包括基础数学运算、逻辑运算、矩阵运算等100余种运算操作。</p>
<p><strong>(1) 数学运算</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.<span class="built_in">abs</span>()                       <span class="comment"># 逐元素取绝对值</span></span><br><span class="line">x.ceil()                      <span class="comment"># 逐元素向上取整</span></span><br><span class="line">x.floor()                     <span class="comment"># 逐元素向下取整</span></span><br><span class="line">x.<span class="built_in">round</span>()                     <span class="comment"># 逐元素四舍五入</span></span><br><span class="line">x.exp()                       <span class="comment"># 逐元素计算自然常数为底的指数</span></span><br><span class="line">x.log()                       <span class="comment"># 逐元素计算x的自然对数</span></span><br><span class="line">x.reciprocal()                <span class="comment"># 逐元素求倒数</span></span><br><span class="line">x.square()                    <span class="comment"># 逐元素计算平方</span></span><br><span class="line">x.sqrt()                      <span class="comment"># 逐元素计算平方根</span></span><br><span class="line">x.sin()                       <span class="comment"># 逐元素计算正弦</span></span><br><span class="line">x.cos()                       <span class="comment"># 逐元素计算余弦</span></span><br><span class="line">x.add(y)                      <span class="comment"># 逐元素加</span></span><br><span class="line">x.subtract(y)                 <span class="comment"># 逐元素减</span></span><br><span class="line">x.multiply(y)                 <span class="comment"># 逐元素乘（积）</span></span><br><span class="line">x.divide(y)                   <span class="comment"># 逐元素除</span></span><br><span class="line">x.mod(y)                      <span class="comment"># 逐元素除并取余</span></span><br><span class="line">x.<span class="built_in">pow</span>(y)                      <span class="comment"># 逐元素幂</span></span><br><span class="line">x.<span class="built_in">max</span>()                       <span class="comment"># 指定维度上元素最大值，默认为全部维度</span></span><br><span class="line">x.<span class="built_in">min</span>()                       <span class="comment"># 指定维度上元素最小值，默认为全部维度</span></span><br><span class="line">x.prod()                      <span class="comment"># 指定维度上元素累乘，默认为全部维度</span></span><br><span class="line">x.<span class="built_in">sum</span>()                       <span class="comment"># 指定维度上元素的和，默认为全部维度</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 逻辑运算</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.isfinite()                  <span class="comment"># 判断Tensor中元素是否是有限的数字，即不包括inf与nan</span></span><br><span class="line">x.equal_all(y)                <span class="comment"># 判断两个Tensor的全部元素是否相等，并返回形状为[1]的布尔类Tensor</span></span><br><span class="line">x.equal(y)                    <span class="comment"># 判断两个Tensor的每个元素是否相等，并返回形状相同的布尔类Tensor</span></span><br><span class="line">x.not_equal(y)                <span class="comment"># 判断两个Tensor的每个元素是否不相等</span></span><br><span class="line">x.less_than(y)                <span class="comment"># 判断Tensor x的元素是否小于Tensor y的对应元素</span></span><br><span class="line">x.less_equal(y)               <span class="comment"># 判断Tensor x的元素是否小于或等于Tensor y的对应元素</span></span><br><span class="line">x.greater_than(y)             <span class="comment"># 判断Tensor x的元素是否大于Tensor y的对应元素</span></span><br><span class="line">x.greater_equal(y)            <span class="comment"># 判断Tensor x的元素是否大于或等于Tensor y的对应元素</span></span><br><span class="line">x.allclose(y)                 <span class="comment"># 判断两个Tensor的全部元素是否接近</span></span><br></pre></td></tr></table></figure>
<p><strong>(3) 矩阵运算</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.t()                         <span class="comment"># 矩阵转置</span></span><br><span class="line">x.transpose([<span class="number">1</span>, <span class="number">0</span>])           <span class="comment"># 交换第 0 维与第 1 维的顺序</span></span><br><span class="line">x.norm(<span class="string">&#x27;fro&#x27;</span>)                 <span class="comment"># 矩阵的弗罗贝尼乌斯范数</span></span><br><span class="line">x.dist(y, p=<span class="number">2</span>)                <span class="comment"># 矩阵（x-y）的2范数</span></span><br><span class="line">x.matmul(y)                   <span class="comment"># 矩阵乘法</span></span><br></pre></td></tr></table></figure>
<p>2.2.6 Tensor的广播机制[<a href="https://blog.csdn.net/xu1129005165/article/details/130727373?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171910922016800227421466%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171910922016800227421466&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-130727373-null-null.142^v100^control&amp;utm_term=pytorch%20tensor&amp;spm=1018.2226.3001.4187">参考</a>]</p>
<p><img src="https://pic.imgdb.cn/item/667824b7d9c307b7e92b4c85.png"></p>
<h3 id="2-3-Pandas学习"><a href="#2-3-Pandas学习" class="headerlink" title="2.3 Pandas学习"></a>2.3 Pandas学习</h3><div class="bvideo">
    <a href="//www.bilibili.com/video/BV1hP41197we" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/c789e63c8da8240c34efb235d3ee69d8bf5391d3.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:55:14</span>
            </div>
            <div class="bvideo-info">
                <p class="title">Python深度学习：Pandas标签库</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>4.8万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>230</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">爆肝杰哥</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<h4 id="2-3-0-为什么要学习Pandas"><a href="#2-3-0-为什么要学习Pandas" class="headerlink" title="2.3.0 为什么要学习Pandas"></a>2.3.0 为什么要学习Pandas</h4><p>Numpy已经能够帮助我们处理数据，能够结合matplotlib解决我们数据分析的问题，那么Pandas学习的目的在什么地方呢？Numpy能够帮我们处理处理数值型数据，但是这还不够， 很多时候，我们的数据除了数值之外，还有字符串、时间序列等。<strong>比如：我们通过爬虫获取到了存储在数据库</strong>中的数据。所以，Pandas出现了。 </p>
<p><font color="red"><strong>简单来说，Pandas是编程界的Excel</strong></font>。 </p>
<p>我个人理解，Pandas相当于Python中Excel、SQL这类表格工具，只是在此基础上它提供了更加丰富而高效的功能。</p>
<p>熟悉Excel和SQL的同学应该理解，Excel和SQL经常用于一维和二维数据的处理，效率非常高。</p>
<p>以数据分析为例，假如我们利用Python从零开始开发一个程序，需要先后实现数据的读取、数据结构的定义、数据遍历、数据处理、数据计算 ….  这是一个繁琐而多余的过程。</p>
<p>通过SQL或者Excel，我们可以借助<code>count</code>、<code>sum</code>、<code>join</code>、<code>group by</code>等函数，仅有几行代码就可以实现Python几十甚至上百行代码的工作，极大的提升了开发效率。</p>
<p>而Python相对于SQL、Excel则提供了更加灵活、更加强大的数据分析/处理功能。</p>
<p>它的功能包括但不限于下述内容：</p>
<ul>
<li>数据清理</li>
<li>数据填充</li>
<li>数据规范化</li>
<li>合并和连接</li>
<li>数据可视化</li>
<li>统计分析</li>
</ul>
<p><a href="https://www.zhihu.com/question/433408227">参考链接1：如何最简单、通俗地理解Python的pandas库？ - 知乎</a></p>
<p><a href="https://www.zhihu.com/question/640160608">参考链接2：Python数据处理003：为什么要学习 Numpy &amp; Pandas？ - 知乎</a></p>
<p><a href="https://mofanpy.com/tutorials/data-manipulation/pandas/why/">参考链接2：为什么用 Pandas - 莫凡Python</a></p>
<h4 id="2-3-1-对象的创建"><a href="#2-3-1-对象的创建" class="headerlink" title="2.3.1 对象的创建"></a>2.3.1 对象的创建</h4><p>导入Pandas时，通常给其一个别名“pd”，即 <code>import pandas as pd</code>。</p>
<p>作为标签库，Pandas对象在NumPy数组基础上给予其行列标签。可以说：</p>
<p><img src="https://pic.imgdb.cn/item/667826b1d9c307b7e92fb32c.png" style="zoom:60%"></p>
<p>Pandas中，所有数组特性仍在，Pandas的数据以NumPy数组的方式存储。</p>
<h5 id="Ⅰ-一维对象的创建"><a href="#Ⅰ-一维对象的创建" class="headerlink" title="Ⅰ 一维对象的创建"></a>Ⅰ 一维对象的创建</h5><p><strong>(1) 字典创建法</strong></p>
<p>NumPy中，可以通过<code>np.array()</code>函数，将Python列表转化为NumPy数组；同样，Pandas中，可以通过 <code>pd.Series()</code>函数，将Python字典转化为 Series 对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建字典</span></span><br><span class="line">dict_v = &#123; <span class="string">&#x27;a&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">0.25</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">0.5</span>, <span class="string">&#x27;d&#x27;</span>:<span class="number">0.75</span>, <span class="string">&#x27;e&#x27;</span>:<span class="number">1</span> &#125;</span><br><span class="line"><span class="comment"># 用字典创建Pandas对象</span></span><br><span class="line">sr= pd.Series( dict_v)</span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># a    0.00</span></span><br><span class="line"><span class="comment"># b    0.25</span></span><br><span class="line"><span class="comment"># c    0.50</span></span><br><span class="line"><span class="comment"># d    0.75</span></span><br><span class="line"><span class="comment"># e    1.00</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 数组创建法</strong><br>最直接的创建方法即直接给<code>pd.Series()</code>函数参数，其需要两个参数：</p>
<ul>
<li>第一个参数是值 values(<strong>列表、数组、张量</strong>均可)，</li>
<li>第二个参数是键index(索引)。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用列表创建对象</span></span><br><span class="line">v = [<span class="number">0</span>, <span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">0.75</span>,<span class="number">1</span>]</span><br><span class="line">k = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line"><span class="comment"># 键值创建法</span></span><br><span class="line">sr = pd.Series(v , index=k)</span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># a    0.00</span></span><br><span class="line"><span class="comment"># b    0.25</span></span><br><span class="line"><span class="comment"># c    0.50</span></span><br><span class="line"><span class="comment"># d    0.75</span></span><br><span class="line"><span class="comment"># e    1.00</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br></pre></td></tr></table></figure>
<p>其中，参数index可以省略，省略后索引即从0开始的顺序数字。</p>
<h5 id="Ⅱ-一维对象的属性"><a href="#Ⅱ-一维对象的属性" class="headerlink" title="Ⅱ 一维对象的属性"></a>Ⅱ 一维对象的属性</h5><p>Series 对象有两个属性：values与index。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用数组创建 sr</span></span><br><span class="line">v = np.array([<span class="number">53</span>,<span class="number">64</span>,<span class="number">72</span>,<span class="number">82</span>])</span><br><span class="line">k = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>,<span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">sr = pd.Series(v, index=k)</span><br><span class="line"><span class="built_in">print</span>(sr.values)</span><br><span class="line"><span class="comment"># [53 64 72 82]</span></span><br><span class="line"><span class="built_in">print</span>(sr.index)</span><br><span class="line"><span class="comment"># Index([&#x27;1号&#x27;, &#x27;2号&#x27;, &#x27;3号&#x27;, &#x27;4号&#x27;], dtype=&#x27;object&#x27;)     </span></span><br></pre></td></tr></table></figure>
<p>事实上，无论是用列表、数组还是张量来创建对象，最终values均为数组。</p>
<p>可见，虽然Pandas对象的第一个参数values可以传入列表、数组与张量，但传进去后默认的存储方式是 NumPy数组。这一点更加提醒我们，<strong>Pandas是建立在 NumPy基础上的库</strong>，没有NumPy数组库就没有Pandas数据处理库。<strong>当想要 Pandas 退化为 NumPy 时，查看其 values 属性即可</strong>。</p>
<h5 id="Ⅲ-二维对象的创建"><a href="#Ⅲ-二维对象的创建" class="headerlink" title="Ⅲ 二维对象的创建"></a>Ⅲ 二维对象的创建</h5><p>二维对象将面向矩阵，其不仅有行标签index，还有列标签columns。</p>
<p><strong>(1) 字典创建法</strong></p>
<p>用字典法创建二维对象时，必须基于多个Series对象，每一个Series 就是一列数据，相当于对一列一列的数据作拼接。</p>
<ul>
<li>创建 Series对象时，字典的键是index，其延展方向是竖直方向；</li>
<li>创建 DataFrame 对象时，字典的键是columns，其延展方向是水平方向。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建sr1:各个病人的年龄</span></span><br><span class="line">v1 = [<span class="number">53</span>, <span class="number">64</span>, <span class="number">72</span>, <span class="number">82</span> ]</span><br><span class="line">i = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">sr1 = pd.Series( v1,index=i )</span><br><span class="line"><span class="built_in">print</span>(sr1)</span><br><span class="line"><span class="comment"># 1号    53</span></span><br><span class="line"><span class="comment"># 2号    64</span></span><br><span class="line"><span class="comment"># 3号    72</span></span><br><span class="line"><span class="comment"># 4号    82</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建sr2:各个病人的性别</span></span><br><span class="line">v2 =[<span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>]</span><br><span class="line">i = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;6号&#x27;</span>]</span><br><span class="line">sr2 = pd.Series(v2, index=i)</span><br><span class="line"><span class="built_in">print</span>(sr2)</span><br><span class="line"><span class="comment"># 1号    女</span></span><br><span class="line"><span class="comment"># 2号    男</span></span><br><span class="line"><span class="comment"># 3号    男</span></span><br><span class="line"><span class="comment"># 4号    女</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建df对象</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;年龄&#x27;</span>:sr1,<span class="string">&#x27;性别&#x27;</span>:sr2&#125;)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     年龄 性别</span></span><br><span class="line"><span class="comment"># 1号  53  女</span></span><br><span class="line"><span class="comment"># 2号  64  男</span></span><br><span class="line"><span class="comment"># 3号  72  男</span></span><br><span class="line"><span class="comment"># 4号  82  女</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在做大数据处理的时候，大数据表格一般都长成上述代码中的df那样：列代表不同的特征，行代表不同的个体(采样)</p>
</blockquote>
<p>如果 sr1 和 sr2 的 index 不完全一致，那么二维对象的 index 会取 sr1 与 sr2 的index的交集，相应的，该对象就会产生一定数量的缺失值(NaN)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建sr1:各个病人的年龄</span></span><br><span class="line">v1 = [<span class="number">53</span>, <span class="number">64</span>, <span class="number">72</span>, <span class="number">82</span> ]</span><br><span class="line">i = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">sr1 = pd.Series( v1,index=i )</span><br><span class="line"><span class="built_in">print</span>(sr1)</span><br><span class="line"><span class="comment"># 1号    53</span></span><br><span class="line"><span class="comment"># 2号    64</span></span><br><span class="line"><span class="comment"># 3号    72</span></span><br><span class="line"><span class="comment"># 4号    82</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建sr2:各个病人的性别</span></span><br><span class="line">v2 =[<span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>]</span><br><span class="line">i = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;6号&#x27;</span>]</span><br><span class="line">sr2 = pd.Series(v2, index=i)</span><br><span class="line"><span class="built_in">print</span>(sr2)</span><br><span class="line"><span class="comment"># 1号    女</span></span><br><span class="line"><span class="comment"># 2号    男</span></span><br><span class="line"><span class="comment"># 3号    男</span></span><br><span class="line"><span class="comment"># 4号    女</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建df对象</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;年龄&#x27;</span>:sr1,<span class="string">&#x27;性别&#x27;</span>:sr2&#125;)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 年龄   性别</span></span><br><span class="line"><span class="comment"># 1号  53.0    女</span></span><br><span class="line"><span class="comment"># 2号  64.0    男</span></span><br><span class="line"><span class="comment"># 3号  72.0    男</span></span><br><span class="line"><span class="comment"># 4号  82.0  NaN</span></span><br><span class="line"><span class="comment"># 6号   NaN    女</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 数组创建法</strong></p>
<p>最直接的创建方法即直接给<code>pd.DataFrame</code>函数参数，其需要三个参数。第一个参数是值 values(数组)，第二个参数是行标签index，第三个参数是列标签columns。其中，index和columns参数可以省略，省略后即从0开始的顺序数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定键值</span></span><br><span class="line">v = np.array([[<span class="number">53</span>,<span class="string">&#x27;女&#x27;</span>],[<span class="number">64</span>,<span class="string">&#x27;男&#x27;</span>],[<span class="number">72</span>,<span class="string">&#x27;男&#x27;</span>],[<span class="number">82</span>,<span class="string">&#x27;女&#x27;</span>]])</span><br><span class="line">i = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">c = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>]</span><br><span class="line"><span class="comment"># 键值创建法</span></span><br><span class="line">df = pd.DataFrame(v, index=i, columns=c )</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     年龄 性别</span></span><br><span class="line"><span class="comment"># 1号  53  女</span></span><br><span class="line"><span class="comment"># 2号  64  男</span></span><br><span class="line"><span class="comment"># 3号  72  男</span></span><br><span class="line"><span class="comment"># 4号  82  女</span></span><br></pre></td></tr></table></figure>
<p>细心的同学可能会发现端倪，第二行的NumPy数组居然又含数字又含字符串，上次课中明明讲过数组只能容纳一种变量类型。这里的原理是，<strong>数组默默把数字转为了字符串</strong>，于是v就是一个字符串型数组。</p>
<h5 id="Ⅳ-二维对象的属性"><a href="#Ⅳ-二维对象的属性" class="headerlink" title="Ⅳ 二维对象的属性"></a>Ⅳ 二维对象的属性</h5><p>DataFrame对象有三个属性：values、index与columns。</p>
<p>承接上述代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看values属性</span></span><br><span class="line"><span class="built_in">print</span>(df.values)</span><br><span class="line"><span class="comment"># [[&#x27;53&#x27; &#x27;女&#x27;]</span></span><br><span class="line"><span class="comment">#  [&#x27;64&#x27; &#x27;男&#x27;]</span></span><br><span class="line"><span class="comment">#  [&#x27;72&#x27; &#x27;男&#x27;]</span></span><br><span class="line"><span class="comment">#  [&#x27;82&#x27; &#x27;女&#x27;]]</span></span><br><span class="line"><span class="comment"># 这里可以看到，年龄从数字转变为了字符；</span></span><br><span class="line"><span class="comment"># 此外，想要Pandas退化为Numpy时，查看其values属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 査看index属性</span></span><br><span class="line"><span class="built_in">print</span>(df.index)</span><br><span class="line"><span class="comment"># Index([&#x27;1号&#x27;, &#x27;2号&#x27;, &#x27;3号&#x27;, &#x27;4号&#x27;], dtype=&#x27;object&#x27;)</span></span><br><span class="line"><span class="comment"># 查看columns属性</span></span><br><span class="line"><span class="built_in">print</span>(df.columns)</span><br><span class="line"><span class="comment"># Index([&#x27;年龄&#x27;, &#x27;性别&#x27;], dtype=&#x27;object&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取完整的数组</span></span><br><span class="line">arr = df.values</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># [[&#x27;53&#x27; &#x27;女&#x27;]</span></span><br><span class="line"><span class="comment">#  [&#x27;64&#x27; &#x27;男&#x27;]</span></span><br><span class="line"><span class="comment">#  [&#x27;72&#x27; &#x27;男&#x27;]</span></span><br><span class="line"><span class="comment">#  [&#x27;82&#x27; &#x27;女&#x27;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取第[0]行，并转化为一个整数型数组</span></span><br><span class="line">arr = arr[:,<span class="number">0</span>].astype(<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="comment"># [53 64 72 82]</span></span><br></pre></td></tr></table></figure>
<p>由于数组只能容纳一种变量类型，因此需要<code>.astype(int)</code>的操作。但对象不用，对象每一列的存储方式是单独的，这就很好的兼容了大数据的特性。</p>
<h4 id="2-3-2-对象的索引"><a href="#2-3-2-对象的索引" class="headerlink" title="2.3.2 对象的索引"></a>2.3.2 对象的索引</h4><p>在学习 Pandas的索引之前，需要知道：</p>
<ul>
<li>Pandas的索引分为<strong>显式索引</strong>与<strong>隐式索引</strong>。显式索引是使用Pandas对象提供的索引，而隐式索引是使用数组本身自带的从0开始的索引。</li>
<li>现假设某演示代码中的索引是整数，这个时候显式索引和隐式索引可能会出乱子。于是，Pandas作者发明了<strong>索引器loc(显式)</strong>与<strong>iloc(隐式)</strong>手动告诉程序自己这句话是显式索引还是隐式索引。</li>
</ul>
<h5 id="Ⅰ-一维对象的索引"><a href="#Ⅰ-一维对象的索引" class="headerlink" title="Ⅰ 一维对象的索引"></a>Ⅰ 一维对象的索引</h5><p><strong>(1) 访问元素</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#创建 sr</span></span><br><span class="line">v = [<span class="number">53</span>, <span class="number">64</span>, <span class="number">72</span>, <span class="number">82</span>]</span><br><span class="line">k = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>,<span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">sr = pd.Series(v, index=k )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素（显式）</span></span><br><span class="line">age = sr.loc[<span class="string">&#x27;3号&#x27;</span>] <span class="comment"># age = sr[&#x27;3号&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"><span class="comment"># 72</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 花式索引（显式）</span></span><br><span class="line">sr2 = sr.loc[[<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>]] <span class="comment"># sr2 = sr[[&#x27;1号&#x27;, &#x27;3号&#x27;]]</span></span><br><span class="line"><span class="built_in">print</span>(sr2)</span><br><span class="line"><span class="comment"># 1号    53</span></span><br><span class="line"><span class="comment"># 3号    72</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改元素（显式）</span></span><br><span class="line">sr.loc[<span class="string">&#x27;3号&#x27;</span>] = <span class="number">100</span> <span class="comment"># sr[&#x27;3号&#x27;] = 100 </span></span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># 1号     53</span></span><br><span class="line"><span class="comment"># 2号     64</span></span><br><span class="line"><span class="comment"># 3号    100</span></span><br><span class="line"><span class="comment"># 4号     82</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建 sr</span></span><br><span class="line">v = [<span class="number">53</span>, <span class="number">64</span>, <span class="number">72</span>, <span class="number">82</span>]</span><br><span class="line">k = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>,<span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">sr = pd.Series(v, index=k )</span><br><span class="line"><span class="comment"># 访问元素（隐式）</span></span><br><span class="line">age = sr.iloc[<span class="number">2</span>] <span class="comment"># age = sr[2]</span></span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"><span class="comment"># 72</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 花式索引（隐式）</span></span><br><span class="line">sr2 = sr.iloc[[<span class="number">0</span>, <span class="number">2</span>]] <span class="comment"># sr2 = sr[[0, 2]]</span></span><br><span class="line"><span class="built_in">print</span>(sr2)</span><br><span class="line"><span class="comment"># 1号    53</span></span><br><span class="line"><span class="comment"># 3号    72</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改元素（隐式）</span></span><br><span class="line">sr.iloc[<span class="number">2</span>] = <span class="number">100</span> <span class="comment"># sr[2] = 100</span></span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># 1号     53</span></span><br><span class="line"><span class="comment"># 2号     64</span></span><br><span class="line"><span class="comment"># 3号    100</span></span><br><span class="line"><span class="comment"># 4号     82</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 访问切片</strong></p>
<p>使用显式索引时，’1号’:’3号’ 可以涵盖最后一个’3号’，但隐式与之前一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建 sr</span></span><br><span class="line">v = [<span class="number">53</span>, <span class="number">64</span>, <span class="number">72</span>, <span class="number">82</span>]</span><br><span class="line">k = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>,<span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">sr = pd.Series(v, index=k )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问切片（显式）</span></span><br><span class="line">sr1 = sr.loc[<span class="string">&#x27;1号&#x27;</span>:<span class="string">&#x27;3号&#x27;</span>] <span class="comment"># sr1 = sr[&#x27;1号&#x27;:&#x27;3号&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(sr1)</span><br><span class="line"><span class="comment"># 1号    53</span></span><br><span class="line"><span class="comment"># 2号    64</span></span><br><span class="line"><span class="comment"># 3号    72</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片仅仅是视图（显式）</span></span><br><span class="line">cut = sr.loc[<span class="string">&#x27;1号&#x27;</span>:<span class="string">&#x27;3号&#x27;</span>] <span class="comment"># cut = sr[&#x27;1号&#x27;:&#x27;3号&#x27;]</span></span><br><span class="line">cut.loc[<span class="string">&#x27;1号&#x27;</span>] = <span class="number">120</span> <span class="comment"># cut[&#x27;1号&#x27;] = 120</span></span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># 1号    120</span></span><br><span class="line"><span class="comment"># 2号     64</span></span><br><span class="line"><span class="comment"># 3号     72</span></span><br><span class="line"><span class="comment"># 4号     82</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象赋值仅是绑定（显式）</span></span><br><span class="line">sr2 = sr</span><br><span class="line">sr2.loc[<span class="string">&#x27;4号&#x27;</span>] = <span class="number">400</span> <span class="comment"># sr2[&#x27;4号&#x27;] = 400</span></span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># 1号    120</span></span><br><span class="line"><span class="comment"># 2号     64</span></span><br><span class="line"><span class="comment"># 3号     72</span></span><br><span class="line"><span class="comment"># 4号     400</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建 sr</span></span><br><span class="line">v = [<span class="number">53</span>, <span class="number">64</span>, <span class="number">72</span>, <span class="number">82</span>]</span><br><span class="line">k = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>,<span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">sr = pd.Series(v, index=k )</span><br><span class="line"><span class="comment"># 访问切片（隐式）</span></span><br><span class="line">sr1 = sr.iloc[<span class="number">0</span>:<span class="number">3</span>] <span class="comment"># sr1 = sr[0:3]</span></span><br><span class="line"><span class="built_in">print</span>(sr1)</span><br><span class="line"><span class="comment"># 1号    53</span></span><br><span class="line"><span class="comment"># 2号    64</span></span><br><span class="line"><span class="comment"># 3号    72</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片仅仅是视图（隐式）</span></span><br><span class="line">cut = sr.iloc[<span class="number">0</span>:<span class="number">3</span>] </span><br><span class="line">cut.iloc[<span class="number">0</span>] = <span class="number">120</span> <span class="comment"># cut[0] = 120</span></span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># 1号    120</span></span><br><span class="line"><span class="comment"># 2号     64</span></span><br><span class="line"><span class="comment"># 3号     72</span></span><br><span class="line"><span class="comment"># 4号     82</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象赋值仅是绑定（隐式）</span></span><br><span class="line">sr2 = sr</span><br><span class="line">sr2.iloc[<span class="number">3</span>] = <span class="number">400</span> <span class="comment"># sr2[3] = 400</span></span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># 1号    120</span></span><br><span class="line"><span class="comment"># 2号     64</span></span><br><span class="line"><span class="comment"># 3号     72</span></span><br><span class="line"><span class="comment"># 4号     400</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br></pre></td></tr></table></figure>
<p>若想创建新变量，与 NumPy 一样，使用<code>.copy()</code>方法即可。</p>
<p>如果去掉<code>.loc</code>和<code>.iloc</code> ，此时与NumPy中的索引语法完全一致。</p>
<h5 id="Ⅱ-二维对象的索引"><a href="#Ⅱ-二维对象的索引" class="headerlink" title="Ⅱ 二维对象的索引"></a>Ⅱ 二维对象的索引</h5><p>在二维对象中，<strong>索引器不能去掉</strong>，否则会报错，因此必须适应索引器的存在。</p>
<p><strong>(1) 访问元素</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#字典创建法</span></span><br><span class="line">i = [<span class="string">&#x27;1号&#x27;</span>,<span class="string">&#x27;2号&#x27;</span>,<span class="string">&#x27;3号&#x27;</span>,<span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">v1 = [<span class="number">53</span>,<span class="number">64</span>,<span class="number">72</span>,<span class="number">82</span>]</span><br><span class="line">v2 = [<span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>]</span><br><span class="line">sr1 = pd.Series( v1, index=i)</span><br><span class="line">sr2 = pd.Series( v2, index=i)</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;年龄&#x27;</span>:sr1,<span class="string">&#x27;性别&#x27;</span>:sr2&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素（显式）</span></span><br><span class="line">age = df.loc[<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"><span class="comment"># 53</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 花式索引（显式）</span></span><br><span class="line">sr3 = df.loc[[<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>], [<span class="string">&#x27;性别&#x27;</span>, <span class="string">&#x27;年龄&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(sr3)</span><br><span class="line"><span class="comment">#    性别  年龄</span></span><br><span class="line"><span class="comment"># 1号  女  53</span></span><br><span class="line"><span class="comment"># 3号  男  72</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改元素（显式）</span></span><br><span class="line">df.loc[<span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;年龄&#x27;</span>] = <span class="number">300</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#      年龄 性别</span></span><br><span class="line"><span class="comment"># 1号   53  女</span></span><br><span class="line"><span class="comment"># 2号   64  男</span></span><br><span class="line"><span class="comment"># 3号  300  男</span></span><br><span class="line"><span class="comment"># 4号   82  女</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#字典创建法</span></span><br><span class="line">i = [<span class="string">&#x27;1号&#x27;</span>,<span class="string">&#x27;2号&#x27;</span>,<span class="string">&#x27;3号&#x27;</span>,<span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">v1 = [<span class="number">53</span>,<span class="number">64</span>,<span class="number">72</span>,<span class="number">82</span>]</span><br><span class="line">v2 = [<span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>]</span><br><span class="line">sr1 = pd.Series( v1, index=i)</span><br><span class="line">sr2 = pd.Series( v2, index=i)</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;年龄&#x27;</span>:sr1,<span class="string">&#x27;性别&#x27;</span>:sr2&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素（隐式）</span></span><br><span class="line">age = df.iloc[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"><span class="comment"># 53</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 花式索引（隐式）</span></span><br><span class="line">sr3 = df.iloc[[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line"><span class="built_in">print</span>(sr3)</span><br><span class="line"><span class="comment">#    性别  年龄</span></span><br><span class="line"><span class="comment"># 1号  女  53</span></span><br><span class="line"><span class="comment"># 3号  男  72</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改元素（隐式）</span></span><br><span class="line">df.iloc[<span class="number">2</span>, <span class="number">0</span>] = <span class="number">300</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#      年龄 性别</span></span><br><span class="line"><span class="comment"># 1号   53  女</span></span><br><span class="line"><span class="comment"># 2号   64  男</span></span><br><span class="line"><span class="comment"># 3号  300  男</span></span><br><span class="line"><span class="comment"># 4号   82  女</span></span><br></pre></td></tr></table></figure>
<p>在 NumPy数组中，花式索引输出的是一个向量。但在 Pandas 对象中，考虑到其行列标签的信息不能丢失，所以输出一个向量就不行了，所以这里才输出一个二维对象。</p>
<p><strong>(2) 访问切片</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#字典创建法</span></span><br><span class="line">i = [<span class="string">&#x27;1号&#x27;</span>,<span class="string">&#x27;2号&#x27;</span>,<span class="string">&#x27;3号&#x27;</span>,<span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">v1 = [<span class="number">53</span>,<span class="number">64</span>,<span class="number">72</span>,<span class="number">82</span>]</span><br><span class="line">v2 = [<span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>]</span><br><span class="line">sr1 = pd.Series( v1, index=i)</span><br><span class="line">sr2 = pd.Series( v2, index=i)</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;年龄&#x27;</span>:sr1,<span class="string">&#x27;性别&#x27;</span>:sr2&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片（显式）</span></span><br><span class="line">sr3 = df.loc[<span class="string">&#x27;1号&#x27;</span>:<span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(sr3)</span><br><span class="line"><span class="comment"># 1号    53</span></span><br><span class="line"><span class="comment"># 2号    64</span></span><br><span class="line"><span class="comment"># 3号    72</span></span><br><span class="line"><span class="comment"># Name: 年龄, dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取二维对象的行（显式）</span></span><br><span class="line">sr4 = df.loc[<span class="string">&#x27;3号&#x27;</span>, :]</span><br><span class="line"><span class="built_in">print</span>(sr4)</span><br><span class="line"><span class="comment"># 年龄    72</span></span><br><span class="line"><span class="comment"># 性别     男</span></span><br><span class="line"><span class="comment"># Name: 3号, dtype: object</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 提取二维对象的列（显式）</span></span><br><span class="line">sr5 = df.loc[:, <span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(sr5)</span><br><span class="line"><span class="comment"># 1号    53</span></span><br><span class="line"><span class="comment"># 2号    64</span></span><br><span class="line"><span class="comment"># 3号    72</span></span><br><span class="line"><span class="comment"># 4号    82</span></span><br><span class="line"><span class="comment"># Name: 年龄, dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#字典创建法</span></span><br><span class="line">i = [<span class="string">&#x27;1号&#x27;</span>,<span class="string">&#x27;2号&#x27;</span>,<span class="string">&#x27;3号&#x27;</span>,<span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">v1 = [<span class="number">53</span>,<span class="number">64</span>,<span class="number">72</span>,<span class="number">82</span>]</span><br><span class="line">v2 = [<span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>]</span><br><span class="line">sr1 = pd.Series( v1, index=i)</span><br><span class="line">sr2 = pd.Series( v2, index=i)</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;年龄&#x27;</span>:sr1,<span class="string">&#x27;性别&#x27;</span>:sr2&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片（隐式）</span></span><br><span class="line">sr3 = df.iloc[<span class="number">0</span>:<span class="number">3</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(sr3)</span><br><span class="line"><span class="comment"># 1号    53</span></span><br><span class="line"><span class="comment"># 2号    64</span></span><br><span class="line"><span class="comment"># 3号    72</span></span><br><span class="line"><span class="comment"># Name: 年龄, dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取二维对象的行（隐式）</span></span><br><span class="line">sr4 = df.iloc[<span class="number">2</span>, :]</span><br><span class="line"><span class="built_in">print</span>(sr4)</span><br><span class="line"><span class="comment"># 年龄    72</span></span><br><span class="line"><span class="comment"># 性别     男</span></span><br><span class="line"><span class="comment"># Name: 3号, dtype: object</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 提取二维对象的列（隐式）</span></span><br><span class="line">sr5 = df.iloc[:, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(sr5)</span><br><span class="line"><span class="comment"># 1号    53</span></span><br><span class="line"><span class="comment"># 2号    64</span></span><br><span class="line"><span class="comment"># 3号    72</span></span><br><span class="line"><span class="comment"># 4号    82</span></span><br><span class="line"><span class="comment"># Name: 年龄, dtype: int64</span></span><br></pre></td></tr></table></figure>
<p>在显示索引中，提取矩阵的行或列还有一种简便写法，即</p>
<ul>
<li>提取二维对象的行：<code>df.loc[&#39;3号&#39;]</code>(原理是省略后面的冒号，隐式也可以)</li>
<li>提取二维对象的列：<code>df[&#39;年龄&#39;]</code>(原理是列标签本身就是二维对象的键)</li>
</ul>
<h4 id="2-3-3-对象的变形"><a href="#2-3-3-对象的变形" class="headerlink" title="2.3.3 对象的变形"></a>2.3.3 对象的变形</h4><h5 id="Ⅰ对象的转置"><a href="#Ⅰ对象的转置" class="headerlink" title="Ⅰ对象的转置"></a>Ⅰ对象的转置</h5><p>有时候提供的大数据很畸形，行是特征，列是个体，这必须要先进行转置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建畸形 df</span></span><br><span class="line">v = [[<span class="number">53</span>, <span class="number">64</span>, <span class="number">72</span>, <span class="number">82</span>], [<span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>]]</span><br><span class="line">i = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>]</span><br><span class="line">c = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">df= pd.DataFrame( v,index=i, columns=c)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     1号  2号  3号  4号</span></span><br><span class="line"><span class="comment"># 年龄  53  64  72  82</span></span><br><span class="line"><span class="comment"># 性别   女   男   男   女</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转置</span></span><br><span class="line">df = df.T</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     年龄 性别</span></span><br><span class="line"><span class="comment"># 1号  53  女</span></span><br><span class="line"><span class="comment"># 2号  64  男</span></span><br><span class="line"><span class="comment"># 3号  72  男</span></span><br><span class="line"><span class="comment"># 4号  82  女</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-对象的翻转"><a href="#Ⅱ-对象的翻转" class="headerlink" title="Ⅱ 对象的翻转"></a>Ⅱ 对象的翻转</h5><p>紧接上面的例子，对Pandas对象进行左右翻转与上下翻转。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 左右翻转</span></span><br><span class="line">df = df.iloc[:, : : -<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#    性别  年龄</span></span><br><span class="line"><span class="comment"># 1号  女  53</span></span><br><span class="line"><span class="comment"># 2号  男  64</span></span><br><span class="line"><span class="comment"># 3号  男  72</span></span><br><span class="line"><span class="comment"># 4号  女  82</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上下翻转</span></span><br><span class="line">df = df.iloc[: : -<span class="number">1</span>, :]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#    性别  年龄</span></span><br><span class="line"><span class="comment"># 4号  女  82</span></span><br><span class="line"><span class="comment"># 3号  男  72</span></span><br><span class="line"><span class="comment"># 2号  男  64</span></span><br><span class="line"><span class="comment"># 1号  女  53</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅲ-对象的重塑"><a href="#Ⅲ-对象的重塑" class="headerlink" title="Ⅲ 对象的重塑"></a>Ⅲ 对象的重塑</h5><p>考虑到对象是含有行列标签的，<code>.reshape()</code>已不再适用，因此对象的重塑没有那么灵活。但可以做到将sr并入 df，也可以将df割出sr。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#数组法创建 sr</span></span><br><span class="line">i = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">v1 = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]</span><br><span class="line">v2 = [<span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;女&#x27;</span>]</span><br><span class="line">v3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">sr1 = pd.Series( v1, index=i)</span><br><span class="line">sr2 = pd.Series( v2, index=i)</span><br><span class="line">sr3 = pd.Series( v3, index=i)</span><br><span class="line"><span class="built_in">print</span>(sr1)</span><br><span class="line"><span class="built_in">print</span>(sr2)</span><br><span class="line"><span class="built_in">print</span>(sr3)</span><br><span class="line"><span class="comment"># 1号    10</span></span><br><span class="line"><span class="comment"># 2号    20</span></span><br><span class="line"><span class="comment"># 3号    30</span></span><br><span class="line"><span class="comment"># 4号    40</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"><span class="comment"># 1号    女</span></span><br><span class="line"><span class="comment"># 2号    男</span></span><br><span class="line"><span class="comment"># 3号    男</span></span><br><span class="line"><span class="comment"># 4号    女</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br><span class="line"><span class="comment"># 1号    1</span></span><br><span class="line"><span class="comment"># 2号    2</span></span><br><span class="line"><span class="comment"># 3号    3</span></span><br><span class="line"><span class="comment"># 4号    4</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;年龄&#x27;</span>:sr1, <span class="string">&#x27;性别&#x27;</span>:sr2&#125;)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     年龄 性别</span></span><br><span class="line"><span class="comment"># 1号  10  女</span></span><br><span class="line"><span class="comment"># 2号  20  男</span></span><br><span class="line"><span class="comment"># 3号  30  男</span></span><br><span class="line"><span class="comment"># 4号  40  女</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将sr并入 df</span></span><br><span class="line">df[<span class="string">&#x27;牌照&#x27;</span>] = sr3</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     年龄 性别  牌照</span></span><br><span class="line"><span class="comment"># 1号  10  女   1</span></span><br><span class="line"><span class="comment"># 2号  20  男   2</span></span><br><span class="line"><span class="comment"># 3号  30  男   3</span></span><br><span class="line"><span class="comment"># 4号  40  女   4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把df[&#x27;年龄&#x27;]分离成sr4</span></span><br><span class="line">sr4 = df[<span class="string">&#x27;年龄&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(sr4)</span><br><span class="line"><span class="comment"># 1号    10</span></span><br><span class="line"><span class="comment"># 2号    20</span></span><br><span class="line"><span class="comment"># 3号    30</span></span><br><span class="line"><span class="comment"># 4号    40</span></span><br><span class="line"><span class="comment"># Name: 年龄, dtype: int64</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅳ-对象的拼接"><a href="#Ⅳ-对象的拼接" class="headerlink" title="Ⅳ 对象的拼接"></a>Ⅳ 对象的拼接</h5><p>Pandas 中有一个<code>pd.concat()</code>函数，与<code>np.concatenate()</code>函数语法相似。</p>
<p><strong>(1) 一维对象的合并</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建 sr1 和 sr2</span></span><br><span class="line">v1 = [<span class="number">10</span>, <span class="number">20</span>,<span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">v2 = [<span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line">k1 = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">k2 = [<span class="string">&#x27;4号&#x27;</span>, <span class="string">&#x27;5号&#x27;</span>, <span class="string">&#x27;6号&#x27;</span>]</span><br><span class="line">sr1 = pd.Series( v1,index=k1 )</span><br><span class="line">sr2 = pd.Series( v2,index=k2 )</span><br><span class="line"><span class="built_in">print</span>(sr1)</span><br><span class="line"><span class="built_in">print</span>(sr2)</span><br><span class="line"><span class="comment"># 1号    10</span></span><br><span class="line"><span class="comment"># 2号    20</span></span><br><span class="line"><span class="comment"># 3号    30</span></span><br><span class="line"><span class="comment"># 4号    40</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"><span class="comment"># 4号    40</span></span><br><span class="line"><span class="comment"># 5号    50</span></span><br><span class="line"><span class="comment"># 6号    60</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line">sr3 = pd.concat([sr1, sr2])</span><br><span class="line"><span class="built_in">print</span>(sr3)</span><br><span class="line"><span class="comment"># 1号    10</span></span><br><span class="line"><span class="comment"># 2号    20</span></span><br><span class="line"><span class="comment"># 3号    30</span></span><br><span class="line"><span class="comment"># 4号    40</span></span><br><span class="line"><span class="comment"># 4号    40</span></span><br><span class="line"><span class="comment"># 5号    50</span></span><br><span class="line"><span class="comment"># 6号    60</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，输出结果的键中出现了<strong>两个“4号”</strong>，这是因为Pandas 对象的属性，<strong>放弃了集合与字典索引中“不可重复”的特性</strong>，实际中，这可以拓展大数据分析与处理的应用场景。那么，如何保证索引是不重复的呢？对对象的属性<code>.index</code>或<code>.columns</code> 使用<code>.is unigue</code>即可检査，返回True表示行或列不重复，False 表示有重复。</p>
<p><strong>(2) 一维对象与二维对象的合并</strong><br>一维对象与二维对象的合并，即可理解为：<strong>给二维对象加上一列或者一行</strong>。因此，不必使用<code>pd.concat()</code>函数，只需要借助“二维对象的索引”语法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建 sr1与 sr2</span></span><br><span class="line">v1=[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">v2=[<span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;男&#x27;</span>]</span><br><span class="line">sr1 = pd.Series(v1,index=[<span class="string">&#x27;1号&#x27;</span>,<span class="string">&#x27;2号&#x27;</span>,<span class="string">&#x27;3号&#x27;</span>])</span><br><span class="line">sr2 = pd.Series(v2,index=[<span class="string">&#x27;1号&#x27;</span>,<span class="string">&#x27;2号&#x27;</span>,<span class="string">&#x27;3号&#x27;</span>])</span><br><span class="line"><span class="comment"># 创建df</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;年龄&#x27;</span>:sr1, <span class="string">&#x27;性别&#x27;</span>:sr2&#125;)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     年龄 性别</span></span><br><span class="line"><span class="comment"># 1号  10  女</span></span><br><span class="line"><span class="comment"># 2号  20  男</span></span><br><span class="line"><span class="comment"># 3号  30  男</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为二维对象加上一列特征，可以是列表、数组、张量或一维对象</span></span><br><span class="line">df[<span class="string">&#x27;牌照&#x27;</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     年龄 性别  牌照</span></span><br><span class="line"><span class="comment"># 1号  10  女   1</span></span><br><span class="line"><span class="comment"># 2号  20  男   2</span></span><br><span class="line"><span class="comment"># 3号  30  男   3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为二维对象加上一行个体。可以是列表、数组、张量或一维对象。</span></span><br><span class="line"><span class="comment"># 注意使用显示索引</span></span><br><span class="line">df.loc[<span class="string">&#x27;4号&#x27;</span>] = [<span class="number">40</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     年龄 性别  牌照</span></span><br><span class="line"><span class="comment"># 1号  10  女   1</span></span><br><span class="line"><span class="comment"># 2号  20  男   2</span></span><br><span class="line"><span class="comment"># 3号  30  男   3</span></span><br><span class="line"><span class="comment"># 4号  40  女   4</span></span><br></pre></td></tr></table></figure>
<p><strong>(3) 二维对象的合并</strong></p>
<p>二维对象合并仍然用 <code>pd.concat()</code> 函数，不过其多了一个 <code>axis</code> 参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 设定 df1、df2、df3</span></span><br><span class="line">v1 = [ [<span class="number">10</span>,<span class="string">&#x27;女&#x27;</span>], [<span class="number">20</span>,<span class="string">&#x27;男&#x27;</span>], [<span class="number">30</span>,<span class="string">&#x27;男&#x27;</span>], [<span class="number">40</span>,<span class="string">&#x27;女&#x27;</span>]]</span><br><span class="line">v2 = [[<span class="number">1</span>,<span class="string">&#x27;是&#x27;</span>], [<span class="number">2</span>,<span class="string">&#x27;是&#x27;</span>],[<span class="number">3</span>,<span class="string">&#x27;是&#x27;</span>],[<span class="number">4</span>,<span class="string">&#x27;否&#x27;</span>]]</span><br><span class="line">v3 = [[<span class="number">50</span>,<span class="string">&#x27;男&#x27;</span>, <span class="number">5</span>,<span class="string">&#x27;是&#x27;</span>], [<span class="number">60</span>,<span class="string">&#x27;女&#x27;</span>, <span class="number">6</span>,<span class="string">&#x27;是&#x27;</span>]]</span><br><span class="line">i1 = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">i2 = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">i3 = [<span class="string">&#x27;5号&#x27;</span>, <span class="string">&#x27;6号&#x27;</span>]</span><br><span class="line">c1 = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>]</span><br><span class="line">c2 = [<span class="string">&#x27;牌照&#x27;</span>, <span class="string">&#x27;ikun&#x27;</span>]</span><br><span class="line">c3 = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>, <span class="string">&#x27;牌照&#x27;</span>, <span class="string">&#x27;ikun&#x27;</span>]</span><br><span class="line">df1 = pd.DataFrame( v1, index=i1, columns=c1 )</span><br><span class="line">df2 = pd.DataFrame( v2, index=i2, columns=c2 )</span><br><span class="line">df3 = pd.DataFrame( v3, index=i3, columns=c3 )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照列的方向来合并</span></span><br><span class="line">df = pd.concat([df1, df2], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     年龄 性别  牌照 ikun</span></span><br><span class="line"><span class="comment"># 1号  10  女   1    是</span></span><br><span class="line"><span class="comment"># 2号  20  男   2    是</span></span><br><span class="line"><span class="comment"># 3号  30  男   3    是</span></span><br><span class="line"><span class="comment"># 4号  40  女   4    否</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照行的方向来合并</span></span><br><span class="line">df = pd.concat([df, df3], axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     年龄 性别  牌照 ikun</span></span><br><span class="line"><span class="comment"># 1号  10  女   1    是</span></span><br><span class="line"><span class="comment"># 2号  20  男   2    是</span></span><br><span class="line"><span class="comment"># 3号  30  男   3    是</span></span><br><span class="line"><span class="comment"># 4号  40  女   4    否</span></span><br><span class="line"><span class="comment"># 5号  50  男   5    是</span></span><br><span class="line"><span class="number">6</span>号  <span class="number">60</span>  女   <span class="number">6</span>    是</span><br></pre></td></tr></table></figure>
<h4 id="2-3-4-对象的运算"><a href="#2-3-4-对象的运算" class="headerlink" title="2.3.4 对象的运算"></a>2.3.4 对象的运算</h4><h5 id="Ⅰ-对象与系数之间的运算"><a href="#Ⅰ-对象与系数之间的运算" class="headerlink" title="Ⅰ 对象与系数之间的运算"></a>Ⅰ 对象与系数之间的运算</h5><p>下列演示代码中，左侧为一维对象，右侧为二维对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建一维对象 sr</span></span><br><span class="line">sr = pd.Series([<span class="number">53</span>,<span class="number">64</span>,<span class="number">72</span>],index=[<span class="string">&#x27;1号&#x27;</span>,<span class="string">&#x27;2号&#x27;</span>,<span class="string">&#x27;3号&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># 1号    53</span></span><br><span class="line"><span class="comment"># 2号    64</span></span><br><span class="line"><span class="comment"># 3号    72</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line">sr = sr+<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># 1号    63</span></span><br><span class="line"><span class="comment"># 2号    74</span></span><br><span class="line"><span class="comment"># 3号    82</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line">sr = sr*<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># 1号    126</span></span><br><span class="line"><span class="comment"># 2号    148</span></span><br><span class="line"><span class="comment"># 3号    164</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建二维对象 df</span></span><br><span class="line">v = [[<span class="number">53</span>,<span class="string">&#x27;女&#x27;</span>], [<span class="number">64</span>,<span class="string">&#x27;男&#x27;</span>], [<span class="number">72</span>,<span class="string">&#x27;男&#x27;</span>]]</span><br><span class="line">df = pd.DataFrame(v,index=[<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>], columns=[<span class="string">&#x27;年龄&#x27;</span>,<span class="string">&#x27;性别&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     年龄 性别</span></span><br><span class="line"><span class="comment"># 1号  53  女</span></span><br><span class="line"><span class="comment"># 2号  64  男</span></span><br><span class="line"><span class="comment"># 3号  72  男</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 年龄+10</span></span><br><span class="line">df[<span class="string">&#x27;年龄&#x27;</span>] = df[<span class="string">&#x27;年龄&#x27;</span>]+<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     年龄 性别</span></span><br><span class="line"><span class="comment"># 1号  63  女</span></span><br><span class="line"><span class="comment"># 2号  74  男</span></span><br><span class="line"><span class="comment"># 3号  82  男</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 年龄*2</span></span><br><span class="line">df[<span class="string">&#x27;年龄&#x27;</span>] = df[<span class="string">&#x27;年龄&#x27;</span>]*<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#      年龄 性别</span></span><br><span class="line"><span class="comment"># 1号  126  女</span></span><br><span class="line"><span class="comment"># 2号  148  男</span></span><br><span class="line"><span class="comment"># 3号  164  男</span></span><br></pre></td></tr></table></figure>
<p>df 这里面明明是一个混合型的数组，提取的年龄一列它不应该是一个字符串或者是一个 obiect 的类型的混合变量吗？</p>
<p><code>df.values</code> 是一个NumPy数组，其整体只能以 <code>obiect</code> 类型的混合形式存在，因此之前需要对单独的数字列进行.astype(int)的操作。<code>df[&#39;年龄&#39;]</code>是Pandas对象的数字列，Pandas 为数据处理而生，尽管整体表现为object，但每一列数据单独存储，因此数字列和字符列完美共存。</p>
<h5 id="Ⅱ-对象与对象之间的运算"><a href="#Ⅱ-对象与对象之间的运算" class="headerlink" title="Ⅱ 对象与对象之间的运算"></a>Ⅱ 对象与对象之间的运算</h5><p>对象做运算，必须保证其都是数字型对象，两个对象之间的维度可以不同。</p>
<p><strong>(1) 一维对象之间的运算</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建 sr1</span></span><br><span class="line">v1 =[<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]</span><br><span class="line">k1 = [<span class="string">&#x27;1号&#x27;</span>,<span class="string">&#x27;2号&#x27;</span>,<span class="string">&#x27;3号&#x27;</span>,<span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">sr1 = pd.Series(v1,index= k1 )</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建sr2</span></span><br><span class="line">v2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">k2 = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>,<span class="string">&#x27;3号&#x27;</span>]</span><br><span class="line">sr2 = pd.Series(v2,index= k2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象加法</span></span><br><span class="line">s1 = sr1+sr2</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment"># 1号    11.0</span></span><br><span class="line"><span class="comment"># 2号    22.0</span></span><br><span class="line"><span class="comment"># 3号    33.0</span></span><br><span class="line"><span class="comment"># 4号     NaN</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 对象乘法</span></span><br><span class="line">s2 = sr1*sr2</span><br><span class="line"><span class="built_in">print</span>(s2)</span><br><span class="line"><span class="comment"># 1号    10.0</span></span><br><span class="line"><span class="comment"># 2号    40.0</span></span><br><span class="line"><span class="comment"># 3号    90.0</span></span><br><span class="line"><span class="comment"># 4号     NaN</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 二维对象之间的运算</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建df1和df2格</span></span><br><span class="line">v1 = [[<span class="number">10</span>,<span class="string">&#x27;女&#x27;</span>],[<span class="number">28</span>,<span class="string">&#x27;男&#x27;</span>],[<span class="number">30</span>,<span class="string">&#x27;男&#x27;</span>],[<span class="number">48</span>,<span class="string">&#x27;女&#x27;</span>]]</span><br><span class="line">v2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line">i1 = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">c1 = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>]</span><br><span class="line">i2 = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;6号&#x27;</span>]</span><br><span class="line">c2 = [<span class="string">&#x27;牌照&#x27;</span>]</span><br><span class="line">df1 = pd.DataFrame( v1,index=i1,columns=c1)</span><br><span class="line">df2 = pd.DataFrame( v2,index=i2,columns=c2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加法</span></span><br><span class="line">df1[<span class="string">&#x27;加法&#x27;</span>] = df1[<span class="string">&#x27;年龄&#x27;</span>] + df2[<span class="string">&#x27;牌照&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"><span class="comment">#     年龄 性别    加法</span></span><br><span class="line"><span class="comment"># 1号  10  女  11.0</span></span><br><span class="line"><span class="comment"># 2号  28  男  30.0</span></span><br><span class="line"><span class="comment"># 3号  30  男  33.0</span></span><br><span class="line"><span class="comment"># 4号  48  女   NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 减法、乘法、除法、幂方</span></span><br><span class="line">df1[<span class="string">&#x27;减法&#x27;</span>] = df1[<span class="string">&#x27;年龄&#x27;</span>] - df2[<span class="string">&#x27;牌照&#x27;</span>]</span><br><span class="line">df1[<span class="string">&#x27;乘法&#x27;</span>] = df1[<span class="string">&#x27;年龄&#x27;</span>] * df2[<span class="string">&#x27;牌照&#x27;</span>]</span><br><span class="line">df1[<span class="string">&#x27;除法&#x27;</span>] = df1[<span class="string">&#x27;年龄&#x27;</span>] / df2[<span class="string">&#x27;牌照&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>本章的最后，补充两点内容，读者可自行尝试。</p>
<ol>
<li>Numpy中的数学函数可以直接对Pandas对象使用(这也证明Pandas就是建立在Numpy库之上的)<ol>
<li>使用 <code>np.abs()</code>、<code>np.cos()</code>、<code>np.exp()</code>、<code>np.log()</code>等数学函数时，会保留索引；</li>
</ol>
</li>
<li>Pandas中仍然存在布尔型对象，用法与NumPy无异，会保留索引。</li>
</ol>
<h4 id="2-3-5-对象的缺失值"><a href="#2-3-5-对象的缺失值" class="headerlink" title="2.3.5 对象的缺失值"></a>2.3.5 对象的缺失值</h4><h5 id="Ⅰ-发现缺失值"><a href="#Ⅰ-发现缺失值" class="headerlink" title="Ⅰ 发现缺失值"></a>Ⅰ 发现缺失值</h5><p>发现缺失值使用 <code>.isnull()</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#创建sr</span></span><br><span class="line">v =[ <span class="number">53</span>, <span class="literal">None</span>, <span class="number">72</span>, <span class="number">82</span> ]</span><br><span class="line">k = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">sr = pd.Series(v, index=k)</span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># 1号    53.0</span></span><br><span class="line"><span class="comment"># 2号     NaN</span></span><br><span class="line"><span class="comment"># 3号    72.0</span></span><br><span class="line"><span class="comment"># 4号    82.0</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(sr.isnull())</span><br><span class="line"><span class="comment"># 1号    False</span></span><br><span class="line"><span class="comment"># 2号     True</span></span><br><span class="line"><span class="comment"># 3号    False</span></span><br><span class="line"><span class="comment"># 4号    False</span></span><br><span class="line"><span class="comment"># dtype: bool</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-剔除缺失值"><a href="#Ⅱ-剔除缺失值" class="headerlink" title="Ⅱ 剔除缺失值"></a>Ⅱ 剔除缺失值</h5><p>剔除缺失值使用 <code>.dropna()</code> 方法，返回一个<strong>Pandas对象</strong>，一维对象很好剔除；二维对象比较复杂，要么单独剔除df中含有缺失值的行，要么剔除df中含有缺失值的列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一维对象剔除</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 创建sr</span></span><br><span class="line">v = [<span class="number">53</span>, <span class="literal">None</span>, <span class="number">72</span>, <span class="number">82</span>]</span><br><span class="line">k = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">sr = pd.Series( v,index=k)</span><br><span class="line"><span class="comment"># 剔除sr的缺失值</span></span><br><span class="line">dsr = sr.dropna()</span><br><span class="line"><span class="built_in">print</span>(dsr)</span><br><span class="line"><span class="comment"># 1号    53.0</span></span><br><span class="line"><span class="comment"># 3号    72.0</span></span><br><span class="line"><span class="comment"># 4号    82.0</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维对象剔除</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#创建df</span></span><br><span class="line">v=[[<span class="literal">None</span>,<span class="literal">None</span>],[<span class="number">64</span>,<span class="literal">None</span>],[<span class="number">72</span>,<span class="number">3</span>],[<span class="number">82</span>,<span class="number">4</span>]]</span><br><span class="line">i = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">c = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;牌照&#x27;</span>]</span><br><span class="line">df = pd.DataFrame(v,index=i,columns=c)</span><br><span class="line"><span class="comment"># 剔除df的缺失值的行</span></span><br><span class="line">dff = df.dropna(axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(dff)</span><br><span class="line"><span class="comment">#       年龄   牌照</span></span><br><span class="line"><span class="comment"># 3号  72.0  3.0</span></span><br><span class="line"><span class="comment"># 4号  82.0  4.0</span></span><br></pre></td></tr></table></figure>
<p>把含有 NaN 的行剔除掉了，你也可以通过<code>df.dropna(axis=&#39;columns&#39;)</code>的方式剔除列。但请警惕，一般都是别除行，只因大数据中行是个体，列是特征。</p>
<p>此外有些同学认为，只要某行含有一个NaN 就剔除该个体太过残忍，我们可以设定一个参数，只有当该行全部是NaN，才剔除该列特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 剔除df全是None的行</span></span><br><span class="line">dff = df.dropna(how=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line"><span class="comment">#       年龄   牌照</span></span><br><span class="line"><span class="comment"># 2号  64.0  NaN</span></span><br><span class="line"><span class="comment"># 3号  72.0  3.0</span></span><br><span class="line"><span class="comment"># 4号  82.0  4.0</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅲ-填补缺失值"><a href="#Ⅲ-填补缺失值" class="headerlink" title="Ⅲ 填补缺失值"></a>Ⅲ 填补缺失值</h5><p>填充缺失值使用 <code>.filna()</code> 方法，实际的数据填充没有统一的方法，很灵活。</p>
<p><strong>(1) 一维对象填充</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#创建sr</span></span><br><span class="line">v = [<span class="number">53</span>, <span class="literal">None</span>, <span class="number">72</span>, <span class="number">82</span>]</span><br><span class="line">sr = pd.Series(v, index=[<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(sr)</span><br><span class="line"><span class="comment"># 1号    53.0</span></span><br><span class="line"><span class="comment"># 2号     NaN</span></span><br><span class="line"><span class="comment"># 3号    72.0</span></span><br><span class="line"><span class="comment"># 4号    82.0</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 用常数0填充</span></span><br><span class="line">sr1 = sr.fillna(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(sr1)</span><br><span class="line"><span class="comment"># 1号    53.0</span></span><br><span class="line"><span class="comment"># 2号     0.0</span></span><br><span class="line"><span class="comment"># 3号    72.0</span></span><br><span class="line"><span class="comment"># 4号    82.0</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 用均值填充</span></span><br><span class="line">sr2 = sr.fillna(np.mean(sr))</span><br><span class="line"><span class="built_in">print</span>(sr2)</span><br><span class="line"><span class="comment"># 1号    53.0</span></span><br><span class="line"><span class="comment"># 2号    69.0</span></span><br><span class="line"><span class="comment"># 3号    72.0</span></span><br><span class="line"><span class="comment"># 4号    82.0</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 用前值填充</span></span><br><span class="line">sr3 = sr.fillna(method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sr3)</span><br><span class="line"><span class="comment"># 1号    53.0</span></span><br><span class="line"><span class="comment"># 2号    53.0</span></span><br><span class="line"><span class="comment"># 3号    72.0</span></span><br><span class="line"><span class="comment"># 4号    82.0</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 用后值填充</span></span><br><span class="line">sr4 = sr.fillna(method=<span class="string">&#x27;bfill&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sr4)</span><br><span class="line"><span class="comment"># 1号    53.0</span></span><br><span class="line"><span class="comment"># 2号    72.0</span></span><br><span class="line"><span class="comment"># 3号    72.0</span></span><br><span class="line"><span class="comment"># 4号    82.0</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 二维对象填充</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">v=[[<span class="literal">None</span>,<span class="literal">None</span>],[<span class="number">64</span>,<span class="literal">None</span>],[<span class="number">72</span>,<span class="number">3</span>],[<span class="number">82</span>,<span class="number">4</span>]]</span><br><span class="line">i = [<span class="string">&#x27;1号&#x27;</span>, <span class="string">&#x27;2号&#x27;</span>, <span class="string">&#x27;3号&#x27;</span>, <span class="string">&#x27;4号&#x27;</span>]</span><br><span class="line">c = [<span class="string">&#x27;年龄&#x27;</span>, <span class="string">&#x27;牌照&#x27;</span>]</span><br><span class="line">df = pd.DataFrame(v,index=i,columns=c)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 用常数0填充</span></span><br><span class="line">df1 = df.fillna(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(df1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用均值填充</span></span><br><span class="line">df2 = df.fillna(np.mean(df))</span><br><span class="line"><span class="built_in">print</span>(df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用前值填充</span></span><br><span class="line">df3 = df.fillna(method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df3)</span><br><span class="line"><span class="comment">#       年龄   牌照</span></span><br><span class="line"><span class="comment"># 1号   NaN  NaN</span></span><br><span class="line"><span class="comment"># 2号  64.0  NaN</span></span><br><span class="line"><span class="comment"># 3号  72.0  3.0</span></span><br><span class="line"><span class="comment"># 4号  82.0  4.0</span></span><br><span class="line"><span class="comment"># 注意，前值没有，故仍用NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用后值填充</span></span><br><span class="line">df4 = df.fillna(method=<span class="string">&#x27;bfill&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df4)</span><br></pre></td></tr></table></figure>
<h4 id="2-3-6-导入-Excel-文件"><a href="#2-3-6-导入-Excel-文件" class="headerlink" title="2.3.6 导入 Excel 文件"></a>2.3.6 导入 Excel 文件</h4><h5 id="Ⅰ-创建-Excel-文件"><a href="#Ⅰ-创建-Excel-文件" class="headerlink" title="Ⅰ 创建 Excel 文件"></a>Ⅰ 创建 Excel 文件</h5><p>首先，创建 Excel 文件，录入信息，第一列为index，第一行为columns。</p>
<p><img src="https://pic.imgdb.cn/item/667aa931d9c307b7e9aaec4f.png"></p>
<p>如果你的数据没有index和columns，也即你只是想导入一个数组，那么也请先补上行列标签，后续用<code>.values</code>属性就能将二维对象转换为数组。</p>
<p><img src="https://pic.imgdb.cn/item/667aa9c8d9c307b7e9abe65f.png"></p>
<p>接着，将其另存为为CSV文件。</p>
<h5 id="Ⅱ-放入项目文件夹"><a href="#Ⅱ-放入项目文件夹" class="headerlink" title="Ⅱ 放入项目文件夹"></a>Ⅱ 放入项目文件夹</h5><p>将刚刚另存为的 CSV 文件放置工程项目文件夹。</p>
<h5 id="Ⅲ-导入Excel信息"><a href="#Ⅲ-导入Excel信息" class="headerlink" title="Ⅲ 导入Excel信息"></a>Ⅲ 导入Excel信息</h5><ul>
<li><ul>
<li><code>pd.read_csv()</code>: 从 CSV 文件中读取数据。</li>
<li><code>pd.read_excel()</code>: 从 Excel 文件中读取数据。</li>
<li><code>pd.to_csv()</code>: 将 DataFrame 保存到 CSV 文件。</li>
<li><code>pd.to_excel()</code>: 将 DataFrame 保存到 Excel 文件。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 导入 Pandas 对象</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>, index_col=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment">#     age gender  num ikun</span></span><br><span class="line"><span class="comment"># 1号   10      女    1    是</span></span><br><span class="line"><span class="comment"># 2号   20      男    2    是</span></span><br><span class="line"><span class="comment"># 3号   30      男    3    是</span></span><br><span class="line"><span class="comment"># 4号   40      女    4    否</span></span><br><span class="line"><span class="comment"># 5号   50      男    5    是</span></span><br><span class="line"><span class="comment"># 6号   60      女    6    是</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-3-7-数据分析"><a href="#2-3-7-数据分析" class="headerlink" title="2.3.7 数据分析"></a>2.3.7 数据分析</h4><h5 id="Ⅰ-导入信息"><a href="#Ⅰ-导入信息" class="headerlink" title="Ⅰ 导入信息"></a>Ⅰ 导入信息</h5><p>首先，准备好Excel数据表格。</p>
<p><img src="https://pic.imgdb.cn/item/667aad34d9c307b7e9b1e096.png"></p>
<p>发现没有行标签,因此需要在最左侧快速填充一列顺序数字：</p>
<p><img src="https://pic.imgdb.cn/item/667aad6ed9c307b7e9b23e74.png"></p>
<p>导入表格到python中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#导入Pandas对象</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;行星数据.csv&#x27;</span>, index_col=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-聚合方法"><a href="#Ⅱ-聚合方法" class="headerlink" title="Ⅱ 聚合方法"></a>Ⅱ 聚合方法</h5><p>可在输出 df时，对其使用<code>.head()</code>方法，使其仅输出前五行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#导入Pandas对象</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;行星数据.csv&#x27;</span>, index_col=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line"><span class="comment">#    发现时间  发现数量   观测方法    行星质量   距地距离       轨道周期</span></span><br><span class="line"><span class="comment"># 0  1982     1   径向速度  11.680  40.57  29.726245</span></span><br><span class="line"><span class="comment"># 1  1992     3  脉冲行星法   2.000    NaN  12.797459</span></span><br><span class="line"><span class="comment"># 2  1992     3  脉冲行星法   3.000    NaN  93.576595</span></span><br><span class="line"><span class="comment"># 3  1994     3  脉冲行星法   4.000    NaN  83.094802</span></span><br><span class="line"><span class="comment"># 4  1995     1   径向速度   0.472  15.36  79.473673</span></span><br></pre></td></tr></table></figure>
<p>NumPy中所有的聚合函数对Pandas对象均适用。此外，Pandas将这些函数变为对象的方法，这样<strong>不导入NumPy 也可使用</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/667aaf23d9c307b7e9b53fb2.png"></p>
<p>在这些方法中，像 NumPy中一样，有默认值为0的参数axis。一般不要将其数值手动设定为1，因为这种情况在数据分析中毫无意义。</p>
<p> 此外，这些方法都忽略了缺失值，属于NumPy中聚合函数的安全版本。</p>
<h5 id="Ⅲ-描述方法"><a href="#Ⅲ-描述方法" class="headerlink" title="Ⅲ 描述方法"></a>Ⅲ 描述方法</h5><p>在数据分析中用以上方法挨个查看未免太过麻烦，可以使用 <code>.describe()</code> 方法直接查看所有聚合函数的信息。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#导入Pandas对象</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;行星数据.csv&#x27;</span>, index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述方法</span></span><br><span class="line">info = df.describe()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(info))</span><br><span class="line"><span class="comment"># &lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(info)</span><br><span class="line"><span class="comment">#               发现时间       发现数量       行星质量       距地距离       轨道周期</span></span><br><span class="line"><span class="comment"># count    19.000000  19.000000  17.000000  16.000000  19.000000</span></span><br><span class="line"><span class="comment"># mean   1995.526316   2.368421   2.921071  20.436250  52.228279</span></span><br><span class="line"><span class="comment"># std       3.820535   1.300022   2.943290  11.624346  30.467731</span></span><br><span class="line"><span class="comment"># min    1982.000000   1.000000   0.472000   4.700000   2.082275</span></span><br><span class="line"><span class="comment"># 25%    1995.500000   1.000000   1.040000  13.470000  33.045239</span></span><br><span class="line"><span class="comment"># 50%    1996.000000   2.000000   2.000000  16.515000  52.687083</span></span><br><span class="line"><span class="comment"># 75%    1998.000000   3.000000   3.900000  21.297500  81.284238</span></span><br><span class="line"><span class="comment"># max    1999.000000   5.000000  11.680000  47.920000  93.576595</span></span><br></pre></td></tr></table></figure>
<p>count：有效数据个数，以上为例，若count&lt;19，则有缺失值。</p>
<ul>
<li>第1行count是计数项，统计每个特征的有效数量(即排除缺失值)，从count可以看出，距地距离的缺失值比较多，需要考虑一定的办法填充或舍弃。</li>
<li>第2行至第3行的mean与std 统计每列特征的均值与标准差。</li>
<li>第4行至第8行的 min、25%、50%、75%、max的意思是五个分位点，即把数组从小到大排序后，0%、25%、50%、75%、100%五个位置上的数值的取值。显然，50%分位点即中位数。</li>
</ul>
<h5 id="Ⅳ-数据透视"><a href="#Ⅳ-数据透视" class="headerlink" title="Ⅳ 数据透视"></a>Ⅳ 数据透视</h5><p><strong>(1) 两个特征内的数据透视</strong></p>
<p>数据透视，对数据分析来讲十分重要。</p>
<p>现以泰坦尼克号的生还数据为例，以“是否生还”特征为考察的核心(或者说是神经网络的输出)，研究其它特征(输入)与之的关系，如示例所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#导入Pandas对象</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;泰坦尼克.csv&#x27;</span>, index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据透视：一个特征</span></span><br><span class="line">ts1 = df.pivot_table(<span class="string">&#x27;是否生还&#x27;</span>, index=<span class="string">&#x27;性别&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ts1)</span><br><span class="line"><span class="comment">#       是否生还</span></span><br><span class="line"><span class="comment"># 性别       </span></span><br><span class="line"><span class="comment"># 女    0.440	(全体女性中生还的概率为44.0%)</span></span><br><span class="line"><span class="comment"># 男    0.375	(全体男性中生还的概率为37.5%)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据透视：两个特征</span></span><br><span class="line">ts2 = df.pivot_table(<span class="string">&#x27;是否生还&#x27;</span>, index=<span class="string">&#x27;性别&#x27;</span>, columns=<span class="string">&#x27;船舱等级&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ts2)</span><br><span class="line"><span class="comment"># 船舱等级    一等        三等        二等</span></span><br><span class="line"><span class="comment"># 性别                            </span></span><br><span class="line"><span class="comment"># 女     0.25  0.571429  0.666667</span></span><br><span class="line"><span class="comment"># 男     0.50  0.400000  0.000000</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，数据透视表中的数值默认是输出特征“是否生还”的均值(mean)，行标签和列标签变成了其它的输入特征。</p>
<p><code>print(ts1)</code>可以看出，女性整体的生还概率是44.0%，男性整体的生还概率为37.5%。</p>
<p> <code>print(ts2)</code>则区分的更细致。</p>
<p>值得注意的是，<code>pivot_table()</code>方法有一个很重要的参数：<code>aggfunc</code>，其默认值是<code>mean</code>，除此以外，所有的聚合函数<code>max</code>、<code>min</code>、<code>sum</code>、<code>count</code>均可使用。显然，对于这里的“是否生还”来说，<code>mean</code>就是最好的选择，其刚好为概率。</p>
<p><strong>(2) 多个特征的数据透视</strong></p>
<p>有时需要考察更多特征与输出特征的关系。前面的示例只涉及到两个特征，这里，将年龄和费用都加进去。但是，这两个特征的数值很分散，之前的性别和船舱等级都可以按照类别分，现在已经不能再按类别分了。因此，需要涉及到数据透视表配套的两个重要函数：<code>pd.cut()</code>与<code>pd.qcut()</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#导入Pandas对象</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;泰坦尼克.csv&#x27;</span>, index_col=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据透视</span></span><br><span class="line">ts1 = df.pivot_table(<span class="string">&#x27;是否生还&#x27;</span>, index=<span class="string">&#x27;性别&#x27;</span>)</span><br><span class="line"><span class="comment">#print(ts1)</span></span><br><span class="line"></span><br><span class="line">ts2 = df.pivot_table(<span class="string">&#x27;是否生还&#x27;</span>, index=<span class="string">&#x27;性别&#x27;</span>, columns=<span class="string">&#x27;船舱等级&#x27;</span>)</span><br><span class="line"><span class="comment">#print(ts2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据透视：3个特征</span></span><br><span class="line"><span class="comment"># 重置年龄列</span></span><br><span class="line">age = pd.cut(df[<span class="string">&#x27;年龄&#x27;</span>], [<span class="number">0</span>, <span class="number">25</span>, <span class="number">100</span>]) <span class="comment"># 手动 - 以25岁为分水岭：把年龄分成2组[0, 25] [25, 100]</span></span><br><span class="line">ts3 = df.pivot_table(<span class="string">&#x27;是否生还&#x27;</span>, index=[<span class="string">&#x27;性别&#x27;</span>, age], columns=<span class="string">&#x27;船舱等级&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ts3)</span><br><span class="line"><span class="comment"># 船舱等级                一等        三等   二等</span></span><br><span class="line"><span class="comment"># 性别 年龄                                </span></span><br><span class="line"><span class="comment"># 女  (0, 25]    0.142857  0.000000  1.0</span></span><br><span class="line"><span class="comment">#    (25, 100]  0.400000  0.666667  0.6</span></span><br><span class="line"><span class="comment"># 男  (0, 25]    0.500000  0.500000  NaN</span></span><br><span class="line"><span class="comment">#    (25, 100]  0.500000  0.375000  0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据透视：4个特征</span></span><br><span class="line"><span class="comment"># 重置费用列</span></span><br><span class="line">fare = pd.qcut(df[<span class="string">&#x27;费用&#x27;</span>], <span class="number">2</span>) <span class="comment"># 自动 - 将费用分为2部分</span></span><br><span class="line">ts4 = df.pivot_table(<span class="string">&#x27;是否生还&#x27;</span>, columns=[<span class="string">&#x27;性别&#x27;</span>, age], index=[<span class="string">&#x27;船舱等级&#x27;</span>, fare])</span><br><span class="line"><span class="built_in">print</span>(ts4)</span><br><span class="line"><span class="comment"># 性别                                     女                 男          </span></span><br><span class="line"><span class="comment"># 年龄                               (0, 25] (25, 100] (0, 25] (25, 100]</span></span><br><span class="line"><span class="comment"># 船舱等级 费用                                                             </span></span><br><span class="line"><span class="comment"># 一等   (10.206000000000001, 26.88]     0.5  0.333333     0.5      0.50</span></span><br><span class="line"><span class="comment">#      (26.88, 49.654]                 0.0  0.500000     NaN       NaN</span></span><br><span class="line"><span class="comment"># 三等   (10.206000000000001, 26.88]     0.0  0.500000     0.0      0.75</span></span><br><span class="line"><span class="comment">#      (26.88, 49.654]                 NaN  0.750000     1.0      0.00</span></span><br><span class="line"><span class="comment"># 二等   (10.206000000000001, 26.88]     1.0  0.333333     NaN       NaN</span></span><br><span class="line"><span class="comment">#      (26.88, 49.654]                 NaN  1.000000     NaN      0.00</span></span><br></pre></td></tr></table></figure>
<p><code>pd.cut()</code>函数需要手动设置分割点，也可以设置为<code>[0,18,60,100]</code>。<code>pd.qcut()函</code>数可自动分割，如果需要分割成3部分，可以设置为 3。当然，这里只演示了4个特征，你可以继续在<code>pivot_table()</code>的<code>index</code>或<code>columns</code>的列表参数里添加其他特征，但也不要添加太多，会很混乱。</p>
<h3 id="2-4-matplotlib学习"><a href="#2-4-matplotlib学习" class="headerlink" title="2.4 matplotlib学习"></a>2.4 matplotlib学习</h3><h4 id="2-4-1-绘图基础"><a href="#2-4-1-绘图基础" class="headerlink" title="2.4.1 绘图基础"></a>2.4.1 绘图基础</h4><p>Matplotlib库太大，画图通常仅仅使用其中的核心模块 <code>matplotlib.pyplot</code> ，并给其一个别名 plt，即<code>import matplotlib.pyplot as plt</code>。</p>
<h5 id="Ⅰ-绘制图像"><a href="#Ⅰ-绘制图像" class="headerlink" title="Ⅰ 绘制图像"></a>Ⅰ 绘制图像</h5><p>展示一个很简单的图形绘制示例，这个示例的代码就像在 Matlab 里一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># matplotlib inline</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图像</span></span><br><span class="line">Fig1 = plt.figure()		<span class="comment"># 创建新的绘图窗口</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]	 <span class="comment"># 数据的x值</span></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span> ]	<span class="comment"># 数据的y值</span></span><br><span class="line">plt.plot(x,y)	<span class="comment"># plot函数:先描点，再连线</span></span><br><span class="line">plt.show()	<span class="comment"># 显示图像</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-保存图像"><a href="#Ⅱ-保存图像" class="headerlink" title="Ⅱ 保存图像"></a>Ⅱ 保存图像</h5><p>用<code>.savefig()</code>方法，其需要一个<code>r</code>字符串：<code>r&#39;绝对路径\图形名.后缀</code></p>
<ul>
<li>绝对路径：如果要保存到桌面，绝对路径即：<code>C:Users\用户名\Desklop</code>；</li>
<li>后缀：可保存图形的格式很多，包括：<code>eps、jpg、pdf、png、ps、svg</code>等。为了保存清晰的图，推荐保存至svg 矢量格式，即</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Fig2.savefig(<span class="string">r&#x27;c:\Users\zjj\Desktop\我的图.svg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>保存为svg 格式后，可直接拖至 Word 或 Visio 中，即可显示高清矢量图。</p>
<h5 id="Ⅲ-2种绘图方式"><a href="#Ⅲ-2种绘图方式" class="headerlink" title="Ⅲ 2种绘图方式"></a>Ⅲ 2种绘图方式</h5><p>Matplollib中有两种画图方式：<strong>① Matlab方式</strong>和 <strong>② 面向对象方式</strong>。这两种方式都可以完成同一个目的，也可以相互转化(3.3小节的颜色条只有Mallab方式具备，4.1与4.2二者转化时形式出现区别)。</p>
<p><img src="https://pic.imgdb.cn/item/6683bfb2d9c307b7e9c3703e.png" alt="两种画图方式" style="zoom:70%"></p>
<h5 id="Ⅳ-图窗与坐标轴"><a href="#Ⅳ-图窗与坐标轴" class="headerlink" title="Ⅳ 图窗与坐标轴"></a>Ⅳ 图窗与坐标轴</h5><p>图形窗口(figure)在Matlab中会单独弹出，该窗口中可容纳元素，也可以是空的窗口。在Jupyter中，由于我们将图形嵌入到了<code>Out[]</code>中，所以不会看到有 figure 弹出。虽然看不到窗口，但在画图之前，仍然要手动 <code>Fig1=plt.figure()</code>创建图窗，毕竟保存图形的<code>.savefg()</code>方法是需要图形名，且后面几章会更加强调。坐标轴(axes)是一个矩形，其下方是x的数值与刻度，左侧是y轴的数值与刻度。因此，将1.4示例的Ou[4]中的蓝色曲线副除，剩余部分全是axcs。</p>
<h4 id="2-4-2-多图形的绘制"><a href="#2-4-2-多图形的绘制" class="headerlink" title="2.4.2 多图形的绘制"></a>2.4.2 多图形的绘制</h4><p>在Jupyter的某个代码块中使用 <code>Fig1=plt.figure()</code>创建图窗后，其范围仅仅在此代码块内，跳出此代码块外的其它面图命令将与Fig1无关。</p>
<p>因此，画一幅图，请在一个代码块内完成，不得分块。</p>
<h5 id="Ⅰ-绘制多线条"><a href="#Ⅰ-绘制多线条" class="headerlink" title="Ⅰ 绘制多线条"></a>Ⅰ 绘制多线条</h5><p>在同一个图窗内绘制多线条，按Matlab画图方式来演示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备敬据</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y2 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">y3 = [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matlab方式</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">plt.plot(x,y3)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">fig.savefig(<span class="string">&#x27;pie_chart.svg&#x27;</span>, <span class="built_in">format</span>=<span class="string">&#x27;svg&#x27;</span>)	<span class="comment"># 保存为矢量图svg，高清不失真</span></span><br></pre></td></tr></table></figure>
<h5 id="Ⅱ-绘制多个子图"><a href="#Ⅱ-绘制多个子图" class="headerlink" title="Ⅱ 绘制多个子图"></a>Ⅱ 绘制多个子图</h5><p>类似Matlab，使用<code>plt.subplot(3, 1, 1)</code>语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备敬据</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y2 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">y3 = [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matlab方式</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">plt.plot(x,y3)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-图表类型"><a href="#2-4-3-图表类型" class="headerlink" title="2.4.3 图表类型"></a>2.4.3 图表类型</h4><h5 id="Ⅰ-基本的图表类型"><a href="#Ⅰ-基本的图表类型" class="headerlink" title="Ⅰ 基本的图表类型"></a>Ⅰ 基本的图表类型</h5><p>plt提供5类基本图表，分别是二维图、网格图、统计图、轮廓图、三维图。以下罗列深度学习中可能用的。</p>
<p><a href="https://matplotlib.org/stable/plot_types/index">https://matplotlib.org/stable/plot_types/index</a></p>
<p><strong>(1) 二维图</strong></p>
<p>二维图，只需要两个向量即可绘图，其中线型图可以替代其它所有二维图。</p>
<p><img src="https://pic.imgdb.cn/item/6683c83cd9c307b7e9d5007a.png" alt="不同类型的二维图"></p>
<p><strong>(2) 网格图</strong></p>
<p>网格图，只需要一个矩阵即可绘图，以下网格图都有一定的实用价值。</p>
<p><img src="https://pic.imgdb.cn/item/6683c8b8d9c307b7e9d6280d.png" alt="常见类型网格图"></p>
<p><strong>(3) 统计图</strong></p>
<p>统计图一般做数据分析时使用。</p>
<p><img src="https://pic.imgdb.cn/item/6683c921d9c307b7e9d71535.png" alt="常见统计图"></p>
<p>以上图形只会挑选其中最关键、使用最频繁的函数进行讲解。其它情况可百度或者去官网查看使用方法。</p>
<p>除了上述链接中的这五类基本图表外，还有更多作者提前画好的花哨的靓图详见 <a href="https://matplotlib.org/stable/gallery/index.html，看到自己想画的图点进去即可学习示例代码。">https://matplotlib.org/stable/gallery/index.html，看到自己想画的图点进去即可学习示例代码。</a></p>
<p>最后，作者还温馨地向小白的我们提供了从0开始到大神的完整教程，详见:<a href="https://matplotlib.org/stable/tutorials/index.html。">https://matplotlib.org/stable/tutorials/index.html。</a></p>
<h5 id="Ⅱ-二维图绘制"><a href="#Ⅱ-二维图绘制" class="headerlink" title="Ⅱ 二维图绘制"></a>Ⅱ 二维图绘制</h5><p>二维图，仅演示plot线型图函数，只因其可以替代其它所有二维图。</p>
<p><strong>(1) 设置颜色</strong></p>
<p>plot()函数含<code>color</code>关键字，可以设置线条的颜色，如示例所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备敬据</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y2 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">y3 = [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matlab方式</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.plot(x,y1, color=<span class="string">&#x27;red&#x27;</span>)     <span class="comment"># 红色全拼</span></span><br><span class="line">plt.plot(x,y2, color=<span class="string">&#x27;b&#x27;</span>)       <span class="comment"># 蓝色缩写</span></span><br><span class="line">plt.plot(x,y3, color=<span class="string">&#x27;#47ADC7&#x27;</span>) <span class="comment"># 16进制颜色代码</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6683cb1ed9c307b7e9da945c.png" alt="颜色设置" style="zoom:50%"></p>
<p><strong>(2) 设置不同风格</strong></p>
<p>plot()函数含<code>linestyle</code> 关键字，可以设置线条的风格，如示例所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备敬据</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y2 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">y3 = [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matlab方式</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.plot(x,y1, color=<span class="string">&#x27;red&#x27;</span>, linestyle=<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">plt.plot(x,y2, color=<span class="string">&#x27;b&#x27;</span>, linestyle=<span class="string">&#x27;-.&#x27;</span>)</span><br><span class="line">plt.plot(x,y3, color=<span class="string">&#x27;#47ADC7&#x27;</span>, linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><strong>(3) 设置粗细</strong></p>
<p>plot()函数含<code>linewidth</code> 关键字，可以设置线条的粗细，如示例所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备敬据</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y2 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">y3 = [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matlab方式</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.plot(x,y1, color=<span class="string">&#x27;red&#x27;</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, linewidth=<span class="number">0.5</span>)</span><br><span class="line">plt.plot(x,y2, color=<span class="string">&#x27;b&#x27;</span>, linestyle=<span class="string">&#x27;-.&#x27;</span>, linewidth=<span class="number">3.5</span>)</span><br><span class="line">plt.plot(x,y3, color=<span class="string">&#x27;#47ADC7&#x27;</span>, linestyle=<span class="string">&#x27;:&#x27;</span>, linewidth=<span class="number">6.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6683cdd6d9c307b7e9dfc531.png" alt="粗细设置" style="zoom:50%"></p>
<p><strong>(4) 设置标记</strong></p>
<p>plot()函数含 <code>marker</code> 关键字，可以设置线条的标记，如示例所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备敬据</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y2 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">y3 = [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matlab方式</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.plot(x,y1, color=<span class="string">&#x27;red&#x27;</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.plot(x,y2, color=<span class="string">&#x27;b&#x27;</span>, linestyle=<span class="string">&#x27;-.&#x27;</span>, marker=<span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">plt.plot(x,y3, color=<span class="string">&#x27;#47ADC7&#x27;</span>, linestyle=<span class="string">&#x27;:&#x27;</span>, marker=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6683ce79d9c307b7e9e0dca1.png" alt="标记设置" style="zoom:50%"></p>
<p>标记的尺寸可以由 <code>markersize</code> 关键字调整，其值以3至9为宜</p>
<h5 id="Ⅲ-网格图"><a href="#Ⅲ-网格图" class="headerlink" title="Ⅲ 网格图"></a>Ⅲ 网格图</h5><p>网格图，仅演示<code>imshow()</code>函数，只因另外两个在深度学习中几乎用不到。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">1000</span>)</span><br><span class="line">l = np.sin(x)*np.cos(x).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.imshow(l, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line"><span class="comment"># 显示颜色柱</span></span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6683d5d5d9c307b7e9ef3ab4.png" alt="网格图" style="zoom:50%"></p>
<h5 id="Ⅳ-统计图"><a href="#Ⅳ-统计图" class="headerlink" title="Ⅳ 统计图"></a>Ⅳ 统计图</h5><p>统计图，仅演示<code>hist</code>函数，只因其它函数主要出现在数据分析领域。为避免将直方图hist与条形图bar混，现说明：条形图bar可用plot 替代；hist则是统计学的函数，是为了看清某分布的均值与标准差。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 10000 个标准正态分布的样本</span></span><br><span class="line">data=np.random.randn(<span class="number">10000</span>)</span><br><span class="line"><span class="comment"># Matlab 方式</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.hist( data )</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6683d690d9c307b7e9f078bb.png" alt="默认直方图" style="zoom:50%"></p>
<p><strong>(1) 参数1：区间个数</strong></p>
<p>bins 关键字参数即区间划分的数量，默认为10，现将其改为为30。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">plt.hist( data, bins=<span class="number">30</span> )</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6683d6fcd9c307b7e9f1384d.png" alt="直方图区间参数" style="zoom:50%"></p>
<p><strong>(2) 参数2：透明度</strong></p>
<p>Alpha 关键字表示透明度，默认为1，现将其改为为0.5。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">plt.hist( data, alpha=<span class="number">0.5</span> )</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6683d762d9c307b7e9f21b75.png" alt="透明度设置" style="zoom:50%"></p>
<p><strong>(3) 参数3：图表类型</strong> </p>
<p><code>histtype</code> 表示类型，默认为’bar’，现将其改为为’stepfilled’，图形浑然一体。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">plt.hist( data, histtype=<span class="string">&#x27;stepfilled&#x27;</span> )</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6683d859d9c307b7e9f3d87e.png" alt="图表类型" style="zoom:50%"></p>
<p><strong>(4) 参数4：直方图颜色</strong></p>
<p>使用<code>color</code>表示直方图的颜色。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">plt.hist( data, color=<span class="string">&#x27;green&#x27;</span> )	<span class="comment"># 颜色设为绿色</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6684080dd9c307b7e9595b71.png" alt="颜色参数" style="zoom:50%"></p>
<p><strong>(5) 参数5：边缘颜色</strong></p>
<p>使用<code>edgecolor</code>表示直方图边缘的颜色。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">plt.hist( data, edgecolor=<span class="string">&quot;k&quot;</span> )	<span class="comment"># 边缘设置为黑色</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h4 id="2-4-4-图窗属性"><a href="#2-4-4-图窗属性" class="headerlink" title="2.4.4 图窗属性"></a>2.4.4 图窗属性</h4><h5 id="Ⅰ-坐标轴上下限"><a href="#Ⅰ-坐标轴上下限" class="headerlink" title="Ⅰ 坐标轴上下限"></a>Ⅰ 坐标轴上下限</h5><p>尽管 Matplotlib 会自动调整图窗为最佳的坐标轴上下限，但叛逆的我们知道很多时候仍需手动设置，才能适应当时的情况。</p>
<p>设置其坐标轴上下限，有两种方法：<code>lim</code>法与<code>axis</code>法。</p>
<p><strong>(1) lim法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matlab方式(lim法)</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.xlim(<span class="number">1</span>, <span class="number">10</span>)	<span class="comment"># 设置x轴为1~10</span></span><br><span class="line">plt.ylim(<span class="number">1</span>, <span class="number">135</span>)	<span class="comment"># 设置y轴为1~135</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/66840badd9c307b7e960e873.png" alt="lim法" style="zoom:50%"></p>
<p><strong>(2) axis法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.axis([<span class="number">1</span>,<span class="number">6</span>, <span class="number">1</span>, <span class="number">150</span>]) 	<span class="comment"># 设置x轴为1~16， 设置y轴为1~150</span></span><br><span class="line">plt.grid()	<span class="comment"># 添加网格</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/66840c7cd9c307b7e9629c13.png" alt="axis法" style="zoom:50%"></p>
<h5 id="Ⅱ-图标题与轴名称"><a href="#Ⅱ-图标题与轴名称" class="headerlink" title="Ⅱ 图标题与轴名称"></a>Ⅱ 图标题与轴名称</h5><p>主要使用<code>xlabel</code>、<code>ylabel</code>、<code>title</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  <span class="comment"># python中画图所用到的第三方库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1956-1920年对应的GDP值，单位亿元</span></span><br><span class="line">y = [<span class="number">1470.1</span>, <span class="number">1447.5</span>, <span class="number">1312.3</span>, <span class="number">1071.4</span>, <span class="number">1030.7</span>, <span class="number">911.6</span>, <span class="number">859.8</span>, <span class="number">824.4</span>, <span class="number">679.1</span>]  </span><br><span class="line"><span class="comment"># 1952-1960年</span></span><br><span class="line">x = [<span class="number">1960</span>, <span class="number">1959</span>, <span class="number">1958</span>, <span class="number">1957</span>, <span class="number">1956</span>, <span class="number">1955</span>, <span class="number">1954</span>, <span class="number">1953</span>, <span class="number">1952</span>]  </span><br><span class="line"></span><br><span class="line">plt.scatter(x, y)  <span class="comment"># 画点，将列表中的值分别画在plot中</span></span><br><span class="line">plt.plot(x, y, color=<span class="string">&#x27;r&#x27;</span>)  <span class="comment"># 连线，按顺序将</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;year&quot;</span>)  <span class="comment"># 横轴的标签</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;GDP/Billion&quot;</span>)  <span class="comment"># 纵轴的标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Changes in China&#x27;s GDP since the founding of the PRC&quot;</span>)  <span class="comment"># 图像标头</span></span><br><span class="line">plt.show()  <span class="comment"># 相当于将图像显示出，必须要加上才能显示出图像</span></span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6268bae1239250f7c5112e80.jpg" alt="显示结果" style="zoom:70%"></p>
<h5 id="Ⅲ-图例"><a href="#Ⅲ-图例" class="headerlink" title="Ⅲ 图例"></a>Ⅲ 图例</h5><p>一般图例会出现在二维图与统计图中，网格图则用的是颜色条。</p>
<p>主要使用<code>label</code>和<code>legend</code>两个参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">y1 = np.array([<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>])</span><br><span class="line">y2 = y1/<span class="number">2</span></span><br><span class="line">y3 = y2 + <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Matlab方式(lim法)</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.plot(x,y1, label=<span class="string">&#x27;legend1&#x27;</span>)</span><br><span class="line">plt.plot(x,y2, label=<span class="string">&#x27;legend2&#x27;</span>)</span><br><span class="line">plt.plot(x,y3, label=<span class="string">&#x27;legend3&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>如果你不想展示某些线条的图例，只需要去除该函数中的label关键字即可(除了 plot 外，其它画图函数也携带label关键字参数)。</p>
<p>当然，有些教程不使用label关键字参数，使用下个示例的操作来替代上面的<code>label</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Fig3 = plt.figure()</span><br><span class="line">plt.plot(x,y1)</span><br><span class="line">plt.plot(x,y2)</span><br><span class="line">plt.plot(x,y3)</span><br><span class="line">plt.legend([<span class="string">&#x27;y=x&#x27;</span>, <span class="string">&#x27;y=0&#x27;</span>, <span class="string">&#x27;y=-x’])</span></span><br></pre></td></tr></table></figure>
<p>legend 还有三个常用的关键字参数：<code>loc</code>、<code>frameon</code>和<code>ncol</code>。</p>
<ul>
<li>loc用于表示图例位置，该关键字在<code>upper、center、lower</code>中选一个，在<code>left、center、right</code> 中选一个,用法如 <code>loc=&#39;upper right&#39;</code>，也可以 <code>loc=&#39;best&#39;</code>。</li>
<li>frameon用于表示图例边框，去边框是<code>frameon=False</code>。</li>
<li>ncol用于表示图例的列数，默认是1列，也可以通过<code>ncol=2</code>调为2列。</li>
</ul>
<p><a href="https://blog.csdn.net/qq_42864343/article/details/135534059">解决python画图无法显示中文的问题 - CSDN博客</a></p>
<p><a href="https://www.bilibili.com/read/cv28733784/">Python绘图设置新罗马字体和设置字体大小 - Bilibili</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
        <category>编程语言学习</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
        <tag>编写规范</tag>
      </tags>
  </entry>
  <entry>
    <title>科研日记</title>
    <url>/2023/07/16/Research-Diary/</url>
    <content><![CDATA[<h4 id="2023-07-14"><a href="#2023-07-14" class="headerlink" title="2023-07-14"></a>2023-07-14</h4><p>今日主要完成工作：泛读并简要整理如下5篇文献。</p>
<ol>
<li>第1篇是2022年西安电子科技大学的任启宏的硕士论文——《复杂杂波背景下的雷达目标检测方法研究》 </li>
<li>第2篇是2017年海军航空工程学院的陈小龙发表的一篇小论文——《高分辨稀疏表示及其在雷达动目标检测中的应用》 </li>
<li>第3篇是2020年江苏自动化研究所的潘冬华发表的一篇小论文——《海空小目标雷达检测算法研究》 </li>
<li>第4篇是2021年西安电子科技大学的许述文发表的一篇小论文——《海杂波背景下雷达目标贝叶斯检测算法》 </li>
<li>第5篇是2013年中国民航大学的吴仁彪发表的一篇小论文——《机载雷达高速空中机动目标检测新方法》  </li>
</ol>
<h4 id="2023-07-15"><a href="#2023-07-15" class="headerlink" title="2023-07-15"></a>2023-07-15</h4><p>今日主要完成工作：泛读并简要整理如下6篇文献。</p>
<ol>
<li>第1篇是2022年电子科技大学的吴佳奇的硕士论文——《机载雷达高速目标积累检测算法研究》 </li>
<li>第2篇是2013年中国民航大学的贾琼琼发表的一篇小论文——《基于修正STAP的高速空中机动目标检测方法》 </li>
<li>第3篇是2019年国防科技大学的回丙伟发表的一篇小论文——《空中弱小目标检测跟踪测试基准》 </li>
<li>第4篇是2015年西安电子科技大学的饶烜的博士论文——《空中弱小目标长时间相参积累检测技术研究》 </li>
<li>第5篇是2022年西安电子科技大学的董佳鑫的硕士论文——《雷达低慢小目标检测算法研究》  </li>
<li>第6篇是2023年烟台大学的秦天慈发表的一篇综述文献——《雷达恒虚警目标检测处理技术综述》  </li>
</ol>
<h4 id="2023-07-16"><a href="#2023-07-16" class="headerlink" title="2023-07-16"></a>2023-07-16</h4><p>今日主要完成工作：泛读并简要整理如下4篇文献。</p>
<ol>
<li>第1篇是2007年深圳大学的郭尊华发表的一篇综述文献——《雷达目标联合跟踪与识别技术研究》 </li>
<li>第2篇是2017年兰州市27支局的胡志宏发表的一篇小文章——《浅谈基于粒了滤波的微弱雷达目标检测方法》 </li>
<li>第3篇是2012年南京航空航天大学的张弓发表的一篇综述文献——《压缩感知在雷达目标探测与识别中的研究进展》</li>
<li>第4篇是2023年电子科技大学的林兰瑾的博士论文——《运动平台雷达目标检测中的相参积累方法研究》 </li>
</ol>
<h4 id="2023-07-17"><a href="#2023-07-17" class="headerlink" title="2023-07-17"></a>2023-07-17</h4><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>学术科研</category>
      </categories>
      <tags>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>空时自适应处理STAP算法梳理</title>
    <url>/2023/08/08/STAP-Algorithm-Foundation/</url>
    <content><![CDATA[<h4 id="1-STAP算法简介"><a href="#1-STAP算法简介" class="headerlink" title="1. STAP算法简介"></a>1. STAP算法简介</h4><p>空时自适应处理(STAP)是由L.E. Brennan等人<sup><a href="#[1]">[1]</a></sup>于1973年提出，利用机载雷达杂波信号存在空时耦合特性。</p>
<p>STAP技术充分利用多通道雷达提供的多个空域通道信息和相干脉冲串提供的时域信息，通过空域和时域二维自适应滤波的方式，实现杂波的有效抑制。STAP 技术的自适应体现在对外部杂波环境的准确感知及应对，其依赖于待检测距离单元( Rangecell Under Test, RUT) 杂波协方差矩阵(Clutter Covariance Matrix, CCM) 的实时获取，而CCM 在实际应用中通常是未知的，需要通过一定数量的独立同分布( Independent Identically Distributed, IID)训练样本<strong>最大似然估计</strong>得到。根据Reed-Mallett-Brennan准则<sup><a href="#[2]">[2]</a></sup>，确保STAP输出信杂噪比损失小于$3\text{ dB}$以内所需<strong>IID样本</strong>数应至少为<strong>2倍系统自由度</strong>。但机载雷达通常工作在非均匀杂波环境中，难以获得足够的IID训练样本<sup><a href="#[3]">[3]</a></sup>。</p>
<p>目前，国内外解决上述问题主要两类技术： 一类是将含奇异值样本剔除，使得样本均匀化；另一类是降低均匀样本需求，设计小样本条件下次最优STAP处理器。具体方法划分如图1.1。</p>
<center><img src="https://pic.imgdb.cn/item/64ddcb58661c6c8e543b0a68.jpg" alt="图1.1 STAP相关算法" style="zoom:50%"></center>

<ul>
<li>降维STAP将样本需求由全局系统自由度降至局域系统自由度范畴。</li>
<li>降秩STAP基于子空间处理，摒除了由于噪声发散引起的自适应方向图畸变问题，将样本需求降至杂波秩量级，但性能严重依赖于杂波秩估计准确性，且运算量巨大。</li>
<li>平滑STAP可利用有限样本的空时平滑获取更多样本，但样本间的强相关性及其固有孔径损失使得该类算法性能不甚理想。</li>
<li>直接数据域STAP仅利用RUT数据，消除了非均匀杂波影响，但易受噪声影响且存在空时孔径损失导致性能无法达到次最优，同时空域平滑处理也决定了其仅适用于均匀线/面阵机载雷达。</li>
<li>参数化STAP本质为空-时最小二乘有限冲激响应滤波器，在理想条件下可显著降低样本需求，但在实际应用中性能受其模型准确性影响较大。</li>
<li>知识辅助STAP利用先验信息所估CCM对杂波进行预白化，以降低后续STAP 处理负担，但如何准确获取及有效利用先验信息仍是当前待解决难题。</li>
</ul>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-1wig{font-weight:bold;text-align:left;vertical-align:top}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg" style="undefined;table-layout: fixed; width: 574px">
<colgroup>
<col style="width: 50.0px">
<col style="width: 150.0px">
<col style="width: 210.0px">
<col style="width: 280.0px">
</colgroup>
<thead>
  <tr>
    <td class="tg-7btt" rowspan="20"><br><br><br><br>S<br>T<br>A<br>P<br>算<br>法<br>概<br>述</td>
    <td class="tg-fymr">关键问题</td>
    <td class="tg-fymr">涉及的相关方法</td>
    <td class="tg-1wig">注释</td>
  </tr>
  <tr>
    <td class="tg-fymr" rowspan="2">运算量和误差<br></td>
    <td class="tg-0pky">降维STAP</td>
    <td class="tg-0lax" rowspan="2"></td>
  </tr>
  <tr>
    <td class="tg-0pky">降秩STAP</td>
  </tr>
  <tr>
    <td class="tg-fymr" rowspan="7"><br><br><br><br>非均匀杂波</td>
    <td class="tg-0pky">功率非均匀抑制法</td>
    <td class="tg-0lax" rowspan="7">机载雷达所照射的范围非常广，能达到几百公里，在这个范围内地面/地形的情况不可能是一成不变的(如陆海交界)。</td>
  </tr>
  <tr>
    <td class="tg-0pky">非均匀检测器</td>
  </tr>
  <tr>
    <td class="tg-0pky">直接数据域法</td>
  </tr>
  <tr>
    <td class="tg-0pky">模型参数化STAP法</td>
  </tr>
  <tr>
    <td class="tg-0pky">知识辅助的STAP法</td>
  </tr>
  <tr>
    <td class="tg-0pky">稀疏恢复STAP法</td>
  </tr>
  <tr>
    <td class="tg-0pky">混合STAP法</td>
  </tr>
  <tr>
    <td class="tg-fymr" rowspan="7"><br><br><br><br>非平稳杂波问题</td>
    <td class="tg-0pky">一维补偿类法</td>
    <td class="tg-0lax" rowspan="7">主要是由雷达天线放置的形式和载机飞行方向之间的几何关系，例如若机载相控阵阵面于飞行方向不平行(存在夹角)，此时杂波回波谱会随着距离变化。</td>
  </tr>
  <tr>
    <td class="tg-0lax">二维补偿类法</td>
  </tr>
  <tr>
    <td class="tg-0lax">空时内插类法</td>
  </tr>
  <tr>
    <td class="tg-0lax">权值调整类法</td>
  </tr>
  <tr>
    <td class="tg-0lax">逆协方差矩阵预测类法</td>
  </tr>
  <tr>
    <td class="tg-0lax">基于俯仰维预滤波法</td>
  </tr>
  <tr>
    <td class="tg-0pky">3D-STAP法</td>
  </tr>
  <tr>
    <td class="tg-fymr" rowspan="3"><br>空时自适应检测<br></td>
    <td class="tg-0pky">基于GLRT准则的STAD</td>
    <td class="tg-0lax" rowspan="3">传统STAP主要用于杂波抑制，STAD则是将杂波抑制与目标检测结合到一起考虑。</td>
  </tr>
  <tr>
    <td class="tg-0pky">基于Rao准则的STAD</td>
  </tr>
  <tr>
    <td class="tg-0pky">基于Wald准则的STAD</td>
  </tr>
</thead>
</table>

<h4 id="2-STAP信号模型"><a href="#2-STAP信号模型" class="headerlink" title="2. STAP信号模型"></a>2. STAP信号模型</h4><p>本部分主要参考文献<a href="#[12]">[12]</a>第二章，机载雷达的相关参数设置如下：</p>
<ul>
<li>机载平台高度为$H$，运动速度为$v$且方向平行于$X$轴；</li>
<li>机载雷达的载频为$f_c$(波长为：$\lambda_c = \dfrac{c}{f_c}$)，初始相位为$\phi$；</li>
<li>机载平台的运动方向与阵面天线轴向的夹角为$\alpha$；</li>
<li>天线为含有$N$个阵元的水平均匀线阵，阵元间距为$d$；</li>
<li>一个相干处理间隔(CPI)内发射$M$个脉冲；</li>
<li>脉冲重复频率(PRF)为$f_r = \dfrac{1}{T_r}$，脉冲宽度为$T_p$；</li>
</ul>
<blockquote>
<p>此外，文献<a href="#[15]">[15]</a>和文献<a href="#[16]">[16]</a>关于STAP回波的建模写的也特别好，本博客的“2.3 干扰模型”和“2.4 噪声模型”主要参考这两篇文献。</p>
<p>并且文献<a href="#[16]">[16]</a>对于下文公式$(2-21)$中模糊函数部分也有解释，可以看一下。</p>
</blockquote>
<h5 id="2-1-窄带阵目标信号模型"><a href="#2-1-窄带阵目标信号模型" class="headerlink" title="2.1 窄带阵目标信号模型"></a>2.1 窄带阵目标信号模型</h5><p>假设此时存在一个目标，与雷达视线俯仰角为$\varphi$，相对阵面轴向的方位角为$\theta$，目标相对于天线轴向的入射锥角为$\psi$，目标与载机间的相对径向速度为$v_t$。具体示意图如下。</p>
<center><img src="https://pic.imgdb.cn/item/64ddd312661c6c8e5459c6df.jpg" alt="图2.1 雷达对目标观测示意图" style="zoom:50%"></center>

<p>发射的时域完整波形为：</p>
<script type="math/tex; mode=display">
s^{\mathrm t}(t) = a_t u(t) \mathrm e^{\mathrm j 2 \pi f_c t} \mathrm e^{\mathrm j \phi} \tag{2-1}</script><p>式中上标用字母$t$表示该式为$s^{\mathrm t}(t)$的时域形式，$a_t$表示发射信号的复幅度，$u(t)$为脉冲调制的发射信号基带波形。</p>
<p>考虑到雷达多脉冲相参处理情况，$t = t_k + t_m$为全时间变量，$t_k$为快时间变量，其取值范围为$[0, T_r]$，$t_m = mT_r \quad (m =1,2, \cdots, M)$为慢时间变量。等效相位中心发射第$m$个脉冲经目标散射回到第$n$个阵元的回波信号可以表示为：</p>
<script type="math/tex; mode=display">
s^{\mathrm t}_{n, m}(t_k) = a_r u(t_k - \tau_{c, n, m}) \mathrm e^{\mathrm j 2 \pi f_c (t_k - \tau_{c, n, m})} \mathrm e^{\mathrm j \phi}, \quad n = 1,2, \cdots, N \tag{2-2}</script><p>注意，式$(2-2)$中时间变量为$t_k$ (PS：我之前一直认为这里用全时间变量$t$更合适，其实是错误的，这里$t_k$是表示已经减去了发射脉冲的慢时间间隔，根据下文$\tau_{c,n,m}$的计算可知，$\tau_{c,n,m}$表示的是第$nm$个脉冲从发射到接收的延迟，不是第$nm$个脉冲相对第$1~1$的延迟)，$a_r$表示回波信号幅度，主要由发射功率、系统损耗、距离、天线方向图和目标后向散射特性等决定。复包络信号$u(t)$的宽度为$T_p$ ，当$0 \leq t \leq T_p$时，$u(t)$为发射信号的复包络；当$T_p \leq t \leq T_r$时，$u(t) = 0$。</p>
<p>设第1号阵元为参考阵元，第1个脉冲为参考脉冲，则：</p>
<script type="math/tex; mode=display">
\tau_{c, n, m} = \dfrac{2R - (n-1)d \cos \psi - 2(m-1)T_r v_t}{c}</script><p>其中，$\tau_c = \dfrac{2R}{c}$是参考脉冲由等效相位中心发射经目标散射返回到参考阵元的双程时延，简称目标距离延时；$\tau_m = \dfrac{2(m-1)T_r v_t}{c}$为第$m$个脉冲相对参考脉冲的时延；$\tau_n = \dfrac{(n-1)d \cos \psi}{c}$为第$n$个阵元相对参考阵元的时延。</p>
<p>将接收到的回波信号进行混频，搬移到基带后，第$n$个阵元第$m$个脉冲的回波信号表示为：</p>
<script type="math/tex; mode=display">
s^{\mathrm t}_{n, m}(t_k) = a_r u(t_k - \tau_{c, n, m}) \mathrm e^{- \mathrm j 2 \pi f_c   \tau_{c, n, m}}  \tag{2-3}</script><p>当相控阵雷达系统为<strong>窄带系统</strong>时，式中<strong><font color="red">回波信号的复包络在阵元间和脉冲间的相对延时引起的变化可以忽略不计</font></strong>，也即在包络延时中用$\tau_c$代替$\tau_{c, n, m}$，上式表示为：</p>
<script type="math/tex; mode=display">
s^{\mathrm t}_{n, m}(t_k) = a_r u(t_k - \tau_{c}) \mathrm e^{- \mathrm j 2 \pi f_c   \tau_{c, n, m}}  \tag{2-4}</script><p>接着，对混频后的回波信号进行离散时间采样，以$f_s$为采样频率均匀采样，脉冲间隔$T_r$时间内可得采样点数$L = T_r f_s$。离散采样后，$N$个阵元$M$个脉冲的回波信号离散形式为：</p>
<script type="math/tex; mode=display">
\boldsymbol S^{\mathrm t} = [\boldsymbol s^{\mathrm t}_{1,1} \quad \cdots \quad \boldsymbol s^{\mathrm t}_{N,1} \quad \boldsymbol s^{\mathrm t}_{1,2} \quad  \cdots \quad \boldsymbol s^{\mathrm t}_{N,2} \quad \cdots \quad \boldsymbol s^{\mathrm t}_{1,M} \quad \cdots \quad \boldsymbol s^{\mathrm t}_{N,M} ] \tag{2-5}</script><p>其中，$\boldsymbol s^{\mathrm t}_{n,m}$为第$n$个阵元接收到第$m$个脉冲的$L$ 个离散回波信号组成的矢量：</p>
<script type="math/tex; mode=display">
\boldsymbol s^{\mathrm t}_{n,m} = \left[s^{\mathrm t}_{n,m}\left(\dfrac{0}{L}T_r\right) \quad \cdots \quad s^{\mathrm t}_{n,m}\left(\dfrac{l}{L}T_r\right)  \quad \cdots \quad  s^{\mathrm t}_{n,m}\left(\dfrac{L-1}{L}T_r\right) \right]^{\mathrm T} \tag{2-6}</script><p>其中，$s^{\mathrm t}_{n,m}\left(\dfrac{l}{L}T_r\right)$表示第$n$个阵元第$m$个脉冲回波的第$l$ 个采样点的信号：</p>
<script type="math/tex; mode=display">
s^{\mathrm t}_{n,m}\left(\dfrac{l}{L}T_r\right) = a_r u\left(\dfrac{l}{L}T_r - \tau_c\right)\mathrm e^{- \mathrm j 2 \pi f_c   \tau_{c, n, m}}  \tag{2-7}</script><p>时间离散后的发射复包络信号的矢量形式为：</p>
<script type="math/tex; mode=display">
\boldsymbol u = \left[u\left(\dfrac{0}{L}T_r\right) \quad \cdots \quad u\left(\dfrac{l}{L}T_r\right) \quad \cdots \quad u\left(\dfrac{L-1}{L}T_r\right)\right]^{\mathrm T} \tag{2-8}</script><p>考虑到雷达的脉冲压缩(脉冲的匹配滤波)通常在频域进行，我们对第$n$个阵元接收到第$m$个脉冲的离散回波信号$\boldsymbol s^{\mathrm t}_{n,m}$做快速傅里叶变换(FFT)处理，可以得到距离频域的信号形式：</p>
<script type="math/tex; mode=display">
\boldsymbol s^{\mathrm f}_{n,m} = \mathrm{FFT}(\boldsymbol s^{\mathrm t}_{n,m}) = \boldsymbol F^{\mathrm H}\boldsymbol s^{\mathrm t}_{n,m} \tag{2-9}</script><p>式中$\boldsymbol s^{\mathrm f}_{n,m}$为$L \times 1$维列向量，其上标用字母$f$ 表示该式为信号$\boldsymbol s^{\mathrm t}_{n,m}$的频域形式。$\boldsymbol F$为$L \times L$维的FFT矩阵，第$l$列矢量$\boldsymbol f_l$表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol f_l=\left[\begin{array}{c}
1 \\ \mathrm e^{\mathrm j 2\pi 1 \times (l - L/2)/L} \\ \vdots \\ \mathrm e^{\mathrm j 2\pi (L-1) \times (l - L/2)/L}
\end{array}\right],
\quad
\boldsymbol F=\left[\begin{array}{ccccc}
\boldsymbol f_0 & \boldsymbol f_1 & \cdots & \boldsymbol f_{L-1}
\end{array}\right]
\tag{2-10}</script><p>第$l_f$号滤波器的中心频率为：$f_l = \dfrac{l_f - L_f/2}{L_f}f_s$，其中$l_f = 0,1,\cdots , L_f -1$表示距离频域滤波器序号，$L_f = L$表示距离频域滤波器个数(为了区分时域采样点数和频域滤波器数，在频域使用$L_f$）。由离散时域信号的DFT时移特性，距离频率为$f_l$的信号可以写成：</p>
<script type="math/tex; mode=display">
s^{\mathrm f}_{n,m} = a_r U(f_l)  \exp\left(-\mathrm j 2\pi \dfrac{l_f - L_f/2}{L_f} f_s \tau_c\right)  \exp\left(-\mathrm j 2\pi f_c \tau_{c,n,m}\right) \tag{2-11}</script><p>其中，$U(f_l)$是发射脉冲复包络的频谱，是由离散后的发射复包络$u\left(\dfrac{l}{L}T_r\right)$做$L$点FFT处理得到的。</p>
<p>然后在距离频域进行匹配滤波，使用基带信号匹配滤波函数：</p>
<script type="math/tex; mode=display">
h(t) = u^*(-t) \tag{2-12}</script><p>其时间离散后的矢量形式表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol h =  \left[h\left(\dfrac{0}{L}T_r\right) \quad \cdots \quad h\left(\dfrac{l}{L}T_r\right) \quad \cdots \quad h\left(\dfrac{L-1}{L}T_r\right)\right]^{\mathrm T} \tag{2-13}</script><p>上式做$L$点FFT处理，得到距离频域的匹配滤波响应：</p>
<script type="math/tex; mode=display">
\boldsymbol H(f) = \mathrm{FFT}(\boldsymbol h) = \boldsymbol F^{\mathrm H} \boldsymbol h \tag{2-14}</script><p>$\boldsymbol H(f)$是$L \times 1$维列向量，表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol H
& =\left[H(f_0), \cdots, H(f_l), \cdots, H(f_{L_f-1}) \right]^{\mathrm T} \\
& =\left[H\left(\dfrac{-L_f/2}{L_f}f_s\right) \quad \cdots \quad H\left(\dfrac{l_f - L_f/2}{L_f}f_s\right) \quad \cdots \quad H\left(\dfrac{L_f/2-1}{L_f}f_s\right)\right]^{\mathrm T} 
\end{aligned} \tag{2-15}</script><p>其中，$H(f_l)$为距离频率为$f_l = \dfrac{l_f - L_f/2}{L_f}f_s$的匹配滤波信号：</p>
<script type="math/tex; mode=display">
H(f_l) = U^*(f_l) \tag{2-16}</script><p>对窄带回波信号在频域进行匹配滤波，匹配滤波后的频域输出为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x_{n, m, l_{f}}^{\mathrm{f}} & =s_{n, m, l_{f}}^{\mathrm{f}} H_{l_{f}}=s_{n, m}^{\mathrm{f}}\left(f_l\right) H\left(f_l\right) \\
& =a_r U(f_l) U^*(f_l) \exp\left(-\mathrm j 2 \pi\frac{l_{f}-L_{f} / 2}{L_{f}} f_s \tau_c\right) \exp\left(- \mathrm j 2 \pi f_c \tau_{c, n, m}\right)
\end{aligned} \tag{2-17}</script><p>其中，$x_{n, m, l_{f}}^{\mathrm{f}}$的上标用字母$f $表示该式为信号的频域形式。再对$L$个距离频域输出进行逆傅里叶变换(IFFT)，即：</p>
<script type="math/tex; mode=display">
\boldsymbol x^{\mathrm t}_{n,m} = \mathrm{IFFT}(\boldsymbol x_{n, m}^{\mathrm{f}}) = \boldsymbol T^{\mathrm H} \boldsymbol x_{n, m}^{\mathrm{f}} \tag{2-18}</script><p>其中，$\boldsymbol x_{n, m}^{\mathrm{f}}​$为$L \times 1​$维距离频域输出列向量，$\boldsymbol T​$为$L \times L​$维的IFFT 矩阵，第$l​$列矢量$t_l​$表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol t_l=\left[\begin{array}{c}
1 \\ \mathrm e^{-\mathrm j 2\pi 1 \times (l - L/2)/L} \\ \vdots \\ \mathrm e^{-\mathrm j 2\pi (L-1) \times (l - L/2)/L}
\end{array}\right],
\quad
\boldsymbol T=\left[\begin{array}{ccccc}
\boldsymbol t_0 & \boldsymbol t_1 & \cdots & \boldsymbol t_{L-1}
\end{array}\right] = \boldsymbol F^{\mathrm H}
\tag{2-19}</script><p>$\boldsymbol x^{\mathrm t}_{n,m}$为$L \times 1$维距离时域输出列向量，表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol x^{\mathrm t}_{n,m} = \left[x^{\mathrm t}_{n,m, 0} \quad \cdots \quad x^{\mathrm t}_{n,m,l} \quad \cdots \quad x^{\mathrm t}_{n,m,L-1} \right]^{\mathrm T} \tag{2-20}</script><p>其中第$l$个距离时域的信号输出$x^{\mathrm t}_{n,m, l}$可以表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& x_{n, m, l}^{\mathrm{t}}=\frac{1}{L} \sum_{l_{f}=0}^{L-1} x_{n, m, l_{f}}^{\mathrm{f}} \exp\left(\mathrm j 2 \pi \dfrac{l_{f}-L / 2}{L} l\right) \\

& =\exp\left(-\mathrm j 2 \pi f_c \tau_{c, n, m}\right) \cdot \frac{1}{L} \sum_{l_{f}=0}^{L-1} a_r U\left(f_l\right) U^*(f_l) \exp\left(-\mathrm j 2 \pi \dfrac{l_{f}-L / 2}{L_{f}} f_s \tau_{\mathrm{c}}\right) \exp \left({\mathrm j 2 \pi \frac{l_{f}-L / 2}{L} l}\right) \\

& \approx \exp\left(-\mathrm j 2 \pi f_c \tau_{c, n, m}\right) \cdot \exp \left(\mathrm j 2 \pi \frac{L}{2}\left(\frac{f_s \tau_{\mathrm{c}}}{L_{f}}-\frac{l}{L}\right)\right) \cdot \xi_0 \sum_{l_{f}=0}^{L-1} \exp\left(-\mathrm j 2 \pi \frac{l_{f}}{L_{f}} f_s \tau_{\mathrm{c}}\right) \exp\left(j 2 \pi \frac{l_{f}}{L} l\right) \\

& =\xi_0 \dfrac{\sin \pi L\left(\dfrac{f_{s} \tau_{c}}{L_{f}}-\dfrac{l}{L}\right)}{\sin \pi\left(\dfrac{f_{s} \tau_{c}}{L_{f}}-\dfrac{l}{L}\right)} \exp\left(\mathrm j 2 \pi \dfrac{L}{2}\left(\dfrac{f_{s} \tau_{c}}{L_{f}}-\dfrac{l}{L}\right)\right)\exp\left(-\mathrm j 2 \pi \frac{L-1}{2}\left(\dfrac{f_{s} \tau_{c}}{L_{f}}-\dfrac{l}{L}\right)\right) \exp\left(-j 2 \pi f_{c} \tau_{c, n, m}\right) \\

& \approx \xi_0 \dfrac{\sin \pi L\left(\dfrac{f_{s} \tau_{c}}{L_{f}}-\dfrac{l}{L}\right)}{\sin \pi\left(\dfrac{f_{s} \tau_{c}}{L_{f}}-\dfrac{l}{L}\right)} \exp\left(-\mathrm j 2 \pi f_c \tau_{\mathrm{c}, n, m}\right) \\
\end{aligned} \tag{2-21}</script><p>其中，$x_{n, m, l}^{\mathrm{t}}$的上标用字母$t$表示该式为信号的时域形式，$l = 0,1, \cdots, L -1$表示第$l$号距离门。式中指数项为阵元间的延时相位、脉冲间的延时相位和目标距离延时的相位。</p>
<blockquote>
<p>$x_{n, m, l}^{\mathrm{t}}$的计算中由两个点需要注意：</p>
<p>① 复指数级数求和的计算，这一部分请参考博客文章<a href="https://www.cnblogs.com/junhengwang/p/16696968.html">记忆常用公式  - 1.4.3 常见其他数列求和 - 博客侦探 - 博客园</a>；</p>
<p>② 式中$\xi_0$的意思，这个可是花费了我大量时间，目前我还是没有搞明白，先暂时放弃，但是目前查到的一些相关的资料，这一部分应该是与“匹配滤波器的输出(模糊函数)”有关，可能日后如果有需要可以再仔细研究 —— 文献<a href="#[13]">[13]</a>、文献<a href="#[14]">[14]</a>。</p>
</blockquote>
<p>将目标距离延时的相位和信号输出幅度合并，得到窄带信号匹配滤波后的输出信号复幅度：</p>
<script type="math/tex; mode=display">
\eta_l = \xi_0 \dfrac{\sin \pi L \left(\dfrac{f_s \tau_c}{L_f} - \dfrac{l}{L}\right)}{\sin \pi \left(\dfrac{f_s \tau_c}{L_f} - \dfrac{l}{L}\right)} \exp(-\mathrm j 2 \pi f_c \tau_c) \tag{2-22}</script><p>代入式$(2-21)$整理得第$l$个距离单元回波信号的形式：</p>
<script type="math/tex; mode=display">
x_{n, m, l}^{\mathrm{t}} = \eta_l \exp\left(\mathrm j 2 \pi f_c \tau_{n, m}\right) =  \eta_l \exp\left(\mathrm j 2 \pi f_c (\tau_{n} + \tau_m)\right) \tag{2-23}</script><p>观察上式可以发现，当目标出现在第$l$号距离单元时，$\eta_l$取最大值。</p>
<blockquote>
<p>简要解释为什么目标出现在第$l$号距离单元时，$\eta_l$取最大值：</p>
<p>仅考虑$\eta_l$的模值项——$\xi_0 \dfrac{\sin \pi L \left(\dfrac{f_s \tau_c}{L_f} - \dfrac{l}{L}\right)}{\sin \pi \left(\dfrac{f_s \tau_c}{L_f} - \dfrac{l}{L}\right)}$在$\left(\dfrac{f_s \tau_c}{L_f} - \dfrac{l}{L}\right) = 0$时候取得最大值。因此若目标在第$l$号距离单元，则$\tau_c = \dfrac{l}{f_s}$，此时$\left(\dfrac{f_s \tau_c}{L_f} - \dfrac{l}{L}\right)$恰好等于0，$\eta_l$的模值取得最大。</p>
</blockquote>
<p>对于同一个采样时刻，各阵元各脉冲的目标回波信号复幅度相同，目标峰值会出现在同一个距离单元中。</p>
<p><img src="https://pic.imgdb.cn/item/64df0a04661c6c8e54e839e7.jpg" alt="图2.2 信号处理过程示意图"></p>
<p>由式$(2-23)$可以得到窄带相控阵雷达系统的目标空域导向矢量：</p>
<script type="math/tex; mode=display">
\boldsymbol a^{(t)} = [1 \quad \mathrm e^{\mathrm j 2 \pi \vartheta} \quad \cdots \quad \mathrm e^{\mathrm j 2 \pi (N-1) \vartheta} ]^{\mathrm T} \tag{2-24}</script><p>其中，$\vartheta$表示目标的空域频率，与$\tau_n = \dfrac{d \cos \psi}{c} (n-1)$有关：</p>
<script type="math/tex; mode=display">
\vartheta=f_c \frac{d \cos \psi}{c} \tag{2-25}</script><p>同样地，根据式$(2-23)$可以得出目标时域导向矢量：</p>
<script type="math/tex; mode=display">
\boldsymbol b^{(t)} = [1 \quad \mathrm e^{\mathrm j 2 \pi \varpi} \quad \cdots \quad \mathrm e^{\mathrm j 2 \pi (M-1) \varpi} ]^{\mathrm T} \tag{2-26}</script><p>其中，$\varpi$表示目标的归一化多普勒频率，与$\tau_m = \dfrac{2 T_r v_t}{c} (m-1)$有关：</p>
<script type="math/tex; mode=display">
\varpi = f_c \frac{2 T_r v_{t}}{c} = f_c \frac{2 v_{t}}{c f_r} \tag{2-27}</script><p>由此我们可以推导出窄带目标的空时导向矢量：</p>
<script type="math/tex; mode=display">
\boldsymbol \hbar^{(t)} = \boldsymbol b^{(t)}(\varpi) \otimes \boldsymbol a^{(t)}(\vartheta) \tag{2-28}</script><p>其中，$\otimes$表示Kronecker积。则第$l$号距离单元的$NM \times 1$维目标回波数据$\boldsymbol{x}^{(t)}_l$可表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol{x}^{(t)}_l=\eta_l \cdot \boldsymbol{\hbar}^{(t)} \tag{2-29}</script><p>统一在此说明一下，这里用上标$(t)$表示目标target的回波信号，同样下文中会使用上标$(c)$、$(j)$、$(n)$分别表示杂波、干扰、噪声。</p>
<h5 id="2-2-窄带杂波模型"><a href="#2-2-窄带杂波模型" class="headerlink" title="2.2 窄带杂波模型"></a>2.2 窄带杂波模型</h5><p>机载相控阵雷达与地面杂波的几何关系如图2.3所示。杂波的建模最初文献来自<strong>Ward</strong>撰写的文献<a href="#[14]">[14]</a>。</p>
<center><img src="https://pic.imgdb.cn/item/64ddf75f661c6c8e54e1b052.jpg" alt="图2.3 雷达对地观测示意图" style="zoom:60%"></center>

<p>载机运动方向与阵面天线轴向的夹角为$\alpha$，杂波块相对雷达视线的俯仰角为$\varphi$，相对阵面轴向的方位角为$\theta$，此时杂波块相对于天线轴向的入射锥角为$\psi$，载机的飞行速度为$v$ 。将雷达所照射到的所有地面杂波区域，按照等距离环均匀划分，每个距离环内又按照等方位角均匀划分，得到众多的独立小杂波块，将各个小杂波块的回波叠加起来，就得到了完整的杂波回波。</p>
<blockquote>
<p>PS：其实建立了前面的运动目标的信号模型，杂波模型基本就类比得到结论即可(因为杂波相当于运动速度为0的目标)。</p>
</blockquote>
<p>在上述坐标系中，第$i$个距离环，第$j$个独立杂波块$(\theta_j, \varphi_i)$处杂波的空域频率$\vartheta_{i,j}$可表示为：</p>
<script type="math/tex; mode=display">
\vartheta_{i,j} = f_c \dfrac{d \cos \psi_{i,j}}{c} = f_c \dfrac{d \cos \theta_j \cos \varphi_i}{c} \tag{2-30}</script><p>则有，第$i$个距离环，第$j$个独立杂波块的空域导向矢量为：</p>
<script type="math/tex; mode=display">
\boldsymbol a^{(c)}_{i, j} = \left[1 \quad \mathrm e^{\mathrm j 2 \pi \vartheta_{i,j}} \quad \cdots \quad  \mathrm e^{\mathrm j 2 \pi (N-1) \vartheta_{i,j}} \right]^{\mathrm T} \tag{2-31}</script><p>归一化多普勒频率$\varpi_{i,j}$可表示为：</p>
<script type="math/tex; mode=display">
\varpi_{i,j} = f_c \dfrac{2vT_r \cos(\theta_j + \alpha) \cos \varphi_i}{c} =  f_c \dfrac{2v \cos(\theta_j + \alpha) \cos \varphi_i}{c f_r}\tag{2-32}</script><p>则第$i$个距离环，第$j$个独立杂波块的时域导向矢量为：</p>
<script type="math/tex; mode=display">
\boldsymbol b^{(c)}_{i, j} = \left[1 \quad \mathrm e^{\mathrm j 2 \pi \varpi_{i,j}} \quad \cdots \quad  \mathrm e^{\mathrm j 2 \pi (M-1) \varpi_{i,j}} \right]^{\mathrm T} \tag{2-33}</script><p>由式$(2-31)$和式$(2-33)$可得，第$i$个距离环，第$j$个独立杂波块$(\theta_j, \varphi_i)$处杂波的空时导向矢量：</p>
<script type="math/tex; mode=display">
\boldsymbol \hbar^{(c)}_{i, j} = \boldsymbol b^{(c)}_{i, j}(\varpi) \otimes \boldsymbol a^{(c)}_{i, j}(\vartheta) \tag{2-34}</script><p>位于第$i$个距离门，第$j$个杂波块的杂波回波数据形式为：</p>
<script type="math/tex; mode=display">
\boldsymbol x^{(c)}_{i, j} = \kappa^{(c)}_{i, j} \cdot \boldsymbol \hbar^{(c)}_{i, j} \tag{2-35}</script><p>其中，$\kappa^{(c)}_{i, j}$代表该杂波块的复幅度，并且满足以下关系：</p>
<script type="math/tex; mode=display">
\mathbb{E}\left(\left|\kappa^{(c)}_{i, j}\right|^2\right) = \sigma^2_n \xi_{i,j } \tag{2-36}</script><p>其中，$\mathbb{E}(\cdot)$表示数学期望，$\xi_{i,j}$为第$i$个距离门，第$j$个杂波块的杂噪比(CNR)，$\sigma^2_n$表示噪声功率。</p>
<table width="50px"><td style="word-wrap:break-word;word-break:break-all;" ; bgcolor="HoneyDew"><font size="3">
下面解释一个<strong>距离模糊次数</strong>的概念： <br>

机载相控阵雷达信号带宽为$B$，载机高度为$H$，距离分辨率为$\Delta R = \dfrac{c}{2B}$，若地球曲率和载机高度决定的雷<br>达最大视距是$R_{\max}$，以距离分辨率为间隔将杂波区域等分成若干距离环，则地面上距离环的总数为：
$$
L_{\max} = \dfrac{R_{\max} - H}{c/2B}  \tag{2-37}
$$
而实际上雷达的最大不模糊距离为$R_u = \dfrac{c}{2f_r}$，以最大不模糊距离为间隔，将雷达视距范围$H \sim R_{\max}$的所<br>有距离区域混叠到最大不模糊距离的各个距离环上。雷达的距离模糊次数$N_r$为：
$$
N_r = \left \lfloor \dfrac{R_{\max}}{R_u} \right \rfloor + 1  \tag{2-38}
$$

其中，$\left \lfloor  \cdot \right \rfloor$表示向下取整。

</font></td></table>

<p>综上所述，可以得到第$i$个距离单元的杂波回波数据：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol x^{(c)}_ i = &\sum_{k=1}^{N_r} \sum_{j = 1}^{N_c} \kappa^{(c)}_{k, i, j} \cdot \boldsymbol \hbar^{(c)}_{k, i, j} \\
= & \sum_{k=1}^{N_r} \sum_{j = 1}^{N_c} \kappa^{(c)}_{k,i, j} \cdot\boldsymbol b^{(c)}_{k, i, j}(\varpi) \otimes \boldsymbol a^{(c)}_{k, i, j}(\vartheta)
\end{aligned} \tag{2-39}</script><p>其中，$\kappa^{(c)}_{k,i, j}$表示第$k$次模糊到第$i$个距离单元的第$j$个杂波块的复幅度，$N_c$为每个杂波环内的杂波块数，$\boldsymbol \hbar^{(c)}_{k, i, j}$表示相应的空时导向矢量。</p>
<h5 id="2-3-干扰模型"><a href="#2-3-干扰模型" class="headerlink" title="2.3 干扰模型"></a>2.3 干扰模型</h5><p>本小节仅研究典型的噪声压制干扰信号，并对其进行建模，其他的干扰方式将在第三章和第四章作详细描述。噪声压制干扰机通常被置于距离敌方雷达较远的地基平台或机载平台，通过发射大功率、宽频带的噪声干扰信号来遮盖有用信号，尽可能地降低目标信噪比，从而实现对接收机的阻塞作用和对目标的压制作用。<strong>根据窄带假设，干扰信号在阵元间的传播时间相较于$1/B$要小得多，所以干扰信号在阵元之间是相关的；当雷达的PRF 明显小于接收机的瞬时带宽时，干扰信号在脉冲之间不相关。</strong>因此，干扰信号在空域上看起来像点目标或离散的杂波源，在时域的干扰效果则类似热噪声。</p>
<p>第$m$个脉冲重复周期(Pulse Repetition Interval, PRI)的空间快拍的干扰分量表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol x^{(j)}_{m} = \gamma_m \boldsymbol a_j \tag{2-40}</script><p>其中，$\gamma_m$为第$m$个PRI 的干扰信号幅度，$\boldsymbol a_j$为$N \times 1$维干扰空间导向矢量。</p>
<p>设干扰信号俯仰角$\varsigma$，方位角$\epsilon$，可以得到干扰信号的空时快拍为：</p>
<script type="math/tex; mode=display">
\boldsymbol x^{(j)} = \boldsymbol \gamma_j \otimes \boldsymbol a_j \tag{2-41}</script><p>其中，$\boldsymbol \gamma_j$是服从复高斯分布的干扰幅度，具体形式如下：</p>
<script type="math/tex; mode=display">
\boldsymbol \gamma_j = [\gamma_0  \quad \gamma_1 \quad \cdots \quad \gamma_{M-1}]^{\mathrm T} \tag{2-42}</script><script type="math/tex; mode=display">
\boldsymbol a_j = \boldsymbol a_j(\epsilon, \varsigma) = \left[ 1 \quad \mathrm e^{\mathrm j 2 \pi (d \cos \varsigma \sin \epsilon)/\lambda_0} \quad \cdots \quad \mathrm e^{\mathrm j 2 \pi (N-1)(d \cos \varsigma \sin \epsilon)/\lambda_0}  \right]^{\mathrm T} \tag{2-43}</script><p>已知来自不同脉冲的干扰信号之间互不相关，并进一步假设干扰信号在一个CPI内是平稳的，则有：</p>
<script type="math/tex; mode=display">
\mathbb{E}[\gamma_{m_1} \gamma_{m_2}^*] = \sigma_n^2 \xi_j \delta(m_1-m_2)\\
\Updownarrow \\
\mathbb{E}[\boldsymbol \gamma_j \boldsymbol \gamma_j^{\mathrm H}] = \sigma^2_n \xi_j \boldsymbol I_M \\
\tag{2-44}</script><p>可以计算得到其协方差矩阵如下式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbf{R}_j & = \mathbb{E}\left\{\boldsymbol{x}^{(j)} \boldsymbol{x}^{(j) \mathrm H}\right\}= \mathbb{E}[\boldsymbol \gamma_j \boldsymbol \gamma_j^{\mathrm H}] \otimes \mathbb{E}[ \boldsymbol a_j \boldsymbol a_j^{\mathrm H}]\\

& =\sigma^2_n \xi_j \boldsymbol{I}_M \otimes \boldsymbol{a}_j \boldsymbol{a}_j^{\mathrm H} \\

& =\boldsymbol{I}_M \otimes \sigma_n^2 \xi_j \boldsymbol{a}_j \boldsymbol{a}_j^{\mathrm H} \\

& =\boldsymbol{I}_M \otimes \mathbf{\Phi}_j

\end{aligned} \tag{2-45}</script><p>其中，$\xi_j$为干扰噪声比(Jamming to Noise Ratio，JNR)。式$(2-45)$的空时协方差矩阵是一个块状对角矩阵，即在该矩阵的对角线上，有$M$个$N \times N$维矩阵，而其余部分均为$0$。</p>
<h5 id="2-4噪声模型"><a href="#2-4噪声模型" class="headerlink" title="2.4噪声模型"></a>2.4噪声模型</h5><p>雷达进行目标探测时，接收机内部噪声是主要的限制因素。首先，假设每个阵元的接收机噪声在空间上互不相关；此外，<strong>当瞬时带宽大于脉冲重复频率(Pulse Repetition Frequency, PRF)时，单个阵元的接收机噪声还满足时间上的不相关</strong>。</p>
<p>令$x_{n, n,m}$表示第$n$个阵元在第$m$个脉冲的噪声采样，则噪声的空间相关性和时间相关性分别表示为：</p>
<script type="math/tex; mode=display">
\mathbb{E}[x_{n, n_1,m} x^*_{n, n_2, m}] = \sigma_n^2 \delta(n_1 - n_2) \tag{2-46}</script><script type="math/tex; mode=display">
\mathbb{E}[x_{n,n,m_1} x^*_{n, n, m_2}] = \sigma_n^2 \delta(m_1 - m_2) \tag{2-47}</script><p>本文仅考虑接收机内部噪声。因为每个阵元有各自的接收机，所以可以认为不同阵元的噪声是不相关的。噪声呈随机分布，所以同一阵元的噪声在时间维也是不相关的。假设噪声信号服从均值为$0$，方差为$\sigma_n^2$的高斯分布。噪声空间的协方差矩阵可表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol R_n =\mathbb{E}[\boldsymbol x^{(n)} \boldsymbol x^{(n)\mathrm H}] =  \sigma_n^2 \boldsymbol I_M \times \boldsymbol I_N =  \sigma_n^2 \boldsymbol I_{MN} \tag{2-48}</script><h5 id="2-5-窄带阵信号模型适用假设讨论"><a href="#2-5-窄带阵信号模型适用假设讨论" class="headerlink" title="2.5 窄带阵信号模型适用假设讨论"></a>2.5 窄带阵信号模型适用假设讨论</h5><p>在传统的窄带相控阵雷达系统中，点目标的方向$\psi$和与载机的相对径向速度$v_t$在CPI 内均是视为近似不变，目标空域导向矢量和时域导向矢量在CPI 内均不变。</p>
<h4 id="3-稀疏STAP算法概述"><a href="#3-稀疏STAP算法概述" class="headerlink" title="3 稀疏STAP算法概述"></a>3 稀疏STAP算法概述</h4><h5 id="3-1-SR-STAP-基本原理及杂波稀疏性分析"><a href="#3-1-SR-STAP-基本原理及杂波稀疏性分析" class="headerlink" title="3.1 SR STAP 基本原理及杂波稀疏性分析"></a>3.1 SR STAP 基本原理及杂波稀疏性分析</h5><p><strong>(一) 基本原理</strong></p>
<p>不考虑距离模糊次数，第$i$个距离单元机载雷达接收杂波(+噪声)数据可表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol y =& \boldsymbol x^{(c)}_ i + \boldsymbol x^{(n)} \\
 = & \sum_{j = 1}^{N_c} \kappa^{(c)}_{i, j} \cdot\boldsymbol b^{(c)}_{i, j}(\varpi) \otimes \boldsymbol a^{(c)}_{i, j}(\vartheta) +  \boldsymbol x^{(n)}
\end{aligned} \tag{3-1}</script><p>这里再回顾一下各个符号的含义：</p>
<ul>
<li>$\boldsymbol x^{(c)}_ i$为第$i$个距离单元的杂波回波数据<ul>
<li>$\kappa^{(c)}_{i, j}$为该杂波块的回波复幅度；</li>
<li>$\boldsymbol b^{(c)}_{ i, j}(\varpi)$为第$i$距离环，第$j$个独立杂波块的时域导向矢量；</li>
<li>归一化多普勒频率$\varpi_{i,j} = f_c \dfrac{2vT_r \cos(\theta_j + \alpha) \cos \varphi_i}{c}$</li>
<li>$a^{(c)}_{i, j}(\vartheta)$为第$i$距离环，第$j$个独立杂波块的空域导向矢量；</li>
<li>空域频率$\vartheta_{i,j} = f_c \dfrac{d \cos \theta_j \cos \varphi_i}{c}$</li>
</ul>
</li>
<li>$ \boldsymbol x^{(n)}$表示随机噪声</li>
</ul>
<p>由于我们现在只考虑第$i$个杂波距离环内的杂波抑制，因此下标$i$不再标出，并且将下标$j$改为$p$，将信号重写为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\boldsymbol y =& \boldsymbol x^{(c)} + \boldsymbol x^{(n)} \\
 = & \sum_{p = 1}^{N_c} \kappa^{(c)}_{p} \cdot \boldsymbol \nu^{(c)}_{p}(\varpi, \vartheta) +  \boldsymbol x^{(n)} \\
 = & \sum_{p = 1}^{N_c} \kappa^{(c)}_{p} \cdot \boldsymbol b^{(c)}_{p}(\varpi) \otimes \boldsymbol a^{(c)}_{p}(\vartheta) +  \boldsymbol x^{(n)}
\end{aligned} \tag{3-2}</script><p>其中，$\boldsymbol y \in \mathbb C^{NM \times 1}$，$ \kappa^{(c)}_{p}$第$p$个杂波块对应的复幅度，$\boldsymbol \nu^{(c)}_{p}(\varpi, \vartheta)$为空时二维导向矢量，时域导向矢量$\boldsymbol b^{(c)}_{p}(\varpi)$和空域导向矢量$\boldsymbol a^{(c)}_{p}(\vartheta)$分别为：</p>
<script type="math/tex; mode=display">
\boldsymbol b^{(c)}_{p}(\varpi) =\left[1 \quad \mathrm e^{\mathrm j 2 \pi \varpi_{p}} \quad \cdots \quad  \mathrm e^{\mathrm j 2 \pi (M-1) \varpi_{p}} \right]^{\mathrm T} \tag{3-3}</script><script type="math/tex; mode=display">
\boldsymbol a^{(c)}_{p}(\vartheta) = \left[1 \quad \mathrm e^{\mathrm j 2 \pi \vartheta_{p}} \quad \cdots \quad  \mathrm e^{\mathrm j 2 \pi (N-1) \vartheta_{p}} \right]^{\mathrm T} \tag{3-4}</script><p>由式$(3-2)$看出，机载雷达回波可由不同波束指向(空频)和不同多普勒频率的回波信号叠加而成。若将空频和多普勒频率分别离散化为$N_S = \rho_S N$ 和$N_D = \rho_D M$($\rho_S$和$\rho_D$分别为空频和多普勒频率离散化倍数，通常$\rho_S, \rho_D \gg 1$)，同时忽略量化误差影响，则待雷达回波信号还可表征为：</p>
<script type="math/tex; mode=display">
\boldsymbol y = \sum_{q = 1}^{N_S \cdot N_D} \alpha^{(c)}_q \boldsymbol v^{(c)}_{q}(\varpi, \vartheta) + \boldsymbol x^{(n)} = \boldsymbol{V}^{(c)}\boldsymbol{\alpha}^{(c)} +  \boldsymbol x^{(n)} \tag{3-5}</script><p>其中，$\alpha^{(c)}_q$和$\boldsymbol v^{(c)}_q$分别为空时平面第$q$个网格点对应幅度和空时二维导向矢量。$\boldsymbol V^{(c)}$为空时二维平面所有网格点对应空时二维导向矢量集合，也称为字典：</p>
<script type="math/tex; mode=display">
\boldsymbol \alpha^{(c)} = [\alpha_1^{(c)}, \alpha_2^{(c)}, \cdots,\alpha_{N_S N_D}^{(c)}]^{\mathrm T} \in \mathbb C^{N_S N_D \times 1} \tag{3-6}</script><script type="math/tex; mode=display">
\boldsymbol V^{(c)} = [\boldsymbol v^{(c)}_{1}, \boldsymbol v^{(c)}_{2}, \cdots, \boldsymbol v^{(c)}_{N_SN_D}] \in \mathbb C^{NM \times N_S N_D} \tag{3-7}</script><p>由于$N_S × N_D \gg N × K$，式$(3-5)$为欠定方程． 根据SR理论，如果变量$\boldsymbol \alpha^{(c)}$足够稀疏，则可通过以下约束优化问题获得唯一解：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min & \| \boldsymbol{\alpha}^{(c)} \|_0 \\ 
\text { s.t. } & \| \boldsymbol y - \boldsymbol{V}^{(c)}\boldsymbol{\alpha}^{(c)} \|^2_2 \leq \varepsilon 
\end{cases} \tag{3-8}</script><p>其中，$\varepsilon$为噪声功率，此外，式$(3-8)$还可表述为如下形式：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min & \| \boldsymbol y - \boldsymbol{V}^{(c)}\boldsymbol{\alpha}^{(c)} \|^2_2\\ 
\text { s.t. } &  \| \boldsymbol{\alpha} ^{(c)}\|_0  \leq r_s
\end{cases} \tag{3-9}</script><p>其中，$r_s$表示杂波稀疏度。求解式$(3-8)$或式$(3-9)$得到稀疏系数$\boldsymbol \alpha$后，当前主要有两大类方法实现目标检测：</p>
<ul>
<li>① 是利用训练样本求得稀疏系数来计算CCM，进而设计空时滤波器进行滤波处理后再检测；</li>
<li>② 是仅利用RUT数据求得稀疏系数，实现目标和杂波的同时超分辨谱估计，进而在该空时二维谱平面进行目标检测处理。</li>
</ul>
<p><strong>(二) 稀疏性分析</strong></p>
<p>已知机载雷达杂波来向与其相应多普勒频率依从如下关系：</p>
<script type="math/tex; mode=display">
f_D = \dfrac{2v}{\lambda} \cos(\theta + \alpha)\cos\psi</script><p>由该式可看出杂波多普勒频率与空频存在依从关系，即一个空频对应一个多普勒频率( 不考虑距离模糊) ，因此杂波在空时二维平面仅分布于满足该依从关系的脊线及附近区域。也就是说，相比于整个空时二维平面，杂波仅分布于小部分特殊区域(一条直线上)，因此在该平面是稀疏的。</p>
<p>文献<a href="#[17]">[17]</a>分析和讨论了杂波在空时平面的稀疏性问题，并指出理想情况及正侧机载雷达杂波稀疏度$r_s$等于杂波秩$r$，即杂波子空间可由r个正交空时导向矢量完备表述。但该结论是否适用于非理想或非正侧情况，尚无定论。</p>
<p>上述讨论均是基于由空时导向矢量构成的过完备字典，其中字典中各导向矢量又称<strong>原子</strong>。在字典中包含上述$r$个正交原子情况下，通过设计合理SR算法即可求得相应原子位置以及幅度。</p>
<blockquote>
<p>注意：<strong>对于非正侧或非理想情况，杂波秩要显著高于理想正侧情况</strong>，因此构成杂波子空间的正交基或正交空时二维导向矢量个数也相应增加。基于该判断，与理想正侧情况相比，非正侧或非理想情况下杂波稀疏度势必变大，同时杂波在空时平面的稀疏性将变差。</p>
</blockquote>
<h5 id="3-2-研究进展及相关问题"><a href="#3-2-研究进展及相关问题" class="headerlink" title="3.2 研究进展及相关问题"></a>3.2 研究进展及相关问题</h5><p><strong>(一) 研究进展</strong></p>
<p><img src="https://pic.imgdb.cn/item/64e1876b661c6c8e54d80ddc.jpg" alt="3.1 SR-STAP算法的发展"></p>
<p><strong>(二) 相关问题讨论</strong></p>
<p><strong>(1) 空时谱估计还是杂波抑制?</strong></p>
<p>目标由于自身尺寸限制，同杂波一样在空时平面也具有稀疏性。因此，不同于杂波抑制后检测目标的方式，若直接采用SR技术将RUT数据进行稀疏表征，得到目标和杂波的角-多普勒超分辨谱，则无需进行杂波抑制处理，而直接在空时二维谱检测目标，该方法称为SR空时谱估计方法。</p>
<p><img src="https://pic.imgdb.cn/item/64e207d7661c6c8e5493ea22.jpg"></p>
<blockquote>
<p>综上所述，实际中采用SR杂波抑制的方式更为稳健，且有利于发现弱小目标。因此，基于SR类空时处理方法的研究应侧重于杂波抑制类方法。</p>
</blockquote>
<p><strong>(2) 单观测样本还是多观测样本?</strong></p>
<p>单观测样本，即仅利用RUT数据进行恢复处理，但受噪声影响恢复性能不甚理想。在假定各观测数据具有相同稀疏结构，即不同观测数据中对应稀疏系数矢量的非零元素位置和个数均相同的前提下，式$(3-8)$在多观测样本条件下可进一步表述为：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min & \| \boldsymbol{A} \|_{2,0} \\ 
\text { s.t. } & \| \boldsymbol Y - \boldsymbol{V}^{(c)}\boldsymbol{A}^{(c)} \|_{\mathrm F} \leq \varepsilon 
\end{cases} \tag{3-10}</script><p>其中，$\boldsymbol A = \left[\boldsymbol{\alpha}^{(c)}_1, \boldsymbol{\alpha}^{(c)}_2, \cdots, \boldsymbol{\alpha}^{(c)}_L \right]$为稀疏系数矩阵，$\boldsymbol Y$为观测样本矩阵，$L$为观测样本个数。$|| \boldsymbol{A} ||_{2,0}$表示对矩阵各行取$l_2$范数，然后在列向取$l_0$范数；$|| \cdot ||_{\mathrm F}$表示对矩阵取Frobenius范数。</p>
<p>文献<a href="#[40]">[40-44]</a>将各类经典SR算法进行了拓展，并证明了如下结论：即<strong>单观测样本下SR求得唯一解的充要条件(不考虑噪声)：</strong></p>
<script type="math/tex; mode=display">
r_s < \dfrac{\text{spark}(\boldsymbol V^{(c)})}{2} \tag{3-11}</script><p><strong>在多观测样本条件下松弛为：</strong></p>
<script type="math/tex; mode=display">
r_s = |\mathrm{supp}| < \dfrac{\boldsymbol V^{(c)} - 1 + \mathrm{rank}(\boldsymbol Y)}{2} \tag{3-12}</script><p>其中，$\mathrm{spark}(·)$表示矩阵的最小线性独立列个数，$\mathrm{rank}(·)$表示矩阵的秩。这也就是说多观测样本对稀疏度的要求显著降低，更有利于获得最优解。该结论同样适用于噪声条件下<sup><a href="#[40]">[40]</a></sup>。</p>
<p><strong>(3) 白化还是置零?</strong></p>
<p>从杂波抑制方式来看，现有SR STAP方法主要分为两类，即杂波白化和杂波置零。</p>
<ul>
<li>杂波白化主要是基于恢复得到原子及其相应幅度构造CCM，然后再进行自适应滤波处理<sup><a href="#[19]">[19]</a>,<a href="#[23]">[23]</a>,<a href="#[25]">[25]</a></sup>。</li>
<li>杂波置零则利用SR得到杂波分量对应原子构造杂波子空间，再通过正交投影等方式进行杂波滤除<sup><a href="#[31]">[31]</a></sup>。</li>
</ul>
<p>与白化类方法相比，杂波置零类方法基于信号间正交特性进行杂波抑制，因此无需原子幅度信息，这部分降低了SR难度；同时可生成较深零深，将杂波处功率抑制为零，而白化类算法的零深取决于该处杂波功率强弱，且仅能将杂波抑制到噪声电平。 然而，杂波置零类算法性能严重依赖于杂波子空间维度信息的准确性。</p>
<p>通常来说，子空间维度的略微过估计并不会造成性能下降，但欠估计却可导致性能严重降低，甚至失效<sup><a href="#[45]">[45]</a></sup>. 尽管文献<a href="#[46]">[46]</a>给出了理想情况各类配置情况杂波秩估计准则，但在实际应用中，受各类非理想因素影响，杂波秩很难准确得到，导致置零类SR算法的性能严重受损。尽管白化类SR算法依赖于原子幅度信息，但可通过合理设计算法而准确估计，因此更适用于机载雷达实际应用。</p>
<p><strong>(4) 重构算法参数依赖还是不依赖?</strong></p>
<p>通过拉格朗日乘子，式$(3-8)$和式$(3-9)$还可转化为如下优化问题：</p>
<script type="math/tex; mode=display">
\min _{\lambda, \boldsymbol \alpha^{(c)}} \dfrac{1}{2} \| \boldsymbol y - \boldsymbol{V}^{(c)} \boldsymbol \alpha^{(c)} \|^2_2 + \lambda \| \boldsymbol \alpha^{(c)} \|_0 \tag{3-13}</script><p>其中，第一项和第二项分别对应信号的保真度和稀疏度，而正则化参数$\lambda$则用于平衡两者间的相对重要性。由式$(3-8)$、$(3-9)$和$(3-10)$可知，参数$\varepsilon$、$r_s$和$\lambda$的设置对于上述优化问题的求解具有重要意义。实质上，$\lambda$可作为式$(3-8)$和$(3-9)$中约束优化问题的对偶形式中的对偶变量，如果已知噪声强度或稀疏度信息，则可对应求得其最优值。</p>
<p>在机载雷达中，准确噪声功率往往是未知的，特别是在低或中重频条件下。因此，参数设置问题成为影响其SR性能的重要因素。在实际应用中，由于空域幅相误差、杂波起伏和载机偏航等非理想因素的影响，杂波的空时谱展宽或泄漏到其他区域，无论杂波秩还是杂波稀疏度均无法准确获知，因此严重依赖该参数的各类算法在实际应用中往往是不稳健的。</p>
<p>将$l_0$拟范数松弛为$l_1$范数后，可通过典型凸优化方法求解上述优化问题，但运算量巨大，且性能严重依赖于正则化参数。从贝叶斯分析角度考虑，可将$l_1$范数优化方法转化为最大后验概率估计方法。在该框架下，SBL方法将稀疏系数各分量表征为不同方差且相互独立的零均值高斯随机变量，并且其参数化先验分布的期望形式为具有较强稀疏性的学生$t$分布，最终求取稀疏系数的过程转化为其超参数的迭代学习过程<sup><a href="#[47]">[47]</a></sup>。</p>
<blockquote>
<p>与$l_1$范数优化方法相比，SBL方法可获得更稀疏的全局最优解，同时不需要噪声强度先验信息，也无需设置正则化参数，因此也是当前SR STAP 中性能稳健的一类方法<a href="#[48]">[48]</a>。</p>
</blockquote>
<p><strong>(5) 非平稳杂波环境下是否适用?</strong></p>
<p>除单基正侧放置均匀线(面)阵外，均存在杂波多普勒随距离变化而变化的情况，即杂波具有非平稳性<sup><a href="#[49]">[49]</a></sup>。</p>
<p>与表述样本间功率或散射源差异性的非均匀不同，非平稳侧重于表述杂波在不同样本间空时二维分布的差异性。该差异性同样导致各观测样本稀疏结构不同，进而影响多样本SR性能。那么在非平稳杂波条件下，SR-STAP技术是否仍旧可行呢?</p>
<p>实质上，机载雷达非平稳杂波由天线俯仰下副瓣引入，主要成份为近程杂波<sup><a href="#[50]">[50]</a>,<a href="#[51]">[51]</a></sup>，因此可通过设计合理的俯仰维波束形成方式进行提前滤除，实现杂波的平稳化<sup><a href="#[50]">[50]</a><a href="#[51]">[51]</a>,<a href="#[52]">[52]</a></sup>。此时各观测样本间具有了相同稀疏结构。</p>
<p>如前所述，非均匀杂波条件下提升STAP性能的主要策略是<strong>降低样本需求</strong>，提升小样本条件下的算法性能；而非平稳杂波环境下则侧重于<strong>剔除非平稳杂波分量</strong>，将杂波平稳化。现实应用环境中往往是杂波非平稳性和非均匀性交织在一起，因此通过滤除非平稳杂波再级联SR STAP的方式可有效提升上述背景下的杂波抑制性能。</p>
<p><strong>(6) 干扰条件下是否可行?</strong></p>
<p>STAP技术基于空域和时域二维联合自适应处理，对于干扰抑制具有先天优势，因此利用空时自适应滤波同时抑制杂波和干扰是当前机载雷达的重要技术手段。尽管干扰多是宽频带的，但由于其仅来自有限几个方向，因此在空时二维域仍是稀疏的<sup><a href="#[26]">[26]</a>,<a href="#[29]">[29]</a></sup></p>
<ul>
<li>对于副瓣压制噪声干扰，直接采用传统STAP处理或者SR STAP处理即可实现对干扰和杂波的同时抑制；</li>
<li>对于主瓣压制噪声干扰，传统STAP处理由于主瓣畸变引起目标损失，导致算法性能失效，而如果仅利用RUT数据进行稀疏处理得到干扰、杂波和目标空时二维谱，则可期望实现对目标的有效检测和定位，但前提是目标功率相对较强；对于在时域功率变化剧烈的灵巧干扰，传统STAP处理由于无法获取有效样本往往性能较差，如果采用SR STAP进行处理，则可在极少样本条件下实现对干扰和杂波的有效抑制。</li>
</ul>
<h4 id="4-未来工作展望"><a href="#4-未来工作展望" class="headerlink" title="4 未来工作展望"></a>4 未来工作展望</h4><h5 id="4-1-网格失配问题"><a href="#4-1-网格失配问题" class="headerlink" title="4.1 网格失配问题"></a>4.1 网格失配问题</h5><p>目前，SR STAP方法中字典由均匀离散化的空间锥角和多普勒频率所对应空时二维导向矢量构成。尽管这种构建字典的方法简单且易于处理，但不可避免存在网格失配问题，即<strong>真实杂波以较低概率落于空时平面网格点</strong>。网格失配导致杂波能量泄露到其他原子而引起杂波谱展宽，进而影响后续空时滤波器性能。加密网格可增大杂波落于网格点的概率，但过于密集的网格会造成基字典中相邻原子间相关性太强，从而降低恢复性能<sup><a href="#[53]">[53]</a></sup>。</p>
<p>已有SR STAP方法的研究多集中于正侧视且设定杂波脊线与网格点划分吻合，并未考虑网格失配所带来的严重杂波估计损失问题。文献<a href="#[39]">[39]</a>研究了SR STAP中网格失配问题，并提出一种知识辅助的非均匀网格划分方法，以消除网格失配带来的不利影响，但方法依赖于载机速度和偏航角度等先验知识的准确性。</p>
<p>2012年Candés等<sup><a href="#[54]">[54]</a></sup>提出利用全变分范数可从少量时域采样中重构无限精度的连续频率值，该方法直接在连续域上进行稀疏正则化，由于无需对连续参数空间进行离散化，因此能够提供信号的精确SR模型并从根本上消除网格失配问题；Tang等<sup><a href="#[55]">[55]</a></sup>在此基础上提出无网格压缩感知(Gridless Compressive Sensing, GCS)，通过求解原子范数最小化问题，可从有限随机时域采<br>样中重构出无限精度的连续频率值，但对频率源间隔要求不低于系统自由度的四分之一。</p>
<p>文献<a href="#[38]">[38]</a>将GCS 理论引入到SR-STAP领域，初步验证了该理论对于消除网格失配的天然优势，但并未从理论上给出GCS适用于连续分布杂波的证明，且仅考虑了理想情况． 在后续的工作中，证明GCS理论适用于连续杂波SR，以及研究基于GCS理论的各类非理想条件下SR-STAP方法是该领域的重要研究方向。</p>
<h5 id="4-2-空域误差问题"><a href="#4-2-空域误差问题" class="headerlink" title="4.2 空域误差问题"></a>4.2 空域误差问题</h5><p>在实际工程中，由于通道内放大器的增益不一致导致的阵元<strong>幅相误差</strong>不可避免。在传统STAP方法中，误差分量隐含在接收回波数据中，因此基于回波数据所构造的CCM中蕴含了误差信息，只要有足够空域系统自由度参与自适应处理，则相应空时滤波器对误差具有较强的自适应补偿能力。而在SR-STAP方法中，由于误差未知，通常直接采用理想空时二维导向矢量来构建字典，因此各原子与真实阵列流形之间存在偏差，且误差越大，偏差越大。如果采用不准确的字典来进行SR处理，所估CCM 势必与真实情况存在较大偏差，从而造成后续滤波性能恶化甚至失效。因此，由阵元通道幅相误差导致的原子失配是SR-STAP应用于实际工程时必须要解决的问题。<br>在SR源定位应用中<sup><a href="#[56]">[56]</a></sup>，可基于特定稀疏优化准则对信源方位和阵列幅相误差参数进行联合优化估计，以实现对误差参数的在线实时估计和校正，从而提升误差条件下源定位的稳健性。需要注意的是，当前源定位误差校正均基于离散信源背景。Ma 等<sup><a href="#[28]">[28]</a></sup>首次将源定位中误差和信源来向联合优化技术移植到联合SR-STAP技术中，但其仿真实验仅基于有限强散射杂波源进行了验证。Sun等<sup><a href="#[36]">[36]</a></sup>继而提出了误差条件下基于SBL的离散强杂波源抑制方法。Liu 等<sup><a href="#[57]">[57]</a></sup>提出一种误差自校正子空间STAP算法，但严重依赖于对杂波秩的准确估计． 近期，文献<sup><a href="#[58]">[58]</a></sup>提出的幅相误差与杂波联合优化估计方法，提升了误差条件下SR STAP方法的杂波抑制性能，但该算法性能严重依赖于正则化参数和惩罚因子的设置。因此，进一步验证连续杂波背景下误差自校正SR STAP技术的可行性，以及在此基础上设计稳健的误差与杂波联合稀疏优化方法是未来解决误差影响问题的重要研究方向。</p>
<h4 id="5-基于DOA估计的On-Grid、Off-Grid、Gridless模型梳理-59-61"><a href="#5-基于DOA估计的On-Grid、Off-Grid、Gridless模型梳理-59-61" class="headerlink" title="5 基于DOA估计的On-Grid、Off-Grid、Gridless模型梳理[59], [61]"></a>5 基于DOA估计的On-Grid、Off-Grid、Gridless模型梳理<sup><a href="#[59]">[59]</a>, <a href="#[61]">[61]</a></sup></h4><blockquote>
<p>注：目前看来文献[61]对其中几个问题有一些解释。</p>
</blockquote>
<h5 id="5-1-简要稀疏恢复模型"><a href="#5-1-简要稀疏恢复模型" class="headerlink" title="5.1 简要稀疏恢复模型"></a>5.1 简要稀疏恢复模型</h5><p><strong>(一) 模型概述</strong></p>
<p>稀疏恢复的模型为：</p>
<script type="math/tex; mode=display">
\boldsymbol y = \boldsymbol{Ax} + \boldsymbol e \tag{5-1}</script><p>其中，$\boldsymbol A \in \mathbb C^{M \times \bar{N}}$称为一个字典，$\boldsymbol A$中的列称为“原子”。$\boldsymbol y \in \mathbb C^{M \times 1}$是观测矢量，$\boldsymbol x \in \mathbb C^{\bar{N} \times 1}$是需要稀疏恢复的信号。$\boldsymbol x$中非零元素$K \ll \bar N$，也即$\boldsymbol y$仅需$\boldsymbol A$中$K$个原子就可线性表示。无噪声条件下，稀疏恢复问题为：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol x} & || \boldsymbol{x} ||_0 \\ 
\text { s.t. } & \boldsymbol y = \boldsymbol{Ax}
\end{cases} \tag{5-2}</script><p><strong>(二) 凸松弛</strong></p>
<p>第一个实用稀疏恢复算法是基于凸松弛的——将$l_0$范数松弛$l_1$范数，此时问题为：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol x} & || \boldsymbol{x} ||_1 \\ 
\text { s.t. } & \boldsymbol y = \boldsymbol{Ax}
\end{cases} \tag{5-3}</script><p>这个算法被称为<strong>基追踪(Basic Pursuit, BP)</strong>。由于$l_1$范数是凸的，$(5-3)$可以在多项式时间内求解。</p>
<p>当考虑噪声时，可以解决以下优化问题：</p>
<script type="math/tex; mode=display">
\min\limits_{\boldsymbol x}  \lambda|| \boldsymbol{x} ||_1+ \dfrac{1}{2} ||\boldsymbol y - \boldsymbol{Ax}||_2^2  \tag{5-4}</script><script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol x} & || \boldsymbol{x} ||_1 \\ 
\text { s.t. } & ||\boldsymbol y - \boldsymbol{Ax}||_2 \leq \eta
\end{cases} \tag{5-5}</script><p>其中，式$(5-4)$中的参数$\lambda&gt;0$为正则化参数，式$(5-5)$中的$\eta \geq ||\boldsymbol e||_2$是噪声能量的上界。式$(5-4)$被称为<strong>LASSO(Least Absolute Shrinkage and Selection Operator)</strong>问题，式$(5-5)$被称为<strong>基追踪去噪问题(Basis Pursuit Denoising, BPDN)</strong>问题。当参数$\lambda,\eta \to 0$时，式$(5-4)$和式$(5-5)$都等价与式$(5-3)$。</p>
<p>此外，一种LASSO算法的改进版本为<strong>平方根LASSO(Square-Root LASSO, SR-LASSO)</strong>，其具体形式为：</p>
<script type="math/tex; mode=display">
\min\limits_{\boldsymbol x}  \tau|| \boldsymbol{x} ||_1+ ||\boldsymbol y - \boldsymbol{Ax}||_2  \tag{5-6}</script><p>其中，$\tau&gt;0$是正则化参数。对于LASSO，噪声通常被假设为高斯，并且正则化参数$\lambda$被选择为与噪声的标准偏差成比例，而SR-LASSO只需要对噪声分布的较弱假设，并且$\tau$可以被选择为独立于噪声水平的常数。</p>
<p>$l_1$范数虽然是凸优化，但$l_1$范数不是平滑的，高效求解很困难，到目前为止，在加速计算方面也有一些进展，比如$l_1$-magic算法、内点法、共轭梯度法、Nesterov’s带延拓平滑技术等。</p>
<p><strong>(三) 非凸松弛</strong></p>
<p>一个向量的$l_q(0&lt;q&lt;1)$范数定义为：</p>
<script type="math/tex; mode=display">
||\boldsymbol x_q|| = \left(\sum_n |x_n|^q\right)^{\frac{1}{q}} \tag{5-7}</script><p>可以将$l_0$问题非凸松弛为$l_q$范数，无噪声条件下，相应的稀疏恢复问题如下：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol x} & || \boldsymbol{x} ||_q^q \\ 
\text { s.t. } & \boldsymbol y = \boldsymbol{Ax}
\end{cases} \tag{5-8}</script><p>其中，使用$|| \boldsymbol{x} ||_q^q$而不是$|| \boldsymbol{x} ||_q$是为了方便计算。与$l_1$范数相比，$l_q$范数更接近$l_0$范数，因此可以预期式$(5-8)$中的$l_q$优化会比BP产生更好的性能。</p>
<p>一个著名的$l_q$优化算法为<strong><font color="blue">FOCUSS(Focal Underdetermined System Solver)</font></strong>，FOCUS是一种迭代加权最小二乘法，无噪条件下，在每次迭代中FOCUS解决以下加权最小二乘问题：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol x} & \displaystyle\sum_n w_n |x_n|^2\\ 
\text { s.t. } & \boldsymbol y = \boldsymbol{Ax}
\end{cases} \tag{5-9}</script><p>其中，权重系数$w_n = |x_n|^{q-2}$会根据当前迭代的最新解$\boldsymbol x$进行更新。注意，式$(5-9)$可以以closed form求解，因此可以通过适当的初始化来实现迭代算法。该这种算法可以解释为一种保证收敛到局部最小值的<strong>大化-最小化(Majorization-Minimization, MM)</strong>算法。</p>
<p>当考虑噪声时，可采用如下正则化方法：</p>
<script type="math/tex; mode=display">
\min\limits_{\boldsymbol x}  \lambda|| \boldsymbol{x} ||_q^q+ \dfrac{1}{2}||\boldsymbol y - \boldsymbol{Ax}||_2^2 \tag{5-10}</script><p>其中，$\lambda&gt;0$是正则化参数。与FOCUS中相同的主要思想开发了针对式$(5-10)$的<strong>正则化FOCUSS算法</strong>。但关于式$(5-10)$的一个难题是参数$\lambda$的选择。尽管一些文献中介绍了几种调整该参数的启发式方法，但据我们所知，在这方面还没有理论结果。</p>
<p>为了绕过参数调整问题，提出一种通过<strong>迭代最小化稀疏学习(Sparse Learning via Iterative Minimization, SLIM)</strong>的MAP估计方法。假设i.i.d的高斯噪声分布服从$\mathcal{CN}(0, \eta)$，$\boldsymbol x$具有如下先验分布：</p>
<script type="math/tex; mode=display">
f(\boldsymbol x) \propto \prod_{n} \exp\left[-\dfrac{2}{q}(|x_n|^q - 1)\right] \tag{5-11}</script><p>SLIM通过求解如下的$l_q$优化问题来计算MAP估计：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol x} M \log \eta + \eta^{-1} ||\boldsymbol{Ax} - \boldsymbol y||_2^2 + \dfrac{2}{q}||\boldsymbol x||_q^q \tag{5-12}</script><p>为局部求解式$(5-12)$，SLIM会像“正则化FOCUSS”算法一样，迭代更新$\boldsymbol x$，但与FOCUSS算法不同的是，SLIM算法也会同时根据最新的$\boldsymbol x$迭代更新$\eta$。</p>
<p><strong>(四) 最大似然估计(MLE)</strong></p>
<p>MLE是稀疏恢复的另一种常见方法，与凸松弛和OMP相比，MLE的一个优点是不需要了解噪声水平或稀疏程度。</p>
<p>假设$\boldsymbol x$服从均值为0，协方差为$\boldsymbol P = \mathrm{diag}(\boldsymbol p)$的多元高斯分布，其中$p_n \geq 0, n=1, \cdots, \bar N$，(这可视为$\boldsymbol x$的先验分布)，此外设噪声是方差为$\sigma$的i.i.d高斯分布，则从$\boldsymbol y = \boldsymbol{Ax} + \boldsymbol e$可得，$\boldsymbol y$服从均值为0，协方差为$\boldsymbol R = \boldsymbol{APA}^{\mathrm H} + \sigma \boldsymbol I$的高斯分布，可得$\boldsymbol  y$的负对数似然函数为：</p>
<script type="math/tex; mode=display">
\mathcal L(\boldsymbol p, \sigma) = \log|\boldsymbol R| + \boldsymbol y^{\mathrm H}\boldsymbol R^{-1}\boldsymbol y \tag{5-13}</script><p>参数$(\boldsymbol p, \sigma)$可通过最小化$\mathcal L(\boldsymbol p, \sigma)$来估计：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol p, \sigma} \mathcal L(\boldsymbol p, \sigma) = \min_{\boldsymbol p, \sigma}\log|\boldsymbol R| + \boldsymbol y^{\mathrm H}\boldsymbol R^{-1}\boldsymbol y \tag{5-14}</script><p>一旦求解得到了参数$(\boldsymbol p, \sigma)$，则可以获得稀疏$\boldsymbol x$的后验分布，其均值和协方差为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\boldsymbol \mu = \boldsymbol{\Sigma A}^{\mathrm H}\boldsymbol y \\
\\
&\boldsymbol \Sigma = (\boldsymbol A^{\mathrm H}\boldsymbol A + \sigma \boldsymbol P^{-1})^{-1}
\end{aligned} \tag{5-15}</script><p>稀疏向量$\boldsymbol x$可以估计为其后验均值$\boldsymbol \mu$。MLE一个主要的困难来自求解式$(5-14)$，该式的第一项$\log |\boldsymbol R|$是参数$(\boldsymbol p, \sigma)$的非凸(实际是凹的)函数，目前已提出了不同的方法，如<strong>重新加权优化法</strong>和<strong><font color="red">稀疏贝叶斯学习法 (SBL)</font></strong>。</p>
<ol>
<li><strong>重新加权优化法</strong>，给定最新的估计值$\boldsymbol R_j$后，采用<strong>MM算法</strong>在每次迭代时通过其切面$\mathrm{Tr}(\boldsymbol R_j^{-1} \boldsymbol R)$对$ \log |\boldsymbol R| $进行线性化。每次迭代产生的问题都是凸问题，使用一种称为<strong><font color="blue">基于协方差的稀疏迭代估计(SPICE)</font></strong>的算法求解。</li>
<li>在稀疏贝叶斯SBL框架内，人们对MLE从不同的角度进行了阐释。特别是为了实现稀疏性，假设$\boldsymbol x$的先验分布是具有促进稀疏性的(稀疏先验)，比如以分层方式构建了$\boldsymbol x$的$\mathrm{Student-t}$分布。有趣的是，虽然方法不同，但是得到的目标函数却也是$\min\limits_{\boldsymbol p, \sigma} \mathcal{L}(\boldsymbol p, \sigma)$，为了优化这个目标函数，采用<strong>EM算法</strong>，在E-Step中计算$\boldsymbol x$的后验分布，在M-Step中对参数$(\boldsymbol p, \sigma)$进行更新。(注意：若$\boldsymbol x$设置不同的促进稀疏的先验分布，则SBL的目标函数会略有不同)</li>
</ol>
<p><strong>(五) 稀疏恢复与DOA估计的差异</strong></p>
<p>稀疏表示中的字典通常包含有有限数量的原子，而DOA估计中的参数(角度)是连续值——即对应无限原子。</p>
<p>此外DOA一般有多个快拍，可以利用时间冗余性。</p>
<h5 id="5-2-基于网格-On-Grid-的DOA估计"><a href="#5-2-基于网格-On-Grid-的DOA估计" class="headerlink" title="5.2 基于网格(On-Grid)的DOA估计"></a>5.2 基于网格(On-Grid)的DOA估计</h5><p><strong>(一) 数据模型</strong></p>
<p>为了填补连续DOA估计与离散稀疏表示之间的空白，网格稀疏方法简单地假定，连续DOA域可以由一组给定的网格点代替：</p>
<script type="math/tex; mode=display">
\bar{\boldsymbol \theta} = (\bar \theta_1, \bar \theta_2, \cdots, \bar \theta_{\bar N}) \tag{5-16}</script><p>其中，$\bar N \gg M$，从而得到如下的$M \times \bar N$的字典矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol A(\bar{\boldsymbol \theta}) = \left[\boldsymbol a(\bar \theta_1), \cdots, \boldsymbol a(\bar \theta_{\bar N})\right] \tag{5-17}</script><p>考虑$L$个快拍数据(MMV模型)，则有如下：</p>
<script type="math/tex; mode=display">
\boldsymbol Y = \boldsymbol{AX} + \boldsymbol E \tag{5-18}</script><p>其中，$\boldsymbol X = \left[\boldsymbol x(1), \cdots, \boldsymbol x(L)\right]$是行稀疏矩阵。</p>
<p><strong>(二) $l_{2,0}$优化</strong></p>
<p>矩阵$\boldsymbol X$的$l_{2,0}$范数为：</p>
<script type="math/tex; mode=display">
||\boldsymbol X||_{2,0} = \#\left\{n: ||\boldsymbol X_n||_2 > 0\right\} = \#\left\{n:  X_n \neq \boldsymbol 0\right\} \tag{5-19}</script><p>其中，$\boldsymbol X_n$表示$\boldsymbol X$的第$n$行。在无噪情况下，$l_{2,0}$优化问题可以描述为：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol X} & || \boldsymbol{X} ||_{2,0} \\ 
\text { s.t. } & \boldsymbol Y = \boldsymbol{AX}
\end{cases} \tag{5-20}</script><p>这是一个NP-Hard难题。</p>
<p><strong>(三) 凸松弛</strong></p>
<p>(1) $l_{2,1}$范数优化</p>
<p>矩阵$\boldsymbol X$的$l_{2,1}$范数为：</p>
<script type="math/tex; mode=display">
||\boldsymbol X||_{2,1} = \sum_n ||\boldsymbol X_n||_2 \tag{5-21}</script><p>在无噪情况下，$l_{2,0}$优化问题紧凸松弛为$l_{2,1}$问题可以描述为：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol X} & || \boldsymbol{X} ||_{2,1} \\ 
\text { s.t. } & \boldsymbol Y = \boldsymbol{AX}
\end{cases} \tag{5-22}</script><p>在有噪情况下，可转换为LASSO问题或者BPDN问题：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \mathrm{LASSO}: \min\limits_{\boldsymbol X}  \lambda|| \boldsymbol{X} ||_{2,1}+ \dfrac{1}{2} ||\boldsymbol Y - \boldsymbol{AX}||_F^2  \\
\\
& \mathrm{BPDN}: \begin{cases}
\min\limits_{\boldsymbol X} & || \boldsymbol{X} ||_{2,1} \\ 
\text { s.t. } & ||\boldsymbol Y - \boldsymbol{AX}||_F \leq \eta
\end{cases}
\end{aligned} \tag{5-23}</script><p>其中，$\eta \geq ||\boldsymbol E||_2$是噪声能量的上界。LASSO问题中的参数$\lambda$的选择是十分困难的。</p>
<p>(2) $l_{2,1}-SVD$算法优化</p>
<p>。。。。。。</p>
<p><strong>(四) 非凸松弛</strong></p>
<p>矩阵$\boldsymbol X$的$l_{2,q}$范数为：</p>
<script type="math/tex; mode=display">
||\boldsymbol X||_{2,q} = \left(\sum_n ||\boldsymbol X_n||^q_2 \right)^{\frac{1}{q}} \tag{5-24}</script><p>在无噪情况下，$l_{2,0}$优化问题紧凸松弛为$l_{2,q}$问题可以描述为：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol X} & || \boldsymbol{X} ||^q_{2,q} \\ 
\text { s.t. } & \boldsymbol Y = \boldsymbol{AX}
\end{cases} \tag{5-25}</script><p>为了局部求解$(5-25)$问题，将FOCUSS算法拓展到多块拍的<strong>M-FOCUSS算法</strong>，与单快拍EOCUSS一样，M-FOCUSS算法每次迭代中解决如下加权最小二乘问题：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol X} & \displaystyle\sum_n w_n ||\boldsymbol X_n||_2^2\\ 
\text { s.t. } & \boldsymbol Y = \boldsymbol{AX}
\end{cases} \tag{5-26}</script><p>其中，权重系数$w_n = ||\boldsymbol X_n||_2^{q-2}$会根据当前迭代的最新解$\boldsymbol X$进行更新。式$(5-26)$有封闭形式的解，因此可以利用迭代算法。</p>
<p>在有噪情况下，可转换为LASSO：</p>
<script type="math/tex; mode=display">
\min\limits_{\boldsymbol X}  \lambda|| \boldsymbol{X} ||^q_{2,q}+ \dfrac{1}{2} ||\boldsymbol Y - \boldsymbol{AX}||_F^2 \tag{5-27}</script><p>为了避免式$(5-27)$中调整正则化参数$\lambda$的困难，将SLIM拓展到多快拍情况，也即噪声是方差为$\eta$的i.i.d高斯分布，$\boldsymbol X$服从如下的先验分布：</p>
<script type="math/tex; mode=display">
f(\boldsymbol X) \propto  \prod_{n} \exp\left[-\dfrac{2}{q}(||\boldsymbol X_n||_2^q - 1)\right] \tag{5-28}</script><p>与单快拍类似，SLIM通过求解下述$l_{2,q}$优化问题得到$\boldsymbol X$的MAP：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol x} M \log \eta + \eta^{-1} ||\boldsymbol{AX} - \boldsymbol Y||_F^2 + \dfrac{2}{q}||\boldsymbol X||_{2,q}^q \tag{5-29}</script><p>使用与M-FOCUSS类似的重新加权技术，可以以封闭形式迭代更新$\boldsymbol X$和$\eta$，从而得到SLIM的多快拍版本。</p>
<p><strong>(五) 稀疏迭代协方差估计SPICE</strong><sup><a href="#[62]">[62]</a></sup></p>
<blockquote>
<p>SPICE(Sparse Iterative Covariance-based Estimation)是一种用于稀疏信号处理和估计的算法，主要用于估计协方差矩阵。<strong>基本思想</strong>是利用协方差矩阵的稀疏性来降低算法的复杂度，并通过迭代方法逐步逼近协方差矩阵的真实值。在迭代过程中，SPICE算法利用了一种基于协方差矩阵估计的方法，即<strong>通过最小化原始数据和协方差矩阵之间的误差来估计协方差矩阵</strong>。在估计协方差矩阵的同时，SPICE算法还实现了稀疏性，即只有少数非零元素的矩阵表示。</p>
</blockquote>
<p>(1) 广义最小二乘</p>
<p>为了推导广义最小二乘，做如下统计假设：</p>
<script type="math/tex; mode=display">
\left\{\boldsymbol x(1), \cdots, \boldsymbol x(L), \boldsymbol e(1), \cdots, \boldsymbol e(L)\right\}  \tag{5-30}</script><p>是互不相关的，并且满足：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\mathbb{E}\left[\boldsymbol e(t) \boldsymbol e^{\mathrm H}(t)\right] = \sigma \boldsymbol I \\
& \mathbb{E}\left[\boldsymbol x(t) \boldsymbol x^{\mathrm H}(t)\right] =  \boldsymbol P = \mathrm{diag}(\boldsymbol p)
\end{aligned}  \tag{5-31}</script><p>其中，$\sigma \geq 0$，$p_n \geq 0,(n = 1,2,\cdots, \bar N)$是感兴趣的参数。由此可得，观测数据$\{\boldsymbol y(1), \cdots, \boldsymbol y(L)\}$是互不相关的，其协方差为：</p>
<script type="math/tex; mode=display">
\boldsymbol R = \mathbb{E}\left[\boldsymbol y(t) \boldsymbol y^{\mathrm H}(t)\right] = \boldsymbol{APA}^{\mathrm H} + \sigma \boldsymbol I = \boldsymbol A' \boldsymbol P' \boldsymbol A'^{\mathrm H}  \tag{5-32}</script><p>其中，$\boldsymbol A’ = [\boldsymbol A, \boldsymbol I] \in \mathbb C^{M \times (\bar N + M)}$，$\boldsymbol P’ = \mathrm{diag}(\boldsymbol p, \sigma I) \in \mathbb C^{(\bar N + M)\times (\bar N + M)}$，该过程示意图如下。</p>
<center><img src="https://pic.imgdb.cn/item/64f6d6f7661c6c8e54a11f52.jpg" style="zoom:60%"></center>

<p>据此，看到$\boldsymbol R$是参数$(\boldsymbol p, \sigma )$的线性函数。记样本协方差矩阵(Sample Covariance Matrix, SCM)为$\tilde{\boldsymbol R} = \dfrac{1}{L} \boldsymbol{YY}^{\mathrm H}$，给定$\tilde{\boldsymbol R}$，为了估计$\boldsymbol R$(实际上是估计参数$\boldsymbol p$和$\sigma$)，考虑<strong>广义最小二乘法</strong>。</p>
<p>首先向量化$\tilde{\boldsymbol R}$为$\tilde{\boldsymbol r} = \mathrm{vec}(\tilde{\boldsymbol R})$，向量化$\boldsymbol R$为$\boldsymbol r = \mathrm{vec}(\boldsymbol R)$，由于$\tilde{\boldsymbol R}$是${\boldsymbol R}$的无偏估计，因此有：</p>
<script type="math/tex; mode=display">
\mathbb E(\tilde{\boldsymbol r}) = \boldsymbol r \tag{5-33}</script><p>此外可以计算$\tilde{\boldsymbol r}$的协方差矩阵为(<a href="https://www.doc88.com/p-3157185346622.html">参考文档-加权协方差拟合准则推导</a>)：</p>
<script type="math/tex; mode=display">
\mathrm{Cov}(\tilde{\boldsymbol r}) = \dfrac{1}{L} {\boldsymbol R}^{\mathrm T} \otimes \boldsymbol R \tag{5-34}</script><p>在广义最小二乘中最小化下述过程：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \quad\dfrac{1}{L}(\widetilde{\boldsymbol{r}}-\mathbb{E} \widetilde{\boldsymbol{r}})^{\mathrm H} \mathrm{Cov}^{-1}(\widetilde{\boldsymbol{r}})(\widetilde{\boldsymbol{r}}-\mathbb{E} \widetilde{\boldsymbol{r}}) \\
=&\quad (\widetilde{\boldsymbol{r}}-\boldsymbol{r})^{\mathrm H}\left[\boldsymbol{R}^{-{\mathrm T}} \otimes \boldsymbol{R}^{-1}\right](\widetilde{\boldsymbol{r}}-\boldsymbol{r}) \\
=&\quad\operatorname{vec}^{\mathrm H}(\widetilde{\boldsymbol{R}}-\boldsymbol{R})\left[\boldsymbol{R}^{-{\mathrm T}} \otimes \boldsymbol{R}^{-1}\right] \operatorname{vec}(\widetilde{\boldsymbol{R}}-\boldsymbol{R}) \\
=&\quad\operatorname{vec}^{\mathrm H}(\widetilde{\boldsymbol{R}}-\boldsymbol{R}) \operatorname{vec}\left\{\boldsymbol{R}^{-1}(\widetilde{\boldsymbol{R}}-\boldsymbol{R}) \boldsymbol{R}^{-1}\right\} \\
=&\quad\operatorname{Tr}\left\{(\widetilde{\boldsymbol{R}}-\boldsymbol{R}) \boldsymbol{R}^{-1}(\widetilde{\boldsymbol{R}}-\boldsymbol{R}) \boldsymbol{R}^{-1}\right\} \\
=&\quad\left\|\boldsymbol{R}^{-\frac{1}{2}}(\widetilde{\boldsymbol{R}}-\boldsymbol{R}) \boldsymbol{R}^{-\frac{1}{2}}\right\|_{\mathrm{F}}^2
\end{aligned} \tag{5-35}</script><p>式$(5-35)$中的准则具有良好的统计特性；例如，在某些条件下，它提供了感兴趣的参数$(\boldsymbol p, \sigma )$的大快照最大似然ML估计器。不幸的是式$(5-35)$在${\boldsymbol R}$中是非凸的，因此在$(\boldsymbol p, \sigma )$中也是非凸的。因此不能保证它可以在全局范围内最小化。</p>
<p>根据式$(5-35)$的启发，提出一种凸准则：</p>
<script type="math/tex; mode=display">
\left|\left|\tilde{\boldsymbol R}^{-1/2}(\tilde{\boldsymbol R} - \boldsymbol R)\tilde{\boldsymbol R}^{-1/2}\right|\right|_F^2 \tag{5-36}</script><p>其中，式$(5-34)$中的$\mathrm{Cov}(\tilde{\boldsymbol r})$用其一致估计代替，也即$\dfrac{1}{L} \tilde{\boldsymbol R}^{\mathrm T} \otimes \tilde{\boldsymbol R}$。由此得到的估计是一个大样本ML估计值，但它只适用于$\tilde{\boldsymbol R}$是非奇异且$L \geq M$的情况。接下来介绍的SPICE算法依赖于式$(5-35)$或式$(5-36)$。</p>
<p>(2) SPICE算法</p>
<p>在SPICE中，当$\tilde{\boldsymbol R}$是非奇异且$L \geq M$时，采用如下协方差拟合准则：</p>
<script type="math/tex; mode=display">
h_1 = \left|\left|{\boldsymbol R}^{-1/2}(\tilde{\boldsymbol R} - \boldsymbol R)\tilde{\boldsymbol R}^{-1/2}\right|\right|_F^2 \tag{5-37}</script><p>在$L&lt;M$，$\tilde{\boldsymbol R}$是奇异时，使用如下拟合标准：</p>
<script type="math/tex; mode=display">
h_2 = \left|\left|{\boldsymbol R}^{-1/2}(\tilde{\boldsymbol R} - \boldsymbol R)\right|\right|_F^2 \tag{5-38}</script><p>一个简单的计算显示？？？</p>
<script type="math/tex; mode=display">
\begin{aligned}
h_1 &=\mathrm{Tr}\left(\boldsymbol R^{-1}\tilde{\boldsymbol R}\right) + \mathrm{Tr}\left(\tilde{\boldsymbol R}^{-1}{\boldsymbol R}\right)-2M \\
&=\mathrm{Tr}\left(\tilde{\boldsymbol R}^{1/2}\boldsymbol R^{-1}\tilde{\boldsymbol R}^{1/2}\right) + \sum_{n=1}^{\bar N} \left(\boldsymbol a_n^{\mathrm H} \tilde{\boldsymbol R}^{-1} \boldsymbol a_n\right) + \mathrm{Tr}\left(\tilde{\boldsymbol R}^{-1}\right) \sigma-2M
\end{aligned} \tag{5-39}</script><p>因此基于$h_1$的SPICE的优化问题可以等价地表示为：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol p \succeq 0, \sigma>0} \mathrm{Tr}\left(\tilde{\boldsymbol R}^{1/2}\boldsymbol R^{-1}\tilde{\boldsymbol R}^{1/2}\right) + \sum_{n=1}^{\bar N} \left(\boldsymbol a_n^{\mathrm H} \tilde{\boldsymbol R}^{-1} \boldsymbol a_n\right)p_n + \mathrm{Tr}\left(\tilde{\boldsymbol R}^{-1}\right) \sigma \tag{5-40}</script><p>注意，上式中目标函数的第一项可以等价于：？？？</p>
<script type="math/tex; mode=display">
\mathrm{Tr}\left(\tilde{\boldsymbol R}^{1/2}\boldsymbol R^{-1}\tilde{\boldsymbol R}^{1/2}\right) =
 \begin{cases}
 \min & \mathrm{Tr}(\boldsymbol X)\\ 
 \text { s.t. } & \left[\begin{array}{cc}
\boldsymbol X&  \tilde{\boldsymbol R}^{1/2} \\
\tilde{\boldsymbol R}^{1/2} & \boldsymbol R
\end{array}\right] \succeq 0
 \end{cases} \tag{5-41}</script><p>此时它在$\boldsymbol R$中是凸的，也即在参数$(\boldsymbol p, \sigma)$中是凸的，因此$h_1$在参数$(\boldsymbol p, \sigma)$上是凸的。</p>
<p>同样，对于$h_2$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
h_2 &=\mathrm{Tr}\left(\boldsymbol R^{-1}\tilde{\boldsymbol R^2}\right) + \mathrm{Tr}\left({\boldsymbol R}\right)-2\mathrm{Tr}\left(\tilde{\boldsymbol R}\right) \\
&=\mathrm{Tr}\left(\tilde{\boldsymbol R}\boldsymbol R^{-1}\tilde{\boldsymbol R}\right) + \sum_{n=1}^{\bar N} \left(\boldsymbol ||a_n||_2^2 p_n\right) -2 \mathrm{Tr}\left(\tilde{\boldsymbol R}\right) +2M\sigma
\end{aligned} \tag{5-42}</script><p>此时，对应的优化问题：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol p \succeq 0, \sigma>0}\mathrm{Tr}\left(\tilde{\boldsymbol R}\boldsymbol R^{-1}\tilde{\boldsymbol R}\right) + \sum_{n=1}^{\bar N} \left(\boldsymbol ||a_n||_2^2 p_n\right) +2M\sigma \tag{5-43}</script><p>与式$(5-40)$类似，式$(5-43)$也是凸的，尽管式$(5-40)$、式$(5-43)$都可以被表示为二阶锥优化(SOCP)或半定规划(SDP)，并且有标准的求解器，但由于维度高，在实践中不能基于这些公式轻松求解。</p>
<p>我们现在<strong>介绍SPICE算法来处理上述<font color="blue">计算问题</font></strong>。我们关注的是$L \geq M$的情况，但类似的结果也适用于$L&lt;M$的情况。SPICE的主要基础是以下重新构造：</p>
<script type="math/tex; mode=display">
\mathrm{Tr}\left(\tilde{\boldsymbol R}^{1/2}\boldsymbol R^{-1}\tilde{\boldsymbol R}^{1/2}\right) =
 \begin{cases}
 \min\limits_{\boldsymbol C} & \mathrm{Tr}(\boldsymbol C^{\mathrm H}\boldsymbol P'^{-1} \boldsymbol C)\\ 
 \text { s.t. } & \boldsymbol A' \boldsymbol C = \tilde{\boldsymbol R}^{1/2} 
 \end{cases} \tag{5-44}</script><p>并表明$\boldsymbol C$的解由下式给出：</p>
<script type="math/tex; mode=display">
\boldsymbol C = \boldsymbol P' \boldsymbol A'^{\mathrm H}\boldsymbol R^{-1} \tilde{\boldsymbol R}^{1/2}  \tag{5-45}</script><p>将式$(5-44)$带入到式$(5-40)$中，可得最小化$h_1$等价于：</p>
<script type="math/tex; mode=display">
\begin{cases}
 \min\limits_{\boldsymbol C, \boldsymbol p \succeq 0, \sigma>0} &\mathrm{Tr}(\boldsymbol C^{\mathrm H}\boldsymbol P'^{-1} \boldsymbol C) + \displaystyle\sum\limits_{n=1}^{\bar N} \left(\boldsymbol a_n^{\mathrm H} \tilde{\boldsymbol R}^{-1} \boldsymbol a_n\right)p_n + \mathrm{Tr}\left(\tilde{\boldsymbol R}^{-1}\right) \sigma\\ 
 \text { s.t. } & \boldsymbol A' \boldsymbol C = \tilde{\boldsymbol R}^{1/2} 
 \end{cases} \tag{5-46}</script><p>基于式$(5-46)$，通过迭代求解$\boldsymbol C$和$(\boldsymbol p, \sigma)$，得出SPICE算法为：</p>
<ol>
<li>首先使用传统波束形成器来初始化$(\boldsymbol p, \sigma)$；</li>
<li>根据$(\boldsymbol p, \sigma)$的最新值带入式$(5-45)$更新$\boldsymbol C$；</li>
<li>再固定$\boldsymbol C$来更新$(\boldsymbol p, \sigma)$；</li>
<li>重复这一过程直到收敛。</li>
</ol>
<p>注意：$(\boldsymbol p, \sigma)$是有解析解的在固定$\boldsymbol C$时，为进一步说明，考察：</p>
<script type="math/tex; mode=display">
 \mathrm{Tr}(\boldsymbol C^{\mathrm H}\boldsymbol P'^{-1} \boldsymbol C) = \sum_{n}^{\bar N} \dfrac{||\boldsymbol C_n||_2^2}{p_n} + \sum_{n=\bar N + 1}^{\bar N +M}\dfrac{||\boldsymbol C_n||_2^2}{\sigma} \tag{5-47}</script><p>其中，$\boldsymbol C_n$表示$\boldsymbol C$的第$n$行。将式$(5-47)$带入式$(5-46)$可得：</p>
<script type="math/tex; mode=display">
\begin{aligned}
p_n & =\dfrac{\left\|\boldsymbol{C}_n\right\|_2}{\sqrt{\boldsymbol{a}_n^{\mathrm H}\widetilde{\boldsymbol{R}}^{-1} \boldsymbol{a}_n}}, \quad n=1, \ldots, \bar{N}, \\ \\
\sigma & =\sqrt{\sum_{n=\bar{N}+1}^{\bar{N}+M}\dfrac{\left\|\boldsymbol{C}_n\right\|_2^2}{\operatorname{Tr}\left(\widetilde{\boldsymbol{R}}^{-1}\right)}} .
\end{aligned} \tag{5-48}</script><p>由于问题是凸的，并且目标函数在迭代过程中单调递减，因此SPICE算法有望收敛到全局最小值。</p>
<p>接下来我们将讨论如何在SPICE中利用信号稀疏性和联合稀疏性。将式$(5-48)$插入$(5-46)$中，我们看到SPICE问题等价于：</p>
<script type="math/tex; mode=display">
\begin{cases}
 \min\limits _{\boldsymbol{C}} &\displaystyle\sum\limits_{n=1}^{\bar{N}} \sqrt{\boldsymbol{a}_n^{\mathrm H} \widetilde{\boldsymbol{R}}^{-1} \boldsymbol{a}_n}\left\|\boldsymbol{C}_n\right\|_2+\sqrt{\operatorname{Tr}\left(\widetilde{\boldsymbol{R}}^{-1}\right) \sum_{n=\bar{N}+1}^{\bar{N}+M}\left\|\boldsymbol{C}_n\right\|_2^2}\\ 
 \text { s.t. } & \boldsymbol A^{\prime} \boldsymbol C=\widetilde{\boldsymbol{R}}^{1/2}
 \end{cases} \tag{5-49}</script><p>观察到，式$(5-49)$中第一项实际上是$\boldsymbol C$的前$\bar N$行的$l_2$范数的加权和(加权$l_{2,1}$范数)，从而促进了$\boldsymbol C$的行稀疏性，因此可以预期大部分$||\boldsymbol C_n||_2$将等于0，与式$(5-48)$一起看，则大部分$p_n$等于0，从而实现稀疏性。联合稀疏性是通过假设$\boldsymbol X$的每一行中的条目具有相同的方差$p_n$来实现的。</p>
<p>SPICE与单快照情况下的平方根LASSO有关。式$(5-43)$中的SPICE问题等效于：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol x} ||\boldsymbol x||_1 + ||\boldsymbol y - \boldsymbol{Ax}||_2 \tag{5-50}</script><p>也即相当于平方根LASSO中正则化参数$\tau = 1$的情况。</p>
<p>最后，请注意，式$(5-32)$中的分解在一般情况下并<strong>不是唯一的</strong>。这一观察结果的直接结果是SPICE算法通常不能提供$(\boldsymbol p, \sigma)$的唯一估计。这个问题将在SPICE的无网格版本中得到解决，</p>
<p><strong>(六) 最大似然估计MLE</strong></p>
<p>在MLE中也可以利用联合稀疏性，方法与SPICE类似。</p>
<p>设$\boldsymbol x(t), t=1,\cdots, L$是均值为0，协方差为$\boldsymbol P = \mathrm{diag}(\boldsymbol p)$的i.i.d的多元高斯分布。同时假设存在方差为$\sigma$的i.i.d的高斯噪声，且$\boldsymbol{X,E}$相互独立。那么观测数据$\boldsymbol y(t), t = 1, \cdots, L$则是i.i.d的0均值、协方差为$\boldsymbol R = \boldsymbol{APA}^{\mathrm H} + \sigma \boldsymbol I$的高斯分布，与$\boldsymbol Y$相关的负对数似然函数(<a href="https://zhuanlan.zhihu.com/p/301741267">参考文档-深入浅出多维高斯分布的最大似然估计矩阵推导</a>)为：</p>
<script type="math/tex; mode=display">
\mathcal L(\boldsymbol p, \sigma) = \log |\boldsymbol R| + \mathrm{Tr}\left(\boldsymbol R^{-1} \tilde{\boldsymbol R}\right) \tag{5-51}</script><p>由此可通过该式进行参数$(\boldsymbol p, \sigma)$的估计：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol p, \sigma}\mathcal L(\boldsymbol p, \sigma) = \min_{\boldsymbol p, \sigma} \log |\boldsymbol R| + \mathrm{Tr}\left(\boldsymbol R^{-1} \tilde{\boldsymbol R}\right) \tag{5-52}</script><p>多快照MLE已在SBL或贝叶斯压缩传感框架内进行了研究。为了利用 $\boldsymbol x(t), t = 1, \cdots, L$的联合稀疏性，假定所有的$\boldsymbol x(t)$都有相同的稀疏先验。EM算法也可以通过最小化式$(5-52)$中的目标来进行参数估计。</p>
<p>在网格方法的框架内似乎很难获得对该问题的完全令人满意的解决方案，因为所采用的离散网格点与真正的连续DOA之间总是存在不匹配。</p>
<h5 id="5-3-偏离网格-Off-Grid-的DOA估计"><a href="#5-3-偏离网格-Off-Grid-的DOA估计" class="headerlink" title="5.3 偏离网格(Off-Grid)的DOA估计"></a>5.3 偏离网格(Off-Grid)的DOA估计</h5><p>离散网格外的稀疏回复算法仍然需要进行网格划分，但与On-Grid的方法不同的是，DOA估计不在受限于网格上，Off-Grid的方法主要有两个方向：</p>
<ol>
<li>基于固定网格和网格偏移的联合估计方法；</li>
<li>依赖动态网格的估计；</li>
</ol>
<p><strong>(一) 固定网格+网格偏移</strong></p>
<p>对于固定网格$\bar{\boldsymbol \theta} = (\bar\theta_1, \cdots, \bar \theta_{\bar N})$，可引入如下的Off-Grid数据模型。假设$\bar{\boldsymbol \theta}$是由均匀间隔的网格点组成，网格间隔为$ r = \bar \theta_{k+1} - \bar \theta_k \propto \dfrac{1}{\bar N}$。则对于任意真实的DOA $\theta_k$，设离其最近的网格点为$\bar \theta_{nk}$，满足$|\theta_k - \bar \theta_{nk}|&lt;\dfrac{r}{2}$，此时使用一阶泰勒展开来近似导向矢量$\boldsymbol a(\theta_k)$：</p>
<script type="math/tex; mode=display">
\boldsymbol a(\theta_k) \approx \boldsymbol a(\bar \theta_{nk}) + \boldsymbol b(\bar \theta_{nk})(\theta_k - \bar \theta_{nk}) \tag{5-53}</script><p>其中，$ \boldsymbol b(\bar \theta_{nk}) =  \boldsymbol a’(\bar \theta_{nk})$，类比On-Grid数据模型式$(5-18)$，可得此时数据模型表示为：</p>
<script type="math/tex; mode=display">
\boldsymbol Y = \boldsymbol \Phi(\boldsymbol \beta) \boldsymbol X + \boldsymbol E \tag{5-54}</script><p>其中，$\boldsymbol \Phi(\boldsymbol \beta) = \boldsymbol A + \boldsymbol B \mathrm{diag}(\boldsymbol \beta)$，阵列流形矩阵$\boldsymbol A$的定义不变，具体各部分的定义如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
& \boldsymbol A = \left[\boldsymbol a(\bar \theta_1), \cdots, \boldsymbol a(\bar \theta_{\bar N})\right] \\
&\boldsymbol B = \left[\boldsymbol b(\bar \theta_1), \cdots, \boldsymbol b(\bar \theta_{\bar N})\right] \\
& \boldsymbol \beta = \left[\beta_1, \cdots, \beta_{\bar N}\right] \in \left[-\dfrac{r}{2}, \dfrac{r}{2}\right]^{\bar N}
\end{aligned} \tag{5-55}</script><p>且满足：</p>
<script type="math/tex; mode=display">
\begin{aligned}
x_n(t) & = \begin{cases}s_k(t), & \text { if } \bar{\theta}_n=\bar{\theta}_{n_k} ; \\
0, & \text { otherwise, }\end{cases} &\beta_n  = \begin{cases}\theta_k-\bar{\theta}_{n_k}, & \text { if } \bar{\theta}_n=\bar{\theta}_{n_k} ;  \\
0, & \text { otherwise, }\end{cases}
\end{aligned} \tag{5-56}</script><p>其中$n=1, \cdots, \bar{N}, t=1, \cdots, L$。</p>
<p>由式$(5-54)$可知，Off-Grid模型下，DOA估计问题可以表述为具有不确定参数的稀疏表示。 特别是，一旦可以根据$\boldsymbol Y$估计行稀疏矩阵$\boldsymbol  X$和$\boldsymbol \beta$ ，则可以估计DOA。</p>
<p>与On-Grid模型式$(5-18)$相比，式$(5-54)$的Off-Grid模型引入了额外的网格偏移参数$\beta_n, n = 1, \cdots, \bar{N}$。注意，若$\boldsymbol \beta = \boldsymbol 0$，则式$(5-54)$的Off-Grid模型可化简为式$(5-18)$的On-Grid数据模型。式$(5-18)$的On-Grid数据模型可视为真实数据模型的<strong>0阶近似</strong>，而式$(5-54)$的Off-Grid模型可视为真实数据模型的<strong>1阶近似</strong>，网格失配可以通过联合估计网格偏移量得到补偿。</p>
<p>基于式$(5-54)$中的Off-Grid模型已经提出了几种联合估计$\boldsymbol  X$和$\boldsymbol \beta$的算法，下面重点介绍基于$l_1$优化和SBL的2种算法。</p>
<p>(1) $l_1$优化算法</p>
<p>受标准稀疏恢复的启发，提出了几种$l_1$优化算法来处理Off-Grid中的DOA估计。首先是一种称为<strong>稀疏全最小二乘(Sparse Total Least-Squares, STLS)</strong>的算法，在单快拍情况下，可解决如下类似LASSO的问题：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol x , \boldsymbol \beta} \lambda_1 ||\boldsymbol x||_1 + \dfrac{1}{2}|| \boldsymbol y - [\boldsymbol A + \boldsymbol B \mathrm{diag}(\boldsymbol \beta)] \boldsymbol x ||_2^2 + \lambda_2 || \boldsymbol \beta||_2^2 \tag{5-57}</script><p>其中，$\lambda_1, \lambda_2$是正则化参数。但式$(5-57)$中没有使用$\boldsymbol \beta \in \left[-\dfrac{r}{2}, \dfrac{r}{2}\right]^{\bar N}$的先验信息。为了启发式控制$\boldsymbol \beta$的大小，它的功率也被最小化。注意，由于<strong>双线性</strong>项$\mathrm{diag}(\boldsymbol \beta) \boldsymbol x$，式$(5-57)$中的问题是非凸的。因此，为了求解式$(5-57)$采用一种<strong>交替算法</strong>，迭代求解$\boldsymbol x$和$\boldsymbol \beta$。此外式$(5-57)$也可以拓展到MMV情况来利用$\boldsymbol X$的联合稀疏性。但这些算法都存在一定的困难——参数$\lambda_1, \lambda_2$的选择。</p>
<p>为了利用先验信息$\boldsymbol \beta \in \left[-\dfrac{r}{2}, \dfrac{r}{2}\right]^{\bar N}$，提出了类似BPDN的算法用于单快拍情况：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol x, \boldsymbol \beta \in \left[-\dfrac{r}{2}, \dfrac{r}{2}\right]^{\bar N}} & ||\boldsymbol{x}||_1 \\ 
\text { s.t. } & \left|\left| \boldsymbol y - [\boldsymbol A \quad \boldsymbol B]   \left[\begin{array}{c} \boldsymbol x \\ \boldsymbol \beta \odot \boldsymbol x \end{array}\right]
 \right|\right|_2 \leq \eta
\end{cases} \tag{5-58}</script><p>其中，$\odot$表示Hadamard乘积，对应位置元素相乘(Hadamard乘积也可以使用$\circ$符号表示)，$\eta$与噪声水平有关。 类似式$(5-57)$，式$(5-58)$也是非凸的，因此也可以利用<strong>交替算法</strong>来单调地减小目标函数。</p>
<p>在上述算法基础上，另一种凸优化算法利用$\boldsymbol x$和$\boldsymbol v = \boldsymbol \beta \odot \boldsymbol x$地联合稀疏性：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol x, \boldsymbol v} \lambda ||[\boldsymbol x \quad \boldsymbol v]||_{2,1} + \dfrac{1}{2}\left|\left| \boldsymbol y - [\boldsymbol A \quad \boldsymbol B]   \left[\begin{array}{c} \boldsymbol x \\ \boldsymbol v\end{array}\right]
 \right|\right|_2^2  \tag{5-59}</script><p>式$(5-59)$在参数选择合适的情况下，等价于下面的问题：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol x, \boldsymbol v} & ||[\boldsymbol{x \quad v}]||_{2,1} \\ 
\text { s.t. } & \left|\left| \boldsymbol y - [\boldsymbol A \quad \boldsymbol B]   \left[\begin{array}{c} \boldsymbol x \\ \boldsymbol v \end{array}\right]
 \right|\right|_2 \leq \eta
\end{cases} \tag{5-60}</script><p>这种方法的优势在于它是凸的，可以在多项式时间内求全局解。但该方法无法利用$\boldsymbol \beta$的先验信息，得到的解$\beta_n = \dfrac{v_n}{x_n}$甚至不正确，为解决这个问题，一种2阶段解决方案被提出：</p>
<ol>
<li>首先从式$(5-59)$中求解得到$\boldsymbol x$；</li>
<li>再固定$\boldsymbol x$，通过最小化$|| \boldsymbol y - [\boldsymbol A + \boldsymbol B \mathrm{diag}(\boldsymbol \beta)] \boldsymbol x ||_2^2$来求解$\boldsymbol \beta$；</li>
</ol>
<p>(2) SBL优化算法</p>
<p>相关文献在多快照下的SBL框架内提出一种Off-Grid DOA估计的系统方法，称为<strong><font color="green">离网稀疏贝叶斯推理(OGSBI)</font></strong>。 为了估计附加参数$\boldsymbol \beta$，假设$\beta_n(n=1, \cdots, \bar N)$是i.i.d的均匀分布在区间$\left[-\dfrac{r}{2}, \dfrac{r}{2}\right]$上。 在所得的EM算法中，行稀疏信号$\boldsymbol X$的后验分布可以像标准SBL中一样在期望步骤中计算。 在最大化步骤中，除了更新行稀疏信号的功率$\boldsymbol p$和噪声方差$\sigma$之外，还更新$\boldsymbol \beta$。 与标准SBL 一样，似然度保证单调增加，因此可以获得算法的收敛性。</p>
<p><strong>(二) 动态网格</strong></p>
<p>数据模型被称为动态网格$\bar{\boldsymbol \theta}$，因为网格点$\theta_n$不是固定的：</p>
<script type="math/tex; mode=display">
\boldsymbol Y = \boldsymbol A(\bar{\boldsymbol \theta}) \boldsymbol X + \boldsymbol E \tag{5-61}</script><p>对于这个模型，我们需要联合估计行稀疏矩阵$\boldsymbol X$和网格$\bar{\boldsymbol \theta}$。 一旦获得它们，就使用与$\boldsymbol X$的非零行相对应的$\bar{\boldsymbol \theta}$网格点来估计DOA。由于$\theta_n$是根据数据估计的并且可以是连续 DOA 域中的任何值，因此这种离网数据模型是准确的，并且不会出现网格失配。 然而，由于映射$\boldsymbol a(θ)$的非线性，设计$\boldsymbol X$和$\bar{\boldsymbol \theta}$联合估计的算法是困难的。 请注意，我们将介绍的以下算法被指定为离网方法而不是无网格方法，因为它们仍然涉及网格选择(例如$\bar N$的选择和$\bar{\boldsymbol \theta}$的初始化），这会影响算法的计算速度和准确性。 </p>
<p>基于式$(5-61)$中的数据模型，已经提出了几种算法：</p>
<ul>
<li><strong>基于SBL框架</strong></li>
</ul>
<p>第一类在<strong>SBL的框架</strong>内。但是，通常利用变分<font color="blue">EM算法(或变分贝叶斯推断)</font>来执行稀疏信号和参数估计，而不是像以前那样使用EM算法。原因是稀疏向量$\boldsymbol x$的后验分布通常不能在这里明确计算，并且EM需要该分布，而变分EM不需要。这些算法的主要困难是由于强非线性而更新$\boldsymbol \theta$。由于无法获得闭合形式的解，因此只能使用数值方法。</p>
<ul>
<li><strong>基于$l_1$优化</strong></li>
</ul>
<p>在单个快照的情况下，作为一个例子，论文<a href="#[60]">[60]</a>使用了一个小的$\bar N \geq K$，并试图通过迭代更新$\boldsymbol x$和$\boldsymbol \theta$来解决以下$l_1$优化问题：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol x,\bar{\boldsymbol \theta}} \lambda ||\boldsymbol x||_{1} + \dfrac{1}{2}\left|\left| \boldsymbol y - \boldsymbol A(\bar{\boldsymbol \theta}) \boldsymbol x
 \right|\right|_2^2  \tag{5-62}</script><p>为了避免某些$\bar \theta_n$收敛到相同的值，加入一个额外的(非凸)项$g(\bar{\boldsymbol \theta})$来惩罚位置紧邻的参数：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol x,\bar{\boldsymbol \theta}} \lambda_1 ||\boldsymbol x||_{1} + \dfrac{1}{2}\left|\left| \boldsymbol y - \boldsymbol A(\bar{\boldsymbol \theta}) \boldsymbol x
 \right|\right|_2^2 + \lambda_2 g(\bar{\boldsymbol \theta})  \tag{5-63}</script><p>其中，$\lambda_1, \lambda_2$是需要调整的正则化参数项。注意到，式$(5-62)$和式$(5-63)$均是非凸的，因此即使给定$\boldsymbol x$求解$\bar{\boldsymbol \theta}$也是困难的，且参数调整也很困难。此外文献<a href="#[60]">[60]</a>考虑了$l_q(0&lt;q&lt;1)$优化以增强稀疏性，但也存在同样的问题。</p>
<p>为增强稀疏性，相关文献又提出一种类似$l_1$优化算法：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol x,\bar{\boldsymbol \theta}} \sum_{n=1}^{\bar N} \lambda \log\left(|x_n|^2+\varepsilon\right)+ \left|\left| \boldsymbol y - \boldsymbol A(\bar{\boldsymbol \theta}) \boldsymbol x
 \right|\right|_2^2  \tag{5-64}</script><p>为了局部求解式$(5-64)$，要迭代更新$\boldsymbol x$和$\bar{\boldsymbol \theta}$。为了以封闭形式求解$\boldsymbol x$，式$(5-64)$中目标函数的第一项被一个二次代理函数代替，该函数保证了目标的下降。然后使用梯度下降法来解$\bar{\boldsymbol \theta}$，尽管难以选择$\lambda$，但被建议将$\lambda$设置为与噪声方差的倒数成比例。</p>
<p>总之，Off-Grid的方法引入了更多要估计的量，使算法复杂化了，且多数算法都涉及了非凸优化，只能保证局部收敛。此外很多算法没有理论保证。</p>
<h5 id="5-4-无网格-Gridless-的DOA估计"><a href="#5-4-无网格-Gridless-的DOA估计" class="headerlink" title="5.4 无网格(Gridless)的DOA估计"></a>5.4 无网格(Gridless)的DOA估计</h5><p><strong>(一) 数据模型</strong></p>
<p>重新梳理数据模型，对于$N$阵元的ULA，数据模型为：</p>
<script type="math/tex; mode=display">
\boldsymbol Y = \boldsymbol A(\boldsymbol f)\boldsymbol S +\boldsymbol E \tag{5-65}</script><p>其中，$\boldsymbol f=(f_1, \cdots, f_K), f_k \in \mathbb T = \left(-\dfrac{1}{2}, \dfrac{1}{2}\right]$，$\boldsymbol A(\boldsymbol f) = [\boldsymbol a(f_1), \cdots, \boldsymbol a(f_K)] \in \mathbb C^{N \times K}$。</p>
<p>在单快照情况下，上述问题与线谱(频率)估计问题一致。 由于第一个无网格稀疏方法是针对线谱(频率)估计问题开发的，因此我们在单个快照情况下介绍它们，然后讨论如何通过利用快照的联合稀疏性将它们扩展到多个快照情况。 在此之前，下一小节将介绍一个重要的数学工具——<strong>Vandermonde分解</strong>。</p>
<p><strong>(二) Toeplitz协方差矩阵的Vandermonde分解</strong></p>
<p>在无噪情况下，数据的协方差矩阵为：</p>
<script type="math/tex; mode=display">
\boldsymbol R = \mathbb{E}\left(\boldsymbol y(t) \boldsymbol y^{\mathrm H}(t)\right) = \boldsymbol A(\boldsymbol f)\mathrm{diag}(\boldsymbol p)\boldsymbol A^{\mathrm H}(\boldsymbol f) \tag{5-66}</script><p>其中，$p_k &gt;0 (k = 1, \cdots,K)$是源信号的功率。可以验证数据的协方差矩阵$\boldsymbol R$是一个<strong>Hemitian Toeplitz矩阵</strong>：</p>
<script type="math/tex; mode=display">
\boldsymbol R = \boldsymbol T(\boldsymbol u) = \left[\begin{array}{cccc}
u_1 & u_2 & \cdots & u_N \\
u_2^* & u_1 & \cdots & u_{N-1}\\
\vdots & \vdots & \ddots & \vdots \\
u_N^* & u_{N-1}^* & \cdots & u_1
\end{array}\right] \tag{5-67}</script><p>其中，$\boldsymbol u = [u_1,u_2, \cdots, u_n] \in \mathbb C^N$。并且<strong>$\boldsymbol R$是一个半正定矩阵(PSD)</strong>，秩为$K$(在$K&lt;N$的条件下)。</p>
<p>Vandermonde分解定理表明：任意非满秩且半正定的Toeplitz矩阵都可以唯一地分解为如式$(5-66)$所示的形式。这就意味着可以从数据协方差中精确地提取频率。形式上这个定理可以表述为如下形式：</p>
<p><img src="https://pic.imgdb.cn/item/64f8724b661c6c8e54069370.jpg"></p>
<p>证明请参考<a href="https://blog.csdn.net/weixin_43413559/article/details/128116149">半正定Toeplitz矩阵的范德蒙德分解 - CSDN</a>。</p>
<p>在同噪声方差的情况下，协方差$\boldsymbol R$仍是Toeplitz矩阵，此时自然可将$\boldsymbol R$分解为信号协方差与噪声协方差之和：</p>
<p><img src="https://pic.imgdb.cn/item/64f87296661c6c8e5406af96.jpg"></p>
<p>Toeplitz矩阵的Vandemonde分解是无网格稀疏方法中的一个重要工具，特别是这些方法将线谱(频率)估计问题转化为一个PSD的Toeplitz矩阵的估计问题，一旦矩阵被估计出来，则可以进行Vandemonde分解获得频率。</p>
<p>通过将Toeplitz矩阵释义为数据协方差矩阵(尽管可能因为某些统计假设不成立，导致并不是)，与传统的子空间方法直接从样本协方差矩阵估计频率不同，无网格方法利用更复杂的优化方法来估计数据协方差，利用其特殊结构/性质(Toeplitz性、低秩性、半正定性)有望实现更优的性能。</p>
<p>下面，在单快拍情况下讨论2种无网格稀疏优化方法：</p>
<ol>
<li>确定性优化算法：① 原子范数；② Hankle范数；</li>
<li>协方差拟合方法：① SPICE的无网格版本；</li>
</ol>
<blockquote>
<p>注：“确定性”是指不对感兴趣的信号做出任何统计假设，相反信号是确定性的。我们在一组预定集合中寻找最稀疏的候选信号，候选信号的选取通过某种稀疏度来衡量。</p>
</blockquote>
<p><strong>(三) “确定性”优化算法的通用框架</strong></p>
<p>单快拍情况下的数据：</p>
<script type="math/tex; mode=display">
\boldsymbol y = \boldsymbol z + \boldsymbol e = \boldsymbol A(\boldsymbol f) \boldsymbol s + \boldsymbol e \tag{5-70}</script><p>对于确定性稀疏方法，通常要求解以下形式的优化问题：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{\boldsymbol z} & \mathcal M(\boldsymbol z) \\ 
\text { s.t. } & \left|\left| \boldsymbol z - \boldsymbol y \right|\right|_2 \leq \eta
\end{cases} \tag{5-71}</script><p>其中，$\eta$与噪声功率有关，$\mathcal{M}(\boldsymbol z)$是稀疏度量，该稀疏度量被定义为使得通过最小化$\mathcal{M}(\boldsymbol z)$来减少用于表示$\boldsymbol z$的原子个数。</p>
<p>代替式$(5-71)$，我们可以解决一个正则化问题：</p>
<script type="math/tex; mode=display">
\min_{\boldsymbol z} \lambda \mathcal{M}(\boldsymbol z) + \dfrac{1}{2}\left|\left| \boldsymbol z - \boldsymbol y \right|\right|_2^2  \tag{5-72}</script><p>下面则是要重点考察如何构造$\mathcal{M}(z)$。</p>
<p>(1) 原子$l_0$范数</p>
<p>定义如下原子集：</p>
<script type="math/tex; mode=display">
\mathcal A = \left\{\boldsymbol a(f, \phi) = \boldsymbol a(f) \phi \mid f \in \mathbb T, \phi \in \mathbb C, |\phi| = 1 \right\} \tag{5-73}</script><p>它是无限精度的，因为$f$可以是任意实数。$\phi$是允许了一个初始相位的不同。 而根据式$(5-70)$，真实信号$\boldsymbol z$是原子集中$K$个原子的线性组合。 而原子$l_0$范数，就是指能组成$\boldsymbol z$的最少所需原子数， 即：</p>
<script type="math/tex; mode=display">
\begin{aligned}
||\boldsymbol z||_{\mathcal A, 0} =& \inf_{c_k, f_k, \phi_k} \left\{ \mathcal K \left| \boldsymbol z = \sum_{k=1}^{\mathcal K} c_k \boldsymbol a(f_k, \phi_k),  \quad c_k >0, f_k \in \mathbb T, |\phi_k| = 1 \right.\right\} \\
= & \inf_{s_k, f_k} \left\{ \mathcal K \left| \boldsymbol z = \sum_{k=1}^{\mathcal K} s_k \boldsymbol a(f_k),  \quad f_k \in \mathbb T \right. \right\}
\end{aligned} \tag{5-74}</script><p>因为我们的目的就是为了恢复出$\boldsymbol A(\boldsymbol f)$，而$\boldsymbol z$可以写成无数种$\mathcal{A}$ 中原子线性组合的形式。 但只有对应所用原子数最少即对应最小原子$l_0$范数时，此时组成$\boldsymbol z$的原子才恰好对应待恢复的$\boldsymbol A(\boldsymbol f)$。因此，下面的任务就是最小化$\boldsymbol z$的原子$l_0$范数$||\boldsymbol z||_{\mathcal A, 0}$。</p>
<p>虽然模型建立出来了，但是容易看到，如何对$||\boldsymbol z||_{\mathcal A, 0}$进行最小化，可以说是完全摸不着头脑。这似乎比$l_0$范数最小化更为抽象。此时就是见证数学魅力的时刻，考虑如下形式的矩阵：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cc}
x & \boldsymbol z^{\mathrm H} \\
\boldsymbol z & \boldsymbol T(\boldsymbol u) 
\end{array}\right] \succeq 0  \tag{5-75}</script><p>其中，$x$是一个要被优化的自由变量(这里是标量)，$\boldsymbol T(\boldsymbol u)$的定义如之前，是一个由$\boldsymbol u$得到的Teoplitz矩阵。$x$则是一个待优化的变量。 这个约束隐含了如下的结论：</p>
<ol>
<li>$\boldsymbol T(\boldsymbol u) \succeq 0$，否则无法保证对于任何向量$\boldsymbol y$都有$\boldsymbol y^{\mathrm H} \left[\begin{array}{cc} x &amp; \boldsymbol z^{\mathrm H} \\ \boldsymbol z &amp; \boldsymbol T(\boldsymbol u) \end{array}\right]\boldsymbol y \geq 0$；</li>
<li>$\boldsymbol z$ 一定位于$\boldsymbol T(\boldsymbol u)$的列空间中，即$\boldsymbol z$能由$r=\mathrm{rank}(\boldsymbol T(\boldsymbol u))$个原子线性表示。</li>
</ol>
<p>由于$\boldsymbol T(\boldsymbol u) \succeq 0$， 因此$\boldsymbol T(\boldsymbol u)$是一个半正定矩阵， 即存在范德蒙德分解：</p>
<script type="math/tex; mode=display">
\boldsymbol T(\boldsymbol u) = \sum_{k=1}^r p_k \boldsymbol a(f_k) \boldsymbol a^{\mathrm H}(f_k) = \boldsymbol A(\boldsymbol f) \mathrm{diag}(\boldsymbol p) \boldsymbol A^{\mathrm H}(\boldsymbol f) \tag{5-76}</script><p>其中，$r = \mathrm{rank}(\boldsymbol T(\boldsymbol u))$。由于$\boldsymbol z$一定位于$\boldsymbol T(\boldsymbol u)$的列空间中，那么$\boldsymbol z$必能写为$\boldsymbol a(f_k)$的线性组合！ 这一点至关重要，因为这引出了如下的结论：</p>
<p><strong><font color="red">最小化原子$l_0$范数等价于求解如下问题</font>：</strong></p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{x, \boldsymbol u} & r = \mathrm{rank}(\boldsymbol T(\boldsymbol u)) \\ 
\text { s.t. } & \left[\begin{array}{cc}
x & \boldsymbol z^{\mathrm H} \\
\boldsymbol z & \boldsymbol T(\boldsymbol u) 
\end{array}\right] \succeq 0
\end{cases} \tag{5-77}</script><p>由于$\boldsymbol z$是$\boldsymbol T(\boldsymbol u)$范德蒙德分解所得的$r$个原子的线性组合。当找到秩最小的$r$时，也就找到了组成$\boldsymbol z$所需的最少原子数，也就对应$\boldsymbol z$的原子$l_0$范数最小化。 而对于这个转化后的问题，如果$\boldsymbol u$被解出，那么$\boldsymbol T(\boldsymbol u)$也能得到，那么对$\boldsymbol T(\boldsymbol u)$进行范德蒙德分解，也就获得了$\boldsymbol A(\boldsymbol f)$。但是美中不足的是，该目标函数并非凸函数，无法轻易求解。</p>
<p>将原子$l_0$范数进行凸松弛， 得到的就是原子$l_1$范数，简称<strong><font color="red">原子范数</font></strong>。 其定义如下：</p>
<p>对于原子集合$\mathcal A$，若其凸包$\mathrm{conv}(\mathcal A)$相对于原点是一个中心对称的紧集，且包含原点作为内点，这意味着$\mathcal A$中的任一元素$\boldsymbol a \in \mathcal A$不会位于除$\boldsymbol a$以外的其他元素所构成的凸包$ \mathrm{conv}(\mathcal A \backslash \boldsymbol a)$内，即$\mathcal A$中的元素都是$\mathrm{conv}(\mathcal A)$的极值点，$\boldsymbol a \in \mathcal A$当且仅当$-\boldsymbol a \in \mathcal A$。此时由凸包$\mathrm{conv}(\mathcal A)$的尺度函数定义的范数称为原子范数，用$||\boldsymbol z||_{\mathcal A, 1}$或$||\boldsymbol z||_{\mathcal A}$表示(详细内容参考：<a href="https://m.fx361.com/news/2016/0823/16764966.html">如何解决基不匹配问题：从原子范数到无网格压缩感知</a>或者文献<a href="#[61]">[61]</a>)：</p>
<script type="math/tex; mode=display">
\begin{aligned}
||\boldsymbol z||_{\mathcal A, 1} =& \inf \left\{ t>0 \left| \boldsymbol z \in t\mathrm{conv}({\mathcal A})  \right.\right\} \\
= & \inf_{f_k, s_k} \left\{ {\sum_k ∣s_k∣ \left|  \boldsymbol z = \sum_k \boldsymbol a(f_k) s_k , \quad f_k \in \mathbb T \right.} \right\}
\end{aligned} \tag{5-78}</script><p>与原子$l_0$范数的定义进行比较，发现这和将传统的$\ell_0$-范数松弛为$\ell_1$-范数如出一辙。然而如何最小化$||\boldsymbol  z||_{\mathcal A, 1}$看上去也非常困难。此时再度利用范德蒙德分解，有如下精彩的结论。</p>
<p><strong><font color="red">最小化原子范数(Atomic Norm Minimization, ANM)等价于求解如下问题：</font></strong></p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{x, \boldsymbol u} & \dfrac{1}{2}x + \dfrac{1}{2}u_1 \\ 
\text { s.t. } & \left[\begin{array}{cc}
x & \boldsymbol z^{\mathrm H} \\
\boldsymbol z & \boldsymbol T(\boldsymbol u) 
\end{array}\right] \succeq 0
\end{cases} \tag{5-79}</script><blockquote>
<p>注意到，这是一个凸问题。首先目标函数显然是变量的仿射函数，因此为凸(既凸且凹)。限制条件也可以写为变量的仿射函数形式。 因此也满足凸问题的限制条件($f(x) \leq 0$，$f(x)$为凸函数)。($\boldsymbol X \succeq 0$可以等价为$\boldsymbol y^{\mathrm H} \boldsymbol X \boldsymbol y \geq 0, \quad \forall \boldsymbol y$，而对于每个$\boldsymbol y$， 都是关于$\boldsymbol X$的仿射变换）</p>
<p>$\boldsymbol T(\boldsymbol u)$的对角元素都是$u_1$， 那么事实上$u_1$就是$\mathrm{tr}(\boldsymbol T(u))$！而后者又被称为<strong>核函数</strong>， 也是$\mathrm{rank}(\boldsymbol T(u))$的<strong>经典凸松弛</strong>。 这从另一个角度解释了原子范数最小化是原子$l_0$范数最小化的凸松弛。</p>
</blockquote>
<p>至此，压缩感知问题被转化为了一个可以由CVX进行直接求解的凸问题！还剩的最后一块拼图：即为何$\ell_1$-原子范数可以等效为这个凸问题(Ps：其实我已经推导过了，详细请参考相关博客)。</p>
<p>原子范数与原子$l_0$范数类似，频率也被编码在Toeplitz矩阵$\boldsymbol T(\boldsymbol u)$中，因此原子范数可以视为<strong><font color="red">基于协方差矩阵</font></strong>的，但原子范数与原子$l_0$范数有一个区别在于强制$\boldsymbol T(\boldsymbol u)$的低秩性的方法：</p>
<p><img src="https://pic.imgdb.cn/item/64f84119661c6c8e54f70614.jpg" style="zoom:70%"></p>
<p>相关文献研究了无噪声时，ANM的理论性能。在ULA情况下由$\min_{\boldsymbol z} \mathcal{M}(\boldsymbol z)  \quad \text{s.t.} \quad  \boldsymbol z = \boldsymbol y$导出的ANM问题实际允许平凡解$\boldsymbol{z=y}$。但是从式$(5-79)$导出的如下SDP问题的解仍有意义，可用于频率估计：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{x, \boldsymbol u} & \dfrac{1}{2}x + \dfrac{1}{2}u_1 \\ 
\text { s.t. } & \left[\begin{array}{cc}
x & \boldsymbol y^{\mathrm H} \\
\boldsymbol y & \boldsymbol T(\boldsymbol u) 
\end{array}\right] \succeq 0
\end{cases} \tag{5-80}</script><p>令$\mathcal{T}=\left\{f_1, \ldots, f_K\right\}$，定义$\mathcal T$的最小间隔为任意两个元素之间最近的环绕距离：</p>
<script type="math/tex; mode=display">
\Delta \mathcal{T} = \inf_{1 \leq j \neq k \leq K} \min\{|f_j - f_k|, 1-|f_j, f_k|\} \tag{5-81}</script><p>当考虑噪声时，由式$(5-72)$可得相应的SDP问题为：</p>
<script type="math/tex; mode=display">
\begin{cases}
\min\limits_{x, \boldsymbol u, \boldsymbol z} & \dfrac{\lambda}{2}(x + \mu_1) + \dfrac{1}{2}||\boldsymbol z - \boldsymbol y||_2^2 \\ 
\text { s.t. } & \left[\begin{array}{cc}
x & \boldsymbol z^{\mathrm H} \\
\boldsymbol z & \boldsymbol T(\boldsymbol u) 
\end{array}\right] \succeq 0
\end{cases} \tag{5-82}</script><p>其中，正则化参数$\lambda$明显是用来平衡信号稀疏性和保真度的，但如何选择正则化参数却不清晰。在i.i.d高斯噪声假设下，相关文献进行了研究。</p>
<p>(2) 基于Hankel的核范数</p>
<p>另一种$\mathcal{M}(\boldsymbol z)$的选择是基于Hankel的核范数，这种$\mathcal{M}(\boldsymbol z)$度量是基于以下观察提出的：给定式$(5-70)$中的$\boldsymbol z$，构造如下Hankel矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol H(\boldsymbol z) = \left[\begin{array}{cccc}
z_1 & z_2 & \cdots & z_n \\
z_2 & z_3 & \cdots & z_{n+1} \\
\vdots & \vdots & \ddots & \vdots \\
z_m & z_{m+1} & \cdots & z_N
\end{array}\right] \tag{5-83}</script><p>其中，$m+n = N+1$，此时也就意味着：</p>
<script type="math/tex; mode=display">
\boldsymbol H(\boldsymbol z) = \sum_{k=1}^{K} s_k  \left[\begin{array}{c}
1 \\ \mathrm{e}^{\mathrm i 2\pi f_k} \\ \vdots \\ \mathrm{e}^{\mathrm i 2\pi (m-1)f_k}
\end{array}\right]  \left[\begin{array}{c}
1 & \mathrm{e}^{\mathrm i 2\pi f_k} & \cdots & \mathrm{e}^{\mathrm i 2\pi (n-1)f_k}
\end{array}\right] \tag{5-84}</script><p>如果$K &lt; \min(m,n)$，则可以得到$\boldsymbol H(\boldsymbol z)$是一个低秩矩阵：$\mathrm{rank}(\boldsymbol H(\boldsymbol z)) = K$。</p>
<p>因此为了重构$\boldsymbol z$，可以<strong>选择$\mathrm{rank}(\boldsymbol H(\boldsymbol z))$为稀疏度量</strong>，如果可以确定$\boldsymbol z$，那么可以从$\boldsymbol z$中恢复频率。</p>
<p>由于$\mathrm{rank}(\boldsymbol H(\boldsymbol z))$很难解决，寻找$\mathrm{rank}(\boldsymbol H(\boldsymbol z))$的凸松弛，而<strong>核范数</strong>是一个$\mathrm{rank}$常用的凸松弛，此时有：</p>
<script type="math/tex; mode=display">
\mathcal{M}(\boldsymbol z) = ||\boldsymbol H(\boldsymbol z)||_\star \tag{5-85}</script><p>其中，核范数定义式为$||\boldsymbol A||_{\star} = \mathrm{Tr}\sqrt{\boldsymbol A^{\mathrm H}\boldsymbol A}$。将式$(5-71)$和式$(5-72)$中的$\mathcal{M}(\boldsymbol z)$替换为核范数，所导出的优化问题为<strong>增强矩阵补全(EMaC)问题</strong>。</p>
<p>来看一下核范数本身所导出的SDP问题：</p>
<script type="math/tex; mode=display">
\begin{cases}
||\boldsymbol H(\boldsymbol z)||_{\star} = &\min\limits_{\boldsymbol Q_1, \boldsymbol Q_2} & \dfrac{1}{2}\left[\mathrm{Tr}(\boldsymbol Q_1) + \mathrm{Tr}(\boldsymbol Q_1) \right] \\ 
&\text { s.t. } & \left[\begin{array}{cc}
\boldsymbol Q_1 & \boldsymbol H^{\mathrm H}(\boldsymbol z) \\
\boldsymbol H(\boldsymbol z) & \boldsymbol Q_2
\end{array}\right] \succeq 0
\end{cases} \tag{5-86}</script><blockquote>
<p>相关的证明以及矩阵补全问题请参考如下几个链接：<br><a href="https://zhuanlan.zhihu.com/p/159485649">矩阵核范数优化和SDP等价性 - 吃饭吧唧吧唧嘴的文章 - 知乎</a><br><a href="https://www.cnblogs.com/kailugaji/p/14613210.html">涉及矩阵范数的优化问题总结 - 博客园</a><br><a href="https://www.zhihu.com/question/263668140/answer/1147983618">矩阵补全中核范数优化问题如何求解？ - Orbitopes的回答 - 知乎</a><br><a href="https://www.zhihu.com/question/47716840">矩阵补全（matrix completion）的经典算法有哪些？目前比较流行的算法是什么？ - 知乎</a><br><a href="https://www.cnblogs.com/aezero/p/4860174.html">研究领域总结（二）：稀疏——矩阵补全 - 博客园</a></p>
</blockquote>
<p>与原子范数一样，EMaC问题也可以作为SDP，使用现有的优化器求解。</p>
<p>(3) ANM与EMaC的联系与区别</p>
<p>。。。。。。</p>
<p><strong>(四) 协方差拟合：无网格SPICE(GLS)</strong></p>
<p>GLS被引入作为SPICE算法的无网格版本的改进。由于SPICE是基于协方差的，并且数据协方差是感兴趣的DOA参数的高度非线性函数，因此在SPICE中执行网格化以基于<strong>零阶近似</strong>将问题线性化。GLS的关键思想是<strong>通过使用Toeplitz协方差矩阵的Vandermonde分解，使用在新参数向量$\boldsymbol u$中是线性的PSD Toeplitz矩阵$\boldsymbol T(\boldsymbol u)$来重新参数化数据协方差矩阵</strong>。为了推导GLS，我们自然会做出与SPICE相同的假设。</p>
<p>首先考虑ULA的情况。假设噪声是同方差的(注意，与SPICE一样，GLS可以扩展到异方差噪声的情况)。数据协方差矩阵$\boldsymbol R$是Toeplitz矩阵。因此，$\boldsymbol R$可以线性地重新参数化为：</p>
<script type="math/tex; mode=display">
\boldsymbol R = \boldsymbol T(\boldsymbol u), \quad \boldsymbol T(\boldsymbol u) \succeq 0 \tag{5-87}</script><p>在单快拍时，SPICE将最小化以下协方差拟合准则：</p>
<script type="math/tex; mode=display">
\left\|\boldsymbol{R}^{-\frac{1}{2}}\left(\boldsymbol{y} \boldsymbol{y}^{\mathrm{H}}-\boldsymbol{R}\right)\right\|_{\mathrm{F}}^2=\|\boldsymbol{y}\|_2^2 \cdot \boldsymbol{y}^{\mathrm{H}} \boldsymbol{R}^{-1} \boldsymbol{y}+\operatorname{Tr}(\boldsymbol{R})-2\|\boldsymbol{y}\|_2^2 \tag{5-88}</script><p>将式$(5-87)$带入式$(5-88)$，得到GLS的优化问题：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\begin{cases}
\min\limits_{\boldsymbol u} & \|\boldsymbol{y}\|_2^2 \cdot \boldsymbol{y}^{\mathrm{H}} \boldsymbol{T}^{-1}(\boldsymbol u) \boldsymbol{y}+\operatorname{Tr}(\boldsymbol{T}(\boldsymbol u)) \\ 
\text { s.t. } &\boldsymbol T(\boldsymbol u) \succeq 0
\end{cases} \\
& \qquad \qquad \qquad\Updownarrow \\
&\begin{cases}
\min\limits_{x, \boldsymbol u} & \|\boldsymbol{y}\|_2^2 x+Mu_1 \\ 
\text { s.t. } &\boldsymbol T(\boldsymbol u) \succeq 0 \\
& x \geq \boldsymbol{y}^{\mathrm{H}} \boldsymbol{T}^{-1}(\boldsymbol u) \boldsymbol{y}
\end{cases} \\
& \qquad \qquad \qquad\Updownarrow \\
&\begin{cases}
\min\limits_{x, \boldsymbol u} & \|\boldsymbol{y}\|_2^2 x+Mu_1 \\ 
\text { s.t. } & \left[\begin{array}{cc}
x & \boldsymbol y^{\mathrm H} \\
\boldsymbol y & \boldsymbol T( \boldsymbol u)
\end{array}\right] \succeq 0
\end{cases}
\end{aligned} \tag{5-89}</script><p>因此协方差拟合问题被视为可以在多项式时间内求解的SDP问题，问题求解后，就能得到数据协方差估计值$\hat{\boldsymbol R} = \boldsymbol T(\hat{\boldsymbol  u})$，再利用推论(也即式$(5-69)$)，从$\hat{\boldsymbol R}$中估计出参数$(\hat{\boldsymbol f}, \hat{\boldsymbol p}, \sigma)$。</p>
<p>GLS保证产生一个具有最多$N-1$个源的稀疏解。这是频率检索步骤的直接结果(同样见推论)，一般来讲，在存在噪声时，GLS会高估真实源的数目$K$，这是合理的，因为GLS不假设对源数或者噪声方差有任何了解。</p>
<p>相关文献中根据数据协方差估计$\hat{\boldsymbol R}$的特征值提出了一种<strong>自动源数估计法(又称模型阶次选择)</strong>，其基本思想是——较大的特征值对应源，较小的特征值对应噪声。一种称为<strong><font color="blue">SORTE算法</font></strong>可以用来区分两组特征值。</p>
<p><strong>(五) ANM与GLS的关联与区别</strong></p>
<p>。。。。。。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a id="[1]"></a> [1] Brennan L E, Reed L S. Theory of adaptive radar[J]. IEEE transactions on Aerospace and Electronic Systems, 1973 (2): 237-252. </p>
<p><a id="[2]"></a> [2] Reed I S, Mallett J D, Brennan L E. Rapid convergence rate in adaptive arrays[J]. IEEE Transactions on Aerospace and Electronic Systems, 1974 (6): 853-863. </p>
<p><a id="[3]"></a> [3] Melvin W L, Showman G A. An approach to knowledge-aided covariance estimation[J]. IEEE Transactions on Aerospace and Electronic Systems, 2006, 42(3): 1021-1042. </p>
<p><a id="[4]"></a> [4] Melvin W L, Guerci J R. Adaptive detection in dense target environments[C]//Proceedings of the 2001 IEEE Radar Conference (Cat. No. 01CH37200). IEEE, 2001: 187-192. </p>
<p><a id="[5]"></a> [5] Guerci J R, Baranoski E J. Knowledge-aided adaptive radar at DARPA: An overview[J]. IEEE Signal Processing Magazine, 2006, 23(1): 41-50. </p>
<p><a id="[6]"></a> [6] Brown R D, Wicks M C, Zhang Y, et al. A space-time adaptive processing approach for improved performance and affordability[C]//Proceedings of the 1996 IEEE National Radar Conference. IEEE, 1996: 321-326. </p>
<p><a id="[7]"></a> [7] Goldstein J S, Reed I S. Reduced-rank adaptive filtering[J]. IEEE Transactions on Signal Processing, 1997, 45(2): 492-496. </p>
<p><a id="[8]"></a> [8] Pillai S U, Lim Y L, Guerci J R. Generalized forward/backward subaperture smoothing techniques for sample starved STAP[J]. IEEE Transactions on Signal Processing, 2000, 48(12): 3569-3574. </p>
<p><a id="[9]"></a> [9] Sarkar T K, Wang H, Park S, et al. A deterministic least-squares approach to space-time adaptive processing (STAP)[J]. IEEE Transactions on Antennas and Propagation, 2001, 49(1): 91-103. </p>
<p><a id="[10]"></a> [10] Parker P, Swindlehurst A. Space-time autoregressive filtering for matched subspace STAP[J]. IEEE Transactions on Aerospace and Electronic Systems, 2003, 39(2): 510-520. </p>
<p><a id="[11]"></a> [11] Melvin W L, Showman G A. An approach to knowledge-aided covariance estimation[J]. IEEE Transactions on Aerospace and Electronic Systems, 2006, 42(3): 1021-1042. </p>
<p><a id="[12]"></a> [12] 冯建婷. 宽带机载相控阵雷达空时自适应处理方法研究[D]. 西安电子科技大学, 2021.</p>
<p><a id="[13]"></a> [13] 孟庆统. 机载DDMA MIMO雷达杂波建模与杂波抑制[D].西安电子科技大学,2021.</p>
<p><a id="[14]"></a> [14] Ward J .Space-time adaptive processing for airborne radar[C]//Space-Time Adaptive Processing (Ref. No. 1998/241), IEE Colloquium on.1998.</p>
<p><a id="[15]"></a> [15] 秦兆锐. 对空时二维处理的干扰技术研究[D]. 陕西:西安电子科技大学,2020.</p>
<p><a id="[16]"></a> [16] 闵丛丛. 基于学习的空时自适应处理方法研究[D]. 四川:电子科技大学,2017.</p>
<p><a id="[17]"></a> [17] Yang Z, Li X, Wang H, et al. On clutter sparsity analysis in space–time adaptive processing airborne radar[J]. IEEE Geoscience and Remote Sensing Letters, 2013, 10(5): 1214-1218. </p>
<p><a id="[18]"></a> [18] Maria S, Fuchs J J. Application of the global matched filter to STAP data an efficient algorithmic approach[C]//2006 IEEE International Conference on Acoustics Speech and Signal Processing Proceedings. IEEE, 2006, 4: IV-IV. </p>
<p><a id="[19]"></a> [19] Sun K, Zhang H, Li G, et al. A novel STAP algorithm in heterogeneous [A]. IEEE International Conference on Geoscience ＆ Remote Sensing Symposium [C]. Cape Town: IEEE, 2009. 336－339. </p>
<p><a id="[20]"></a> [20] Li J, Zhu X, Stoica P, et al. High resolution angle-Doppler imaging for MTI radar[J]. IEEE Transactions on Aerospace and Electronic Systems, 2010, 46(3): 1544-1556. </p>
<p><a id="[21]"></a> [21] Selesnick I W, Pillai S U, Li K Y, et al. Angle-Doppler processing using sparse regularization[C]//2010 IEEE International Conference on Acoustics, Speech and Signal Processing. IEEE, 2010: 2750-2753. </p>
<p><a id="[22]"></a> [22] Parker J T, Potter L C. A Bayesian perspective on sparse regularization for STAP post-processing[C]//2010 IEEE Radar Conference. IEEE, 2010: 1471-1475. </p>
<p><a id="[23]"></a> [23] Sun K, Meng H, Wang Y, et al. Direct data domain STAP using sparse representation of clutter spectrum[J]. Signal Processing, 2011, 91(9): 2222-2236. </p>
<p><a id="[24]"></a> [24] Yang Z, de Lamare R C, Li X. $ L_1 $-regularized STAP algorithms with a generalized sidelobe canceler architecture for airborne radar[J]. IEEE Transactions on Signal Processing, 2011, 60(2): 674-686. </p>
<p><a id="[25]"></a> [25] Ma Z, Liu Y, Meng H, et al. Jointly sparse recovery of multiple snapshots in STAP[C]//2013 IEEE Radar Conference (RadarCon13). IEEE, 2013: 1-4. </p>
<p><a id="[26]"></a> [26] Sen S. OFDM radar-space-time adaptive processing by exploiting spatio-temporal sparsity [J]. IEEE Transactions on Signal Processing, 2013, 61(1): 118 - 130. </p>
<p><a id="[27]"></a> [27] Yang Z, Li X, Wang H, et al. On clutter sparsity analysis in space–time adaptive processing airborne radar[J]. IEEE Geoscience and Remote Sensing Letters, 2013, 10(5): 1214-1218. </p>
<p><a id="[28]"></a> [28] Ma Z, Liu Y, Meng H, et al. Sparse recovery‐based space‐time adaptive processing with array error self‐calibration[J]. Electronics letters, 2014, 50(13): 952-954. </p>
<p><a id="[29]"></a> [29] Feng W, Zhang Y, He X, et al. Cascaded clutter and jamming suppression method using sparse representation[J]. Electronics Letters, 2015, 51(19): 1524-1526. </p>
<p><a id="[30]"></a> [30] Wang Z, Wang Y, Duan K, et al. Subspace-augmented clutter suppression technique for STAP radar[J]. IEEE Geoscience and Remote Sensing Letters, 2016, 13(3): 462-466. </p>
<p><a id="[31]"></a> [31] Yang X, Sun Y, Zeng T, et al. Fast STAP method based on PAST with sparse constraint for airborne phased array radar[J]. IEEE Transactions on Signal Processing, 2016, 64(17): 4550-4561. </p>
<p><a id="[32]"></a> [32] Yang Z, Li X, Wang H, et al. Knowledge‐aided STAP with sparse‐recovery by exploiting spatio‐temporal sparsity[J]. IET Signal Processing, 2016, 10(2): 150-161. </p>
<p><a id="[33]"></a> [33] Guo Y, Liao G, Feng W. Sparse representation based algorithm for airborne radar in beam-space post-Doppler reduced-dimension space-time adaptive processing[J]. IEEE Access, 2017, 5: 5896-5903. </p>
<p><a id="[34]"></a> [34] Duan K, Wang Z, Xie W, et al. Sparsity‐based STAP algorithm with multiple measurement vectors via sparse Bayesian learning strategy for airborne radar[J]. IET Signal Processing, 2017, 11(5): 544-553. </p>
<p><a id="[35]"></a> [35] Wang Z, Xie W, Duan K, et al. Clutter suppression algorithm based on fast converging sparse Bayesian learning for airborne radar[J]. Signal Processing, 2017, 130: 159-168. </p>
<p><a id="[36]"></a> [36] Sun Y, Yang X, Long T, et al. Robust sparse Bayesian learning STAP method for discrete interference suppression in nonhomogeneous clutter[C]//2017 IEEE Radar Conference (RadarConf). IEEE, 2017: 1003-1008. </p>
<p><a id="[37]"></a> [37] Zetao W, Yongliang W, Fei G, et al. Clutter nulling space‐time adaptive processing algorithm based on sparse representation for airborne radar[J]. IET Radar, Sonar &amp; Navigation, 2017, 11(1): 177-184. </p>
<p><a id="[38]"></a> [38] Feng W, Guo Y, Zhang Y, et al. Airborne radar space time adaptive processing based on atomic norm minimization[J]. Signal Processing, 2018, 148: 31-40. </p>
<p><a id="[39]"></a> [39] Duan K, Liu W, Duan G, et al. Off‐grid effects mitigation exploiting knowledge of the clutter ridge for sparse recovery STAP[J]. IET Radar, Sonar &amp; Navigation, 2018, 12(5): 557-564. </p>
<p><a id="[40]"></a> [40] Cotter S F, Rao B D, Engan K, et al. Sparse solutions to linear inverse problems with multiple measurement vectors[J]. IEEE Transactions on signal processing, 2005, 53(7): 2477-2488. </p>
<p><a id="[41]"></a> [41] Tropp J A, Gilbert A C, Strauss M J. Algorithms for simultaneous sparse approximation. Part I: Greedy pursuit[J]. Signal processing, 2006, 86(3): 572-588. </p>
<p><a id="[42]"></a> [42] Tropp J A. Algorithms for simultaneous sparse approximation. Part II: Convex relaxation[J]. Signal Processing, 2006, 86(3): 589-602. </p>
<p><a id="[43]"></a> [43] Chen J, Huo X. Theoretical results on sparse representations of multiple-measurement vectors[J]. IEEE Transactions on Signal processing, 2006, 54(12): 4634-4643. </p>
<p><a id="[44]"></a> [44] Wipf D P, Rao B D. An empirical Bayesian strategy for solving the simultaneous sparse approximation problem[J]. IEEE Transactions on Signal Processing, 2007, 55(7): 3704-3716. </p>
<p><a id="[45]"></a> [45] Tsao T, Himed B, Michels J H. Effects of interference rank estimation on the detection performance of rank reduced STAP algorithms[C]//Proceedings of the 1998 IEEE Radar Conference, RADARCON’98. Challenges in Radar Systems and Solutions (Cat. No. 98CH36197). IEEE, 1998: 147-152. </p>
<p><a id="[46]"></a> [46] Goodman N A, Stiles J M. On clutter rank observed by arbitrary arrays[J]. IEEE Transactions on Signal processing, 2006, 55(1): 178-186. </p>
<p><a id="[47]"></a> [47] Tipping M E. Sparse Bayesian learning and the relevance vector machine[J]. Journal of machine learning research, 2001, 1(Jun): 211-244. </p>
<p><a id="[48]"></a> [48] Wipf D P, Rao B D. Sparse Bayesian learning for basis selection[J]. IEEE Transactions on Signal processing, 2004, 52(8): 2153-2164. </p>
<p><a id="[49]"></a> [49] Wang Y L, Peng Y N, Bao Z. Space–time adaptive processing for airborne radar with various array orientations[J]. IEE Proceedings-Radar, Sonar and Navigation, 1997, 144(6): 330-340. </p>
<p><a id="[50]"></a> [50] Meng X, Wang T, Wu J, et al. Short-range clutter suppression for airborne radar by utilizing prefiltering in elevation[J]. IEEE Geoscience and Remote Sensing Letters, 2009, 6(2): 268-272. </p>
<p><a id="[51]"></a> [51] 段克清, 谢文冲, 陈辉, 等. 基于俯仰维信息的机载雷达非均匀杂波抑制方法[J]. 电子学报, 2011, 39 (3): 585－590. </p>
<p><a id="[52]"></a> [52] Wu J, Wang T, Meng X, et al. Clutter suppression for airborne non-sidelooking radar using ERCB-STAP algorithm[J]. IET radar, sonar &amp; navigation, 2010, 4(4): 497-506. </p>
<p><a id="[53]"></a> [53] Yang Z, Xie L. On gridless sparse methods for line spectral estimation from complete and incomplete data[J]. IEEE Transactions on Signal Processing, 2015, 63(12): 3139-3153. </p>
<p><a id="[54]"></a> [54] Candès E J, Fernandez‐Granda C. Towards a mathematical theory of super‐resolution[J]. Communications on pure and applied Mathematics, 2014, 67(6): 906-956. </p>
<p><a id="[55]"></a> [55] Tang G, Bhaskar B N, Shah P, et al. Compressed sensing off the grid[J]. IEEE transactions on information theory, 2013, 59(11): 7465-7490. </p>
<p><a id="[56]"></a> [56] Sun K, Liu Y, Meng H, et al. Adaptive sparse representation for source localization with gain/phase errors[J]. Sensors, 2011, 11: 4780-4793. </p>
<p><a id="[57]"></a> [57] Liu A, Sun H, Teh K C, et al. Robust space-time adaptive processing for nonhomogeneous clutter in the presence of model errors[J]. IEEE Transactions on Aerospace and Electronic Systems, 2016, 52(1): 155-168. </p>
<p><a id="[58]"></a> [58] Zhaocheng Y, de Lamare R C, Liu W. Sparsity-based STAP using alternating direction method with gain/phase errors[J]. IEEE Transactions on Aerospace and Electronic Systems, 2017, 53(6): 2756-2768. </p>
<p><a id="[59]"></a> [59] Yang Z, Li J, Stoica P, et al. Sparse methods for direction-of-arrival estimation[M]//Academic Press Library in Signal Processing, Volume 7. Academic Press, 2018: 509-581. </p>
<p><a id="[60]"></a> [60] C. Austin, J. Ash, R. Moses, Dynamic dictionary algorithms for model order and parameter estimation, IEEE Transactions on Signal Processing 61 (20) (2013) 5117–5130.</p>
<p><a id="[61]"></a> [61] 李慧启. 基于无网格压缩感知的跳频信号参数估计研究[D].战略支援部队信息工程大学,2019.</p>
<p><a id="[62]"></a> [62] Ottersten B, Stoica P, Roy R. Covariance matching estimation techniques for array signal processing applications[J]. Digital Signal Processing, 1998, 8(3): 185-210. </p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>信号处理与雷达</category>
        <category>信号与系统</category>
      </categories>
      <tags>
        <tag>雷达信号处理</tag>
        <tag>STAP</tag>
      </tags>
  </entry>
  <entry>
    <title>王老师科研资料</title>
    <url>/2022/05/06/Teacher-Wang-s-scientific-research-materials/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6aa9e4ac22c1eaae9b7388833a580db2d2bb67c18e67204068e5cf4f3656d7d9">270cb3bbed971930ec4ebcba9f8cc138f5d4800f50eb8f4502a546dcfd41431b30150ec62430037366c2fc37d468751db9ddc8492ae22722a5ccd659f5069437da78b40e3f0e241b4fed30054962dee21d874e0ea5facdf784b9a03317ef891736dada1f32e05cbef322ee36d64391b83e92de6bffe73316c18c5edef89cb2fb9b3b60f3e7ba7742d19fb50b2d0bd86fdcbc8283f0ccba3fdacb1848819261b959484b0163e87af046ee64e9186f3a3b865dea10bb44a0906251cca44c0f9261e459ee3bcd239b7e03be7690050d8fc547d7cf3370335347cf876bcf547509390dd76f765eac3cb2566c287893ee676d440bd3e654a2a844cdf665d774d29723a1a1b18c138e746e9b9a45a520e14b19f470ffde70ee5835c10b31e7985c8b6324238ae8a428640fb213b7a74e171c90107a3434a4464769d9ae86be16855c93dae6f6f6e8fa5867d9a11c5829dc74eb35b11f5e8930058b59a4a54301b9a995178eb32acc9c90620a15c90e6a4fbdc2e104da6d5458a30627f6954c9d0e0cfdd2eb1291b264dec3a46881760fbccb0f03e20eeb452bf4500357ac32d1e0e4038ef74aa7a015c4ab2ad0f5be1927b8a1d1e4c785398de41282ea7c82867dc97dd4ba20742efebe141b20f4c491c6aa6c7389c23696a64fc0d4c467831c705a8dd5e78cb8b9d7847c754b26592f47657c71e9713532f545e19ba116f369dc386894bc8ce3e15289695d249d211dcbadce6a6a664da08cc72a0e696d0bd8a7e6e5089a35f9daf78abe1063473ecbaea3911072b845cb13b72d9534e5fa8da2e9536ef4c633381306f73bf06bdbe4ec977dd55f2aef685cbfef95db5fda38b79c5fe787935c01d6adbb875b35d44c2e763677f6d62be2d22ba15fa59dfc7c2738a209ca7206971b53b33d5b71576e34280fa3d343be8ee41a7280178763c58c3b8618e04924a2b65891cedffb5dcc88982b6c942efbb9c863e9a08fd51446ba3c030bf7f7a70e539fb1198d6d54df57b11d8bad55f0f55d62243b61229e6e94ed64e71fc1c6fcb6901946d3d805b8214bca3f70d26a268a32bb717be5e1e58d270949a5761f350ad4eba3ef82918922c0c445801a68193b55949e440b38f45cd1907997b1a2c36a6229ba46f26097ae966f817fedf31a20ca3fa1e98457e635defd07c2a0cbd3d70b0772c84cff9963b9ff61bf435f1656911f4ffe2d63faa23c1b55228f978af28bf3e27e1a705b724a90a235a3912687be0085a0facc969c645ab07d70e58347c802048233102afc50a03f7f63a3680a66bb9d00d18bb739dc3de232f710f1df17b448aa990bf02bc811ca2d82b1034d2acbf6c7ce8c4c058b4af09ea2daaaee7572255c510dbd41bbb116586b9c9ba663dacc70836dad23f8ae00c82d2f421a5e47d87f90101d9c445877358bfe3068925547a7366bd51c323e8faf1318d1b668c04204ccc82a94a04b38362fab8edb1805e103930e0ab2353e73e41a2cc5e363b97bdd0651bde0625946e6b9c0c653722bd90b20094442337b56d040e2c7c581bc7e78e8f3f4135f113e06c6fbb7c06a0aef2b0e2be28f2f9831556ef453b8a9d1708a17e104723965ef60908de9db6650a73367e955d04bab1f863f8f5d7be33bde01e733b1161abc59212fb5bb47bcc63697f3ce4c55d41cc22a4453620b441cf709b41c7da3e7848b74038771907ac5e014d4a183d00a85477b923390dabb1a486cea7f56d099fec52a2e3f033a39fa87bd65a01b8135baa19f6cfc622a64bacd48a2dad8fa735e45892d6047834423ab524e7745ca997bad72690517b91c3d4d893204e5106ed7b01fc5435ec165a06b4dbdca3132a471be2a5cd51e43070ea9f435f326d0374e1c11cc4e581fe5ad44f5dda2b9a72a11d7723c8af0ab89e3b84d45d78baed97e3d8d3dfed12354343e749c024998eb997b77f6a81df94189b6f730c48ddfc5c7ee5978fbb6493f29dbd1b0dd3da8b6a0485ce46a844d076cae5d15308818a1a7a9bce3b4aa1e11a3f134bff22b54226fdf8af076366258bffa9384e31a43f520719b42618f29aabbe920f4e7794a6d17e3ec436acd21ca481898a11586b4f9849d8ded6dde3d2664ff676b890342ca2ba21c4d1161ec83a9370383c1d214a65a053fc52c656d9976f24f0a1532ab53f651438ce1a4afc3c55822a487c9f3059a2f944fbf0d070dac5ccea0c88e252b414f6679fd8e0e5431716e78e4774ab6c6e489990bb90535c3d0917bf9152958fb36b30cabd2d6108b77b723d88ac293ec1bf38ce6d3a8db8c9a3e1a75b9a70112a8dece41f5cef0ef770f52ac60e3776eda7cb7cc6fff50c47abbdc3b816c9ff3f26f0870b08b0fa8fafcf270ac684b150c7dedb8c7bff9b8179b0c8c82f2b1468c925ddead06db76f96aaf9b0afaa23778455a2148ef9b77f8c40d07f9583c8b5248b97139ee86258567d9dabc75e0e5555d048ad2f76bed46046f3d36dd35d6feb3106dafd02d4a10828f7173ceb44e30d0828c8a83967b7ae6719a802276b9987181b4751cad63cf79db0c7d74e81349e2eb57b9c4bd0501fd7875bf21c91dab6e561c7ad4f2efd686cdb0cb1ca2dffc4dde6b10fa1974466f1dcbf649e2f84d4fea926ad29504aecd304cadf49fba249f1bbc0e725aa60ed1ce55d155e426f85c560005dd96b1f24350980613d825a72482bde1e9a29c95fb35a7c2bd206fb40e4d70d77db3ad1ba803edb2db707ddd9739e1ce1888881b7ebf00e4ebfd69a5561441f585075743b50ef9700fbfce7f83964b206c57cf3499f2aa3356df312ca0ba6ada2313e131e238e50d5fb6c9b9f002e0505f2247e9ef9cd999c034e616daa0e6d9b8c15cec0848bea053eca323f3711c422c65df25b1f3e749e7dfaafd53e2cc23e480dba8849f2b61816c7ae829e56409d68743ddee73db39a5fd56002b15e324694040dbe4d0db4e32437c486d0f8224f7563044bc5dc0a8c0126a4342a9eb21a77c0973118584ec1bc230f4bd8dfef9deaa8d172f0ec3f234ce3fcda94e46d2e670a064dc0093ccc999fdedae23a348339624a3c127ae472a0ed715a0a19ed3aa345abd2cae7d0afaa6bc8be946221d25e490a15b399024b3c97dd20505b2cd62f8a931077600268d166600e0706dda79831a8a732e4f46b875dc6e7c1c9f83711f5569d87623d187517f08cbe74740e4e8df07c011f4ac4ac06353b6e0ee834abdd161ae7e0db3097d9240d3b22d6bd489cdf25bbcbab94d4ae9ebed682ff551d89cee3bb03b35c396ea7b42be6956d24b9ceb43988c564505c63f3ed106660987009ae32728207307a4fc9f5436cd35385dd483b66426bac96e679db607ae62bc70678d990cef20f13b76a399955fcce2089ac1521ce570eae48ad38c443090c7c9d82d68d8cb531e9eb024988c92515e6193798b7cf5c007bd6c6e4247316efa1309ea173aebc79f2603db27ecdd173f61012f400bccd5ad888012329e2003f24af2bec164871ead7ecf2cbf834866dc3fffbfc316608ee574b8a5df7da47794f4e25f85a3d824ee57006c6b26ece4f7869e0fa216177b5965477544654d15943382c90246925fec54f6b1c7717797eeabf648d04aecaa1f6f98cdde00e61c2ee1b56f8a2c1066a3fd991b603b6a087591182f2b5c9e99322e6c326ce830220c9f3a731c00af0b796de5d4c8f2a9f422c499ce987aff0f28205e4e08d400c1a704decf03fd4631b93c405992c4c872d84c69f4eb296bbf60a544315ecef681651387db76da93eea1d58902d2d30612badaf0559925b4352b550369d27b52e5390e49ee7c23c68eedd56d581f779bfaaa40a846ee9cf9d26b4d6e7c42bde87c31795e4e6e2678f17fa9c9d68a10064c21da3309ae4dcc6708ea989a1a354c11a4381f3e7e9bf3790f4049984ee4ef63eb6f2de5c417d93c9c2705273fd514c606d5f5be00d531fb0e95c4aaf5ba4cae848af3bdfa05ed6046b28505e84bdd81fba3a237102b7a55db9be5e0d920088588d4b8ec15aae6eb752e31d3088a3ae51da4703fed7c9ad4459a9d15d2c27f391f9f1d52d198cc0a8fa516f38c4bf58a3dbdadfad8657a02335595c783636a9ea564bebd338343643d770ce6ab7ef021ba4b823c352272beda11aafaaf64c988ea9192f7e42e88c303cc49e0af9691f212063db3a1dd88bd4cec55244d884678acbe717ad230eeb39cd6fbd7988e7adab6ff8b80a1893650f2598fdbf894e86cc45d8d07f02c502d46c265cf402527e5bd57a708bf9f22018e99b67b8ca680d762ef49a4fb495e3ab8bd547d09f60095644a9fb5af3b926d8b0ba6ffe3191721bbd8b183c6aea71f1ae80fd1027073578c40f0df303d4a0fc5fd9b592bebc97a66ecf62baf898d8c88d86bc7a09c4a8522d1a3b261c26c1c46e243596ab7c48c3869b27239997089b0db37062a4540d3f927c9fb22a824b1fe4ae01b99129c9e2ddddbd5594899d1f17c271615c0741df0ae91bc8255837a69fbeb9cc59605caf32f1870f7d32053a52b4343f59d253d6ad48adf39bbd4393b4273db7179b7797318ae159278af2feb3e88528aeaca1fa759f79e4732a8ae726a795c32a5b530eb58cbf9ff5162ce7638d1ca106df6189c430623dfb090f271b5ad1b435c0af4c7bd857dc648943db6c070f75e40937450006148fe4978e5c1c9cccae2f714127d50526ca8bca55d31e77a42f1881777a14d316125ff80ae52fe4dc0d96916ffa6fe44e22f2c4af9b7c4c98d557430e8d0d4c781b7cb40b7d93c82210a8721adb7b7bd99b64d761d4e16c1a4e2c4d23a79a5599098158a7f9406e584a08afe490acb1c132c9c6dcfabfcb14b884e0ec484481a4c450b2aa5e342463c510530cf0385db011c112c9481c419358db68c8e3f646139bdffe221c41415b11cc039e2053f60db6c614e2e18c7de10238777e7b45c4d8dd9c779e5b4445b698edf48a872cb03acfadf952a3637020d443a4578bf9b8a4af9dc5f7c5380936bb1c0996d866c5d72bf95cd73f2fe3f4b9730f85c4fd56467b78fdc22c8848e568937b36524333459e80d18f4ec233741e700817dc9f1d00a3ab539e1376417ce2c000db088844292a34a85c4ec064b585f68db0191ee11a2501fb0a7226c9f92a9bf3d966cb0157236af1594af76e59c319c5e1856b2d94765becc01ac458fe250c11af89083f03cb7e50828686adba5ef46e40639351d9b75222e63316f7985c1400a2c944fddb1b92099da5934d6bc1c01eda6fb86667260e705da403c3bdd41fb8efb83225286dfa38f9732e9afb9308febdb184be2623f1b31c9e87681b086149c24a050d3bd1eed36db80f470dd493eb267d08b8ea42f70ba9292a84fa8d46c03f0e3cf4052febca571fb1b8dcdf43ca488a78fac34b30533dcb3006e5aa6f62151b33b170bfd8fa28470899bbe42590c09f5ff93b4c53040fff85626ccca8ef97fa2ec619d4050487619129d286ea948fcd56b5ac14eb90733c4845bc28b349d8b47507a95703b34178a9b77de300d5dd61f66ce55e120c18d905468deaeac51e37f49d6e8efba7f41aef7ec6e23ff4123c1f7494c71b8992aabbf4df1cb527553280d829330d02207b7c41bb27d7f64521aa4b8a39f805da91326df9c0f2ba2eb72304b5b41fb09664fdff0d48279d15594ed57f843dfdd8cdd22f1d4fe75bc59436f8fe47f11133357e9ddfe6731292ac32716e755390f2f7f03e23dbe3afcb3465b20fceacf1930396629a398e7c51bff8fcf9be60ed67f8ee209b4850947729cfeb728a1c194b4bc6cc8a97036218d18f7c67718e9fe8e5d6b9a1cab5f878ed1fe232b0ba7b59d30c6ce8fe625a60c2c9debea1eead8fbcf93c10916583577dc2dbfe6fe7b04fd8c88352328fd4b0d64a60542e8cd81182b55fb4ae8b8f543ef287c628add614545df04ff2ec4c68f2a7ed5f6b4babf05aa9899568d6d1c9f42350ecb43e496a297279f3fdc62371906355db8ee6305bcc20fd1957466524612e96f26048eb5148d10b9dbd64265bebc676196dea817efcd5d2df133ec91e761b7ecc79625498ebd8a9fa3bcc257c39378fbcaec2f065460a0c3436ab6a264247439e66f575c471e009c91bb63db95aeb182dd9ec4dbe6e737720d3d7692dcfe634d3f192a7a88e1888b43190f874e13d08ca9b60173e01cb2e38bfd8a544dfdcbfe9ad0c082e33e692647042ccd745a6bfd1779124ca96f2c5d298d4241c344e71893436887669e64a776882d6088bc3e7ab64cb30e19ed50ef60522c86285e7328fef08d8fba249b6fc8f5addc56bdc7f01adedba007c56ccded61e3c641b56f59ff29aed6f60ad817423595dc3b2716b1bd96810f9d13d15c4dc3e14616fc8d7deef9f3b14ec27be55160e2fe015638d9424aa734ee76e2876240cb0a0b62c4b1a2b1ff997210a5549013352e236c0189cc07792ab9b88b79b4bd48c03b17a3f1be62152ec9d18bb28d7f86ee029cd1c53989bb6436427428a993e2366d4ebe39a1e82f17f4a9b8fa47c306606124d90d3f3e4d2318fec8644515a539b438cd337c8f9b01e05d095cd0f25ad33900064f7a3a9b45c88ae616dd008fd2244a717eb5942d2573b2352c581e9251b2534690431f81ea3e16bf92c15e41738ab2a8e16a27b7a299554e1fe9ab5a3446f94ef9a78d177de4dad0997f3266b661b831226f787a249455fe3d2c813b6f7bcf073a1bbf589eae38b48a7cd93f3c8f432b0e7d0f5796c522a8bab99d24997774322eafc9042639083141fae027de964ac8096c5d4dbcad6d0ed8806175c08da2dd8a3c3c88350a63629a6afb1aa65c332bb1df55937542e6c593465a8fec6fc5462a685b5cbe2e1ffd9821c4b1cd8d45d513babfeaadf45afa708eba4d40a6a11080d2c2911e82aa316fca01f8e51e9c8f1e099f42ea76a7f6acb5cc32af5bbb034848e416b42be914885ab5bca956abd5c058e7168455a534d3149b8bccf995508f1cd80413d06c7effc0999f967032c187078dfe1cc81f9650a66e02ce7eb260545d54ebeed815dc1639dfeb9992c9a7b313514aa5d2c3d964fb3413a7646a5447c142d9430271d94e84bd43ba642f17e2e83029a84a679a59a92c3b718acc21f792a920d44fe16d7c3d1bf7d6a36d4824974d027a44cd80f800bc07c16638c729cda7e988d2297ed4abb55cb396fa1ef0fbc5ab6906b1d408ba998f8bc1d01f8af74f690d6f27b78110fc3559b9a4ccce1c6fc61603101efea998c6e43c21a447489d8047f98b638c727ecfc11d5ffe7e993282df8d732c515ec361ee6172863704f8664e96c38946131f60287d56dc121a721e9b4e8f5b283ead2bc2ed7273dc21b2b1bdcd6f150c9c8e747172a1ebf681a4197c6f535f7a1220dc2b0da93dfe42163357fb0784da65f558e4860dd875691fddd7454106d79a460a047056e2fd18bb1477f3355e1c44ad1979d116bc75a6e4ff153513d00cfb2e2f6b30ebc969f7be2a337937177d0075d250d3f1007045d18ef0a5e00bf5272780dc52aa8c8cdc059f13c734e0093afe3efb9ea3e34b3a222eb834992fc284e13b01614ae2924e31d38b89bf1cc28526afec68ae4348652c058116e1b50c8708665ddf705d61f87d5970c90b9a2fb846dfb1ac00e7a9bd01d1512bbd55b614d1bd50dc2ed874db443642a4d2104d45f2e6ef3da04432747bacb519190bf963e11d213e9deaff2947411f6eb6d3bc10f4d3f8e5c788a6b763e8e17b9efc168115d114a10a92a9858b3e18bd02227af6a34d2bc7c0441e67093e28c473fba6bd5c56b448987c10def0f43953626110d1854879babc3750545817d3ddd44303d1267488b3afba786d651a37f126029116c357c98b0e16a62d7505aa691eb6170c7afa73e71ef7f0b5ee895aff9f5fa9f675f7121e9e7192785ceca232af07503ba44d05733815750c94571b33ffd64d30fc1efbc8064362c8c469486efa3d36217fcc63607b76593c2ff28747280cc085a73af5a35221a038f1a25781b63796288913226c918691b8c439d319ebdec83d533b50341d5bdaf3c281b8bd8bd5d192dbc7a8da201b15ff4d3b2a2f59e69e4c081d19885dfcb5112ea7bef438b572d7f1d25f1afb2d7d9963bb1ab7dd46b1e1b7ee8935b51dc9ec6a8acd4338bc41af2dbbf0cf2c6553906e2544a6a449561d5bbd1f46398fbf5b27415306ae654f0df89e29157327cae4939349c75b4c163f217b28af41a3c4ed3f356d2d90207350df492e25f682f30cb217f676feeb77a8cba26d7c11644724fac06da4c2c5b6a7b61fd170e6fbae25e670307331e8af56e03007f31b8fab19500318f51c90a51a0be7a595b82765dfda3af67612f004aed715f4f092e1364f31c70d49fc53c22adfb1b9a143bc2b245401c9ee4fe8920fb7f80b1dfdaf59607043ea51755f96ed569ec548c59441223f0e119d21fa5e807feec7a6c087eeb2b1c0698171903d055895c69ac0989608593e9d910a36a811e1c4b26004bd4caf72d9f20cffc73343a915b8a2420c715ab37d5ea0f710c3aee13c900b20cf95b8c7c18130b82ff828e146890ab28559614aed12408f25826be57f86372ecca047db901f648d74c19fe419642a96168ff678f3e400461b565cd3fa5c678e6e48f5a73418a0579dbc86a905a8462737d67844fc93343cac7fe67004199e838689fba478bef5a880d010105dfb7202c38de4764f8574e1d973d1b7f89545769a9a991c1f0a2478fa64490cd23ff1937cde6a9434c38fdb7cc6b455af886f3604d2a3cf0b15457dabfad9b05a76dc8c5c7b23ae148c4c663d5d7045bbf8b55f16e07498360a83bb640e3099f41e110a66e2df9ac2189fe2a9a5b482aa16cf3d47e804d18111022ba818ff836637475ecdf2af109a422a035e1ac21727abf3a1bf22ff9f2c0e1b46d27184b0d041d1113c4749554f494a9d479ce6a71eb7028f724b3466e202009df49f1a50de535cedfe635dd1b8f560cf13db6f381458b78e2625fdabb4b5aa383adfef5914da8ad79376e51c49cd84975b305ef39bb50355a365b85c8f5107ffdb3491642a77b1b17e5a185ded8353adc97420b084f82869408e5f240c1b16aaba051a61cb5ca59317e3177a748a6c81b1f3e2cc1e70c1f30f97a526dd3c9db2b8ffa5b3970b612ed9629ce11fbfbadfac64d7765ec5cd81f7a920ee42bea1d0d02cd3295d6bd72f0b3e6fa1b1535643cc4cf6d9cefaf0cc3ff9a35b7e481001dd68a4d16090369ea990246acd27aab113518f00b31df33ef51565c2021f47d5851e2063c1fca1dabf867ff270b967e785d894bfa03a5a4c97019932a684c82ee130374e19dcbad5eb4ef932fd29a6900d694eec4a7d99150664b1102f025a386565846accbcb33d2043e976b8912689ed3d5c0fea2a6706a1b4048a9db0c6ba48ad91510d2362a717e2115f8d2240f47cb796dcd429e0af912d7c84d27d1aaa1bbdb406d36050cd8844118ea43c2326d5eeb2bf5af07e87df7d3ce22991f24de3695e9a5a6d8379e1bbb988b896d08b4b3409ad15b0eda00b9e7b375e0f388d58cf790fe672d782daf0fc3b63e8176437bc197b32e4b77a59c32ed6365574fa849eb08d89c0c5c6db594ceb2d89405310aab14385330a3ed285b9eaa17e65b70fa6e28fae5cbc273569065d90ae2bef306f10fef9bed8a8256a6561394e08c51135c6f3d8568be717d9cb6047024835326378e0f272062310965a189c91f939cce62dd7038dd83eb9d48bc7d8b174eaa771483d87b8535c2959042acb1d05c38b8219c53c58a533103685c79c4f3524f143a061c2961cb5bab31a7a04e85651f5a283a1e2112f6fca0a7c4e0d45a28982c638c7026b5885f7a4886ae5b1c07776d4542f2808ff05b1be4d78193de16c056a728f984632bfc4b124fc0685264ebd3d849a9e30e350b2d09f8048c3fdcc58691d2f255e253fba2ae23863f6d243130940c6e496548b38a424208525695c2008a4293a14131e993fd7ad7c2eaadbdb0717fdc99193640bbee45dbe3259c767e6bfe8e0aff2f54a5d868485fd340ca565ff1b82e9b6a7429300a1f061d67de953256ca0f2d45c16feca2f951e5854a2458ae8364d52d9014c08a5b25aaf9fae98285a515cb2de4635617517d999e146d101dc25254208a468c9a947c1bedc82bbc1384cdaf7ce5997b879c18044b3faabb99f34de9aeef3f4b63affa401def841936bdc0fced1dc898a35aebfb4d56108fb0525019da009e1e9323fdef1cb653f169f039697dae50fe085b7e0256c815cfd4e293acc26aa4f68231ed87da919ff9a852ec06a4e243cd16d20a544cb4c8e81f7106b67fec9b10f401c99833e6dff5cdd699aa76e7328983c40f783f82da2dbbd552329a3d6ba1187e7b23519610aec05fe105a3849a8e697fe7d6738fe0a1bbbd410dbd11ea8d81606d1f52f844b49e964a1a08659f24a645c8118ec9b4f43ae4bb87ba1463879132f2f63aa082283675981d4981f27d078563a7b1b99be4011ea74adc81fcdef8203b24c319e495fb140647665386f086696b1023364a2e2aaa039ad9f1675d100fac072cf6dc08b1bceb2535d90bf6fa35c723ddab461d9176f864a7c8c8fb8257c8cabc9cae42dab11346a62f5bd0c6136f27392df82ac123290ec6888d45ba6d7f48e4be862e7163c6efcb1a220c97b5cd16207c51780c8ea3bc271cbb2b08b49a24e8e6bd4ce4f8e2e1ab6d483366349a2c7ac4be16b422ce3a96087036e0393222c9269b67699cd567a33324f6930e3706f0a47c0414b387124545762c6ebdcf1bd29dc99f3be69470481e4ff0e216bd72efa17f0840108a4a6182a9521155a999892eecfa56a73d1da82ba1cb9c62f77ab3af32d7feb204308304779fd051112ce4e681a7081c809eb40e38dababfca4b8ac0edc584ecd24fe6a41e0ff1b0436456511382f74762267ccb9798c146c4ae94fc54dbc46b645ff8957e08b634b97ed5773b050df61593eaf78eddc2bccbabfde6c88502f7eb407c80c16d24eaff0d1974a73d639796a6cca7f7d5a28ee295465539948cb7c895f44a20c941da264fda811e4f7a87578ffbfaca867c9131031111c612ee8a94da4ed53939f1ccb12b73b9dc70457e516f7613d960ec2a09c3367ffd58d82c5df603e931d577dca438cfc78418530d5e1e904aeb26544d617beafe1232718822fb38613f207537570796bf861ef527addd5481084cf44b8e0814acb20d017f367b067e845279e94e5d9f2e00c62f71ff0d2451c95ec667f5997f813c10e7c2cded7c060ae00dfd05a9fcce1a105499340997bdb803860d1064b0192d59682238cb924c51f726cdf03228589e6204892bf74f9bc914b853561715aa568c6245a863df287578f145b6ca6a7c9804fd44091e0c33bb7412e9a661e7b44857a35f64de932661a88c4865c3f8dd2b0cb18deae0f92141eb73efeaa94547c96bb6385dde74feb390b9ceea4eac14acaa7e9f6d2f79120e59cdf64e6b785fa7063e94feb5147ba0affeb8519c9e7cbe5cea50309a1755397ee505915ff0d5544eb8d58ab1d4e7ce74ff1711fe322b8dda3dd357c7d16551accb212b2c8816cfb20d3728e9e4dd0e343e896b94427cebd50fd985b1ef33b7a4a5f7fc7ecb1890b236ad77ce0fe0df073d80a2028083315578aca3a31c0b5b911fbb16e5d6d5db5b9632bf43edb1499fe69e4d53c880b06bae81859bbcea0bc60c9411c9c2c5a40139afadd5ef7b5be62462846790b802edac39761c1d3d108624340e35ef3d17a22e269df7a422a19d5e171dd49aae0d61b017fbd09187a8894f75280420ce8df97df343e97cadb15fde05a029cf58d73d0b3cf83742c55eb2c2bc9e030d92fbfbee22fa5d29d6e9ff210ef63475bc5af7fb0b20f38b44acec88e70e248d999a15d27f686313939f60288c627d4a23448f2d12db5b2334837fd0d903bc5bc9017aa5364efe7b6a2351b290151cd6844b9d0d0667097032357a4ca5aaeb10cc56ba4257c1d6352fcf745d57839b3122fb8c5a72fb60f27c0d6b5c045e5c414f70c7ed5150a0a5486d266f9796f84eee39731bc17cdc270a22d200d9e0981973cfaef36035c4d9ca7c40e54a1770b1bcd32a88f08ba231c8e7ff02da2d06b3cbf78428a07883d21e9e41058c5fa3067bbcf0904cbbc6ab7b67d227c517851d5642a5ded8e84b5dc40fbbfcd0f2e41266344a213d9b0ebad4c34fd15c0ce7649343229142c230b4111dac911c8000a3846ebc8287fcc42e478ed19b28cfedb1c3bfe90ac3c4f699a11a9383db475250fd5a21863ed4f3b5d96722346f57db81029ae4774a575696d231a9982d3babf507f208479b92975e266dc8cbcffe95870e0c0ec7e980ed4992037e393f428206dbdc0fe98a6a2c6d847bd8508d12bc81eb2b726c959bf1b1e7651c218761be09077bdc8dd8fad1a179bad91f379cff829aa2fc238d1015a7c2267fe1edf2e733ede65aa937136c606df25681385ec235ea158a23fd85a6b0274f7fc0fc439ce57c0f9d028fd1f55839c0920404d416e865f321712187a59390533d2383a46a1fd7ebaa71b7ef9ccb79852448f64ca00e50a8ce02cedda11de1fbd941ed3b7dab70f69919508eb3c03bdb528be83d923f58ea25a7f84d6551363437107a67fab75790fdf1c06d6ceec49f368659049752670092a39e5096641bb6470c68da353b2cf5be1cb1e6fa6386e56a80721616cde892eb7ce88510cfb04b7fb30ce909315d6add01ab58e537f4352a42774a9de17f8f46bca49b982730c874fb001989d2c3e278fd921bddd593e56fa99a4bca0751feaa9b7261b027c9d645cdda16a2dca7562aca787ac6a8133995e28200cd76516ed8670739ce56ea0fb882925156d2dae6ab7f6a06f6615d9b1eea60349bef1c350e3614776aff6deb44dc08da95bfa5832006e27a94dcf4be44f42d395b26bd7aa60fe4eb30afc8b457264e9a1ef8ed582a25fe72c22a4f41a0d14fb8b72264c02e9ea44bd7aac49ac62b94e7b3f4b67bc11eec4f20c0813cc267fbbc73f1c90ba2ade79c3ad9484f44188a5e9108921263492013697a6f1a5e21bbc0fa3148ab3c29d5f91432cf879a73f867e925142248edd68092eb10e2769a4d77d607951473ad3b6a620a0e055b199d846fbd12e2f4085012f4ea03d53f347bea301559276d07a3e7b0f41e0924406a81b1e031919aca01a038ced07e9f4db03d2edca4be6c4b21ed5636122de06f551e884e0f6e24b5eb9ac7aa299fc8decbca10bfba0120cb932061b99f4ceb0613e27a233aee9ea270d52a328a3d0be2f30f4b5c6f70565fc4e4b39ed4e8a5b1a19225e66cf1c9dafdb7f2b83ade4b7fd60c93c420f8c1cfda9d5ed8618267c66631c3ced54c3f638e7be1d6fe0061d730b90764b30b676fe2b79dd05cde68498fbed4ea8a19140c230e766d7edc01b711cb097572f4fa9c7686fefdf1c23df19467d9baf71dd67ac3520b20b65c7331cd1dd6f570c3e865c006583698716e0a1152de91222e15e3653dd29369398324cc1e3acd56f08fc0b24d341a620448916a37b3fc9fadf09f58f1068ed2b95dd49707850042f43d4ff4cf24eea6c36c416da5b944613637faf277621b0814caff418ac2e369af01f513ecab2cec6243a5ffe0f614891dc1a9fda8373cc2eb73adc1468c5c07baa28ed79750ee91769e3d4bee14ae4e6c1feb1a86a8ee207b29dee073331f8f43d88c43027a33a79581f47e2680c2bb0015db26f892d5c81d78c6f01ece0a0376b4934b4686af731b4ca367ad90c403f0c069adbf2abddde6a16bd9f986931febc4c49546f623cfa19567ece1975c45fe93ff68cbe0b7e2bd2b7800bc85f35ffa1bb374ee1c9305eb2bd771aa6b66e11fa3424359bb222dd0dd34aed5e77d0fc6758e2314b7da7e98714bfd230f227028ea1371332abbbf8486273fdac2d78358ed49df90617aaba6fe0fd96c4e306dce5e2caa9fd54d8af984f8c5b4e5a2895173d6d4a74a262ca4a3f3e0bbed95430a43570a01bc72e5e48586319cb0530900b818d08c1636449cc00d98338abd5f589a6307a2458e5ffe164cd6c7dd4d3523b047caa57fceafd2a610cbf5eae713cd7d14e446db640855d2de57ae02b09bd2c51ac43c665b4d91336c24dd7d94fe2f9be201f0105a7dd2903c65e35015cd68738616d266458d2a7eb96118df1b6c8779637ee336c786f6243b0dcb35bceac05abda9990c4eb3f9c1fae7017aab50295ba3901f1db94b9d86fce7395de67039d64ad18c2f6f1a06c91627cff0dfb5984a27715b4c200cfe91006ddbe00648020e21faa5c41f0d19025c785c58652a3ce134691ef695882aaa463f38882cd36563b599f8ea254828ecc2c0721108c8d8bf487bf80c3ba72a53fa89a7dbb7ecae29cfbdbce4c2b5489e00fa18db18a0c27f36a9f8ab414f09fa80d270de2b4ab6f03f61cda153a81efea558d3db0141b09334667d2fafbe65f6d4fe5c96ac8ff2c6929540fc1f1cb9de191b959c5079c62e693f52dadf8484dccf66f1c1b02b9c773daaf1ca6068a88068676d6bd71dadc34c635d642ab66ebc89c1c30e3bf63db401fa2e2e3b0e298a567ec12ffd19235d233a76df097646c391e7678f1f59de9fe20c1317d7fb903df827118c7efb484a7d916cb85c44fecf2ff91d2196aaae86c6400588e52eac75bf4e740b2ca8eaf374c5c4c32740115b6214d5617dfc5467ee7f2d5f2b0c7aea628840618a329914867b7c62b5d64f7de0d8101b6db02270dc629ee8e5dd431b86008ec3424efe0afea07fcc1ed9bac79059a89f2e202f23c3894fe55887962ea0ef8207fd70d54b6ec90e3673c9e3b4d0bea4b483e652e87ebcd3a0fd04280ed35cea6f64bef018a96c138db752eb86b63bae161abb4227da1b9c6bd2c6f56bc7ed1fdbbf45e920e7dbdaf0b7b260ffb5d3016ea84764e56ae3d103321edfc7d5daf3df33e7480a4a50edd212d54b1083e23d32a204e8e43c4b18c951c2e011c5b43bfe8af453de14cad3bb0725254c0c4ef47e043223a843dfdb94b889013eff976fb12ae170d83ba8412e49b2940db3dd31067111af5ea6329cfca30285cb0291b26c836c061b17a4201b2a41ec72c5e0c2b62a100c78c53e12e5d0e1f502983bd3487de7db8aedbebd5d25f82cb4d16b2aa327a8a54514e4827775f47def15c0c47bb88be91a0f04a2363e065b0195ca43528fc0cae61760bde4369fda88252084668a2b22883678c4e2de9e961751f552807b13715e726b4426936a4f25f67c76829579d50930f7da5a32ea19fb9353966a6c96646a56fea290054da1d11af59269664b04c204f01a7350516aecdf21f9d15f259f54862aa2c0be8a842dfdbdae48d9b0711ac28af9321f362422e73e4048b19ba9453205a55612c3b5aae40736e5b16cb61cc96acf36d5d7599a4b52ee5b96d50131698eeb2ef95165fc34965c6e9aa2a9c2aae632e0a0077c08bf36def2d2bb5d23a00f637956546b449413845d2655ad6f7384287956477d0bafc6721021b961605dc78169b3a6ee1a2384de4526fe4ef829c8734c60855a16049d0cc90677654d7c4d425533221f9c7771831f6da3d876252b7c3f956978f45da04185f24757abb12b35e4cc851271b506fe35729bf250b637697a9c1d8b9a84b39d6eb2b8ae501b6aa72a4f1814d76cce458770a945b7349d1cb97c934dca8884d6c7fc6dbc96d22876122e011a9267a6febf7e57aacc01628905a0610554a37fb32b207a717ac6b9a596925009f1e936f1402a3e84d6edf7ed80e7d57e93378538b7760bd840065c75cb3b7d9be24201ce36cdd67d5fac4b697f3c63895c38212a7103186659a5e0bf72cb10f6b34659ecf0f698b47f4a7a0d041ef42caada5cec1884bcbfc40bd86f1a9cc0f7c08f7b616509f6eae83a7be2dd4280a1ffa50727fe6977498e991ec4bf751347f2a31b5383264f7242f50344902fe26c29c28d3f1493f961d36986dcc1d932e9139b1cad4c19446edaf2cbc3d217c7a7d8905bfc2bf62eadbbb617662dcf7588f27d99d29d7ab74288c56bfc7d3137ba7f866de1dced0db2c0f59cfeab9d289c5fd3ec86a402928d38b7402ddaa1a1e2e1348a47f468deced4fd9c8a5b167e4ebefa305e854e517ec1abc0ce3536ddaa99eed5c26e84fe7ea1533c8a2687478f2d1918c96be0a660169f6cea5ed97f29b421215965e09510dceef0a51fbdaaabf244384c7b1a635fd876af8218d9d4cd5fffede08a7f830d2b6fcfbe12478f86495a382932b53b1e95cdef33ad0557c465f40a6c2f62c2aeb41450b1b2b02d590919ead183a8b0b17e3a9ac83d75b670f8973dc015059be5c289189324b31ce4d495c9c08af0beaf51c192d2dea269e68fdf1f34bb48bf2b353bfc0b989502833994d483e4eac5124e3024fe44a5c378d084491806cd84409de48be2ec5d797416260674926fcf34c95bec0e6c3571ae2940b7b48a30081cd2555e3a5edaae8eea8e6a4db6483c00d025e7faaf668db69860ed41298f7af36da042890bd86e29c194a44363d46ce307cab70cdaab618c912bb18403f50a0ce5645161126ae3757b1e3d3e80816e452449893f13a7715973d7f8c1b7d94cf9f23f3e85068f31f67bb1deb1bcbb2d0896c7b6e86c2cd1c78bb7cb828d39a55a36d8632aa8f7468a3ef7e2b887a66cf97f6568a33f47fd4196374694f2fd2aea02a734da1cecd3ae8eb536c17f8cedccb6d06046ee0bd74be190a5df648c016a46081afb7e4767eea36671c794fd5157feabdea78a76254a2eb62ae764b0ac0438211412dedc7d01c997974fcda66b1560a92336c51633958fdca907f221320073166b50c6bcafed9aeaa0108cb3f779b2ebea183ffbfaae2a297249f98384d57bf2186c0869ad6cf91d24eab8fe31db2b6230fd038abe2d0d61e61f8403a9e92c72d8f145cd28b282e9da1e7f466db3dcad462a151336b321db6566597bde363cc4b064bbf37b21a93f7344c0efeef04a5e4fa7f45abf30d917aeb0c29efa3108dd6bceb1a445cba9a6af6fff6d17a6c011bc2cc5e0285d5ebc2d7e5d5ac29798592462726c3002063d0e8177daaa1fa574d45414e0c04b11eabee3eac4fa9c4ac2d97713e412d46b693cb1e654e6642d8293ee73de3d0e7ee22178809ec3dbc11307170f641fec0350e09084e9067ed117ae386b9b872030fba67270f75adf79c0054074ec1293e23c71b4ed1f681560b2caf85408ece6d1c3471dd0c9100ea2d0ee2bce49245e0eedef96087d9add98e2631cc65846bff8484ced851fdbbd02c5d04cf96a3b57d484aeab99c0891b6ecfdd9ee423b9c0f96f5279d824a5e0b1720d0d5823bd124de63bef3f8be029c67bd844cdaa30b3ca3f0ed20ad6b6952b678f8dd8883c3539081fe9bdaa786cb8861cf6b416698d41201d76fd7188249096fbb38e83f6db86f504d480a0825c639c6bf7254475887b6edfeb1e9607c814b84c62d93913917fc249bde91a059585a1f8125e6e7e0c85a7419779b4adcdd9b01784413c5ca11b30f165ba9fa4e29442130f42c8dcd424113331f81b65b5ea2eaa628aabe899fcdfa0596661e59c6edcf2347214ffa258be122ac7d396f76e310cd99a89959846820b2b8cacb4395dbc104a88c2563ba427eea4b951b4a31d6f9f7fd0834c2179de6ee51c2c95552b98d651faf6336f7e42cb94efe3fab3ed53b68d8a05f45e2615cff12273e6a8a1497bee00f4c53a2662bd088e740d0a95e7d5bc074ebb64ebef9cc139be3f61c5c2e64e34428f90398e39138ad3dc07d011e3103b83e21742e528ec37c22d49b0593bda0ad5026d07a982dbff648b297b8f9913b306df8fe9c8f119f08a6bf3f7b0218f281716cd5c117ad0b3c7e9a3eada6e24cda24dd79b4f652d721603185f15666e9f149b615375c8b3275b9c756f62e7af4d7d8299c0038fac2115e702151319022df1ac465379cd7c5da94836abb5dd520cc8bc263cd986b0f2a7566960182f61ab2de49de8471958f497e5d7f2475756ba542e0e947032ca14c5a7bde8d9c912d8d2ddeab1c6e99cb9e9ac0ff5a78bd39868a50a2a454f66685a8deb75b35d8ab09350a4430234222698392e6cdf9af8fb364715ff76962cec836f3ac227baa37aff388621068a4391997597bb26849622a37f55d3fc7bc5e415dc77bf44b6cc1d895d4708cd90d2d978b36666f817f775cc03a12bd2cf592ec74a26e3944c76f16a05b5f56e85ce1e2e2bc8bfeeaa845abcccbb7ab22368fe09a7fb184b55ac2a0685dc0c8099f90f7a524b537718d5ca26e0d8f5cce7718a7b69654c8b1359462b900ba97bd871475b7abdb4ad1046662bdd7866fd75f08830f0418f1f488a09df6505859ca35b9b1e58f1c8d22d27b3303082e309eedeb48807340576a07a734f6425c5e94da8b1cfd16d7696c03293d31d83c547d231ad684a56dd52917359937556db4ed67bae23dbf99d125c74d20cbc1c8cd97f5491546b4abd2d63ee4310762910d5019ee6763c4879b0974dce055a49e94852ba8f12c8a3cac6bf563e8b2aef841b7730d7919de121aa3a85eec3aa28dd3810b6a4f99ba5efd89c6fee41a51b6f940484345e1e88b91c21c191959bef038ca2d02a7694864b129f6fd5254443094c5a193673b89e3bee50072e4d889309895df4340e8cc31e0e587ae3cb7c3125063e3e19680117844718b686427e4a12d87a13a1f2d79d50511fe1b5f2ea84dbf28805c2c681966509937a2fd79eaa984e1093935afb51c68f2be8e9bd81e31650b781d4d354f37bf5b2feff2f5b96addc11490bc7a0f5a0842c4ff5b8f01dd4f834097ad24bfa9ee3b4522c7cce869cd82d9e8078fd6e959fb5580c933bb51bf4b73b9551342e9228dbaa4a2a3f2758377c7e6eed02f678d8e86155230565ceced10b47fe792d7b6bc7e7982e4424383c412427073dee10586059d09a9a60c0de72c8b3c82ac0e881da0d17386c5be1dc9271771c7d2c2b863be261d49441fb696c9082de62abc98f04bd8e0dcfd6cb7ee1462e9b331c3913809ff71206db3b6d93eadcb3cbc905bb26c8933f404378118efdffe646c082d829e67bb5aab7d75f63d0dc1d379d9920caed0b0133a34e7ec0e23bfe8d629c9544a5f77faf1aed1e4ad69b68279c7989a00afefec192492878a622a478ea539bcf5abef95fc7f56ce97ffe09e222dd3099b2076276a9bdb4c82a280eadd5b0602153a0054821beb55daff6cecf3f68f16eefc2d922afb5d2684e0d407c4e23377fa02060d8f8ecfc6eb2e68c5f792096feb95269201ebd4b4c54509d63223e4c2beee1fbe81078b38078cad1c3e2a9cf48f7117f889ac312ce10b206c5ed2ca0b47739c63ba5a989aa68c03b192d53a8fdbd36c605d4ee939e0b95bb12194c64b0515914697eeae30c34f02d282b2a78b257773177ad7f21667c7cc104d993e330e4b8fa4de958f29cae686660fbe157115ba7cf46de270d1bce0cfaa7e466568ace8a62850dd7534bc7b33ac8f21d6bce00cf0508d6d397a23f7592a753dabd875da8f104a503d89fe373f0b6053ad9f22a34c12be59310a6db4e2f2081c3dccdd97920ae5c9f061699e693399db11a654ffdfc01dc2d63a3d5dc98abb89237e611b390f83d7e1abde98bfc5930cbf59ba02fd53dc7d7328b0808ea005bb3591ef5841856671e1e78fe943d83c03832d9559baa7e34453d9cda0d7be7f6d830326927b970baaf373b6f772e90c68e92244f994b637ff0bc5f5cc98a7872b021c132913ee039dfa61ca6283bde134360e71b1fe46497d1de955fa7833f03e18155f621230cd51f6b62e857f1364f863b9eeb807dfbad8e650189f8d780a85cd11d54c5f6946a88974e6242b78af2315fd3cb9f7fb7e4e78f95c3aa445b23de841a533e553dbc9b66070aa4e4b000ab7a04893850df3c81e71494778fa70112fc1c0ad26b03c99a0481cc5b873217cb6cadb7d3128f2d0e2246a0af0b2bf45b2b6762b15a1c5a0c0200b2c4131c96678eb8997304a6b2872ff8fb2d92a0ae8aa2834a5e5eae2719a8954fb6db8e2709bc8142770bcbf129b75aa2529843cdc6f4f89fc819d8bfb3139809aaa161593ee8eb98bb974d288465138b9202202a2a3be3c32c3936571a7f2f8c107716863486251794110a1401388f77bab4a83d65a610b5c56904a790284627adf12a3efc7ed10e6f9c69a4068e5c73e8ee051f537289013537366f0981d32fe06752217a0116ac339984a6948ab4b27a8c38225e1e4df059700110e9a6867ba363fe9f4988bf0dd08f88d3dcb3ec138a6d779625965fecfce39b577af3572996c79f53f83ada77a64aebe42d16014f6a930c11f780f3f44a191d9b535c98142ae8654ae144a4f3ef29241617063289b7171242ea25aeaf0061d647f6e7c6b7d8ca51c5140b4eb506b1eb41a7593a29f6c03b7449676ef9a7cc934a828a61b019e4e1e81708edeb6b240fe49d4ba7ebe60325a67f26f959a527ba1e6451036722e078c0df156388ada160b559c293dc5ed3e467b02469c9f12da5087efec36576c2068c992f469255cbc65ee79b1702f47a337862d717f3702fb2e47cc4eaeacfc59d66990a1aa27781c7b68b9b6156e525675ff9eb9bd2abbe3b9603fff305012e78d3977a5e1bb10e87cf7c27729838d3091f681d322d31f1a9276ddd8ed3ce77318464bfea741451409d839d0747735257c639fdd1470b205760af36e2362547de35a42831cdbd952e07f5b0bc8d127cdf484b6bfb2e251fd3fcdf9d024708425ad56c4a18bf35878f699d8dc759df924a513ec330490122d353bd4f4c5c475cea0027c3f954e4dcbb688bbc985b22faf03c8d8e815e7390ca9b2c127af76b367e023595dcf02685bb9a7be44dff2fcdc3cbd7ae6755e52e1fb7585e243081cf1a9c3941628e4b8d2febe5dddadf6eac8114e050137cb8dcd13861e50af727c411bf9b49e7d32174f7446b461ff5c6964664fab5a8aff19198cba6de875a828b8b6db20760a142389422aa638fb08c59f84d017d6f064c23eb6749befd17164418dbd9a4c32a21e7c52a0f3a2913aaf25053f2f2af0e2a54577384a9b1c8e90c2f74d4e2755e0977840a8a8fb8a5f19a416ac531c7567afa84bd8c99833522c0e546dca832b2f917bf6954861f7e8b28646e7a5a30b1c881d15277e209bad5823842b10a82941ef8b56e22b7784fb457bd7b543cd45a7b10a504993b9c026c13094e864db2c9089a44674c3a0b10dc49281543af4019a36ebc6460a9e5a75d4d4cc4f90c1d6356eba3d1cbd220cc8ad528ae8b63f2d73ce64e130fe85799dca3cf6af32bf4f645088e405ff6fc0ea9b20ae35ca3a4c7797f336d924a8b948277c98730c33220bb7f3436bd2d5a5053504dc122bd84a1fb5857f3d5aa8e44ad7053a35d08ce840191e12c106984f8d5b5cfbb6ebdfc53563232c2375fdfc52ec94430a423fb136d40c765d7d28d389f0fcec560654c1e4e5bc4eb65f5fa2fa27fcf9037d0afdfe9dbcd53f2089ec01a1e47f6aee728d26302672470d24f35bd22409383d5213e45cb44ae9908f34da86fbeb019e4bf868a05dc6fa430af1bfa5a751d810e74179d5a40b2a92341ab8cf43872b14ae9683ae1463cb224559a203816a6908c51b354590ff37f36839a2003ec6deab628c2f0e27c2318bba2ccd2429ebf61010e5a6cb7657916f7e653553cef69d73ec23b2f516509090bd0b76dc2da4be607b449a1bd6a4677b19af1fa8f9f3a042c1b411f997d6c2798ecced080edb6dcc60e6855c6d7faef56f6002be7021bcd2098ba3f582da0afc5a2076cfa606c3cffd832d45b39cfcab08b68e447b982ceee8e2811e7c12efcfcbe709de6e50a782cd912700bbc8817d41e5969ba1d1841265fd1bd28663c0735b9bb2da68a5be2aad5ac3bd30c6bb3fdaead646484ca4b1d8bfe045c66411162449191cd8bb4afdf56f2468ad628d91bb5ed02b9a33bfbcd4da36fcb4478796c6b659c0c08bd43df8f17d9258e2ef008ad3feae3627605502222e4c731e19f468c8a6a86a58b5df5a1ded7b159be52033f240a6c76cc1d1d9d6987e6ce94c93a4088d8bd64b8e393bf22c526f3a25d1348c63713532dce27b366d998ff2913289630bba0a6d821222a3b3bea233baf65b4fe647c331cd81b18277442e04a88a3e90f16d282e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>学术科研</category>
      </categories>
      <tags>
        <tag>科研技能</tag>
      </tags>
  </entry>
  <entry>
    <title>编码规范</title>
    <url>/2022/12/13/coding-standard/</url>
    <content><![CDATA[<h3 id="1-Matlab编码规范"><a href="#1-Matlab编码规范" class="headerlink" title="1 Matlab编码规范"></a>1 Matlab编码规范</h3><h4 id="1-1-命名规则"><a href="#1-1-命名规则" class="headerlink" title="1.1 命名规则"></a>1.1 命名规则</h4><h5 id="1-1-1-变量"><a href="#1-1-1-变量" class="headerlink" title="1.1.1 变量"></a>1.1.1 变量</h5><ul>
<li><strong>小驼峰命名法</strong><ul>
<li>第一个单词以小写字母开始，后面单词的首字母大写。例如：<code>firstName</code>、<code>lastName</code>。</li>
</ul>
</li>
<li><strong>使用英文</strong><ul>
<li>变量名最重要的原则就是，一看就知道这个变量是什么意思。 </li>
</ul>
</li>
<li><strong>大范围的变量应带有意义的名称，小范围变量可用短变量名(无意义)</strong> <ul>
<li>例如：<code>stepSize</code>：大范围意义、<code>dt</code>(δt)：小范围。</li>
</ul>
</li>
<li><strong>循环变量</strong><ul>
<li>应该以<code>i</code>、<code>j</code>、<code>k</code>为前缀。例如：<code>iFiles</code>、<code>jPositions</code>。不使用<code>i</code>、<code>j</code>的原因是：这两个在matlab中是虚数。 </li>
<li>此外常用循环变量还有：<code>num</code>、<code>iter</code>、<code>count</code>、<code>mark</code>、<code>index</code>、<code>id</code>以及这些循环变量的组合形式。</li>
</ul>
</li>
<li><strong>代表单个实体数据的变量可以加以后缀No</strong><ul>
<li>例如：<code>tableNo</code>、<code>employeeNo</code>。</li>
</ul>
</li>
<li><strong>避免否定式的布尔变量命名</strong> <ul>
<li>例如：若命名<code>isNotFound</code>，在使用判断的时候，<code>~isNotFound</code>，搞半天才知道啥意思。所以不适用否定式布尔变量命名。</li>
</ul>
</li>
<li><strong>拓展变量</strong><ul>
<li>释义：就是在已有变量上经过进一步计算得到的新变量，或者与已有变量相关的变量。</li>
<li>策略1：在已有变量的基础上以小驼峰命名的方法在变量的后端添加限定词；</li>
<li>策略2：在已有变量的基础上以小驼峰命名的方法在变量的前端添加限定词；</li>
<li>推荐使用默认使用——策略1。</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考链接1：<a href="https://zhuanlan.zhihu.com/p/594149389">程序员如何优雅地对变量命名？- idea小时的文章 - 知乎</a><br>参考链接2：<a href="https://bossshi.notion.site/bossshi/8d0e7f4857504c388462b67999504068">变量命名规范</a></p>
</blockquote>
<h5 id="1-1-2-常数"><a href="#1-1-2-常数" class="headerlink" title="1.1.2 常数"></a>1.1.2 常数</h5><ul>
<li><strong>全大写字母+下划线</strong> <ul>
<li>例如：<code>MAX_ITERATIONS</code>、<code>COLOR_RED</code>。</li>
</ul>
</li>
<li><strong>参数可以以某些通用类型名作为前缀</strong><ul>
<li>例如：<code>COLOR_RED</code>，<code>COLOR_GREEN</code>，<code>COLOR_BLUE</code>。</li>
</ul>
</li>
</ul>
<h5 id="1-1-3-结构体"><a href="#1-1-3-结构体" class="headerlink" title="1.1.3 结构体"></a>1.1.3 结构体</h5><ul>
<li><strong>大驼峰命名法</strong><ul>
<li>这是区别一般变量，例如：<code>ParameterSet</code>。</li>
</ul>
</li>
<li><strong>结构体的命名应该是隐性的，并且不需要包括字段名</strong><ul>
<li>例如：用<code>Segment.length</code>，避免<code>Segment.segmentLength</code>。</li>
</ul>
</li>
</ul>
<h5 id="1-1-4-函数"><a href="#1-1-4-函数" class="headerlink" title="1.1.4 函数"></a>1.1.4 函数</h5><ul>
<li><strong>函数名应该采用全小写字母+下划线</strong></li>
<li><strong>函数名与它的.m文件名必须相同</strong></li>
<li><strong>函数名应该有具体的意义</strong><ul>
<li>避免短的函数名/缩写，这经常使得其名字含糊不清。</li>
<li>例如：采用：<code>compute_total_width()</code>，避免：<code>compwid()</code></li>
</ul>
</li>
<li><strong>避免无意识地覆盖</strong><ul>
<li>有时候我们取的名字，可能在MATLAB中含有这个函数名了，可以用<code>exist</code>检查是否含有了。</li>
</ul>
</li>
</ul>
<h4 id="1-2-文件与程序结构"><a href="#1-2-文件与程序结构" class="headerlink" title="1.2 文件与程序结构"></a>1.2 文件与程序结构</h4><h5 id="1-2-1-M文件"><a href="#1-2-1-M文件" class="headerlink" title="1.2.1  .M文件"></a>1.2.1  .M文件</h5><ul>
<li><p><strong>模块化</strong></p>
<ul>
<li>编写一个大程序的最好的方法是将它以好的设计分化为小块（通常采用函数的方式）。</li>
<li>这种方式通过减少为了理解代码的作用而必须阅读的代码数量使得程序的可读性、易于理解性和可测试性得到了增强。超过编辑器两屏幕的代码都应该考虑进行分割。并且设计规划很好的函数也使得它在其他的应用中可用性增强了。</li>
</ul>
</li>
<li><p><strong>确保交互过程清晰</strong></p>
<ul>
<li>函数通过输入输出参数以及全局变量与其他代码交互通信。使用参数几乎总是比使用全局变量清楚明了。采用<font color="blue">结构体</font>可以避免那种一长串儿的输入输出参数的形式。</li>
</ul>
</li>
<li><p><strong>分割与封装</strong></p>
<ul>
<li>所有的子函数和所有的函数都应只把一件事情做好。每个函数应该隐藏(hide)一些东西。</li>
<li>任何在多个.m文件中出现的代码块都应该考虑用函数的形式封装起来。</li>
</ul>
</li>
<li><p><strong>利用现有的函数</strong></p>
<ul>
<li>开发一个有正确功能的、可读的、合理灵活性的函数是一项有重大意义的任务。或许寻找一个现成的提供了要求的部分、甚至全部功能的函数应该更快也更具有正确性。</li>
</ul>
</li>
<li><p><strong>子函数</strong></p>
<ul>
<li>只被另外一个函数调用的函数应该作为一个子函数写在同一个文件中。这使得代码更加利于理解与维护。</li>
</ul>
</li>
<li><p><strong>测试脚本</strong></p>
<ul>
<li>为每一个函数写一个测试脚本。这样可以提高初期版本的质量和改进版本的可靠性。</li>
</ul>
</li>
</ul>
<h4 id="1-3-注释、文档与排版"><a href="#1-3-注释、文档与排版" class="headerlink" title="1.3 注释、文档与排版"></a>1.3 注释、文档与排版</h4><h5 id="1-3-1-注释"><a href="#1-3-1-注释" class="headerlink" title="1.3.1 注释"></a>1.3.1 注释</h5><p>注释的目的是为代码增加信息。注释的典型应用是解释用法、提供参考信息、证明结果、阐述需要的改进等。经验表明，在写代码的同时就加上注释比后来再补充注释要好。 </p>
<ul>
<li><strong>注释文字应该简洁易读</strong><ul>
<li>一个糟糕的或者是无用的注释反而会影响读者的正常理解。N.Schryer提到：“如果代码与注释不一致，那么或许两者都是错误的。”</li>
<li>一个通常更重要的是注释应该讲的是“为什么(Why)”和“怎么做(how)“，而不是“是什么(what)”。</li>
</ul>
</li>
<li><strong>函数的注释写法（英文好的话尽量使用英文）</strong> </li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%================================================================</span></span><br><span class="line"><span class="comment">% 功能：       传统LMS滤波算法</span></span><br><span class="line"><span class="comment">% 输入参数：   </span></span><br><span class="line"><span class="comment">%              xn           输入信号</span></span><br><span class="line"><span class="comment">%              mu           步长因子</span></span><br><span class="line"><span class="comment">%              dn           参考信号</span></span><br><span class="line"><span class="comment">%              numIte       迭代次数</span></span><br><span class="line"><span class="comment">%              M            滤波器阶数</span></span><br><span class="line"><span class="comment">% 输出参数：</span></span><br><span class="line"><span class="comment">%              theta        滤波器的系数矩阵</span></span><br><span class="line"><span class="comment">%              en           误差信号</span></span><br><span class="line"><span class="comment">%              yn           滤波器的输出信号</span></span><br><span class="line"><span class="comment">% 备注：		入射角只考虑一个维度的</span></span><br><span class="line"><span class="comment">% 调用方法：	   见XXX文件</span></span><br><span class="line"><span class="comment">% 日期：   	2011/7/12 20:37</span></span><br><span class="line"><span class="comment">%================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[theta,en,yn]</span> = <span class="title">my_lms</span><span class="params">(un, dn, mu, Num_iteration, M)</span></span></span><br><span class="line">。。。（具体编程开始）</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%================================================================</span></span><br><span class="line"><span class="comment">% 功能：	求圆孔的夫琅禾费衍射光强分布</span></span><br><span class="line"><span class="comment">% 参数：	CircleHoleFD为圆孔结构体，包含圆孔衍射相关信息；</span></span><br><span class="line"><span class="comment">% 		   theta为衍射场的次波方向，可以为向量，求取各方向的光强</span></span><br><span class="line"><span class="comment">% 返回值：	I为衍射光强分布</span></span><br><span class="line"><span class="comment">% 主要思路：使用夫琅禾费单缝衍射公式计算</span></span><br><span class="line"><span class="comment">% 备注：	入射角只考虑一个维度的</span></span><br><span class="line"><span class="comment">% 调用方法：见CalcCircleHoleFD_Test文件</span></span><br><span class="line"><span class="comment">% 日期：   2011/7/12 20:37</span></span><br><span class="line"><span class="comment">%================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">I</span> = <span class="title">calcCircleholefd</span><span class="params">(circleHoleFD, theta)</span></span></span><br><span class="line">。。。（具体编程开始）</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>一段代码注释写法</strong><ul>
<li>用于理解一小段代码含义的注释，统一写在代码上方，如：</li>
</ul>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%（1）初始化 </span></span><br><span class="line">Number = <span class="built_in">zeros</span>(<span class="number">1</span>,PNumber);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:PNumber </span><br><span class="line">    Number(<span class="built_in">i</span>) = MNumber;</span><br><span class="line"><span class="keyword">end</span>  </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>一句代码注释写法</strong><ul>
<li>用于理解一句代码的意思可以写在代码后方，但是注意不能超过180字符。太长可以考虑写在代码上方，如：</li>
</ul>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">gen = <span class="number">0</span>;  <span class="comment">%迭代计数器 </span></span><br><span class="line">JmNumber = Max_Cell(Jm);               <span class="comment">% 调用Max_Cell子函数求机器的数量 </span></span><br><span class="line">[PNumber,MNumber] = <span class="built_in">size</span>(Jm);          <span class="comment">% PNumber为工件个数，MNumber为工序个数 </span></span><br><span class="line">trace = <span class="built_in">zeros</span>(<span class="number">2</span>, MAXGEN);               <span class="comment">% 寻优结果的初始值，一行存放各代的最优解，一行存放各代解的均值 </span></span><br><span class="line">TotalOP_Number = PNumber*MNumber;      <span class="comment">% 工序总个数 </span></span><br></pre></td></tr></table></figure>
<h5 id="1-3-2-文档"><a href="#1-3-2-文档" class="headerlink" title="1.3.2 文档"></a>1.3.2 文档</h5><ul>
<li><strong>文档规范化</strong><ul>
<li>作为有用的文档应该包含一个对如下内容的可读性的描述：代码打算干什么（要求），它是如何工作的（设计），它依赖于什其他什么函数以及怎么被其他代码调用（接口），以及它是如何测试的等。对于额外的考虑，文档可以包含解决方案的选择性的讨论以及扩展与维护的建议。</li>
</ul>
</li>
<li><p><strong>首先考虑书写文档</strong></p>
<ul>
<li>一些程序员相信的方法是：“代码第一，回答问题是以后的事情。”而通过经验，我们绝大多数人知道先开发设计然后再实现可以导致更加满意的结果。如果将测试与文档留在最后，那么开发项目几乎不能够按期完成的。<font color="red">首先书写文档</font>可以确保其按时完成甚至可能减少开发时间。</li>
</ul>
</li>
<li><p><strong>修改</strong></p>
<ul>
<li>一个专业的对代码修改进行管理和写文档的方法是采用源程序控制工具。对于很简单的工程，在函数文件的<font color="red">注释中加入修改历史</font>比什么都不做要好。</li>
</ul>
</li>
</ul>
<h5 id="1-3-3-排版"><a href="#1-3-3-排版" class="headerlink" title="1.3.3 排版"></a>1.3.3 排版</h5><ul>
<li><strong>空格的使用</strong><ul>
<li>在二元运算符两边各空一格[=, -, +=, ==, &gt;, in, is not, and]；</li>
<li>函数的参数列表中，<code>,</code>之后要有空格；</li>
<li>函数的参数列表中，默认值等号两边不要添加空格；</li>
<li>左括号之后，右括号之前不要加多余的空格；</li>
<li>不要为对齐赋值语句而使用的额外空格</li>
</ul>
</li>
</ul>
<blockquote>
<p>本文转自：何亮科学网博客。 </p>
<p>链接地址：<a href="https://blog.sciencenet.cn/blog-437026-779476.html">一些MATLAB的编程规范总结1.0版</a></p>
<p>其他参考链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/150926389">科研小技巧——MATLAB的编码规范 - 西涯先生的文章 - 知乎</a></p>
<p><a href="https://blog.csdn.net/wuwuku123/article/details/106666382">matlab 编程之代码规范 -枯荣有常的文章 - CSDN</a></p>
<p><a href="https://blog.csdn.net/magic_yu42/article/details/111467556">MATLAB编程规范 - magic_yu42的文章 - CSDN</a></p>
</blockquote>
<h5 id="1-3-4-绘图、字体设置"><a href="#1-3-4-绘图、字体设置" class="headerlink" title="1.3.4 绘图、字体设置"></a>1.3.4 绘图、字体设置</h5><p>王老师关于绘图、字体设置的一些简单设置：<code>PlotCurvesFontSizeFontName.m</code></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% MATLAB曲线图示例设置字号字体</span></span><br><span class="line"></span><br><span class="line">clear all; clc; close all;</span><br><span class="line"><span class="comment">%% Lena512.bmp图像</span></span><br><span class="line"><span class="comment">%% X Y分别为编码比特率和峰值信噪比</span></span><br><span class="line">X1=[<span class="number">0.15</span> <span class="number">0.20</span> <span class="number">0.25</span> <span class="number">0.30</span> <span class="number">0.40</span> <span class="number">0.50</span> <span class="number">0.60</span> <span class="number">0.75</span> <span class="number">1.00</span> <span class="number">1.25</span>];</span><br><span class="line">X2=X1; X3=X1; X4=X1;</span><br><span class="line">Y1=[<span class="number">22.0370</span> <span class="number">23.4718</span> <span class="number">24.3595</span> <span class="number">25.1125</span> <span class="number">26.5516</span> <span class="number">27.8992</span> <span class="number">29.1981</span> <span class="number">30.8826</span> <span class="number">33.2239</span> <span class="number">35.0960</span>];</span><br><span class="line">Y2=[<span class="number">22.5249</span> <span class="number">23.5379</span> <span class="number">24.2606</span> <span class="number">24.9596</span> <span class="number">26.3507</span> <span class="number">27.5956</span> <span class="number">28.7035</span> <span class="number">30.0974</span> <span class="number">32.1077</span> <span class="number">33.7383</span>];</span><br><span class="line">Y3=[<span class="number">22.5594</span> <span class="number">23.6605</span> <span class="number">24.3931</span> <span class="number">25.1403</span> <span class="number">26.5922</span> <span class="number">27.8500</span> <span class="number">28.9936</span> <span class="number">30.4864</span> <span class="number">32.5300</span> <span class="number">34.1851</span>];</span><br><span class="line">Y4=[<span class="number">22.6049</span> <span class="number">23.7881</span> <span class="number">24.6194</span> <span class="number">25.4626</span> <span class="number">27.0361</span> <span class="number">28.3933</span> <span class="number">29.6686</span> <span class="number">31.3865</span> <span class="number">33.5905</span> <span class="number">35.3823</span>];</span><br><span class="line"><span class="built_in">plot</span>(X1, Y1, <span class="string">&#x27;- r .&#x27;</span>, X2, Y2, <span class="string">&#x27;-. b o&#x27;</span>, X3, Y3, <span class="string">&#x27;: m *&#x27;</span>, X4, Y4, <span class="string">&#x27;-- k p&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;DCT-JPEG&#x27;</span>, <span class="string">&#x27;APWBT-JPEG&#x27;</span>, <span class="string">&#x27;APDCBT-JPEG&#x27;</span>, <span class="string">&#x27;APIDCBT-JPEG&#x27;</span>)</span><br><span class="line">axis([<span class="number">0</span>, <span class="number">1.4</span>, <span class="number">22</span>, <span class="number">36</span>]);</span><br><span class="line"><span class="comment">%% MATLAB的默认字体是Helvetica，fontname的设置，中文字体：宋体、楷体、仿宋、隶书、微软雅黑、幼圆等</span></span><br><span class="line"><span class="comment">%% 英文字体: Times New Roman, Arial, Bodoni, Calibri, Courier New, Frutiger, Futura, Garamond, Geogia, Platino Linotype, Verdana等</span></span><br><span class="line">xlabel(<span class="string">&#x27;\fontsize&#123;12&#125;\fontname&#123;宋体&#125;码率\fontname&#123;Times New Roman&#125;(bpp)&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;\fontsize&#123;12&#125;\fontname&#123;Times New Roman&#125;PSNR (dB)&#x27;</span>)</span><br><span class="line">set(gca, <span class="string">&#x27;xtick&#x27;</span>, [<span class="number">0</span>:<span class="number">0.2</span>:<span class="number">1.4</span>], <span class="string">&#x27;ytick&#x27;</span>, [<span class="number">22</span>:<span class="number">2</span>:<span class="number">36</span>], <span class="string">&#x27;FontSize&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;Fontname&#x27;</span>, <span class="string">&#x27;Times New Roman&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-Python编码规范"><a href="#2-Python编码规范" class="headerlink" title="2 Python编码规范"></a>2 Python编码规范</h3><h4 id="2-1-编码"><a href="#2-1-编码" class="headerlink" title="2.1 编码"></a>2.1 编码</h4><p>无特殊情况，建议Python脚本程序一律使用 UTF-8 编码，并且在文件头部必须加入<code>#-*-coding:utf-8-*-</code>标识，声明文件编码方式，程序文件编码要和声明编码保持一致。 </p>
<h4 id="2-2-命名规范"><a href="#2-2-命名规范" class="headerlink" title="2.2 命名规范"></a>2.2 命名规范</h4><p><strong>文件/模块</strong>： </p>
<ol>
<li>小写字母，使用下划线：<code>Python</code> 的文件名通常是小写字母，单词之间使用下划线 (_) 来分隔。例如：<code>my_script.py</code>，<code>hello_world.py</code>。</li>
<li>避免使用大写字母：<code>Python</code> 不推荐在文件名中使用大写字母。虽然操作系统允许使用，但遵循小写字母的规范可以增加代码的可读性和一致性。</li>
<li>避免特殊字符和空格：尽量避免在文件名中使用特殊字符（如 !, @, #, &amp;, 空格等）。使用下划线来分隔单词。</li>
</ol>
<blockquote>
<p>在<code>python</code>中，一个<code>python</code>文件（以<code>.py</code>为后缀名的文件）就叫作模块，每一个模块在python里都被看做是一个独立的文件。 使用模块也可以<strong>避免函数名称和变量名称重复</strong>，在不同的模块中可以存在相同名字的函数名和变量名。 </p>
<p>简单了解一下<code>python中</code>模块、库、包之间的概念差异</p>
<ul>
<li>模块(<code>module</code>)其实就是<code>py</code>文件，里面定义了一些函数、类、变量等</li>
<li>包(<code>package</code>)是多个模块的聚合体形成的文件夹，里面可以是多个<code>py</code>文件，也可以嵌套文件夹</li>
<li>库是参考其他编程语言的说法，是指完成一定功能的代码集合，在<code>python</code>中的形式就是模块和包</li>
</ul>
<p>我们简单地将这三者都统称为模块，因为我们只需要知道如何去使用就可以了</p>
</blockquote>
<p><strong>类名</strong>： 类名使用驼峰(CamelCase)命名风格，首字母大写，私有类可用一个下划线开头；将相关的类和顶级函数放在同一个模块里。不像Java，没必要限制一个类一个模块。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Farm</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalFarm</span>(<span class="params">Farm</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_PrivateFarm</span>(<span class="params">Farm</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>函数名：</strong></p>
<p>函数名一律小写，如有多个单词，用<strong>下划线</strong>隔开；如果要定义<strong>私有函数</strong>，可以在函数名前面加一个下划线。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_with_env</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><strong>变量名</strong></p>
<ul>
<li>变量名尽量小写，如有多个单词，用下划线隔开；</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    school_name = <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常量采用全大写，如有多个单词，使用下划线隔开；</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MAX_CLIENT = <span class="number">100</span></span><br><span class="line">MAX_CONNECTION = <span class="number">1000</span></span><br><span class="line">CONNECTION_TIMEOUT = <span class="number">600</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>Python</th>
<th>Java</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件命名</td>
<td><code>hello_world.py</code>（小写字母+下划线）</td>
<td></td>
</tr>
<tr>
<td>函数命名</td>
<td><code>run_with_env()</code>（小写字母+下划线）</td>
<td></td>
</tr>
<tr>
<td>变量命名</td>
<td><code>snake_case</code>（小写字母+下划线）</td>
<td><code>camelCase</code>（首字母小写驼峰命名）</td>
</tr>
<tr>
<td>类名命名</td>
<td><code>CamelCase</code>（大写字母开头的驼峰命名）</td>
<td><code>amelCase</code>（大写字母开头的驼峰命名）</td>
</tr>
<tr>
<td>常量命名</td>
<td><code>UPPER_CASE</code>（全大写字母+下划线）</td>
<td><code>UPPER_CASE</code>（全大写字母+下划线）</td>
</tr>
<tr>
<td>私有变量</td>
<td>使用单下划线<code>_var</code> 或双下划线 <code>__var</code></td>
<td>使用 <code>private</code> 关键字</td>
</tr>
</tbody>
</table>
</div>
<p>【参考资料1】：<a href="https://blog.csdn.net/u011148770/article/details/144094991">002.Python命名规则</a></p>
<p>【参考资料2】：<a href="https://blog.csdn.net/meiqi0538/article/details/104993760">【Python】编程代码书写规范！- 科皮子菊的文章  - CSDN</a></p>
<p>【参考资料3】：<a href="https://python.freelycode.com/contribution/detail/47">PEP8中文版 — Python编码风格指南</a></p>
<h4 id="2-3-注释"><a href="#2-3-注释" class="headerlink" title="2.3 注释"></a>2.3 注释</h4><ul>
<li><strong>行注释：</strong> 以 <code>#</code> 开头，<code>#</code> 右边的所有内容都被当做说明文字，只起到辅助说明作用。 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello python&quot;</span>)  <span class="comment"># 输出 `hello python`</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：为了保证代码的可读性，<code>#</code> 后面建议先添加一个空格，然后再编写相应的说明文字。</p>
</blockquote>
<ul>
<li><strong>多行注释(块注释)</strong> ：<code>#</code>号后空一格，段落件用空行分开（同样需要“#”号）。<ul>
<li>如果希望编写的 <strong>注释信息很多，一行无法显示</strong>，就可以使用多行注释。</li>
<li>要在 Python 程序中使用多行注释，可以用 <strong>一对连续的 三个引号</strong>(单引号和双引号都可以)。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是一个多行注释；</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">在多行注释之间，可以写很多很多的内容</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello python&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>补充：</strong> 什么时候需要使用注释？</p>
<p>1、 <strong>注释不是越多越好</strong>，对于一目了然的代码，不需要添加注释；<br>2、 对于<strong>复杂的操作</strong>，应该在操作开始前写上若干行注释；<br>3、 对于<strong>不是一目了然的代码</strong>，应在其行尾添加注释（为了提高可读性，注释应该至少离开代码 2 个空格）。</p>
<h4 id="2-4-空格使用"><a href="#2-4-空格使用" class="headerlink" title="2.4 空格使用"></a>2.4 空格使用</h4><ul>
<li><p>在二元运算符两边各空一格[=, -, +=, ==, &gt;, in, is not, and]</p>
</li>
<li><p>函数的参数列表中，<code>,</code>之后要有空格</p>
</li>
<li>函数的参数列表中，默认值等号两边不要添加空格</li>
<li>左括号之后，右括号之前不要加多余的空格</li>
<li>字典对象的左括号之前不要多余的空格</li>
<li>不要为对齐赋值语句而使用的额外空格</li>
</ul>
<h4 id="2-5-文档注释docstrings"><a href="#2-5-文档注释docstrings" class="headerlink" title="2.5 文档注释docstrings"></a>2.5 文档注释docstrings</h4><p>文档注释，用于解释文档程序，帮助你的程序文档更加简单易懂。docstring 的规范中最其本的两点： </p>
<ul>
<li>所有的公共模块、函数、类、方法，都应该写 docstring 。私有方法不一定需要，但应该在 def 后提供一个块注释来说明。</li>
<li>docstring 的结束<code>&quot;&quot;&quot;</code>应该独占一行，除非此 docstring 只有一行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Return a foobar</span></span><br><span class="line"><span class="string">Optional plotz says to frobnicate the bizbaz first.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;Oneline docstring&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>补充：</strong> 作为文档的Docstring一般出现在模块头部、函数和类的头部，这样在python中可以通过对象的<code>__doc__</code>对象获取文档，编辑器和IDE也可以根据Docstring给出自动提示。</p>
<ul>
<li>文档注释以<code>&quot;&quot;&quot;</code>开头和结尾, 首行不换行, 如有多行, 末行必需换行, 以下是Google的docstring风格示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Example docstrings.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">This module demonstrates documentation as specified by the `Google Python</span></span><br><span class="line"><span class="string">Style Guide`_. Docstrings may extend over multiple lines. Sections are created</span></span><br><span class="line"><span class="string">with a section header and a colon followed by a block of indented text.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example:</span></span><br><span class="line"><span class="string">    Examples can be given using either the ``Example`` or ``Examples``</span></span><br><span class="line"><span class="string">    sections. Sections support any reStructuredText formatting, including</span></span><br><span class="line"><span class="string">    literal blocks::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        $ python example_google.py</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Section breaks are created by resuming unindented text. Section breaks</span></span><br><span class="line"><span class="string">are also implicitly created anytime a new section starts.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不要在文档注释复制函数定义原型，而是具体描述其具体内容，解释具体参数和返回值等</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  不推荐的写法(不要写函数原型等废话)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;function(a, b) -&gt; list&quot;&quot;&quot;</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#  正确的写法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算并返回a到b范围内数据的平均值&quot;&quot;&quot;</span></span><br><span class="line">    ... ...</span><br></pre></td></tr></table></figure>
<ul>
<li>对函数参数、返回值等的说明采用numpy标准，如下所示</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">arg1, arg2</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;在这里写函数的一句话总结(如: 计算平均值).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    这里是具体描述.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    arg1 : int</span></span><br><span class="line"><span class="string">        arg1的具体描述</span></span><br><span class="line"><span class="string">    arg2 : int</span></span><br><span class="line"><span class="string">        arg2的具体描述</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    int</span></span><br><span class="line"><span class="string">        返回值的具体描述</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参看</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    otherfunc : 其它关联函数等...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    示例</span></span><br><span class="line"><span class="string">    --------</span></span><br><span class="line"><span class="string">    示例使用doctest格式, 在`&gt;&gt;&gt;`后的代码可以被文档测试工具作为测试用例自动运行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; a=[1,2,3]</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; print [x + 3 for x in a]</span></span><br><span class="line"><span class="string">    [4, 5, 6]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文档注释不限于中英文, 但不要中英文混用</li>
<li>文档注释不是越长越好, 通常一两句话能把情况说清楚即可</li>
<li>模块、公有类、公有方法, 能写文档注释的, 应该尽量写文档注释</li>
</ul>
<h4 id="2-6-doc-属性的使用"><a href="#2-6-doc-属性的使用" class="headerlink" title="2.6 __doc__属性的使用"></a>2.6 <code>__doc__</code>属性的使用</h4><h5 id="2-6-1-引言"><a href="#2-6-1-引言" class="headerlink" title="2.6.1 引言"></a>2.6.1 引言</h5><p>在Python中，每个对象都有一些特殊的属性和方法，这些特殊的属性和方法可以让我们更方便地使用和理解对象。其中一个特殊的属性是<code>__doc__</code>属性。<code>__doc__</code>属性是一个字符串，用于存储对象的文档字符串。它可以帮助我们更好地理解对象的功能和使用方法。 </p>
<h5 id="2-6-2-什么是文档字符串"><a href="#2-6-2-什么是文档字符串" class="headerlink" title="2.6.2 什么是文档字符串"></a>2.6.2 什么是文档字符串</h5><p>在介绍<code>__doc__</code>属性之前，我们先来了解一下什么是文档字符串。文档字符串是一个对象的描述信息，它用于解释对象的功能和使用方法。文档字符串通常被放置在对象的定义之后，使用三个引号（‘’’）或三个双引号（“””）括起来。下面是一个<a href="https://marketing.csdn.net/p/3127db09a98e0723b83b2914d9256174?pId=2782&amp;utm_source=glcblog&amp;spm=1001.2101.3001.7020">函数</a>的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;This function takes two numbers as input and returns their sum.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，函数add的文档字符串是”This function takes two numbers as input and returns their sum.”。文档字符串可以包含多行，通常用于描述函数的输入、输出和功能等信息。 </p>
<h5 id="2-6-3-doc-属性的使用方法"><a href="#2-6-3-doc-属性的使用方法" class="headerlink" title="2.6.3 __doc__属性的使用方法"></a>2.6.3 <code>__doc__</code>属性的使用方法</h5><p><code>__doc__</code>属性是一个对象的内置属性，用于存储对象的文档字符串。我们可以通过访问对象的<code>__doc__</code>属性来获取其文档字符串。下面是一些使用<code>__doc__</code>属性的示例。</p>
<ul>
<li><strong>获取函数的文档字符串</strong></li>
</ul>
<p>在Python中，我们可以通过<code>函数名.__doc__</code>的方式来获取函数的文档字符串。下面是一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;This function takes two numbers as input and returns their sum.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add.__doc__)</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，输出结果为：“This function takes two numbers as input and returns their sum.”。</p>
<ul>
<li><strong>获取类的文档字符串</strong></li>
</ul>
<p>类也可以有文档字符串，我们可以通过<code>类名.__doc__</code>的方式来获取类的文档字符串。下面是一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;This class represents a rectangle.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, width, height</span>):</span></span><br><span class="line">        self.width = width</span><br><span class="line">        self.height = height</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(Rectangle.__doc__)</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，输出结果为：“This class represents a rectangle.”。 </p>
<ul>
<li><strong>获取模块的文档字符串</strong></li>
</ul>
<p>模块也可以有文档字符串，我们可以通过<code>模块名.__doc__</code>的方式来获取模块的文档字符串。下面是一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rectangle.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;This module provides a Rectangle class.&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;This class represents a rectangle.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, width, height</span>):</span></span><br><span class="line">        self.width = width</span><br><span class="line">        self.height = height</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(__doc__)</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，输出结果为：“This module provides a Rectangle class.”。 </p>
<blockquote>
<p>转载于：<a href="https://blog.csdn.net/davice_li/article/details/135028586">Python内置类属性<code>__doc__</code>属性的使用教程 - CSDN</a></p>
</blockquote>
<h3 id="3-代码整洁"><a href="#3-代码整洁" class="headerlink" title="3 代码整洁"></a>3 代码整洁</h3><p><a href="https://www.cnblogs.com/bndong/tag/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81/">https://www.cnblogs.com/bndong/tag/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81/</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>Pytorch基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn Git</title>
    <url>/2022/01/18/learnGit/</url>
    <content><![CDATA[<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1vy4y1s7k6" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/7d77c3fa1e99a6615aab26615f20b8cf15c78d7a.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">04:52:41</span>
            </div>
            <div class="bvideo-info">
                <p class="title">尚硅谷Git入门到精通全套教程（涵盖GitHub\Gitee码云\GitLab）</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>126.4万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>2.0万</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">尚硅谷</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>
<blockquote>
<p>PS：上面的尚硅谷的Git教程是我认为在B站讲的最好的，但是本文并不是来自上面的视频链接，而是来自廖雪峰的Git教程，具体的链接在文章末。</p>
</blockquote>
<h3 id="sect-1-Git安装"><a href="#sect-1-Git安装" class="headerlink" title="&sect; 1 Git安装"></a>&sect; 1 Git安装</h3><h4 id="1-1-在Windows上安装Git"><a href="#1-1-在Windows上安装Git" class="headerlink" title="1.1 在Windows上安装Git"></a>1.1 在Windows上安装Git</h4><p>在Windows上使用Git，可以从<a href="https://git-scm.com/downloads">Git官网</a>直接下载安装程序，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！可以利用<code>git --version</code>查看安装的Git版本。</p>
<h4 id="1-2-设置名字-邮箱"><a href="#1-2-设置名字-邮箱" class="headerlink" title="1.2 设置名字+邮箱"></a>1.2 设置名字+邮箱</h4><p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>因为Git是分布式版本控制系统，所以每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>注意：<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h3 id="sect-2-创建版本库"><a href="#sect-2-创建版本库" class="headerlink" title="&sect; 2 创建版本库"></a>&sect; 2 创建版本库</h3><h4 id="2-1-定义与创建"><a href="#2-1-定义与创建" class="headerlink" title="2.1 定义与创建"></a>2.1 定义与创建</h4><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p><img src="https://pic.imgdb.cn/item/66af1f60d9c307b7e936dfc1.png" style="zoom:30%"></p>
<p>所以，创建一个版本库非常简单。</p>
<ul>
<li><strong>第一步</strong>，选择一个合适的地方，创建一个空目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir learngit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> learngit</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure>
<p>使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 </p>
<ul>
<li><strong>第二步</strong>，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure>
<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库(empty Git repository)，细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>
<h4 id="2-2-把文件添加到版本库"><a href="#2-2-把文件添加到版本库" class="headerlink" title="2.2 把文件添加到版本库"></a>2.2 把文件添加到版本库</h4><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪<strong>文本文件</strong>的改动，比如txt文件、网页、所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p>
<blockquote>
<p>PS：这里在本地库暂时测试了一下，word文档等应该是可以用Git进行<strong>版本管理</strong>的，只是Git无法直观地展示修改的内容。</p>
</blockquote>
<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<blockquote>
<font color="red">使用Windows的童鞋要特别注意：</font>

<p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="https://code.visualstudio.com/">Visual Studio Code</a>代替记事本，不但功能强大，而且免费！</p>
</blockquote>
<p>言归正传，现在我们编写一个<code>readme.txt</code>文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>
<p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p>
<ul>
<li><strong>第一步</strong>，用命令<code>git add</code>告诉Git，把文件添加到仓库：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt</span></span><br></pre></td></tr></table></figure>
<p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<ul>
<li><strong>第二步</strong>，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;wrote a readme file&quot;</span></span></span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure>
<p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p>
<p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p>
<p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add file1.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add file2.txt file3.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;add 3 files.&quot;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2-3-疑难解答"><a href="#2-3-疑难解答" class="headerlink" title="2.3 疑难解答"></a>2.3 疑难解答</h4><p><strong>Q</strong>：输入<code>git add readme.txt</code>，得到错误：<code>fatal: not a git repository (or any of the parent directories)</code>。<br><strong>A</strong>：Git命令必须在Git仓库目录内执行（<code>git init</code>除外），在仓库目录外执行是没有意义的。</p>
<p><strong>Q</strong>：输入<code>git add readme.txt</code>，得到错误<code>fatal: pathspec &#39;readme.txt&#39; did not match any files</code>。<br><strong>A</strong>：添加某个文件时，该文件必须在当前目录下存在，用<code>ls</code>或者<code>dir</code>命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。</p>
<h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p>现在总结一下今天学的两点内容：</p>
<ul>
<li>初始化一个Git仓库，使用<code>git init</code>命令。</li>
<li>添加文件到Git仓库，分两步：<ol>
<li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li>
<li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li>
</ol>
</li>
</ul>
<h3 id="sect-3、版本控制"><a href="#sect-3、版本控制" class="headerlink" title="&sect; 3、版本控制"></a>&sect; 3、版本控制</h3><h4 id="3-1-修改文件并提交"><a href="#3-1-修改文件并提交" class="headerlink" title="3.1 修改文件并提交"></a>3.1 修改文件并提交</h4><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>
<p>现在，运行<code>git status</code>命令看看结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p>
<p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令查看，此命令是：<strong><font color="blue">比较文件在暂存区和工作区的差异</font></strong> ，即显示已写入暂存区和已经被修改但尚未写入暂存区文件的区别。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff readme.txt</span> </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure>
<p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p>
<p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt</span></span><br></pre></td></tr></table></figure>
<p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p><code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;add distributed&quot;</span></span></span><br><span class="line">[master e475afc] add distributed</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p>
<p><strong>小结</strong></p>
<ul>
<li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li>
<li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li>
</ul>
<h4 id="3-2-版本回退"><a href="#3-2-版本回退" class="headerlink" title="3.2 版本回退"></a>3.2 版本回退</h4><h5 id="3-2-1-查看历史版本记录"><a href="#3-2-1-查看历史版本记录" class="headerlink" title="3.2.1 查看历史版本记录"></a>3.2.1 查看历史版本记录</h5><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure>
<p>然后尝试提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;append GPL&quot;</span></span></span><br><span class="line">[master 1094adb] append GPL</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p>
<p>版本1：wrote a readme file</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>
<p>版本2：add distributed</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>
<p>版本3：append GPL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure>
<p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>
<p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure>
<p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。 </p>
<h5 id="3-2-进行版本回退"><a href="#3-2-进行版本回退" class="headerlink" title="3.2 进行版本回退"></a>3.2 进行版本回退</h5><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure>
<p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p>
<p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat readme.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>
<p>果然被还原了。</p>
<p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，让我们用<code>git log</code>再看看现在版本库的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>
<p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard 1094a</span></span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure>
<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看<code>readme.txt</code>的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat readme.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure>
<p>果然，我胡汉三又回来了。</p>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──&gt; ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure>
<p>改为指向<code>add distributed</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──&gt; ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure>
<p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure>
<p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p>
<p><strong>小结</strong></p>
<p>现在总结一下：</p>
<ul>
<li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<h4 id="3-3-工作区和暂存区"><a href="#3-3-工作区和暂存区" class="headerlink" title="3.3 工作区和暂存区"></a>3.3 工作区和暂存区</h4><h5 id="3-3-1-工作区"><a href="#3-3-1-工作区" class="headerlink" title="3.3.1 工作区"></a>3.3.1 工作区</h5><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区。</p>
<h5 id="3-3-2-版本库（Repository）"><a href="#3-3-2-版本库（Repository）" class="headerlink" title="3.3.2 版本库（Repository）"></a>3.3.2 版本库（Repository）</h5><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage(或者叫index)的暂存区</strong>，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p><img src="https://pic.imgdb.cn/item/61e67be02ab3f51d91087ff2.jpg" alt="Git指针关系"></p>
<p>分支和<code>HEAD</code>的概念我们以后再讲。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<ol>
<li>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</li>
<li>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li>
</ol>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure>
<p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p>
<p>先用<code>git status</code>查看一下状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>
<p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   LICENSE</span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p>现在，暂存区的状态就变成这样了：</p>
<p><img src="https://pic.imgdb.cn/item/61e67c9b2ab3f51d91095d39.jpg" alt="当前暂存区"></p>
<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;understand how stage works&quot;</span></span></span><br><span class="line">[master e43a48b] understand how stage works</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img src="https://pic.imgdb.cn/item/61e67d0c2ab3f51d9109f1d7.jpg" alt="当前库内情况"></p>
<p><strong>小结</strong>：暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</p>
<h4 id="3-4-管理修改"><a href="#3-4-管理修改" class="headerlink" title="3.4 管理修改"></a>3.4 管理修改</h4><p>现在，假定你已经完全掌握了暂存区的概念。下面要讨论的是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>
<p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，修改readme.txt，比如加一行内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat readme.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes.</span><br></pre></td></tr></table></figure>
<p>然后，添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#       modified:   readme.txt</span></span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>然后，再修改readme.txt：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat readme.txt</span> </span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure>
<p>提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;git tracks changes&quot;</span></span></span><br><span class="line">[master 519219b] git tracks changes</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>提交后，再看看状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>咦，怎么第二次的修改没有被提交？别激动，我们回顾一下操作过程：</p>
<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p>
<p>你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD -- readme.txt</span> </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 76d770f..a9c5755 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure>
<p>可见，第二次修改确实没有被提交。</p>
<p>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：</p>
<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p>
<p>好，现在，把第二次修改提交了，然后开始小结。</p>
<p><strong>小结</strong>：现在，理解了Git是如何跟踪修改的，每次修改，若不用<code>git add</code>到暂存区，那就不会加到<code>commit</code>中。</p>
<h4 id="3-5-撤销修改"><a href="#3-5-撤销修改" class="headerlink" title="3.5 撤销修改"></a>3.5 撤销修改</h4><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat readme.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure>
<p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- readme.txt</span></span><br></pre></td></tr></table></figure>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<ul>
<li>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
</ul>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p>现在，看看<code>readme.txt</code>的文件内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat readme.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure>
<p>文件内容果然复原了。</p>
<p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p>
<p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat readme.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt</span></span><br></pre></td></tr></table></figure>
<p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD readme.txt</span></span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	readme.txt</span><br></pre></td></tr></table></figure>
<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p>
<p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p>还记得如何丢弃工作区的修改吗？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- readme.txt</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>整个世界终于清静了！</p>
<p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把<code>stupid boss</code>提交推送到远程版本库，你就真的惨了……</p>
<p><strong>小结</strong></p>
<ul>
<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li>
<li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li>
<li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</li>
</ul>
<h4 id="3-6-删除文件"><a href="#3-6-删除文件" class="headerlink" title="3.6 删除文件"></a>3.6 删除文件</h4><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add test.txt</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;add test.txt&quot;</span></span></span><br><span class="line">[master b84166e] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure>
<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm test.txt</span></span><br></pre></td></tr></table></figure>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm test.txt</span></span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;remove test.txt&quot;</span></span></span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>
<p>现在，文件就从版本库中被删除了。</p>
<p>小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。 </file></file></p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- test.txt</span></span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p> 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ </p>
<p><strong>小结</strong></p>
<p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p>
<h3 id="四、远程仓库"><a href="#四、远程仓库" class="headerlink" title="四、远程仓库"></a>四、远程仓库</h3><h4 id="1-什么是远程库"><a href="#1-什么是远程库" class="headerlink" title="1. 什么是远程库"></a>1. 什么是远程库</h4><p>到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。</p>
<p>可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。</p>
<p>没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：<font color="red"><strong>远程仓库</strong></font>。</p>
<p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p>
<p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过<font color="red"><strong>SSH加密的</strong></font>，所以需要一点设置：</p>
<p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面。</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容。</p>
<p>点“Add Key”，你就应该看到已经添加的Key。</p>
<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p>
<p><strong>小结</strong></p>
<p>“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机</p>
<h4 id="2-添加远程库"><a href="#2-添加远程库" class="headerlink" title="2. 添加远程库"></a>2. 添加远程库</h4><h5 id="2-1创建并关联远程库"><a href="#2-1创建并关联远程库" class="headerlink" title="2.1创建并关联远程库"></a>2.1创建并关联远程库</h5><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库。</p>
<p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。</p>
<p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure>
<p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.</span><br><span class="line">Total 20 (delta 5), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>
<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样 。</p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>
<h5 id="2-2-SSH警告"><a href="#2-2-SSH警告" class="headerlink" title="2.2 SSH警告"></a>2.2 SSH警告</h5><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>
<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p>
<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning: Permanently added &#x27;github.com&#x27; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>
<p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p>
<h5 id="2-3删除远程库"><a href="#2-3删除远程库" class="headerlink" title="2.3删除远程库"></a>2.3删除远程库</h5><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (push)</span><br></pre></td></tr></table></figure>
<p>然后，根据名字删除，比如删除<code>origin</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote rm origin</span><br></pre></td></tr></table></figure>
<p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p>
<p><strong>小结</strong></p>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>
<p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
<h4 id="3-远程库克隆"><a href="#3-远程库克隆" class="headerlink" title="3. 远程库克隆"></a>3. 远程库克隆</h4><p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>
<p>现在，假设<font color="red"><strong>我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆</strong>。</font></p>
<p>首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code> 。</p>
<p>我们勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件。</p>
<p>现在，远程库已经准备好了，下一步是用命令<code>git clone</code>克隆一个本地库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br><span class="line">Cloning into &#x27;gitskills&#x27;...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3</span><br><span class="line">Receiving objects: 100% (3/3), done.</span><br></pre></td></tr></table></figure>
<p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有<code>README.md</code>文件了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd gitskills</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure>
<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>你也许还注意到，GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p>
<p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p>
<p><strong>小结</strong></p>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p>
<p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p>
<h3 id="五、分支管理"><a href="#五、分支管理" class="headerlink" title="五、分支管理"></a>五、分支管理</h3><h4 id="1-分支管理的概念"><a href="#1-分支管理的概念" class="headerlink" title="1. 分支管理的概念"></a>1. 分支管理的概念</h4><p>分支就是科幻电影里的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p>
<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h4 id="2-创建与合并分支"><a href="#2-创建与合并分支" class="headerlink" title="2. 创建与合并分支"></a>2. 创建与合并分支</h4><h5 id="2-1-分支概念与实践"><a href="#2-1-分支概念与实践" class="headerlink" title="2.1 分支概念与实践"></a>2.1 分支概念与实践</h5><p>在<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src="https://pic.imgdb.cn/item/61e696dd2ab3f51d91240513.jpg" alt></p>
<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p>
<p><img src="https://pic.imgdb.cn/item/61e696fd2ab3f51d91242093.jpg" alt></p>
<p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<p><img src="https://pic.imgdb.cn/item/61e697152ab3f51d912435f0.jpg" alt></p>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并： </p>
<p><img src="https://pic.imgdb.cn/item/61e697332ab3f51d91245144.jpg" alt></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p>
<p><img src="https://pic.imgdb.cn/item/61e697492ab3f51d912464db.jpg" alt></p>
<p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p>
<p>下面开始实战。</p>
<p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure>
<p>然后，用<code>git branch</code>命令查看当前分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
<p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick.</span><br></pre></td></tr></table></figure>
<p>然后提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;branch test&quot;</span><br><span class="line">[dev b17d20e] branch test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure>
<p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p>
<p><img src="https://pic.imgdb.cn/item/61e697672ab3f51d91248608.jpg" alt></p>
<p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p>
<p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure>
<p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>
<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>
<h5 id="2-2-switch"><a href="#2-2-switch" class="headerlink" title="2.2 switch"></a>2.2 switch</h5><p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p>
<p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p>
<p>创建并切换到新的<code>dev</code>分支，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure>
<p>直接切换到已有的<code>master</code>分支，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br></pre></td></tr></table></figure>
<p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p>
<p><strong>小结</strong></p>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h4 id="3-解决冲突"><a href="#3-解决冲突" class="headerlink" title="3. 解决冲突"></a>3. 解决冲突</h4><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch -c feature1</span><br><span class="line">Switched to a new branch &#x27;feature1&#x27;</span><br></pre></td></tr></table></figure>
<p>修改<code>readme.txt</code>最后一行，改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure>
<p>在<code>feature1</code>分支上提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;AND simple&quot;</span><br><span class="line">[feature1 14096d0] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>切换到<code>master</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br></pre></td></tr></table></figure>
<p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p>
<p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure>
<p>提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;&amp; simple&quot;</span><br><span class="line">[master 5dc6824] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p>
<p><img src="https://pic.imgdb.cn/item/61e69e7a2ab3f51d912a6360.jpg" alt></p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 2 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">	both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>我们可以直接查看readme.txt的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>
<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure>
<p>再提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;conflict fixed&quot;</span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure>
<p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/61e69ea22ab3f51d912a838f.jpg" alt></p>
<p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>
<p>最后，删除<code>feature1</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 14096d0).</span><br></pre></td></tr></table></figure>
<p>工作完成。</p>
<p><strong>小结</strong></p>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h4 id="4-分支管理策略"><a href="#4-分支管理策略" class="headerlink" title="4. 分支管理策略"></a>4. 分支管理策略</h4><h5 id="4-1-分支管理"><a href="#4-1-分支管理" class="headerlink" title="4.1 分支管理"></a>4.1 分支管理</h5><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p>
<p>首先，仍然创建并切换<code>dev</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch -c dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure>
<p>修改readme.txt文件，并提交一个新的commit：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;add merge&quot;</span><br><span class="line">[dev f52c633] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>现在，我们切换回<code>master</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure>
<p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p>
<p>合并后，我们用<code>git log</code>看看分支历史：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p>
<p><img src="https://pic.imgdb.cn/item/61e69fbd2ab3f51d912b56e2.jpg" alt></p>
<h5 id="4-2-分支策略"><a href="#4-2-分支策略" class="headerlink" title="4.2 分支策略"></a>4.2 分支策略</h5><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><img src="https://pic.imgdb.cn/item/61e69fd92ab3f51d912b6b96.jpg" alt></p>
<p><strong>小结</strong></p>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<h4 id="5-Bug分支"><a href="#5-Bug分支" class="headerlink" title="5. Bug分支"></a>5. Bug分支</h4><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>
<p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch &#x27;issue-101&#x27;</span><br></pre></td></tr></table></figure>
<p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;fix bug 101&quot;</span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p>
<p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure>
<p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure>
<p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p>
<p>那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？</p>
<p>有木有更简单的方法？</p>
<p>有！</p>
<p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p>
<p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>
<p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p>
<p>有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p>
<p><strong>小结</strong></p>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<h4 id="6-Feature分支"><a href="#6-Feature分支" class="headerlink" title="6. Feature分支"></a>6. Feature分支</h4><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p>
<p>于是准备开发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch -c feature-vulcan</span><br><span class="line">Switched to a new branch &#x27;feature-vulcan&#x27;</span><br></pre></td></tr></table></figure>
<p>5分钟后，开发完毕：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   vulcan.py</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure>
<p>切回<code>dev</code>，准备合并：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch dev</span><br></pre></td></tr></table></figure>
<p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p>
<p>但是！</p>
<p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p>
<p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch &#x27;feature-vulcan&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D feature-vulcan&#x27;.</span><br></pre></td></tr></table></figure>
<p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p>
<p>现在我们强行删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 287773e).</span><br></pre></td></tr></table></figure>
<p>终于删除成功！</p>
<p><strong>小结</strong></p>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h3 id="六、多人协作"><a href="#六、多人协作" class="headerlink" title="六、多人协作"></a>六、多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p>
<p>要查看远程库的信息，用<code>git remote</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p>或者，用<code>git remote -v</code>显示更详细的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure>
<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<h4 id="1-推送分支"><a href="#1-推送分支" class="headerlink" title="1. 推送分支"></a>1. 推送分支</h4><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>如果要推送其他分支，比如<code>dev</code>，就改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure>
<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<ul>
<li><code>master</code>分支是主分支，因此要时刻与远程同步；</li>
<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>
<h4 id="2-抓取分支"><a href="#2-抓取分支" class="headerlink" title="2. 抓取分支"></a>2. 抓取分支</h4><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p>
<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into &#x27;learngit&#x27;...</span><br><span class="line">remote: Counting objects: 40, done.</span><br><span class="line">remote: Compressing objects: 100% (21/21), done.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40/40), done.</span><br><span class="line">Resolving deltas: 100% (14/14), done.</span><br></pre></td></tr></table></figure>
<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>
<p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure>
<p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add env&quot;</span><br><span class="line">[dev 7a5e5dd] add env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure>
<p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add new env&quot;</span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure>
<p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>
<p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>
<p>再pull：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344">解决冲突</a>完全一样。解决后，提交，再push：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;fix env conflict&quot;</span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure>
<p>因此，多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p><strong>小结</strong></p>
<ul>
<li>查看远程库信息，使用<code>git remote -v</code>；</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>
</ul>
<h3 id="七、Rebase"><a href="#七、Rebase" class="headerlink" title="七、Rebase"></a>七、Rebase</h3><p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p>
<p>每次合并再push后，分支变成了这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure>
<p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p>
<p>其实是可以做到的！</p>
<p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p>
<p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p>
<p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 582d922 (HEAD -&gt; master) add author</span><br><span class="line">* 8875536 add comment</span><br><span class="line">* d1be385 (origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的HEAD和远程origin的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p>
<p>现在我们尝试推送本地分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure>
<p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (1/1), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From github.com:michaelliao/learngit</span><br><span class="line">   d1be385..f005ed4  master     -&gt; origin/master</span><br><span class="line"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> hello.py | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<p>再用<code>git status</code>看看状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 3 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p>
<p>用<code>git log</code>看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch &#x27;master&#x27; of github.com:michaelliao/learngit</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) set exit=1</span><br><span class="line">* | 582d922 add author</span><br><span class="line">* | 8875536 add comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？</p>
<p>有！</p>
<p>什么问题？</p>
<p>不好看！</p>
<p>有没有解决方法？</p>
<p>有！</p>
<p>这个时候，rebase就派上了用场。我们输入命令<code>git rebase</code>试试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add comment</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: add author</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure>
<p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin/master) set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p>
<p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>
<p>最后，通过push操作把本地分支推送到远程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:~/learngit michael$ git push origin master</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 1 local object.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f005ed4..7e61ed4  master -&gt; master</span><br></pre></td></tr></table></figure>
<p>再用<code>git log</code>看看效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>远程分支的提交历史也是一条直线。</p>
<p><strong>小结</strong></p>
<ul>
<li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li>
<li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li>
</ul>
<h3 id="八、标签管理"><a href="#八、标签管理" class="headerlink" title="八、标签管理"></a>八、标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>Git有commit，为什么还要引入tag？</p>
<p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p>
<p>“一串乱七八糟的数字不好找！”</p>
<p>如果换一个办法：</p>
<p>“请把上周一的那个版本打包发布，版本号是v1.2”</p>
<p>“好的，按照tag v1.2查找commit就行！”</p>
<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h4 id="1-创建标签"><a href="#1-创建标签" class="headerlink" title="1. 创建标签"></a>1. 创建标签</h4><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure>
<p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure>
<p>可以用命令<code>git tag</code>查看所有标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure>
<p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>
<p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure>
<p>再用命令<code>git tag</code>查看标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure>
<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p>
<p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure>
<p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p> 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 </p>
<p><strong>小结</strong></p>
<ul>
<li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li>
<li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li>
<li>命令<code>git tag</code>可以查看所有标签。</li>
</ul>
<h4 id="2-操作标签"><a href="#2-操作标签" class="headerlink" title="2. 操作标签"></a>2. 操作标签</h4><p>如果标签打错了，也可以删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag &#x27;v0.1&#x27; (was f15b0dd)</span><br></pre></td></tr></table></figure>
<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure>
<p>或者，一次性推送全部尚未推送到远程的本地标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure>
<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &#x27;v0.9&#x27; (was f52c633)</span><br></pre></td></tr></table></figure>
<p>然后，从远程删除。删除命令也是push，但是格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure>
<p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>
<p><strong>小结</strong></p>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
<h3 id="九、Github"><a href="#九、Github" class="headerlink" title="九、Github"></a>九、Github</h3><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p>
<p>在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。</p>
<p>但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p>
<p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap">https://github.com/twbs/bootstrap</a>，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/bootstrap.git</span><br></pre></td></tr></table></figure>
<p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p>
<p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─ GitHub ────────────────────────────────────┐</span><br><span class="line">│                                             │</span><br><span class="line">│ ┌─────────────────┐     ┌─────────────────┐ │</span><br><span class="line">│ │ twbs/bootstrap  │────&gt;│  my/bootstrap   │ │</span><br><span class="line">│ └─────────────────┘     └─────────────────┘ │</span><br><span class="line">│                                  ▲          │</span><br><span class="line">└──────────────────────────────────┼──────────┘</span><br><span class="line">                                   ▼</span><br><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ local/bootstrap │</span><br><span class="line">                          └─────────────────┘</span><br></pre></td></tr></table></figure>
<p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p>
<p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p>
<p>如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：<a href="https://github.com/michaelliao/learngit">https://github.com/michaelliao/learngit</a>，创建一个<code>your-github-id.txt</code>的文本文件，写点自己学习Git的心得，然后推送一个pull request给我，我会视心情而定是否接受。</p>
<p><strong>小结</strong></p>
<ul>
<li>在GitHub上，可以任意Fork开源仓库；</li>
<li>自己拥有Fork后的仓库的读写权限；</li>
<li>可以推送pull request给官方仓库来贡献代码。</li>
</ul>
<h3 id="十、使用Gitee"><a href="#十、使用Gitee" class="headerlink" title="十、使用Gitee"></a>十、使用Gitee</h3><p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。</p>
<p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——<a href="https://gitee.com?utm_source=blog_lxf">Gitee</a>（<a href="https://gitee.com?utm_source=blog_lxf">gitee.com</a>）。</p>
<p>和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p>
<p> Gitee的免费版本也提供私有库功能，只是有5人的成员上限。 </p>
<p>使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的<code>.ssh/id_rsa.pub</code>文件的内容粘贴进去，点击“确定”即可完成并看到刚才添加的Key。</p>
<p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？</p>
<p>首先，我们在Gitee上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”。</p>
<p>项目名称最好与本地库保持一致：</p>
<p>然后，我们在本地库上使用命令<code>git remote add</code>把它和Gitee的远程库关联：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure>
<p>之后，就可以正常地用<code>git push</code>和<code>git pull</code>推送了！</p>
<p>如果在使用命令<code>git remote add</code>时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure>
<p>这说明本地库已经关联了一个名叫<code>origin</code>的远程库，此时，可以先用<code>git remote -v</code>查看远程库信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin	git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin	git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure>
<p>可以看到，本地库已经关联了<code>origin</code>的远程库，并且，该远程库指向GitHub。</p>
<p>我们可以删除已有的GitHub远程库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>
<p>再关联Gitee的远程库（注意路径中需要填写正确的用户名）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure>
<p>此时，我们再查看远程库信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin	git@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">origin	git@gitee.com:liaoxuefeng/learngit.git (push)</span><br></pre></td></tr></table></figure>
<p>现在可以看到，origin已经被关联到Gitee的远程库了。通过<code>git push</code>命令就可以把本地库推送到Gitee上。</p>
<p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联Gitee呢？</p>
<p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p>
<p>使用多个远程库时，我们要注意，git给远程库起的默认名称是<code>origin</code>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p>
<p>仍然以<code>learngit</code>本地库为例，我们先删除已关联的名为<code>origin</code>的远程库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>
<p>然后，先关联GitHub的远程库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure>
<p>注意，远程库的名称叫<code>github</code>，不叫<code>origin</code>了。</p>
<p>接着，再关联Gitee的远程库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure>
<p>同样注意，远程库的名称叫<code>gitee</code>，不叫<code>origin</code>。</p>
<p>现在，我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">gitee	git@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">gitee	git@gitee.com:liaoxuefeng/learngit.git (push)</span><br><span class="line">github	git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">github	git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure>
<p>如果要推送到GitHub，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure>
<p>如果要推送到Gitee，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push gitee master</span><br></pre></td></tr></table></figure>
<p>这样一来，我们的本地库就可以同时与多个远程库互相同步：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────┐ ┌─────────┐</span><br><span class="line">│ GitHub  │ │  Gitee  │</span><br><span class="line">└─────────┘ └─────────┘</span><br><span class="line">     ▲           ▲</span><br><span class="line">     └─────┬─────┘</span><br><span class="line">           │</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ Local Repo  │</span><br><span class="line">    └─────────────┘</span><br></pre></td></tr></table></figure>
<p>Gitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：<a href="https://gitee.com/liaoxuefeng/learngit?utm_source=blog_lxf">https://gitee.com/liaoxuefeng/learngit</a>，创建一个<code>your-gitee-id.txt</code>的文本文件， 写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在Gitee和GitHub做双向同步。</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>本博客主要内容转自廖雪峰大神的Git学习版块，原文链接：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰Git学习</a><br>如果涉嫌侵权，著作权人可以联系我，我会立即删除。 </p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>休闲事情</title>
    <url>/2022/06/11/leisure-activities/</url>
    <content><![CDATA[<h4 id="1-学习提升"><a href="#1-学习提升" class="headerlink" title="1 学习提升"></a>1 学习提升</h4><h5 id="1-1-读书"><a href="#1-1-读书" class="headerlink" title="1.1 读书"></a>1.1 读书</h5><p>总说“要么读书，要么旅行，身体和心灵总有一个在路上”。作为自我认识深刻的人呀 ，闲来无事就会去看书。是打发，也是在别人的文字里找到有共鸣的我。</p>
<h5 id="1-2-图书馆"><a href="#1-2-图书馆" class="headerlink" title="1.2 图书馆"></a>1.2 图书馆</h5><p>一定要远离宿舍，图书馆能做的事情不要太多啊！看书上网画画写字，我还会逛书架，就像逛超市一样，发现一些奇葩的书，一些别人记在边角的小情绪，或者从一个奇怪的方向看书等等，意外得像一个礼物不是么?</p>
<h5 id="1-3-练字"><a href="#1-3-练字" class="headerlink" title="1.3 练字"></a>1.3 练字</h5><p>练字的好处太多了就不列举了，一个人就应该多做做有（zhuang）益(zhuang)身(bi)心(ge)的事呀</p>
<h5 id="1-4-口才"><a href="#1-4-口才" class="headerlink" title="1.4 口才"></a>1.4 口才</h5><p>每天花1个小时读新闻，在读的过程中不仅能够帮助我们练习口才，还能够梳理逻辑。因为新闻和文章不一样，有着严谨的逻辑。每次读完以后，尝试着用自己的话表达出来，坚持下去，你的表达能力会越来越好。</p>
<h5 id="1-5-了解行业资讯"><a href="#1-5-了解行业资讯" class="headerlink" title="1.5 了解行业资讯"></a>1.5 了解行业资讯</h5><p>曾听过一句话：“在了解事实的过程中，我们会筛选出许多资讯，这些资讯会引导我们做出决定”。每天花十分钟了解资讯，观察行业的最新情况，以便进行深度评价。判断所处行业是朝阳还是夕阳产业，或转行或深耕，规划职业生涯，定位日后的发展方向。</p>
<h5 id="1-6-参加活动，见识牛人"><a href="#1-6-参加活动，见识牛人" class="headerlink" title="1.6 参加活动，见识牛人"></a>1.6 参加活动，见识牛人</h5><p>在一个熟悉的圈子待久了，我们常常受限于自己的视野。<br>想要扩展自己的眼界，先要认识到自己圈子的不足。<br>多去参加活动，接触更多的牛人，把他们的经验运用在工作、生活上，能够规避很多坑。<br>另外，接触新鲜的人和物，就能看到自己跟别人的差距，从而促使你自我成长。</p>
<h5 id="1-7-学会理财"><a href="#1-7-学会理财" class="headerlink" title="1.7 学会理财"></a>1.7 学会理财</h5><p>理财的目的就是钱生钱，也就说所说的资产增值。要合理安排自己现有的资产并进行分配。然后财富才能进入一个不断积累的过程，财富积累后自然就可以做一些自己想做的事情，财富增值并不是最终的理财目标，而是我们达到人生目标的必经之路。 　</p>
<h5 id="1-8-学习PS、PR"><a href="#1-8-学习PS、PR" class="headerlink" title="1.8 学习PS、PR"></a>1.8 学习PS、PR</h5><p>随着自媒体的发展，越来越多人开始做博主，视频博主最紧要的事情九四剪辑视频，你学会可以学习商单，一单十几或七八百，不过对技术要求很多，随着佣金越高做出的视频效果自然非同寻常了。当然当有一天，你的其他知识学习很好时，你可以随时离开不喜欢的公司，随时成为一位自由工作者。</p>
<h4 id="2-梳理总结与反思"><a href="#2-梳理总结与反思" class="headerlink" title="2 梳理总结与反思"></a>2 梳理总结与反思</h4><h5 id="2-1-梳理总结"><a href="#2-1-梳理总结" class="headerlink" title="2.1 梳理总结"></a>2.1 梳理总结</h5><p>整理自己电脑、网盘已经各种在线网站(博客)中的文件夹/文档，定时整理邮箱邮件，不然囤积太多。</p>
<h5 id="2-2-规划时间"><a href="#2-2-规划时间" class="headerlink" title="2.2 规划时间"></a>2.2 规划时间</h5><p>管理自己的时间，花时间去复盘，做做计划，让自己更加清楚，做做总结呗，看看实际和梦想的差距，再进行调整，还可以写点字。此外，还要好好想想最近有什么事情需要做，及时去做，不拖延。</p>
<h5 id="2-3-调整心态，摒弃杂念"><a href="#2-3-调整心态，摒弃杂念" class="headerlink" title="2.3 调整心态，摒弃杂念"></a>2.3 调整心态，摒弃杂念</h5><p>人生在世，难免面对许多纷纷扰扰。心态烦躁，眼前的小事也就成了大事；心静下来，许多大事也就化成了小事。<br>面对问题时，保持从容镇定，心静则清，心清则明，这是最好的生活态度，也是人生至高的境界。<br>人生短暂，也许有些事我们无法改变，但如何提升自己却可以由我们自己决定。<br>请相信，那些你流过的汗、读过的书、走过的路、行过的善，最终都会回馈到你自己的身上。</p>
<h5 id="2-4-反省自己"><a href="#2-4-反省自己" class="headerlink" title="2.4 反省自己"></a>2.4 反省自己</h5><p>学习学习心理学，定时反省自己，找找自己的优缺点，针对缺点重点改进。</p>
<h5 id="2-5-输出内容"><a href="#2-5-输出内容" class="headerlink" title="2.5 输出内容"></a>2.5 输出内容</h5><p>我自己会定期在知乎上面写一些回答，把自己学到的知识，用相对通俗易懂的话去表达出来。即费曼学习法:当你将一些专业知识讲给别人听，别人能听得懂，就说明你已经对知识的理解非常扎实了。<br>写篇博客文章。一点点的闲暇时间是更新博客文章的绝佳时机，也不完也可以分几次，累积。</p>
<h4 id="3-生活娱乐"><a href="#3-生活娱乐" class="headerlink" title="3 生活娱乐"></a>3 生活娱乐</h4><h5 id="3-1-电影刷剧"><a href="#3-1-电影刷剧" class="headerlink" title="3.1 电影刷剧"></a>3.1 电影刷剧</h5><h5 id="3-2-收纳清理"><a href="#3-2-收纳清理" class="headerlink" title="3.2 收纳清理"></a>3.2 收纳清理</h5><p>要时常清理一下自己的生活环境，定时收纳平时乱放的一些东西，此外还要时常打扫卫生、清理自己的办公桌，一个干净卫生的环境、一张整洁的桌子使你更有效率，你只需要把办公桌上或周围地上积累的各式各样垃圾都简单清理一下就完事，同样的简单、不花多少时间。</p>
<h5 id="3-3-打电话。"><a href="#3-3-打电话。" class="headerlink" title="3.3 打电话。"></a>3.3 打电话。</h5><p>列一份你需要打电话清单，记下号码并且随身带上。不管在桌前还是在路上，你都可以在很短时间内解决一些通话。</p>
<h4 id="4-休闲探索"><a href="#4-休闲探索" class="headerlink" title="4 休闲探索"></a>4 休闲探索</h4><h5 id="4-1-城市徒步"><a href="#4-1-城市徒步" class="headerlink" title="4.1 城市徒步"></a>4.1 城市徒步</h5><p>不管是不是从小长到大的城市，这个城市一定有你还没到过的角落，拿着地图就像在游戏中开拓新领域一样的去探索吧，想象每走过一个地方那个地方的黑色就没有了，感觉很有趣啊!尤其是在上海这种地方，一不小心就会发现什么故居或者优秀历史建筑，比如我到过的老舍故居张爱玲楼下的咖啡厅丰子恺故居林微因住过的小楼等等，会有很多意外收获哦~</p>
<h5 id="4-2-夜游"><a href="#4-2-夜游" class="headerlink" title="4.2 夜游"></a>4.2 夜游</h5><p>城市的夜晚和白天完全是两个样子你造嘛!!很多有格调的店子可能只有五六点以后才开，很多露天的小演奏，不一样的夜景，还有各种跑车。。。一个人觉得不安全的话可以豆瓣同城啊，有很多夜游团伙(团伙? )，一起看凌晨的城市，安静或者喧嚣的，多么有趣!</p>
<h5 id="4-3-看海"><a href="#4-3-看海" class="headerlink" title="4.3 看海"></a>4.3 看海</h5><p>我承认大家一起在海边玩真的很高兴，可偶然自己一个人去的时候，是完全不一样的feel~还能独自感受大海浩浩荡荡，涛声阵阵</p>
<h4 id="5-运动健身"><a href="#5-运动健身" class="headerlink" title="5 运动健身"></a>5 运动健身</h4><p>跑步、游泳、健身，运动的时候一个人也很开心而且更自在啊!!!不用担心有人看到自己面红耳赤的样子，也不用担心形象不佳，爱怎么动怎么动！</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>生活休闲</category>
        <category>闲暇时光</category>
      </categories>
      <tags>
        <tag>休闲</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建历程</title>
    <url>/2022/01/18/my-first-bolg/</url>
    <content><![CDATA[<h3 id="〇-简要介绍"><a href="#〇-简要介绍" class="headerlink" title="〇. 简要介绍"></a>〇. 简要介绍</h3><p>本博客的搭建不需要什么技术，而且自己截止到当前时间对Git和Github的使用也刚学，所以只是参考网上博客和B站的教学视频来做的。</p>
<h3 id="一-部署Github-Pages"><a href="#一-部署Github-Pages" class="headerlink" title="一. 部署Github Pages"></a>一. 部署Github Pages</h3><p>在自己的Github上创建一个新的<strong>Repositories</strong>，注意命名规则是——Github账号名.github.io。</p>
<h3 id="二-安装Hexo"><a href="#二-安装Hexo" class="headerlink" title="二. 安装Hexo"></a>二. 安装Hexo</h3><h4 id="1-插入注解"><a href="#1-插入注解" class="headerlink" title="1. 插入注解"></a>1. 插入注解</h4><h5 id="1-常见的博客搭建方法"><a href="#1-常见的博客搭建方法" class="headerlink" title="(1) 常见的博客搭建方法"></a>(1) 常见的博客搭建方法</h5><p>据我目前所知，搭建博客总体上分有两种方法：</p>
<ul>
<li>第三方平台：在现有的博客网站、论坛或社区上注册个人主页。如知乎，掘金，简书，segmentFault，csdn，博客园等。特点：无技术门槛，可专注于内容。</li>
<li>静态网站生成技术：在终端执行命令快速生成静态网站，如 Jekyll、Hugo、Hexo等。然后通过 Github Pages、Coding 等展示。特点：通过插件可增加评论、搜索、分析等功能。有多种主题可选。在本地以特定格式书写文章，放置在指定的文件夹。每次发布或修改文章都需要重新生成和部署网站。</li>
<li>其他：<a href="https://juejin.cn/post/6951679886557708302">参考链接-如何搭建个人博客 ：几种方案比较 + 个人实现</a> </li>
</ul>
<h5 id="2-静态网站生成技术比较"><a href="#2-静态网站生成技术比较" class="headerlink" title="(2) 静态网站生成技术比较"></a>(2) 静态网站生成技术比较</h5><p>在该方法当中，也与许多可供选择的方案，像 Jekyll、Hugo、Hexo、Typecho、Wordpress等等，那么它们各有什么优缺点呢，这里我就不说了(不是我的重点)，请参考链接：<a href="https://blog.laoda.de/archives/blog-choosing">Hexo还是Hugo？Typecho还是Wordpress？读完这篇或许你就有答案了！</a></p>
<h4 id="2-安装相应软件"><a href="#2-安装相应软件" class="headerlink" title="2. 安装相应软件"></a>2. 安装相应软件</h4><h5 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="(1) 安装Node.js"></a>(1) 安装Node.js</h5><p><a href="https://nodejs.org/zh-cn/">Node.js的官方网站</a>，下载好了之后直接安装，安装过程中会出现</p>
<p><img src="https://pic.imgdb.cn/item/61e64e022ab3f51d91dc2599.png" alt="&lt;font color=red&gt;图1&lt;/font&gt;  Node安装"></p>
<p>要点第四个，添加到Path(环境变量)。</p>
<h5 id="2-Git安装"><a href="#2-Git安装" class="headerlink" title="(2) Git安装"></a>(2) Git安装</h5><p>Git的安装则是傻瓜式安装即可，虽然步骤多，但是按照默认的来就行；</p>
<p>好的，现在已经全部准备完毕，下面简单测试一下看看是否安装成功。</p>
<h5 id="3-测试"><a href="#3-测试" class="headerlink" title="(3) 测试"></a>(3) 测试</h5><p> 为了验证我们的Node.js和Git是否安装完毕，可以在CMD（win+R，输入“cmd”即可打开）中输入两条命令查看： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">git version</span><br></pre></td></tr></table></figure>
<p>若两条命令没有报错，而且显示了版本号，则安装成功！</p>
<h4 id="3-Hexo本地化"><a href="#3-Hexo本地化" class="headerlink" title="3. Hexo本地化"></a>3. Hexo本地化</h4><h5 id="1-创建新文件夹"><a href="#1-创建新文件夹" class="headerlink" title="(1) 创建新文件夹"></a>(1) 创建新文件夹</h5><p>这个新文件夹在之后会保存Hexo的文件以及你的博客相关内容，十分重要，我是建立在E盘下新文件夹I.myBlog。</p>
<h5 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="(2) 安装Hexo"></a>(2) 安装Hexo</h5><p>打开Windows中使用cmd命令打开命令行，然后更改命令行目录到上一步创建的新文件夹中，然后执行下面的命令安装Hexo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>注意安装过程中网络不要断开，安装完成后文件夹还是一个空的状态，下一步要初始化。</p>
<h5 id="3-初始化Hexo"><a href="#3-初始化Hexo" class="headerlink" title="(3) 初始化Hexo"></a>(3) 初始化Hexo</h5><p> 执行以下代码完成初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>这时候文件夹就出现了新文件，不再是空的，文件主要有以下几种：</p>
<ul>
<li>.deploty_git：上传到Github的最终文件，如果不使用Git，则不会生成</li>
<li>.github：一个神秘文件夹</li>
<li>node_modules：一个神秘文件夹</li>
<li>public：上传到Github的最终文件，不安装Git时可以使用这种方法直接部署</li>
<li>scaffolds：存放创建新文章时的模板文件</li>
<li>theme：主题存放文件夹</li>
<li>post：博客文章存放的地方</li>
</ul>
<h3 id="三-基础配置与指令"><a href="#三-基础配置与指令" class="headerlink" title="三. 基础配置与指令"></a>三. 基础配置与指令</h3><h4 id="1-主题配置-美化"><a href="#1-主题配置-美化" class="headerlink" title="1. 主题配置(美化)"></a>1. 主题配置(美化)</h4><p>进入博客文件夹根目录，打开<strong>_config.yml</strong>文件，然后自行进行修改。</p>
<p><img src="https://pic.imgdb.cn/item/61e64e022ab3f51d91dc258c.png" alt="&lt;font color=red&gt; 图2&lt;/font&gt;  _config文件截图示意"></p>
<p>这里是一些基本的，比如说你的网站名（第六行）、描述（第八行）、作者（第十行）、语言（第十一行）等都可以进行自主修改。</p>
<p><img src="https://pic.imgdb.cn/item/61e64e022ab3f51d91dc25a2.png" alt="&lt;font color=red&gt; 图3&lt;/font&gt;  url修改"></p>
<p>如图3所示，这里url的修改十分重要，一定要记得修改。要改成你将来要部署的网站！！！比如你要用GitHub Pages部署，就必须是那一节你部署过的网站链接！！！ </p>
<p><img src="https://pic.imgdb.cn/item/61e64e022ab3f51d91dc2594.png" alt="&lt;font color=red&gt; 图4&lt;/font&gt;  git链接修改"></p>
<p><strong><font color="red">注意，下面这几处修改十分重要！！！</font></strong></p>
<ul>
<li>第100行的主题名改为之前让你复制的那个文件夹名(记得空格，在你没有下载新主题之前不用管，默认即可)；</li>
<li>第105行“type”后面填写“git”；</li>
<li>第106行加上“repo”，然后加上链接——不是GitHub Pages的链接，是GitHub Pages的库的链接！！</li>
</ul>
<blockquote>
<p>注意：这里由于Github在2021年进行了一次更新，应该是不能再使用https协议了，转而应该示意SSH，但是我这里使用了https好像也没什么问题，其实我自己现在对Git、GitHub的使用也还是模模糊糊，对一些操作、概念(如：密钥、公钥、令牌等)不明白，所以也就是稀里糊涂，后面我还要仔细学习学习Git的知识，如果你的使用https不行，建议参考链接进行设置——<a href="https://vabzjaby.github.io/2021/10/05/pwh/#%E7%AC%AC%E5%9B%9B%E6%AD%A5-%E7%BC%96%E8%BE%91">如何在手机端搭建并部署Hexo - 听话的便当 - 个人博客</a></p>
</blockquote>
<ul>
<li>第107行加上“branch”，名字起main。注意，这里与Github在2021年进行了一次更新有关，之前应该是填写master，现在填写main即可；</li>
</ul>
<p>完成这些后，可以再次用<code>hexo s</code>这个指令查看预览，发现已经更新主题了。</p>
<h4 id="2-Hexo的常用命令"><a href="#2-Hexo的常用命令" class="headerlink" title="2. Hexo的常用命令"></a>2. Hexo的常用命令</h4><ul>
<li><code>hexo s</code>：在本地演示网站</li>
<li><code>hexo g</code>：在本地渲染静态页面(就是将md转换为html)</li>
<li><code>hexo d</code>：把静态页面一键上传到Github Pages</li>
<li><code>hexo new</code>：<ul>
<li><code>标题</code>(直接加标题则是在source/_posts文件夹生成—个”标题.md”文件作为文章，建议生成新文章和页面时最好用阿拉伯数字或者英文，这样链接不会很长)</li>
<li><code>page+标题</code>(标题前加page则是生成一个新页面，hexo刚开始只有默认的首页和归档页，创建其他页面，例如标签、关于等页面都需要此指令生成)</li>
<li><code>post+标题</code>(在_config.yml中将post_asset_folder设为true之后hexo new post “first-page”之后新建了一篇文章，就会同时在hexo/source/_post文件夹下生成一个.md文件和一个同名文件夹，文件夹存放文章中的图片)</li>
</ul>
</li>
<li><code>hexo clean</code>：清理已有的静态页面(不是删干净重来)</li>
</ul>
<h4 id="3-示例配置过程"><a href="#3-示例配置过程" class="headerlink" title="3. 示例配置过程"></a>3. 示例配置过程</h4><p>在执行<code>hexo init</code>之后，可以再执行<code>hexg g</code> 在本地渲染页面，完成后文件夹中会出现<strong>public</strong>文件夹。然后再执行<code>hexo new ts</code> 这时在source文件夹下会生成_post文件夹，里面有hello-world.md(默认自带)和ts.md(代码新生成的)，然后我们可以在ts.md中写一些东西，就是日后的博客文章。还可以使用命令<code>hexo new page about</code> 生成一个新的about文件夹，里面有index.md，可以写一些介绍自己的内容。</p>
<p>弄好上面的之后，我们可以执行命令<code>hexo s</code> 在本地演示网站，此时cmd窗口会生成一个<a href="http://localhost:4000">http://localhost:4000</a> 的链接，我们在浏览器打开就可以看到渲染的博客页面了。</p>
<h4 id="4-主题的美化"><a href="#4-主题的美化" class="headerlink" title="4. 主题的美化"></a>4. 主题的美化</h4><p>主要是利用<strong>根目录下的_config.yml文件</strong>和<strong>themes文件夹下某一主题文件夹下的_config.yml</strong>进行修改美化页面，可以自己进行探索。</p>
<h5 id="1-关于主题的设置"><a href="#1-关于主题的设置" class="headerlink" title="(1) 关于主题的设置"></a>(1) 关于主题的设置</h5><ul>
<li>存放位置：/themes/主题名/_config.yml(注意：有别于根目录下的_config.yml文件)<ul>
<li>这里需要说明的是：Hexo在渲染静态页面时，themes文件夹的_config.yml文件优先度比根目录的_config.yml高</li>
</ul>
</li>
<li>修改方式：大部分为布尔值(只需要修改true或者false即可)，支持中文的主题大部分会有注释<ul>
<li>这里推荐Hexo的Next与Ayer主题，两者有很清晰明了的中文，页面也很清爽(我的主题是Ayer)</li>
</ul>
</li>
<li>添加自定义js的方式：在/themes/主题名/layout/layout.ejs中添加<ul>
<li>该方法是我在用Next主题时发现的，当时成功了，是后来Ayer主题失败了，还是要按照不同的主题来</li>
</ul>
</li>
</ul>
<p>完成配置后，可以使用<code>hexok s</code> 在本地演示网站看一下配置情况。</p>
<h5 id="2-Markdown语法学习"><a href="#2-Markdown语法学习" class="headerlink" title="(2) Markdown语法学习"></a>(2) Markdown语法学习</h5><p>自己学习，这里不讲。</p>
<h3 id="四-部署与上传"><a href="#四-部署与上传" class="headerlink" title="四. 部署与上传"></a>四. 部署与上传</h3><p>在进行完这一步之后，就可以真正意义上有一个可以在浏览器打开的自己的博客网站！！！</p>
<p>正常情况下，在cmd输入指令<code>npm install hexo-deployer-git --save</code> 之后指令<code>hexo g -d</code> 理论上就可以成功将博客文件上传到Github上了，然后在GitHub网页的settings页面下找到pages，就可以找到对应的网址，打开即可看到自己的博客。<br>但是，由于Github服务器在国外，所以经常出现网络问题，需要搭梯子，下面是失败情况下的一些处理方法。</p>
<ul>
<li>失败则输入指令<code>git config --global credential.helper wincred</code></li>
<li>再次失败，错误原因是spawn的话就是网络有些问题，重启cmd试试</li>
<li>还是失败的话可能是电脑上装了两个hexo</li>
<li>最终还是失败的话可以使用指令<code>hexo g</code>，然后直接在网页端的GitHub上传public文件夹。</li>
</ul>
<h3 id="五-相关链接"><a href="#五-相关链接" class="headerlink" title="五. 相关链接"></a>五. 相关链接</h3><h4 id="1-帮助文档链接"><a href="#1-帮助文档链接" class="headerlink" title="1. 帮助文档链接"></a>1. 帮助文档链接</h4><p>在自己搭建第一个博客中出现了很多问题，有许多博客、视频帮助了我，贴在下面可以可看一下。</p>
<p>听话的便当的B站视频：<a href="https://space.bilibili.com/435364951/channel/seriesdetail?sid=812995">听话的_便当的个人空间_哔哩哔哩_bilibili</a> </p>
<p>听话的便当的博客：<a href="https://byn6.github.io/2021/08/29/gp-h/">https://byn6.github.io/2021/08/29/gp-h/</a></p>
<p>Ayer中文官方文档： <a href="https://shen-yu.gitee.io/2019/ayer">https://shen-yu.gitee.io/2019/ayer</a></p>
<p>Hexo官方文档：<a href="https://hexo.io/zh-cn/docs/asset-folders.html">https://hexo.io/zh-cn/docs/asset-folders.html</a></p>
<p>Hexo常用命令详解及使用方法：<a href="https://www.mabiji.com/hexo/hexocommands.html">https://www.mabiji.com/hexo/hexocommands.html</a></p>
<p>Hexo为文章设置目录与标签的方法：<a href="https://blog.csdn.net/weixin_44543463/article/details/119738094">https://blog.csdn.net/weixin_44543463/article/details/119738094</a></p>
<p>[hexo]如何更换主题、删除文章：<a href="https://www.cnblogs.com/mrwuzs/p/7942689.html">https://www.cnblogs.com/mrwuzs/p/7942689.html</a></p>
<p>hexo搭建博客后图片无法显示的完美解决：<a href="https://blog.csdn.net/weixin_43702620/article/details/118655308">https://blog.csdn.net/weixin_43702620/article/details/118655308</a></p>
<p>不会git就学不会github吗？：<a href="https://www.zhihu.com/question/29566172">https://www.zhihu.com/question/29566172</a></p>
<p>git是干什么的？ sourcetree是干什么的？：<a href="https://www.zhihu.com/question/48322958">https://www.zhihu.com/question/48322958</a></p>
<p>SourceTree的基本使用教程：<a href="https://blog.csdn.net/qq_34129814/article/details/82847753">https://blog.csdn.net/qq_34129814/article/details/82847753</a></p>
<p>Hexo server报错TypeError: Cannot read property ‘utcOffset’ of null解决方法：<a href="http://t.zoukankan.com/mmzuo-798-p-10510225.html">http://t.zoukankan.com/mmzuo-798-p-10510225.html</a></p>
<p>免费图床，看这一篇就够了！：<a href="https://www.duangvps.com/archives/1737">https://www.duangvps.com/archives/1737</a></p>
<h4 id="2-数学公式解决方法"><a href="#2-数学公式解决方法" class="headerlink" title="2. 数学公式解决方法"></a>2. 数学公式解决方法</h4><p>如何在Hexo中插入数学公式 <a href="https://qingstudios.com/2020/03/01/Hexo%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">https://qingstudios.com/2020/03/01/Hexo%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</a></p>
<p>MathJax在Hexo博客中插入数学公式：<a href="https://blog.csdn.net/weixin_39789979/article/details/110806006">https://blog.csdn.net/weixin_39789979/article/details/110806006</a></p>
<p>markdown斜体和数学公式的矛盾：<a href="https://blog.moper.net/2640.html">https://blog.moper.net/2640.html</a></p>
<p>hexo博客MathJax公式渲染问题：<a href="https://www.cnblogs.com/Ai-heng/p/7282110.htm">https://www.cnblogs.com/Ai-heng/p/7282110.htm</a></p>
<p>hexo 如何解决markdown下划线要加反斜杠，以及如何使用其他markdown的渲染引擎？：<a href="https://segmentfault.com/q/1010000003987383">https://segmentfault.com/q/1010000003987383</a></p>
<h4 id="3-优秀博客示例"><a href="#3-优秀博客示例" class="headerlink" title="3. 优秀博客示例"></a>3. 优秀博客示例</h4><p>二十五画生 <a href="https://blog.laoda.de">https://blog.laoda.de</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>生活休闲</category>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>如何作科研</title>
    <url>/2022/03/18/Scientific-Research/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="11080732f47c4591b8313eacf32f092250948f430bacd1e4db31477afda41044">270cb3bbed971930ec4ebcba9f8cc138f5d4800f50eb8f4502a546dcfd41431b30998da6854b2e15eb22a7e101761fe2b3ed00e98f1f91479488e71aa95499c395f2da24a1a990b53a4de9ac0615424691ef8c4296fdd3e7f3665920e08d9281e077e7b0f6f6451bd4d7fa5c6baebccfe6a9542cb5bc7623d935af3d8a9479367991556a60945b8fd167599426660b6fecac4510bb724cdb230e0e65b8abff829a823fb3cf6fb8553aad575a0c56f140e2445340d04b8a7d23fa8babc90c6204cf338db488b04532dbdc3f4b5c2b55c8b4a1ec45df45227b2cbfafaa97c19893dfe050b432cd5db51fbae44f2dd2112ea755ad3b6b7dfe894540a8ee94238d0a4dc448577dac9254628aea179a9bacbe31a2256493b2d7ec6972fb9bad69b1848730ee7cb6ac99ff0ab741ddc8146e505a5ddc236e5ca7eb1677182cd27e50890f930b5c6e7f91acad7439f8f59623354bf4360d7aafb47cbf5f1ef121bd66e16e20cc1f2d5eba7936dbc1fd443524367ddf6605ec7dc032492515812ae9e6d31c45213445561ea148b3dedbb0d9870d1bf25ff1d9c6d7b38d0285f2b8fdbd9bbcecf7afd8a4ae96b4b40d3c521cec24acd3b8a93fce71dcccc2dd3b51fcfdf1979652f7591a6313ce581effa6d731cfcbfed0ef4d6079c66c4e83221e0aa6ed653c1e39729bbc4c620d3b26beb551b6685c3d8de8e28c368fe6249ca3be78eccbbba97ccccbf44cd90820054419ef2f06c6e268326f0a09b26bcea8581a727b1cce1b6a3aedf0f82df7d83b69773e10cf89988098bbfc37a062927a6243a8f8da231681648f0bc220b0f15a41e337720ab40e3e5123852c2a8ef32c8cfb5599fba20d084f689f350787b683fb12c3529c4e97bc6f3cdae109842884295e3c0f4bf2c5bfcbd2782d1b8c890169d57b9548131b62ae8c9b78148a3cd533661793bc33b64e358577e69f63b8a2b4bafd766eee9678a09df069c92d758f24a82aeba0d6a34d2c39a781ad6b5991d5ccfdeb5b5cd730adbe2216e3b0450f0685cd08b1c1404aa8930540c6118e53daf768c2e1d9e636f6168538d75e5f8b98281fe84bc5c78740a93216ba4fa2ceb91ce8bc3ddacf90cc56c47ddcb11e0bca9d13b315fedc1acda808d646f36d32a4730f18b2ee57cbdf02c80c227e5cfbfb75d63b0d5fd09abeb269d4eb4b769c857909279eff838f3ae047ecb9263d96ea2cbc8c1c6c6c1a3cab57f019a4ceab9b59c4e37b7a2e7128829165f0ed2706b52916fc274558be4c5611e075be1b0c0b3eb8cdfc979319ec31d0c424731ebebc0e8a8c73313ed6ee9462e8cc60992cd0ffdd8f0b3dce8adde71abaf5572a6a7879755fc824baadaf0acf5605348428182ed0113845adfc0279d14e5254cfec372ae4dc1ce9045fcc1ab716c246670ce56bf3fde3f7840b11c49a322320a4ad0824952111ef752c76ab2a52238cfff19005d74b3101227879f64f68b634416edcee782c68c1a2eae9e9c40b4faef56262d630ac3efb4b1cd51e06ffa06c64abc2c2980117da1adaa19ddbf1a71ca8fa9c389559beb05efc6741d0c31b0008d64c5c63414d0afe7a7f3fe62f30a22cd833948f88d9c1e0b4116c6c66a6d5ca30701b017a9c23d7ad76453b84c6ebf35d18e5cd6bd9e06224ac32153b0e325142d3bcb4f9844d64d27498a7d1048d89d4b8de3b72034994ca27f5ea1816ad2b838d898cd57bc90137d6cd9bf6aab78d0839927ec7396cc7a121c640253d9c2efbc1901da0878ec28ded888c48b06da8a576b7255fe35b1e15d589e8d1e08043230c7b480d3f26ad477ca6902a1e81c8dff6c0c0bfbcc7395fa1a4465ba5069e62d0f9bbd0058ebc6f8af5d3fa63b5374363d47b0c6b719b324773c2c18ae0fe37670648d3aa129c89c48559973a616f52509d2a71cde838893fa505f2d3102623ee81e5ae49f1cc7b718101fffe4fa82e0ff8f20abaa963f4e33ecbf0263a8237d3f9ff794e9dad7522ce7546667d4443a7f1c61ae03bdc79b33254ff7b9cd0e23fe3deee23a8169eaec0ea50c52044ff12f909d8344557fbd3eb9b89b290ecede6dc45bb03492f05e91e9d962862b2f0d59326d38214de0a0780d1c848e9acb08b33a81dad11bb128984879a7264fdbb4e637a2e11092d1460045d827c714b3f39f37f00c7e31c0f69a63705316040644f3ad7bf6c221d030f5d0bb23a09b03d1bec1abf8be8b6bbd5801c82caed5251829726d9c687068b457c0c31f19654bfd10975508e61e693008c80e3ce2ccab29b12b0a3fe5151f4365cf4a94cb4577a1751f78b8b908105a8c2681e3442c96fb20dddb58bea26c4f429d5b45478275a4722273493470770bfec61b8ec982f7e146dcf242067cb67fe9e49903e1190e36753a052261f6d42425d8bed38a4486bab22115aff071f91409e188634b348a5f05053ed731182f1d67c40d97f655f5c36690b9cf5fa2e779e4e3ebebccab43c67fb0b834a80daf571775cce4688e31d1c3ca6e612a55d1415c8e20fe0f260dfd0bf052224dcf23f344d2e8e490f7ea6ed32cf13c9c297c67c31550aab27cc8c52c706ad736912ec8c02fa7b641c4de7970d09d183ad3721d1d8f9963d8fb77d42d7a71116486e99c0fb6d74b7556639013a15eb690f7716e28abbdd84758cad10d1cb3a4df9e803b0dd79dcd0158c8fd5ba5fd9e6b97a29ba79a51fa6fe961734cb2f2838244301efc56f92d29473db79ee0bea29eb7b416eabc50dd0c504aa6955a2fae235bf36deca38f978e8f385987bf5267e427903d47870cf3f4efeb84ed4b91f018d974b30ff972ba91f19886c3fb4ce4a09d73a1531dfa47d6173a6a06e10fe0859042f7c069a1a7d3064b27e5bb1dcb9b4f3dacf7631158e2d0c92f019e8db76618ef27b7f0a9964097a074a34f7253d0d82e2635f353641cbe78cd30faf20d8fda9404a1d57ef6ae573fedd11043d1eec40e331dc482f9c7e3fa2645f829eb518e9bd7145a307b06bd44850bf4f7a4c859a16447819e56b7c8e98e697578da42004007da368163e15343865b922215759d4522a27c5ab5517d33fca024d539931d0394cdef5bd8aa3c28b861376f87b8df2c576599e33b5cbc973ffb7a0303364b2064fa0b5b7713cb311b8af773e137340ac1b82e8205b9f450e964226ab4dab20fe6d88c9336211cbbffea6563cc3d2f3b04344f7c12040b621e6ca6aafafb58888d6e72873470f8f702668d89163707256ce85bee1a599f83bbdfd42b50b20aaacb53725e84c0523d3a657fa018c3140c46b08ffcd6abc0efa1ebb029acfc2d57b4213325d94da792ae82ed6f0043cd74f3f8bfbfec7ea330a9e34bc90213f66963e958d3e1cd5a788d8c720f18d503e9096bc2a4840b0bb0131dae19656928a8d4c443bd7f2b13b321f5d113fd19087673cf658f667d5b9f11a813b000b17b86176bf303782e5f2c78871b07b3e45c4d253aa223c4fac7d5069ea760347e5650ebede243bfd6e248827f6de6ca0ac98bf1ead4d8f776f429be37dd97e50cf655dc83ccacaa6ec83e1112cec73ef9652c5ec48021d7b38c9e4f47e4eaf0661ef51839292c62b23b4dd7e1a6ff6ddad991ca7b35d9b22408dca168dc1111e3e3b5e3a1219812ea5c39d5759943b24aa37af743f7aea87c999b19785f654c5f862ba6a9533d7539270ea9e1bb60e329ac02765324c7abed8683449b04d235de4ac3c65cac172eb62ceb84185da5ef46274784f2d89465d3108a7b91c3d647f034dd33a6b40535eded7bfdec991d2be149baf1ffc0a19a50f9176ca75067c6bd35f2fc1de673f82f4a6e8ee1a3356f0ed4aaf1a0cc5400ef0621b735616e939dc6d2f696c0023865639385d1c38ac34820d62885cf9c05610392bc058ac0bf7bc8802e0d31b5ee1d448b1b5db6f67d15bbc076f5e150f89f05c8bec03a616937bb99bb7c7524f9e9b5d9a770ebe0eb21f4596dd6c9181e7b36e9e602e3c7c3604cc2512eb444a5b38f4666b09e20a8961bc1dd6082dd64afef6d2df37200dbf9e1b68423defbccd33ce6b2de2bf5993abb798c5e595e80145fbbced1994be6b5065460647cc6a8ae97a74186ec896b89233439c6f4409ff7b1ced148da42dede3dcf8dc41d37ec9a1fe7d5ce31effac3274887ab290d8d8b185629efb3bd9297d64996beb77501e4e4725fb7af5be79ab87a7d77ec86ea4bac14338498c0e65664c99870914cb20e4a25dbeddfac0484b917ecfb9fc2917f051cb98bea85e9b54705a79d12d5800e5ad9298b51e396a91d6467a7305a3dfc8dcd31479d9d55c5d3b9a621666e19b6331064b46da374986449238e4b8e64b5ee0f37ce5718a818253d69e415463e6f0e98a53dcbb8d54b3344b1955d127bbd6119004568a2aefadc69d5343184d6b5451ec63f71f441bcf6445166acd07463cd986d731e86c63aab691b0f31ba8aa8b8ba488682f0eacaf1bc116589d18d2d3fc8dd70fc32167aae6810eeea698cde7771c45269e1867168c4c45524146fe23dfe3adfcff42655326aaa7483c5da862d5f3e0a0fba7ec344a0eebb4e1ddcc6beebdb2753337c8ab53c526e9b327fb03003089df2fb56a48f1fc90286381a88d642285c89d01568d9cb0229ad460ad80c9013e91e403c53e6198b8ffbdbd8705b49ff7b4cd48a15df3bad1728f9e0ad503120ff0fee21aa6e6519e99ce216232bc9dd74e352f653c03a145319d7263f09f1b88dfb800dec2576b03a0eb3b131c9233c7697ef9e291c8cfee9d9fac9a5ad1ac350fb74db20a4ee66241a842f5eac7e6a1adcbdcd94e10bab0ce93adcff221f9445ae938ebaa535eeca83e4536399ec7657a776c26740072d32af91da53f30ba9e584a79fa5d7f5a5b9dc0009d9d5a583cd427e9ccb81d81007bfba75e421e27d26738e1bae52ddf2694e964f0150444b1bf561b29d09cb801911e5bcc1a37927cdd7c87cc6de5a9d4fa6af30ba0ace8ef34eb4e5b0457b3dd18c53a4627530e697225b53fb2ef2e2accbe7e19a8d40a70663eb266fc803badd3876deef1694fb03fb0db1eb2ed2d519f787d7bdd93fe16c34eb44cf1b7c687ffbda6aea57e0c89216f427e854d9c63ede97d79cd6ebf1abf321c190dbe28326c40bf05c757ffd4df309ed9113f32da9421fb010ed879efead37ff510e9dccec6de2541d56a8eb798410850b70d92c436ec36095b1c6cf730005b654b0184edeeccaa3191293e45bb63c831b354e467c87aa99eabcd468b3a0e0f11fc99f4d2c12175b98a540d084c9fac263ca19f5c371c4e91255a66089d6e735b5ddd30965be6956f25a41cffd1bb7569eafcc1b5bcd6225d1ba9439244b55d2abe44d2f43bb3c95f6894e5150a6958d7e2f9b63d43bf86f94ef9bf9250f84124e4d27b017f209a913179613008c069a5ceccd3f885275fb8ec1b1788d0c06906772a214ed81bdcd05631d5fcf376e759285c7c00eb2370c4c05e253f0fc54ac9d70b9fa22d55f177e64b9191cca2f6044d838117043bf193a176261b458d7e0095102a83db39b9c575d10c8b6b8ebf1c341a1fc4bf39e7d96310de3af71cbe9bf59ff09757069092f06f96d17f85bfe4f5d35b1d98803c70ca5d62d435a68cb6b4a32c02c1ded28ee0030f75f709033598fe05e1bd61ec985312034a745d8ce1af4690f6021a093bfa70fae2c1f9d88b0fcd1f395ee92bf6ccea1d39be4a9b21a109bbb7b2c8a427046a98fba7e654bd3971b4ba040ebc65c4af729f7ad79b151df3bda60ac01f20f1042a7a3d4d9534a5836085d09a29d803f127208abaac2d6a9e39cb4e732ba8026d53627c94558c59ed0797c631d2a0507dd8045319e98b2d6dfc0c9af014cc223dde74446eb45dbb15cb6d25f6dc4b8735b8031b44a5620000e0677a576067a3bdeaf001d34800d48c3c72864bcafb14cacdacbeeb101a31786404c32d9fe3bd71bcdfc29aebd11f403a6238dff94c05bf676e9c57f994c23ac797cd2d0220a01478f780dec1a686b750a49ba3a0435ef646389368003dd6688a1999bf9c3af4eeb7ab5f28f3cfb91940f536b31885db3d7ef71bf67cf4fdc87b89dc8f4632b502f27a29385f5aa2c69643a2b64d8b1401cf8625dc425d913aaa9e7e5a53703b19c4f65c201985d257286f882577e2abb74716bfc9bef1ba173eb3c93fa4a03875d3bae3b4448ac266a236d2ce812263585942f944dc2d5e8a02f54d70dbc2ef8cc175f69905c9289fd4c9bf2d87ec6dc581d8c7eb6e4b6927f983a729f14578e630a017584648cb50c0f9a866271fcaf87c8f30a984e0fbd70b60637fd522ec2e48096bc30664c5d827e5e5b70d21a24c1445eac69874b47a0453e3466c092b677aaf0c7e123c310e4ddc4e607caed385016c155d3978edb7508ce30c3f8a681deb31456a5df36d859dac964ecf6cac1fbc7e233f990659984039762efb500197979789eb85f861b8901c9e8d70bd451e59294c9c075a81c43f99f6c246eca7da828b10e616d8c00b31ed07639b641ae9e5e3a1be2ae922961b96f2c94cc9d1524ab5faa37f875f2c969f114d1c4721d79add661fbd733a3c2d46de66b560ff5eb786de5a226c92fc8f119b5d58c6d825a07bfe3714b92babbfca0677a4d031fb8723a1c1163c83236b35e5b3257d2ffcd73dd9124af5be75da8563902a27718e338a7f84603733a9c7401f5b50894503191e69c1f7b1ec6b38c7c07eef4f13882c996c2f532aeab534da5f7eb846277c2e5077b859c81cb57edf5a6f46f30ba226880a45721e9bdb47a2ec7f7db4ab8b550b87b45371b11612e1667b9ba78bbf5b8ba9caf64a1ed461f19728351c4136ceb3f2cf314253fc50d8d0492378ea2683834f4ac2b74ab677ce068648fe79a49f409ff90b5793597785b9ad8eccaabd2997dcc8ecc4d7cca616fd47ff3f0cfc416dd13dec69cc4862781260e08b146f0e220a12f100a741301f5f5ad0c724374d0e916c938e5a2c3966292e20c4862cbadfe3a564dd974251e0c628417a293c82f466b4a2683db190fbe306dbea131ae0fab54769be6a84d05f87a00ba6d41f9ca5ec9645112570e90cf85266c1317331e661d7dcd5b4a86563ea8eeb82bcc3dab971b2c59b3ee50841871624a8628e8dd5c2429fbe9c8b19db6cfe581a2f2b5f3fd698bdc04ddc86cfe8bec70b138cac591994e6a58f4af9568468fa6908c3af74180044838f52abdd695f34ee6301ad661befc725cf03268ac2df538f9f6fd6375408f4488ca7082711089cb2f8bb8960c04894df51cc40e64e4b2911efdc17a312540b14fd7cb8bf5ad24aaf87428478400d07b6e8e0c79196a338d74acb5efc7d4dc045bf7f6e10808f8c65f05313f7aec0709180c45b5da0f728d7827f82ccf0a04c6c1d7002e898b36d9bbf7287ef2059308add3a85651e597c942ec496b0b38ae16b62fae3c066367227afdbb2eb508dd37ecfc4a69ce71adec3854c70fb5f1d7fa04db192af166fe2040c5d055f446ab7d3c7ff38bcebf5f5c9489574461ab74c6a7297896a9b7e868426c0d64220fcf7207d54b751fdfea750393a40fb778bcd0d3902616c471b807f3e94a273543710adf27aec6970e0a987624092260e42efbd721d5923a7fc431cb60859ea86e28476fefb4ff9c7a8e801e4d9c0ab99dd6656609bd6fd773e4a8bc0eae95634a88a3e1fa1c388fb2e684b442c85c8625d8b0ade7d8f3e56bf3ab203ea0890f20e58a0949ef33cfa1588252a50fa58c394f28150b8d1ea9c3e4a0bb06b08c01995dbc8980d59fc4a34aaeb46f46df8e3ac8c559932cf0b467b6fa4cbc5ef09b663ffb995029aaae2fcd8b237cfa8e708c07e7b3bcb3a5c05490e133b3525b660adc9ad1d5ac233bb50f403eceffd742629991a21baa34a91188ed095c24a28324a4b62efa977fe788be917533cc89f66fd918c59f463e0d073794936cb6b32dca6f9883574badc327b05ce8dc75630e404f732b8e2ce9e11c324ec2813f069fdb60b31bd0ba3cd74d4fdc12598a364f1e6e7a3c7574eeacc428bbcb1773b1d7097e06b0809d50dffe4347585e8f48baa4d13da0def795fb22b56ba27564947b8b8c27222f6494e4fb28835690fcf4d6477b3f6d2b8be7ff7375f07dc9d9353479db7ba7242cc514bd8a6335c835630bb5cd5b7f863d208923df8de6d3a1ab6b5d75181a473c2a548396153056710c60309d64b3284d983f37cbd08b131010a41b1baab969f7759e8c0f07de92fe9d5df4cb5c8f769f8f67cad153197f07146670ac8bcfe17b33df1cc7eb649e99cda3ee600d48f758b2bed2980e150e1ace5423b33e17c9ab849519fbf0abb7626880392d10438a362c61d5a9c226624f447af16bb7d7d8916b0876ac984ecc064d80c7d26e3e6e5fe75989a8a889a8e9b125eddc0481844e753ee5a727e392ec279eeeb3c589b19ece08fbf74357b557acbeda7d38aeec0bd335fed31ec502e467aee668b3acc8a92784186c53bcb5a924d45af813ed6f3e66e26e657e0eadcb60444ac0d97da9ff3141f9f95d66bc87f772ee6fc6b44d3ba8367429a037ed08eeee7a5a0e34088ce648affe7c03b6665eddc61dfacc3816e85980286a8ced27482a7297c50c513728326433054dc9a2a202b1cf8c5a8d6b3a6f670ffa052b93674529d47e5081b36789084157c8134ecc7cc9b27b59f61db9fdbdc794653289ea0cbb8c6cfcf1ef20326f1eaa1b6e52ed676e5daeff235344ed9f15735f8538f2a77e683caf3b1d795561d7533f4a74dfead682523863fc977ce2c00e080033423814ccec600ac3ec5c559ece019f6aa834a3ba59159354bc9821a9ac087b28b9de04cc17923842a1f7293da85ffd7f219f065016d29f83454841ca9d2bd2f04eaf29783d9de99e2d2bf31185958cc7b2ce59ba72cd2edf60709d2570affefd8a7e269ae8bf11299a8b0f39b4d3e3c422384601d8d9ac9d921cd9d67cbb5c3559ab0821ceb5799765dd1d1f449234819ac557ea77c3389888c1e207cb6b2e32bb52c610a44ce49508c3592150a6b139b5d31bd4338d47254b9a22fcf7d6e8904127493cd617297cad7b4a6e39c796be23869e073e64fb727379e7b4e34c951306117d66e346aabca3995a8432dade2bf9bbfae0d480e88462db6ff220639a373d949349fc6b6b45025f6afad39b58eeeb89c09782e8da06b93ca3b4b2308f652441596e40abc1a92b08ce012f26f55fd25c8fe052a6718c20697d8fb744a45ce782c3804039df40012e797831ae80f8803db045d2360c2745f11e8ab77fe598080347df577e55c3fce5b7d52918b0dd3392a8fd6d854a5e6dae0fcc399660ef37fb9a58b7150831f06c0413335ff58295ed970ee7d6c42b08e46dcd4082f24ef7859a77deec9568e5d6c919cd4a2d670a9736c1d2fb9741933fce43b6e1ee7cea0387a3a4c228c964f9cf02c5975246ddaedf99edf1bea086c2623f78366ea27e1a3b07997396e077edf1aa94c608560d8fa3277443da115c64027631fd58d050130621fcedb47e39e93bd47ec4f5c9503ad324b402d91ee86258b8937dcb6bce91f290fdb05bc2c2303519251c06d48edb77bb8b1ef35f14416aed25f2a5f505d5ff34dc6256de2631072a819833bf73f2fab0b1b955e5d734c97893d172612bf878e90ff2f5647d6b118d21362c0435d71c7f5ff21c1e11dec6ecdd9f33aa9f32ca1cbb7ea5fbc51ccc2ba5d189b46756346a9d818c87f224586f515694e2eb62f42825c727d544f8ac3f75bcdab88d941916adbc826207a2d7101ccd551df462e274942f07652fccddd754d861273b71ed68448198eb63d61ceb78b6da22f3dce70f778318f1a68110fbcbb99d865341849d465c7f408ed7247a2d24278e03ac8de7a714b17c9acbf63448724110058b0423ea71a2542b87224d9159d98587510bb4adf0969438153a8d8bab946feeabc7a26baffa3b5086cb9b195e256517a9e4885266be771e0887b24955d4cda82f55bd11d4d86595920631d4825c2ba89c59a19f5e6fdc0ec0b412aeba47b93d7608babc51a9306439e76c90e5873c940692b36284bd26642921b22cedecefd873fbbe5b805f3aa814a52bfc6a1b86b6e456a2016ba58a98fb98fa26613ea73bf86f602d0ba3641d4a9a77b803e1ac77c9f24ac6eee386e3394728800b495b063e8478247ef23bd5546c80acef91da4a1edbc0526007b12212c8838851e05ec9560c895a5b70e9c7240b9b4c00924c7186f8000927389e948d05bbecc096ae577bcb498c6f1acdc1344bef81036b8eeb16884a08ee193e5d443ecbebb1f6072d8c0137b56256b3c4fd5d77422f1cceb6427ee7b10881eca48dfcc4f41a8b2024d08cbab70b1c5e20a331f467d7418b99d763fd9532683424496dede7d4c955894076d35702e1901b343419ec27adbdcc30f3bdf16fa0f56372e016311ae8f60f571aaab2966ac5ef03929df28f1d5eff5981f7e62a98a9e8ebad7d19aa7d9d764b3816974a8d4213ee242bda1ff3ce2e3bc8f062c9180d050d9dede7549e55e29590cebe9b6c7792ea517baf54655a9254188faed45cd0f06862afb788a785bac9d77b524ff8c6a1fd42d0ab95a0224b1fa189527365f478029ba9b513442646022e454ccc823c8d28c9cc1f1b1c527a7613da78e475f8081b187920944c81e9064bccef699b235e895d1c33f94de8c79280ab0a97178b537fc243a1b8e7fa7ac83ce45edb3df20bd2c2935508c806b58a7d3d9283f1ebfb7e65c4cf54056b869c01a0dfa6e6f81a01292c60d516b33b7afaee1be049cb7390b01985b7919a09ef832f7e60f7c4e95d4ff351bf94e02d7c6deac8a930dc9ad34227711083b3f8f97303a4e065987b15ff23c75d1afb8f7dc82cf2252523e2dc6a8767b84630f022b7a591c200a1950911608eea6125fc3dc176b916ddbbb839906bef52199a9e50f48d2b6a0ddede86301215f9b01040bace31a00b33f4122f62120af90eb2b0e418e851f472a2852b60ec73d378c028f37169775ad2b8105adcdd0f7da01414f8169637df8ca93d2151a4f7c92a5f32a4516fac291f8fafa360b7a4fb2d19eb55cefd3a5b3dbabe05727d379ebc68a790fdc94f8e83acb4db9f091c3efa52f5d9ab45a1512ab188712c459f081347d2291abe8009e79f51666957345cb8a070861227fa6572ce78c8c175bc3534a9c6611e0d02927af1b76822c3be37387deb1f9e53cee0373a089b7b5383c6337da148d3c51919bb15a56a9e74d5a799053536dee3f91e95fc879594c52b6e947883974e5ed8b68c43bbb77f368c49516f81321ca330593152f9ce73cac8f457a3476b5b003ce5f4a152dcfd7755d5f01785e19373b2bbf691bfaa8a1d5da65d7b4a039b27af6ddd92e0624c935fa6bcc5dc37439d1c8021a5c1f6e0443cb1787383176b5690b1437adeada3c5cd22200c326cd4a974defe487b34c5d7d6ff2c1f598352c044cd2d0d1a32af87361aa723f04b60f8f71ec9f8face6457c012779cb36a636bb5ecdf6d3c348c3e84d2a4f37208713e9d9598888b7fa4b50da58818266e0e018a33b039a50a7f787a536e96493955e2f4ffdc730efe483d0dc5853f54f940ab912908f2f66fa1f607a1f664a0b32f61223cf7763b5a542e7fba980714cdfc64a7fd4fb333f097533a51e2140c161dab4409f0094b418c5e933230e0bd86dd4819ccf95de1696b70a9868c20771bbd868b4932773cbb062510d6099b97156c283739186759ac1a0bf1c88b2137c9cf5a26e5ca6c6cd54c7adb9d9f583f6ee5c5d3affc2be3d798e47d835b70ae98bc2b9258249d3ce9928f354d9a9148eb6cbc6f57d16d71fc548a7a337a0eb352bfe42b2cd1523c3fbffa9a69c306937dd1996131dcbbebb8cf40f2600e780217415ce0dc18d24176b4997c3d60f930454aa50a0ab8b2681ef7e9f204ced9590ae559809416bf4072d1678d8c8a4f4b8aa87878f48676f119e037e8b98d6a8c9f2e6f814349b4465d95f96ec6bebbe6d9a5095143f29830da5d41750bf4e0f2ad1eb2ac3ba3a9ddeed4c26531806535f3344d3119c44afb7faf46f727d54a94f57e2adeee2a6c0fda343635c3901ef0720062464e5954df382ade4a4d103a3c022daddfacbd67bc8806fddc2d0dbd6990a898d0dc1f00ffa46e4dde4108dd5d8d006a925e3bfed62e21bbcb0bac84126b3eb1290889d3281e68faa3d73b788a4f0808e8dd8efb33170ee55a2bd6f8c14201e64db875a2e5963cf1256cebd4eb87cf2b0de944cb7b25cf1b4cef49c4ee5555d789fb9948021516b057168571ca69228e59a1394a1df5f4b78d0d86293fc0ee61265d41d87c07c2f4bfb716d1a87f414d66775efa8149bcf839d585709f9f9b7caf24ae6ad4307178707300ca35d52ac10a7fa0fe6ed8d655de254ba8c9a9a48c9c26429bdd9b2349aee7be55149ec1150a829d874b9e4c0d96f9e5ae1a26eebee067d7b73bcadd85ff47afb60647c56cc93876a82518f6e7a09c94558430ce46b00510191fae629e9f03ca7be981615245d7939ad9250e2f9dddcd3f9147280b61c1d1bbf75a250bc0b2ea9c5bf82db99a81a8c00fc4d05d1cf3758d35bc6c3ce49a887e1a237093dfc284ef10d5b265e7a7427a2a9127949e713ed2a2a7329099537e22bc983b310a6a881b0beb46fa9e27dd4864fa8e76cd9275684a60f5038e8e9934ef734630ae7bb3536da2f350d3e626fe49aff77cbf44b3343152c3bc114c9866f4e67283bbb509816738444df6c80840ae2e6c0b4c703cc7076abdadffed463f161c1fc751e3760c9895122180248a37d417834ab6a870894956c584e5ee9ba66074a54ecbf6a2430b4aa9a989f1d9407400c475b4d2c02993de5432c1c500e419f8e70893c9b66a7ebc609efe52bd15224234cdae3246e43d3ce7f885b869c17115361ff1b7a4b9685c381356a745ae33f3a0b86d50587d762865c8c5da7739263e1ad97d9e7af71f23df9e209d8ac545817bf5ef40dd22d915faa1aaaa98aa6e51d417dc81f9bdf711bfd4d63c904503ef12babc8502ebf60df5b83a86a3ae904e06b73656832894e2c373d766ba7b0fbf82f981abf35c345be081fceb57d2ee8afd9addc962fb123188d876c79196b8e92fe6c8b62e3b33b6b36381cb706ec968e8556dd0134aa1f456b23986153771781435d010b56a390ad900aaf7e8dca5dbbaea4b631b850831b01ba5a4ebb530ca53ef29d2cff9217284bb9486d2ec8b6d435e10d8a466e4d50f3475c0b57782b0f023421c75150a3b4ba879fa82ce0948ee1130b9517869b27a97d220160e10330628e593fd9f8d52f05ef273562817acff81ae29204b862cda87f04ad55c8c54e50172b8a334a8bb90d565c81afd75bb55225aafab351be1c33d40f0f8ca162ad252014863fb50fcf5b973d6206b3ce1f15e364657bea522929b8d47ac45ab2d438c27c97859e64f3832f592d9fa5993add01e159f3f70412966b7fd55bb84ef31eab1aa29064203170093246c12f02174674e163717b23eb1dec63b453547e4350a97cab4a5bfa90ca369b836e60414c5a51c4f957b3001f38430b07f85e8ac0c34bf4a954318c8c47e30845c4d0d784df53adfd5a182c70354d9127a6f1d3e98244d3dac6a6478647b609fdd04a42270a981f348e10dc6912e7b78e65747043368265e98b0580e2fdccd1b2338a6427935b7f3f3a0690d0ed347484d887b7853d254aac86515fc9490bb18c428ce1fed55feadba1b5276d84246a9b60de2508af3302a4097d38834126444b026616f940d94871de3bf3c3af6531c3b1094ffc6ac1121a800536bcaf4edd2c7441332de711ba0bdbeacebf6c5356199fdd36654579dd39adcf19fe0193e8a6b15da29e716d5f793438c38d527afbd39c1917710dd032adc6f8983153f3a60648d83a4c26e6ca74c3581beb743b2645090dfcc25f7b6107e198db6b4701b944361cf18e708f052e02cc418b0aeb067c370b5fe0cc708b1bf54909eb7da48e12533941127c18f8bfacd27dd7f9b2fa876499b2286f37d4cf436e3ee9c4e55287fae3375961a0034105d439d2209964266af823873dfcc859604201bed4c5b822f536e46099a8637b00cdae98024fff76d4b5047802db3d28a7d800a54da8b7031962fc225f8fc84634429fdfb729d657828fbf71aa54ea2dc3e1bdafd013f662e8ff322861c622a935bf5728bd6390c1a95ef8ad9a74612a0bf34ef56fe81b516beb5ab0dac40e83d2833903bce0bda8c1dbee89066cd442a05aa9bdef1cbf8ac43eadd70874987c9c29c0bcb1c88ed066d89346dbe362eb280bbde2a72e774ea2758c9fc942e2376d790149a0876cf98c79260ad20aad8c9d715cc0e265a80857a3fd3236e56728bb6c414fb1aa762ff8882cdb2feba3b102bfd7b2f54e205bfbbe4da54cfaebdfbf710d4fbc86eb25595f2423aaca53fe671447d67c69dce000694c0699a142ab37df0619af280649df7bafab15870f410c17b8a45456c8df8fca252f8dc7551a637dabd235f1e3c3877e87550b340fa25aee01ef79fb402631d0dbe5532d0036bbb3ab2c267c0f8ea10c7844bbc95387b03ce36e774b1e526bd0238188d7e32d754d14086b387b4ddac389efb7027fe3a5b581ba8ea4c6ebed6ae4173a546279ad07f4b65253fd3379c87fe5611979073478b8afd543e84c9241824045a6cd2430c8d74820dce23ec5dc872cf245ccdaf6fddfeaef7754132b32d7730e831bccb0f26d7e5d7730d6b3b6f7f84937d2fc62b33b31263adc94e68d2baa99d47557dace7b16f9f38e3452e3641bf93216a3eac6e9db30c263e3096ef8d956a7f1dda845e747c4fa9fb760dfec58d83737038b79552d2867a676b8873b9f7103253757d720f66a3bbb37e2fe7c0278789cf987bb8c321814081533bdf6e09b2ad2a2f46e9e9443ce6adf3349546026d158ed9f516aa6669e8ff762c45a7e56c64c9b843318ad9775d08ec2b85ececf8b11343e18d3e8eff9e630c647bfda6c99690a7fbc7ffa56164e7f998ba7656fd190ef8d13e910eff56eaaf8f67834deeb960bf3d6178829c4b451e7c90b0d109409c76fa733f0a2f0daefcc3616788b8fb3395f65adc6fe6e7856e408f6c31d9836252c7f54092fc6941c289775ddb3575c6687f9e82f135465c05b81257ed65a5db9e1c602dc6ff7fab32c2c997d0bbd82dbac3f3a45ab1632eeaeb9f9498a3765e28a4831dbcabd95b3fd615890ca48609e90e48650cadfb2102d87e57cbd6d32d6e557bbb0b59bfc943d5ef9b02cce6851dfc27168305d925efcc70e071e4edd1c67f698444cfb589d5bec0d9e591db5e4bf43a634108fc6ee0234f71fa51b20e5277d27f6513416c1c796661423ae7359c7aba0fd545f56d8aa5998b1a59ea15862fa1c4881a71be744c45e8eb19b02bde7636fb3ec63ee0c952db70371f270adccb18d904028d9012b0e68ef87d8d7c86d884f29ad31e2e40ed7d2430dfbb328cf99bd9afbe7940567470cbdcba2d9855a34f0b2e9fd05dae7c93cc40c20fd2825f40872743d2535fb1da7bb1b306086607fa768d98364b146c124f9020aed8f998bd2da23d2f45e81d06606f34c774aa92d0abb5e1bc28e269ba0df8887e3f33634e546cc01e5094e4f88e740abaade989bfbb1cc8751455f75a97f5aa2e5437593d2d169217aae93fff375bc77d7cff440d3e69d5f270478dd2fcfb4f509be4a355507dc243754964b672ac4079b52f5aff9dab526691fcb0cadab93d6cf782369644aa99bc001d083598f845fa17577db3154dfc640e7321ee0d6b9db4b5797ca84d8facf6c4a3414aed6861fc5aaca9e48753b5104252bbf68512c0f9ab8309176ad69db3e52d72aa41b9812010d967de3843fe056bc622fc91d12fa88f0a11aa5acd757597e3e23d850a7b1e64217b1be6ef08848654daa976c4454b2c38af2aaec153804e62217d67b0f80dd3119f81a5a7e87eb243f98446dd6a0e10a09cd0f2f8ccdd36c8203c6324f2751a569199a81d120b610c1c0141aad29e5dfed36e0875e48dc793bccd2ab744c594d62b4ab6f6919142c26dd41540ec30146c3e85862ce6e4e4d7a5ad5e75fad7513ebf3f591b7046f2e42117101a9ff92092c9628d158091d3cf6d293d6cf922c1c28cc68187163dcbabde66544b28cea6f76722ee8d5b6edec899529e22dbdf494e44a1eb62a9975a0036c57bf92173e795504333d372ddac4ea2c5a7110dcc536c545168eb74ea7ffad60cc82f2143b401e728def3589c9513d0884e5db326d7081509ca7f6e9c7be7fe97686e9e04a4b8ff48ab5255b396bf01b604c5331899f199ee71a05e99ea31460485e4239b41e9632b3c2adb1039cd4f4bf8dec2447b29117f2a18c3074f2af5c15b8e8b3eb8bf161729c6648da2c40c755cccc422699da51be8c8fc166f3b3a852277fabe7d4553ad6af1e7b8b69314c3b74d3ace12fc4c48dffde3a4c87ec286f6f74bdd832f4596873367e69e0df35cdb6ced4acab65b475c5f8c89fad5c58a62f49df598a4290fae787010e0bfc10d68685b4cf54b352e8e83d44847fca7b48a615b61118f96280733a2d74884d4ada9f612bdfe91cd6ef4e3e9e8ede1eee52d851a895e927b8b072b45095128a5638f48befb0fa594a64cd894690bbde3380a558c30063d16b91fdd81b3f854798ad4d2a1b3b59cab35b1052e683f195b3ca8f4c12a7c90f0f82a754ade51a8dfa9f2af75aad4415eedb717f5eb5d071752f1148ead5a36cafa6dca8ecbcc053e0e706e753b9c9846f8a223f4e5fc5076ba1eec5596ce25e4995c392d085dae976da0affe9ef66cbb2b1eacce7d06188c29b4ab311df3d73e2af3576aea737ef7d781dfab5bb8ca4f95f3af344b3f3349ee6fbf1d24f1941e784cf065affc47af24c222e5d012afb52395d39d560e0038807de3ee7aadebbd5f944c41b6c7a41192902f0121c2d50a7d73c659b4c3dbdd6f30c25ffd593fc78c940210b446aeea83743ba14ce6e2d4352032f14e9213f890c4117fb3003d93cbdfd6e87457bf41b79d37e9029536ba377fa1c88b754475ce703983da4edb15a4e6cf4b1e50bc6ac0ed36a45e480af4041c3ed49d1ea8555a82b864bf50c17a3759c7f4242a031735a8896ff805b32e35055e13fb23991a4871b06e0ac89c8191018d477cf94250de026e0e11dca6db84cf93bf2c104c29fa41c47abeb908f93e35855992eee810814a50b263d260670a1dd0596ea5a22877871f68d086ff5608830bf4000687dee3cbcc039d37db04f5ef47556b9547757cc7fde839d63d1a6cdad7852c27f406318eae5505967173d7871740a1d0aa1124e9e145574e20810898efad909f2f6c015726562169f0175bcbbc94d6a12b2db79655b3c032f969ac21361393026f3da0eddb26dfd016cfdd8f3a7e41fd4166eb50baa113994a555f8737cd763a85bf075792c68153d05816831e47ff54eb1451d21a78a8147c124dd88a29da13223f00909b35f6903f4193b486855c378e3de9303b2a001bfe59a658e7db6954fa5ece47e6e8f89229b6ba0625bfd916c7b7c83506d88eb0a2c1da4531803e85d3a489c2c03db47dd0f3dd989ff2708c9771cb7c1e63517afbc559ce7210d0d4d7bf15db543f5ccc0c1e1f4e3e5f3d7eeaa1f92d703b4536aa4a63120855230535b41f862e522a46438a71bc967cd1ecf27d3604e1e1224e4e63248341400369807244be856afa1e361b2c7898b07a7b8ac05d3a20cc7dfbb735865ca3ef43f8fe97dcb596f98b75c35ce38be742c798e01b4698fb4c9993b206a321775f90ab3741fd586cf950745c562050142c2c60986cda6f56d22afe5634d40aad4da66efc0b47bc6a6fa47ddcd9562a4d214e7e97f02db53b62ca07812879f73a870e71629e93d4f47a18d193b8ed1a70e9215ffdd0e6e65e615bcf9c43d7e3099210899e3ba9acfb39027adc3d24adc0b73cb57431b31f55a1d29dda08a6786b0913a2436e08101d4c11f73fab76e973ac69ccf270d27a303968d893b61f15314bf42ee9d1f8ac7ac3b3467770cd266c0965de2ff72ff1d53d2134d72ba03ec670053aed36f90151cd3b9f31a986d4c02a02042f3c7232911bd6650801fc7b5a239e7bf41949d60f6e5912a334c7049844b2b24c8e5caa130ab3186e6eba8581d2a695197d5e61f4f55c50856dff4a64a12c88033817aad003cb161cc46a38b18e7f17846937de0c1192f28707b87331bd6afc4564dd575fe3445cedfe995d3ea84fe1641f54b2793798a4272913aca4678</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>学术科研</category>
      </categories>
      <tags>
        <tag>科研技能</tag>
      </tags>
  </entry>
  <entry>
    <title>信号与系统概念本质理解</title>
    <url>/2022/01/27/signal-and-system-essence/</url>
    <content><![CDATA[<h3 id="一、模拟频率、模拟角频率、数字频率"><a href="#一、模拟频率、模拟角频率、数字频率" class="headerlink" title="一、模拟频率、模拟角频率、数字频率"></a>一、模拟频率、模拟角频率、数字频率</h3><h4 id="1-模拟频率-f"><a href="#1-模拟频率-f" class="headerlink" title="1. 模拟频率$f$"></a>1. 模拟频率$f$</h4><p>包括在模拟电路、高频电路以及传感器课程上，都是以$f$作为频率响应函数的横坐标。使用f的好处是其真实反映了实际系统的工作情况，从$0$到$\infty$，反映了实际模拟信号振荡速度的快慢。  </p>
<h4 id="2-模拟角频率-Omega"><a href="#2-模拟角频率-Omega" class="headerlink" title="2. 模拟角频率$\Omega$"></a>2. 模拟角频率$\Omega$</h4><p>$\Omega=2πf$，写成$\cos(\Omega t)$来描述模拟余弦函数。此时$\Omega$的取值也是从$0$到$\infty$，这体现出模拟(角)频率没有周期性的特点。</p>
<h4 id="3-数字角频率-omega"><a href="#3-数字角频率-omega" class="headerlink" title="3. 数字角频率$\omega$"></a>3. 数字角频率$\omega$</h4><p>$\omega$完全颠覆了我们过往对于频率的认识，首先要明确的是数字信号的获得是通过对模拟信号采样的方式。</p>
<p>它的引入可从$\cos(\Omega t)$开始：$\cos(\Omega t)$中相位变化一周期($2π$)所需时间为$T$，则模拟角频率定义成$\Omega = \dfrac{2π}{T}=2πf$。对于该余弦信号，采样后变成了一个离散数字序列，此时再谈过了多少时间走完一个周期已经没有意义，而是过了间隔$N$相位刚好变化一个周期。故数字角频率推导出为$\omega = \dfrac{2\pi}{N}$，余弦信号则为$cos(\omega n)$。既然$N$是由对应一段时间$T$采样而来，那么$N = T*f_s = \dfrac{T}{t_s}$($f_s$为采样率，$t_s$为对应的采样间隔)，自然而然，$\omega = \dfrac{\Omega}{f_s} = \dfrac{\Omega}{t_s} = \dfrac{2πf}{f_s}$。</p>
<p><strong><font color="red">简单来说，数字角频率$\omega$是模拟角频率$\Omega$对于采样率$f_s$的归一化，这是数字角频率$\omega$的核心要义。</font></strong></p>
<blockquote>
<p>注意：$Ω$和$ω$具体哪个表示模拟角频率和数字角频率看具体的书籍，理解这个意思就行。</p>
</blockquote>
<h4 id="4-一些涉及本质的问题"><a href="#4-一些涉及本质的问题" class="headerlink" title="4.  一些涉及本质的问题"></a>4.  一些涉及本质的问题</h4><h5 id="1-如何理解数字信号处理中傅里叶变换的周期为-2π-？"><a href="#1-如何理解数字信号处理中傅里叶变换的周期为-2π-？" class="headerlink" title="1-如何理解数字信号处理中傅里叶变换的周期为$2π$ ？"></a>1-如何理解数字信号处理中傅里叶变换的周期为$2π$ ？</h5><blockquote>
<p>分析信号的频谱特性时，经常要对信号进行傅里叶变换，但傅里叶变换是以$2π$为周期，而时域里的信号角频率的范围是很宽的，为什么傅里叶变换中的$0 \sim 2π$就可以代表信号整个频率范围呢？</p>
</blockquote>
<p>1、模拟信号的频率：模拟频率越大，信号变化越快。拿构成模拟信号的频率分量来说，比如$\cos(\Omega t)$。</p>
<p>2、数字信号是对模拟信号[等间隔]抽样得到的，即$\cos(\Omega t_s n)=\cos(\omega n)$，$ω=Ω t_s$[称为数字频率]，由于<strong>离散[数字]信号的自变量<font color="red">n是整数</font></strong>，因此数字频率$\omega$与$ω+2πM$是同一个数字频率，即：</p>
<script type="math/tex; mode=display">
\cos(\omega n) = \cos[(\omega+2πM)n]</script><p>因此对离散信号作傅里叶变换，实际上是将离散信号[量化后就是数字信号]分解为$e^{jωn}$的线性组合，其频谱就具有周期性，频率为$\omega$的频谱等于频率为$\omega+2πM$的频谱。</p>
<p>3、再来看$\cos(\omega n)$是构成实数离散信号的基本信号，它最大的频率是多少呢？周期最小$N=1$，故变化最快的是$ω=π$；变化最慢的是直流$ω=0$。故$ω=0$频率最小，$w=π$最高频率，对应模拟信号频率为：</p>
<script type="math/tex; mode=display">
\Omega=\dfrac{ω}{T}=\dfrac{π}{T}=\dfrac{f_s}{2}</script><p>即为采样频率的一半。对实数离散信号来说，$0 \sim 2π$的频谱图是以$\omega=\pi$对称的。</p>
<p>4、由时域采样定理，采样频率$f_s$最小为被采模拟信号最高频率的2倍；故可认为被采模拟信号最高频率为$\dfrac{f_s}{2}$，这个频率对应数字频率的$π$。</p>
<p>5、实际中即使模拟信号的最高频率是无穷大，但是可以通过滤波，滤去无用的高频分量，再对他抽样以避免频谱混叠。</p>
<p><strong>e.g.</strong> $f_s=1 \mathrm{Hz}$，$\Omega$分别等于$\dfrac{π}{8}$和$\dfrac{17\pi}{8}$，得到如下两幅图。可以看出虽然模拟角频率$\Omega$增加了$2π$，但由于采样点数和采样值都相同，所以实际的离散信号是一回事。 </p>
<p><img src="https://pic1.zhimg.com/80/v2-f23a15fb4a8a85a2c9885597f2d54a70_720w.jpg" alt> </p>
<p>正是因为数字信号对于$\omega$具有周期性，DSP才增加了额外的很多考虑：</p>
<p>1）DTFT、DFT是将数字信号从时间域$n$转为频域$\omega$，因此我们只转为$\omega$在$[-π,π]$区间内复指数信号的叠加(也可以考虑$[0,2π]$，不过由于$ω=0$和$2π$是低频信号，$ω=π$是高频信号，考虑$[-π,π]$更接近模拟信号的频谱分布)。</p>
<p>2）我们根据$\omega=\dfrac{Ω}{f_s}$可知，从模拟角频率到数字角频率不只会落在$[-π,π]$，若转为数字频谱后其频带占用超过了$[-π,π]$，则由于具有周期性，相互之间会产生混叠。我们要把频谱$\omega$限定在$[-π,π]$，则由奈奎斯特采样定理可以知道，$f_s$必须≥信号最高频率的2倍才不会发生信号混叠，因此$f_s$能采样到的信号最高频率为$\dfrac{fs}{2}$。</p>
<p>3）在运用频域采样法设计IIR时，我们基于的AD/DA转换就是上述的$ω=\dfrac{\Omega}{f_s}$(双线性变化法则不是)。上述说到模拟角频率$\Omega$是没有周期性可言的，但是由于采样率的限制(离散化)，导致说数字角频率$\omega$具有周期性。从映射角度理解，数字角频率$[-π,π]$在模拟角频率上的映射是一对多的。采样间隔$T=\dfrac{1}{f_s}$，在给定$T$时，数字角频率$\omega$受到的影响来源于以$\dfrac{2π}{T}$为单位的模拟角频率$Ω = \dfrac{ω}{T}$）。为了使数字频域不发生混叠，我们需要将模拟角频率$\Omega$框在$[-\dfrac{π}{T}, \dfrac{π}{T}]$，这在设计高通/带阻数字滤波器时是复杂的，如下图展示的用频域采样法设计高通FIR时所需要增加的裁剪步骤。 </p>
<h5 id="2-如何理解数字频率的归一化？"><a href="#2-如何理解数字频率的归一化？" class="headerlink" title="2-如何理解数字频率的归一化？"></a>2-如何理解数字频率的归一化？</h5><p>频率的归一化与幅度的归一化有不同的出发点，主要是在数字信号处理中，针对采样频率进行归一化，归一化后就可以在数字角频率$0 \sim 2\pi$下进行分析和讨论，这样做的原因有两点：一是类似于最大值的归一化(此时的$2\pi$对应采样率)，二是采样后的频谱是以$2\pi$为周期的。 </p>
<p>数字角频率是模拟角频率对采样频率的归一化，很好理解，本来模拟信号一秒钟变化5弧度，抽样率为$5 \mathrm{Hz}$，采样后信号变成每抽样点变化1弧度，这里“归一”成“抽样点”了或者说“基准”变成“抽样点”了。 </p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>参考链接1.1：<a href="https://zhuanlan.zhihu.com/p/53664104">数字角频率ω与模拟角频率Ω的理解 - 知乎</a></p>
<p>参考链接1.2：<a href="https://blog.csdn.net/jyfu2_12/article/details/78650858">模拟角频率和数字角频率的关系 - CSDN</a></p>
<p>参考链接1.3：<a href="http://www.360doc.com/content/18/1008/20/38894361_793066968.shtml">如果理解数字信号处理中傅里叶变换的周期为2pi？- 360文档</a></p>
<p>参考链接1.4：<a href="https://www.zhihu.com/question/65441510/answer/298234811">所有的傅里叶变换之后的频域信号周期都是2π吗？ - 尔尔的回答 - 知乎</a></p>
<hr>
<h3 id="二、傅里叶级数-傅里叶变换推导"><a href="#二、傅里叶级数-傅里叶变换推导" class="headerlink" title="二、傅里叶级数-傅里叶变换推导"></a>二、傅里叶级数-傅里叶变换推导</h3><h4 id="1-傅里叶级数"><a href="#1-傅里叶级数" class="headerlink" title="1. 傅里叶级数"></a>1. 傅里叶级数</h4><h5 id="1-傅里叶级数的普通形式"><a href="#1-傅里叶级数的普通形式" class="headerlink" title="(1) 傅里叶级数的普通形式"></a>(1) 傅里叶级数的普通形式</h5><p>设信号的周期为$T_1$，对应的$\omega_1 = \dfrac{2\pi}{T_1}$</p>
<p>周期函数可以分解为三角函数系的组合：</p>
<script type="math/tex; mode=display">
f(t) = \sum_{n=0}^{\infty}a_k\cos n \omega_1 t + \sum_{n = 0}^{\infty}b_n\sin n \omega_1 t \tag{1.1}</script><p>但是我们见到课本上一般是下面这种形式：</p>
<script type="math/tex; mode=display">
f(t) = \frac{a_0}{2}+\sum_{n=1}^{\infty}[a_n\cos n \omega_1 t + b_n\sin n \omega_1 t]</script><p>将$n = 0$单独分出来化简就可以得到下面的形式，我们就以课本常见的格式求解系数：$a_0, a_n, b_n$</p>
<script type="math/tex; mode=display">
\frac{a_0}{2} = \frac{1}{T_1}\int_{0}^{T_1}{f(t)dt}</script><script type="math/tex; mode=display">
a_n = \frac{2}{T_1}\int_{0}^{T_1}f(t)\cos n \omega_1 tdt</script><script type="math/tex; mode=display">
b_n = \frac{2}{T_1}\int_{0}^{T_1}f(t)\sin n \omega_1 tdt</script><h5 id="2-傅里叶级数的复数形式"><a href="#2-傅里叶级数的复数形式" class="headerlink" title="(2) 傅里叶级数的复数形式"></a>(2) 傅里叶级数的复数形式</h5><p>利用欧拉公式：$e^{j\theta} = \cos\theta + j\sin\theta$ 可以将其转换为复指数形式：</p>
<script type="math/tex; mode=display">
f(t) = \sum_{n = -\infty}^{\infty}C_ne^{jn\omega_0 t}</script><p>其系数为：</p>
<script type="math/tex; mode=display">
C_n = \frac{1}{T}\int_0^Tf(t)e^{-jn\omega_0 t}dt</script><p>其中：$\omega_0 = \dfrac{2\pi}{T}$</p>
<h4 id="2-傅里叶变换"><a href="#2-傅里叶变换" class="headerlink" title="2. 傅里叶变换"></a>2. 傅里叶变换</h4><p>对于非周期信号，我们可以将其视为一种特殊的周期函数，只不过该周期函数的周期$T \rightarrow \infty$，据此，我们做以下变换，将傅里叶级数转变为傅里叶变换：</p>
<script type="math/tex; mode=display">
f(t) = \frac{1}{2\pi}\int_{-\infty}^{\infty} F(\omega)e^{j\omega t}d\omega</script><p>其中，$F(\omega)$就是$f(t)$的傅里叶变换：</p>
<script type="math/tex; mode=display">
F(\omega) = \int_{-\infty}^{\infty}f(t)e^{-j\omega t}dt</script><h4 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h4><p>参考链接2.1：<a href="https://www.bilibili.com/video/BV1Et411R78v?share_source=copy_web">纯干货数学推导_傅里叶级数与傅里叶变换 - Bilibili</a></p>
<p>参考链接2.2：<a href="https://zhuanlan.zhihu.com/p/96521358">傅里叶变换系列学习（1）——从线性变换说起 - 技术派到了中年的文章 - 知乎</a></p>
<hr>
<h3 id="三、拉普拉斯变换、Z变换"><a href="#三、拉普拉斯变换、Z变换" class="headerlink" title="三、拉普拉斯变换、Z变换"></a>三、拉普拉斯变换、Z变换</h3><h4 id="1-拉普拉斯变换LT"><a href="#1-拉普拉斯变换LT" class="headerlink" title="1. 拉普拉斯变换LT"></a>1. 拉普拉斯变换LT</h4><p>不是所有的信号都能从时域经过傅里叶变换到频域。必须是满足<strong>狄利赫里条件</strong>的信号才能进行傅里叶变换。</p>
<ul>
<li><p>狄利赫里条件</p>
<p>函数在任意有限区间内连续，或只有有限个第一类间断点；</p>
<p>在一个周期内，函数有有限个极大值或极小值；</p>
<p>函数绝对可积，即$\int_0^\infty |f(t)|&lt; \infty$；</p>
</li>
</ul>
<p>为了将绝对不可积函数可以进行傅里叶变换，我们引入一个衰减因子$e^{-\sigma t}$，将傅里叶变换推广到拉普拉斯变换：</p>
<script type="math/tex; mode=display">
F(\omega) = \int_{-\infty}^{\infty}f(t)e^{-\sigma t}e^{-j\omega t}dt =  \int_{-\infty}^{\infty}f(t)e^{-(\sigma+j\omega) t}dt</script><script type="math/tex; mode=display">
f(t) = \frac{1}{2\pi} \int_{-\infty}^{\infty}F(\omega)e^{(\sigma+j\omega) t}d\omega</script><h4 id="2-Z变换ZT"><a href="#2-Z变换ZT" class="headerlink" title="2. Z变换ZT"></a>2. Z变换ZT</h4><p>离散数字信号域的ZT相当于连续时间信号的FT，其也是为了处理不满足绝对可和的数字信号(e.g. $ f(k) = k^2$)，因此我们给它乘以一个衰减因子$e^{-\sigma n}$(另一种理解方法，让离散复指数乘以一个放大因子，不断变大，就能跟上信号的变化，从而降服信号)</p>
<script type="math/tex; mode=display">
X(z) = \sum_{n = -\infty}^{\infty}x(n)z^{-n} = \sum_{n = -\infty}^{\infty}x(n)e^{-\sigma n}e^{-j\omega n}</script><script type="math/tex; mode=display">
x(n) = \frac{1}{2\pi j} \oint X(z)z^{n-1}dz</script><p>和拉普拉斯变换一样，z变换也有<strong>收敛域</strong>的概念。 拉普拉斯$s = \sigma +j \omega$ 对应的是直角坐标是一个平面。 Z变换$z = e^{\sigma + j\omega}$对应的是一个极坐标系是一个圆。 </p>
<p><img src="https://pic2.zhimg.com/80/v2-b0771ba027e7d23fed45975f267bb407_720w.jpg?source=1940ef5c" alt> </p>
<h4 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h4><p>参考链接3.1：<a href="https://www.zhihu.com/question/22085329">傅里叶变换、拉普拉斯变换、Z 变换的联系是什么？为什么要进行这些变换？ - 知乎</a></p>
<p>参考链接3.2：<a href="https://www.cnblogs.com/taigacon/p/8313482.html">离散时间信号处理学习笔记 - 8. z逆变换 - 博客园 - TaigaComplex</a></p>
<hr>
<h3 id="四-、DFS、DTFT、DFT、FFT"><a href="#四-、DFS、DTFT、DFT、FFT" class="headerlink" title="四 、DFS、DTFT、DFT、FFT"></a>四 、DFS、DTFT、DFT、FFT</h3><p>根据前面的学习，对一些信号采样然后进行DTFT之后，得到的信号在频域上还是连续的（也就是对于我们归一化之后的角频率ω还是连续的，是以2π为周期的，以π为对称中心），这样对于计算机来说还是没有办法处理的，所以再在频域内对其采样，采样之后的得到的就是DFT。<br>DFS是对于时域是离散的周期信号来说的，DFS与DFT的区别就是相对于我们之前时域连续信号中的傅里叶级数与傅里叶变换。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">变换方法</th>
<th style="text-align:center">时域</th>
<th style="text-align:center">频域</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\rm{FS}$</td>
<td style="text-align:center">连续周期信号</td>
<td style="text-align:center">离散非周期频谱</td>
</tr>
<tr>
<td style="text-align:center">$\rm{FT}$</td>
<td style="text-align:center">连续非周期信号</td>
<td style="text-align:center">连续非周期频谱</td>
</tr>
<tr>
<td style="text-align:center">$\rm{DFS}$</td>
<td style="text-align:center">离散周期信号</td>
<td style="text-align:center">离散周期频谱</td>
</tr>
<tr>
<td style="text-align:center">$\rm{DTFT}$</td>
<td style="text-align:center">离散非周期信号</td>
<td style="text-align:center">连续周期频谱</td>
</tr>
<tr>
<td style="text-align:center">$\rm{DFT}$</td>
<td style="text-align:center">离散非周期信号</td>
<td style="text-align:center">离散非周期频谱</td>
</tr>
<tr>
<td style="text-align:center">$\rm{FFT}$</td>
<td style="text-align:center">离散非周期信号</td>
<td style="text-align:center">离散非周期频谱</td>
</tr>
</tbody>
</table>
</div>
<h4 id="1-离散时间傅里叶变换DTFT"><a href="#1-离散时间傅里叶变换DTFT" class="headerlink" title="1. 离散时间傅里叶变换DTFT"></a>1. 离散时间傅里叶变换DTFT</h4><p>严格来说，<strong>DTFT</strong>处理的是离散时间序列信号，这种信号在时间上是离散的，但是信号的幅度是可以任意值，也就是说没有量化，还不是数字信号。非严格的场合，可以认为它是离散信号，并且是非周期信号。</p>
<script type="math/tex; mode=display">
X(\omega) = \sum_{-\infty}^{\infty}x[n]e^{-j\omega n}</script><script type="math/tex; mode=display">
x[n] = \frac{1}{2\pi}\int_{2\pi} X(\omega)e^{-j\omega n}</script><h4 id="2-离散傅里叶级数DFS"><a href="#2-离散傅里叶级数DFS" class="headerlink" title="2. 离散傅里叶级数DFS"></a>2. 离散傅里叶级数DFS</h4><p>一个周期为$N$的周期序列，即$x(n)=x(n+kN)$，$k$为任意整数，$N$为周期<br><strong>周期序列不能进行Z变换，因为其在负无穷到正无穷都周而复始永不衰减，即Z平面上没有收敛域。</strong>但是正像连续时间周期信号可用傅氏级数表示，周期序列也可用离散的傅里叶级数来表示，也即用周期为$N$的正弦序列及其谐波来表示。</p>
<p>在连续域，我们的基是$\displaystyle{e^{jk\omega_0 t}}$是周期，其中$k$是整数，一直变化对应到不同的基，$\omega_0 = \dfrac{2\pi}{T}$是周期，t是连续的时间变量。这是我们第一次处理离散信号，离散信号的周期变成了$N$，连续的时间信号$t$换成离散的序列$n$，这样我们的基就变成了$ e^{j\frac{2\pi}{N}kn}$</p>
<p>离散域通常用大写字母序列表示正变换结果，小写字母序列表示原信号。 </p>
<script type="math/tex; mode=display">
X[k] = \frac{1}{N}\sum_{n=0}^{N-1}x[n]e^{-j\frac{2\pi}{N}kn}</script><script type="math/tex; mode=display">
x[n] = \sum_{k=0}^{N-1}X[k]e^{j\frac{2\pi}{N}kn}</script><p>由上知， <strong>DFS是DTFT在单位圆上的N等分</strong>，其傅里叶级数不仅是离散的，而且还是周期性的(以N为周期) </p>
<h4 id="3-离散傅里叶变换DFT"><a href="#3-离散傅里叶变换DFT" class="headerlink" title="3. 离散傅里叶变换DFT"></a>3. 离散傅里叶变换DFT</h4><p><strong>DFT</strong>才是我们耳熟能详的变换，<strong>DFT</strong>处理的是非周期离散信号，这样的信号计算机比较容易处理，我们再看看<strong>DTFT</strong>，正变换产生了连续信号，这个不利于计算机处理。为了方便计算机处理，必须让正变换的结果也是离散值，这一点<strong>DFS</strong>正满足。<strong>DFS</strong>应对的是周期离散信号，正变换后的序列也是周期离散的。前面我们提到，对于非周期信号，数学家总是先假设其周期为T，然后取极限，让T趋向于无穷大，这样得到了非周期信号的变换结果。细心的你，可能已经发现，非周期信号的变换结果，都是连续的，连续信号对于CPU来说，不是一个好东西。</p>
<p>所以，数学家在这次处理非周期信号的时候，采用了不同的方法。这次的方法是对非周期信号做周期延拓，这样不就变成<strong>DFS</strong>了吗，还要<strong>DFT</strong>做什么呢。别急，DFS变换后是周期离散信号，但是<strong>DFT</strong>只取<strong>DFS</strong>变换后的一个周期。<strong>DFT</strong>在处理的时候投机取巧，方便了计算机处理，所以我们通常听得比较多的就是<strong>DFT</strong>。</p>
<p>另外，<strong>DFT</strong>也可以从<strong>DTFT</strong>抽样过来，<strong>DTFT</strong>作为连续信号，均匀采样$N$个点，就变成<strong>DFT</strong>了。</p>
<script type="math/tex; mode=display">
X[k] = \sum_{n = 0}^{N-1} x[n]e^{-j\frac{2\pi}{N}nk}</script><script type="math/tex; mode=display">
x[n] = \frac{1}{N} \sum_{k = 0}^{N-1} X[k]e^{j\frac{2\pi}{N}nk}</script><p><strong><font color="red">[6]</font></strong>可以发现，DFT与离散傅里叶级数(DFS)仅有一点点区别，那就是DFT在逆变换时，即在合成源信号时，会乘上1/N，而DFS相反，除开这一点并无区别，所以这就表示是，<strong><font color="red">DFT实际上是，以信号的N点为周期的信号的DFS</font></strong>，那么DFT和DTFT是什么关系呢？从上述角度上来讲，只能说当DFT所取点数趋于无穷时，那么DFT就可以趋近于DTFT，这也是傅里叶变换的来源，那么书上不是有DFT是DTFT的采样的结论么？该结论是怎样来的？有条件么？</p>
<p>在$\omega$轴上$[0 ,2\pi]$范围内，对DTFT的变换结果$X(e^{j\omega})$以$N$个等间隔频率$\omega_k = \dfrac{2\pi k}{N}，(0 \leq k \leq N-1)$均匀抽样，可得：</p>
<script type="math/tex; mode=display">
X(e^{j\omega})|_{\omega = \frac{2\pi k}{N}}=\sum_{ n= 0}^{N-1}x[n]e^{\frac{j2\pi kn}{N}}，0 \leq k \leq N-1</script><p>个人认为，这也解答了为何DFS与DFT有个系数上的差异，这就是为了在DTFT与DFT的满足采样特点的吻合。</p>
<p>在许多书上，离散时间傅里叶变换都是由是连续信号采样得到的离散信号而得到，这样来介绍，由于有采样频率等的影响，这样会对连续、离散信号产生一定的混淆，个人认为，离散傅里叶变换时离散时间信号的频域特性，并不一定非得和采样、连续信号等产生关系，离散信号可以是由连续信号采样，归一化产生，也可以是其本身就是离散的，如年月日，像素坐标等，如果离散信号是由连续信号采样得到的，那么，当用给定的采样频率，对连续信号采样，归一化后，那么就产生了一个新的离散信号，至于其傅里叶变换和原来的傅里叶变换有何关系，这就是另外一个话题了。</p>
<p>傅里叶变换的核心思想便是能让任意一个信号都可以由一种基本信号来合成，这个基本信号对于连续时间信号便是：$\exp(j\omega t)$，离散时间信号便是：$\exp(j\omega n)$。</p>
<p>对于DTFT的定义式，可以发现其积分是由$[-\pi, \pi]$，而对于FT的定义式积分是从$(-\infty, \infty)$，<strong><font color="red">其根本原因就是——基本信号存在差异</font></strong>，对于$\exp(j\omega t)$，由于$t$可以取任意值因此其不存在周期，当$\omega$取任意值，$\exp(j\omega t)$都会变为一个独一无二的信号，故FT需要从$(-\infty, \infty)$，让每一个$\exp(j\omega t)$都能成为被合成信号的成分（当然这还得取决于前面系数，即傅里叶系数），而对于DTFT而言，由于其基本信号$\exp(j\omega n)$中$n$只能取正整数故周期为$2\pi$，故当要合成新信号时，只需要取任何一个$2\pi$区段就可获得合成信号的所有成分，故上式取$[-\pi, \pi]$即可，当然，这样也很容易得出$F(\exp(jw))$也是周期的。<strong><font color="red">[6]</font></strong></p>
<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p>参考链接4.1：<a href="https://blog.csdn.net/qq_44554964/article/details/108025590">数字信号处理（DTFT与DFT、DFS的详细讲解以及FFT算法）- CSDN</a></p>
<p>参考链接4.2：<a href="https://zhuanlan.zhihu.com/p/97835957">傅里叶变换系列学习（3)——FS,FT,DTFT,DFS,DFT,FFT - 技术派到了中年的文章 - 知乎</a></p>
<p>参考链接4.3：<a href="https://www.cnblogs.com/BitArt/archive/2012/11/24/2786390.html">一幅图弄清DFT与DTFT,DFS的关系 - 博客园</a></p>
<p>参考链接4.4：<a href="https://www.codenong.com/cs106440896">五种傅里叶变换的分析（FT、FS、DTFT、DFT、DFS）</a></p>
<p>参考链接4.5：<a href="https://blog.51cto.com/rainlee/1629264">关于对傅里叶变换的一些理解 - 51博客</a></p>
<p>参考链接4.6：<a href="http://www.360doc.com/content/19/0611/18/908538_841808337.shtml">数字信号处理系列串讲第6篇（离散信号的频域分析之三）——离散傅里叶变换DFT（1）- 360文档</a></p>
<hr>
<h3 id="五、采样频率、频率分辨率"><a href="#五、采样频率、频率分辨率" class="headerlink" title="五、采样频率、频率分辨率"></a>五、采样频率、频率分辨率</h3><h4 id="1-采样定理"><a href="#1-采样定理" class="headerlink" title="1. 采样定理"></a>1. 采样定理</h4><ul>
<li>时域采样定理的一种表述方式是：当时间信号函数$f(t)$的最高频率分量为$f_M$时，$f(t)$的值可由一系列采样间隔$t_s \leq \dfrac{1}{2×f_M}$的采样值来确定，即采样点的重复频率$f ≥ 2×f_M$。时域采样定理是采样误差理论、随机变量采样理论和多变量采样理论的基础。  </li>
<li>频域采样定理：对于时间上受限制的连续信号$f(t)$ (即当$│t│&gt;t_m $时，$f(t)=0$，这里信号的持续时间是$(-t_m,t_m)$，若其频谱为$F(ω)$，则可在频域上用一系列离散的采样值来表示，只要这些采样点的频率间隔$\omega \leq \dfrac{\pi}{t_m}$</li>
</ul>
<h4 id="2-FFT频率分辨率"><a href="#2-FFT频率分辨率" class="headerlink" title="2. FFT频率分辨率"></a>2. FFT频率分辨率</h4><p><strong><font color="red">[1]</font></strong>这里涉及到两种意义下的分辨率问题，一种叫“波形频率分辨率(Waveform frequency resolution)”，另一种则叫做“FFT分辨率”。虽然，这个分类和命名不一定是很专业的术语，但却有助于对“频率分辨率”概念的理解。在没有补零的情况下，这两个概念通常容易被混淆，因为它们是等价的。</p>
<p>波形频率分辨率是指可以被分辨的2个频率的最小间隔（Spacing）；而FFT 分辨率则是频谱中的数据点数(The number of points in the spectrum)，它是与做FFT的点数直接相关的。</p>
<p><strong>(1) 波形分辨率/物理分辨率</strong></p>
<script type="math/tex; mode=display">
\Delta R_w = \frac{1}{T}</script><p>其中，$T$是实际信号的时间长度。</p>
<p><strong>(2) FFT分辨率</strong></p>
<script type="math/tex; mode=display">
\Delta R_f = \frac{f_s}{N_{\rm{FFT}}}</script><p>其中，$f_s$为采样频率(the sampling frequency)，$N_{\rm{FFT}}$为FFT的点数。$\Delta R_f $代表了FFT频率轴上的频率取值的间隔(Spacing)。 </p>
<p>值得注意的是，可能有很好的FFT分辨率，但却不一定能够很好的把2个频率成分简单的分开。同样，可能有很高的波形分辨率，但波形的能量峰值会通过整个频谱而分散开(这是因为FFT的频率泄漏现象)。</p>
<p>我们知道，信号的离散傅里叶变换(DFT)或快速傅里叶变换(FFT)是对波形的任何一边补零形成的无限序列进行计算的。这就是，为什么FFT的每个频率单元(bin)都具有明显的$\mathrm{sinc}$波的形状。</p>
<p>波形频率分辨率$1/T$与一个$\mathrm{sinc}$函数空值间隔(the space between nulls)是一样的。<strong><font color="red">[1]</font></strong></p>
<p><strong>(3) 区别辨析</strong></p>
<p><strong><font color="red">[2]</font></strong>用MATLAB做FFT并不要求数据点个数必须为以2为基数的整数次方。之所以很多资料上说控制数据点数为以2为基数的整数次方，是因为这样就能采用以2为基的FFT算法，提升运算性能。</p>
<p>如果数据点数不是以2为基数的整数次方，处理方法有两种，一种是在原始数据开头或末尾补零，即将数据补到以2为基数的整数次方，<strong>这是“补零”的一个用处</strong>；第二种是采用以任意数为基数的FFT算法。</p>
<p>而MATLAB的$\rm{fft}(x, N)$函数参数$N$正好就是数据$x$的长度，但又不是以2为基数的整数次方时，并不会采用补零的方法，而是采用以任意数为基数的FFT算法，这样也能得到很好的结果，只不过速度要稍稍慢了一些，但一般的计算量是体现不出来的。 </p>
<p>比如，现在我有一个信号，这个信号中仅包含两个正（余）弦波，一个是$1MHz$，一个是$1.05MHz$，即：</p>
<script type="math/tex; mode=display">
x = \cos(2\pi × 1000000t) + \cos(2\pi × 1050000t)</script><p>设采样频率为$f_s = 100\mathrm{MHz}$，如果采1000个点，那么对应的时域信号时长为$\rm T = 10\mu s$。</p>
<p><img src="https://pic.imgdb.cn/item/6412b628ebf10e5d5376b4b3.jpg"></p>
<p>直接对这1000个数据点其做快速傅里叶变换，将得到频谱图： </p>
<p><img src="https://pic.imgdb.cn/item/6412b64debf10e5d53770c1c.jpg"></p>
<p>可以发现，频谱点稀疏，在1MHz附近根本无法将$1 \mathrm{MHz}$和$1.05 \mathrm{MHz}$的两个频率分开。 发现频率成分无法被区分开来，第一反应应该就是：<strong>频率分辨率不够</strong>。那么如何提高频率分辨率呢？这里就涉及两种分辨率的区别了。之所以要区分，是因为后面要进行“补零”操作。<strong>如果不补零，直接对原始数据做FFT，那么这两种分辨率是相等的。</strong></p>
<script type="math/tex; mode=display">
\Delta R_w = \frac{1}{10\mu s} = \Delta R_{\rm{fft}} = \frac{100MHz}{1000} = 100kHz</script><p>那么，如果现在在原始数据点后补零会有什么效果呢？假设在这 1000个原始数据点后面再补充零达到7000个点，那么数据变成了： </p>
<p><img src="https://pic.imgdb.cn/item/6412b712ebf10e5d5378c59b.jpg"></p>
<p>此时对其做快速傅里叶变换，结果如下： </p>
<p><img src="https://pic.imgdb.cn/item/6412b75eebf10e5d5379a933.jpg"></p>
<p>可以发现，频谱点密集了不少，但是在$1MHz$ 附近依然无法将$1MHz$ 和$1.05MHz$  的两个频率成分分开。这是因为从波形分辨率公式可以看出，<strong>波形分辨率只与原始数据的时长 $\rm T$ 有关</strong>，而与参与FFT的数据点数无关。所以，虽然补了很多零，但波形分辨率依然为：$\Delta R_w = \dfrac{1}{10 \mu s} = 100kHz$，该分辨率大于$1MHz$ 和$1.05MHz$ 这两个频率成分之间的距离$50kHz$  。这就好比用筛子分黄豆和大米，分辨率就好像是筛子上孔的大小，如果筛子的孔太大了，就没有办法把这两者分开。</p>
<p>而“时域补零相当于频域插值”，也就是说，补零操作增加了频域的插值点数，让频域曲线看起来更加光滑，也就是增加了FFT频率分辨率， <strong>这是“补零”的另一个原因</strong>。</p>
<p>显然，根据上面的分析可知，在采样频率不变的情况下，要想将$1MHz$ 和$1.05MHz$这两个频率成分分析出来，光靠“补零”是不够的，必须要改变波形分辨率，也就是要延长原始数据的时长。现在以相同的采样频率对信号采 7000个点作为原始信号： </p>
<p><img src="https://pic.imgdb.cn/item/6412b78debf10e5d537a3bb2.jpg"></p>
<p>对其做快速傅里叶变换，结果如下： </p>
<p><img src="https://pic.imgdb.cn/item/6412b7baebf10e5d537ac60f.jpg"></p>
<p>因为此时的波形分辨率为：$\Delta R_w = \dfrac{1}{70 \mu s} \approx  14kHz$ ，小于两个频率成分之间的距离 $50kHz$ ，所以可以看出有两个明显的峰值。</p>
<p>但是会发现$1MHz$对应的幅值为1，与原始信号中该频率成分的幅值一致，但$1.05MHz$ 对应的幅值明显低于1，但是其周边的点上却都有不小的幅值，这就是所谓的<strong>频谱泄露</strong>，因为数据点的个数影响，使得在$1MHz$ 处有谱线存在，但在$1.05MHz$处没有谱线存在，使测量结果偏离实际值 ,同时在实际频率点的能量分散到两侧的其它频率点上，并出现一些幅值较小的假谱。</p>
<p>为了解决这个问题，可以设法使得谱线同时经过$1MHz$ 和$1.05MHz$ 这两个频率点，找到他们的公约数。</p>
<p>如果原始数据不变，在后面再补充1000个零点：</p>
<p><img src="https://pic.imgdb.cn/item/6412b7d3ebf10e5d537b05d1.jpg"></p>
<p>那么FFT分辨率就是$12.5kHz$，是这两个频率的公约数，$1MHz = 80×12.5kHz，1.05MHz = 84×12.5kHz$ ，所以谱线同时经过 $1MHz$ 和 $1.05MHz$ 这两个频率点。</p>
<p>对其做快速傅里叶变换，结果如下：</p>
<p><img src="https://pic.imgdb.cn/item/6412b81bebf10e5d537bc164.jpg"></p>
<p>会发现两个频率对应的幅值均为1，与原始信号一致。</p>
<p><strong>这也是一种补零操作带来的影响???(这里有点问题，频谱泄露与补零没有关系，后续修改补充)</strong>。 </p>
<p>上图会有一些旁瓣出现，这是因为补零影响了原始信号，如果，直接采8000个点作为原始数据，那么有： </p>
<p><img src="https://pic.imgdb.cn/item/6412b851ebf10e5d537c506e.jpg"></p>
<p>并对其做FFT，结果如下 </p>
<p><img src="https://pic.imgdb.cn/item/6412b870ebf10e5d537cba2e.jpg"></p>
<p>这样就不存在补零带来的误差了。 <strong><font color="red">[2]</font></strong></p>
<h4 id="参考链接-3"><a href="#参考链接-3" class="headerlink" title="参考链接"></a>参考链接</h4><p>[1]傅里叶变换的波形分辨率与频率分辨率 <a href="https://wap.sciencenet.cn/blog-425437-1043431.html?mobile=1">https://wap.sciencenet.cn/blog-425437-1043431.html?mobile=1</a></p>
<p>[2]快速傅里叶变换(FFT)中为什么要“补零”？ - 李狗嗨的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/85863024">https://zhuanlan.zhihu.com/p/85863024</a> </p>
<p>[3]观察频谱的窗口——物理与计算分辨率 <a href="http://www.360doc.com/content/20/0402/23/32196507_903494495.shtml">http://www.360doc.com/content/20/0402/23/32196507_903494495.shtml</a></p>
<p>[4]傅里叶变换补零与能否提高频率分辨率 <a href="https://blog.csdn.net/chichuhe/article/details/90369651">https://blog.csdn.net/chichuhe/article/details/90369651</a></p>
<p>[5]DFT中人为地补零加长序列对频谱的影响？ - 杨树下的狐狸的回答 - 知乎 <a href="https://www.zhihu.com/question/30312644/answer/47615752">https://www.zhihu.com/question/30312644/answer/47615752</a> </p>
<hr>
<h3 id="六、能量信号、功率信号"><a href="#六、能量信号、功率信号" class="headerlink" title="六、能量信号、功率信号"></a>六、能量信号、功率信号</h3><hr>
<h3 id="七、信号的频谱，频谱密度，能量谱"><a href="#七、信号的频谱，频谱密度，能量谱" class="headerlink" title="七、信号的频谱，频谱密度，能量谱"></a>七、信号的频谱，频谱密度，能量谱</h3><h3 id="八、-其他问题"><a href="#八、-其他问题" class="headerlink" title="八、 其他问题"></a>八、 其他问题</h3><p><strong>如何理解奈奎斯特采样定理</strong></p>
<p>参考链接8.1：<a href="https://www.zhihu.com/question/28792456/answer/491794439">怎样理解Nyquist采样定理？ - 甜草莓的回答 - 知乎</a></p>
<p>参考链接8.2：<a href="https://www.zhihu.com/question/28792456/answer/2174692083">怎样理解Nyquist采样定理？ - 吃货彪彪的回答 - 知乎</a></p>
<p><strong>卷积与插值(内插)</strong></p>
<p>在CFA去马赛克和图像旋转放大时都需要进行插值运算。在空间域内，<font color="red"><strong>插值是卷积计算</strong></font>。</p>
<p>当已知数据点位于整数格点上时，插值函数h(x)应该有：h(0)=1;h(n)=0; n是非零整数。</p>
<p>在频率域，以步长1采样的图像中如果含有高于1/2的频率分量将会产生混叠。空间域内的卷积对应在频率域内的相乘运算，可以从中判断插值算法的特性</p>
<p>这是几类插值函数在空间域的曲线：</p>
<p><img src="http://www.baas1995.org/digitalprocessing/interp/interp01.jpg" alt></p>
<p>对应频率域的变换： </p>
<p><img src="http://www.baas1995.org/digitalprocessing/interp/interp02.jpg" alt></p>
<p>下面比较一下几类插值算法的特点。</p>
<p>1）邻域插值。即找离插值点最近的格点的值作为插值点的值。<br>插值函数是一个宽度为1的矩形脉冲。在频率域则是一个sinc函数。在-1/2和1/2的频率附近，sinc函数对原频谱中的高频分量进行衰减，使得插值图像变得模糊；而sinc函数在频率轴上向两端无限延伸，减弱缓慢，加入了新的高频分量，对应在插值图像中形成锯齿。</p>
<p>2）线性插值。权重由离插值点的距离线性决定。<br>插值函数是半宽为1的三角脉冲，即两个宽度为1的矩形脉冲的卷积，所以在频率域是一个sinc^2函数。与邻域插值相比，混入的高频有所减少，同时图像也变得模糊。</p>
<p>3）立方插值。<br>插值函数为：((A+2)x-(A+3))x^2+1 (0&lt;x&lt;1) ((Ax-5A)x+8A)x-4A (1&lt;x&lt;2)<br>（选自<a href="http://www.all-in-one.ee/~dersch/interpolator/interpolator.html）">http://www.all-in-one.ee/~dersch/interpolator/interpolator.html）</a><br>插值函数的特点：第一个节点位于x=1，此处曲线的斜率是A。第二个节点位于x=2，斜率是0。</p>
<p><img src="http://www.baas1995.org/digitalprocessing/interp/interp04.jpg" alt></p>
<p>在频率域上可以看出，参数A越接近0，原图像中的高频分量衰减得越厉害；A越接近-1，原图像中的高频分量衰减得越少，甚至中间波段还有提升。因此参数可以用来调节图像的锐度。根据这个网页上的数据，认为PS的算法接近于A=-0.75的效果。 </p>
<p><img src="http://www.baas1995.org/digitalprocessing/interp/interp05.jpg" alt></p>
<p>上面三种插值函数在+-1/2频率处的响应均降为0，从而抑制了混叠效应，同时模糊了图像。</p>
<p>4）sinc插值<br>sinc函数在频率域是一个矩形，看起来似乎最适合做内插。在+-1/2频点，矩形函数的值降低到1/2而非0，因此如果存在混叠则无法得到抑制。从实际来看，很难限制图像的带宽。因此使用sinc函数做插值在图像的边缘等地方会很敏感。另一方面，sinc函数做插值时收敛较慢，需要的采样点要多得多。在采样点较少时，在+-1/2频点会出现振荡，产生失真。</p>
<p><img src="http://www.baas1995.org/digitalprocessing/interp/interp03.jpg" alt></p>
<p>5）加窗sinc插值（选自<a href="http://www.all-in-one.ee/~dersch/interpolator/interpolator.html）">http://www.all-in-one.ee/~dersch/interpolator/interpolator.html）</a> 将两个不等宽矩形脉冲做卷积，得到梯形脉冲。使用这个函数在频域做乘积，则图像中的高频分量受到较少的衰减，图像细节被保留，而超出采样带宽较多的分量被阻断，不会产生类似振铃的效应。 在空间域，插值函数为sinc(x)*sinc(x/w)，w是窗口宽度。与立方或线性插值相比，所需要的采样点多很多。 </p>
<p>参考链接8.3：<a href="http://www.baas1995.org/digitalprocessing/interp/interp.htm">数字图像处理（九）插值算法之二</a></p>
<p>参考链接8.4：<a href="https://blog.csdn.net/shiyimin1/article/details/80141333">图像处理中的三次卷积插值(Cubic Convolution) - CSDN</a></p>
<p>参考链接8.5：<a href="https://blog.csdn.net/dx199771/article/details/111940754">图像插值算法——双立方（三次）卷积插值 - CSDN</a></p>
<p><strong>卷积与互相关函数的关系</strong></p>
<p>参考链接8.6：<a href="https://zhuanlan.zhihu.com/p/366472797">信号处理中的卷积、深度学习中的卷积和反卷积 - 初识CV的文章 - 知乎</a></p>
<p>参考链接8.7：<a href="https://www.zhihu.com/question/54677157/answer/1849389835">卷积(convolution)为什么叫「卷」积(「convolut」ion)？ - 初识CV的回答 - 知乎</a></p>
<p><strong>sinc函数是一组正交基？</strong></p>
<p>参考链接8.8：<a href="http://www.360doc.com/content/15/0321/23/202378_457041010.shtml">信号与系统（5）：采样定理和多分辨分析</a></p>
<p><strong>为什么Sinc是完美插值函数？</strong></p>
<p>参考链接8.9：<a href="https://zhuanlan.zhihu.com/p/150876542">为什么Sinc是完美插值函数 - starimpact的文章 - 知乎</a></p>
<p><strong>如何理解非周期的离散时间信号的傅里叶变换在频域上连续？</strong></p>
<p>题主问的是为什么频域上连续，其实频域的连续只和信号在时域上是否是周期信号有关，与信号是否离散还是连续没有关系。 如果题主明白连续非周期信号为什么在频域上连续，可以同理理解离散信号。由于周期的无穷大导致了频率幅度的无穷小，但也导致了频率的连续，但频率幅度之间的相对大小没有发生变化，所以序列傅立叶变换后的幅度值是一个相对值，叫频谱密度。 </p>
<p><strong>补零方式</strong></p>
<p>时域的末尾补零，提高频域计算分辨率，时域的中间补零，相当于是尺度变换，那么在频域，末尾补零，提高时域计算分辨率，中间补零，频域尺度变换，频域之间间隔越小，极限近似于连续，那么时域间断，那么相对的，频域之间间隔越大，时域平滑。 </p>
<p>时域上的f(t)变成f(2t)时，在频域上他的频谱就会压缩。这是时频之间的相反特性。 </p>
<p>参考链接8.10：<a href="https://www.zhihu.com/question/270235354">实现时域内插可以fft、频域补零，再ifft，那么频域补零为何要在中间部位补零呢？ - 知乎</a></p>
<p>参考链接8.11：<a href="http://zhidao.baidu.com/question/357985740?sharesource=weibo">信号与系统 时域与频域尺度变换的二个简单问题 - 百度知道</a></p>
<h4 id="参考链接：-1"><a href="#参考链接：-1" class="headerlink" title="参考链接："></a>参考链接：</h4><p>参考链接1：<a href="https://blog.csdn.net/weixin_45102840/article/details/105408476">概率密度函数及其在信号方面的简单理解（上）概率密度函数 - CSDN</a></p>
<p>参考链接2：<a href="https://www.zhihu.com/question/333121021/answer/738658182">信号的频谱，功率谱，能量谱，傅立叶级数，傅立叶展开，这几个有什么区别和联系吗，感觉很懵。？ - 张大侠的回答 - 知乎</a></p>
<p>参考链接3：<a href="https://zhuanlan.zhihu.com/p/417454806">功率谱密度（PSD） - 菜狗的文章 - 知乎</a></p>
<p>参考链接4：<a href="https://www.cnblogs.com/yongzhewudi/p/5911003.html">信号的频谱，频谱密度，能力谱区别 - 博客园</a></p>
<p>参考链接5：<a href="https://www.cnblogs.com/htj10/p/8638275.html">能量信号、功率信号、频谱、能量谱、功率谱、及一些定理 - 博客园</a></p>
<p>参考链接6：<a href="http://blog.sina.com.cn/s/blog_65d374720100kzms.html">功率谱密度（功率信号）、能量谱密度（能量信号）</a></p>
<p>参考链接7：<a href="https://zhuanlan.zhihu.com/p/449608778">离散时间傅立叶变换（DTFT） - 知乎 (zhihu.com)</a> </p>
<p>参考链接8：<a href="https://www.zhihu.com/question/39196097">做DFT时频率分辨能力的定义到底是什么？（程佩青《数字信号处理》） - 知乎</a></p>
<p>参考链接9：<a href="https://www.zhihu.com/question/489681533">在离散傅里叶变换（DFT）中如何理解采样频率、模拟频率和数字频率三者之间的关系？ - 知乎</a> </p>
<p>参考链接10：<a href="https://blog.csdn.net/u010237785/article/details/73881889">关于采样与DFT的一点点思考 - u010237785 - CSDN - dft 采样定理</a> </p>
<p>参考链接11：<a href="https://blog.csdn.net/qq_36756600/article/details/117700771">复信号处理（1）——复信号理解 - CSDN</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>信号处理与雷达</category>
        <category>信号与系统</category>
      </categories>
      <tags>
        <tag>信号与系统</tag>
      </tags>
  </entry>
  <entry>
    <title>thinking and record</title>
    <url>/2022/11/14/thinking-and-record/</url>
    <content><![CDATA[<h3 id="1-统计信号估计理论：滤波、预测、平滑-参数估计、状态估计"><a href="#1-统计信号估计理论：滤波、预测、平滑-参数估计、状态估计" class="headerlink" title="1 统计信号估计理论：滤波、预测、平滑 + 参数估计、状态估计"></a>1 统计信号估计理论：滤波、预测、平滑 + 参数估计、状态估计</h3><h4 id="1-1-什么是估计理论（Estimation）"><a href="#1-1-什么是估计理论（Estimation）" class="headerlink" title="1.1 什么是估计理论（Estimation）"></a>1.1 什么是估计理论（Estimation）</h4><p>估计理论是从被噪声污染后的量测数据中恢复无法直接观测的随机变量、随机过程或者系统某些特征的统计信号处理方法。</p>
<h4 id="1-2-估计的三种基本形式"><a href="#1-2-估计的三种基本形式" class="headerlink" title="1.2 估计的三种基本形式"></a>1.2 估计的三种基本形式</h4><h5 id="1-2-1-解释1"><a href="#1-2-1-解释1" class="headerlink" title="1.2.1 解释1"></a>1.2.1 解释1</h5><p>(1) 滤波——Filtering</p>
<p>滤波是用当前时刻及以前的数据来估计当前时刻感兴趣信息的一种运算过程。</p>
<p>(2) 预测——Prediction</p>
<p>预测是用当前时刻及以前的数据来估计未来某时刻感兴趣的信息。</p>
<p>(3) 平滑——Smoothing</p>
<p>平滑是利用感兴趣时刻之后的所有观测数据估计感兴趣时刻的信息，因此它是一种后验形式的估计。</p>
<h5 id="1-2-2-解释2"><a href="#1-2-2-解释2" class="headerlink" title="1.2.2 解释2"></a>1.2.2 解释2</h5><p>自适应滤波器的三种状态：滤波，预测，平滑</p>
<p>平滑只是滤波器的一种工作状态，如果感兴趣的信号部分在过去，现在，未来，那么滤波器是在分别做平滑，滤波，预测。根据时间序号$k$和信号样本集$N$，通过统计规则实现的自适应滤波器有三种效果：</p>
<p>(1) 预测：当$N&lt;k$，这是在预测未来的状态，我们在做预测估计(predicted estimate)，也就是预测；</p>
<p>(2) 滤波：当$N=k$，这是在用所有过去的观测值和当前的观测值估计当前的状态，这是在做滤波估计(filtered estimate)，也就是滤波；</p>
<p>(3) 平滑：当$N&gt;k$，这是在估计过去的状态，这是在做平滑估计(smoothed estimate)，也就是平滑。</p>
<blockquote>
<p>解释2来自：<a href="https://www.zhihu.com/question/35073143/answer/531133735">在信号处理和图像处理领域，滤波，平滑和去噪几个词的区别和联系？ - 甜草莓的回答 - 知乎</a></p>
</blockquote>
<h5 id="1-2-3-解释3"><a href="#1-2-3-解释3" class="headerlink" title="1.2.3 解释3"></a>1.2.3 解释3</h5><p>一个系统不可避免的受到外界的干扰，因而系统的状态一般是不能精确量测的。这样就存在着基于系统量测(输出)对系统状态进行估计(estimation)的问题</p>
<p>首先需要了解参数估计的一般理论。对于一个未知参数向量，量测是一个随机向量，一组量测构成了样本，对样本的统计量就称为对参数的一个估计量。利用样本对参数的估计量本质上是随机的，而当样本值给定时所得到的参数估计值一般与真值并不相同，因而需要用某些准则进行评价：</p>
<ul>
<li><p>如果所得估计量的数学期望等于真值，则称这个估计是对参数的一个无偏估计；</p>
</li>
<li><p>如果所得估计量依概率收敛于真值，称其是对参数的一个一致估计量。</p>
</li>
</ul>
<p>最常用的参数估计方法有最小二乘估计算法、极大似然估计算法等。近年来还发展有期望极大化算法等。</p>
<p>对于控制系统而言，状态估计问题是一个动态估计问题，分为三种不同的类型：</p>
<p>(1) 滤波问题：利用直到当前时刻的实时信息对当前的状态进行估计；</p>
<p>(2) 预测问题：利用直到当前时刻的实时信息对未来的状态进行估计；</p>
<p>(3) 平滑问题：利用直到当前时刻的实时信息对过去的状态进行估计。</p>
<p>仅仅就滤波问题而言，如果系统是线性的，一般可采用所谓卡尔曼(Kalman)滤波算法进行状态估计。由于相当多的系统不满足线性随机系统的条件，所以标准卡尔曼滤波算法并不适用。为此，针对非线性情况，早年就发展了所谓扩展卡尔曼滤波算法，即利用在线的线性化方法，把非线性系统在一个名义值附近进行线性近似，然后利用标准卡尔曼滤波算法进行一步滤波处理，然后递推实现在线滤波。</p>
<blockquote>
<p>解释3来自：<a href="https://www.zhihu.com/question/24877642/answer/263267371">滤波、预测和平滑之间的关系是什么？ - 繁星丶落幕的回答 - 知乎</a></p>
</blockquote>
<h5 id="1-2-4-解释4"><a href="#1-2-4-解释4" class="headerlink" title="1.2.4 解释4"></a>1.2.4 解释4</h5><p>这里讨论的是对信号波形进行估计的问题，或者是对函数的估计问题。一般是用某一个时间点$t$以前测量得到的信息，对某一时刻$t +\Delta t$上面的信号值进行估计。随着估计时间的不断推移，就可以得到全部信号。</p>
<p>(1) 平滑或内插：如果时间差$\Delta t &lt; 0$，这时的估计工作称为平滑或内插。其作用是一致已经得到观测点上的信号值，是对过去观测值的处理。</p>
<p>(2) 滤波：如果时间差$\Delta t = 0$，这时的估计工作称为滤波。它是对目前时间点上的信号值进行估计，一般用于抑制当前时间点上的观测噪声。</p>
<p>(3) 预测：如果时间差$\Delta t &gt; 0$，这时的估计工作是对将来时间点上的信号值进行估计，是一种预测。<br>在实际应用中，滤波应用得比较多。</p>
<blockquote>
<p>解释4来自：<a href="https://wenku.baidu.com/view/0288465b01768e9951e79b89680203d8ce2f6afc.html?_wkts_=1668424284360&amp;bdQuery=%E6%BB%A4%E6%B3%A2%E3%80%81%E9%A2%84%E6%B5%8B%E5%92%8C%E5%B9%B3%E6%BB%91">第五章 统计滤波 - 百度文库</a></p>
</blockquote>
<h4 id="1-3-滤波、预测和平滑的区别"><a href="#1-3-滤波、预测和平滑的区别" class="headerlink" title="1.3 滤波、预测和平滑的区别"></a>1.3 滤波、预测和平滑的区别</h4><p>滤波和预测是能够根据当前获得的数据实现对所期望时刻的数据估计，因此它们是一类实时(Online)运算。而平滑因需要所有观测数据进行处理，所以它是一类离线(Offline)运算或者批处理运算。</p>
<h4 id="1-4-估计的两种形式"><a href="#1-4-估计的两种形式" class="headerlink" title="1.4 估计的两种形式"></a>1.4 估计的两种形式</h4><p>(1) 参数估计：根据量测数据来估计系统中随时间不变或缓慢变化的参数，其中被估计的参数包括随机变量和非随机变量。</p>
<p>(2) 状态估计：基于状态空间模型，根据量测数据来估计系统中随时间连续变化的状态，其中包括离散时间状态和连续时间状态。</p>
<h4 id="1-5-参数估计和状态估计区别"><a href="#1-5-参数估计和状态估计区别" class="headerlink" title="1.5 参数估计和状态估计区别"></a>1.5 参数估计和状态估计区别</h4><p>参数估计本质上属于概率论和数理统计理论的一个分支。而状态估计是控制理论、计算机技术及概率论与数理统计理论相结合的产物，是现代控制理论的一个重要分支。</p>
<blockquote>
<p>以上内容转自：<a href="http://www.suanfajun.com/%e7%bb%9f%e8%ae%a1%e4%bf%a1%e5%8f%b7%e4%bc%b0%e8%ae%a1%e7%90%86%e8%ae%ba%e6%bb%a4%e6%b3%a2%e9%a2%84%e6%b5%8b%e5%b9%b3%e6%bb%91%e5%8f%82%e6%95%b0%e4%bc%b0%e8%ae%a1%e7%8a%b6%e6%80%81%e4%bc%b0%e8%ae%a1.html">统计信号估计理论：滤波、预测、平滑 + 参数估计、状态估计</a></p>
</blockquote>
<h3 id="2-维纳滤波"><a href="#2-维纳滤波" class="headerlink" title="2 维纳滤波"></a>2 维纳滤波</h3><h4 id="2-1-维纳滤波基本原理和概述"><a href="#2-1-维纳滤波基本原理和概述" class="headerlink" title="2.1 维纳滤波基本原理和概述"></a>2.1 维纳滤波基本原理和概述</h4><p>维纳(Wiener)是用来解决从噪声中提取信号的一种过滤(或滤波)方法。这种线性滤波问题，可以看做是一种估计问题或一种线性估计问题。</p>
<p>一个线性系统，如果它的单位样本响应为$h(n)$，当输入一个随机信号$x(n)$，且：</p>
<script type="math/tex; mode=display">
x(n) = s(n) + v(n) \tag{2.1.1}</script><p>其中，$x(n)$表示信号，$v(n)$表示噪声，则输出$y(n)$为：</p>
<script type="math/tex; mode=display">
y(n) = \sum_m h(m)x(n-m) \tag{2.1.2}</script><p>我们希望$x(n)$通过线性系统$h(n)$后得到的$y(n)$尽量接近于$s(n)$，因此称$y(n)$为$s(n)$的<br>估计值，用$\hat s(n)$表示，即：</p>
<script type="math/tex; mode=display">
y(n) = \hat s(n) \tag{2.1.3}</script><p>则维纳滤波器的输入—输出关系可用下面图表示。</p>
<p><img src="https://pic.imgdb.cn/item/637238eb16f2c2beb1dad908.jpg" style="zoom:80%"></p>
<p>实际上，式$(2.1.2)$所示的卷积可理解为从当前和过去的观察值$x(n), x(n-1), \cdots, x(n-m), \cdots$ 来估计信号的当前值$s(n)$。因此，用$h(n)$进行过滤问题实际上是一种统计估计问题。</p>
<p>一般地滤波、预测、平滑可以从如下划分：</p>
<ul>
<li>从当前的和过去的观察值$x(n), x(n-1), x(n-2), \cdots$估计当前的信号值$y(n)=\hat s(n)$称为过滤或滤波；</li>
<li>从过去的观察值，估计当前的或者将来的信号值$y(n)=\hat s(n +N), (N≥0)$称为外推或预测；</li>
<li>从过去的观察值，估计过去的信号值$y(n)=\hat s(n-N), (N&gt;1)$称为平滑或内插。</li>
</ul>
<p>因此维纳滤波器又常常被称为最佳线性过滤与预测或线性最优估计。这里所谓的最佳与最优是以最小均方误差为准则的。</p>
<p>如果分别以$s(n)$与$\hat s(n)$表示信号的真实值与估计值，而用$e(n)$表示它们之间的误差，即：</p>
<script type="math/tex; mode=display">
e(n)= s(n)-s(n) \tag{2.1.4}</script><p>显然$e(n)$可能是正值，也可能是负值，并且它是一个随机变量。因此，用它的均方误差来表达误差是合理的，所谓均方误差最小即它的平方的统计期望最小：</p>
<script type="math/tex; mode=display">
\xi (n) = \min E[e^2(n)] \tag{2.1.5}</script><p>用最小均方误差准则作为最佳过滤准则的原因还在于其理论分析比较简单，不要求对概率的描述。</p>
<p><strong><font color="red">维纳-霍夫方程的求解</font></strong></p>
<p>为了按$(2.1.5)$式所示的最小均方误差准则来确定维纳滤波器的冲激响应$h(n)$，令$\xi(n)$对$h(j)$的导数等于零，即可得：</p>
<script type="math/tex; mode=display">
R_{xs}(m) = \sum_i h(i)R_{xx}(m-i) \tag{2.1.6}</script><p>式中，$R_{xs}(m)$是$s(n)$与$x(n)$的互相关函数，$R_{xx}(m)$是$x(n)$的自相关函数，分别定义为：</p>
<script type="math/tex; mode=display">
R_{xx} = E[x(n)s(n+m)] \qquad R_{xx} = E[x(n)x(n+m)]</script><p>式$(2.1.6)$称为维纳滤波器的标准方程或维纳-霍夫(Wiener-Hopf)方程。若已知$R_{xs}(m)$和$R_{xx}(m)$，那么解此方程即可求的维纳滤波器的冲激响应。</p>
<p>式$(2.1.6)$所示标准方程右端的求和范围即$i$的取值范围没有具体标明，实际上有三种情况：</p>
<ul>
<li>有限冲激响应(FIR)维纳滤波器，$i$从$0$到$N-1$取得有限个整数值；</li>
<li>非因果无限冲激响应(非因果IIR)维纳滤波器，$i$从$-\infty$到$+\infty$所有整数值;</li>
<li>因果无限冲激响应(因果IIR)维纳滤波器，$i$从$0$到$+\infty$取正整数值。</li>
</ul>
<p>上述三种情况下标准方程的解法不同，本文只描述FIR维纳滤波器的求解。设滤波器冲激响应序列的长度为$N$，冲激响应矢量为：</p>
<script type="math/tex; mode=display">
h = [h(0), h(1), \cdots,h(N-1) ]^{\mathrm T} \tag{2.1.7}</script><p>滤波器的输入数据矢量：</p>
<script type="math/tex; mode=display">
x = [x(n), x(n-1), \cdots, x(n-N+1)]^{\mathrm T} \tag{2.1.8}</script><p>则滤波器的输出为：</p>
<script type="math/tex; mode=display">
y(n) = \hat s(n) = x^{\mathrm T}h = h^{\mathrm T}x \tag{2.1.9}</script><p>这样，式$(2.1.6)$所示的维纳-霍夫方程可写成：</p>
<script type="math/tex; mode=display">
P^{\mathrm T} = h^{\mathrm T}R \quad {\mathrm{OR}} \quad P =  R^{\mathrm T}h \tag{2.1.10}</script><p>其中，$P = E[x(n)s(n)]$是$s(n)$与$x(n)$的互相关函数，它是一个$N$维列矢量；$R$是$x(n)$的自相关函数，是$N$阶方阵，$R = E[x(n)x^{\mathrm T}(x)]$</p>
<p>利用求逆矩阵的方法直接求解式$(2.1.10)$，得：</p>
<script type="math/tex; mode=display">
h_{\mathrm{opt}} = R^{-1}P</script><p>这里opt表示“最佳”，这就是FIR维纳滤波器的冲激响应。</p>
<blockquote>
<p>以上内容主要转自：<a href="https://www.renrendoc.com/paper/179876044.html">维纳滤波器</a></p>
</blockquote>
<h3 id="3-卡尔曼滤波"><a href="#3-卡尔曼滤波" class="headerlink" title="3 卡尔曼滤波"></a>3 卡尔曼滤波</h3><p> <a href="https://www.cnblogs.com/laozhu1234/p/14932627.html">关于卡尔曼滤波中协方差矩阵Q,R的一些思考,卡尔曼原理讲解</a>：这个人写的感觉挺不错，但没有细看。</p>
<p>卡尔曼滤波算法从名称上来看落脚点是一个滤波算法，一般的滤波算法都是频域滤波，而卡尔曼滤波算法是一个时域滤波，时域就是它的强大之处。卡尔曼滤波也是一种最优估计算法，常见的最优估计算法有“最小二乘法”等，卡尔曼滤波也是一个迭代器，根据以知的先验值，预测下一时刻的估计值。<br>再说说滤波这个名词，本质上就是给加权。既然是加权，那么卡尔曼滤波算法本质就是数据融合的操作(Data fusion)，卡尔曼增益就是融合过程中的权重，融合的内容有两个：分别是满足一定分布的先验状态估计值和满足一定分布的观测值之间的融合（也就是你们可能在其他资料上看到的两个椭圆相乘，其实就是数据的融合），融合后得到后验状态估计值。</p>
<p>其实深度学习中的卷积操作也是加权求和，本质上也是滤波，本质上也是求导，比如边缘检测的离散微分算子sobel的计算过程，也是分别在x和y两个方向上求导，提取出边缘特征。（下面是我个人的思考）由点及面，我们就可以想像到一个大尺寸的卷积核，其实就相当于“变形求导”，通过卷积核内部权重数值大小给定求导曲线，卷积就是求解在这条曲线上的导数。 一个卷积核是提取特征，那么多个卷积核组合起来就有无限可能，提取到的就是高维特征（高维特征对应图片的纹理等深层次的语义信息），组合起来非常之强大，就能够实现深度学习中的分类、边框回归等功能。</p>
<blockquote>
<p>以上内容转自：<a href="https://blog.csdn.net/qq_39523365/article/details/109094713">深入理解卡尔曼滤波算法</a></p>
</blockquote>
<p>维纳滤波与卡尔曼滤波比较：</p>
<p>解释1：</p>
<p>维纳滤波和卡尔曼滤波都是解决线性滤波和预测问题的方法，并且都是以均方误差最小为准则的，在平稳条件下两者的稳态结果是一致的。但是它们解决问题的方法有很大区别。维纳滤波是根据全部过去观测值和当前观测值来估计信号的当前值，因此它的解形式是系统的传递函数$S(k) = A(k)S(k-1)+w_1(k-1)$</p>
<p>卡尔曼滤波是用当前一个估计值和最近一个观测值来估计信号的当前值,它的解形式是状态变量值。维纳滤波只适用于平稳随机过程,卡尔曼滤波就没有这个限制。设计维纳滤波器要求已知信号与噪声的相关函数,设计卡尔曼滤波要求已知状态方程和量测方程,当然两者之间也有联系。 </p>
<blockquote>
<p>以上内容转自：<a href="https://easylearn.baidu.com/edu-page/tiangong/questiondetail?id=1721316694860560840&amp;fr=search">比较维纳滤波和卡尔曼滤波方法的区别和联系</a></p>
</blockquote>
<p>解释2：</p>
<ul>
<li><p>共同点：都解决最佳线性滤波和预测问题，都以均方误差最小为最优准则，平稳条件下它们得到的稳态结果一致。</p>
</li>
<li><p>不同点:</p>
<ul>
<li><p>维纳滤波根据$x(n),x(n-1),…,x(1)$估计信号的当前值，它的解以系统的系统函数$H(z)$或单位脉冲响应$h(n)$形式给出。这种系统常称为最佳线性滤波器。</p>
<p>卡尔曼滤波用前一个估计值和最近一个观察数据来估计信号当前值，它用状态方程和递推的方法进行估计，它的解以估计值（常是状态变量值）形式给出。系统常称为线性最优估计器。</p>
</li>
<li><p>维纳滤波只适用于平稳随机过程；卡尔曼滤波适用于平稳和非平稳随机过程。</p>
</li>
<li><p>维纳滤波设计时要已知信号与噪声的统计分布规律。卡尔曼滤波设计时要求已知状态方程和量测方程。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>以上内容转自：<a href="https://www.docin.com/p-1404646080.html">维纳滤波和卡尔曼滤波 - 豆丁网 (docin.com)</a> </p>
</blockquote>
<p><a href="http://t.zoukankan.com/dushikang-p-8310821.html">卡尔曼滤波的原理与思想 - 走看看</a></p>
<p><a href="https://blog.csdn.net/xiaoma_bk/article/details/82491083">卡尔曼滤波 kalman  理解</a></p>
<p><a href="https://bbs.21ic.com/icview-292853-1-1.html">授之以渔： 卡尔曼滤波器 ….大泻蜜</a></p>
<p><a href="https://blog.csdn.net/miraito_wa/article/details/125968274">卡尔曼滤波算法总结</a></p>
<p><a href="https://blog.csdn.net/shanzsz/article/details/87282192">其他-卡尔曼滤波</a></p>
<p><a href="https://blog.csdn.net/m0_64007201/article/details/127410885">卡尔曼滤波介绍</a></p>
<p><a href="https://blog.csdn.net/Mr_sticker/article/details/106918752">卡尔曼滤波的个人理解</a></p>
<p><a href="https://www.bilibili.com/read/cv17659049">世界上应用最广泛的算法之一的卡尔曼滤波算法原理-从放弃到精通-无人机/机器人应用 - 哔哩哔哩 (bilibili.com)</a> ：卡尔曼滤波器的通俗举例 - 好了，现在对于某一分钟我们有两个有关于该房间的温度值。</p>
<p><a href="https://blog.csdn.net/weixin_43096365/article/details/122447840">卡尔曼滤波算法 - 生命不止，学习不息的博客-CSDN博客</a> </p>
<p><a href="https://blog.csdn.net/sillykog/article/details/78535767">卡尔曼滤波和维纳滤波 - sillykog的博客-CSDN博客_卡尔曼滤波和维纳滤波的区别</a> </p>
<p><a href="https://blog.csdn.net/weixin_42570192/article/details/122265199">维纳滤波和卡尔曼滤波 - 西岸贤的博客-CSDN博客_维纳滤波和卡尔曼滤波</a> </p>
<p><a href="https://blog.csdn.net/victor_zy/article/details/82862904?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control">卡尔曼滤波算法详细推导 - victorzy的博客-CSDN博客_卡尔曼滤波推导</a> </p>
<h3 id="4-协方差"><a href="#4-协方差" class="headerlink" title="4 协方差"></a>4 协方差</h3><p><a href="https://blog.csdn.net/weixin_46021869/article/details/117334362">初学）从协方差到协方差矩阵，再到特征向量和特征值</a></p>
<p><a href="http://www.360doc.com/content/17/0810/21/37752273_678258912.shtml">协方差矩阵的特征向量指的是什么</a></p>
<p><a href="https://www.lianxh.cn/news/9a0b602dbe8fb.html">主成分分析-交互固定效应基础：协方差矩阵的几何意义</a>：好像写的很好！！！</p>
<p><a href="https://blog.csdn.net/qq_38148024/article/details/97269169">协方差的几何意义</a></p>
<p><a href="https://blog.csdn.net/goodshot/article/details/50961720">协方差的意义和计算公式</a></p>
<h3 id="5-距离分辨率与带宽"><a href="#5-距离分辨率与带宽" class="headerlink" title="5 距离分辨率与带宽"></a>5 距离分辨率与带宽</h3><h4 id="5-1-距离分辨力"><a href="#5-1-距离分辨力" class="headerlink" title="5.1 距离分辨力"></a>5.1 距离分辨力</h4><p>距离分辨力本质上是和脉冲宽度有关，脉宽越窄，距离分辨力越高，但是由于在发射机峰值功率一定的情况下，脉宽越窄，对应的平均功率越小，这会导致雷达最大可测距离减小，这就是俗称的距离分辨力与最大可测距离之间的矛盾。</p>
<p>为了解决这个矛盾，雷达接收机中频信号处理引入匹配滤波技术(时宽近似为带宽分之一)，可以解决这个矛盾。chirp信号发射的一般是大时宽带宽积的信号，大时宽保证最大可测距离，大带宽(MF之后对应小时宽)保证高的距离分辨力。</p>
<ul>
<li>距离分辨率本质上到底是看脉宽还是看带宽？ <ul>
<li>早期的确是时宽，因为考虑到最大可测距离与距离分辨力的矛盾，引入脉压技术，所以现代雷达说的都是带宽。  本质是时(脉)宽，但一般现代雷达中脉宽和带宽存在一个倒数关系，所以经常用那个带宽的公式。</li>
</ul>
</li>
</ul>
<h4 id="5-2-速度分辨力"><a href="#5-2-速度分辨力" class="headerlink" title="5.2 速度分辨力"></a>5.2 速度分辨力</h4><p>至于速度分辨力(多普勒分辨力)和雷达对目标回波做的相参积累时间T有关，近似等于$\dfrac{1}{T}$。</p>
<blockquote>
<p>以上内容转自：<a href="https://www.zhihu.com/question/318858527/answer/643253088">线性调频脉冲信号的距离分辨率和速度分辨率与什么因素有关？ - fever wong的回答 - 知乎</a></p>
</blockquote>
<h3 id="6-随机信号处理笔记之白噪声"><a href="#6-随机信号处理笔记之白噪声" class="headerlink" title="6 随机信号处理笔记之白噪声"></a>6 随机信号处理笔记之白噪声</h3><h4 id="6-1-白噪声的概念"><a href="#6-1-白噪声的概念" class="headerlink" title="6.1 白噪声的概念"></a>6.1 白噪声的概念</h4><p>“白噪声”，Additive White Gaussian Noise(AWGN)。“白”的概念来自于光学，和白光的“白”是同一个意思，指的是包含所有频率分量的噪声，且这所有的频率分量是等值的。</p>
<p>白噪声，就是说功率谱为一常数；即其协方差函数在时延$\tau = 0$时不为0，在$\tau \neq 0$时值为0； 换句话说，样本点互不相关。 所以“白”与“不白”是和分布没有关系的。 当随机地从高斯分布中获取采样值时，采样点所组成的随机过程就是<strong>“高斯白噪声”</strong>； 同理，随机从均匀分布中获取采样值时，采样点所组成的随机过程就是<strong>“均匀白噪声”</strong>。 </p>
<h4 id="6-2-白噪声的统计学定义"><a href="#6-2-白噪声的统计学定义" class="headerlink" title="6.2 白噪声的统计学定义"></a>6.2 白噪声的统计学定义</h4><p>如果白噪声的功率谱密度在所有频率上都是一个常数(功率谱密度只与白噪声与否有关，即与自相关函数有关，与高斯与否无关。 )：</p>
<script type="math/tex; mode=display">
P(\omega) = \frac{N_0}{2}</script><p>其中，$N_0&gt;0, \omega \in (-\infty, \infty)$，则称该噪声为白噪声。 白噪声的单边功率谱密度： </p>
<script type="math/tex; mode=display">
P_{单}(\omega) = N_0</script><p>其中，$N_0&gt;0, \omega \in (0, \infty)$。</p>
<h4 id="6-3-白噪声的自相关函数"><a href="#6-3-白噪声的自相关函数" class="headerlink" title="6.3 白噪声的自相关函数"></a>6.3 白噪声的自相关函数</h4><p>根据维纳-辛钦定理，平稳随机过程的功率谱密度函数和自相关函数是傅里叶变换对。</p>
<p>白噪声的自相关函数：</p>
<script type="math/tex; mode=display">
R(\tau) = \frac{N_0}{2}\delta(\tau)</script><p>对于所有的$\tau \neq 0$，都有$R(\tau) = 0$，说明白噪声仅在$\tau=0$时刻才是相关的，而在其他时刻（$\tau \neq 0$)的随机变量都是不相关的。</p>
<p>白噪声的平均功率： </p>
<script type="math/tex; mode=display">
R(0) = \frac{N_0}{2}\delta(0) = \infty</script><p>因此真正“白”的噪声是不存在的。实际工程应用中，只要噪声的功率谱密度均匀分布的频率范围远大于通信系统的工作频带($3 \text{ dB}$带宽)，就可将其视作白噪声。 </p>
<blockquote>
<p>以上内容主要转自：<a href="https://blog.csdn.net/qq_43045275/article/details/106472372">随机信号处理笔记之白噪声</a></p>
</blockquote>
<h3 id="7-窄带噪声、高斯噪声、白噪声"><a href="#7-窄带噪声、高斯噪声、白噪声" class="headerlink" title="7 窄带噪声、高斯噪声、白噪声"></a>7 窄带噪声、高斯噪声、白噪声</h3><h4 id="7-1-概念解析"><a href="#7-1-概念解析" class="headerlink" title="7.1 概念解析"></a>7.1 概念解析</h4><ul>
<li>高斯噪声是指它的概率密度函数服从高斯分布(即正态分布)的一类噪声；</li>
<li>窄带噪声是指频带范围较窄的一类噪声，系统的频带宽度远远小于其中心频率的系统；</li>
<li>白噪声是指它的功率谱密度函数在整个频域内是常数。</li>
</ul>
<p>可以看出他们描述的属于不同的领域，<strong>高斯噪声是从概率方面描述</strong>，<strong>窄带是从带宽方面描述</strong>，<strong>白噪声是从功率方面描述</strong>。</p>
<blockquote>
<p>以上内容转自：<a href="https://zhuanlan.zhihu.com/p/131593352">窄带噪声、高斯噪声、白噪声 - 嵌入式随笔的文章 - 知乎</a></p>
</blockquote>
<h4 id="7-2-高斯白噪声"><a href="#7-2-高斯白噪声" class="headerlink" title="7.2 高斯白噪声"></a>7.2 高斯白噪声</h4><p>高斯型白噪声也称高斯白噪声，是指噪声的概率密度函数满足正态分布统计特性，同时它的功率谱密度函数是常数的一类噪声。高斯型白噪声同时涉及到噪声的两个不同方面，即概率密度函数的正态分布性和功率谱密度函数均匀性，二者缺一不可。 </p>
<p>假设高斯白噪声服从$(0, \sigma^2)$正态分布，则其自相关函数为：</p>
<script type="math/tex; mode=display">
R(\tau) = \sigma^2 \delta(\tau)</script><p>高斯白噪声的功率谱密度$P(\omega)$是其自相关函数$\R(\tau)$的傅里叶变换，有：</p>
<script type="math/tex; mode=display">
P(\omega) = \frac{N_0}{2} = \sigma^2</script><p>也就是在通信信道中，一般噪声的均值$\mu = 0$，那么当噪声的均值是零的时候，噪声的平均功率等于其方差。 </p>
<blockquote>
<p>以上内容转自：<a href="https://www.zhihu.com/question/35577235/answer/1368652133">高斯白噪声的自相关函数是什么？ - 高宏的回答 - 知乎</a></p>
</blockquote>
<ul>
<li><strong>高斯色噪声</strong></li>
</ul>
<p>那么，是否有“非白的高斯”噪声呢？答案是肯定的，这就是”高斯色噪声“。</p>
<p>这种噪声其分布是高斯的，但是它的频谱不是一个常数，或者说，对高斯信号采样的时候不是随机采样的，而是按照某种规律来采样的。</p>
<blockquote>
<p>以上内容转自：<a href="https://www.cnblogs.com/angel/articles/459650.html">噪声的讨论 - 博客园</a></p>
</blockquote>
<h4 id="7-3-几个问题的辨析解释"><a href="#7-3-几个问题的辨析解释" class="headerlink" title="7.3 几个问题的辨析解释"></a>7.3 几个问题的辨析解释</h4><h5 id="7-3-1-白噪声的方差等于什么"><a href="#7-3-1-白噪声的方差等于什么" class="headerlink" title="7.3.1 白噪声的方差等于什么"></a>7.3.1 白噪声的方差等于什么</h5><p>当均值为零时，高斯白噪声的功率谱密度等于方差，此时的功率谱密度为双边功率谱密度，数字信号处理上面有关于这些的推导，$\dfrac{n_0}{2}$是双边功率谱密度，$n_0$为单边功率谱密度，一般都是考虑双边的。</p>
<p>通常文献所说的噪声的方差，是指加性高斯白噪声(AWGN)的经过采样后的采样值的方差，具体说，就是数字通信原理里说的在<strong>相关接收/或匹配滤波</strong>后的输出，此时的方差是$\dfrac{N_0}{2}$（见Proakis的digital communcations的第五章第一、二节）。</p>
<p>若说某个白高斯过程的方差是$\dfrac{N_0}{2}$，这个提法本身就是不严格的，因为对于均值为0的高斯白噪声，方差就是总功率，因为：</p>
<script type="math/tex; mode=display">
总功率=直流功率+交流功率=0+交流功率=0+方差</script><p>因为均值为0，所以直流功率为0，方差就是交流功率，亦即总功率。</p>
<p>根据白噪声的定义，其功率谱在整个频段上都是一个常数，此时总功率是对功率谱在整个频段上的积分，这个总功率自然就是无穷大的了。 实际上，即使输入的噪声真的是AWGN，经过相关接收/或匹配滤波后，噪声项就不再是白的了，因为相关接收/匹配滤波器本身就可以被看作是一个滤波器(积分器的系统函数为1,即是个低通)，<strong>wgn经过滤波器后，功率自然就不再是无穷大了</strong>，虽然它的相关接收/匹配滤波器输出采样值分布仍然是高斯的。</p>
<p><strong>如果有作者说“高斯白噪声服从的是均值为0，方差为$\dfrac{N_0}{2}$的高斯分布”，那一定是指白噪声经过相关接收/或匹配滤波后并采样获得的离散随机过程是均值为0，方差为$\dfrac{N_0}{2}$的高斯分。</strong> </p>
<blockquote>
<p>以上内容转自：<a href="https://zhidao.baidu.com/question/369362806302624204.html">白噪声的方差等于什么_百度知道 (baidu.com)</a></p>
</blockquote>
<h5 id="7-3-2-为什么高斯白噪声的平均功率等于方差"><a href="#7-3-2-为什么高斯白噪声的平均功率等于方差" class="headerlink" title="7.3.2 为什么高斯白噪声的平均功率等于方差"></a>7.3.2 为什么高斯白噪声的平均功率等于方差</h5><p>高斯白噪声$\xi(t)$是一种平稳的随机过程，假设该过程为<em>ξ</em>(<em>t</em>)，那么其自相关函数的定义如下： </p>
<script type="math/tex; mode=display">
R(t) =E(\xi(t) \xi(t+\tau))</script><p>随机过程的自相关函数非常重要，它有两条非常重要的性质： </p>
<ul>
<li>$R(0) = E(\xi^2(t)]$，表示平均功率</li>
<li>$R(\infty) = E^2(\xi(t))$，表示直流功率</li>
</ul>
<p>为什么$R(0)$表示平均功率，$R(\infty)$表示直流功率呢？</p>
<p>其实$R(0)$表示平均功率相对好理解一些，输入的信号是$ξ(t)$，信号的平方就是功率，对功率取个$E(\cdot)$，就是取平均，那就是平均功率了。</p>
<p>当$τ$为无穷大时，$ξ(t)$和$ξ(t+\tau)$相当于独立同分布的两个随机变量了，因此：</p>
<script type="math/tex; mode=display">
\begin{aligned}
R(\infty) &=E[\xi(t) \xi(t+\tau)] \\
&=E[\xi(t)] \cdot E[\xi(t+\tau)] \\
&=E[\xi(t)] \cdot E[\xi(t)] \\
&=E^2[\xi(t)]
\end{aligned}</script><p>这个就是信号先求平均(即直流分量)，再平方结果自然就是直流的功率了。 </p>
<p><strong>自相关函数$R(\tau)$也叫二阶原点矩，而自协方差函数$C(\tau)$是二阶中心矩</strong>，它的定义为： </p>
<script type="math/tex; mode=display">
\begin{aligned}
C(\tau) &=E[[\xi(t)-m(t)][\xi(t+\tau)-m(t+\tau)]] \\
&=E[\xi(t) \xi(t+\tau)]-m(t)) \cdot m(t+\tau)
\end{aligned}</script><p>其中，$m(t)$表示$t$时刻的平均值。当$\tau = 0$时，$C(0) = E[\xi^2 (t)]−m^2 (t) = R(0) − m^2 (t)$，即平均功率减去均值平方，表示方差。所以，对于高斯白噪声来说，它的均值为0，即$m(t)$为0，因此平均功率等于方差。</p>
<blockquote>
<p>以上内容转自：<a href="https://zhuanlan.zhihu.com/p/345016734">为什么高斯白噪声的平均功率等于方差？ - 张大侠的文章 - 知乎</a></p>
</blockquote>
<h5 id="7-3-3-待定。。。之后根据下面的链接进行补充"><a href="#7-3-3-待定。。。之后根据下面的链接进行补充" class="headerlink" title="7.3.3 待定。。。之后根据下面的链接进行补充"></a>7.3.3 待定。。。之后根据下面的链接进行补充</h5><p><a href="https://www.zhihu.com/question/52360072">为何连续高斯白噪声的方差定义是无穷大？ - 知乎</a>；<a href="https://blog.csdn.net/bananashoes/article/details/83029099">高斯白噪声解惑_hupipi96的博客-CSDN博客</a> ；<a href="https://blog.csdn.net/gllnupt/article/details/41149671?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-41149671-blog-83029099.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-41149671-blog-83029099.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=5">学了3,4年，终于明白了高斯白噪声的那些东西。_gllnupt的博客-CSDN博客</a> ；<a href="https://blog.csdn.net/lsg32/article/details/8646407?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-8646407-blog-83029099.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-8646407-blog-83029099.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=1">高斯噪声和高斯白噪声相关介绍_咆哮的狼的博客-CSDN博客</a> ；<a href="https://blog.csdn.net/hltt3838/article/details/125206849">高斯白噪声（white Gaussian noise，WGN）_他人是一面镜子，保持谦虚的态度的博客-CSDN博客</a> ；<a href="https://blog.csdn.net/From0_to1_/article/details/120947023">高斯白噪声与信噪比 - CSDN</a>；<a href="http://www.360doc.com/content/20/0119/23/13328254_887072728.shtml">噪声相关笔记 - 360个人图书馆</a>；<a href="http://staff.ustc.edu.cn/~wyzhou/chapter2%20basic.pdf">通信基本概念与基础知识</a>；<a href="https://www.sohu.com/a/155330773_464087">白噪声高斯噪声高斯白噪声的区别 - 搜狐</a>；<a href="https://blog.csdn.net/u011650143/article/details/69047456">高斯白噪声 - CSDN</a>；<a href="https://xk.qust.edu.cn/__local/5/48/53/C8018705C781490F59C28EDBA88_6B7849BC_7F781.pdf?e=.pdf">3.4 信道的加性噪声 一、噪声的分类 </a></p>
<h3 id="8-自相关矩阵与协方差矩阵"><a href="#8-自相关矩阵与协方差矩阵" class="headerlink" title="8 自相关矩阵与协方差矩阵"></a>8 自相关矩阵与协方差矩阵</h3><p><a href="https://blog.csdn.net/weixin_39910711/article/details/112726698?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%87%AA%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-112726698.nonecase&amp;spm=1018.2226.3001.4187">自相关函数与互相关函数 - CSDN</a></p>
<p><a href="https://blog.csdn.net/shulianghan/article/details/123248041?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166878585816782414963883%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166878585816782414963883&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-4-123248041-null-null.142^v65^pc_rank_34_queryrelevant25,201^v3^control_2,213^v2^t3_esquery_v2&amp;utm_term=%E8%87%AA%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">【数字信号处理】相关函数应用 ( 高斯白噪声 的 自相关函数 分析 )</a></p>
<p><a href="https://blog.csdn.net/feng__shuai/article/details/53609543?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166878585816782414963883%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166878585816782414963883&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-53609543-null-null.142^v65^pc_rank_34_queryrelevant25,201^v3^control_2,213^v2^t3_esquery_v2&amp;utm_term=%E8%87%AA%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">自相关函数的理解 - CSDN</a></p>
<p><a href="https://blog.csdn.net/qq_41691212/article/details/121870083">【什么是自相关矩阵，自协方差矩阵，互相关矩阵，互协方差矩阵？】 - CSDN</a></p>
<h3 id="9-卷积和相关"><a href="#9-卷积和相关" class="headerlink" title="9 卷积和相关"></a>9 卷积和相关</h3><p><a href="https://www.zhihu.com/question/22298352">如何通俗易懂地解释卷积？ - 知乎</a></p>
<p><a href="https://www.eet-china.com/mp/a80624.html">信号处理绕不过去的坎：相关与卷积 - 面包板</a></p>
<h3 id="10-条件期望"><a href="#10-条件期望" class="headerlink" title="10 条件期望"></a>10 条件期望</h3><h4 id="10-1-条件期望的定义-摘自Wiki"><a href="#10-1-条件期望的定义-摘自Wiki" class="headerlink" title="10.1 条件期望的定义(摘自Wiki)"></a>10.1 条件期望的定义(摘自Wiki)</h4><p>(1) 设$X$和$Y$都是离散型随机变量，则$X$在给定事件$Y=y_k$条件时的条件期望： </p>
<script type="math/tex; mode=display">
E(X \mid Y=y) = \sum_i x_i P(X=x_i \mid Y=y_k)</script><p>(2) 设$X$是连续型随机变量，$Y$是离散型随机变量，$X$在给定事件$Y=y_k$条件时的条件期望： </p>
<script type="math/tex; mode=display">
E(X \mid Y=y) = \int_{-\infty}^{\infty} x f_{X \mid Y}(x \mid Y=y_k) \text{ d}x</script><p> (3) 设$X$和$Y$都是连续型随机变量，联合概率密度为$f_{X,Y}(x,y)$，$Y$的密度函数为$f_Y(y)$，则$X$的条件概率密度函数：</p>
<script type="math/tex; mode=display">
f_{X \mid Y}(x \mid y) = \frac{f_{X,Y}(x,y)}{f_Y(y)}</script><p>在给定事件$Y=y$条件时的条件期望：</p>
<script type="math/tex; mode=display">
E(X \mid Y=y) = \int_{-\infty}^{\infty} x f_{X \mid Y}(x \mid y) \text{ d}x = \frac{1}{f_Y(y)}\int_{-\infty}^{\infty} x f_{X,Y}(x,y) \text{ d}x</script><h4 id="10-2-区分-E-X-、-E-X-mid-Y-、-E-X-mid-Y-y"><a href="#10-2-区分-E-X-、-E-X-mid-Y-、-E-X-mid-Y-y" class="headerlink" title="10.2 区分$E(X)$、$E(X \mid Y)$、$E(X \mid Y=y)$"></a>10.2 区分$E(X)$、$E(X \mid Y)$、$E(X \mid Y=y)$</h4><ul>
<li>$E(X)$：一个数；</li>
<li>$E(X \mid Y)$：随机变量，关于$Y$的函数，没有固定的$y$值；</li>
<li>$E(X \mid Y=y)$ ：不是随机变量，而是一个关于$y$的函数$f(y)$，对于给定的$y$，有唯一确定值与之对应。</li>
</ul>
<p>$E(X)$是对所有$\omega \in \Omega$， $X(\omega)$取值<strong>全体的加权平均</strong>；而$E(X \mid Y=y)$是局限在$\omega \in \begin{Bmatrix} \omega \mid Y(\omega)=y \end{Bmatrix}$时，$X(\omega)$ 取值<strong>局部的加权平均</strong>。</p>
<h4 id="10-4-全期望公式-Law-of-total-expectation"><a href="#10-4-全期望公式-Law-of-total-expectation" class="headerlink" title="10.4 全期望公式(Law of total expectation)"></a>10.4 全期望公式(Law of total expectation)</h4><p>设$X,Y$为随机变量，下列期望和条件期望均存在，则：</p>
<script type="math/tex; mode=display">
E(X) = E(E(X \mid Y))</script><ul>
<li>若$Y$为连续型随机变量，则：</li>
</ul>
<script type="math/tex; mode=display">
E(X) = E(E(X \mid Y)) = \int_{-\infty}^{\infty} E(X \mid Y = y) f_Y(y) \text{ d}y</script><ul>
<li>若$Y$为离散型随机变量，则：</li>
</ul>
<script type="math/tex; mode=display">
E(X) = E(E(X \mid Y)) = \sum_i E(X \mid Y = y_i) P(Y = y_i)</script><blockquote>
<p>以上内容转自：<a href="https://zhuanlan.zhihu.com/p/417592820">条件期望与全期望公式 - Ryan的文章 - 知乎</a></p>
</blockquote>
<h4 id="10-5-其他几点"><a href="#10-5-其他几点" class="headerlink" title="10.5 其他几点"></a>10.5 其他几点</h4><h5 id="10-5-1-条件期望是否能去掉"><a href="#10-5-1-条件期望是否能去掉" class="headerlink" title="10.5.1 条件期望是否能去掉"></a>10.5.1 条件期望是否能去掉</h5><p>(1) 设$h(\cdot)$是一个函数，则：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E(X \cdot h(Y))  &=  E[E(X \cdot h(Y) \mid Y)] \\
&=  \int_{-\infty}^{\infty} E(X \cdot h(Y) \mid Y = y) f_Y(y) \text{ d}y \\
&= \int_{-\infty}^{\infty} E(X \cdot h(y) \mid Y = y) f_Y(y) \text{ d}y \\
&=  \int_{-\infty}^{\infty} h(y)E(X \mid Y = y) f_Y(y) \text{ d}y \\
&= \int_{-\infty}^{\infty} h(y) [E(X)](Y)_{Y = y} f_Y(y) \text{ d}y \\
&= \int_{-\infty}^{\infty} h(y) G(Y)_{Y = y} f_Y(y) \text{ d}y
\end{aligned}</script><p>e.g. $X \sim \text{Exp}(Y)$，则：</p>
<script type="math/tex; mode=display">
\begin{aligned}
E(X)  &= E(E(X \mid Y)) \\
&=  \int_{-\infty}^{\infty} E(X \mid Y = y) f_Y(y) \text{ d}y \\
&= \int_{-\infty}^{\infty} G(Y)_{Y = y} f_Y(y) \text{ d}y \\
&= \int_{-\infty}^{\infty} \frac{1}{Y} \mid_{Y = y} f_Y(y) \text{ d}y \\
&= \int_{-\infty}^{\infty} \frac{1}{y} f_Y(y) \text{ d}y 
\end{aligned}</script><h3 id="11-群延时与相位延时"><a href="#11-群延时与相位延时" class="headerlink" title="11 群延时与相位延时"></a>11 群延时与相位延时</h3><p><a href="https://blog.csdn.net/qq_37335890/article/details/83043204?spm=1001.2101.3001.6650.19&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-19-83043204-blog-79203927.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-19-83043204-blog-79203927.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=21">信号与系统学习难点（一）群时延与相频特性</a></p>
<p><a href="https://blog.csdn.net/zhoupian/article/details/117935161">一文读懂群延时(Group Delay)：非常简单易懂</a></p>
<h3 id="12-幅频特性和相频特性"><a href="#12-幅频特性和相频特性" class="headerlink" title="12 幅频特性和相频特性"></a>12 幅频特性和相频特性</h3><p><a href="https://blog.csdn.net/christiedong10/article/details/122115486?spm=1001.2101.3001.6650.12&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-12-122115486-blog-83043204.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-12-122115486-blog-83043204.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=19">幅频特性和相频特性的物理意义</a></p>
<h3 id="13-维纳滤波器和平时所说的低通频域滤波器的区别"><a href="#13-维纳滤波器和平时所说的低通频域滤波器的区别" class="headerlink" title="13 维纳滤波器和平时所说的低通频域滤波器的区别"></a>13 维纳滤波器和平时所说的低通频域滤波器的区别</h3><p><a href="https://web.xidian.edu.cn/kywang/files/20171213_190142.pdf">第五章 数字滤波器的基本概念及一些特殊滤波器</a></p>
<h3 id="14-线性代数中各种矩阵的简介及其性质"><a href="#14-线性代数中各种矩阵的简介及其性质" class="headerlink" title="14 线性代数中各种矩阵的简介及其性质"></a>14 线性代数中各种矩阵的简介及其性质</h3><p><a href="https://blog.csdn.net/wnma3mz/article/details/90182652?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-90182652-blog-647511.pc_relevant_recovery_v2&amp;spm=1001.2101.3001.4242.3&amp;utm_relevant_index=7">线性代数中各种矩阵的简介</a></p>
<p><a href="https://blog.csdn.net/myan/article/details/647511?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-647511-blog-105778485.pc_relevant_recovery_v2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-647511-blog-105778485.pc_relevant_recovery_v2&amp;utm_relevant_index=10">理解矩阵（一）</a></p>
<p><a href="https://blog.csdn.net/I_canjnu/article/details/105778485?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-105778485-blog-104575987.pc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-105778485-blog-104575987.pc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=6">矩阵相关定义性质全总结</a></p>
<p><a href="https://blog.csdn.net/qq_41157212/article/details/104575987?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-104575987-blog-74169484.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">矩阵的分类以及性质</a></p>
<h3 id="15-向量的模和范数"><a href="#15-向量的模和范数" class="headerlink" title="15 向量的模和范数"></a>15 向量的模和范数</h3><h4 id="15-1-向量的模"><a href="#15-1-向量的模" class="headerlink" title="15.1 向量的模"></a>15.1 向量的模</h4><p>向量的模，表示向量的长度；向量$\boldsymbol x = (x_1, x_2, \cdots, x_n)^{\mathrm T}$它的模的计算公式：</p>
<script type="math/tex; mode=display">
|\boldsymbol x| = \sqrt{x_1^2+x_2^2+ \cdots + x_n^2}</script><h4 id="15-2-向量的常见范数"><a href="#15-2-向量的常见范数" class="headerlink" title="15.2 向量的常见范数"></a>15.2 向量的常见范数</h4><h5 id="15-2-0-向量的0范数"><a href="#15-2-0-向量的0范数" class="headerlink" title="15.2.0 向量的0范数"></a>15.2.0 向量的0范数</h5><p>向量中非零元素的个数 ；</p>
<h5 id="15-2-1-向量的1范数-L1范数、曼哈顿范数"><a href="#15-2-1-向量的1范数-L1范数、曼哈顿范数" class="headerlink" title="15.2.1 向量的1范数(L1范数、曼哈顿范数)"></a>15.2.1 向量的1范数(L1范数、曼哈顿范数)</h5><script type="math/tex; mode=display">
\|\boldsymbol x \|_1 = \sum_{i = 1}^{n} |x_i|</script><h5 id="15-2-2-向量的2范数-L2范数、欧式范数"><a href="#15-2-2-向量的2范数-L2范数、欧式范数" class="headerlink" title="15.2.2 向量的2范数(L2范数、欧式范数)"></a>15.2.2 向量的2范数(L2范数、欧式范数)</h5><script type="math/tex; mode=display">
\|\boldsymbol x \|_2 = \sqrt{\sum_{i = 1}^{n} x_i^2}</script><p><strong><font color="red">向量的2范数等价于向量的模长</font></strong>。</p>
<h5 id="15-2-3-向量的无穷范数-infty-范数、最大值范数"><a href="#15-2-3-向量的无穷范数-infty-范数、最大值范数" class="headerlink" title="15.2.3 向量的无穷范数($\infty$范数、最大值范数)"></a>15.2.3 向量的无穷范数($\infty$范数、最大值范数)</h5><script type="math/tex; mode=display">
\| \boldsymbol x \|_{\infty} = \max_{1 \leq i \leq n} |x_i|</script><h5 id="15-2-4-向量的p范数"><a href="#15-2-4-向量的p范数" class="headerlink" title="15.2.4 向量的p范数"></a>15.2.4 向量的p范数</h5><script type="math/tex; mode=display">
\| \boldsymbol x \|_p = \left( \sum _{i = 1}^{n} |x_i|^p \right)^{\frac{1}{p}}</script><blockquote>
<p>临时补充：复数的模</p>
<p>$z_1 = a + bi$、$z_2 = c + di$</p>
<p>$|z_1 \times z_2| = |z_1| \times |z_2|$</p>
<p>$\left|\dfrac{z_1}{z_2} \right| = \dfrac{|z_1|}{|z_2|}$</p>
</blockquote>
<p><a href="https://blog.csdn.net/geter_CS/article/details/85100045?spm=1001.2101.3001.6650.13&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-13-85100045-blog-87282642.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-13-85100045-blog-87282642.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=21">熟悉陌生的2-范数（向量的模）</a></p>
<p><a href="https://blog.csdn.net/linkequa/article/details/87282642?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EESLANDING%7Edefault-4-87282642-blog-81698878.pc_relevant_landingrelevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EESLANDING%7Edefault-4-87282642-blog-81698878.pc_relevant_landingrelevant&amp;utm_relevant_index=9">向量 模（module） 范数（norm）</a></p>
<h3 id="16-充分性，必要性，充分条件，必要条件的区别"><a href="#16-充分性，必要性，充分条件，必要条件的区别" class="headerlink" title="16 充分性，必要性，充分条件，必要条件的区别"></a>16 充分性，必要性，充分条件，必要条件的区别</h3><h4 id="16-1-概述"><a href="#16-1-概述" class="headerlink" title="16.1 概述"></a>16.1 概述</h4><p>令：$A$是命题，$B$是结论，则有：</p>
<ul>
<li>$A \longrightarrow B$：$A$是$B$的充分条件；<ul>
<li>$A$成立$B$一定成立，$A$不成立$B$不一定不成立。</li>
</ul>
</li>
<li>$B \longrightarrow A$：$A$是$B$的必要条件；<ul>
<li>$A$成立$B$不一定成立，$A$不成立$B$一定不成立。</li>
</ul>
</li>
<li>$A \longleftrightarrow B$：$A$和$B$互为充要条件（充分必要），即$B$成立当且仅当$A$成立。</li>
</ul>
<blockquote>
<p>E.g. 说$B$的充要条件是$A$，是把后者作为条件：</p>
<p>即证$B$的充要条件是$A$，是：证充分性（$A \longrightarrow B$），证必要性（$B \longrightarrow A$）</p>
</blockquote>
<p>转载于：<a href="https://www.cnblogs.com/acha/p/6263887.html">充分性，必要性，充分条件，必要条件的区别 - 博客园 - 用户_zwl </a></p>
<h4 id="16-2-充分条件、必要条件、充要条件"><a href="#16-2-充分条件、必要条件、充要条件" class="headerlink" title="16.2 充分条件、必要条件、充要条件"></a>16.2 充分条件、必要条件、充要条件</h4><p>以初中平面几何中的全等三角形的判定定理1：若两个三角形的三条对应边均相等，则这两个三角形全等为例，首先引入充分条件与必要条件。</p>
<ul>
<li><strong>充分条件：</strong> 若已知两三角形三边对应相等，则两三角形全等 ，也就是说：两个三角形三边对应相等是这两个三角形全等成立的充分条件 。其中充分条件的含义是，若两三角形三边对应相等，则有充分理由断定“这两个三角形全等”成立。</li>
<li><strong>必要条件：</strong> 若已知两个三角形全等，则这两个三角形三条边对应相等 ，也就是说：两个三角形三边对应相等是这两个三角形全等成立的必要条件 。其中必要条件的含义是，若两个三角形全等，则必定需要 满足一个条件：“两三角形三边对应相等”，即只有满足了这个条件，这两个三角形全等才成立。</li>
<li><strong>充分必要条件：</strong> 结合上述两部分论断，我们可以得到如下的命题：两三角形全等的充要条件是这两个三角形的三边对应相等。</li>
</ul>
<h4 id="16-3-充分性、必要性"><a href="#16-3-充分性、必要性" class="headerlink" title="16.3 充分性、必要性"></a>16.3 充分性、必要性</h4><ul>
<li><strong>充分性：</strong>常用箭头$\Longleftarrow$表示，即由条件推出结论（假设两三角形三边对应相等成立，来证明两三角形全等）。</li>
<li><strong>必要性：</strong>常用箭头$\Longrightarrow$表示，即由结论推条件（假设两三角形全等成立，来证明三角形三边对应相等）。</li>
</ul>
<h4 id="16-4-定义"><a href="#16-4-定义" class="headerlink" title="16.4 定义"></a>16.4 定义</h4><p>有了上面的例子，很容易得到充分条件、必要条件等的定义：</p>
<p>设$A$、$B$是两个命题，并且有：$A$成立的充要条件是$B$成立，则：</p>
<ul>
<li><strong>充分条件：</strong>若$B$成立则$A$成立，即$B$成立是$A$成立的充分条件。</li>
<li><strong>必要条件：</strong>若$A$成立则$B$成立，即$B$成立是$A$成立的必要条件。</li>
<li><strong>充分性：</strong> 用 $\Longleftarrow$代替，即“假定$B$成立，去证明$A$成立”(条件推结论)。</li>
<li><strong>必要性：</strong> 用$\Longrightarrow$代替，即“假定$A$成立，去证明$B$成立”(结论推条件)。</li>
</ul>
<h4 id="16-5-“当且仅当”（if-and-only-if）"><a href="#16-5-“当且仅当”（if-and-only-if）" class="headerlink" title="16.5 “当且仅当”（if and only if）"></a>16.5 “当且仅当”（if and only if）</h4><p>有时候也会用到<strong>“当且仅当”</strong>一词来表示<strong>充要条件</strong> 。仍用上面所举三角形全等的例子，就可以说：两三角形全等当且仅当两三角形三边对应相等。也可以一般化为：$A$成立当且仅当$B$成立，这时：</p>
<ul>
<li><strong>充分条件：</strong>当$B$成立时$A$成立（$B$成立能充分说明$A$成立）。</li>
<li><strong>必要条件：</strong>仅当$B$成立时$A$才成立（$B$成立是$A$成立所必定需要的）。</li>
</ul>
<h4 id="16-6-补充：充分必要条件的意义"><a href="#16-6-补充：充分必要条件的意义" class="headerlink" title="16.6 补充：充分必要条件的意义"></a>16.6 补充：充分必要条件的意义</h4><p>$A$成立的充要条件是$B$成立，说明命题$A$与$B$是相互等价的，是同一现象（事物）的不同表现形式。<br>也即：若$A$成立的充要条件是$B$成立，则得到$A$与$B$互为充要条件。</p>
<h4 id="16-7-找准哪个命题是“充要条件”"><a href="#16-7-找准哪个命题是“充要条件”" class="headerlink" title="16.7 找准哪个命题是“充要条件”"></a>16.7 找准哪个命题是“充要条件”</h4><p>实际运用中，常会出现两种十分相似的表述，但是二者仍有很大区别，即</p>
<ul>
<li>$A$成立的充要条件是$B$。</li>
<li>$A$成立是$B$成立的充要条件。</li>
</ul>
<p>在第一种表述中，可以认为$A$是“结论”，$B$是“条件”；</p>
<p>而第二种表述恰恰相反。如果在实际分析中出现了第二种表述，就不能简单地认为$A\Longrightarrow B$是必要性了，还需要找到哪个命题是“条件”，哪个命题是“结论”，然后进行进一步的分析。</p>
<p>转载于：<a href="https://blog.csdn.net/qq_41437512/article/details/108066877">理解充分条件与必要条件 - CSDN - CSDN用户zorchp </a></p>
<h3 id="17-概率论——总体、样本、统计量-顺序统计量-的基本概念"><a href="#17-概率论——总体、样本、统计量-顺序统计量-的基本概念" class="headerlink" title="17 概率论——总体、样本、统计量(顺序统计量)的基本概念"></a>17 概率论——总体、样本、统计量(顺序统计量)的基本概念</h3><h4 id="17-1-总体"><a href="#17-1-总体" class="headerlink" title="17.1 总体"></a>17.1 总体</h4><p>总体是与我们所研究的问题有关的所有个体组成，而样本是总体中抽取的一部分个体。若总体中个体的数目为有限个，则称为有限总体, 否则称为无限总体。 </p>
<p><strong>关于总体的一个争论：总体是不是一个随机变量？</strong></p>
<p>具体可以参考下面这个链接：<a href="https://www.zhihu.com/question/301826927">为什么总体和样本都是随机变量？ - 知乎</a></p>
<h4 id="17-2-样本"><a href="#17-2-样本" class="headerlink" title="17.2 样本"></a>17.2 样本</h4><p><strong><font color="red">样本具有两重性</font></strong>，意思是样本<strong>既可看成具体的数，又可以看成随机变量(或随机向量)</strong>。在完成抽样后，它是具体的数；在实施抽样前，它被看成随机变量。因为在实施具体抽样之前无法预料抽样的结果，只 能预料它可能取值的范围，故可把它看成一个随机变量，因此才有概率分布可言。为区别起见，今后用大写的英文字母表示随机变量或随机向量，用小写字母表示具体的观察值。</p>
<h4 id="17-3-统计量"><a href="#17-3-统计量" class="headerlink" title="17.3 统计量"></a>17.3 统计量</h4><p><strong>数理统计的任务是通过样本去推断总体</strong>。而样本自身是一些杂乱无章的数字，要对这些数字进行加工整理，计算出一些有用的量。可以这样理解：这种由样本算出来的量，把样本中与所要解决的问题有关的信息集中起来了我们把这种量称为统计量，其定义如下：</p>
<p><strong>由样本算出的量是统计量，或者是统计量是样本的函数</strong>。对这一定义我们作如下几点说明: </p>
<ul>
<li><p>统计量只与样本有关，不能与未知参数有关。</p>
<ul>
<li>例如，$X \sim N(\mu, \sigma^2)$，当$\mu$和$\sigma^2$皆为未知参数时，$\sum _ {i=1}^{n}(X_i-\mu)^2$和$\sum _ {i=1}^{n}\dfrac{X_i^2}{\sigma^2}$都不是统计量，而$\sum _ {i=1}^{n}X_i ^2$和$\sum_{i=1}^{n}X_i^2$均是统计量</li>
</ul>
</li>
<li>由于样本具有两重性，同时统计量是样本的函数，因此统计量也具有两重性。正因为统计量可视为随机变量(或随机向量)，因此才有概率分布可言，这是利用统计量进行统计推断的依据。 </li>
<li>在什么问题中选用什么统计量，要看问题的性质。一般说来，所提出的统计量应是最好的集中了样本中与所讨论问题有关的信息，这不是容易做到的。</li>
</ul>
<h4 id="17-4-顺序统计量"><a href="#17-4-顺序统计量" class="headerlink" title="17.4 顺序统计量"></a>17.4 顺序统计量</h4><p>首先直接说明几点前提和结论：</p>
<ul>
<li>随机变量不可以比较大小；</li>
<li>顺序统计量属于随机变量。</li>
</ul>
<h5 id="17-4-1-顺序统计量的定义"><a href="#17-4-1-顺序统计量的定义" class="headerlink" title="17.4.1 顺序统计量的定义"></a>17.4.1 顺序统计量的定义</h5><p>顺序统计量：</p>
<script type="math/tex; mode=display">
X_{(1)}\le X_{(2)}\le \dots\le X_{(n)}</script><p>其中，$X _ {(1)}=\min\begin{Bmatrix}X_1,\dots,X_n\end{Bmatrix}$，$X_{(n)}=\max\begin{Bmatrix}X_1, \cdots, X_n\end{Bmatrix}$，$X_{(k)}$为$X_1, \cdots, X_n$的递增排序的第$k$位。$X _ {(n)}-X_{(1)}$样本极差。</p>
<h5 id="17-4-2-关于顺序统计量的理解"><a href="#17-4-2-关于顺序统计量的理解" class="headerlink" title="17.4.2 关于顺序统计量的理解"></a>17.4.2 关于顺序统计量的理解</h5><p>其实到写到这为止感觉还是没有透彻理解顺序统计量，我自己关于顺序统计量主要有两个疑点：</p>
<ul>
<li>从表面上看，顺序统计量就是对随机变量大小排序，但是我们知道随机变量是不能比较大小的。</li>
<li>其次，为什么顺序统计量是一个随机变量，感觉随机变量排序后只是一个大小的比较结果，咋就能视为一个随机变量了呢？</li>
</ul>
<p>首先，先说一下我的简单理解：</p>
<p>从总体中抽出$n$个样本$X_1, \cdots, X_n$，我们想要了解这些样本中大小排第$k$的样本(随机变量)的分布情况$F_{X_{(k)}}(x_k) = P(X _ {(k)} &lt; x_k)$，由于$k$的取值可以从$1 \sim n$，即我们先研究排序中每一位置的分布情况，所以何不就直接从小到大排个序，这也就导出了顺序统计量。</p>
<p>其次，我们看一下ChatGPT的回答：</p>
<ul>
<li>问：随机变量能比较大小吗？<ul>
<li>答：不可以，随机变量是数值不确定的变量，它们本身并不具有可比性，不能比较大小。但是我们可以对随机变量的概率分布进行比较，即可以比较两个随机变量所代表的概率分布的差异程度。 </li>
</ul>
</li>
<li>问：随机变量不能比较大小为什么会出现顺序统计量？<ul>
<li>答1：顺序统计量并不是指对随机变量进行大小比较，而是指对样本数据进行排序，将数据按照其大小排列，并编号。顺序统计量是样本中某一数值的排名，通常用于研究样本分布的性质，如判断样本的正态性等。因此，顺序统计量是由样本数据而不是随机变量生成的。 </li>
<li>答2：随机变量是描述随机现象的数学概念，不能直接比较大小。但是，我们可以通过研究其特定分布情况，对其进行统计分析，以得到有关其大小关系的统计结论。因此，出现了顺序统计量的概念，即对随机变量的样本数据进行排序，从而对其分布情况进行研究。 </li>
</ul>
</li>
<li>问：顺序统计量是随机变量但随机变量不是不能比较大小吗？<ul>
<li>答：顺序统计量和随机变量是两个不同的概念，顺序统计量是对随机变量的一种排列（即大小顺序）的统计描述。顺序统计量是随机变量，因为其值取决于随机变量的值，并且随机变量值不同时顺序统计量值也不同。然而，随机变量本身不能比较大小，因为它是一个概率分布，只能描述数据的可能性，而不能对数据的大小进行比较。 </li>
</ul>
</li>
<li>问：如何理解你说的“顺序统计量是对随机变量的一种排列（即大小顺序）的统计描述”，你的意思不就是对随机变量比较大小然后排序吗 ？<ul>
<li>答：是的，顺序统计量通过比较随机变量的大小并将其进行排序，得出其大小顺序，以此作为对随机变量的统计描述。但是这种比较大小和排序行为仅仅是在计算上的表现，并不能说明随机变量本身具有大小关系，因为随机变量本身并不具有确定的值。 </li>
</ul>
</li>
<li>问：请问“但是这种比较大小和排序行为仅仅是在计算上的表现，并不能说明随机变量本身具有大小关系”这句话能不能详细解释一下？<ul>
<li>答：所谓“比较大小和排序行为仅仅是在计算上的表现”，是指我们在研究统计问题时，常常需要对一组随机变量的取值进行比较和排序，以得到更直观、客观的描述。然而，这种比较大小和排序的行为，只是计算的一种方法，并不能真实反映出随机变量本身的大小关系，因为随机变量的大小关系是不确定的，只能通过概率的方式来表示。 </li>
</ul>
</li>
</ul>
<p>关于这一部分，主要参考下面的链接，特别注意第一个链接特别好：</p>
<p><a href="http://staff.ustc.edu.cn/~zwp/teach/Prob-Stat/Lec12_slides.pdf">概率论与数理统计课件 - 张伟平 - USTC</a>；<a href="http://staff.ustc.edu.cn/~zwp/index.html">张伟平个人主页 - 统计与金融系教授</a></p>
<p><a href="https://bookdown.org/hezhijian/book/intro.html#section-8">数理统计讲义</a></p>
<p><a href="https://www.cnblogs.com/jy333/p/14345941.html">数理统计1：数理统计的概念，总体与样本，统计量 - 江景平个人</a></p>
<h3 id="18-条件概率和事件的交的概率有什么区别"><a href="#18-条件概率和事件的交的概率有什么区别" class="headerlink" title="18 条件概率和事件的交的概率有什么区别"></a>18 条件概率和事件的交的概率有什么区别</h3><p>简单来说：</p>
<ul>
<li><p>条件概率是已知前提条件中描述的事件发生了。</p>
</li>
<li><p>事件的交则是涉及到的事件均还没有发生，求这几个事件一块发生的概率。</p>
</li>
</ul>
<blockquote>
<p>本质上来说，条件概率减小了事件的空间，而一般事件的交仍然是整个样本空间$\Omega$</p>
</blockquote>
<p>常见题目中的字眼：</p>
<ul>
<li>若出现“在已知。。。”，则一般为条件概率；</li>
<li>若一般出现“并且、且”等字眼，则为事件的交。</li>
</ul>
<p>参考链接：<a href="https://zhidao.baidu.com/question/988259011390372139.html">概率论中，条件概率和事件的交的概率有什么区别</a></p>
<h3 id="19-随机向量"><a href="#19-随机向量" class="headerlink" title="19 随机向量"></a>19 随机向量</h3><ul>
<li>根据参考链接[19.1]的评论区：<ul>
<li>总体研究的是一项数量指标还是多个维度的数量指标？比如一个班上的学生是一个总体，$X_1$是身高，$X_2$是体重，样本是$(X_1, X_2)$是个二维随机变量。还是总体只研究一个指标，比如身高$X$，$(X_1, X_2)$是样本，代表第一个学生和第二个学生的身高值。知乎博主给出的回答是：都可以，看你怎么定义研究的内容。 </li>
</ul>
</li>
<li>根据参考链接[19.2]给的例子：<ul>
<li>当个体上的数量指标不止一项时，我们用随机向量来表示总体。例如研究某地区小学生的发育状况时，人们关心的是其身高$X$和体重$Y$这两个数量指标，此时总体就可以用二维随机向量$ (X，Y)$或其联合分布$F(x, y)$表示。</li>
</ul>
</li>
</ul>
<blockquote>
<p>此外，我还从今天(2023.02.08)发现的最强大的智能对话ChatGPT上，通过问答获得以下结果：</p>
<p><img src="https://pic.imgdb.cn/item/63e3b44c4757feff33bd3f3b.jpg" style="zoom:70%"></p>
</blockquote>
<p>参考链接：</p>
<p>【19.1】<a href="https://www.zhihu.com/question/301826927/answer/528085629">为什么总体和样本都是随机变量？ - 杜克清风侠的回答 - 知乎</a></p>
<p>【19.2】<a href="http://staff.ustc.edu.cn/~zwp/teach/Prob-Stat/Lec12_slides.pdf">概率论与数理统计课件 - 张伟平 - USTC</a></p>
<h3 id="20-矩阵相关定义性质全总结"><a href="#20-矩阵相关定义性质全总结" class="headerlink" title="20 矩阵相关定义性质全总结"></a>20 矩阵相关定义性质全总结</h3><h4 id="20-1-基本概念"><a href="#20-1-基本概念" class="headerlink" title="20.1 基本概念"></a>20.1 基本概念</h4><ul>
<li><strong>矩阵定义：</strong>$m \times n$矩阵为$m \times n$个数排成的$m$行$n$列的表格，当$m=n$时，矩阵$\boldsymbol A$称为$n$阶方阵。</li>
<li><strong>零矩阵：</strong>矩阵所有元素都为0，在下文中用$\boldsymbol O$表示。</li>
<li><strong>单位阵：</strong>对角线全为1，其他全为0的方阵，一般用$\boldsymbol I$或$\boldsymbol E$表示，本文用$\boldsymbol I$，用$\boldsymbol E$表示初等矩阵。</li>
<li><strong>同型矩阵：</strong>$\boldsymbol A$矩阵为$m \times n$矩阵，$\boldsymbol B$矩阵为$s \times t$矩阵，若$m=s,n=t$，$\boldsymbol A$和$\boldsymbol B$为同型矩阵。</li>
<li><strong>矩阵相等：</strong>$\boldsymbol A$和$\boldsymbol B$相等意味着两个同型矩阵对应的元素都相等。</li>
<li><strong>矩阵行列式：</strong>$n$阶方阵$\boldsymbol A$构成的行列式，一般记为：$\det \boldsymbol A$或者$|\boldsymbol A|$。</li>
</ul>
<blockquote>
<p>注意：<br>只有方阵才有行列式；矩阵$\boldsymbol A$是表格，而行列式$|\boldsymbol A|$是数。</p>
</blockquote>
<h4 id="20-2-基本运算"><a href="#20-2-基本运算" class="headerlink" title="20.2 基本运算"></a>20.2 基本运算</h4><ul>
<li><strong>乘法：</strong>设$\boldsymbol A$是一个$m \times s$矩阵，$\boldsymbol B$是一个$s \times t$矩阵(即左矩阵的列数=右矩阵的行数)，则乘积$\boldsymbol{AB}$是一个$m \times t$矩阵，记为$\boldsymbol C$。</li>
<li><strong>矩阵多项式：</strong> 设$\boldsymbol A$是$n$阶矩阵，$f(x)=a_m x^m+ \cdots +a_1 x+a_0$是$x$的多项式，则称$a_m\boldsymbol A^m+a_{m-1}\boldsymbol A^{m-1}+ \cdots +a_1\boldsymbol A+a_0 \boldsymbol I$为矩阵多项式，记为$f(\boldsymbol A)$。</li>
</ul>
<p>注意一下几点：</p>
<ol>
<li>一般情况$\boldsymbol{AB} \neq \boldsymbol{BA}$；</li>
<li>$\boldsymbol A \neq \boldsymbol O$，$\boldsymbol B \neq \boldsymbol O$，但有可能$\boldsymbol{AB} = \boldsymbol O$；</li>
<li>$\boldsymbol{AB} = \boldsymbol{AC}, \boldsymbol A \neq \boldsymbol O$不能推出$\boldsymbol B = \boldsymbol C$；</li>
<li>$\boldsymbol{AB} = \boldsymbol O$可推出$\boldsymbol B$的列向量是$\boldsymbol{Ax}= \boldsymbol 0$的解；</li>
</ol>
<h4 id="20-3-矩阵基础操作"><a href="#20-3-矩阵基础操作" class="headerlink" title="20.3 矩阵基础操作"></a>20.3 矩阵基础操作</h4><h5 id="20-3-1-矩阵转置"><a href="#20-3-1-矩阵转置" class="headerlink" title="20.3.1 矩阵转置"></a>20.3.1 矩阵转置</h5><p><strong>(一) 定义</strong></p>
<p>将$m \times n$型矩阵$\boldsymbol A=(a_{ij})_{m \times n}$的行列互换的到的$n \times m$矩阵$(a_{ji})_{n \times m}$，称为$\boldsymbol A$的转置矩阵。 </p>
<p><strong>(二) 性质</strong></p>
<ol>
<li>$(\boldsymbol A + \boldsymbol B)^{\mathrm T} = \boldsymbol A^{\mathrm{T}} + \boldsymbol B^{\mathrm{T}}$</li>
<li>$(k\boldsymbol A)^{\mathrm T} = k\boldsymbol A^{\mathrm T}$</li>
<li>$(\boldsymbol A \boldsymbol B)^{\mathrm T} = \boldsymbol B^{\mathrm T}\boldsymbol A^{\mathrm T}$</li>
</ol>
<h5 id="20-3-2-伴随矩阵"><a href="#20-3-2-伴随矩阵" class="headerlink" title="20.3.2 伴随矩阵"></a>20.3.2 伴随矩阵</h5><p><strong>(一) 余子式和代数余子式</strong></p>
<ul>
<li><strong>余子式：</strong>是指在$n$阶行列式中，把元素$a_{ij}$(其中$i$和$j$分别表示行和列)所在的第$i$行和第$j$列划去后，留下来的$n-1$阶行列式叫做元素$a_{ij}$的余子式，记做$M_{ij}$。</li>
<li><strong>代数余子式：</strong>在余子式的基础上，记$A_{ij}=(-1)^{i+j}M_{ij}$，叫做元素$a_{ij}$的代数余子式。</li>
</ul>
<blockquote>
<p>注意：<br>只有方阵才有余子式，余子式和代数余子式都是一个行列式，其结果是一个数而不是矩阵。 </p>
</blockquote>
<p>只讲概念比较枯燥，通过例题计算更直观，例如计算下面这个行列式的$a_{32}$元素的余子式和代数余子式分别是多少： </p>
<script type="math/tex; mode=display">
\left|\begin{array}{lll}
a_ {11}& a_ {12} & a_ {13} \\
a_ {21} & a_ {22} & a_ {23} \\
a_ {31} & a_ {32} & a_ {33}
\end{array}\right|</script><p>根据概念，所谓$a_{32}$的余子式就是把$a_{32}$所在的行和列划去，留下来的行列式，那么$a_{32}$的余子式就是：</p>
<script type="math/tex; mode=display">
M_{32}= \left|\begin{array}{ll}
a_ {11}& a_ {13} \\
a_ {21} & a_ {23}
\end{array}\right|</script><p>那么，顺势而推，$a_{32}$的代数余子式就是：</p>
<script type="math/tex; mode=display">
A_{32} = (-1)^{3+2}\left|\begin{array}{ll}
a_ {11}& a_ {13} \\
a_ {21} & a_ {23}
\end{array}\right|</script><p><strong>(二) 伴随矩阵</strong></p>
<p>矩阵$\boldsymbol A​$的伴随矩阵一般记为$\boldsymbol A^*​$。由矩阵$\boldsymbol A​$的所有代数余子式构成，列对应行。</p>
<p>方阵$\boldsymbol A = (a_{ij})_{n \times n}$的各个元素的代数余子式转置构成伴随矩阵$\boldsymbol A^*$：</p>
<script type="math/tex; mode=display">
\boldsymbol A^* = \left(\begin{array}{cccc}
A_{11} & A_{21} & \cdots & A_{n1} \\
A_{12} & A_{22} & \cdots & A_{n2} \\
\vdots & \vdots & \ddots & \vdots\\
A_{1n} & A_{2n} & \cdots & A_{nn}
\end{array}\right)</script><p><strong>(三) 相关性质</strong></p>
<ol>
<li>$\boldsymbol A \boldsymbol A^ <em> =$ $\boldsymbol A^ </em> \boldsymbol A = |\boldsymbol A|\boldsymbol I$</li>
<li>$(\boldsymbol A^ <em> )^{-1} =$ $(\boldsymbol A^{-1})^ </em> $1</li>
<li>$(k \boldsymbol A)^ <em>  =$ $k^{n-1}\boldsymbol A^ </em> $</li>
<li>$(\boldsymbol A^ <em> )^{\mathrm{T}} =$ $(\boldsymbol A^{\mathrm{T}})^</em>$</li>
<li>$|\boldsymbol A^ * | = |\boldsymbol A|^{n-1}$</li>
<li>$\boldsymbol A^{-1} = \dfrac{1}{|\boldsymbol A|}\boldsymbol A^ * $</li>
<li>$(\boldsymbol{AB})^<em> =$ $\boldsymbol B^ </em> \boldsymbol A^ * $</li>
<li><p>伴随矩阵的秩：</p>
<ul>
<li>$\mathrm{rank}(\boldsymbol A^ * ) = n, \mathrm{rank}(\boldsymbol A) = n$</li>
<li>$\mathrm{rank}(\boldsymbol A^ * ) = 1, \mathrm{rank}(\boldsymbol A) = n-1$</li>
<li>$\mathrm{rank}(\boldsymbol A^ * ) = 0, \mathrm{rank}(\boldsymbol A) &lt; n-1$</li>
</ul>
<blockquote>
<p>矩阵的秩等于0的充分必要条件是这个矩阵是零矩阵。 </p>
</blockquote>
</li>
</ol>
<h5 id="20-3-3-逆矩阵"><a href="#20-3-3-逆矩阵" class="headerlink" title="20.3.3 逆矩阵"></a>20.3.3 逆矩阵</h5><p><strong>(一) 定义</strong></p>
<p>只有方阵才有逆矩阵，非方阵可以定义伪逆。</p>
<p>若$\boldsymbol A$、$\boldsymbol B$为$n$阶方阵，且满足：$\boldsymbol{AB} = \boldsymbol{BA} = \boldsymbol I$，则$\boldsymbol A$和$\boldsymbol B$互为逆矩阵，即：</p>
<script type="math/tex; mode=display">
\boldsymbol A^{-1} = \boldsymbol B; \quad \boldsymbol B^{-1} = \boldsymbol A</script><p><strong>(二) $n$阶矩阵$\boldsymbol A$可逆的充分必要条件</strong></p>
<ol>
<li>存在$n$阶矩阵$\boldsymbol A$，使$\boldsymbol{AB} = \boldsymbol I$或者$\boldsymbol{BA} = \boldsymbol I$；</li>
<li>$|\boldsymbol A|≠ 0​$，或者$\boldsymbol A​$满秩，或者$\boldsymbol A​$的列(行)向量线性无关；</li>
<li>齐次方程组$\boldsymbol{Ax = 0}$只有零解；</li>
<li>任意$\boldsymbol b$，非齐次线性方程组$\boldsymbol{Ax = b}$总有唯一解；</li>
<li>矩阵$\boldsymbol A$的所有特征值均不等于0；</li>
<li>能表示成一些初等矩阵的乘积：PN…P2P1A=E</li>
</ol>
<p><strong>(三) 性质</strong></p>
<ol>
<li>$k≠0$，$(k\boldsymbol A)^{-1}=\dfrac{1}{k} \boldsymbol A^{-1}$</li>
<li>$(\boldsymbol A \boldsymbol B)^{-1} = \boldsymbol B^{-1} \boldsymbol A^{-1}$</li>
<li>$(\boldsymbol A^{\mathrm T})^{-1} = (\boldsymbol A^{-1})^{\mathrm T}$</li>
<li>$|\boldsymbol A^{-1}| = \dfrac{1}{|\boldsymbol A|}$</li>
</ol>
<blockquote>
<p>注意：即使$\boldsymbol A$、$\boldsymbol B$和$\boldsymbol A + \boldsymbol B$都可逆，一般的$(\boldsymbol A + \boldsymbol B)^{-1} \neq  \boldsymbol A^{-1}+\boldsymbol B^{-1}$。</p>
</blockquote>
<p><strong>(四) 矩阵求逆方法</strong></p>
<ul>
<li><strong>公式法：</strong>$|\boldsymbol A| \neq 0$，则$\boldsymbol A^{-1} = \dfrac{1}{|\boldsymbol A|}\boldsymbol A^*$</li>
<li><strong>初等变换：</strong>$(\boldsymbol A \mid \boldsymbol I) \longrightarrow (\boldsymbol I \mid \boldsymbol A^{-1})$</li>
</ul>
<h5 id="20-3-4-初等矩阵、行阶梯矩阵和行最简矩阵"><a href="#20-3-4-初等矩阵、行阶梯矩阵和行最简矩阵" class="headerlink" title="20.3.4 初等矩阵、行阶梯矩阵和行最简矩阵"></a>20.3.4 初等矩阵、行阶梯矩阵和行最简矩阵</h5><p><strong>(一) 初等变换</strong></p>
<p>设$\boldsymbol A$是$m \times n$矩阵，进行初等倍乘、互换、倍加行(列)变换，统称为初等变换。</p>
<ol>
<li><strong>倍乘：</strong>用某个非零常数$k(k≠0)$乘$\boldsymbol A$的某行(列)的每个元素，此时行列式的值乘以$k$。</li>
<li><strong>互换</strong>：互换$\boldsymbol A$的某两行(列)的位置，此时行列式变为相反数，即行列式的值会乘以-1。</li>
<li><strong>倍加行(列)：</strong>将$\boldsymbol A$的某行(列)元素的$k$倍加到另一行(列)，此时行列式不变。</li>
</ol>
<p><strong>(二) 初等矩阵</strong></p>
<p>单位矩阵经<strong>一次</strong>初等变换得到的矩阵为初等矩阵。 常见初等矩阵的表示可用$\boldsymbol E$、$\boldsymbol P$或者$\boldsymbol Q$这3个字母。</p>
<p><strong>(三) 等价矩阵</strong></p>
<p>在线性代数和矩阵论中，有两个$m \times n$阶矩阵$\boldsymbol A$和$\boldsymbol B$，如果这两个矩阵满足：</p>
<script type="math/tex; mode=display">
\boldsymbol P \boldsymbol A \boldsymbol Q = \boldsymbol B</script><p>其中，$\boldsymbol P$是$m \times m$阶可逆矩阵，$\boldsymbol Q$是$n \times n$阶可逆矩阵），那么这两个矩阵之间是等价关系。也就是说，存在可逆矩阵$\boldsymbol P、\boldsymbol Q$，使得$\boldsymbol A$经过有限次的初等变换得到$\boldsymbol B$。 </p>
<blockquote>
<p>注意：<br><strong><font color="green">左乘矩阵</font></strong>相当于对原矩阵进行了初等行变换，<strong><font color="green">右乘矩阵</font></strong>相当于对原矩阵进行了初等列变换。 </p>
</blockquote>
<p><strong>(四) 性质</strong></p>
<ol>
<li>初等矩阵的<strong>转置</strong>仍然是初等矩阵；</li>
<li>初等矩阵均是可逆矩阵($\boldsymbol E$，满秩)，且其逆矩阵仍是初等矩阵；</li>
<li>用初等矩阵$\boldsymbol E$左乘(右乘)$\boldsymbol A$，其结果$\boldsymbol{EA}$($\boldsymbol{AE}$)相当于对$\boldsymbol A$作相应的初等行(列)变换。</li>
</ol>
<p><strong>(五) 行阶梯矩阵、行最简矩阵</strong></p>
<ul>
<li><strong>行阶梯矩阵</strong><ul>
<li>如果矩阵有零行(即这一行元素全是0)，则零行在最底部；</li>
<li>每个非零元素的主元(即该行的最左边的第一个非零元)，它们的列指标随着行指标的递增而严格增大。</li>
</ul>
</li>
<li><strong>行最简矩阵</strong>：<ul>
<li>是行阶梯矩阵；</li>
<li>非零行的主元都是1；</li>
<li>主元所在的列的其他元素都是0。</li>
</ul>
</li>
</ul>
<h4 id="20-4-矩阵的几种属性"><a href="#20-4-矩阵的几种属性" class="headerlink" title="20.4 矩阵的几种属性"></a>20.4 矩阵的几种属性</h4><h5 id="20-4-1-方阵的行列式"><a href="#20-4-1-方阵的行列式" class="headerlink" title="20.4.1 方阵的行列式"></a>20.4.1 方阵的行列式</h5><p><strong>(一) 概念</strong></p>
<p>矩阵行列式是指矩阵的全部元素构成的行列式，$\boldsymbol A$是数域$\mathbb{R}$上的一个$n$阶矩阵，则所有$\boldsymbol A$中的元素组成的行列式称为矩阵$\boldsymbol A$的行列式，记为$|\boldsymbol A|$或$\det(\boldsymbol A)$。行列式的意义是变换后，<strong>空间的膨胀系数</strong>。</p>
<p><strong>(二) 性质</strong></p>
<ol>
<li>$|\boldsymbol A^{\mathrm T}| = |\boldsymbol A| = \lambda_1 \times \lambda_2 \times \cdots \times \lambda_n$</li>
<li>$|k\boldsymbol A| = k^n |\boldsymbol A|$</li>
<li>$|\boldsymbol{AB}| = |\boldsymbol A| |\boldsymbol B|$</li>
<li>$|\boldsymbol A^*| = |\boldsymbol A|^{n-1}$</li>
<li>$|\boldsymbol A^{-1}| = |\boldsymbol A|^{-1}$</li>
</ol>
<h5 id="20-4-2-矩阵的秩"><a href="#20-4-2-矩阵的秩" class="headerlink" title="20.4.2 矩阵的秩"></a>20.4.2 矩阵的秩</h5><p><strong>(一) k阶子式(数)</strong></p>
<p>在$m \times n​$矩阵$\boldsymbol A​$中，任取$k​$行与$k​$列($k \leq m,k \leq n​$)，位于这些行与列的交叉点上的$k^2​$个元素按其在原来矩阵$\boldsymbol A​$中的次序可构成一个$k​$阶<strong>行列式</strong>，称其为矩阵$\boldsymbol A​$的一个$k​$阶子式。 </p>
<ul>
<li><strong>顺序主子式</strong></li>
</ul>
<p>顺序主子式是$n$阶方阵的$n$个行列式的序列，第$k$个行列式由方阵的前$k$行和前$k$列组成。 </p>
<p><img src="https://pic.imgdb.cn/item/63e4f0394757feff33a046a4.jpg"></p>
<p><strong>(二) 秩的概念</strong></p>
<p>设$\boldsymbol A$为$m \times n$矩阵，若$\boldsymbol A$中存在$r$阶子式不等于0，$r$阶以上子式均等于0，则称矩阵$\boldsymbol A$的秩为$r$，记为$r(\boldsymbol A)=\mathrm{rank}(\boldsymbol A)$。零矩阵的秩规定为0。</p>
<p><strong>(三) 性质</strong></p>
<ol>
<li>$r(\boldsymbol A)=0$等价于$\boldsymbol A=\boldsymbol O$，同时也有$\boldsymbol A\neq \boldsymbol O$等价于$r(\boldsymbol A) \geq 1$；</li>
<li>$\boldsymbol A$是$n$阶矩阵，$r(\boldsymbol A) = n$等价于$|\boldsymbol A| \neq 0$等价于$\boldsymbol A$可逆，$r(A)&lt;n$等价于$|\boldsymbol A| = 0$等价于$\boldsymbol A$不可逆;</li>
<li>若$\boldsymbol A$是$m \times n$矩阵，则$r(\boldsymbol A) \leq \min(m,n)$；</li>
<li>经过初等变换矩阵的秩不变；</li>
</ol>
<p><strong>(四) 拓展性质(公式)</strong></p>
<ol>
<li>$r(\boldsymbol A)=r(\boldsymbol A^{\mathrm T})$；$r(\boldsymbol A \boldsymbol A^{\mathrm T})=r(\boldsymbol A)$</li>
<li>$r(\boldsymbol A+\boldsymbol B)&lt;=r(\boldsymbol A)+r(\boldsymbol B)$</li>
<li>$r(\boldsymbol{AB}) \leq \min(r(\boldsymbol A), r(\boldsymbol B)) \leq \max(r(\boldsymbol A), r(\boldsymbol B)) \leq r(\boldsymbol A + \boldsymbol B) \leq r(\boldsymbol A)+r(\boldsymbol B)$</li>
<li>若$\boldsymbol A$可逆，则$r(\boldsymbol{AB})=r(\boldsymbol B)$，$r(\boldsymbol{BA})=r(\boldsymbol B)$</li>
<li>若$\boldsymbol A$是$m \times n$矩阵，$\boldsymbol B$是$n×s$矩阵且$\boldsymbol{AB=O}$，则$r(\boldsymbol A)+r(\boldsymbol B) \leq n$</li>
</ol>
<h5 id="20-4-3-矩阵的迹"><a href="#20-4-3-矩阵的迹" class="headerlink" title="20.4.3 矩阵的迹"></a>20.4.3 矩阵的迹</h5><h5 id="20-4-4-矩阵的特征值"><a href="#20-4-4-矩阵的特征值" class="headerlink" title="20.4.4 矩阵的特征值"></a>20.4.4 矩阵的特征值</h5><p><strong>n阶矩阵一定有n个特征值。</strong>因为特征值是特征多项式的根,n阶方阵的特征多项式是个n次多项式,根据代数基本定理,n次多项式有且只有n个根(重根按重数计算),这些根可能是实数,也可能是复数。</p>
<p>更加详细的说法为：一个n阶矩阵一定有n个特征值（包括重根），也可能是复根。一个n阶实对称矩阵一定有n个实特征值（包括重根）。每一个特征值至少有一个特征向量（不止一个）。不同特征值对应特征向量线性无关。</p>
<p><strong>特征根是特征多项式的根的概念，对特征根t当有特征向量a满足Aa-ta等于0成立，称特征根为特征值。当方阵不能对角化时，不是所有特征根都能称为特征值。</strong> </p>
<h4 id="20-5-几种特殊矩阵"><a href="#20-5-几种特殊矩阵" class="headerlink" title="20.5 几种特殊矩阵"></a>20.5 几种特殊矩阵</h4><h5 id="20-5-1-奇异矩阵"><a href="#20-5-1-奇异矩阵" class="headerlink" title="20.5.1 奇异矩阵"></a>20.5.1 奇异矩阵</h5><p>行列式为零的方阵称为奇异矩阵。</p>
<p>该定义蕴含着奇异矩阵是方阵，因为行列式是对方阵而言的。行列式恰好为零，是不是就很“奇异”呢？换个问题，行列式恰好为1的矩阵奇异不奇异呢？行列式恰好为2呢？3呢？素数呢？从某种意义上说，这些矩阵确实都很奇异。但为何只说行列式为零的矩阵才奇异呢？</p>
<p>这很可能是由线性方程组的解的个数引出的名词。对于系数行列式非零的情况，方程组的解是唯一的；否则，就有无穷多解。换句话说，系数行列式可能取各种值，但不管是什么值，只要不为零，相应的方程组的解一定是唯一的。但是，如果系数行列式恰巧为零，方程组的解就可以有无穷多。这样，行列式为零的矩阵就显得很“突出”、很“不一样”、很“另类”、很“奇怪”，等等。而“奇异”包含了奇怪和异端两种意思，正好用于描述这种矩阵。 </p>
<p>参考链接：<br>本文来自李毅伟科学网博客。 链接地址：<a href="https://blog.sciencenet.cn/blog-315774-889594.html">https://blog.sciencenet.cn/blog-315774-889594.html </a>   </p>
<h5 id="20-5-2-正交矩阵"><a href="#20-5-2-正交矩阵" class="headerlink" title="20.5.2 正交矩阵"></a>20.5.2 正交矩阵</h5><p><strong>(一) 定义</strong></p>
<p>设$\boldsymbol Q$为$n$阶方阵，若$\boldsymbol {QQ}^{\mathrm T} = \boldsymbol Q^{\mathrm T} \boldsymbol Q=\boldsymbol I$，则称$\boldsymbol Q$为正交矩阵。 </p>
<p><strong>(二) 性质</strong></p>
<ol>
<li>$\boldsymbol Q^{\mathrm T} = \boldsymbol Q^{-1}$；</li>
<li>$\boldsymbol Q$的行(列)向量都是单位向量且两两正交；</li>
<li>$|\boldsymbol Q| = \pm 1$；</li>
<li>对任意一向量$\boldsymbol x$，有$|\boldsymbol{Qx}| = |\boldsymbol x|$，即正交阵不改变向量模长；</li>
<li>正交阵的特征值一定是1或-1；</li>
<li>正交阵的每一个行(列)向量都是模为1的向量；</li>
<li>正交阵每个元素绝对值都$\leq1$，若有一个元素为1，则该元素所在的行和列的其余元素均为0。 </li>
</ol>
<h5 id="20-5-3-相似矩阵"><a href="#20-5-3-相似矩阵" class="headerlink" title="20.5.3 相似矩阵"></a>20.5.3 相似矩阵</h5><p><strong>(一) 定义</strong></p>
<p>设$\boldsymbol A$、$\boldsymbol B$都是$n$阶矩阵，若存在<strong>可逆矩阵</strong>$\boldsymbol P$，使得$\boldsymbol P^{-1}\boldsymbol{AP}= \boldsymbol B$，则称$\boldsymbol B$是$\boldsymbol A$的相似矩阵，或$\boldsymbol A$相似于$\boldsymbol B$，记为$\boldsymbol A \sim \boldsymbol B$。</p>
<p><strong>(二) 性质</strong></p>
<ol>
<li>$\boldsymbol A \sim \boldsymbol A$；</li>
<li>$\boldsymbol A \sim \boldsymbol B \Longleftrightarrow \boldsymbol B \sim \boldsymbol A$；</li>
<li>若$\boldsymbol A \sim \boldsymbol B$，$\boldsymbol B \sim \boldsymbol C$ 则可以推导出$\boldsymbol A \sim \boldsymbol C$；</li>
<li>$n$阶<strong>方阵</strong>$\boldsymbol A$可对角化的<strong><font color="blue">充分必要条件</font></strong>是$\boldsymbol A$有$n$个线性无关的特征向量。(可得若$n$阶矩阵$\boldsymbol A$有$n$个不同的特征值$\lambda_1, \lambda_2, \cdots, \lambda_n$，则$\boldsymbol A$可相似对角化，且对角矩阵元素一一对应特征值。)</li>
<li>$n$阶矩阵$\boldsymbol A$可相似对角化的充分必要条件是$\boldsymbol A$的每个特征值中，线性无关的特征向量的个数恰好等于该特征值的重数。</li>
<li>若$\boldsymbol A \sim \boldsymbol \Lambda$，其中$\boldsymbol \Lambda$为<strong>对角阵</strong>，则称$\boldsymbol A$可相似对角化，$\boldsymbol \Lambda$是$\boldsymbol A$的相似标准形。</li>
</ol>
<p><strong>(三) 相似的必要条件</strong></p>
<ol>
<li>特征多项式相同：$|\lambda\boldsymbol I - \boldsymbol A|=|\lambda \boldsymbol I-\boldsymbol B|$</li>
<li>$r(\boldsymbol A)=r(\boldsymbol A)$</li>
<li>$\boldsymbol A$和$\boldsymbol B$有相同的特征值</li>
<li>$|\boldsymbol A|=|\boldsymbol B|=特征值之积$</li>
<li>$\mathrm{tr}(\boldsymbol A) = \mathrm{tr}(\boldsymbol B) = 特征值之和$</li>
<li>$\boldsymbol A^2 \sim \boldsymbol B^2(\boldsymbol A^n \sim \boldsymbol B^n)$</li>
<li>$\boldsymbol A+k\boldsymbol I \sim \boldsymbol B+k\boldsymbol I$</li>
<li>如果$\boldsymbol A$可逆，$\boldsymbol A^{-1} \sim \boldsymbol B^{-1}$</li>
</ol>
<h5 id="20-5-4-实对称矩阵"><a href="#20-5-4-实对称矩阵" class="headerlink" title="20.5.4 实对称矩阵"></a>20.5.4 实对称矩阵</h5><p><strong>(一) 定义</strong></p>
<p>除了主对角线，两侧相对应的数相同的矩阵，也即满足：</p>
<script type="math/tex; mode=display">
\boldsymbol A = \boldsymbol A^{\mathrm T}</script><p><strong>(二) 性质</strong></p>
<ol>
<li>实对称矩阵<strong>&lt;/font color=red&gt;必可相似对角化&lt;/font&gt;</strong>；</li>
<li>实对称矩阵的属于不同特征值对应的特征向量相互<strong><font color="red">正交</font></strong>；</li>
<li>设$\boldsymbol A$为$n$阶实对称矩阵，则必存在正交阵$\boldsymbol Q$，使得$\boldsymbol Q^{-1}\boldsymbol A\boldsymbol Q = \boldsymbol Q^{T}\boldsymbol A\boldsymbol Q = \boldsymbol \Lambda$</li>
</ol>
<h5 id="20-5-5-酉矩阵-幺正矩阵"><a href="#20-5-5-酉矩阵-幺正矩阵" class="headerlink" title="20.5.5 酉矩阵(幺正矩阵 )"></a>20.5.5 酉矩阵(幺正矩阵 )</h5><p><strong>(一) 定义</strong></p>
<p><strong>酉矩阵（unitary matrix）</strong>也叫<strong>幺正矩阵</strong>。当矩阵元为实数时也叫<strong>正交矩阵</strong>，是正交矩阵的复数拓展，即矩阵元可以是复数。酉矩阵$\boldsymbol U$的定义同样为：</p>
<script type="math/tex; mode=display">
\boldsymbol U^{\mathrm H} \boldsymbol U = \boldsymbol U \boldsymbol U^{\mathrm H} = \boldsymbol I</script><p>其中，$\boldsymbol U^{\mathrm H}$表示共轭转置。酉矩阵一定是方阵。</p>
<p><strong>(二) 性质</strong></p>
<ol>
<li>$\boldsymbol U^{-1} = \boldsymbol U^{\mathrm H}$，同样就有$\boldsymbol U^{-1}$和$\boldsymbol U^{\mathrm T}$也是酉矩阵；</li>
<li>$|\boldsymbol U| = 1$；</li>
</ol>
<p><strong>(三) 充要条件</strong></p>
<p>复矩阵$\boldsymbol A \in \mathbb{C}_{n \times n}$是酉矩阵的充要条件是$\boldsymbol A$的$n$个列向量是标准的正交向量。 可见，快速判断一个复矩阵是不是酉矩阵可以看它任意两个列向量是不是<strong>正交</strong>且<strong>单位</strong>的。</p>
<h5 id="20-5-6-正定矩阵"><a href="#20-5-6-正定矩阵" class="headerlink" title="20.5.6 正定矩阵"></a>20.5.6 正定矩阵</h5><p><strong>(一) 定义</strong><br>对于$n$阶方阵$\boldsymbol A$，若对于任何非零向量$\boldsymbol x$，都有：</p>
<script type="math/tex; mode=display">
\boldsymbol x^{\mathrm T}\boldsymbol {Ax} > 0</script><p>则$\boldsymbol A$为正定矩阵。在实数域上，正定矩阵是<strong>实对称矩阵</strong>，在复数域上，正定矩阵是<strong>Hermit矩阵</strong>。</p>
<p><strong>(二) 性质</strong></p>
<ol>
<li>正定阵行列式恒为正，即正定矩阵一定可逆；</li>
<li>实对称矩阵$\boldsymbol A$正定当且仅当$\boldsymbol A$与单位矩阵<strong>合同</strong>；</li>
<li>若$\boldsymbol A$是正定矩阵，则$\boldsymbol A$的逆矩阵也是正定矩阵；</li>
<li>两个正定矩阵的<strong>和</strong>是正定矩阵；</li>
<li>在实数域中，正定矩阵的主对角线元素均大于0。</li>
</ol>
<p><strong>(三) 一个矩阵是正定矩阵的充要条件</strong></p>
<ol>
<li>$\boldsymbol A$的特征值均为正；</li>
<li>存在可逆矩阵$\boldsymbol P$，使得$\boldsymbol A = \boldsymbol P^{\mathrm T} \boldsymbol P$，即$\boldsymbol A$与$\boldsymbol I$合同；</li>
<li>$\boldsymbol A$的前$k(k = 1,2,\cdots,n)$阶顺序主子式均大于零；</li>
</ol>
<h4 id="20-6-小结：常见几种矩阵变换——合同、相似、等价"><a href="#20-6-小结：常见几种矩阵变换——合同、相似、等价" class="headerlink" title="20.6 小结：常见几种矩阵变换——合同、相似、等价"></a>20.6 小结：常见几种矩阵变换——合同、相似、等价</h4><h5 id="20-6-1-矩阵合同"><a href="#20-6-1-矩阵合同" class="headerlink" title="20.6.1 矩阵合同"></a>20.6.1 矩阵合同</h5><p><strong>(一) 定义</strong></p>
<p>设$\boldsymbol A$和$\boldsymbol B$是两个$n$阶方阵，若存在可逆阵$\boldsymbol C$，使得$\boldsymbol C^{\mathrm T}\boldsymbol A\boldsymbol C=\boldsymbol B$，则称$\boldsymbol A$合同于$\boldsymbol B$，记成$\boldsymbol A \simeq \boldsymbol B$.</p>
<p>在线性代数，特别是二次型理论中，常常用到矩阵间的合同关系。 </p>
<p><strong>(二) 性质</strong></p>
<ol>
<li><strong>反身性：</strong>任意矩阵都与其自身合同；</li>
<li><strong>对称性：</strong>矩阵$\boldsymbol A$合同于矩阵$\boldsymbol A$，则可以推出矩阵$\boldsymbol A$合同于矩阵$\boldsymbol B$；</li>
<li><strong>传递性：</strong>矩阵$\boldsymbol A$合同于矩阵$\boldsymbol B$，矩阵$\boldsymbol B$合同于矩阵$\boldsymbol C$，则可以推出矩阵$\boldsymbol A$合同于矩阵$\boldsymbol C$。</li>
</ol>
<p><strong>(三) 矩阵合同的判别/充要条件</strong></p>
<ul>
<li>$r(\boldsymbol A) = r(\boldsymbol B)$<ul>
<li>设$\boldsymbol A$和$\boldsymbol B$均为复数域上的$n$阶对称矩阵，则$\boldsymbol A$与$\boldsymbol B$在复数域上合同等价于$\boldsymbol A$与$\boldsymbol B$的秩相同。</li>
<li>设$\boldsymbol A​$与$\boldsymbol B​$均为实数域上的$n​$阶对称矩阵，则$\boldsymbol A​$与$\boldsymbol B​$在实数域上合同等价于$\boldsymbol A​$与$\boldsymbol B​$有相同的正、负惯性指数(即正、负特征值的个数相等)。</li>
</ul>
</li>
</ul>
<h5 id="20-6-2-小结：相似、合同、等价"><a href="#20-6-2-小结：相似、合同、等价" class="headerlink" title="20.6.2 小结：相似、合同、等价"></a>20.6.2 小结：相似、合同、等价</h5><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>合同</th>
<th>相似</th>
<th>等价</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>$\boldsymbol C^{\mathrm T}\boldsymbol A\boldsymbol C=\boldsymbol B$</td>
<td>$\boldsymbol P^{-1}\boldsymbol A\boldsymbol P=\boldsymbol B$</td>
<td>$\boldsymbol P\boldsymbol A\boldsymbol Q=\boldsymbol B$</td>
</tr>
<tr>
<td>记作</td>
<td>$\boldsymbol A \simeq \boldsymbol B$</td>
<td>$\boldsymbol A \sim \boldsymbol B$</td>
<td>$\boldsymbol A \cong \boldsymbol B$</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>相似矩阵必为等价矩阵，等价矩阵未必为相似矩阵，满足$\boldsymbol{PQ=I}$的等价矩阵是相似矩阵。</li>
<li>合同矩阵必为等价矩阵，等价矩阵未必为合同矩阵，满足 pA=pB,qA=qB的等价矩阵是合同矩阵。</li>
<li>相似矩阵未必合同，合同矩阵未必相似。</li>
<li>正交相似矩阵必合同，正交合同矩阵必相似。</li>
<li>实对称矩阵相似必合同，实对称矩阵合同未必相似。</li>
</ul>
<p>矩阵合同、矩阵相似、矩阵等价是矩阵理论中常见的三个概念，它们的定义如下：</p>
<ol>
<li>矩阵合同：设$\boldsymbol A, \boldsymbol B$是 $n$ 阶实（或复）矩阵，若存在一个$n$阶可逆实（或复）矩阵$\boldsymbol P$，使得$\boldsymbol B = \boldsymbol{P^\mathrm T A P}$，则称矩阵$\boldsymbol A$和$\boldsymbol B$合同。记为$\boldsymbol A \simeq \boldsymbol B$。</li>
<li>矩阵相似：设$\boldsymbol A, \boldsymbol B$是$n$阶实（或复）矩阵，若存在一个$n$阶可逆实（或复）矩阵$\boldsymbol P$，使得$\boldsymbol B=\boldsymbol{P^{-1}AP}$，则称矩阵$\boldsymbol A$和$\boldsymbol B$相似。记为$\boldsymbol A \sim \boldsymbol B$。</li>
<li>矩阵等价：设$\boldsymbol A, \boldsymbol B$是$n$阶实（或复）矩阵，若存在$n$阶可逆实（或复）矩阵$\boldsymbol P, \boldsymbol Q$，使得$\boldsymbol B = \boldsymbol{P^{-1}AQ}$，则称矩阵$\boldsymbol A$和$\boldsymbol B$等价。记为$\boldsymbol A \approx \boldsymbol B$。</li>
</ol>
<p>三者的联系与区别如下：</p>
<ol>
<li>矩阵合同是一种特殊的矩阵等价关系，即如果矩阵$\boldsymbol A$ 和$\boldsymbol B$合同，则它们等价，即$\boldsymbol A \approx \boldsymbol B$。但反之不成立，即等价的矩阵不一定合同。</li>
<li>矩阵相似是一种更加严格的关系，如果矩阵$\boldsymbol A$和$\boldsymbol B$相似，则它们一定等价，即$\boldsymbol A \sim \boldsymbol B$蕴含$\boldsymbol A \approx \boldsymbol B$。但反之不成立，即等价的矩阵不一定相似。</li>
<li>矩阵等价是最一般的关系，如果矩阵$\boldsymbol A$和$\boldsymbol B$等价，则它们具有一些共同的性质，例如它们的秩、行列式、迹等都相同，但它们不一定相似或合同。</li>
</ol>
<p>总的来说，矩阵等价是最一般的关系，矩阵相似是一种较为特殊的等价关系，而矩阵合同是在实对称矩阵和复Hermitian矩阵中的等价关系。</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象设计(C++)</title>
    <url>/2024/10/31/object-oriented-design/</url>
    <content><![CDATA[<h3 id="0-程序设计哲学"><a href="#0-程序设计哲学" class="headerlink" title="0. 程序设计哲学"></a>0. 程序设计哲学</h3><p>尽量把我们的代码建筑在已有代码的基础上（避免Code Duplication），如果你的程序有很多一模一样的代码，显然出错了修改起来会很麻烦。</p>
<p>栈——&gt;堆栈，堆——&gt;堆 </p>
<h3 id="1-面向对象的基本概念和原理"><a href="#1-面向对象的基本概念和原理" class="headerlink" title="1. 面向对象的基本概念和原理"></a>1. 面向对象的基本概念和原理</h3><h4 id="1-1-什么是对象"><a href="#1-1-什么是对象" class="headerlink" title="1.1 什么是对象"></a>1.1 什么是对象</h4><script type="math/tex; mode=display">
\text{Object} = \text{Attributes + Services}</script><p><img src="https://pic.imgdb.cn/item/672368d4d29ded1a8c57d9b3.png" style="zoom:40%"></p>
<p>数据（Data）：表示对象的属性或状态。例如：杯子是一个对象，杯子的高度、重量、口径、颜色等都是杯子这个对象的数据。数据也可分动态和静态的，比如装了多少水是可以改变的，但是杯子的材质、颜色一般是固定的。</p>
<p>操作（Operation）：表示对象对外能够提供的服务。例如：杯子能够盛水。</p>
<ul>
<li>什么是面向对象<ul>
<li>一种组织方式<ul>
<li>设计：解决问题的思路</li>
<li>实现：用代码实现</li>
</ul>
</li>
<li>对象，而不是控制或数据流，是设计和实现的主要焦点。</li>
<li>专注于事情，而不是操作。</li>
</ul>
</li>
</ul>
<h4 id="1-2-面向对象编程中的基本理念"><a href="#1-2-面向对象编程中的基本理念" class="headerlink" title="1.2 面向对象编程中的基本理念"></a>1.2 面向对象编程中的基本理念</h4><p><strong>理念1</strong>：对象发送和接收消息（objects do things! ）</p>
<p><img src="https://pic.imgdb.cn/item/67236c7dd29ded1a8c5ac522.png" style="zoom:40%"></p>
<p>对象发送消息，消息是：① 由发件人撰写；② 由接收方翻译；③ 通过方法实现。<br>消息：① 可能导致接收器状态改变；② 可能返回结果。</p>
<p><strong>理念2</strong>：对象(Object) VS 类(Class)</p>
<p>对象（例如：猫）：代表事物、事件或概念，是一个实体，在运行时响应消息。<br>类（例如：猫这个种类）：定义实例的属性，是一个概念，像C++中的类型一样行事。</p>
<p><img src="https://pic.imgdb.cn/item/67237196d29ded1a8c5fc1df.png" style="zoom:70%"></p>
<p><strong>理念3</strong>：OOP特性</p>
<ol>
<li>一切都是Object；</li>
<li>程序是一堆对象，通过发送消息来告诉彼此该做什么；</li>
<li><strong><font color="red">每个对象都有自己的内存，这个对象（可以）再由其他对象组成</font></strong>；</li>
<li>每个对象都有一个类型（即必须先定义类Class，然后对象由类实例化出来）；</li>
<li>特定类型的所有对象都可以接收相同的消息。</li>
</ol>
<p>对象具有<strong>接口</strong>，接口是它接收消息的方式，它在对象所属的类中定义。接口的功能：Communication（交流）和Protection（保护）。</p>
<p><strong>理念4</strong>：隐藏实现(The Hidden lmplementation )</p>
<p>对象的内部、表示其状态的数据成员以及消息被rcvd时所采取的操作都是隐藏的。</p>
<ul>
<li>类创建者与客户端程序员<ul>
<li>让客户程序员的手远离他们不应该接触的部分。</li>
<li>允许类创建者更改类的内部工作，而不必担心它会如何影响客户端程序员。</li>
</ul>
</li>
</ul>
<p><strong>理念5</strong>：封装</p>
<p>将数据和处理这些数据的方法捆绑在一个对象中，隐藏数据和操作的详细信息，仅限制对公开方法的访问。</p>
<h4 id="1-3-自动售票机的例子"><a href="#1-3-自动售票机的例子" class="headerlink" title="1.3 自动售票机的例子"></a>1.3 自动售票机的例子</h4><p>售票机：当顾客为他们的票价投入正确的钱时，售票机会打印一张票。</p>
<p>我们的售票机的工作原理是：客户将钱插入其中，然后要求打印门票。一台机器在运行过程中不断计算它所收集的资金总额。</p>
<p>简要分析，如下图</p>
<p><img src="https://pic.imgdb.cn/item/672379dad29ded1a8c66518e.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketMachine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPrompt</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getMoney</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTicket</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showBalance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> PRICE;</span><br><span class="line">    <span class="keyword">int</span> balance;	<span class="comment">// 外汇balance指的就是账户资金的变化</span></span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>::</code>的解释：。。。</p>
<h4 id="1-4-头文件"><a href="#1-4-头文件" class="headerlink" title="1.4 头文件"></a>1.4 头文件</h4><h5 id="1-4-1-类的定义"><a href="#1-4-1-类的定义" class="headerlink" title="1.4.1 类的定义"></a>1.4.1 类的定义</h5><p>在C++中，使用<strong>分开的.h和.cpp文件</strong>来定义一个类。<br>该类中的类声明和原型位于头文件（.h）中。<br>这些函数的所有主体都在源文件（.cpp）中。</p>
<h5 id="1-4-2-头文件"><a href="#1-4-2-头文件" class="headerlink" title="1.4.2 头文件"></a>1.4.2 头文件</h5><p>如果在头文件中声明了一个函数，则必须在使用该函数和定义该函数的所有位置都包含该头文件。<br>如果在头文件中声明了一个类，则必须在使用该类和定义类成员函数的所有位置都包含该头文件</p>
<ul>
<li>Declarations VS Definitions（声明 VS 定义）<ul>
<li>.cpp文件是一个编译单元</li>
<li>.h中只允许包含声明<ul>
<li><code>extern</code>变量</li>
<li>功能原型</li>
<li>类/结构体声明</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>标准头文件结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_FLAG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_FLAG</span></span><br><span class="line"><span class="comment">// Type declaration here...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HEADER_FLAG</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>.h文件编写提示</strong><ul>
<li><ol>
<li>每个头文件一个类声明</li>
</ol>
</li>
<li><ol>
<li>与文件名前缀相同的一个源文件相关联。</li>
</ol>
</li>
<li><ol>
<li>头文件的内容以<code>#ifndef</code>、<code>#define</code>、<code>#endif</code>包围。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="1-5-时钟的例子"><a href="#1-5-时钟的例子" class="headerlink" title="1.5 时钟的例子"></a>1.5 时钟的例子</h4><h5 id="1-5-1-问题描述"><a href="#1-5-1-问题描述" class="headerlink" title="1.5.1 问题描述"></a>1.5.1 问题描述</h5><p>通过编写程序，来仿真一个时钟。</p>
<p>如果甲方只跟你说：我现在要一个钟，要求这个钟会一分钟一分钟地运行。</p>
<p>面对这么简单地要求，我们很容易想到写个函数，用个循环结构实现即可。但是我们现在在学c++，所以要去想办法从这里面用<strong>面向对象的角度</strong>去看这件事：即我们不去关注它的过程是怎么样的，我们关注的是有什么东西(对象)。</p>
<p>从一个时钟中你看到什么东西，你能不能看到它里面有什么样的东西，你能不能看到这个东西是什么样的东西组成的。当然整个时钟肯定是一个对象，那么这个时钟里面的再分能分成什么样的对象</p>
<ul>
<li>第一种分法：分成小时对象+分钟对象</li>
<li>第二种分法：将时钟的数字分成一个个数码管对象</li>
</ul>
<p>上面提到的这两种分法就是你在做一个对象的定义的设计的时候，你以什么样的角度去看这个问题。</p>
<blockquote>
<p>再比如：如果我现在要划分一下一个人的身体构造的时候，你是把这个人的身体划分成一个个不同功能的器官，还是直接划分成一个个细胞。这是两种不同的看待问题/编写程序的思想</p>
</blockquote>
<h5 id="1-5-2-抽象的概念"><a href="#1-5-2-抽象的概念" class="headerlink" title="1.5.2 抽象的概念"></a>1.5.2 抽象的概念</h5><p>下面就要介绍一个术语叫做<strong>Abstract(抽象)</strong></p>
<p><strong>抽象</strong>是一种忽略零件细节的能力，将注意力集中在更高层次的问题上。<br><strong>模块化</strong>是指将一个整体分解为定义明确的部分，这些部分可以分别构建和检查，并且以定义明确的方式相互交互。 </p>
<p><img src="https://pic.imgdb.cn/item/6725e095d29ded1a8c7b97b9.png" alt="image.png"></p>
<p><img src="https://pic.imgdb.cn/item/6725e0eed29ded1a8c7bebcb.png" style="zoom:40%"></p>
<p><strong>Implementation - ClockDisplay</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClockDisplay</span> &#123;</span></span><br><span class="line">    NumberDisplay hours;</span><br><span class="line">    NumberDisplay minutes;</span><br><span class="line">    Constructor <span class="keyword">and</span> methods omitted.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberDisplay</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Constructor <span class="keyword">and</span> methods omitted.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-面向对象的组成"><a href="#2-面向对象的组成" class="headerlink" title="2. 面向对象的组成"></a>2. 面向对象的组成</h3><h4 id="2-1-局部变量-Local-Variables-和成员变量-Fields"><a href="#2-1-局部变量-Local-Variables-和成员变量-Fields" class="headerlink" title="2.1 局部变量(Local Variables)和成员变量(Fields)"></a>2.1 局部变量(Local Variables)和成员变量(Fields)</h4><p>局部变量在方法内部定义，其作用域仅限于它们所属的方法。</p>
<p>注意：与成员变量(Fields)同名的局部变量将阻止从方法内访问该成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TicketMachine::refundBalance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amountToRefund;		<span class="comment">// 局部变量</span></span><br><span class="line">    amountToRefund = balance;</span><br><span class="line">    balance = <span class="number">0</span>;			<span class="comment">// 这是自动售票机中的成员变量</span></span><br><span class="line">    <span class="keyword">return</span> amountToRefund;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成员变量/字段(Fields)、参数(Parameters)、局部变量(Local Variables)，这三种变量都能够存储适合其定义类型的值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参数（parameters）和本地变量（local variables）是完全相同的东西：</span><br><span class="line"></span><br><span class="line">(1) 它们的存储属性都是本地存储（进入函数之前它们都不存在，进入函数之后他们才会存在）；两种变量都会放在名为“堆栈（stack）”的地方，但是在堆栈中的具体位置还是有所不同的。</span><br><span class="line"></span><br><span class="line">(2) 形式参数和本地变量仅在构造函数或方法执行期间持续存在。它们的生存期仅相当于一次调用，因此在调用之间会丢失它们的值。因此，它们担当临时存储而不是永久存储。</span><br><span class="line"></span><br><span class="line">(3) 形式参数在构造函数或方法的头部定义。它们从外部接收其值，由来自构造函数或方法调用部分的实际参数值初始化。</span><br></pre></td></tr></table></figure>
<h4 id="2-2-组成类的两种要素：成员变量和成员函数"><a href="#2-2-组成类的两种要素：成员变量和成员函数" class="headerlink" title="2.2 组成类的两种要素：成员变量和成员函数"></a>2.2 组成类的两种要素：成员变量和成员函数</h4><ul>
<li><p>字段(Fields)在构造函数和方法之外定义的，是类的<strong>成员变量</strong>。 </p>
<ul>
<li>全局变量的声明（添加 <code>extern</code> 修饰），只是在告诉编译器“我知道有一个全局变量，但是我不知道它在哪”；而字段就是这样的，它是一种<strong>成员变量</strong>，成员变量是写在类的声明里面的。</li>
</ul>
</li>
<li>字段(Fields)用于存储在对象生命周期内持续存在的数据。因此，它们保持对象的当前状态。它们的寿命与物体的寿命一样长。</li>
<li>字段(Fields)具有类作用域：它们的可访问性扩展了整个类，因此它们可以在定义它们的类的任何构造函数或方法中使用。</li>
<li>字段(Fields)只在实例化的时候才“真正存在”，在类Class中的字段(Fields)可以理解为只是一种“声明”（某个地方有这个成员变量），但是类并拥有成员变量，类的实例化对象才拥有成员变量。</li>
</ul>
<ul>
<li><strong>方法/函数是属于类的，不是属于实例化对象的。</strong></li>
</ul>
<p>C++中类定义的形式如下：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    访问范围说明符:</span><br><span class="line">        成员变量<span class="number">1</span>;</span><br><span class="line">        成员变量<span class="number">2</span>;</span><br><span class="line">        ...</span><br><span class="line">        成员函数<span class="number">1</span>声明;</span><br><span class="line">        成员函数<span class="number">1</span>定义;</span><br><span class="line">        ...</span><br><span class="line">    访问范围说明符:</span><br><span class="line">        更多成员变量;</span><br><span class="line">        更多成员函数声明或定义;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">成员函数<span class="number">1</span>类型 类名::成员函数<span class="number">1</span>(参数列表)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>成员变量</strong>是在类中<strong>声明</strong>的变量；同样地，<strong>成员函数</strong>是指在类中<strong>声明</strong>的函数。如上类的形式所示，<strong>成员函数</strong>可以在<strong>类中定义</strong>，也可以在<strong>类外定义</strong>。在类外定义的函数需要用类名和<strong>作用域运算符</strong>（<code>类名::</code>）限定函数所属的类。</p>
<p><strong>而成员变量的定义在实例化对象，给变量分配内存的时候才会发生。</strong><br>此外关于类的声明和定义可参考<a href="https://blog.csdn.net/baidu_35679960/article/details/78988454">如下文章</a>。简而言之，定义类只是在定义一个自己的数据类型；这与我们平时理解的声明和定义基本类型不同：类的声明和定义都不会分配内存，只有在实例化对象的时候才会分配内存。</p>
<h4 id="2-3-C-C-中-h与-cpp文件"><a href="#2-3-C-C-中-h与-cpp文件" class="headerlink" title="2.3 C/C++中.h与.cpp文件"></a>2.3 C/C++中.h与.cpp文件</h4><h5 id="2-3-1-头文件-h文件"><a href="#2-3-1-头文件-h文件" class="headerlink" title="2.3.1 头文件(.h文件)"></a>2.3.1 头文件(.h文件)</h5><p>一般来说，头文件仅仅用于声明，相应的定义要放在对应的cpp文件中。声明的内容一般可以是：    </p>
<ol>
<li>类定义体；（这里可参考”<a href="https://blog.csdn.net/theworldkind/article/details/77967412">头文件为什么只声明不定义，而类定义又可以放在头文件中</a>“ 以及”<a href="https://www.cnblogs.com/pluse/p/5768271.html">关于C++的变量和类的声明和定义</a>“）</li>
<li>类中的成员函数；</li>
<li>类外的函数（free函数）；</li>
<li><p>类外的变量；</p>
</li>
<li><p>类型；</p>
</li>
</ol>
<p>一个文件（比如main.cpp）包含（#include）了一个头文件（比如item.h），就相当于声明了Item.h中声明的所有内容。</p>
<p>但是<code>const</code>常量、<code>inline</code>函数、<code>static</code>函数都可以在头文件中定义（如果是初次学习C++，这点目前仅作了解，之后会慢慢学到）。</p>
<h5 id="2-3-2-源文件-cpp文件"><a href="#2-3-2-源文件-cpp文件" class="headerlink" title="2.3.2 源文件(.cpp文件)"></a>2.3.2 源文件(.cpp文件)</h5><p>.cpp文件用于定义，定义的内容一般可以是： </p>
<ol>
<li>类的成员函数；</li>
<li>类的静态成员变量；</li>
<li>类外的函数（free函数）；</li>
<li>类外的变量； </li>
</ol>
<h5 id="2-3-3-类内成员组成"><a href="#2-3-3-类内成员组成" class="headerlink" title="2.3.3 类内成员组成"></a>2.3.3 类内成员组成</h5><p>类：类一般只在头文件中定义，在cpp中实现其成员函数的定义；类中的成员包括：普通成员函数、static成员函数、普通成员变量、static成员变量、const成员变量、static const成员变量等。</p>
<ul>
<li><strong>普通成员函数</strong> —— 在类内部声明；可以在“类内部/头文件中的类外部”定义（均看作inline）；也可以放在cpp中定义（非inline）。（这点讲到《内联函数（Inline functions）》一章会展开）。</li>
<li><strong>static成员函数</strong> —— 类内部声明；可以在“类内部/cpp中”定义，不能在“头文件中的类外部”定义。在类外部定义的时候要去掉static关键字，因为类里面的static表示该成员属于类，而文件中的static表示文件作用域，这是完全两回事。（这点在下半部分学习笔记的《静态成员（static member）》小节会展开）。</li>
<li><strong>普通成员变量</strong> —— 类内部声明和定义；只能在构造函数的初始化列表中初始化，用户可以不进行初始化（编译器将默认构造）。（这点讲到《构造和析构（Constructor &amp; Destructor）》一章会展开讲）。</li>
<li><strong>static成员变量</strong> —— 类内部声明；只能在cpp中的各方法(函数)外部定义（且不能加static关键词，原因同static成员函数），定义时可以不进行初始化，这时默认为0（也可以不定义，但若使用到了该成员变量，则必须定义，否则连接出错） 。（这点在下半部分学习笔记的《静态成员（static member）》小节会展开）。</li>
<li><strong>const成员变量</strong> —— 类内部声明；只能在构造函数的初始化列表中初始化，而且用户必须自行初始化。（这点讲到《Const》一章会展开）。</li>
<li><strong>static const成员变量</strong> —— 基本同static；特别之处在于，static const成员变量是唯一可以在定义的时候（即类内部）直接初始化的类成员变量；注：static和static const不能在构造函数初始化列表中初始化，因为static关键字表明，它属于类，而不是属于对象；</li>
</ul>
<h4 id="2-4-this关键字"><a href="#2-4-this关键字" class="headerlink" title="2.4 this关键字"></a>2.4 this关键字</h4><p>类是抽象的、是虚的，更像是一种概念，<strong>不是实体，它不拥有它声明的任何一个变量，只有类的对象才是实体，才拥有那些变量</strong>。类和对象间变量的关系有点类似于C语言中<strong>结构体与结构体变量</strong>之间变量的关系。但是定义在类中的函数是属于类的，而不属于类的任何一个对象。总结为一句话就是：类拥有函数而不拥有变量；对象拥有变量而不拥有函数。</p>
<p>由上述关系可知：假设一个类Class的成员函数<code>f()</code>要对字段进行操作，C++是如何知道Class的不同对象调用<code>f()</code>时是谁在调用<code>f( )</code>，以便对各自的字段进行操作的呢？</p>
<p>在C语言中，为了实现上述操作通常需要<strong>传递指针</strong>给函数<code>f( )</code>，在C++中，这个指针通过<code>this</code>关键字实现。</p>
<p><code>this</code>：隐藏参数，这是类的所有成员函数的隐藏参数，不需要手动定义，具有类的类型。</p>
<blockquote>
<p>在成员函数里面，当它去用到成员变量的时候，实际上所有的成员变量前面都可以看作是有<code>this-&gt;成员变量</code>。</p>
</blockquote>
<p><code>this</code>：<strong>指向调用者的指针</strong>，在成员函数内部，您可以使用<code>this</code>作为指向调用函数的变量的指针。这是所有不能定义但可以直接使用的类成员函数的自然局部变量。</p>
<h4 id="2-5-构造和析构（Constructor-amp-Destructor）"><a href="#2-5-构造和析构（Constructor-amp-Destructor）" class="headerlink" title="2.5 构造和析构（Constructor &amp; Destructor）"></a>2.5 构造和析构（Constructor &amp; Destructor）</h4><h5 id="2-5-1-构造函数"><a href="#2-5-1-构造函数" class="headerlink" title="2.5.1 构造函数"></a>2.5.1 构造函数</h5><p>考虑到效率，C++没有规范地约束在生成对象时必须对其初始化（其他一些OOP语言比如Java存在此约束）。如果程序员自己写 <code>init()</code> 函数则需要依赖于他的自觉性（即有没有在生成对象后立刻调用<code>init()</code>，否则就会出问题），所以我们需要一种机制来确保生成对象后一定会被初始化，这便是<strong>constructor构造函数</strong>的由来。</p>
<ul>
<li><strong>构造函数</strong>名字必须与类名相同（包括大小写）；</li>
<li>构造函数没有返回类型(<code>void</code>也不算)；</li>
<li><strong>构造函数会在类的对象被创建时自动被调用；</strong>（所以一般构造函数用于初始化操作）</li>
<li>构造函数可以有参数，对应在创建对象时也需要传个参数；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Tree</span>(<span class="keyword">int</span> i) &#123;...&#125;    <span class="comment">//构造函数</span></span><br><span class="line"><span class="function">Tree <span class="title">t</span><span class="params">(<span class="number">12</span>)</span></span>;          <span class="comment">//创建对象</span></span><br></pre></td></tr></table></figure>
<p>只要不带参数的构造函数都称为“<strong>default constructor</strong>”；而编译器给你的的构造函数称为“<strong>auto default constructor</strong>”，<strong>当你定义了带参构造函数却没有在生成对象时正确调用，编译器会去寻找default constructor调用。</strong> </p>
<h5 id="2-5-2-析构函数"><a href="#2-5-2-析构函数" class="headerlink" title="2.5.2 析构函数"></a>2.5.2 析构函数</h5><ul>
<li><strong>析构函数</strong>即在构造函数名字前加一个波浪号（~）</li>
<li>析构函数会在对象要被“<strong>消灭</strong>”掉的时候自动被调用；（比如在一个大括号内创建栈对象的话，离开大括号范围的时候对象就会被“消灭”掉）</li>
<li>根据析构函数的特性，我们一般会用析构函数来释放掉对象生存期间申请的资源，保证这些资源不会随着对象被“消灭”掉之后一并被带到“棺材”里面去；</li>
<li>析构函数也没有返回类型，而且不能有参数；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">Y</span>();	<span class="comment">// 析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="2-5-3-初始化列表（Initializer-list）"><a href="#2-5-3-初始化列表（Initializer-list）" class="headerlink" title="2.5.3 初始化列表（Initializer list）"></a>2.5.3 初始化列表（Initializer list）</h5><p>除了使用构造函数来做初始化，C++还提供了另一种初始化方法：<strong>初始化列表</strong>；</p>
<ul>
<li>在构造函数的圆括号后面加上冒号，冒号后面跟上成员变量的名字，最后用括号给出初始值；</li>
<li>初始化列表可以初始化任何类型的数据；</li>
<li><strong>初始化列表会早于构造函数被执行；</strong></li>
<li>严格来说，初始化列表做的工作才是初始化；而构造函数做的工作可以称作为“赋值”，构造函数会做两件事：1. 初始化（这个时候你没有明确告诉编译器用什么内容来初始化）；2. 赋值； </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> x, y;</span><br><span class="line">        <span class="built_in">Point</span>(<span class="keyword">float</span> xa = <span class="number">0.0</span>, <span class="keyword">float</span> ya = <span class="number">0.0</span>) : <span class="built_in">y</span>(ya), <span class="built_in">x</span>(xa)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="2-5-4-存储分配"><a href="#2-5-4-存储分配" class="headerlink" title="2.5.4 存储分配"></a>2.5.4 存储分配</h5><p>编译器在作用域的左括号处为该作用域分配所有存储空间，但是构造函数调用直到运行到定义对象的那一行才发生。</p>
<h4 id="2-6-new-amp-delete（动态地制造对象）"><a href="#2-6-new-amp-delete（动态地制造对象）" class="headerlink" title="2.6 new &amp; delete（动态地制造对象）"></a>2.6 new &amp; delete（动态地制造对象）</h4><p>在C语言中，我们通过<code>malloc</code>与<code>free</code>动态地申请和释放内存；在C++，则是用两个新的运算符关键字<code>new</code>和<code>delete</code>来制造和收回一个对象的。</p>
<p>如果<code>new</code>一个变量，则只需做一件事情：分配一个变量的空间；但是如果<code>new</code>一个对象，则<code>new</code>会做两件事情：<strong>① 分配一个对象的空间</strong>；<strong>② 调用构造函数</strong>；当然最后作为一个运算符会返回分配给对象的地址。而<code>delete</code>做的事情与<code>free</code>类似，你给它一个地址，然后它delete掉。对于delete一个对象：<strong>① 调用析构函数</strong>；<strong>② 收回内存空间</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">new</span> Stash;</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *psome = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];	<span class="comment">// new运算符返回块的第一个元素的地址。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> [] psome;	<span class="comment">// 括号的出现告诉程序应该释放整个数组，而不仅仅是元素</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>new</code>出来的东西会放在<strong>堆</strong>里面；</li>
<li>动态申请的内存完全由开发者自行负责管理，开发者对堆对象的生存周期具有完全的支配权(在何时申请内存，分配多少内存，并在何时释放该内存)；</li>
<li>由上一条可知：在堆中的对象不会自动被消灭，内存不会自动回收，<code>new</code>出来的对象在程序运行过程中会一直占用内存空间，直到开发者在代码中主动<code>delete</code>掉它或者程序进程整体退出；</li>
<li>程序进程退出时的内存回收是系统级的，系统会回收分配给该进程的所有内存。但那个时候系统就并不关心你程序里面是如何使用它的了；也就是说系统仅仅是回收内存，不会再帮你调用析构函数了；</li>
<li>我们知道<code>new</code>作为一个运算符会返回分配给对象的地址。如果我们把<code>new</code>返回的地址交给局部指针变量，根据第一章成员变量的秘密我们知道局部变量担任临时存储，那么局部指针变量一但离开局部空间后被销毁，我们就再也无法访问到<code>new</code>申请的内存了。下面是一个代码例：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">	~<span class="built_in">A</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		A* p = <span class="keyword">new</span> <span class="built_in">A</span>();         <span class="comment">//把new返回的地址交给局部指针变量</span></span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;<span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>);    <span class="comment">//此时指针变量p已经被销毁，但new申请的内存还没有回收</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会给出如下错误： </p>
<p><img src="https://pic.imgdb.cn/item/6735bdb8d29ded1a8c7b50eb.png"></p>
<ul>
<li><code>new</code>和<code>delete</code>的使用小技巧<ul>
<li>不要用<code>delete</code>去释放不是<code>new</code>分配出来的空间；</li>
<li>不要连续两次用<code>delete</code>释放同一块空间；</li>
<li>如果用<code>new []</code>分配了一块数组，请用<code>delete []</code>；同样地如果用<code>new</code>分配了单个实体，请用<code>delete</code>；</li>
<li>如果<code>new []</code>了之后用<code>delete</code>释放的话，仅会调用<code>delete</code>指针指向的对象的析构函数，虽然同样回收所有空间，但是会报错。（例如下方贴的代码）</li>
<li><code>delete</code>一个空指针是安全的；</li>
<li><code>new</code>出来的对象在使用完毕后不<code>delete</code>是非常危险的！对于长时间运行的程序很容易造成内存泄漏；</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123; i = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; &#125;            <span class="comment">//构造函数</span></span><br><span class="line">        ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A(),i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;         <span class="comment">//析构函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">this</span>-&gt;i = i; &#125;    </span><br><span class="line">        <span class="comment">//根据就近原则，成员变量i会被参数i屏蔽，需要加this指针表示“调用这个函数的对象的i”</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        A* p = <span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                p[i].<span class="built_in">set</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> p;        </span><br><span class="line">        <span class="comment">//尝试用delete回收new []分配的空间，若要正确运行请改为“delete[] p;”</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-访问限制（Setting-limits）"><a href="#2-7-访问限制（Setting-limits）" class="headerlink" title="2.7 访问限制（Setting limits）"></a>2.7 访问限制（Setting limits）</h4><p>在OOP理论阶段学习过：对象应该是被封装起来的受保护的，对象里面的数据是不被别人直接访问的。别人能访问的只有你的函数，可以通过你的函数要求你做事情；但是这个函数具体怎么做？会对你的数据产生什么样的影响？是由你的代码决定的。</p>
<p>所以我们需要一种机制，使得使用你的类的人不会随心所欲地访问内部的东西；同时设计类的人可以去修改内部的东西而不至于影响到使用者。对C++来说，所有的成员可以有三种访问属性：public、private以及protected。</p>
<ul>
<li>public没什么好说的，任何人都能访问；</li>
<li>private只有自己（这个类中的成员函数）能访问，private可以修饰变量与函数；<ul>
<li><strong>注意private私有性是对类来说的，而不是对象</strong>！<strong>同一个类的不同对象之间是可以互相访问私有的成员变量的</strong>。(如下面的代码示例)</li>
<li>此外，C++对private权限的限制仅仅存在于编译时刻，到了运行时刻就没人管这件事了，原因是C++的OOP特性只在源代码层面体现，编译完后生成的.o文件同C语言、汇编语言、Pascal生成的.o文件是一模一样的。所以只要有办法过了编译那一关，剩下的事情就可以为所欲为了。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; i = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; &#125;            <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A(),i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;         <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">this</span>-&gt;i = i; cout &lt;&lt; <span class="string">&quot;this-&gt;i=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;i &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A* q)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::g(),q-&gt;i=&quot;</span> &lt;&lt; q-&gt;i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">50</span>);</span><br><span class="line">    A b;</span><br><span class="line">    b.<span class="built_in">set</span>(<span class="number">100</span>);</span><br><span class="line">    a.<span class="built_in">g</span>(&amp;b);    <span class="comment">//尝试用a中的成员函数g(A* q)访问b中的私有成员变量i；</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++还有个破坏OOP原则的东西叫做<code>friends</code>：你可以声明别人（可以是别的类，可以是别的不属于任何类的<code>free</code>函数，也可以是别的类里的某个函数）是你的<code>friend</code>（朋友），一旦声明过后，他就可以访问你的<code>private</code>的东西了；</p>
<p>但是不能是你声明你是别人的朋友，然后去访问别人的私有的东西。就像啊我声明：“我是小明的朋友，所以我可以用他的钱”，这是不行的，不是这么玩的。是由类自己决定谁可以访问自己的成员的。</p>
<p>同样的<code>friend</code>的授权是在编译时刻检查的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///演示代码，无法运行</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>;</span>    <span class="comment">// 前向声明</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(X*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(X*, <span class="keyword">int</span>)</span></span>;     <span class="comment">// free函数是friend</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Y::f</span><span class="params">(X*)</span></span>;       <span class="comment">// 结构体成员函数是friend</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">Z</span>;</span>            <span class="comment">// 整个结构体是friend</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X* x, <span class="keyword">int</span> i)</span> </span>&#123;	<span class="comment">// free函数是friend</span></span><br><span class="line">        x-&gt;i = i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Y::f</span><span class="params">(X* x)</span> </span>&#123;	<span class="comment">// 结构体成员函数是friend</span></span><br><span class="line">        x-&gt;i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Z</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>protected表示只有<strong>这个类</strong>自己以及<strong>它的“子子孙孙”</strong>（子类以及再往下的这些）可以访问；</li>
<li>在设计中，我们一般按下面的方式规划所有东西的访问限制：<ul>
<li>所有的数据（一般指成员变量）都是private的，外界及子类都不能直接访问；</li>
<li>提供给所有人（包括外界和子类）使用的东西是public的；</li>
<li>留给子类protected的接口以访问父类中private的数据；</li>
</ul>
</li>
</ul>
<h3 id="3-对象组合（Object-composition）"><a href="#3-对象组合（Object-composition）" class="headerlink" title="3. 对象组合（Object composition）"></a>3. 对象组合（Object composition）</h3><p>OOP三大特性即：封装、继承、多态性。但是从另外一个角度来说“<strong>继承是OOP对软件重用的回答</strong>”或者说“<strong>继承是OOP实现软件重用的一种方式</strong>”。这一章要讲的就是“重用的实现”（Reusing the implementation），但这里先不讲继承。在C++里面，我们还可以以另外一种方式实现软件重用，即“组合”（composition）：用现有的对象构造新对象(把已有的对象组合成新的对象)。 </p>
<blockquote>
<p>组合的关系是一种<strong>has a</strong>的关系； </p>
<p>比如说谈到一辆车，我们会说这辆车<strong>has a</strong>引擎，<strong>has a</strong>方向盘，<strong>has a</strong>空调，<strong>has a</strong> 轮胎……如果我们已经有了引擎、方向盘、空调、轮胎……的对象，我们把它们放在一起，再加一些其他的细节，以这种方式来实现软件的重用，于是我们组合出了一辆车对象。</p>
</blockquote>
<p>“组合”其实在谈OOP的五条原则五条原则时提到过，即“<strong>对象里面还是对象</strong>”；反映到C++的代码上即我们在设计一个类的时候它的成员变量可以是另外一个类的对象。在实际设计中，C++提供了两种不同的内存模型：<strong>fully &amp; by reference</strong>；</p>
<p><strong>fully</strong>表示“那个别的类的对象就是我这个类里的一部分（成员变量是对象本身）”  ；</p>
<p><strong>by reference</strong>表示“那个别的类的对象我知道在哪里，我可以访问到它（成员变量是指针），我可以调用它的方法，但它并不是我这个类里的一部分” ；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        A a;      <span class="comment">//fully</span></span><br><span class="line">        A* aa;    <span class="comment">//by reference</span></span><br><span class="line"> </span><br><span class="line">        B* bb;    </span><br><span class="line"><span class="comment">/*by reference允许成员变量的类型是其本身，而fully无法做到这一点(会陷入无限循环)</span></span><br><span class="line"><span class="comment">因为指针对编译器来说就仅仅是一个指针而已，无论指针所指的类型是什么，</span></span><br><span class="line"><span class="comment">它永远都只是那4个字节（32位系统），编译器不需要知道指针的细节，</span></span><br><span class="line"><span class="comment">指针的细节只有到用的时候才需要，所以不会陷入死循环。</span></span><br><span class="line"><span class="comment">在C语言中的“链表”就是这么干的*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*实际设计中，采用fully还是by reference是根据语义来的，</span></span><br><span class="line"><span class="comment">你认为合适把那个对象直接放在你的类里面，你就用fully，不合适就用by reference</span></span><br><span class="line"><span class="comment">比如你设计一个“同学”对象：他的“大脑”对象显然应该放在“身体”（类）里面（fully），</span></span><br><span class="line"><span class="comment">而他的“书包”对象就不太适合放在“身体”里面（by reference）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">或者以设计一个“收音机”对象为例，作为收音机你肯定是可以听电台嘛，但是在设计“收音机”类</span></span><br><span class="line"><span class="comment">的时候你不应该直接把一个“电台”对象（包括什么录音室、主持人、热线电话、接线员等等等等）</span></span><br><span class="line"><span class="comment">直接放（fully）进你的类里面吧，往往都是通过固定频段（比如FM101.7）去访问电台对象吧，</span></span><br><span class="line"><span class="comment">这个固定频段就可以理解为指针嘛（by reference）*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在组合中我们并不希望破坏对象的边界，于是更好的做法便是<strong>各个对象的初始化由初始化列表调用各自的构造函数完成</strong>，初始化列表也就是用来干这个的。以下面这段代码为例： </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *银行储蓄账户对象实例，类中包含人和货币对象(演示代码不能运行)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Currency</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingAccount</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SavingAccount</span>( <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* address, </span><br><span class="line">        <span class="keyword">int</span> cents ) : <span class="built_in">m_saver</span>(name, address), <span class="built_in">m_balance</span>(<span class="number">0</span>, cents) &#123; ... &#125;  <span class="comment">//构造函数</span></span><br><span class="line">        <span class="comment">//我们在初始化列表中调用了m_saver和m_balance的构造函数，然后把相应的参数传给他们</span></span><br><span class="line"> </span><br><span class="line">        ~<span class="built_in">SavingAccount</span>() &#123; ... &#125;   <span class="comment">//析构函数</span></span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">prints</span><span class="params">()</span></span>&#123;</span><br><span class="line">            m_saver.<span class="built_in">print</span>();</span><br><span class="line">            m_balance.<span class="built_in">print</span>();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        Person m_saver;        <span class="comment">//fully</span></span><br><span class="line">        Currency m_balance;    <span class="comment">//fully</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *附加思考题：</span></span><br><span class="line"><span class="comment"> *这里组合进来的两个对象m_saver和m_balance的属性是private</span></span><br><span class="line"><span class="comment"> *假如我们把他俩放到public里面去会怎样呢？</span></span><br><span class="line"><span class="comment"> *那我们就有可能做这样的事情：</span></span><br><span class="line"><span class="comment"> *		SavingAccount account</span></span><br><span class="line"><span class="comment"> *		account.m_saver.set_name(&quot;Fred&quot;);(假设Person类有set_name())</span></span><br><span class="line"><span class="comment"> *虽然m_saver和m_balance是对象，但是他俩也是SavingAccount类的成员变量；</span></span><br><span class="line"><span class="comment"> *在OOP理论阶段学习过成员变量作为数据应该是包裹起来不被外界直接访问的。</span></span><br><span class="line"><span class="comment"> *所以这显然不是OOP喜欢的，因为他突破了边界，外界可以直接访问里面的数据了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们将构造函数编写为（假设我们已经为子对象设置了访问器）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SavingAccount</span>( <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* address, <span class="keyword">int</span> cents )</span><br><span class="line">&#123;</span><br><span class="line">    m_saver.<span class="built_in">set_name</span>(name);</span><br><span class="line">    m_saver.<span class="built_in">set_address</span>(address);</span><br><span class="line">    m_balance.<span class="function">set <span class="title">cents</span><span class="params">(cents)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将调用默认构造函数，效率低。</p>
</blockquote>
<p>再举一个可运行的简单代码例子 ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> i) &#123; <span class="keyword">this</span>-&gt;i = i; cout &lt;&lt; <span class="string">&quot;A::A(),A::i=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="keyword">int</span> j) : <span class="built_in">a</span>(j+<span class="number">1</span>) &#123; <span class="keyword">this</span>-&gt;j = j; cout &lt;&lt; <span class="string">&quot;B::B(),B::j=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;j &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">//在B的初始化列表中调用了a的构造函数，并将j+1作为参数传给了他</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-继承（Inheritance）"><a href="#4-继承（Inheritance）" class="headerlink" title="4. 继承（Inheritance）"></a>4. 继承（Inheritance）</h3><h4 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h4><p>不同于对象组合，<strong>继承是拿已有的类克隆一份，然后对复制品在已有的基础上增添一些细节或者做一些改造，得到一个新的类</strong>。 在《This关键字的出现》那我们提到过“类是虚的，对象才是实的”，所以我们可以理解为C++里继承是玩虚的，组合是玩实的。</p>
<ul>
<li>继承是C++语言一门重要的技术，也是面向对象设计方法的重要组成部分；</li>
<li>继承使得我们可以共享设计中的：成员数据、成员函数、<strong>接口(Interface，一个类中对外公开的部分称之为“接口”)</strong>；</li>
<li>继承是将一个类的行为或实现定义为另一个类的<strong>超集（superset）</strong>的能力；</li>
<li>对于继承来说，类之间的关系是一种<strong>“is a”</strong>的关系；以下图为例，我们可以说：A student is a person.  Student is a superset of Person.</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6736b926d29ded1a8c3249df.png" style="zoom:60%"></p>
<ul>
<li>C++继承语法为：<strong>类名后面冒号public另外一个类</strong>，于是它就是另外一个类的子类了，如下代码所示：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>():<span class="built_in">i</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; &#125;	<span class="comment">//构造函数</span></span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; &#125;		<span class="comment">//析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;A::print(),i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:		<span class="comment">//protected访问属性详情参考《访问限制（Setting limits）》一章</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i = ii; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;		<span class="comment">//C++继承语法，表示B类是A类的子类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="built_in">set</span>(<span class="number">20</span>); <span class="built_in">print</span>();	<span class="comment">//子类中新增的函数可以调用父类中public的函数</span></span><br><span class="line">		<span class="comment">//i = 30;			//子类不能直接访问父类中private的成员变量</span></span><br><span class="line">    &#125;	</span><br><span class="line">	<span class="comment">//需要注意的是，子类虽然拥有父类private的东西，但是不能直接访问他们</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;			<span class="comment">//子类拥有父类的包括public和private的所有东西</span></span><br><span class="line">	<span class="comment">//b.set(10);	//protected访问限制main里面（外界）不能调用set函数	</span></span><br><span class="line">	b.<span class="built_in">print</span>();</span><br><span class="line">	b.<span class="built_in">f</span>();			<span class="comment">//子类还可以在父类基础上拓展新东西</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>父类、子类、用户类（外界）</strong>三者的关系可由下图表示： </li>
</ul>
<p><img src="https://pic.imgdb.cn/item/675696a1d0e0a243d4e04003.png" style="zoom:70%"></p>
<h4 id="4-2-父类子类的关系"><a href="#4-2-父类子类的关系" class="headerlink" title="4.2 父类子类的关系"></a>4.2 父类子类的关系</h4><p>在《对象组合（Object composition）》一章中我们提到过：各个对象的初始化由初始化列表调用各自的构造函数完成。当时给出的理由是为了避免破坏对象的边界，但是却没有尝试如果不这样做会怎么样。</p>
<p>由《继承（Inheritance）》一章中我们得知子类拥有父类的所有东西，这其实可以看作是父类整个“fully”进子类了。所以，在创建子类的对象时，父类的构造函数会自动被调用。《继承（Inheritance）》一章中的演示代码可以看到类A有一个default constructor，为了演示<strong>初始化列表</strong>的重要性，这里我们对演示代码做一些小改动，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> ii):<span class="built_in">i</span>(ii) &#123; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; &#125;	<span class="comment">//A的构造函数改为带参构造函数</span></span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; &#125;		</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;A::f(),i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i = ii; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;		<span class="comment">//C++继承语法，表示B类是A类的子类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">set</span>(<span class="number">20</span>); <span class="built_in">print</span>(); &#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//B类没有自己的构造函数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;			<span class="comment">//生成子类对象</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码会产生错误，具体请复制到编译器查看。</p>
<p>同样B类中都没有构造函数，为什么仅仅把A类的构造函数改成带参构造函数就无法运行呢？而且这个错误信息看起来毫无头绪。</p>
<p>这就要提到C++里继承的本质了。我们在创建B的对象时，首先会分配一块空间给B，随后进行初始化。而B的对象里面有A的所有东西，所以要初始化B的对象，那么B里面的A类的对象的那部分也要被初始化。而显然，A的带参构造函数没有被正确调用，那么编译器会去寻找默认构造函数去调用。这一点在《构造和析构（Constructor &amp; Destructor）》一章中提到过。</p>
<p>所以，无论是组合还是继承这一点都是一样的：<strong>当你的身体里有其他类的对象的时候，你不懂怎么去初始化他，必须把初始化的工作交给他们自己去做</strong>。这样做对象的边界仍然是清晰的，也可以避免一些莫名其妙的错误。</p>
<p>所以，上面的代码你必须得想办法去调用A的构造函数传参给它，而我们知道构造函数都是创建对象时自动调用的，而我们没法主动调用它。怎么做呢？答案就是：<strong><font color="red">初始化列表</font></strong>。所以，我们只需要给B加个构造函数，比如下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;		</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span> () : <span class="built_in">A</span> (<span class="number">15</span>) &#123;&#125;	<span class="comment">// 初始化列表</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">set</span>(<span class="number">20</span>); <span class="built_in">print</span>(); &#125;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后提一下：当父类和子类都有自己的<strong>构造函数</strong>和<strong>析构函数</strong>时，创建子类对象会先构造父类，再构造子类；退出时先析构子类，再析构父类（先进后出） 。 </p>
<h4 id="4-3-名字隐藏（Name-hiding）"><a href="#4-3-名字隐藏（Name-hiding）" class="headerlink" title="4.3 名字隐藏（Name hiding）"></a>4.3 名字隐藏（Name hiding）</h4><p>在C++中有一个仅此一家的机制：<strong>名字隐藏</strong>。以下方代码为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> ii) :<span class="built_in">i</span>(ii) &#123; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; &#125;	</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::print()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cout &lt;&lt; i; <span class="built_in">print</span>(); &#125;		<span class="comment">//父类中有函数重载</span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i = ii; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;		</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() : <span class="built_in">A</span>(<span class="number">15</span>) &#123; cout &lt;&lt; <span class="string">&quot;B::B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::print()&quot;</span> &lt;&lt; endl; &#125;	</span><br><span class="line">	<span class="comment">//同时子类中出现了与父类重复的函数（函数名相同，参数表相同）</span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">set</span>(<span class="number">20</span>); <span class="built_in">print</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	B b;			</span><br><span class="line">	b.<span class="built_in">set</span>(<span class="number">10</span>);</span><br><span class="line">	b.<span class="built_in">print</span>();</span><br><span class="line">	b.<span class="built_in">f</span>();</span><br><span class="line">	b.<span class="built_in">print</span>(<span class="number">200</span>);    <span class="comment">//ERROR </span></span><br><span class="line">    <span class="comment">//子类拥有父类的所有东西，所以按理说B的对象b应该是有父类中print(int i)函数的</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码会产生错误，具体请复制到编译器查看。</p>
<p>这件事就称之为“<strong>名字隐藏</strong>” ，简单来说：<strong>假设父类中有一组重载函数，子类在继承父类时如果”覆盖”了这组重载函数中的任意一个，则其余没有被”覆盖”的同名函数在子类中是不可见的。</strong>只有C++是这么干的，其他OOP语言都不会出现这种情况。那么，C++为什么会这么干呢？</p>
<p>这其实还和另外一件事情只有C++这么干的有关系：以上面代码为例，对C++来说，子类中的print()函数跟父类中的print()函数其实是没有关系的；其他OOP语言在同样的情况下两个print()函数会构成一种关系：<strong>override（覆盖）</strong>。而C++认为他俩没关系的，只是碰巧重名了；而同时正因为他俩没关系，所以父类中的所有重载函数也必须得和子类没关系才行，要不然就乱套了。</p>
<p>如果你还是想要调用那个print(int i)，那句错误代码就要改成下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b.A::<span class="built_in">print</span>(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<h3 id="5-函数重载和缺省参数（Function-overloading-amp-Default-arguments）"><a href="#5-函数重载和缺省参数（Function-overloading-amp-Default-arguments）" class="headerlink" title="5 函数重载和缺省参数（Function overloading &amp; Default arguments）"></a>5 函数重载和缺省参数（Function overloading &amp; Default arguments）</h3><h4 id="5-1-Function-overloading"><a href="#5-1-Function-overloading" class="headerlink" title="5.1 Function overloading"></a>5.1 Function overloading</h4><p>所谓<strong>函数重载</strong>是指一些函数可以具有相同的函数名，却拥有不同的参数表，他们之间便构成了重载的关系。请注意返回类型不是构成重载的条件（如果两个函数拥有相同的名称和参数列表，但是返回类型不同，是不构成重载关系的） 。</p>
<h4 id="5-2-缺省参数"><a href="#5-2-缺省参数" class="headerlink" title="5.2 缺省参数"></a>5.2 缺省参数</h4><p>所谓“缺省参数”，你可以在函数声明中预先给函数的参数表里部分或全部参数一个值，如果没有在函数调用中提供值，编译器将自动插入预先给的值；</p>
<ul>
<li>声明一个有参数列表的函数时，缺省参数必须从右到左添加；</li>
<li>缺省参数是写在头文件（.h）里的，并且不能在.cpp里面重复一遍；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">short</span> i = <span class="number">6</span>, <span class="keyword">double</span> j = <span class="number">1.23</span>)</span></span>;</span><br><span class="line"><span class="comment">//void f(int m, int n, short i = 6, double j) &#123;&#125;	//ERROR：默认实参不在形参列表的结尾</span></span><br></pre></td></tr></table></figure>
<p>有一点不要忘了：C/C++中<code>#include</code>的本质。编译器在编译之前有一个“<strong>预处理</strong>”过程，在预处理过程中，<code>.h</code>的内容会被展开到<code>.cpp</code>文件里面去。所以当你没有<code>#include a.h</code>的时候直接在<code>main.cpp</code>文件里把<code>a.h</code>的内容复制进来同样可以运行。看起来你好像把缺省参数写在<code>.cpp</code>文件里了，实际上你只是帮助编译器完成了“预处理”这一步的工作。</p>
<h3 id="6-内联函数（Inline-functions）"><a href="#6-内联函数（Inline-functions）" class="headerlink" title="6 内联函数（Inline functions）"></a>6 内联函数（Inline functions）</h3><ul>
<li>函数调用的额外开销：在执行命令之前，设备所需的处理时间<ul>
<li>push参数进栈</li>
<li>push返回地址</li>
<li>准备返回值（x86汇编一般会用AX（accumulator）累加寄存器存放返回值）</li>
<li>pop all pushed（把push进的都要pop出来）</li>
</ul>
</li>
</ul>
<p>C++提供了一个手段以避免上面这些额外开销：<strong>内联函数</strong>。如果这个函数是内联的，当我们去调用该函数时，C++不会真的去调用函数，去做那些“Push、Prepare、Call、Pop、Return”等等动作；<strong>而是把那个函数的代码嵌入到调用它的地方去，并且同时还会保持函数的独立性</strong>（函数有自己的空间：比如函数有自己的局部/本地变量，进去的时候存在，出来就不存在了；或者调用函数时需要对参数进行检查等这些事情都还是保留的）。</p>
<blockquote>
<p>其实，内联函数有点类似于<strong>宏定义函数</strong>。但是宏是不能做<strong>类型检查</strong>的；而inline作为函数是可以由编译器做<strong>类型检查</strong>的。</p>
</blockquote>
<p>内联前：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="built_in">f</span>(a);		</span><br><span class="line">			</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*对应汇编代码：</span></span><br><span class="line"><span class="comment">* _f_int:</span></span><br><span class="line"><span class="comment">*	add  ax,@sp[-8],@sp[-8]</span></span><br><span class="line"><span class="comment">*	ret</span></span><br><span class="line"><span class="comment">* _main:</span></span><br><span class="line"><span class="comment">*	add  sp,#8</span></span><br><span class="line"><span class="comment">*	mov  ax,#4</span></span><br><span class="line"><span class="comment">*	mov  @sp[-8],ax</span></span><br><span class="line"><span class="comment">*	mov	 ax,@sp[-8]</span></span><br><span class="line"><span class="comment">*	push ax</span></span><br><span class="line"><span class="comment">*	call _f_int</span></span><br><span class="line"><span class="comment">*	mov  @sp[-4],ax</span></span><br><span class="line"><span class="comment">*	pop  ax</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>内联后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;   <span class="comment">//加上inline关键字</span></span><br><span class="line">	<span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="built_in">f</span>(a);		<span class="comment">//实际生成的代码：int b = a+a;</span></span><br><span class="line">			</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*对应汇编代码：</span></span><br><span class="line"><span class="comment">* _main:</span></span><br><span class="line"><span class="comment">*	add  sp,#8</span></span><br><span class="line"><span class="comment">*	mov  ax,#4</span></span><br><span class="line"><span class="comment">*	mov  @sp[-8],ax</span></span><br><span class="line"><span class="comment">*	add  ax,@sp[-8],@sp[-8]</span></span><br><span class="line"><span class="comment">*	mov  @sp[-4],ax</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//可以看到最终生成的可执行代码里面是没有那个内联函数的，省去了很多工作</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一个内联函数在.obj文件(Linux平台下为.o文件)里可能不会生成任何代码；</li>
<li>与<strong>缺省参数</strong>不同的是，<strong>内联函数</strong>要求在声明和定义的时候都需要重复<strong>“inline”</strong>关键字，我们简化一下<strong>缺省参数</strong>里面那个代码例子； </li>
</ul>
<p>————————————————</p>
<p>内联函数的使用需要对编译器进行一系列调整，否则会出现一些错误，具体请参考参考链接的介绍。</p>
<p>对于<strong>内联函数</strong>来说，.cpp文件是完全不需要的，在.h里面把所有内联函数的“body”放进去就可以了；</p>
<p>————————————————</p>
<ul>
<li>综合以上所有，以下几种情况建议内联：<ul>
<li>只有两到三行的小函数； </li>
<li>频繁调用的函数（比如函数调用处在循环里，就会被频繁调用）； </li>
</ul>
</li>
<li>以下几种情况不建议内联：<ul>
<li>非常大的函数（比如超过20行的函数）；</li>
<li>递归函数；</li>
</ul>
</li>
</ul>
<p><strong><font color="blue">注意</font></strong>：你在类的声明（declaration）中定义（define）的任何函数都<strong>默认</strong>为内联函数；（就是在<code>.h</code>文件中本来只在类中声明成员方法，但是现在不仅声明了，还在<code>.h</code>文件中把成员函数的函数体也写出来了，那么这个成员方法就是内联函数）。</p>
<h3 id="10-Const"><a href="#10-Const" class="headerlink" title="10 Const"></a>10 Const</h3><h4 id="10-1-Const基础"><a href="#10-1-Const基础" class="headerlink" title="10.1 Const基础"></a>10.1 Const基础</h4><p>在C语言中，我们已经学习过一次<code>const</code>了，意思是<code>const</code>的变量<strong>被初始化之后不能被赋值</strong>，不过对于C++来说，<strong>const的变量仍然是变量，而不是常数</strong>，这是不一样的。因为对编译器来说，变量意味着它真的要在内存里面给你分配地址的，而常数意味着这只是编译器在编译过程中记在自己内存表里的一个实体。</p>
<p>而且，const的变量仍然遵循范围规则（scope rule），如果是本地变量，即便const了，还是进函数才有，出函数就没了。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个编译时刻知道值的const；</span></span><br><span class="line"><span class="comment">// 它的值必须初始化；</span></span><br><span class="line"><span class="comment">// 它可以用来定义数组长度（int buf[bufsize];）</span></span><br><span class="line"><span class="comment">// 除非你添加“extern”显式声明；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufsize = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个编译时刻不知道值的const；</span></span><br><span class="line"><span class="comment">// 不同于上面，它不可以用来定义数组长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufsize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器不会允许你修改其值；</span></span><br><span class="line"><span class="comment">// 这句代码意思是“bufsize是定义在某处的全局变量，同时这个全局变量是const”。对编译器来说：你说它是const，那么我就要求这个bufsize你可以用，但是你不能修改 。这和bufsize本身是不是真的是const没有关系；</span></span><br><span class="line"><span class="comment">// 它同样不可以用来定义数组长度；</span></span><br></pre></td></tr></table></figure>
<p>此外还有用<code>const</code>修饰指针：详情请移步至：<a href="https://blog.csdn.net/YMGogre/article/details/123760858">浅谈const int <em>，int const </em>与int *const</a> </p>
<p><img src="https://pic.imgdb.cn/item/675ac408d0e0a243d4e2f96d.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* x)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*表示可以给这个函数任何int变量（无论是不是const），</span></span></span><br><span class="line"><span class="comment"><span class="function">对调用f函数的人来说，这表示你传给f函数的虽然是指针，</span></span></span><br><span class="line"><span class="comment"><span class="function">但f函数保证不会对你的东西做任何修改*/</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>const</code>可以修饰成员函数，<strong>表示该函数不会改变类的成员变量，也不会在该函数中调用类中其他非const的成员函数</strong></p>
<ul>
<li>在声明和定义的时候都要重复<code>const</code>关键字； </li>
<li>实质上是表明<code>this</code>是<code>const</code>（这一点会在下一章详细讲）；</li>
</ul>
</li>
<li><p>const可以修饰函数返回值，不过我们知道像返回int这种基本类型数据实际上是在返回一个值，返回值的函数不能作<a href="https://zhuanlan.zhihu.com/p/513628368">左值</a>； </p>
<ul>
<li>除非你函数返回一个指针，但如果返回的指针是const那么它带星号 *(f()) 也不能作左值了。<br>对一个函数传进传出整个对象时可能会造成很大的开销（传参需要在堆栈里分配空间，意味着在堆栈里要花很多时间空间做拷贝工作），往往更好的办法是传一个地址。但是传地址我们又会很不放心别人会不会通过指针修改我们的原始数据。<br>这个时候，const修饰指针的作用就来了。我们在前面加上 const 表明我们以一个const的方式传一个对象进去，这样就可以保证我们的数据是安全的。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_i</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i = ii; <span class="built_in">get_i</span>(); cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_i</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">	<span class="built_in">A</span>() ：<span class="built_in">i</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;Now in A::A(),i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123;i = <span class="number">20</span>; cout &lt;&lt; <span class="string">&quot;Now in A::~A(), i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_i</span><span class="params">(<span class="keyword">const</span> A* a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> test = <span class="number">9</span>;</span><br><span class="line"> </span><br><span class="line">	a-&gt;<span class="built_in">get_i</span>();			</span><br><span class="line">    <span class="comment">//get_i()是const修饰的成员函数，表示不会动成员变量，所以可以调用</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//a-&gt;set_i(test);	</span></span><br><span class="line">    <span class="comment">//C2662	“void A::set_i(int)”: 不能将“this”指针从“const A”转换为“A&amp; ”</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A* a = <span class="keyword">new</span> A;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">set_i</span>(a);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">delete</span> a;    </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>const可以修饰整个对象，表明对象里的值是不能被修改的（常量对象），这其实就是和const int、const char等是一回事（别忘了面向对象的5条原则之“万事万物皆是对象”，一个int、一个char都是对象）。一旦将对象定义为const之后，该对象的任何非 const 成员函数都不能被调用，因为任何非 const 成员函数可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;                <span class="comment">//私有的非const成员变量i</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> j;                <span class="comment">//公开的非const成员变量j</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">6</span>;      <span class="comment">//公开的const成员变量k</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_i</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i = ii; cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_j</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> j; &#125;</span><br><span class="line">	<span class="built_in">A</span>() &#123; i = <span class="number">0</span>; j = <span class="number">1</span>; cout &lt;&lt; <span class="string">&quot;Now in A::A(),i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; i = <span class="number">20</span>; j = <span class="number">21</span>; cout &lt;&lt; <span class="string">&quot;Now in A::~A(), i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> A* a = <span class="keyword">new</span> A;</span><br><span class="line">	<span class="comment">//const修饰A类的对象指针a，当然可以直接const对象“const A a;”（类似于const int a;）</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//a-&gt;set_i(10);                        //无法调用非const成员函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;j=&quot;</span> &lt;&lt; a-&gt;<span class="built_in">get_j</span>() &lt;&lt; endl;    <span class="comment">//可以调用const的成员函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;j=&quot;</span> &lt;&lt; a-&gt;j &lt;&lt; endl;          </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;k=&quot;</span> &lt;&lt; a-&gt;k &lt;&lt; endl;          <span class="comment">//可以访问const or 非const的公开的成员变量</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">delete</span> a;    <span class="comment">//new了记得delete</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.51cto.com/u_15717647/8409282">const在函数前后的意义 - 51博客</a></p>
<h4 id="10-2-补充：字符串字面值（String-literals）"><a href="#10-2-补充：字符串字面值（String-literals）" class="headerlink" title="10.2 补充：字符串字面值（String literals）"></a>10.2 补充：字符串字面值（String literals）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	s[<span class="number">0</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码在Visual Studio里无法运行，给出了错误。</p>
<p>而我们修改下代码，就可以成功运行了：   </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[] = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	s[<span class="number">0</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 这是怎么一回事呢？        </p>
<p> 问题出在s是本地变量，存放在堆栈里面。</p>
<p> 当s作为指针，指向了一块内存，这块内存放了个字符串；而”Hello world”是个常量且编译器会认为这是个const的东西。这其实是一个“ const char* s ”不过是编译器接受不加“ const ”的写法，所以它是放在“代码段”里面的。这个时候s只是存放了”Hello world”所在的代码段的地址，而代码段是不可写的。</p>
<p> 而当s作为一个数组，整个数组都存放在堆栈里面。这个时候代码会变成它要对”Hello world”整个做一个拷贝，它会把代码段里的”Hello world”拷贝到堆栈里面来。后续的修改也是对拷贝过来的副本做的修改。</p>
<p> 实际上我们可以证明这件事的：分别打印s1、s2、main函数的地址；结果显示：显然，s1和main函数处在一个段（代码段）；s2处在堆栈段。 </p>
</blockquote>
<h3 id="11-引用-别名"><a href="#11-引用-别名" class="headerlink" title="11 引用/别名"></a>11 引用/别名</h3><h4 id="11-1-引用的基本概念"><a href="#11-1-引用的基本概念" class="headerlink" title="11.1 引用的基本概念"></a>11.1 引用的基本概念</h4><p>C++提供了非常多的内存模型：</p>
<ul>
<li>提供了许多存放对象的地方（堆栈、堆、全局数据区）；</li>
<li>提供了许多可以访问对象的方式（直接“<strong>fully</strong>”那个对象、通过指针访问对象、通过引用访问对象）</li>
</ul>
<p><strong>引用是C++中一种新的数据类型</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> i;            <span class="comment">//i is a character(i是一个字符)</span></span><br><span class="line"><span class="keyword">char</span>* p = &amp;i;      <span class="comment">//p is a pointer to a character(指针)</span></span><br><span class="line"><span class="keyword">char</span>&amp; r = i;       <span class="comment">//r is a reference to a character(引用)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*一般引用都需要在定义的时候给个初始值，以表明r是i的引用；</span></span><br><span class="line"><span class="comment">并且初始值得是一个可以作左值的东西*/</span></span><br></pre></td></tr></table></figure>
<p>引用还有另外一个名字：<strong>alias（别名）</strong>； </p>
<p>由上面两个名字可以看出：引用其实就是当我们需要用<code>i</code>的时候，我们可以用<code>r</code>；用<code>r</code>就是在用<code>i</code> 。<strong>它们只是一个东西的两个名字</strong>。</p>
<p>基本语法：<code>type&amp; refname = name</code>。</p>
<p>只有作为成员变量或者放在(函数)参数表里面才可以不用给初始值，其他都要给。</p>
<p><code>const char&amp; r = i</code>：表示无法通过<code>r</code>改变<code>i</code>。</p>
<p> 与c不同，引用的这种“绑定”关系是不可变的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>；</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; r = x;    <span class="comment">//r是x的引用，绑定关系是永久的</span></span><br><span class="line">    r = y;         <span class="comment">//这句代码就只是纯粹的赋值，而不是将r转变为y的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用可以作<strong>左值</strong>（”做左值”是”引用”的<a href="https://baike.baidu.com/item/%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6/9706361">必要条件</a>），所以返回引用的函数也可以作左值（我们知道返回基本类型的函数不能作左值） </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;        <span class="comment">//返回x的引用（没有提供引用名）</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">h</span><span class="params">(<span class="keyword">int</span>&amp; y)</span> </span>&#123;     <span class="comment">//参数表中的引用可以不用给初始值，在调用时会用实参的值初始化引用   </span></span><br><span class="line">    y++;             <span class="comment">//对引用的操作就是对被引用者的操作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in h() y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> y;        <span class="comment">//return引用就是return被引用者，而函数返回类型还是引用，所以还是返回被引用者的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; i = x;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> k = <span class="number">0.0</span>;</span><br><span class="line"> </span><br><span class="line">    *<span class="built_in">f</span>() = <span class="number">8</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">g</span>() = <span class="number">16</span>;    <span class="comment">//g函数返回x的引用，给引用赋值就是给x赋值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">h</span>(i);       <span class="comment">//因为&quot;引用&quot;的出现，给函数传参就不一定只是传值了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*类似于h(i)这种看起来像传值调用但实际上是可以改变全局变量x的值的，</span></span><br><span class="line"><span class="comment">    所以我们一定要去检查源代码*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">h</span>(j) = <span class="number">7</span>;		<span class="comment">// 可以做左值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*给h传递引用或变量进去都是可以的，可以做引用的引用这种事情</span></span><br><span class="line"><span class="comment">    int&amp; a = x;</span></span><br><span class="line"><span class="comment">    int&amp; b = a;</span></span><br><span class="line"><span class="comment">    这一点指针无法做到：当参数要指针时就只能传地址不能传变量*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//h(k);       //ERROR：无法用&quot;double&quot;类型的值初始化&quot;int &amp;&quot;类型的引用(非常量限定)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-2-引用-VS-指针"><a href="#11-2-引用-VS-指针" class="headerlink" title="11.2 引用 VS 指针"></a>11.2 引用 VS 指针</h4><div class="table-container">
<table>
<thead>
<tr>
<th>指针</th>
<th>引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以为空；<br>  <strong>指针</strong>独立于现有的对象； <br>一个指针可以指向不同的地址；</td>
<td>不能为空，一定要有初始值；<br>依附于现有变量，是现有变量的一个“<strong>别名</strong>”；<br><strong>引用</strong>的这种“绑定”关系是永久的；</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p> C++里<strong>引用其实就是通过指针实现的</strong>（这一点无法验证，我们无法获取到引用的地址，实际上会得到被引用变量的地址，不过这并不妨碍我们理解引用的本质），引用本质上就是个const指针（<code>int *const p</code>，你可以理解为引用<code>r</code>实质上就是那个<code>*p</code>）；<strong>设计“引用”这个东西出来是为了让代码少一点”*”号，使代码看上去简洁美观</strong>。（不过还是不要弄混了，引用在C++内部是通过指针实现，但这不代表引用变量的类型是指针；引用本身就是一种新的数据类型了）</p>
<p>Java则是以另一种方式解决这个问题：Java设计成只能通过指针去访问对象。正因为只有这一种访问对象的方式，所以Java可以把那个”*”号取消掉；然后对外宣称这不是指针，是“引用”。但实际上Java中的“引用”跟C++中的引用不是一回事，它更像C++中的指针。</p>
</blockquote>
<h4 id="1-3-一些引用限制（Restrictions）："><a href="#1-3-一些引用限制（Restrictions）：" class="headerlink" title="1.3 一些引用限制（Restrictions）："></a>1.3 一些引用限制（Restrictions）：</h4><ol>
<li>C++没有引用的引用（但编译器可能会帮你做到这点）；</li>
<li><code>＆</code>引用变量共享被引变量的内存，它是“别名”，故理论上不分配内存；</li>
<li>被<code>＆</code>引用的变量或表达式一定是分配了内存的有址左值；</li>
<li>由此可知，一个<code>＆</code>引用变量不能引用自己；</li>
<li>Visual Studio允许引用的引用，显然：”引用的引用”和”引用”和”被引用者”它们三个都是一个东西；</li>
<li>没有指向引用的指针；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;* p;          <span class="comment">//illegal(非法的)</span></span><br></pre></td></tr></table></figure>
<ol>
<li>但是可以有指针的引用；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = &amp;x;        </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>*&amp; r = p;     <span class="comment">//it&#x27;s OK!</span></span><br></pre></td></tr></table></figure>
<ol>
<li>没有引用的数组。</li>
</ol>
<p>这里补充一点：<strong>离变量名最近的那个符号，决定了它的基本类型</strong>。</p>
<h3 id="12-向上造型（Upcasting）"><a href="#12-向上造型（Upcasting）" class="headerlink" title="12 向上造型（Upcasting）"></a>12 向上造型（Upcasting）</h3><p> <strong>向上造型是将子类的引用或指针转变为父类的引用或指针的一种行为</strong>。也就是说如果B<strong>继承</strong>自A，那么你就可以在任何能够使用A的场合去使用B，B相比A多出来的那些东西可以当作不存在。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> :</span> <span class="keyword">public</span> person &#123;...&#125;;    <span class="comment">//student继承自person</span></span><br><span class="line">student jack;                           <span class="comment">//student对象jack</span></span><br><span class="line"> </span><br><span class="line">person* pp = &amp;jack;    <span class="comment">//it&#x27;s Upcast</span></span><br><span class="line">person&amp; pr = jack;     <span class="comment">//it&#x27;s Upcast   </span></span><br></pre></td></tr></table></figure>
<p>同时，在<a href="https://blog.csdn.net/YMGogre/article/details/126759839">上半部分学习笔记</a>中我们提到过“<strong>名字隐藏</strong>”，但如果你通过”pp”或者”pr”去调用函数时，<strong>实际上会调用父类的对应函数</strong>，也就不会有<strong>名字隐藏</strong>的问题出现。以下面这段代码为例： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f() with no parameter&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f() with one parameter&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f() with two parameters&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f() with three parameters&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f() with two parameters&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	A* p = &amp;b;		<span class="comment">//Upcast，将b的引用交给了指向A的对象的指针p</span></span><br><span class="line">	p-&gt;<span class="built_in">f</span>(i);        <span class="comment">//调用父类的f函数</span></span><br><span class="line">	<span class="comment">//b.f(i);		//ERROR: Name hiding</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不扯远了，回到<strong>向上造型</strong>本身：从内部结构上来说，<strong>子类的对象拥有父类对象的所有东西（包括私有和公共的）</strong>；从实际内存存储上来说，存储B对象的那块内存里面确实存储了一整块A对象而且是放在那块内存顶部的，连A对象里面数据的排列顺序都是完全一致的。所以，B完全可以当作A来看待和使用。以下面这段代码为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>), <span class="built_in">j</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() : <span class="built_in">k</span>(<span class="number">3</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> k; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;	<span class="comment">//将a的地址取出来强制类型转换为指向int的指针后交给指向int的指针p</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a.i=&quot;</span> &lt;&lt; a.i &lt;&lt; <span class="string">&quot;；&quot;</span> &lt;&lt; <span class="string">&quot;a.j=&quot;</span> &lt;&lt; a.j &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b.i=&quot;</span> &lt;&lt; b.i &lt;&lt; <span class="string">&quot;；&quot;</span> &lt;&lt; <span class="string">&quot;b.j=&quot;</span> &lt;&lt; b.j &lt;&lt; <span class="string">&quot;；&quot;</span> &lt;&lt; <span class="string">&quot;b.k=&quot;</span> &lt;&lt; b.<span class="built_in">get_k</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Sizeof(a) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; <span class="string">&quot;	byte&quot;</span> &lt;&lt; endl;	</span><br><span class="line">    <span class="comment">//a实际只存储着它的两个int变量，所以它大小是8（byte）</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Sizeof(b) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(b) &lt;&lt; <span class="string">&quot;	byte&quot;</span> &lt;&lt; endl &lt;&lt; endl;	</span><br><span class="line">    <span class="comment">//b存储着a的所有东西以及自己的int变量k，所以b的大小是12（byte）</span></span><br><span class="line"> </span><br><span class="line">	*p = <span class="number">10</span>;		<span class="comment">//和C类似，C++在获取到地址之后也可以直接访问最底层的内存并做些修改</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a.i=&quot;</span> &lt;&lt; a.i &lt;&lt; <span class="string">&quot;；&quot;</span> &lt;&lt; <span class="string">&quot;a.j=&quot;</span> &lt;&lt; a.j &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	p = (<span class="keyword">int</span>*)&amp;b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;	<span class="comment">//按顺序访问b的内存的每一个int看看b究竟是怎么个顺序存储它的数据的</span></span><br><span class="line">	p++;							</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	p++;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//通过指针就可以随心所欲直接访问b的private的k</span></span><br><span class="line">	*p = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;modify *p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b.i=&quot;</span> &lt;&lt; b.i &lt;&lt; <span class="string">&quot;；&quot;</span> &lt;&lt; <span class="string">&quot;b.j=&quot;</span> &lt;&lt; b.j &lt;&lt; <span class="string">&quot;；&quot;</span> &lt;&lt; <span class="string">&quot;b.k=&quot;</span> &lt;&lt; b.<span class="built_in">get_k</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 由上面代码以及运行结果可以看出：当我们获取到对象的指针时，可以直接通过指针看看对象里面是什么样的。b的大小是12（byte），也证明了在<strong><font color="blue">b（对象）里面是没有成员函数的，只有成员变量，这跟C语言中的结构体是一样的（实际上类的成员函数存放在代码段的）</font></strong>。</p>
<p><strong>同时子类拥有父类的所有东西，连数据存储顺序都是一样的</strong>。以上面代码为例，不会说b的<code>k</code>是插在<code>i</code>和<code>j</code>中间存储的。所以b完全可以当作a来使用，但b还是b，不会因此真的变成a，只是我们把它看作是a了。 </p>
<p><img src="https://pic.imgdb.cn/item/675ba23ad0e0a243d4e32a8b.png" style="zoom:30%"></p>
<p>最后再提一点是：相反地，有<strong>向上造型</strong>也有<strong>向下造型</strong>，即把父类的对象当作子类的对象看待。但<strong>向下造型</strong>是有风险的！ </p>
<h3 id="13-多态性"><a href="#13-多态性" class="headerlink" title="13 多态性"></a>13 多态性</h3><h4 id="13-1-多态的介绍"><a href="#13-1-多态的介绍" class="headerlink" title="13.1 多态的介绍"></a>13.1 多态的介绍</h4><p>现在我们要设计一个画图程序</p>
<p><img src="https://pic.imgdb.cn/item/675fd8f2d0e0a243d4e48b96.png" style="zoom:40%"></p>
<p>程序可以画三种不同的图形：矩形、圆形、椭圆。 他们拥有相同的数据：center（中心点坐标）；可以做三种相同的操作：render（渲染图形）、move（移动图形）、resize（改变大小）。</p>
<p>为了实现上述要求，我们可以以一个类型来定义另一个类型：</p>
<ul>
<li><p>一个ellipse是一种shape；</p>
</li>
<li><p>一个circle是一种特殊的ellipse；</p>
</li>
<li><p>一个rectangle是另外一种不同的shape；</p>
</li>
<li><p>rectangle、circle、ellipse拥有一些共同的：属性（成员变量）和服务（成员函数）；</p>
</li>
<li><p>但它们三个也不是完全相同的；</p>
</li>
</ul>
<p>于是，它们构成了如下图所示的联系：</p>
<p><img src="https://pic.imgdb.cn/item/675fd9bbd0e0a243d4e48bf4.png" style="zoom:40%"></p>
<p>center 和 move() 只在Shape里面定义了，对大家来说center和move()要做的事情都是一样的，所以其他四个类里面就不需要再定义了；而不同图形的 render() 是不一样的，而且不同的图形类里面可能有自己的数据（比如Ellipse类有”长轴”、”短轴”数据），同时不同图形的render()和Shape的render()得是存在某种联系的。</p>
<p>下面来设计代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Shape类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XYPos</span> &#123;</span>...&#125;;    <span class="comment">//x,y point</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>();    <span class="comment">//析构函数也用了virtual修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;    </span><br><span class="line">    <span class="comment">/*&quot;virtual&quot;关键字意思是“虚的”，表示如果将来Shape类的子类里面重写了render()，</span></span><br><span class="line"><span class="comment">    那么重写的render()跟这个render()是有联系的！！</span></span><br><span class="line"><span class="comment">    这跟我们在“Name hiding”中提到的“子类中的print()函数跟父类中的print()函数是没有关系的”</span></span><br><span class="line"><span class="comment">    是不一样的！！*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">const</span> XYPos&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    XYPos center;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ellipse类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Ellipse</span>(<span class="keyword">float</span> maj, <span class="keyword">float</span> minr);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;          </span><br><span class="line">    <span class="comment">/*will define own, &quot;virtual&quot;可以不加，因为只要一个类中某个函数是virtual的，</span></span><br><span class="line"><span class="comment">    那么这个类的子子孙孙的那个函数都是virtual了，无论前面是否加了virtual修饰；</span></span><br><span class="line"><span class="comment">    当然加上&quot;virtual&quot;是个好习惯，这样别人不用去翻祖先类就知道这个函数是virtual了*/</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> major_axis, minor_axis    <span class="comment">//长轴和短轴</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Ellipse &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="keyword">float</span> radius) : <span class="built_in">Ellipse</span>(radius, radius) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之所以搞得这么麻烦是为了实现如下面这个应用实例中的这样的<strong>render()</strong>函数： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(Shape* p)</span> </span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">render</span>();        <span class="comment">//calls correct render function </span></span><br><span class="line">&#125;                       <span class="comment">//for given Shape!</span></span><br><span class="line"><span class="comment">/*render函数接受一个Shape的指针作为输入，然后让指针指向的那个对象去做render</span></span><br><span class="line"><span class="comment">render函数是个通用函数，对任何Shape类的子类都是适用的(包括Shape自己)，</span></span><br><span class="line"><span class="comment">也就是说这个render函数是用于将来的新出现的Shape的子类的对象。而现在，</span></span><br><span class="line"><span class="comment">我还不知道将来Shape还会有什么样的子类，但这个函数写在这里对将来Shape可能出现的子类也是通用的*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Ellipse <span class="title">ell</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    ell.<span class="built_in">render</span>();        <span class="comment">//调用Ellipse的render()</span></span><br><span class="line">    <span class="function">Circle <span class="title">circ</span><span class="params">(<span class="number">40</span>)</span></span>;</span><br><span class="line">    circ.<span class="built_in">render</span>();       <span class="comment">//调用Circle的render()</span></span><br><span class="line">    <span class="built_in">render</span>(&amp;ell);        <span class="comment">//Upcast向上造型，但由于virtual的关系故不会调用父类中的render()，而是调用Ellipse自己的render()</span></span><br><span class="line">    <span class="built_in">render</span>(&amp;circ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-2-多态定义"><a href="#13-2-多态定义" class="headerlink" title="13.2 多态定义"></a>13.2 多态定义</h4><p><strong>“virtual”</strong>是在告诉编译器当一个函数是virtual时，且对这个函数的调用如果是通过指针或引用的话，编译器就不能相信它一定是什么类型的。需要到<strong>运行时刻</strong>确定这个指针所指的那个对象到底是什么类型，再去调用那个类型的该函数；<br>而上面提到的这些事情，就称为“<strong><font color="red">多态性</font></strong>”。对于上面的应用实例代码，<strong>p就是多态的</strong>，有的地方也称p为“多态对象”。因为p指向什么类型的对象，通过p做的动作就是那个类型的对象做的。p指向谁就变成谁的“形态”，故称p是“多态对象”。</p>
<p>由上面可知“<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E6%80%81%E6%80%A7&amp;spm=1001.2101.3001.7020">多态性</a>”是构筑在两件事情上的： </p>
<p>① <strong>向上造型</strong>（Upcast） </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">render</span>(Shape *p)&#123;</span><br><span class="line">    p-&gt;<span class="built_in">render</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="built_in">render</span>(&amp;ell);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//仅看参数表里面的内容，其实就是&quot;Shape *p = &amp;ell&quot;，显然是Upcast</span></span><br></pre></td></tr></table></figure>
<p>② 动态绑定（Dynamic binding）；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">所谓绑定：是指调用时应该调用哪个函数；</span><br><span class="line">静态绑定：调用的函数是确定的(编译时刻就确定的)；</span><br><span class="line">动态绑定：需要到运行时刻才知道到底要调用哪个函数； </span><br></pre></td></tr></table></figure>
<h4 id="13-3-多态的实现："><a href="#13-3-多态的实现：" class="headerlink" title="13.3 多态的实现："></a>13.3 多态的实现：</h4><p>C++到底是怎样实现在运行时刻动态地绑定那个函数，在运行时刻知道p所指的那个对象到底是什么类型的继而去调用正确的函数的呢？又回到了上半部分学习笔记中的那句话：Bjame Sgoustrup 在1979年刚开始研发C++的时候，他的手段仅仅只有C，他是怎么用C语言来实现C++的多态性呢？而且实现方式也不会很复杂，毕竟C++的运行效率也是很高的，太复杂了效率就会低。</p>
<p>首先，任何一个类如果有虚函数(virtual function)，这个类的对象就会比正常的”大”一点。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.<span class="built_in">f</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(a) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//探查第一个int</span></span><br><span class="line">	p++;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//探查第二个int</span></span><br><span class="line">	p++;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//探查（如果有）第三个int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到实际占用都不止4个字节了，以Win32运行结果为例：实际上 a 的成员变量 i 是存储在第二个int的。而第一个int大小的东西我们不知道是什么；<br>那个不知道是什么的东西其实是个指针，叫做<code>vptr</code>。所有有virtual的类的对象里面最顶部都会自动加上这个隐藏的<code>vptr</code>，它指向一张表，表叫做<code>vtable</code>。<br><img src="https://pic.imgdb.cn/item/675fe1f1d0e0a243d4e48fc0.png" style="zoom:50%"></p>
<ul>
<li><strong>vtable</strong>里面存放的是这个<strong>类</strong>的所有的virtual函数的地址。所以vtable是属于这个类的，所以这个类的所有的vptr的值都是一样的，这是可以验证的：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;	<span class="comment">//A类有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	A aa;    <span class="comment">//做两个对象出来</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(a)  = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; <span class="string">&quot;byte&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(aa) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(aa) &lt;&lt; <span class="string">&quot;byte&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;        <span class="comment">//取a的地址出来强制类型转换为int型指针并交给int型指针p        </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p(a)	= &quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//取第一个int出来        </span></span><br><span class="line">	p = (<span class="keyword">int</span>*)&amp;aa;            </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p(aa)	= &quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//同样取第一个int出来，结果显示和上面是一样的</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>另外我们还可以做一些“邪恶”的事情。我们知道 <strong>p</strong> 是指向vtable的指针(就是vtable的地址) 的指针，所以 <em>p 表示指针所指的地方即vtable的地址，我们可以把 </em>p 交给另外一个指针x，那么x就会指向vtable，它们之间的关系如下图所示：</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/675fe736d0e0a243d4e49187.png" style="zoom:50%"></p>
<p>我们验证一下上面的关系： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;	<span class="comment">//A类有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(a)  = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; <span class="string">&quot;byte&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p(a)	= &quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//*p的内容是vtable的地址</span></span><br><span class="line">	<span class="keyword">int</span>* x = (<span class="keyword">int</span>*)*p;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;x	= &quot;</span> &lt;&lt; x &lt;&lt; endl;         <span class="comment">//x的内容应该也是vtable的地址</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而我们要做的“邪恶”的事情就是既然拿到指针了，我们就可以通过*x看到vtable的内容了，现在我们尝试打印下vtable的第一个int（因为x是指向int的指针嘛）：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;	<span class="comment">//A类有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(a)  = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; <span class="string">&quot;byte&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p(a)	= &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span>* x = (<span class="keyword">int</span>*)*p;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*x	= &quot;</span> &lt;&lt; *x &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>还有一点是上面我们提到过”一个有virtual函数的类的不同<strong>对象</strong>的<strong>vptr</strong>是指向同一个<strong>vtable</strong>的(也就是这个类的<strong>vtable</strong>)”；而当这个类有子类的时候，<strong>子类的</strong>不同<strong>对象</strong>当然也会有<strong>vptr</strong>，但是它们会指向子类自己的<strong>vtable</strong>；而不是父类的<strong>vtable</strong>。</li>
</ul>
<p>例如：Ellipse对象的vptr会指向Ellipse的vtable ，而不是其父类Shape的vtable</p>
<p><img src="https://pic.imgdb.cn/item/675fe858d0e0a243d4e491be.png" style="zoom:50%"></p>
<p> 可以看到：子类Ellipse的vtable的结构跟父类是一样的（第一个是析构函数dtor()、第二个render()、第三个resize()），不过里面的值（地址）是不一样的。Ellipse的析构、render()是自己的；而它的resize()是Shape的，因为Ellipse没有写自己的resize()。不过析构是特别的，即便Ellipse没有写自己的析构，编译器也会给Ellipse制造一个析构出来，所以vtable里存的是Ellipse自己的析构。同样的，还有Ellipse的子类Circle： </p>
<p><img src="https://pic.imgdb.cn/item/675fe8a0d0e0a243d4e491d6.png" style="zoom:50%"></p>
<p>通过上面那么大篇幅介绍的方式，我们终于摸清了C++实现<strong>动态绑定</strong>的方式： 只需要通过修改<strong>vtable</strong>表里的地址。当函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(Shape* p)</span> </span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">render</span>();         </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>中说”<strong>p-&gt;render()</strong>“的时候，实际发生的事情是让p所指的对象的第一个地址取出来，从该地址访问到了<strong>vtable</strong>，然后从<strong>vtable</strong>“<strong>+1</strong>“得到了那个 render() 的地址，然后调用那个地址上的 render() 函数就可以了。 </p>
<blockquote>
<p>在之前我们都还没有提到过<code>vptr</code>和<code>vtable</code>的类型。</p>
<p><code>vtable</code>：vtable的类型可以表达为<code>uintptr_t*</code>，表示<code>vtable中</code>每个元素类型都是<code>uintptr_t</code>；</p>
<p><code>vptr</code>：<code>vptr</code>指向<code>vtable</code>，因此<code>vptr</code>的类型是<code>uintptr_t**</code>，表示指针<code>vtpr</code>指向的类型是<code>uintptr_t*</code>；</p>
<p>经验证64位编译模式下<code>uintptr_t</code>、<code>uintptr_t*</code>和<code>uintptr_t**</code>都占用8个字节，所以同样的从vtable”+1”（代码层面的 指针 +1）对应地址”+8”（物理内存层面的 地址 +8）。 </p>
</blockquote>
<p>在上面我们把<em>p交给了<strong>int</strong>型指针x，若想要x指向那个 render() 函数，我们得让x”<em>*+？</em></em>“呢？ </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;	<span class="comment">//A类有虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::g(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(a)  = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; <span class="string">&quot;byte&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">	<span class="keyword">int</span>* x = (<span class="keyword">int</span>*)*p;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(x)	= &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(x) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(int)	= &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/675fea03d0e0a243d4e49223.png" style="zoom:80%"></p>
<p>可以看到这种实现<strong>动态绑定</strong>的方式是高效的，程序在<strong>运行时刻</strong>根本无需知道对象的类型是什么，只是在顺着<strong>vptr</strong>找到了<strong>vtable</strong>，然后找到了应该调用的正确函数的<strong>地址</strong>而已。  </p>
<p> 在“<strong>多态性（Polymorphism）</strong>” 一章我们提到过，” <strong>“动态绑定”</strong>是要通过<strong>指针</strong>或者<strong>引用</strong>调用<strong>virtual</strong>函数时才会去做的 “，那么我们不通过<strong>指针</strong>或者<strong>引用</strong>去调用<strong>virtual</strong>函数会怎么样呢？这一点我们展开来验证一下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;	<span class="comment">//A类有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="built_in">B</span>() : <span class="built_in">j</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f(),j = &quot;</span> &lt;&lt; j &lt;&lt; endl; &#125;	<span class="comment">//B重写了虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	B b;</span><br><span class="line"> </span><br><span class="line">	A* p = &amp;b;	<span class="comment">//Upcast but virtual</span></span><br><span class="line">	p-&gt;<span class="built_in">f</span>();		<span class="comment">//虽然向上造型了但是因为virtual存在还是会调用子类的f</span></span><br><span class="line"> </span><br><span class="line">	a = b;		<span class="comment">//直接把b赋给a</span></span><br><span class="line">	a.<span class="built_in">f</span>();		<span class="comment">//通过a.f()到底是调用a的f还是b的f呢？</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，只有通过<strong>指针</strong>或者<strong>引用</strong>调用<strong>virtual</strong>函数时才会去“<strong>动态绑定</strong>”，通过”<strong>.</strong>“去调用时并不会做这样的事情；<strong>可是我们明明把b赋给a了呀！这一点好像被完全无视了？</strong></p>
<p>我们再修改下程序，这次让指针去调用<strong>virtual</strong>函数 f() ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;	<span class="comment">//A类有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="built_in">B</span>() : <span class="built_in">j</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f(),j = &quot;</span> &lt;&lt; j &lt;&lt; endl; &#125;	<span class="comment">//B重写了虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	B b;</span><br><span class="line"> </span><br><span class="line">	A* p = &amp;b;	<span class="comment">//Upcast but virtual</span></span><br><span class="line">	p-&gt;<span class="built_in">f</span>();		<span class="comment">//虽然向上造型了但是因为virtual存在还是会调用子类的f</span></span><br><span class="line"> </span><br><span class="line">	a = b;		<span class="comment">//直接把b赋给a</span></span><br><span class="line"> </span><br><span class="line">	p = &amp;a;		<span class="comment">//这次我们通过指针去调用virtual函数，已知指针调用时会去做动态绑定的工作</span></span><br><span class="line">	p-&gt;<span class="built_in">f</span>();		<span class="comment">//那么这次又会调用a的f还是b的f呢？答案：还是调用的a的f函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么还是调用的a的f()函数呢？</p>
<p>因为我们在做赋值操作(a = b)时只是把b的值给了a（你可以试试在上面这段代码中B的构造函数里修改A的成员变量i的值，然后在赋值操作完成前后打印a.i，就能观察到b是把i的值赋过去了的），所以a还是a的；所以进行赋值操作时，b的区域是被“切掉”了的，只有符合a的那部分才会被赋值过去。而且在赋值过程中vptr是不传递的。所以自然调用的a的f函数。</p>
<p>但如果是<strong>指针</strong>的赋值的话，那显然原本的a就被覆盖丢失了…(因为指针不代表任何事情嘛，指针就是一个地址而已) </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">B* b = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line"> </span><br><span class="line">a = b;</span><br><span class="line">a-&gt;<span class="built_in">f</span>();    <span class="comment">//B::f() is called</span></span><br></pre></td></tr></table></figure>
<h4 id="13-4-虚析构函数（Virtual-destructors）"><a href="#13-4-虚析构函数（Virtual-destructors）" class="headerlink" title="13.4 虚析构函数（Virtual destructors）"></a>13.4 虚析构函数（Virtual destructors）</h4><p>在《<strong>多态性（Polymorphism）</strong>》一章中我们设计Shape类的代码里可以看到析构函数被设计为了虚函数，为什么要设计成<strong>virtual</strong>的？我们来看看下面这个代码： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shape *p = <span class="keyword">new</span> <span class="built_in">Ellipse</span>(<span class="number">100.0F</span>, <span class="number">200.0F</span>); </span><br><span class="line"><span class="comment">/*在学习《向上造型（Upcasting）》时我们说&quot;person* pp = &amp;jack;&quot;是Upcast，</span></span><br><span class="line"><span class="comment">那上面这句代码是不是Upcast呢？</span></span><br><span class="line"><span class="comment">    这也是Upcast，我们做了个Ellipse的对象交给了父类Shape的指针p：在上半部</span></span><br><span class="line"><span class="comment">分学习《new &amp; delete》时提到过new作为一个运算符会返回分配给对象的地址，所</span></span><br><span class="line"><span class="comment">以这句代码还是向上造型，向上造型本质是：把子类对象当成父类对象用*/</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<p>我们知道：当<code>delete p</code>时会自动调用析构函数，如果析构函数不是virtual的，意味着此时Shape的析构会被调用。所以，我们需要让析构函数是virtual的。</p>
<p><strong>如果我们设计的类中有一个virtual函数，我们就必须把析构函数也设计成virtual的</strong>，这样可以避免可能出现的麻烦。这件事情的关键在于即便现在我们的类没有子类，我们也无法预知将来别人会怎么修改我们的程序。比如我们想象一下下面这种场景：</p>
<p>我们设计了一个类，类里面有一些virtual函数但析构函数不是virtual的。这个时候别人写了个新类继承自我们的这个类，他知道我们的类里有virtual函数所以选择Upcast以实现动态绑定。然后由于别人写的新类里面申请了一些资源，所以别人重写了我们的析构函数用于归还申请的资源（这一点在上半部分学习笔记中的《构造和析构（Constructor &amp; Destructor）》中谈析构的用处时提到过）。而当别人new了一个他写的类的对象之后再去delete时，就像上面的代码那样，会去调用我们父类的析构，而显然我们的析构没有说要去还那些申请的资源</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">0</span>) &#123;  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f()&quot;</span> &lt;&lt; endl; &#125;    <span class="comment">//virtual f()</span></span><br><span class="line">	 ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	 ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A* p)</span> </span>&#123;</span><br><span class="line">	p-&gt;<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	B b;				</span><br><span class="line">	<span class="comment">/*b不是new出来的，在上半部分学习笔记《父类子类的关系》中我们说过：</span></span><br><span class="line"><span class="comment">          &quot;退出时会先析构子类，再析构父类&quot;</span></span><br><span class="line"><span class="comment">	所以离开大括号范围时会先调用~B()，再调用~A()。*/</span></span><br><span class="line"> </span><br><span class="line">	A* p = <span class="keyword">new</span> <span class="built_in">B</span>();		<span class="comment">//Upcast</span></span><br><span class="line"> </span><br><span class="line">	p-&gt;<span class="built_in">f</span>();				<span class="comment">//but f() is virtual，所以动态绑定</span></span><br><span class="line">	<span class="built_in">f</span>(&amp;b);				<span class="comment">//也是Upcast but virtual，所以也会动态绑定</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Before delete p&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> p;			<span class="comment">//此时会调用~A()（这不是我们期望的结果）</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After delete p&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;						<span class="comment">//此时会调用~B()、~A()</span></span><br></pre></td></tr></table></figure>
<h4 id="13-5-覆盖（Override）"><a href="#13-5-覆盖（Override）" class="headerlink" title="13.5 覆盖（Override）"></a>13.5 覆盖（Override）</h4><p>如果父类和子类的两个函数是virtual的，名称相同，参数列表也相同。那它们构成一种关系叫做”Override”。中文可以称作“覆盖”、“覆写”、“重写”或者“改写”。还记得在上半部分学习笔记中的《名字隐藏（Name hiding）》里我们说”子类中的print()函数跟父类中的print()函数是其实是没有关系的”，现在有了virtual，就构成了Override关系了。</p>
<p>在Override中如果我们想要调用父类的那个函数，可以这么写： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;In Derived::func!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        Base::<span class="built_in">func</span>();    <span class="comment">//call to base class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面举一个可以运行的例子：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in B::f(), I&#x27;m trying to call A::f()：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A::<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A* p)</span> </span>&#123;</span><br><span class="line">	p-&gt;<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	B b;				</span><br><span class="line">	A* p = <span class="keyword">new</span> <span class="built_in">B</span>();		</span><br><span class="line"> </span><br><span class="line">	p-&gt;<span class="built_in">f</span>();				</span><br><span class="line">	<span class="built_in">f</span>(&amp;b);				</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">delete</span> p;			</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h4 id="13-6-返回类型放松（Return-types-relaxation）："><a href="#13-6-返回类型放松（Return-types-relaxation）：" class="headerlink" title="13.6 返回类型放松（Return types relaxation）："></a>13.6 返回类型放松（Return types relaxation）：</h4><ul>
<li>假如B继承自A，那么C++允许<strong>B::f()</strong>返回<strong>A::f()</strong>返回类型的子类；</li>
<li><strong>适用于指针和引用类型；</strong></li>
</ul>
<p>比如<code>A::f()</code>如果返回了一个A类自己的的指针，而且<code>B::f()</code>Override它了；那么<code>B::f()</code>就可以返回B类的指针；  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> A* <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> A&amp; <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> A  <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> B* <span class="title">f</span><span class="params">()</span></span>;        <span class="comment">//it&#x27;s OK!</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> B&amp; <span class="title">g</span><span class="params">()</span></span>;        <span class="comment">//it&#x27;s OK!</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> B  <span class="title">h</span><span class="params">()</span></span>;        <span class="comment">//ERROR! Only applies to pointer and reference types</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为只有通过<strong>指针</strong>或者<strong>引用</strong>才构成Upcast关系嘛，才能够发生多态性（polymorphism）嘛。这点在之前多次提到过了。  </p>
<h4 id="13-7-同时有重载-Overload-和覆盖-Override-："><a href="#13-7-同时有重载-Overload-和覆盖-Override-：" class="headerlink" title="13.7 同时有重载(Overload)和覆盖(Override)："></a>13.7 同时有重载(Overload)和覆盖(Override)：</h4><p>现在父类中有一组<strong>virtual</strong>的<strong>重载</strong>(Overload)函数，如果你覆盖<strong>(Override)</strong>了其中一个，你就必须把所有的重载给覆盖掉，否则依然会发生<strong>名字隐藏</strong>那样的事情。 </p>
<h3 id="14-引用再研究"><a href="#14-引用再研究" class="headerlink" title="14 引用再研究"></a>14 引用再研究</h3><p>在《<strong>引用（Declaring reference）</strong>》一章我们提到过”<strong>引用</strong>作为<strong>成员变量</strong>或者<strong>放在参数表里面</strong>才可以不用给初始值”，而这其中当<strong>引用</strong>作为<strong>成员变量</strong>没有给初始值时我们就<strong>必须（也只能）</strong>在初始化列表里面给出初始值来。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span>&amp; m_y;    <span class="comment">//现在还不知道将来构造X的对象时m_y要与谁建立引用关系，没有办法在声明时给初始值</span></span><br><span class="line">        <span class="built_in">X</span>(<span class="keyword">int</span>&amp; a);              <span class="comment">//构造声明</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">int</span>&amp; a) : <span class="built_in">m_y</span>(a) &#123;&#125;        <span class="comment">//构造定义    </span></span><br></pre></td></tr></table></figure>
<p>我们就必须在初始化列表中建立引用关系，因为如果在大括号{}里面写”m_y = a;”那就是在赋值了（把a赋给m_y所“绑定”的那个变量）。比如下面这样：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>&amp; m_y;    </span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span>&amp; a);                <span class="comment">//构造声明</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">int</span>&amp; a) &#123; m_y = a; &#125;     <span class="comment">//构造定义，会报错ERROR</span></span><br></pre></td></tr></table></figure>
<h4 id="14-1-函数返回引用（Returning-references）："><a href="#14-1-函数返回引用（Returning-references）：" class="headerlink" title="14.1 函数返回引用（Returning references）："></a>14.1 函数返回引用（Returning references）：</h4><p>同返回<strong>指针</strong>，函数也可以返回<strong>引用</strong>，而且也不能返回本地变量的<strong>引用</strong>； </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">double</span> myarray[SIZE];</span><br><span class="line"><span class="function"><span class="keyword">double</span>&amp; <span class="title">subscript</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myarray[i];</span><br><span class="line">    <span class="comment">/*返回第i个元素变量，因为一般会在调用该函数的地方会将该变量“绑定”给别的reference</span></span><br><span class="line"><span class="comment">    就像:</span></span><br><span class="line"><span class="comment">    int f() &#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int a = f();</span></span><br><span class="line"><span class="comment">    这样，我们也可以：</span></span><br><span class="line"><span class="comment">    int&amp; f() &#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int&amp; a = f();</span></span><br><span class="line"><span class="comment">    区别在于int a = f()只是在赋值，而int&amp; a = f()是把f()返回的变量“绑定”给a了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; SIZE; count++) &#123;</span><br><span class="line">        myarray[count] = count + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span>&amp; FirstElement = <span class="built_in">subscript</span>(<span class="number">0</span>);         </span><br><span class="line">    <span class="comment">//把返回值“绑定”给另外一个reference</span></span><br><span class="line">    <span class="keyword">double</span> FirstElement_value = <span class="built_in">subscript</span>(<span class="number">0</span>);    </span><br><span class="line">    <span class="comment">/*把返回的「值」赋给了一个double变量（这个时候发生了&quot;dereference&quot;）。</span></span><br><span class="line"><span class="comment">    很容易理解：引用就是别名嘛，把&quot;引用赋给变量&quot;不就跟&quot;把变量赋给变量&quot;一样的嘛，</span></span><br><span class="line"><span class="comment">    &quot;i = j;&quot;这种事不是经常做嘛，实际上就是传值嘛*/</span></span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FirstElement       =&quot;</span> &lt;&lt; FirstElement &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FirstElement_value =&quot;</span> &lt;&lt; FirstElement &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    FirstElement_value = <span class="number">3.1415926</span>;    <span class="comment">//修改double变量对myarray数组没有影响       </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After modify double myarray[0] = &quot;</span> &lt;&lt; myarray[<span class="number">0</span>] &lt;&lt; endl;   </span><br><span class="line">    FirstElement = <span class="number">2.7182818</span>;          <span class="comment">//修改引用的值即修改被引用者的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After modify double&amp; myarray[0]= &quot;</span> &lt;&lt; myarray[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码没有演示返回引用的函数作”左值”的情况，感兴趣的小伙伴可以自己试一试（比如subscript(7) = 2.58;）。因为函数返回reference，所以返回的reference可以作为变量来使用。  </p>
<h4 id="14-2-Const-reference-parameters"><a href="#14-2-Const-reference-parameters" class="headerlink" title="14.2 Const reference parameters"></a>14.2 Const reference parameters</h4><p>在上半部分学习笔记的《Const》一章中我们说过：</p>
<p>“对一个函数传进传出整个对象时可能会造成很大的开销，往往更好的办法是传一个地址。但是传地址我们又会很不放心别人会不会通过指针修改我们的原始数据。这个时候，const修饰指针的作用就来了。我们在前面加上 const 表明我们以一个const的方式传一个对象进去，这样就可以保证我们的数据是安全的。”</p>
<p>现在我们有了引用（reference），我们可以选择用更好的reference，因为reference意味着我们就可以不用在那个函数里面用很多”*”号了，这也是C++开发工作中更推荐的。 </p>
<h5 id="14-2-1-中间结果是const（Temporary-values-are-const）"><a href="#14-2-1-中间结果是const（Temporary-values-are-const）" class="headerlink" title="14.2.1 中间结果是const（Temporary values are const）"></a>14.2.1 中间结果是const（Temporary values are const）</h5><p>我们先来看下下面这段代码： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="built_in">func</span> (i * <span class="number">3</span>);    <span class="comment">//ERROR：无法将参数从&quot;int&quot;转换为&quot;int &amp;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//我们都知道reference必须能做左值，显然i*3不能作左值，当然报错</span></span><br></pre></td></tr></table></figure>
<p>还有种解释是编译器在编译时会生成下面这样的代码： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> tmp@ = i * <span class="number">3</span>;    <span class="comment">//编译器产生了const int的临时变量tmp@</span></span><br><span class="line"><span class="built_in">func</span>(tmp@);                <span class="comment">//因为tmp@是const，就不能传给int &amp;（const不能作左值嘛）</span></span><br></pre></td></tr></table></figure>
<p>那现在我们修改函数的参数为const reference parameter，试试看能不能把<code>tmp@</code>传进去：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">f</span>(i * <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有报错可以正常运行，验证了第二种解释。 </p>
<h5 id="14-2-2-函数返回值有const（const-in-Function-returns）"><a href="#14-2-2-函数返回值有const（const-in-Function-returns）" class="headerlink" title="14.2.2 函数返回值有const（const in Function returns）"></a>14.2.2 函数返回值有const（const in Function returns）</h5><p><strong>（一）函数return了一个const value</strong></p>
<ul>
<li>对于用户定义类型，这意味着“防止作为左值使用”（现代的编译器貌似不用加const都不能作左值了，详见下面的代码）；</li>
<li>对于内置的，它没有任何意义（就像int f()，我们都知道实质上返回的是值，而不是一个变量。值本来就不能作左值，const int f()就无意义了）；</li>
</ul>
<p>我们来测试一些返回用户定义类型的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A b;</span><br><span class="line">	<span class="comment">//f().i = 10;		//ERROR：表达式必须是可修改的左值</span></span><br><span class="line">	<span class="comment">/*上面这句代码理论上应该是行得通的，可能是Visual Studio的编译器现在不允许这种行为了吧*/</span></span><br><span class="line"> </span><br><span class="line">	b.i = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">f</span>() = b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now f().i = &quot;</span> &lt;&lt; <span class="built_in">f</span>().i &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now b.i = &quot;</span> &lt;&lt; b.i &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哦哟，这很奇怪哦，我们明明做了<strong>f() = b</strong>这件事，但是<strong>f().i</strong>好像没啥变化啊？是不是因为局部变量的关系呢？我们在上面代码的基础上加一些监测然后调试试一下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;Now in A::A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Now in A::~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After A a&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After A b&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//f().i = 10;		//ERROR：表达式必须是可修改的左值</span></span><br><span class="line">	<span class="comment">/*上面这句代码理论上应该是行得通的，可能是Visual Studio的编译器现在不允许这种行为了吧*/</span></span><br><span class="line"> </span><br><span class="line">	b.i = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">f</span>() = b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After f() = b;&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now f().i = &quot;</span> &lt;&lt; <span class="built_in">f</span>().i &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now b.i = &quot;</span> &lt;&lt; b.i &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6762291bd0e0a243d4e597b0.png"></p>
<p>当你一步步地调试时，你就可以发现：<strong>f()确实返回了一个对象，在return语句执行时会去析构局部变量a，所以这个时候显然返回的不是a对象本身了，现在我们推测函数返回的是一个a的”副本”，而且此时我们并不知道这个”副本”变量的名字和地址</strong>。</p>
<p>然后程序继续执行”f() = b;”这句代码，此刻这个”副本”变量还没有被析构（通过调试过程看得出来），而<strong>显然我们没有办法去访问到这个返回的对象的任何东西，因为此时我们并不知道这个”副本”变量的名字和地址</strong>。换句话说，没有任何人知道”副本”在哪，没有人此刻掌握着”它”。<br>所以”它”就不存在了，”它”消失了。这句话好像有点哲学哈，我们可以理解为“当世界上没有任何一个人能够观察到你的存在时，你是否还真的存在于这个世界上呢？”Think about it！<br>所以在程序执行完”f() = b;”后，这个”副本”对象也被一起<strong>析构</strong>了，所以发生了我们目前还无法理解的”两次析构被调用”。<br>感兴趣的小伙伴可以构造一个A的对象来掌握返回的那个”副本”对象。这样就直到 掌握着那个”副本”的 对象的 生命周期结束才会调用析构了。比如”A c =  f();        c = b;”。<br>这一段实际发生的事情涉及到马上要讲的《拷贝构造（Copy the structure）》，所以现在不理解也不必担心。 </p>
<p><strong>（二）函数return一个const pointer or reference</strong> </p>
<p>这取决于你期望使用你的类的人会拿着这个返回结果做啥 </p>
<p>在14.1函数返回引用（Returning references）小节开头我们就说”函数不能把本地变量作引用给返回”，但其实我们可以尝试下做这种”邪恶”的事情的，编译器不会报错。<br>下面举一些返回引用的代码例子，这段代码推荐除main函数内的内容以外全部复制进你的IDE内，然后自行测试你能想象到的所有可能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;Now in A::A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Now in A::~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i;    <span class="comment">//全局变量i</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i;            <span class="comment">//返回全局变量的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">ff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = i;</span><br><span class="line">	<span class="keyword">return</span> a;            <span class="comment">//返回本地变量的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i;            <span class="comment">//返回全局变量的引用且是const的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">A&amp; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">return</span> a;            <span class="comment">//返回本地对象变量的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">A b;    <span class="comment">//全局对象变量b；</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> A&amp; <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;            <span class="comment">//返回全局对象变量的引用且是const的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>() = <span class="number">4</span>;        <span class="comment">//我们知道引用和被引用者是一个东西嘛，所以这和 i = 4; 没有区别</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="built_in">f</span>();	<span class="comment">//这和int j = i;没有区别</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;j=&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;return of f()	=&quot;</span> &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl;	</span><br><span class="line">	<span class="comment">//和直接打印全局变量i没有区别，因为f()函数就是拿全局变量i的引用返回的；</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">ff</span>() = <span class="number">44</span>;</span><br><span class="line">	<span class="comment">/*但是返回本地变量的引用就有问题了，因为本地变量的生存周期只有函数内部，</span></span><br><span class="line"><span class="comment">    所以这样的引用实际上是非法的，不过编译器仍然通过了*/</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;return of ff()	=&quot;</span> &lt;&lt; <span class="built_in">ff</span>() &lt;&lt; endl;		</span><br><span class="line">    <span class="comment">//作为一个不存在的变量的引用，它的值当然是不确定的</span></span><br><span class="line">	<span class="comment">//g() = 5;		//返回全局变量的引用是const时编译器则不允许修改其值了</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">h</span>().i = <span class="number">6</span>;</span><br><span class="line">	<span class="comment">//当然返回本地对象变量的引用也存在同样的问题，在退出h()函数时本地对象会被析构</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;h().i=&quot;</span> &lt;&lt; <span class="built_in">h</span>().i &lt;&lt; endl;	</span><br><span class="line">	<span class="comment">/*这里是第二次调用h()了，看似我们是在返回h().i = 6; 的h().i，</span></span><br><span class="line"><span class="comment">    实际上会重新构造本地对象，然后退出时析构；</span></span><br><span class="line"><span class="comment">	而作为已经被析构掉的本地对象变量的引用，它的成员变量i的值同样是不确定的。</span></span><br><span class="line"><span class="comment">	这个时候我们可能会问了：我们构造一个新的对象来掌握h()返回的那个引用呢？就像下面这样：*/</span></span><br><span class="line">	A aa = <span class="built_in">h</span>();</span><br><span class="line">	aa.i = <span class="number">66</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;aa.i=&quot;</span> &lt;&lt; aa.i &lt;&lt; endl;</span><br><span class="line">	<span class="comment">/*好像没有问题了哈？可h()显然是多余的呀，直接A aa;	aa.i = 66;不就可以了吗？*/</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//m().i = 7;		//返回全局对象的引用则不能通过引用修改值</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b.i=&quot;</span> &lt;&lt; b.i &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/67622ba8d0e0a243d4e597f3.png"></p>
<p>如果函数返回在函数中创建的临时对象（别忘了一切事物皆是对象），则不要使用引用。因为当函数结束时，临时对象将消失，因此这种引用是非法的。这点我们在5.1小节《函数返回引用（Returning references）》开篇就提到了；<br>如果函数返回本地对象的引用我们还把它交给了另外一个引用时，这是非常非常危险的行为！！因为那个引用会成为不存在的对象的引用，引用指向的那块内存是没有人在使用的内存即”空闲内存”，而空闲内存是随时都可能有人会用的！也就是说我们随时可能在不经意间使用该引用破坏了别人的内存！下面举一个简单例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;j	=&quot;</span> &lt;&lt; &amp;j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>&amp; r = <span class="built_in">f</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;r	=&quot;</span> &lt;&lt; &amp;r &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">g</span>();	</span><br><span class="line">	<span class="comment">/*我们知道本地变量放在堆栈区（stack），f()执行完后它的本地变量i消失了；</span></span><br><span class="line"><span class="comment">	而g()的本地变量j就会被存放在i刚刚存放的位置*/</span> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是全局对象作引用并返回时，const的作用和之前一样是告诉编译器”禁止用户使用返回的引用去修改其值”；<br>以上三点在函数返回指针时也是一样的（在《引用（Declaring reference）》一章里我们说过”引用本质上就是个const指针（<code>int *const p</code>，可以理解为引用r就是那个<code>*p</code>）”嘛）；</p>
<p>如果上面”return by const pointer or reference”讲过的内容还是不好理解的话，也不要钻牛角尖了。这件事情不要想麻烦了，归根结底就两件事：</p>
<p>① 函数肯定不能返回本地的对象嘛（不管是返回本地变量本身 or 本地变量作为引用并返回 or 本地变量的地址），这是非法的，这一点毋庸置疑，我们在5.1小节《函数返回引用（Returning references）》开篇就提到了；<br>② 如果是返回全局对象的引用或指针且是const的，那这就和我们之前理解的作用是一样的：都是在告诉编译器”禁止通过返回的这个引用或指针去改变全局对象的内容”； </p>
<h3 id="15-拷贝构造（Copy-the-structure）"><a href="#15-拷贝构造（Copy-the-structure）" class="headerlink" title="15 拷贝构造（Copy the structure）"></a>15 拷贝构造<strong>（Copy the structure）</strong></h3><p>我们做一个函数<code>func(A a)</code>，函数的参数是一个A的对象(不是引用或指针哦)。然后我们构造一个A的对象aa，然后调用func时把aa给它…… </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a.i = &quot;</span> &lt;&lt; a.i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">A aa;</span><br><span class="line"><span class="built_in">func</span>(aa);    <span class="comment">//aa is copied into a</span></span><br></pre></td></tr></table></figure>
<p>现在我们都知道a是func里面的对象，和外面的aa是没有关系的，在调用时会直接把a拷贝一份到堆栈里。那么这个时候到底发生的是： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A a = aa;    <span class="comment">//初始化（Initialization） </span></span><br></pre></td></tr></table></figure>
<p>还是 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = aa;     <span class="comment">//赋值（Assignment）</span></span><br></pre></td></tr></table></figure>
<p>呢？在C++这两种有什么区别？（在C++这两件事会有很大区别的，这个往后学会逐渐了解的） </p>
<p>还记得在14.2.2 函数返回值有const小节发生了一件当时我们无法理解的事情吗：”调用了两次<strong>析构函数</strong>“。这其实还不算夸张的，下面来个更夸张的： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ObjectCount = <span class="number">0</span>;    <span class="comment">//对象计数器</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; </span><br><span class="line">		ObjectCount++;	</span><br><span class="line">		<span class="comment">//在之前学习中我们知道每构造一个A的对象就会调用一次构造函数，所以我们让对象计数器++	</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in A::A(), ObjectCount  = &quot;</span> &lt;&lt; ObjectCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	~<span class="built_in">A</span>() &#123;</span><br><span class="line">		ObjectCount--;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in A::~A(), ObjectCount = &quot;</span> &lt;&lt; ObjectCount &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now in func(A a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A aa;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After construct aa&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">func</span>(aa);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After func(aa)&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	A a = aa;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After A a = aa&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/67622dd6d0e0a243d4e5985b.png"></p>
<p>可以看到对象计数器直接给弄成-3了，程序好像只调用了一次构造却调用了4次析构？因此我们居然好像”欠”了程序3个对象？而且<code>A a = aa</code>这句代码好像没有构造就结束了？</p>
<p>先来研究<code>A a = aa</code>，我们先来看看如果加一个带参构造函数再来构造一些对象是否会正常调用构造函数： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ObjectCount = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;</span><br><span class="line">		ObjectCount++;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in A::A(), ObjectCount  = &quot;</span> &lt;&lt; ObjectCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">		ObjectCount++;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in A::A(int i), ObjectCount  = &quot;</span> &lt;&lt; ObjectCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">		ObjectCount++;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in A::A(const A&amp; a), ObjectCount  = &quot;</span> &lt;&lt; ObjectCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	~<span class="built_in">A</span>() &#123;</span><br><span class="line">		ObjectCount--;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in A::~A(), ObjectCount = &quot;</span> &lt;&lt; ObjectCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A aa;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After construct a&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	A a = aa;</span><br><span class="line">    <span class="comment">/*当a类只有默认构造函数的时候，我们知道这句代码好像没有正常去调用A的默认构造函数；</span></span><br><span class="line"><span class="comment">    但现在我们有一个接受A的对象的const引用的带参构造函数，</span></span><br><span class="line"><span class="comment">    (其实构造函数参数是A* a也可以，初始化就得换成A a = &amp;aa;)</span></span><br><span class="line"><span class="comment">    是否能够捕捉到A a = aa这个过程中的初始化呢？*/</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After A a = aa&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="function">A <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After A b(10)&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	A c = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">/*tips：在C++用圆括号或者等号初始化变量是等价的，也就是说这句等价于&quot;A c(20)&quot;</span></span><br><span class="line"><span class="comment">	尽管这看起来像是在把一个整数赋给一个对象，类型不匹配不能就这么等起来；</span></span><br><span class="line"><span class="comment">	但由于A有个要1个int的带参构造函数，所以这么写是可以的*/</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After A c = 20&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/67622e23d0e0a243d4e59868.png"></p>
<p>可以看到，通过新增一个接受A的对象的const引用的带参构造函数，我们成功捕获到了<strong>A a = aa;</strong>的初始化过程。在这基础上感兴趣的同学还可以把第一段代码里的<strong>func()</strong>加到第二段代码里去，你会发现<strong>func()</strong>也能正常调用相应的构造函数了： </p>
<p><img src="https://pic.imgdb.cn/item/67622ea7d0e0a243d4e59889.png"></p>
<p>以上内容了解完后我们可以做总结了：</p>
<p>如果你有一个构造函数的参数是自己类型的const引用，这种构造函数就会在我们用另外一个该类的对象来初始化某个该类的对象（比如A a = aa;还有仅看func()函数的参数表和调用时传的内容，其实发生的也是A a = aa;嘛）时被调用。这样的一个构造函数我们用一个特殊的名字——“拷贝构造”，来称呼它。拷贝构造有如下特点：</p>
<ul>
<li>形式唯一：<code>T::T(const T&amp;)</code> </li>
<li>你可以使用自己写的拷贝构造函数来决定哪些要拷贝，哪些不用，或者完成一些特殊操作；</li>
<li>如果你没有提供拷贝构造，C++会自己提供一个，而且它会： <ul>
<li>拷贝每一个成员（不是简单的一个字节by一个字节地拷贝）；（因为如果成员变量中有其他对象，它会让那个类的拷贝构造来拷贝那个对象）</li>
<li>拷贝每一个指针，当然引用也是； </li>
</ul>
</li>
</ul>
<p>正因为本章开始那段代码我们没有提供自己写的拷贝构造，C++会自己提供一个然后去构造；我们才会看到只调用了1次我们的默认构造函数却调用了4次析构。背后发生的事情就是程序还调用了3次自动提供的拷贝构造，只是我们当时不知道而已；<br>上面说自动提供的那个拷贝构造会去拷贝每一个指针，那显然新的对象里的指针会和老的对象里的指针是相同的，我们来验证一下这件事： </p>
<p><a href="https://blog.csdn.net/YMGogre/article/details/126759839">「面向对象程序设计-C++」学习笔记（上半部分）- YMGogre - CSDN</a><br><a href="https://blog.csdn.net/YMGogre/article/details/126952858">「面向对象程序设计-C++」学习笔记（下半部分）- YMGogre - CSDN</a></p>
<h3 id="N-什么时候该写函数，什么时候该写类"><a href="#N-什么时候该写函数，什么时候该写类" class="headerlink" title="N. 什么时候该写函数，什么时候该写类"></a>N. 什么时候该写函数，什么时候该写类</h3><h4 id="N-1-理论上的基本规则"><a href="#N-1-理论上的基本规则" class="headerlink" title="N.1 理论上的基本规则"></a>N.1 理论上的基本规则</h4><p>把重复的代码写成单独的函数，如果有许多重复顺序的函数调用，就再组织成一个函数。<strong>如果这些函数有共同的数据，可组织成一个类。（其实数据才是灵魂，函数本身是空洞无物的，是表象、外在接口和服务工具。调用Winapi看上去可以立即实现某些功能，实际上也是这个函数修改了OS的内部数据才实现了相应的功能）</strong> 。</p>
<p>转载于:<a href="https://www.cnblogs.com/alleyonline/p/4679219.html">https://www.cnblogs.com/alleyonline/p/4679219.html</a> </p>
<h4 id="N-2-类和函数傻傻分不清楚？三个例子讲明白"><a href="#N-2-类和函数傻傻分不清楚？三个例子讲明白" class="headerlink" title="N.2 类和函数傻傻分不清楚？三个例子讲明白"></a>N.2 类和函数傻傻分不清楚？三个例子讲明白</h4><h5 id="N-2-1-前言"><a href="#N-2-1-前言" class="headerlink" title="N.2.1 前言"></a>N.2.1 前言</h5><p>前两天一位小伙伴问了这样一个问题：虽然已经使用python一年多了，也用python写过很多脚本，代码量从几十行到上千行的也有，但从未使用过类(class)，似乎用函数(def)就能解决所有问题，使用类有什么好处？我什么时候该用类呢？</p>
<p>关于这个问题，算是困惑了许多刚接触python的同学，那么本文就尝试从多个角度来解读这个问题。首先还是先来看看官方给出类与函数的解释。</p>
<p><strong>类提供了一种组合数据和功能的方法</strong>。 创建一个新类意味着创建一个新的对象类型，从而允许创建一个该类型的新实例 。每个类的实例可以拥有保存自己状态的属性。 一个类的实例也可以有改变自己状态的（定义在类中的）方法。</p>
<p><strong>函数的本质就是一段有特定功能、可以重复使用的代码</strong>，这段代码已经被提前编写好了，并且为其起一个“好听”的名字。在后续编写程序过程中，如果需要同样的功能，直接通过起好的名字就可以调用这段代码。</p>
<p>很显然，这样的答案并没有让人搞明白类和函数到底不一样在哪里。但是里面提到了类是创建一个对象，所以类是面向对象程序设计(Object Oriented Programming)。也就是我们常说的OOP。而OOP高度关注的是代码的组织，可重用性和封装。</p>
<h5 id="N-2-2-第一个例子"><a href="#N-2-2-第一个例子" class="headerlink" title="N.2.2 第一个例子"></a>N.2.2 第一个例子</h5><p>上面的官方解释上去还是很抽象，那么我们开始说人话。简单来说当Python中没有可以完全表达我们要表示的内容的数据类型时，那么就需要使用一个类。来看下面的例子。</p>
<p>若计算某人的年龄，则只需使用<code>int</code>，因为它可以满足我的需求。如果我们需要在游戏中表示像敌人之类的东西，则可以创建一个类则可以创建一个类Enemy，其中包含诸如health和armor的数据，并包含诸如fire_weapon射击时的功能。然后，我们还可以创建另一个类FlyingEnemy，Enemy该类从该类继承所有内容，但又具有一个fly方法，因此具有其他功能。</p>
<h5 id="N-2-3-第二个例子"><a href="#N-2-3-第二个例子" class="headerlink" title="N.2.3 第二个例子"></a>N.2.3 第二个例子</h5><p>我们再来看一个例子。假设我们需要编写一个音乐播放器。在这个播放器中，我们有关于不同类型数据的信息，如歌曲、专辑、艺术家和播放列表。还有一些可以播放歌曲、播放专辑、播放艺术家或播放播放列表的功能。我们将每种数据存储在字典中，不同类型的数据有不同的字段名，因为每个play_xxxx函数需要做不同的事情，所以我们就有四个不同的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_song = &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Yellow Submarine&quot;</span>,</span><br><span class="line">    <span class="string">&quot;artist&quot;</span>: the_beatles, <span class="comment"># 指向到包含该艺术家的词典</span></span><br><span class="line">    <span class="string">&quot;album&quot;</span>: yellow_submarine_album, <span class="comment"># 指向包含此相册的dict的链接</span></span><br><span class="line">    <span class="string">&quot;duration&quot;</span>: insert_time_object_here,</span><br><span class="line">    <span class="string">&quot;filepath&quot;</span>: <span class="string">&quot;path/to/file/on/disk&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 其他数据类型的结构也类似</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 一些函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_song</span>(<span class="params">song</span>):</span></span><br><span class="line">    <span class="comment"># 获取歌的路径</span></span><br><span class="line">    path = song[<span class="string">&quot;filepath&quot;</span>]</span><br><span class="line">    <span class="comment"># 播放路径</span></span><br><span class="line">    call_some_library_function(path)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_album</span>(<span class="params">album</span>):</span></span><br><span class="line">    <span class="comment"># 找到专辑里所有的歌曲</span></span><br><span class="line">    <span class="comment"># 分别调用play_song</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_artist</span>(<span class="params">artist</span>):</span></span><br><span class="line">    <span class="comment"># 找到这位艺术家所有的专辑</span></span><br><span class="line">    <span class="comment"># 分别调用play_album</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_playlist</span>(<span class="params">playlist</span>):</span></span><br><span class="line">    <span class="comment"># 找到播放列表中的所有歌曲</span></span><br><span class="line">    <span class="comment"># 分别调用play_song</span></span><br></pre></td></tr></table></figure>
<p>这样写有什么不好？我们有四个非常相似的函数，每个函数都与特定类型的数据相关。你必须把它们叫做不同的东西，而不仅仅是play，你必须确保你把正确的数据传递给它们。虽然这四种不同的类型都可以“播放”，但是没有一种通用的方法可以在不知道它是什么的情况下播放任何东西。</p>
<p>那么在OOP下，怎么实现呢：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Song</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, title, artist, album, duration, filepath</span>):</span></span><br><span class="line">        self.title = title</span><br><span class="line">        self.artist = artist</span><br><span class="line">        self.album = album</span><br><span class="line">        self.duration = duration</span><br><span class="line">        self.filepath = filepath</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">self</span>):</span></span><br><span class="line">        path = self.filepath</span><br><span class="line">        call_some_library_function(path)</span><br></pre></td></tr></table></figure>
<p>这样就定义了如何创建一个新的Song对象。该方法将字段值作为参数，并将它们作为对象的属性赋值。self是一个特殊参数(名称不保留;它可以被称为任何东西)，它是对对象本身的引用。是一种从同一对象的其他方法内部访问属性和方法的方法。当我们从对象外部访问它们时（要使用play方法时将执行此操作），则可以使用在该范围内为对象指定的任何名称。</p>
<p>那么在定义class之前 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># some_song是上面定义的歌</span></span><br><span class="line">play_song(some_song)</span><br></pre></td></tr></table></figure>
<p>在使用class之后： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># self参数没有在这里传递;它会自动添加</span></span><br><span class="line">some_song = Song(<span class="string">&quot;Yellow Submarine&quot;</span>,</span><br><span class="line">                the_beatles,</span><br><span class="line">                yellow_submarine_album,</span><br><span class="line">                insert_time_object_here,</span><br><span class="line">                <span class="string">&quot;path/to/file/on/disk&quot;</span></span><br><span class="line">            )</span><br><span class="line">some_song.play()</span><br></pre></td></tr></table></figure>
<p>为什么这样更好？如果我们有一个对象，则不必知道它是什么就可以播放，因为现在播放任何内容的语法都是相同的：<code>anyobject.play()</code>，即对象“知道”如何使用“自己的”数据进行处理的设计思想。无需从外部检查对象是否具有某些字段并决定如何处理这些内部字段，而是调用play对象提供的方法，并在每个类内部定义该类型的对象应如何实现此功能。</p>
<h5 id="N-2-4-第三个例子"><a href="#N-2-4-第三个例子" class="headerlink" title="N.2.4 第三个例子"></a>N.2.4 第三个例子</h5><p>我们继续看下面两段代码来实现输出一些学生的成绩，<strong>首先是使用类</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender, level, grades=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.level = level</span><br><span class="line">        self.grades = grades <span class="keyword">or</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setGrade</span>(<span class="params">self, course, grade</span>):</span></span><br><span class="line">        self.grades[course] = grade</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getGrade</span>(<span class="params">self, course</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.grades[course]</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getGPA</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(self.grades.values())/<span class="built_in">len</span>(self.grades)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义一些学生</span></span><br><span class="line">john = Student(<span class="string">&quot;John&quot;</span>, <span class="number">12</span>, <span class="string">&quot;male&quot;</span>, <span class="number">6</span>, &#123;<span class="string">&quot;math&quot;</span>:<span class="number">3.3</span>&#125;)</span><br><span class="line">jane = Student(<span class="string">&quot;Jane&quot;</span>, <span class="number">12</span>, <span class="string">&quot;female&quot;</span>, <span class="number">6</span>, &#123;<span class="string">&quot;math&quot;</span>:<span class="number">3.5</span>&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 现在我们可以很容易地得到分数</span></span><br><span class="line"><span class="built_in">print</span>(john.getGPA())</span><br><span class="line"><span class="built_in">print</span>(jane.getGPA())</span><br></pre></td></tr></table></figure>
<p>再来看看用函数怎么实现：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateGPA</span>(<span class="params">gradeDict</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(gradeDict.values())/<span class="built_in">len</span>(gradeDict)</span><br><span class="line"> </span><br><span class="line">students = &#123;&#125;</span><br><span class="line">name, age, gender, level, grades = <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="string">&quot;level&quot;</span>, <span class="string">&quot;grades&quot;</span></span><br><span class="line">john, jane = <span class="string">&quot;john&quot;</span>, <span class="string">&quot;jane&quot;</span></span><br><span class="line">math = <span class="string">&quot;math&quot;</span></span><br><span class="line">students[john] = &#123;&#125;</span><br><span class="line">students[john][age] = <span class="number">12</span></span><br><span class="line">students[john][gender] = <span class="string">&quot;male&quot;</span></span><br><span class="line">students[john][level] = <span class="number">6</span></span><br><span class="line">students[john][grades] = &#123;math:<span class="number">3.3</span>&#125;</span><br><span class="line"> </span><br><span class="line">students[jane] = &#123;&#125;</span><br><span class="line">students[jane][age] = <span class="number">12</span></span><br><span class="line">students[jane][gender] = <span class="string">&quot;female&quot;</span></span><br><span class="line">students[jane][level] = <span class="number">6</span></span><br><span class="line">students[jane][grades] = &#123;math:<span class="number">3.5</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(calculateGPA(students[john][grades]))</span><br><span class="line"><span class="built_in">print</span>(calculateGPA(students[jane][grades]))</span><br></pre></td></tr></table></figure></p>
<p>这两段代码都实现了输出学生的成绩，但是在使用函数的时候，我们需要记住学生是谁，成绩存储在哪里，似乎不是很困难(如果需要输出的学生更多呢)，但是OOP避免了这一点。并且代码也更加pythonic。</p>
<h5 id="N-2-5-结束语"><a href="#N-2-5-结束语" class="headerlink" title="N.2.5 结束语"></a>N.2.5 结束语</h5><p>最后，让我们回到刚开始的问题上来，上面说了这么多类的好处所以我们就应该更多的去使用类吗？并不是！</p>
<p>其实从某种意义上来说，类并不比函数更好。只是在某些情况下使用类能够更好的帮助我们写代码。所以如果发现自己使用各种数据集调用some_function(data)，那么将其用类表示为data.some_function()可能提高我们的效率。至于到底在何时使用类，我们来看看其他程序员的理解：</p>
<ul>
<li>当我们拥有一堆共享状态的函数，或者将相同的参数传递给每个函数时，我们可以重新考虑代码使用类。</li>
<li>类的“可重用性”意味着我们可以在其他应用程序中重用之前的代码。如果我们在自己的文件中编写了类，则只需将其放在另一个项目中即可使其工作。</li>
<li>函数对于小型项目非常有用，但是一旦项目开始变大，仅使用函数就可能变得混乱。类是组织和简化代码的一种非常好的方法</li>
<li>通常，如果在函数内部找到自写函数，则应考虑编写类。如果我们在一个类中只有一个函数，那么请坚持只写一个函数。</li>
<li>如果需要在函数调用之间保留一些状态，那么最好使用带有该函数的类作为方法</li>
</ul>
<p>原文链接：<a href="https://blog.csdn.net/weixin_41846769/article/details/104892293">https://blog.csdn.net/weixin_41846769/article/details/104892293</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>编程与深度学习</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>面向对象编程</tag>
      </tags>
  </entry>
</search>
