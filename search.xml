<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Basic-concepts-of-radar</title>
    <url>/2022/01/25/Basic-concepts-of-radar/</url>
    <content><![CDATA[<h3 id="一、雷达距离fft-多普勒fft"><a href="#一、雷达距离fft-多普勒fft" class="headerlink" title="一、雷达距离fft+多普勒fft"></a>一、雷达距离fft+多普勒fft</h3><p>参考链接：</p>
<p>[1-1]TI毫米波雷达系列（三）：调频连续波雷达回波信号3DFFT处理原理（测距、测速、测角）<a href="https://blog.csdn.net/qq_35605018/article/details/108816709">https://blog.csdn.net/qq_35605018/article/details/108816709</a></p>
<p>[1-2]距离-多普勒谱(RD谱)之二：距离相关 <a href="https://blog.csdn.net/mddh_123/article/details/109152790">https://blog.csdn.net/mddh_123/article/details/109152790</a></p>
<p>[1-3]干货 | 利用MATLAB实现FMCW雷达的距离多普勒估计 <a href="https://www.jianshu.com/p/d2d865da6dce">https://www.jianshu.com/p/d2d865da6dce</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>雷达信号处理</category>
      </categories>
      <tags>
        <tag>雷达基础</tag>
      </tags>
  </entry>
  <entry>
    <title>概率基础概念本质的辨析理解</title>
    <url>/2022/01/24/Basic-concept-of-probability/</url>
    <content><![CDATA[<h3 id="〇、如何学好概率论与数理统计"><a href="#〇、如何学好概率论与数理统计" class="headerlink" title="〇、如何学好概率论与数理统计"></a>〇、如何学好概率论与数理统计</h3><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h4><p>[0-1]如何学好概率论与数理统计 <a href="http://www.hanhai.org/xuexijiaoliu/26.htm">http://www.hanhai.org/xuexijiaoliu/26.htm</a></p>
<p>[0-2]怎样学习大学概率论与数理统计？ - 石溪的回答 - 知乎 <a href="https://www.zhihu.com/question/36833473/answer/862307409">https://www.zhihu.com/question/36833473/answer/862307409</a> </p>
<h3 id="一、什么是概率"><a href="#一、什么是概率" class="headerlink" title="一、什么是概率"></a>一、什么是概率</h3><p><font color="red"><strong>用两个字来表述概率的本质——函数</strong></font></p>
<p><font color="red"><strong>用四个字来表述概率的本质——集合函数，集合到$[0, 1]$区间的映射</strong></font></p>
<h4 id="1-概率公理化定义"><a href="#1-概率公理化定义" class="headerlink" title="1. 概率公理化定义"></a>1. 概率公理化定义</h4><p>定义在事件域$ \mathscr{F} $上的集合函数$P$称为概率，它需要满足下面这三个要求：</p>
<p>​    (1) 非负性：$P(A) \geq 0, ~ \forall A \subset   \mathscr{F}$</p>
<p>​    (2) 规范性/正则性：$P(\Omega) = 1$</p>
<p>​    (3) 可列可加性：若$ A_i \subset  \mathscr{F}, ~ i = 1,2,…$，且两两互不相容，则<br>$$<br>P(\sum_{i=1}^{\infty}A_i) = \sum_{i=1}^{\infty}P(A_i)<br>$$<br>​        或者写作<br>$$<br>P(\mathop{\bigcup}\limits_{i=1}^{\infty}A_i) = \sum_{i=1}^{\infty}P(A_i)<br>$$</p>
<h4 id="2-名词解释"><a href="#2-名词解释" class="headerlink" title="2. 名词解释"></a>2. 名词解释</h4><h5 id="2-1-样本空间"><a href="#2-1-样本空间" class="headerlink" title="2.1 样本空间"></a>2.1 样本空间</h5><p>$\Omega = $ { $  \omega_1, \omega_2,…, \omega_n $ }，其中$\omega_n$称为样本点，比如掷硬币则$\Omega =$ { $  “正面”, “反面” $}，掷骰子则$\Omega =${ $  “1点”, “2点”, “3点”, “4点”, “5点”, “6点” $} </p>
<h5 id="2-2-事件"><a href="#2-2-事件" class="headerlink" title="2.2 事件"></a>2.2 事件</h5><p>样本点的某个集合，比如掷骰子中{$1$}、{$2$} 或者{$2, 3, 5$}等所有可能的组合，事件可以看成$\Omega$的某个子集。</p>
<p>根据以上，我们可以称$\Omega$为必然事件，$\varnothing $是不可能事件。</p>
<h5 id="2-3-事件域"><a href="#2-3-事件域" class="headerlink" title="2.3 事件域"></a>2.3 事件域</h5><p>为了方便展示例子，我们这里将掷骰子的正六面体改为正四面体，也就是此时$\Omega =$ { $1, 2, 3, 4 $}，此时它所有的子集(可能的事件)为：</p>
<center>$A_1 = \varnothing$, $ A_2 = $ { $1$ }, $A_3 = $ { $2$ }, $A_4 = $ {$3$}, $A_5 =$ {$4$}, $ A_6 = ${$1, 2$}</center>

<center>$A_7 = ${$1, 3$}, $A_8 = ${$1,4$}, $ A_9 = ${$2, 3$}, $A _ {10} =$ {$2, 4$}, $A _ {11} =$ {$3, 4$}</center>

<center>$A _ {12} = ${$1, 2, 3$}, $A _ {13} = ${$1, 2, 4$}, $A _ {14} = ${$2, 3, 4$}, $A _ {15} = ${$1, 3, 4$}, $ A _ {16} = \Omega = ${$1, 2, 3 ,4$} </center>

<p>事件域就是$\mathscr{F} = $ { $A_1, A_2, …, A _ {16}$}是由样本空间$\Omega$的一些子集构成的一个$\sigma$域。$\mathscr{F}$中的元素被称为事件。</p>
<h5 id="2-4-σ域"><a href="#2-4-σ域" class="headerlink" title="2.4 σ域"></a>2.4 σ域</h5><p>事件域$\mathscr{F}$必须是$\sigma$域，那么什么样的$\mathscr{F}$在$\sigma$域中呢：</p>
<p>​    (1) $\Omega \subset \mathscr{F}$；</p>
<p>​    (2) 若$A \subset \mathscr{F}$，则$\bar A \in \mathscr{F}$；</p>
<p>​    (3) 若$A_i \subset \mathscr{F},~(i = 1,2,…)$ ，则$\mathop{\bigcup}\limits_{i=1}^{\infty}A_i \subset \mathscr{F} $。</p>
<p>由上面3条我们可以进一步推导得到：</p>
<p>​    1° $\varnothing \subset \mathscr{F} $</p>
<p>​    2° 交集属于事件域——$\mathop{\bigcap}\limits_{i=1}^{\infty}A_i = \overline {\mathop{\bigcup}\limits_{i = 1}^{\infty}\bar{A_i}} $</p>
<p>​    3° 有限并属于事件域</p>
<p>​    4° 有限交属于事件域</p>
<p>例如$\mathscr{F}_1 =$ { $A_1, A_2, …, A _ {16}$ }，$\mathscr{F}_2 =$ { $A_1, A _ {16}, A_2, A _ {14}$ }，$\mathscr{F}_3 =$ { $A_1,  A _ {16}$ } 等都是事件域(都满足上面3条)，其中$\mathscr{F}_3 $是最简单的事件域(一个事件域最少由空集和样本空间这两个集合组成)，又称平凡事件域。</p>
<h5 id="2-5-事件域和样本空间辨析"><a href="#2-5-事件域和样本空间辨析" class="headerlink" title="2.5 事件域和样本空间辨析"></a>2.5 事件域和样本空间辨析</h5><p><strong>事件域是样本空间幂集的子集。也就是说，事件域中的每个元素是样本空间的一个子集。</strong>例如，掷骰子，样本空间取 A={1,2,3,4,5,6}，事件域可以取上述集合的全部子集，即$F=2^A$。此时F中的元素称为事件。例如，“掷出偶数”指的是F中的{2,4,6}这一元素。顺便一提：</p>
<p><font color="red"><strong>概率本质是定义在事件域上的函数，而随机变量本质是定义在样本空间上的函数。</strong> </font></p>
<h4 id="3-重新梳理逻辑"><a href="#3-重新梳理逻辑" class="headerlink" title="3. 重新梳理逻辑"></a>3. 重新梳理逻辑</h4><p>上面我们先是给出了定义，再进一步解释的定义中各部分的意义，有点”由果寻因“的意味，逻辑上逆推。现在我们简单通过逻辑正推梳理一下：</p>
<p>样本点 { $\omega_1, \omega_2,…, \omega_n$}   $\Rightarrow$   样本空间$\Omega =$ {$ \omega_1, \omega_2,…, \omega_n $ }   $\Rightarrow$   某个事件$A_i =$ { $\omega_1, \omega_2$ }, $(A \subset \Omega)$   $\Rightarrow$   事件域$\mathscr{F} =$ { $A_1,A_2,…$}(事件域里面的事件$A_i$不是随意的，必须满足$\sigma$域条件)，那么概率就是一个函数，将事件域映射到$[0,1]$，计算概率的示例如下：</p>
<p>对于之前的$ \mathscr{F}_1$，有：$P(A_1) = 0, P(A_2) = \frac{1}{4}, P(A _ {10}) = \frac{1}{2}$</p>
<p>对于之前的$ \mathscr{F}_2 $，有：$P(A_1) = 0, P(A _ {16}) = 1, P(A_2) = \frac{1}{4}, P(A _ {14}) = \frac{1}{4}$</p>
<p>对于之前的$ \mathscr{F}_3 $，有：$P(A_1) = 0, P(A _ {16}) = 1$</p>
<h4 id="参考链接：-1"><a href="#参考链接：-1" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h4><p>[1-1]到底什么是概率？-哔哩哔哩 <a href="https://b23.tv/oeV9xJp">https://b23.tv/oeV9xJp</a>  </p>
<p>[1-2]什么是概率？ - 马同学的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/58995841">https://zhuanlan.zhihu.com/p/58995841</a> </p>
<p>[1-3]sigma代数、Borel 集、测度概念 <a href="https://blog.csdn.net/zhoujunr1/article/details/77466826?spm=1001.2101.3001.6650.18&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-18.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-18.pc_relevant_aa&utm_relevant_index=21">borel集_zhoujunr1的博客-CSDN博客_borel集</a> </p>
<p>[1-4]【初等概率论】 01<a href="https://blog.csdn.net/kac0c440/article/details/54928122?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~HighlightScore-2.queryctrv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~HighlightScore-2.queryctrv2&utm_relevant_index=4">【初等概率论】 01_kac0c440的专栏-CSDN博客</a> </p>
<p>[1-5]概率论复习笔记(3)——概率的公理化定义 - Fiddie的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/61729415">https://zhuanlan.zhihu.com/p/61729415</a> </p>
<p>[1-6]事件域和样本空间有什么区别？- 恩牛网 <a href="https://www.enmsb.com/article/%E4%BA%8B%E4%BB%B6%E5%9F%9F%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%A9%BA%E9%97%B4.html">https://www.enmsb.com/article/%E4%BA%8B%E4%BB%B6%E5%9F%9F%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%A9%BA%E9%97%B4.html</a>) </p>
<h3 id="二、什么是随机变量"><a href="#二、什么是随机变量" class="headerlink" title="二、什么是随机变量"></a>二、什么是随机变量</h3><h4 id="1-随机变量的本质"><a href="#1-随机变量的本质" class="headerlink" title="1. 随机变量的本质"></a>1. 随机变量的本质</h4><p><font color="red"><strong>随机变量的本质是函数——样本点的函数</strong></font></p>
<p>定义：设$X(w)​$是定义在概率空间$(\Omega, \mathscr{F}, P)​$上的单值实函数(也就是说它的自变量就是一个个的样本点，因变量是实函数)，如果对直线上任意一博雷尔点集$B​$，有$\begin{Bmatrix} \omega, X(\omega) \in B \end{Bmatrix} \subset \mathscr{F}​$则称$X(\omega)​$为随机变量(r.v.)。</p>
<blockquote>
<p>思考题目(某年北京考研题目)：</p>
<p>已知：$\Omega =$ { $\omega_1, \omega_2, \omega_3$ }, $P(\omega_1) = \frac{1}{3}, P(\omega_2) = \frac{1}{6}, P(\omega_3) = \frac{1}{2},  X(\omega_1) = 2, X(\omega_2) = X(\omega_3) = 0$</p>
<p>求：(1) $X$的分布；(2) 已知$E[Y] = 2$，$P(Y=X|X&gt;0) = 1,P(Y = X|X = 0)=\frac{3}{4}$，求$Y$的概率分布。</p>
<p>答案参考链接[2-1]</p>
</blockquote>
<h4 id="2-多维随机变量的本质"><a href="#2-多维随机变量的本质" class="headerlink" title="2. 多维随机变量的本质"></a>2. 多维随机变量的本质</h4><p><font color="red"><strong>多维随机变量的本质是参数方程</strong></font></p>
<p>二维随机变量定义：设$E$是一个随机试验，它的样本空间是$\Omega$，设$X=X(e)$和$Y=Y(e)$是定义在$\Omega$上的随机变量，由它们构成的一个向量$(X, Y)$，叫做二维随机变量。</p>
<p>多为随机变量定义：一般，设$E$是一个随机试验，它的样本空间是$\Omega = $ {$e$}，设$X_1=X_1(e),…,X_n=X_n(e)$是定义在$\Omega$上的随机变量，由它们构成的一个$n$维向量$(X_1,X_2,…,X_n)$叫做$n$维随机向量或$n$维随机变量 </p>
<p><strong>特别要主要两个随机变量的自变量是来自一个样本空间。</strong></p>
<p>例子：假设要了解一下学生的身体指标，这个班里有3个人，我们做一次实验，随机抽出一个人测一下身高$X$，体重$Y$。则我们想一下：</p>
<table>
<thead>
<tr>
<th></th>
<th>张三</th>
<th>李四</th>
<th>王五</th>
</tr>
</thead>
<tbody><tr>
<td>身高</td>
<td>180</td>
<td>175</td>
<td>168</td>
</tr>
<tr>
<td>体重</td>
<td>71</td>
<td>65</td>
<td>60</td>
</tr>
</tbody></table>
<p>二维随机变量$(X,Y)$的样本空间是$\Omega$等于什么，这时如果我们回答$X$的样本空间是{$180, 175, 168$}，$Y$的样本空间是{$71, 65, 60$}就错了，时刻要记得多维随机变量的自变量是来自一个样本空间，所以正确的结果是：</p>
<p>$\Omega =$ {$”抽到张三”, “抽到李四”, “抽到王五”$}</p>
<h4 id="3-随机变量的大小写表示"><a href="#3-随机变量的大小写表示" class="headerlink" title="3. 随机变量的大小写表示"></a>3. 随机变量的大小写表示</h4><p>大写字母表示随机变量，是概率论里面特有的变量，如$X, Y, Z, …$，但这其实是随机变量的简化形式，实际完整的形式如上文提及应该是$X(\omega), Y(\omega), Z(\omega)$，当拓展到$N$维随机变量时，一般使用$X_1, X_2,…,X_n$。</p>
<p>小写的表示函数的自变量，与高等数学里面的函数自变量意义相同。 在概率论里可以代指随机变量的具体取值，例如：$X(\omega) = x$。</p>
<p>表示随机变量之间的关系时，应该用大写，表示随机变量具体的分布函数或者概率密度时，应该用小写。 </p>
<blockquote>
<p><strong>我的疑问——对于多维随机变量定义的理解还不是很清楚：</strong></p>
<p>第一种情况：例如上面表格的情况，我们做一次随机实验$E$，抽出一名同学，则根据人的两个属性/指标可以得到二位随机变量：$X$—身高(属性)，$Y$—体重(属性)，这种情况我明白是正确的。</p>
<p>第二种情况：再例如我们测量某一电路的电流，我们测量了$N$次(相当于做了$N$次实验)，那么$N$次实验的随机变量是否可以组合起来变成$N$维随机变量呢？也就是$(X_1, X_2,…,X_n)$是否可以算是$N$维随机变量吗？？？</p>
</blockquote>
<h4 id="参考链接：-2"><a href="#参考链接：-2" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h4><p>[2-1]什么是随机变量？-哔哩哔哩 <a href="https://b23.tv/7x1yztY">https://b23.tv/7x1yztY</a>  </p>
<p>[2-2]随机变量究竟是什么-哔哩哔哩 <a href="https://b23.tv/OX2bLjq">https://b23.tv/OX2bLjq</a> </p>
<p>[2-3]多维随机变量究竟是什么-哔哩哔哩 <a href="https://b23.tv/S12nmbH">https://b23.tv/S12nmbH</a> </p>
<p>[2-4]随机变量和随机过程的个人理解 - UPPER的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/47113623">https://zhuanlan.zhihu.com/p/47113623</a> </p>
<p>[2-5]概率统计中，小x和大X有什么区别 <a href="https://zhidao.baidu.com/question/501709573263510124.html">https://zhidao.baidu.com/question/501709573263510124.html</a>) </p>
<p>[2-6]请问在概率论中的随机变量X，与统计学中总体随机变量X，极其样本X_1，X_2，X_3有怎么样的关系？ - 顾念一人的回答 - 知乎 <a href="https://www.zhihu.com/question/404719167/answer/1344528800">https://www.zhihu.com/question/404719167/answer/1344528800</a> </p>
<h3 id="三、概率函数P-x-、概率分布函数F-x-、概率密度函数f-x"><a href="#三、概率函数P-x-、概率分布函数F-x-、概率密度函数f-x" class="headerlink" title="三、概率函数P(x)、概率分布函数F(x)、概率密度函数f(x)"></a>三、概率函数P(x)、概率分布函数F(x)、概率密度函数f(x)</h3><h4 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h4><p>进入主题前，先明确几个概念：<br><strong>离散型变量（或取值个数有限的变量）</strong>：取值可一一列举，且总数是确定的，如投骰子出现的点数（1点、2点、3点、4点、5点、6点）。<br><strong>连续型变量（或取值个数无限的变量）</strong>：取值无法一一列举，且总数是不确定的，如所有的自然数（0、1、2、3……）。</p>
<p>**离散型变量取某个值$x_i$的概率$P(x_i)$是个确定的值（虽然很多时候我们不知道这个值是多少），即$P(x_i)≠0$**：例如，投一次骰子出现2点的概率是$P(2)=\dfrac{1}{6}$。</p>
<p><font color="red"><strong>连续型变量取某个值$x_i$的概率$P(x_i)=0$</strong></font>：<font color="blue"> 对于连续型变量而言，<strong>“取某个具体值的概率”的说法是无意义的，因为取任何单个值的概率都等于0</strong>，只能说<strong>“取值落在某个区间内的概率”</strong>，或<strong>“取值落在某个值邻域内的概率”</strong>，即**只能说$P(a&lt;xi≤b)$，而不能说$P(x_i)$。**</font>  为什么是这样？且看下例：<br>   例如，从所有自然数中任取一个数，问这个数等于5的概率是多少？从所有的自然数中取一个，当然是有可能取到5的，但是自然数有无穷多个，因此取到5的概率是$\dfrac{1}{\infty}$，也就是0。<br>   又如扔飞镖，虽然是有可能落在靶心的，但其概率也是0（不考虑熟练程度等其他因素），因为靶盘上有无数个点，每个点的概率是一样的，因此落在某一个具体的点上的概率为$\dfrac{1}{\infty} = 0$。</p>
<p>根据前面的例子可知：<font color="red"> <strong>在连续型变量中：概率为0的事件是有可能发生的，概率为1的事件不一定必然发生。</strong></font> </p>
<h4 id="2-概率分布和概率函数P-X"><a href="#2-概率分布和概率函数P-X" class="headerlink" title="2. 概率分布和概率函数P(X)"></a>2. 概率分布和概率函数P(X)</h4><p><strong>概率分布</strong>：给出了所有取值及其对应的概率（少一个也不行），<strong>只对离散型变量有意义</strong>。例如： </p>
<img src="https://pic.imgdb.cn/item/621457fd2ab3f51d913ee894.jpg" style="zoom:40%">

<p><strong>概率函数</strong>：用函数形式给出每个取值发生的概率，P(x)（x=x1，x2，x3，……），<strong>只对离散型变量有意义</strong>，实际上是对概率分布的数学描述。</p>
<p><strong>概率分布和概率函数只对离散型变量有意义，那如何描述连续型变量呢？</strong></p>
<p> <font color="red">答案就是“**概率分布函数F(x)<strong>”和“</strong>概率密度函数f(x)**”，</font> 当然这两者也是可以描述离散型变量的。</p>
<h4 id="3-概率分布函数F-X-与概率密度函数f-x"><a href="#3-概率分布函数F-X-与概率密度函数f-x" class="headerlink" title="3. 概率分布函数F(X)与概率密度函数f(x)"></a>3. 概率分布函数F(X)与概率密度函数f(x)</h4><p>1、<strong>概率分布函数F(x)：给出取值小于某个值的概率，是概率的累加形式</strong>，即：$F(x_i)=P(x&lt;x_i)= \sum(P(x_1),P(x_2), \cdots ,P(x_i))$（对于离散型变量）或求积分（对于连续型变量，见后图）。</p>
<p>2、<strong>概率分布函数F(x)的性质</strong></p>
<ul>
<li>单调非减性：$\forall a&lt;b$，总有$F(a) \leq F(b)$；</li>
<li>$F(x)$是一个右连续函数；</li>
<li>有界性：$\forall x \in \rm R$，总有$0 \leq F(x) \leq 1$，且$\lim\limits_{x \to -\infty} F(x) = 0, \lim\limits_{x \to \infty} F(x) = 1$；</li>
</ul>
<p>3、<strong>概率分布函数F(x)的作用</strong><br> （1）<strong>给出x落在某区间(a,b]内的概率</strong>：$P(a&lt;x≤b)=F(b)-F(a)$<br> （2）<strong>根据F(x)的斜率判断“区间概率”$P(A&lt;x≤B)$的变化（实际上就是后面要说的概率密度函数f(x)）（特别注意：是判断“区间概率”，即x落在$(A,B]$中的概率，而不是x取某个确定值的概率，这是连续型变量和离散型变量的本质区别）</strong><br>   <strong>某区间(A,B]内，F(x)越倾斜，表示x落在该区间内的概率P(A&lt;x≤B) 越大</strong>。如图中(a,b]区间内F(x)的斜率最大，如果将整个取值区间以$δ_x=b-a$的间隔等距分开，则x落在$(a,b]$内的概率最大。为什么？因为$P(A&lt;x≤B) )=F(B)-F(A)$，所有区间中只有在$(a,b]$这个区间上（即A=a，B=b）$F(B)-F(A)$达到最大值，也就是图中竖向红色线段最长。</p>
<img src="https://pic.imgdb.cn/item/62148eb52ab3f51d91b44170.jpg" style="zoom:40%">

<p>4、<strong>概率密度函数f(x)</strong></p>
<p>给出了变量落在某值$x_i$邻域内（或者某个区间内）的<font color="red"> <strong>概率变化快慢</strong>，<strong>概率密度函数的值不是概率，而是概率的变化率，概率密度函数下面的面积才是概率</strong>。 </font>  </p>
<p>定义1：若存在非负可积函数$f(x)$，使随机变量X取值于任一区间$(a,b]$的概率可表示成<br>$$<br>P(a \leq X \leq b) = \int_a^b f(x)dx<br>$$<br>则称X为连续型随机变量，$f(x)$为X的概率密度函数，简称概率密度或密度。</p>
<p> 5、概率分布函数和概率密度函数之间的关系<br>$$<br>F(x) = \int_{-\infty}^{x}f(t)dt \<br>f(x) = \frac{d}{dx}F(x)<br>$$</p>
<blockquote>
<p>注意：</p>
<p>概率密度函数$f(x)$在点a处取值，不是事件${X=a}$的概率。但是，该值越大，X在a点附近取值的概率越大。</p>
</blockquote>
<img src="https://pic.imgdb.cn/item/62148ee92ab3f51d91b4c173.jpg" style="zoom:50%">

<p><strong>连续型变量的概率、概率分布函数、概率密度函数之间的关系（以正态分布为例）</strong>如下图：<br>   <strong>对于正态分布而言，x落在u附近的概率最大，而F(x)是概率的累加和，因此在u附近F(x)的递增变化最快，即F(x)曲线在（u，F(u)）这一点的切线的斜率最大，这个斜率就等于f(u)。</strong>x落在a和b之间的概率为F(b)-F(a)（图中的红色小线段），而在概率密度曲线中则是f(x)与ab围成的面积S。如下图所示：</p>
<img src="https://pic.imgdb.cn/item/62148f2e2ab3f51d91b58251.jpg" style="zoom:60%">

<h4 id="4-概率密度函数在某点a的值f-a-的物理意义到底是什么？"><a href="#4-概率密度函数在某点a的值f-a-的物理意义到底是什么？" class="headerlink" title="4. 概率密度函数在某点a的值f(a)的物理意义到底是什么？"></a>4. 概率密度函数在某点a的值f(a)的物理意义到底是什么？</h4><p><strong>我们知道f(a)表示，概率分布函数F(x)在a点的变化率(或导数)；其物理意义实际上就是x落在a点附近的无穷小邻域内的概率，但不是落在a点的概率（前已述及，连续变量单点概率=0），用数学语言描述就是：</strong><br>$$<br>f(a) = F’(a) = P(a-\delta x &lt; x \leq a+\delta x)_{\delta x &gt;0 且 \to 0} ≠ P(a)<br>$$</p>
<h4 id="参考链接：-3"><a href="#参考链接：-3" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h4><p>[3-1]概率分布就很好，为什么还要提出概率密度的概念？ - 知乎 <a href="https://www.zhihu.com/question/25367654">https://www.zhihu.com/question/25367654</a> </p>
<p>[3-2]概率基础：概率密度函数并不是概率 - coasxu的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/413360980">https://zhuanlan.zhihu.com/p/413360980</a> </p>
<p>[3-3]概率密度函数在某一点的值有什么意义？ - 知乎 <a href="https://www.zhihu.com/question/23237834">https://www.zhihu.com/question/23237834</a> </p>
<p>[3-4]如何通俗的理解概率密度函数？ - 知乎 <a href="https://www.zhihu.com/question/263467674">https://www.zhihu.com/question/263467674</a> </p>
<p>[3-5]概率函数P(x)、概率分布函数F(x)、概率密度函数f(x) <a href="https://www.jianshu.com/p/0cfc3204af77">https://www.jianshu.com/p/0cfc3204af77</a></p>
<p>[3-6]一文读懂什么是联合概率，条件概率，贝叶斯 - 知乎 <a href="https://zhuanlan.zhihu.com/p/119453101">https://zhuanlan.zhihu.com/p/119453101</a> </p>
<p>[3-7]理解概率密度函数 <a href="https://blog.csdn.net/SIGAI_CSDN/article/details/83586458?utm_source=app&amp;app_version=5.0.0">https://blog.csdn.net/SIGAI_CSDN/article/details/83586458?utm_source=app&amp;app_version=5.0.0</a> </p>
<h3 id="四、概率中的矩的理解"><a href="#四、概率中的矩的理解" class="headerlink" title="四、概率中的矩的理解"></a>四、概率中的矩的理解</h3><h4 id="参考链接：-4"><a href="#参考链接：-4" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h4><p>[4-1]统计学中「矩」这个概念是怎么引入的？它为什么被称为矩？它与物理意义上的矩有什么相同与不同？ - 知乎 <a href="https://www.zhihu.com/question/19915565">https://www.zhihu.com/question/19915565</a> </p>
<p>[4-2]概率论中「矩」（moment）的实际含义是什么，高阶矩表示数据的哪些状态？ - 知乎 <a href="https://www.zhihu.com/question/23236070">https://www.zhihu.com/question/23236070</a> </p>
<p>[4-3]概率论中的“矩”是什么意思 - Mr.看海的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/57802400">https://zhuanlan.zhihu.com/p/57802400</a> </p>
<p>[4-4]矩（moment）、鞅（martingale）、似然（Likelihood）的「奇葩翻译」是怎么想的 - 范函子Skyline的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/78067348">https://zhuanlan.zhihu.com/p/78067348</a> </p>
<h3 id="五、随机变量的特征函数"><a href="#五、随机变量的特征函数" class="headerlink" title="五、随机变量的特征函数"></a>五、随机变量的特征函数</h3><h4 id="参考链接：-5"><a href="#参考链接：-5" class="headerlink" title="参考链接："></a><strong>参考链接：</strong></h4><p>[5-1]如何理解统计中的特征函数？<a href="https://blog.csdn.net/ccnt_2012/article/details/109776736">https://blog.csdn.net/ccnt_2012/article/details/109776736</a></p>
<p>[5-2]随机变量的特征函数 <a href="https://blog.csdn.net/JaneandDaria/article/details/83722395">https://blog.csdn.net/JaneandDaria/article/details/83722395</a></p>
<p>[5-3]特征函数解释了世界的哪个环节？<a href="https://blog.csdn.net/The_Time_Runner/article/details/90107979">https://blog.csdn.net/The_Time_Runner/article/details/90107979</a></p>
<p>[5-4]特征函数 (概率论)<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0_(%E6%A6%82%E7%8E%87%E8%AE%BA)">特征函数 (概率论)</a> </p>
<p>[5-5]如何理解统计中的特征函数？ - 知乎 <a href="https://www.zhihu.com/question/23686709">https://www.zhihu.com/question/23686709</a> </p>
<p>[5-6]随机函数的“特征函数”，是什么意思_百度知道 <a href="http://zhidao.baidu.com/question/922864273710991979?sharesource=weibo">http://zhidao.baidu.com/question/922864273710991979?sharesource=weibo</a></p>
<p>[5-7]随机变量的特征函数及应用 - Sunsnow的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/358618882">https://zhuanlan.zhihu.com/p/358618882</a> </p>
<h3 id="总参考链接："><a href="#总参考链接：" class="headerlink" title="总参考链接："></a>总参考链接：</h3><p>[1]广义线性模型 - 张振虎的博客 <a href="https://zhangzhenhu.github.io/blog/glm/source/index.html">https://zhangzhenhu.github.io/blog/glm/source/index.html</a><br>[2]概率论的基本概念 <a href="https://codeantenna.com/a/T0ryFFnuIZ">https://codeantenna.com/a/T0ryFFnuIZ</a><br>[3]零基础概率论入门:基本概念 <a href="http://www.360doc.com/content/18/0118/23/33209086_723218111.shtml">http://www.360doc.com/content/18/0118/23/33209086_723218111.shtml</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>概率基础</tag>
        <tag>概念辨析</tag>
      </tags>
  </entry>
  <entry>
    <title>书-音-影</title>
    <url>/2022/02/12/Book-Music-Film/</url>
    <content><![CDATA[<h2 id="壹-观影"><a href="#壹-观影" class="headerlink" title="壹 - 观影"></a>壹 - 观影</h2><h3 id="一、鬼子来了【22-02-11】"><a href="#一、鬼子来了【22-02-11】" class="headerlink" title="一、鬼子来了【22-02-11】"></a>一、鬼子来了【22-02-11】</h3><p><a target="_blank" href="https://movie.douban.com/subject/1291858/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">鬼子来了 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/1291858/</span></span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1Wx41157LP" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/69b07d9131be3f5dcd1fc1ea0bf33e44ce3e4613.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:20:54</span>
            </div>
            <div class="bvideo-info">
                <p class="title">细读经典 20: 真正的抗日神片《鬼子来了》</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>106.6万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>6932</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">电影最TOP</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>

<p><strong>转载影评：</strong></p>
<p>终于看了姜文被禁止公映的《鬼子来了》，很多人都将这部片子的禁止公映解说为该片中绝口不提共产党抗日，自始至终未出现一个党员形象，因此而引起不满。但看了这部片子才知道决不是因为这个原因。《鬼子来了》讲的是川北抗战的故事，在那个叫挂甲台的小村落里老百姓无知的固守着自己的善良，却悲惨的被鬼子集体屠杀。而且这场大屠杀发生在日本天皇发表投降诏书之后！中国的农民是淳朴而且安于现状的，他们被诸多的势力欺压了两千年，形成的秉性却温顺贤良。可以想见，当小鬼子们没有进行烧杀戮掠的时候，老百姓虽然会心有不甘，但真的是尚不至于奋起以命相搏（并不是说老百姓就不爱国，而是在那样一个自给自足、封闭且未开化的时期里，“爱国”还是一个虚幻的理念）。片中有大量的这样的痕迹，在那个被日军牢牢把持的小地方，因为没有国军和共军的争夺而显得相对安宁，小日本对当地人进行着和平的奴役。习惯了被压迫的老百姓已经对于尊严的事情麻木了，为了生计这样的眼前利益而过分乐观的活着。小镇上唱曲的在集市上宣扬着皇道乐土，教育众人中日“八百年前是一家”，村落里老百姓见了鬼子一口一个“森塞”的叫着。固执的不肯杀人的村民们为了结果被俘的鬼子，费尽周折请刀斧手，最终得到的结论是这鬼子命不该绝。并最终同意了鬼子用人换粮的建议。    烧杀掳掠外加奸淫妇女，这是鬼子留在中国人心目中固有的形象。但在这部片中的开始，虽然老百姓见了鬼子依然是战战兢兢有着被杀的危险，但小鬼子们仅是打骂并未随意杀人。不过，小鬼子们的武士道精神和对中国人的残忍施暴的一面却被生动形象的刻画出来。两个场景就可以进行完全的阐释： 一、炮楼里的两个鬼子溜出来想吃鸡，老兵教新兵如何粗暴的对待中国人，如何利用自己手中的刺刀，并说“对付支那猪就只有用这种办法”； 二、被囚半年兽性冷却后的小三郎在所谓的鬼子＋百姓的联欢中得意忘形，对中国人大声说着“大哥大嫂过年好，你是我的爷，我是你的儿”，但明显喝高了的他在队长一番激励下，兽性大发对养活了他半年的村民们举起了屠刀。    凡中国人与外族的殊死争斗，敌阵中必有我国人！这简直是个千古不变的道理！汉武帝征讨匈奴，有前宫人在匈奴王帐中出谋划策；抗日战争中更是伪军比日寇数量都多！这部片子中着重刻画了翻译这个角色，这个懂日本话的东北人几乎没有一句是在“直译”，国人对国人的欺瞒才是最可悲的事情。而且这个翻译在被村民释放后居然给鬼子队长出主意让鬼子爽约，结果招来一句奚落：“我们日本人不像你们中国人那样不讲信用。”这句话对我来说真的是太刺耳了。    悲剧就是把美好的东西打碎给人看。这部片子的结局是挂甲台整个村落在大火中消失在鬼子的屠刀下，而国军的抗战将领又让斧劈日本战俘的三儿受戮于已经被俘的小鬼子。这就是中国人的悲哀。为什么这样一个国土辽阔人口众多的民族被一个岛国践踏了整整八年，这部片子给了我们一定的启示。很多时候，不是别人的凶残和强大，而是我们自己的愚昧和自残。       从联合早报网上看到消息，东京举行了一个反华游行，理由是中国还没有对去年4月份爆发的反日游行向日本人道歉。不明白为什么这个世界上还有如此不讲道理的人种，但是毕竟有这样的邻居，有惨痛的教训，我们只能用《霍元甲》中的那句震撼的台词一样——“自强不息”！ </p>
<blockquote>
<p>作者：豆瓣用户——俩飞</p>
<p>原文链接：<a href="https://movie.douban.com/review/1045537/">https://movie.douban.com/review/1045537/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="二、爆裂鼓手【22-02-15】"><a href="#二、爆裂鼓手【22-02-15】" class="headerlink" title="二、爆裂鼓手【22-02-15】"></a>二、爆裂鼓手【22-02-15】</h3><p><a target="_blank" href="https://movie.douban.com/subject/25773932/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">爆裂鼓手 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/25773932/</span></span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1XK4y1a7gC" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/d383ead9dc036edb5b562e10ae2bd7b1ab0d8147.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:31:21</span>
            </div>
            <div class="bvideo-info">
                <p class="title">细读经典 103: 豆瓣8.7，暗黑励志神作《爆裂鼓手》</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>102.5万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>8994</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">电影最TOP</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>

<p><strong>转载影评：</strong></p>
<p>作为今年圣丹斯的获奖影片和奥斯卡热门，影片的上佳口碑主要来自于紧凑的剪辑、优质的表演和对于师徒关系非常规的刻画。诚然，影片的剪辑凌厉而准确，除结尾处有少许松懈，整部电影更像是一部动作悬疑片，节奏一再加快，冲突一再升级，影片结束，107分钟不知不觉中过去。影片对于音乐的处理也相当不马虎，体现了对于细节的重视和专业精神。</p>
<p>然而，如果将电影解读为描绘师徒关系，以及少年经历魔鬼训练，超越极限，从而实现自我的励志电影，大概是个误会。片中鼓手和指挥从始至终是纯粹的互相利用关系。鼓手其实从未得到特殊待遇——他始终是乐队中和其他乐手一样微不足道的一员，随时被指挥予取予求，玩弄于鼓掌之间。在鼓手坦陈指挥对于乐队的虐待，间接导致指挥离职之后，酒吧相遇，看似一番肺腑之言，实际上指挥已暗暗设计陷害，如若没有鼓手最后的破釜沉舟，一个乐手的生涯就要万劫不复（影片一再强调在卡内基演出对于音乐生涯的决定性作用）。即使仇人之间，若有一丁点原则和不忍，做事尚不会如此残忍，何况师徒。</p>
<p>鼓手本身也并非传统的善良天才少年。一定的才华和逼迫自己到极限的决心也许天才少年皆有，但是本片主角个性中的偏执和阴暗才是他一直被指挥吸引，也是指挥最后透露出欣赏的主因——鼓手一定程度是年轻版本的指挥，同样为达目的不择手段。影片中有诸多巧合，其中鼓手丢失首席鼓手让他代为保管的乐谱一节，其实颇值得思量。鼓手是否真的如观众期待那样无辜？未必。台词给出许多暗示：首席为自己辩解时说自己因身体有恙不能记谱，指挥早就知晓（那么其他乐手自然也知道）。鼓手在事发之后毫无愧疚，也从未想过补偿。键盘手似开玩笑让鼓手不要动自己的谱子，未必不是防人之心，等等。鼓手在争夺首席位置、与女友分手和佯作无辜答应指挥帮助演出时也同样毫无愧怍。因为同样认同追求卓越就要牺牲自我、他人，以至阻碍道路的一切，鼓手才会被指挥一番话吸引从而上钩，因为指挥的人生哲学实际道出了鼓手的心声。整部影片细述了鼓手从安德鲁到弗莱彻的渐变，最后一幕父亲在后台观看鼓手的独奏，眼神中惊恐多于欣慰，因为眼前的少年早已不是曾经一起吃爆米花开玩笑的儿子，技术上的提升和人性的嬗变相比已经显得次要。</p>
<p>本片导演说结尾实际是悲剧，主要媒体的影评也多少在这一点达到共识，大概正是为此。片中固然有励志的成分，但是成功的代价是少年纯真的丧失，如果本来尚有纯真的话。结尾高潮处影院中的观众畅然拊掌，其实是庆祝这种扭曲哲学的胜利——鼓手大概经此洗礼，从此更加坚定目标，不顾旁人，不择手段，从而一帆风顺。更可怕的是，等他自己成为别人的老师，恐怕也要把这样的哲学传递下去了。相对于严师是否定出高徒、学艺之路如何逼迫自我突破极限这类常规主题，影片提出的问题更集中于追求极致（无论目标是艺术的完美还是名利的丰收，也无论是否关于音乐）和葆有灵魂的平衡取舍。</p>
<blockquote>
<p>作者：豆瓣用户——Z</p>
<p>原文链接：<a href="https://movie.douban.com/review/7265093/">https://movie.douban.com/review/7265093/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="三、寻梦环游记【22-02-17】"><a href="#三、寻梦环游记【22-02-17】" class="headerlink" title="三、寻梦环游记【22-02-17】"></a>三、寻梦环游记【22-02-17】</h3><p><a target="_blank" href="https://movie.douban.com/subject/20495023/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">寻梦环游记 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/20495023/</span></span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1pW411e7oF" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/a4840b6079f876e0e31075471d2f9c7e3fca0148.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:15:49</span>
            </div>
            <div class="bvideo-info">
                <p class="title">【木鱼微剧场】《寻梦环游记》</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>77.4万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>4180</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">木鱼水心</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>

<p><strong>转载影评：</strong></p>
<p>5星推荐，片子真的好看，适合全年龄层。孩子们可以看到梦想，看到童趣，看到动画乐园一般的亡灵世界。大人可以看到亲情，看到爱情，看到梦想与责任，看到人性善恶。老年人会更感动吧，家人就是要生活在一起，要互相体谅，互相扶持。</p>
<p>最令我感动的一幕是，小孩回到家，他的太奶奶要去世了，忘记了亲人。小孩弹吉他唱起了“请记住我”，歌声响起，我的眼泪跟着落下。老奶奶眼睛亮起，跟着唱出来，亲人还在我们心里。</p>
<p>电影构建的死后世界很华丽，美轮美奂，就象一个巨大的游乐场。亡灵们很萌，白骨间的随意组合带来各种意料之外的笑点，不恐怖反倒很有趣。这个世界建立在另一个活人世界的记忆上，凡是在世的人记得的有照片的人，就可以在亡灵世界存在，反之就彻底消亡。所以一个家族代代传承的记念和供奉，会让家族中死去的人在另一个世界快乐的永生。</p>
<p>鲁迅说，亲人或余悲，他人亦已歌。确实，当人们不再记得一个人，他就真的消失了。如果世界的规律真是如此，我们活着的时候就应该更善意，更有责任感，更关爱家庭，关爱亲人，大家更团结，影响更多的人，这样当我们死去时，才会被人纪念，才会一直活在亲人和世人的心里。</p>
<p>看了电影，很希望亡灵世界就是这样的，我们的亲人也快乐的在。</p>
<p>另：这个逻辑基础下，还是当名人划算，你看电影里那个歌手，明明是个坏人，死后几十年了，还有无数的歌迷送无数的礼物，可以在亡灵世界风生水起。按这个设想一下，大魔头类的，会不会也因为被无数人记住而永生呢。</p>
<blockquote>
<p>作者：豆瓣用户——雪</p>
<p>原文链接：<a href="https://movie.douban.com/review/8999006/">https://movie.douban.com/review/8999006/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="四、催眠大师【22-02-23】"><a href="#四、催眠大师【22-02-23】" class="headerlink" title="四、催眠大师【22-02-23】"></a>四、催眠大师【22-02-23】</h3><p><a target="_blank" href="https://movie.douban.com/subject/24743711/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">催眠大师 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/24743711/</span></span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1ut411X7cR" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/14aea911bef6e21f58ee7a71b81da29234ccc59e.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:25:21</span>
            </div>
            <div class="bvideo-info">
                <p class="title">【木鱼微剧场】优秀国产悬疑电影《催眠大师》</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>104.6万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>7270</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">木鱼水心</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>

<p><strong>转载影评：</strong></p>
<p>今天电影催眠大师上映了，凑了个热闹，第一时间看到这部电影的公映，以国产电影的水准，应该算得上一部‘好电影’了，悬疑+惊悚，不仔细推敲的话，应该是勉强达到了观众的期待值。同时，电影里运用了大量的催眠理论和催眠技术，并且做了艺术的夸张，相信一定让很多观众迷惑，怀疑，不解，让人感觉玄之又玄，虚之又虚。本文，笔者就根据所学的有限的催眠知识，免费给这部电影做一次答疑解惑，也尽自己的一份力解除电影对于催眠术的误导。解释过程尽量做到不剧透吧，免得被喷！</p>
<p>首先科普一下催眠的几个深度，最广泛接受的划分方法是将催眠程度分为六个等级：</p>
<p>第一级催眠深度：小肌群受到暗示被操控，如暗示被催眠对象眼皮睁不开或嘴唇张不开，被催眠者受到暗示无法睁开，被催眠者不感觉被催眠，觉得完全清醒，这阶段已经可以做到减肥、戒烟等心理治疗了。</p>
<p>第二级催眠深度：大的肌群受到暗示，如手臂无法抬起或无法落下。此时被催眠者更加放松，也更加专注与催眠师的指令。</p>
<p>第三级催眠深度：可以完全控制所有的肌肉系统，产生数字阻滞。如无法从椅子上站起来，无法走路，无法说出某个数字，但并不是忘了那个数字，临床催眠师的大部分工作，一般在这前三个等级之内。</p>
<p>第四级催眠深度：开始有失忆现象，被催眠者可以遗忘掉自己的名字，地址，某个数字，并可以产生痛觉阻断，可以做一些手术，拔牙、开刀等。</p>
<p>第五级催眠深度：开始产生梦游状态，产生正性幻觉，可以看到不存在的东西（是真的看到，而不是想象出来的）。 </p>
<p>第六级催眠深度：更新的梦游状态，可以产生负性幻觉，看不见，听不见，确实存在的事物或声音，如暗示被催眠者看不见别人的身体，只能看到头部，那么他就只能看到一个的头。</p>
<p>在影片《催眠大师》中到底达到那个深度，也有人在争议，有人说三级，有人说四级；我认为，至少达到了第五级催眠深度，甚至是第六级，因为被催眠者已经完全不认识自己很熟悉的人（具体情节电影中会交待，此处不详细说的话要剧透），用自己的幻觉代替了现实，这已经完全超出了想像的范畴了。但大多情节中出现的现象达到前三个等级就可以完成，如回忆起以前自己想不起来的事情，跟想象中的人进行对话交流（这在催眠治疗中十分常用，实质是跟自己的潜意识在交流）等，另外，演员在在催眠状态下的表现也符合催眠的状态，如，莫文蔚在催眠状态下产生的眼皮跳动，快速动眼活动，肢体放松，泪水增加，眼白部分变红等等，说明剧组确实注意到了催眠状态下的细节，大家在观看的时候可以留意一下。</p>
<p>最意思是影片中使用的各种催眠技术，种类繁多，甚至可以作为了解催眠技术的一个入门教学了。</p>
<p>先说直接催眠法的技术，首先是眼睛凝视法，影片中使用的道具是怀表，用它的好处是让被催眠者不仅可以凝视重复的摆动，还可以听到单调重复的滴答声， 从而快速导入催眠。影片中的用的凝视法并不限于盯着看怀表，还包括催眠师的眼睛，烟头，笔尘（沈医生在试图催眠徐瑞宁时所用到的）等等，让观众感觉处处有催眠，防不胜防。  </p>
<p>其次是联想法导入催眠的运用，通过让被催眠对象在头脑中产生想象的画面，进而引导他进入更深的催眠状态，这个想像的画面，既可以是对象凭空创造的一个形象或场景，也可以是过去记忆中的的一个场景，这种方法在影片中使用的次数也非常多，如果有兴趣，大家在观影过程中也可以注意一下。</p>
<p>再次是反复加深技术，这种技术的做法就是不断引发被催眠对象唤醒，再不断地导入催眠，从而让对象进入更深的催眠状态，影片中徐峥和莫文蔚不断的互相催眠，又不断的唤醒，再不断的进入催眠……实质上确实使用了这种反复加深技术，不知道是剧情的需要，还是编剧越催眠技术的特意安排。这也是我很喜欢用的一个技术，效果很好，在催眠中，把对象唤醒调整下身体的姿势，反馈一下感受，接着再导入催眠，可以避免被催眠对象长时间保持一个姿势造成的肌肉疲劳。</p>
<p>然后再说一下间接催眠，这是影片中让观众感觉比较玄乎的地方，在影片中叫做清醒催眠，也有人叫做隐性催眠；就是让人在清醒状态下，通过交流谈话或者环境暗示，让对象在不知不觉中进入催眠状态。整个影片框架也是在这种理论的基础上搭建的，为了让观众了解这种催眠技术，影片还特意让主人公对这种理论做了一个讲解，给剧情的勾画做了一个铺垫。如，影片中多次用到了环境的暗示，通过水，声音、光线等，或某一个词语（如影片中用到的“船长”），让对象不知不觉中产生联想和回忆，从而再进一步导入催眠。</p>
<p>另外，影片中有这样的一个比较的高级催眠技术是：混乱技术。该技术的原理是，通过一些异乎寻常的语言，动作，表情等，让被催眠对象短时间内接受大量的信息，造成信息过载，引发神经失衡，触发战斗或逃跑反应（Fight-or-flight response），绕过对象的意识评判区，从而导入催眠。仔细分析一下，影片中一直在使用这种技术，如，影片中心理咨询室故意布置得非常怪异，无形中给予被催眠对象一些混乱；催眠师故意把怀表掉在地上，也是一种混乱；来访者任小妍怪异的心理行为本身就是一种混乱，突然去拨弄钟表指针，突然把水泼出来等都是一种混乱技术的应用，以及从其他咨询师传来的大量信息，也加强了这种混乱，所以，对象没有理由不进入催眠状态了。</p>
<p>当然，能把这种隐性催眠技术运用的如此娴熟，绝非等闲之辈所能及，我想，即使催眠大师艾瑞克森还在世的话，也未必能做到。</p>
<p>现在问题来了，现实中，到底有没有可能做到影片中那样的催眠？我的答案是，有可能。但前期必须做大量的铺垫工作，我不可能在一次咨询过程中做到这样的效果。说到这里，不得不提及另外一种心理技术技术，这就是“心锚”的建立。所谓“心锚”，就是人的内心某一心理状态或行与另外某一动作或表情之间的锚定，它的基础是条件反射。比如开车时看到红灯就不自觉的踩刹车，这就是一种“心锚”。影片中，被催眠对象，一看到有节律的“一，二，三”运动形式就会被催眠，如听到数数123，看烟头有节律的3次一熄一灭，三次晃动水杯，拨动三下钟表针等都能迅速地导入催眠状态，要实现这种简单的瞬间催眠，一般就需要“心锚”的建立，而建立这样的“心锚” 一般还得在催眠状态下，所以这样的“心锚”又称为“催眠后暗示”。</p>
<p>看完影片后，观众还可能有一个担忧，担心自己会不会像影片中那样，某一天被不知不觉的被催眠、被控制，从而说出自己不愿说出的事情，作出自己不愿做的事。其实，大可不必担心，首先，能做到这样快速隐性催眠的催眠师少之又少，凤毛麟角，即使有，也早忙着去某个商业机构都赚大钱去了，恐怕也没有时间闲的蛋疼催眠你玩吧；其次，人在催眠状态下，潜意识的自我保护能力是非常强的，一旦有人要求你做违背个人意愿的事情，很快就能从催眠状态下次苏醒过来。</p>
<p>调查显示，很多普通大众对催眠有很深的误解，认为催眠可以控制人或者让人失去意识进入昏睡状态。因为催眠术早期多用于巫术和宗教等，让它蒙上了一层迷信和神秘的色彩，影片的播出，也可能让许多人加深了这种误解，所以普及和了解一下催眠知识，还是非常有必要的。其实，任何一种催眠状态在平常生活中都出现过，如在睡觉即将清醒或快睡着的时候，突然身体无法动弹，出现‘鬼压床’的现象，就是一种催眠状态；人在某个极度的悲伤或恐惧情绪状态下，眼前突然浮现某个人，就是一种正性幻觉；又如某小美女穿着超短裙去玩，回到家发现青一块，紫一块，什么时候碰的都不知道，这就是一种催眠麻醉状态；有时候时候拿着钥匙找钥匙，拿着电话找手机，或某个东西明明就在桌子上就是找不到，看不见，这就是催眠状态下的一种负性幻觉；所以说催眠一点儿也不神奇。  　　最后再回答一个问题，催眠术可不可能被用于犯罪？答案是可能的！任何一种技术都是一把双刃剑，历史上也确实出现过催眠犯罪的案例，如着名的“海德堡事件”，所以不要轻易找不熟悉的催眠师进行催眠，进行催眠之前最好对催眠师进行一个调查了解，既有利于对催眠师产生信任更好地进入催眠状态，也是一种自我保护。</p>
<p>写这篇文章的过程中，我被催眠了，不知不觉中时间都这么晚了，哈哈哈！有些东西可能说的还不是太清楚，大家有什么问题可以在下面留言，也可以加我QQ：315678525。（吕艳朋，2014年4月29日，于济南宝华苑。） </p>
<blockquote>
<p>作者：豆瓣用户——吕艳朋</p>
<p>原文链接：<a href="https://movie.douban.com/review/6653031/">https://movie.douban.com/review/6653031/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="五、记忆大师【22-02-24】"><a href="#五、记忆大师【22-02-24】" class="headerlink" title="五、记忆大师【22-02-24】"></a>五、记忆大师【22-02-24】</h3><p><a target="_blank" href="https://movie.douban.com/subject/25884801/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">记忆大师 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/25884801/</span></span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1Rx411n7He" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/b1c145efca0651dbf279a3ee081504e0d1ea14a6.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:05:00</span>
            </div>
            <div class="bvideo-info">
                <p class="title">【片片】五分钟看懂《记忆大师》，影帝黄渤的“杀人回忆”</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>28.9万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>548</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">小片片说大片</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>

<p><strong>转载影评：</strong></p>
<p>故事一开始的设定就是和现实不太关联的另外一个国度，我感觉抽取记忆出来的技术就像未来一段时间或许可以发生的，但是后面很多场景又让自己感觉这个又是很接地气的画面，可能是交错未来与现在的交错吧，一些场景选的还是很不错的。</p>
<p>在电影里，可以感觉一个人的记忆对一个人性格影响太大了，在江丰记忆弄错之后，一些举动就变得怪异许多，一个植入的记忆对于一个人的行为的影响是否过大？这个需要推敲一下。朋友们有的说这部电影是比较烧脑的，一路猜测，最后回归到自己第一感觉，沈警官。</p>
<p>故事从零碎的记忆开始，穿插了两段故事，在现实中江丰与妻子有矛盾起冲突，慢慢铺展开来，这一部电影感觉又带有对家暴现象的评价，沈警官对于保护那些避免到家暴女性的态度太过于偏执，最开始怀疑他的原因，来自于去警察局找他的男子他一直不愿意去面对，另外就是去找那个女孩调查时，女孩对他的态度和对他徒弟的态度有点差异。</p>
<p>高潮大概是从被设计之后的江丰怀疑陈姗姗开始，故事开始紧张起来，这里相对来讲精彩了，将所有人的目光吸引到这个凶手可能是女性，又有一点疑问，就是录像中从背影看挺像一个女子，但是从电话到最后，都未再提及这个。</p>
<p>最后是一个美好结局，算是一部烧脑的但又不能细究的悬疑电影吧，还是推荐看看的。对于记忆是否影响人的行为，通过记忆找出凶手，还是保持一个探究之心。 </p>
<blockquote>
<p>作者：豆瓣用户——不懂相负</p>
<p>原文链接：<a href="https://movie.douban.com/review/8536325/">https://movie.douban.com/review/8536325/</a></p>
<p>侵删</p>
</blockquote>
<p> <strong>从狼人杀角度分析记忆大师</strong></p>
<p>先盘狼坑：沈sir金刚狼，拿了警徽，最后时刻发言爆炸；沈sir他爸深水狼；李航发言爆炸的冲锋狼，被沈sir卖了做自己身份。 陈姗姗平民钻了狼坑，又被狼队作为完美抗推位，最后没被推出去晚上被狼人给刀了；李惠兰，首夜吃刀的平民；张代晨划水民但最后跳出来帮女巫挡刀。 江丰女巫，吃夜里信息但是逻辑不行没盘出狼坑，差点把毒撒到被狼人污了一手的陈姗姗身上，还好最后时刻抓住沈sir的发言漏洞又站对了边；徒弟原本是铁站边陈sir的猎人，最后因为沈sir他爸的发言漏洞看出了沈sir是只狼一枪把沈sir给崩了；沈sir他妈，离线预言家。。。</p>
<blockquote>
<p>作者：豆瓣用户——Turkey is done</p>
<p>原文链接：<a href="https://movie.douban.com/review/8510215/">https://movie.douban.com/review/8510215/</a></p>
<p>侵删</p>
</blockquote>
<h3 id="六、我是山姆【22-02-27】"><a href="#六、我是山姆【22-02-27】" class="headerlink" title="六、我是山姆【22-02-27】"></a>六、我是山姆【22-02-27】</h3><p><a target="_blank" href="https://movie.douban.com/subject/1306861/" style="position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; box-sizing: border-box; -webkit-flex-direction: row; -ms-flex-direction: row; flex-direction: row; -webkit-align-items: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; width: 390px; min-height: 84px; border-radius: 8px; max-width: 100%; overflow: hidden; margin: 16px auto; padding: 12px 12px 9px 12px; background-color: #F6F6F6;"><span class="LinkCard-contents"><span style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; max-height: 40px; line-height: 1.25; color: #121212;">我是山姆 - 豆瓣链接</span><span style="display: -webkit-box; font-size: 13px; height: 18px; line-height: 18px; color: #999; word-break: break-all; text-overflow: ellipsis; overflow: hidden; -webkit-line-clamp: 1; -webkit-box-orient: vertical;"><span style="display: inline-flex; align-items: center;"><svg class="Zi Zi--InsertLink" fill="currentColor" viewbox="0 0 24 24" width="14" height="14"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"/></svg></span><span>https://movie.douban.com/subject/1306861/</span></span></span></a></p>
<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1pA411P7wh" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/7a5f1453a3d4948a8ba5f099886956caa63d7665.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">00:11:18</span>
            </div>
            <div class="bvideo-info">
                <p class="title">这个父亲只有7岁智商，却治愈了无数正常人，泪点低的请一个人看</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>600.8万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>630</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">贰哥电影</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>

<p>大概是深夜了，我从手中挑了挑盘，打算安静的找个剧情片看，我挑了一会。衡量再三，选了一部讲述弱智，不健全、低能父亲的这部《我是山姆》放进了DVD机当中。</p>
<p>山姆是一个快乐的人。生活在美国，工作在星巴克，他是一个小时工，拿时薪。那天突然来了一个电话，告诉他马上就快有了，速来医院认领。于是他快乐的飞奔而去。</p>
<p>是一个女孩，他如获至宝，他想这比什么都珍贵，那应该是天上掉下来的钻石，于是他给孩子取名“露西”（《天空中拥有钻石的露西》：披头四的一首曲子）。办完手续，他携子带母出了医院的大门，孩子他妈对山姆说，快看，外星人。山姆一愣，那孩子他妈仓皇的飞奔而去。</p>
<p> 山姆独自拉扯女孩的日子就这么开始了，这日子很惨，惨过1939年的《飘》，但一步步的，他也明白了很多东西：例如婴儿两个小时要喝一次奶；每周例行的电影会，谈心会将要改成不定期的了；苏斯博士的《绿蛋和火腿》是不能给孩子读一辈子的。同时他也获得了很多疑惑，例如为什么有的男人是光头，天空的尽头在哪，夏时令中少的那一个小时去了哪里，露西长的到底是像他还是像孩子他妈？</p>
<p>有一天露西问山姆，我妈还回来吗？山姆冥思后带着苦相答，保罗麦卡特尼（披头四成员）从小就没妈，约翰列侬（同样是披头四成员）也是，所以你注定是一个不平凡的小孩。露西又问，爸，那你是不平凡的吗？是从小就这样？山姆很茫然，可能明白了露西的一语双关。他带着愧意对露西说，对不起。而露西说，这没什么，我们都是幸运的。</p>
<p>当露西7岁的时候，她已经比山姆显得成熟和聪明了，她会读different，而山姆不能。露西要上小学，同时也快过生日了，山姆想，要给她举办一个聚会，在这个聚会他想给露西一个礼物：一张披头四的唱片。</p>
<p>但惊喜终究是没有到来，那场聚会搞砸了，露西看到慌里慌张的山姆瘫在地上，伤心的飞奔而去。</p>
<p>这个家庭面临困境，露西要被别人托管，美国政府的维权组织切入了进来，法庭也来了，他们要剥夺山姆的抚养权，山姆没见过这阵势，又一次陷入了慌张。</p>
<p>还好，他有一群智囊班子，由一群和他一样有一些缺陷的人员组成的智囊班子。他们合伙给山姆推荐了一个本市最牛逼的律师，是600多页的大黄页中筛选的结果，他们甚至细心的告诉了山姆那律师的地址，这让山姆为之一振，兴奋的飞奔而去。</p>
<p>看到这里我想，如果这个故事没有这一刻的神奇，那这就不是戏剧，而是人生了。</p>
<p>这个牛逼律师是一名女性，招牌服饰是高档职业装，高档眼镜压在高鼻梁上面，是极品女强人，当然她个子也不矮。</p>
<p>电影在这一阶段显示出了诡异的蓝，连那个律师的杯子都是蓝蓝的，让人冷峻不已。这个女律师显得很忙，时间就是金钱，一天办八个案子（都收费），甚至忙的亲儿子的电话都必须排在第二线，山姆看到这个情景，不仅一阵慌张，他想，钱怎么办？我不能再当小时工了，我要学个技术，我要学会调卡布奇诺。</p>
<p>在这期间，山姆又飞奔了很多次（在去律师楼和去看露西的路上），有一次看他去看露西的时候，他没有飞好，滑倒了，那手中的蛋糕塌陷了一地，但露西躺在山姆身边，丝毫不会在意，笑得很甜。</p>
<p>一次次山姆的到来，让女律师被同事的白眼和自己的势利心打动了，他对山姆说，好吧 我义务（pro bono）一次，当你律师。山姆很茫然的样子。女律师又换了一个简单词汇，免费（free）。山姆大喜。 接下来就是很诡异地开了很多次庭，电影的底色还是蓝蓝的，也十分冷峻。镜头中大量使用了近角的特写，照在山姆那茫然的额头上，但是山姆挺住了，没有看到汗水顺着他的额头滴落下来，这应该是一种抗争，但天真的山姆应该不能体会到生活何常不是一种抗争呢？</p>
<p>又一次开庭结束，山姆慷慨邀请女律师吃了一顿便饭，他说这顿饭，我来，我义务（pro bono）一次，看山姆学的多快。</p>
<p>人心是肉长的，女律师在一次次与山姆的交流中也学会了很多，例如耐性和聆听。 她发现在这次义务当中，她得到的比山姆还多，他送给了山姆一套西服和一条领带，山姆很开心，要知道当山姆在法庭上看到他的智囊团中的傻小伙A带着一条红领巾一样的蹩脚领带是多么神往。女律师发现当她和山姆在一起的时候，他确实放下了什么叫成功和高档，甚至有一次她哭着告诉山姆，他丈夫泡上了一个比她还要高档完美的女人，她很痛苦。她当着山姆的面，真的是什么都敢说了。</p>
<p>就这么着，日子过去了，露西暂时被一家人收养。在这期间，女律师还是在和不公正的法律抗争，同时也办了离婚；而山姆同时也是在和生活抗争。但好的方向是，山姆升了职，去调卡布奇诺了。</p>
<p>山姆还找了两份兼职，一份是溜狗，这是为了能够离露西近一些。另一份是去必胜客薄饼店当店员，为了多练习一下算数的实际应用，因为最终在法庭上，法官会考山姆，他要证明山姆脑子够用，是一个能精打细算过日子的人。</p>
<p>山姆开始背很多数据，然后一一串联起来，他知道露西暂时住在九号屋，而约翰.列侬是10月9日生的，约翰.列侬的儿子也是10月9号生的，约翰.列侬他妈住在利物浦纽卡斯尔大街9号。他知道这一切不是巧合，他和露西的相遇也不是巧合，天上掉下的钻石就是他的。    </p>
<p>电影就在此刻伴随着山姆的坚持也慢慢的融化了，那冷峻的蓝色调变成了橙色的暖色调，阳光大量的照射在了草地上，木吉他轻松的和弦带出了一场愉快的足球比赛，而最终的胜利者是山姆，露西回到了他的身边。</p>
<p>最后要说的是，1电影原声很好听，很多大牌乐队或歌手翻唱了披头四的经典歌曲作为这个电影的配乐。我个人最喜欢“across the universe”这首。  2 星巴克和必胜客给我的印象彻底改变，我终于知道，其实那只是美国的牛肉面馆子 </p>
<blockquote>
<p>作者：豆瓣用户——饭忒稀</p>
<p>原文链接：<a href="https://movie.douban.com/review/1631458/">https://movie.douban.com/review/1631458/</a></p>
<p>侵删</p>
</blockquote>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>生活休闲</category>
        <category>书-音-影</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>观影</tag>
        <tag>听音乐</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>先验概率与后验概率</title>
    <url>/2022/01/22/Prior-and-Posterior-Probabilities/</url>
    <content><![CDATA[<h4 id="1-先验概率"><a href="#1-先验概率" class="headerlink" title="1. 先验概率"></a>1. 先验概率</h4><p>事情还没有发生，根据以往的经验来判断事情发生的概率，是“由因求果”。(根据统计和规律得出得概率 )</p>
<blockquote>
<p>扔一个硬币，在扔之前就知道正面向上的概率为0.5。这是根据我们之前的经验得到的。这个0.5就是先验概率。</p>
</blockquote>
<h4 id="2-后验概率"><a href="#2-后验概率" class="headerlink" title="2. 后验概率"></a>2. 后验概率</h4><p>事情已发生，有多种原因，判断事情的发生是由哪一种原因引起的，是“由果求因”。(根据贝叶斯公式可以得到) </p>
<blockquote>
<p>今天上学迟到了，有两个原因，一个是自行车坏了，一个是生病了。后验概率就是根据结果（迟到）来计算原因（生病/自行车坏了）的概率。</p>
</blockquote>
<p><font color="red"> <strong>数学表达上，后验概率和条件概率有相同的形式</strong></font></p>
<p><font color="red"><strong>贝叶斯公式就是由先验概率求后验概率的公式</strong> </font></p>
<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>先验概率是对某一件事情发生可能性的预先客观评估，而后验概率是对事情发生是由某一个原因导致的概率。</p>
<p>先验概率是以全事件为背景下A事件发生的概率$P(A|\Omega)$，后验概率是以新事件B为背景下A事件发生的概率$P(A|B)$全事件一般是统计获得的，所以称为先验概率，没有实验前的概率。新事件一般是实验，如试验B，此时的事件背景从全事件变成了B，该事件B可能对A的概率有影响，那么需要对A现在的概率进行一个修正，从$P(A|Ω)$变成$P(A|B)$，所以称 $P(A|B)$为后验概率，也就是试验(事件B发生)后的概率。</p>
<p>后验概率分布是条件概率的一个例子。 后验概率告诉我们，在我们观察到一组特定数据的情况下，参数值的可能性有多大。 当然，条件概率不需要描述参数和数据，所以后验概率是条件概率的一个特例。</p>
<h4 id="4-补充-条件概率与后验概率"><a href="#4-补充-条件概率与后验概率" class="headerlink" title="4. 补充-条件概率与后验概率"></a>4. 补充-条件概率与后验概率</h4><p>后验概率就是一种条件概率，但是与其它条件概率的不同之处在于，它限定了目标事件为隐变量取值，而其中的条件为观测结果。 一般的条件概率，条件和事件都可以是任意的。</p>
<p><strong>举例区分普通条件概率与后验概率的区别</strong>：</p>
<blockquote>
<p>1）那么如果我们出门之前我们听到新闻说今天路上出了个交通事故，那么我们想算一下堵车的概率，这个就叫做条件概率 。也就是P(堵车|交通事故)。这是有因求果。</p>
<p>2）如果我们已经出了门，然后遇到了堵车，那么我们想算一下堵车时由交通事故引起的概率有多大，那这个就叫做后验概率 （其实也是条件概率，但是通常习惯这么说） 。也就是P(交通事故|堵车)。这是有果求因。</p>
</blockquote>
<p> 从上述例子可知道，后验概率就是在已知某B事件发生的情况下，求解其中A事件发生的概率是多少，而A事件正是B事件发生的一个隐状态事件，所以A与B是有前后关联的。在利用贝叶斯进行文本分类的时候也是这个意思：<br>$$<br>P(\frac{c}{d})=\frac{p(\frac{d}{c})p(c)}{p(d)}<br>$$<br>d文档分为c类的概率，$p(c)$就是先验概率，$p(c/d)$就是后验概率，所以贝叶斯就是用先验概率估计后验概率。</p>
<p>而一般的条件概率，目标事件A和条件事件B，是可以没有任何关系的。</p>
<hr>
<p>概率论老师说：</p>
<p>A的概率——$P(A)$</p>
<p>A在条件C下的概率——$P(A|C)$</p>
<p>统计学老师说：</p>
<p>A事件发生的先验概率——$P(A)$</p>
<p>知道C事件发生后，A事件发生的后验概率——$P(A|C)$</p>
<p><strong>小结</strong></p>
<p>条件概率和后验概率理论上是没区别，唯一的区别在于后验概率来自后验概率分布上。后验概率按理应该是在贝叶斯推论框架下，在这个框架下，必须将后验概率分布和后验概率结合来看。</p>
<p>综上，后验概率是贝叶斯推论中的概念，而条件概率在频率学派和贝叶斯学派中都有使用，注意这两个学派的区别后，应该能能理解这两者的区别。</p>
<h4 id="相关链接："><a href="#相关链接：" class="headerlink" title="相关链接："></a>相关链接：</h4><p>[1]贝叶斯学派与频率学派有何不同？ - 知乎 <a href="https://www.zhihu.com/question/20587681">https://www.zhihu.com/question/20587681</a> </p>
<p>[2]用贝叶斯 计算后验概率(一) - 住奥马哈的张校长的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/27006631">https://zhuanlan.zhihu.com/p/27006631</a> </p>
<p>[3]贝叶斯推断如何更新后验概率？ - 知乎 <a href="https://www.zhihu.com/question/27398304">https://www.zhihu.com/question/27398304</a> </p>
<p>[4]概率与似然<a href="https://blog.csdn.net/FWing/article/details/4850068?utm_source=app&amp;app_version=5.0.0">https://blog.csdn.net/FWing/article/details/4850068?utm_source=app&amp;app_version=5.0.0</a> </p>
<p>[5]似然(likelihood)和概率(probability)的区别与联系<a href="https://blog.csdn.net/songyu0120/article/details/85059149?utm_source=app&amp;app_version=5.0.0">https://blog.csdn.net/songyu0120/article/details/85059149?utm_source=app&amp;app_version=5.0.0</a> </p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信号频域变换分析</title>
    <url>/2022/02/02/Digital-signal-spectrum-analysis/</url>
    <content><![CDATA[<h3 id="一、数字信号处理中常用矩函数计算和其物理意义"><a href="#一、数字信号处理中常用矩函数计算和其物理意义" class="headerlink" title="一、数字信号处理中常用矩函数计算和其物理意义"></a>一、数字信号处理中常用矩函数计算和其物理意义</h3><h4 id="一-常用矩函数"><a href="#一-常用矩函数" class="headerlink" title="(一) 常用矩函数"></a>(一) 常用矩函数</h4><h5 id="1-均值"><a href="#1-均值" class="headerlink" title="1. 均值"></a>1. 均值</h5><p>均值表示信号中<strong>直流分量</strong>的大小，用$E(x)$表示。对于高斯白噪声信号而言，它的均值为0，所以它只有交流分量。<br>$$<br>E(x) = \bar x = \frac{x_1 + x_2 + \cdots +x_n}{n} = \frac{\sum_{i=1}^{n}x_i}{n}<br>$$</p>
<h5 id="2-均值的平方"><a href="#2-均值的平方" class="headerlink" title="2. 均值的平方"></a>2. 均值的平方</h5><p>均值的平方，用${E^2(x)}$表示，它表示的是信号中<strong>直流分量的功率</strong>。</p>
<h5 id="3-均方值"><a href="#3-均方值" class="headerlink" title="3. 均方值"></a>3. 均方值</h5><p>均方值表示信号平方后的均值，用$E(x^2)$表示。<strong>均方值表示信号的平均功率</strong>。信号的平均功率 = 信号交流分量功率信号直流分量功率。</p>
<h5 id="4-均方根值"><a href="#4-均方根值" class="headerlink" title="4. 均方根值"></a>4. 均方根值</h5><p>用RMS（root meansquare），即均方值的开根号。<br>$$<br>X_{rms} = \sqrt{\frac{\sum_{i=1}^{n}X_i^2}{N}}<br>$$</p>
<h5 id="5-均方差"><a href="#5-均方差" class="headerlink" title="5. 均方差"></a>5. 均方差</h5><p>均方差（mean squareerror），用MSE表示。均方差是各数据偏离真实值的距离平方和的平均数，也即误差平方和的平均数，计算公式形式上接近方差，它的开方叫均方根误差，均方根误差才和标准差形式上接近。均方差有时候被认为等同于方差。<br>$$<br>X_{MSE} = \frac{1}{n}<br>$$</p>
<h5 id="6-均方根误差"><a href="#6-均方根误差" class="headerlink" title="6. 均方根误差"></a>6. 均方根误差</h5><p>均方根误差用RMSE（root mean  squareerror）表示。它是观测值与真值偏差的平方和观测次数n比值的平方根，在实际测量中，观测次数n总是有限的，真值只能用最可信赖（最佳）值来代替。方根误差对一组测量中的特大或特小误差反映非常敏感，所以均方根误差能够很好地反映出测量的精密度。均方根误差有时被认为是标准差。</p>
<h5 id="7-方差"><a href="#7-方差" class="headerlink" title="7. 方差"></a>7. 方差</h5><p>方差用variance或deviation 或Var表示。方差描述信号的波动范围，表示信号中<strong>交流分量</strong>的强弱，即<strong>交流信号的平均功率</strong>。<br>$$<br>D(X) = E[(X-E(X))^2]<br>$$</p>
<p>$$<br>s^2 = \frac{1}{n-1}\sum_{i=1}^{n}(x_i - \bar x)^2  ——或者另一种形式——s^2 = \frac{1}{n}\sum_{i=1}^{n}(x_i - \bar x)^2<br>$$</p>
<blockquote>
<p>注意上面除以的是n-1，只有这样由样本值估计出的方差才是<strong>无偏的</strong>，即上面式子的期望才是X的方差。但是有的地方也有用除以n来表示方差，只不过这样求出的结果不是方差的无偏估计，计算结果的数学期望并不是X的方差，而是X方差的倍。 </p>
</blockquote>
<h5 id="8-标准差"><a href="#8-标准差" class="headerlink" title="8. 标准差"></a>8. 标准差</h5><p>标准差（Standard Deviation）用σ表示，有的时候标准差又可以被称为均方根误差RMSE。标准差是各数据偏离平均数的距离的平均数，它是离均差平方和平均后的方根，用σ表示，标准差能反映一个数据集的离散程度。</p>
<p>标准差σ， 反映了测量数据偏离真实值的程度，σ越小，表示测量精度越高，因此可用σ作为评定这一测量过程精度的标准。<br>$$<br>S = \sqrt{\frac{\sum_{i=1}^{n}(x_i-\bar x)^2}{n}}<br>$$</p>
<blockquote>
<p>有了方差为什么要使用标准差？标准差比方差有什么优势？</p>
<p>因为方差与我们要处理的数据的量纲是不一致的，虽然能很好的描述数据与均值的偏离程度，但是处理结果是不符合我们的直观思维的。 </p>
</blockquote>
<h4 id="二-总结"><a href="#二-总结" class="headerlink" title="(二) 总结"></a>(二) 总结</h4><p>（1）总的来说，均方差，均方根误差和方差，标准差是不能够等同的，尽管它们的公式相似。我们需要从真实值和均值之间的关系来区分它们</p>
<p>（2）对于方差和标准差而言，它们反映的是数据序列与均值的关系。</p>
<p>（3）对于均方差和均方根误差而言，它们反映的是数据序列与真实值之间的关系。</p>
<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：新浪博客/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> <a href="http://www.360doc.com/content/18/0715/14/908538_770556276.shtml">http://www.360doc.com/content/18/0715/14/908538_770556276.shtml</a></p>
<hr>
<h3 id="二、数字域频率与模拟频率"><a href="#二、数字域频率与模拟频率" class="headerlink" title="二、数字域频率与模拟频率"></a>二、数字域频率与模拟频率</h3><h4 id="一-二者关系"><a href="#一-二者关系" class="headerlink" title="(一) 二者关系"></a>(一) 二者关系</h4><p><strong>重点：数字域频率是模拟角频率相对于采样频率的归一化。</strong></p>
<h5 id="1-第一种理解："><a href="#1-第一种理解：" class="headerlink" title="1. 第一种理解："></a>1. 第一种理解：</h5><p>从”连续时间正弦信号与离散时间正弦信号“的关系来理解。</p>
<img src="https://pic.imgdb.cn/item/61f9eb132ab3f51d91a2dbbe.jpg" style="zoom:70%">

<p>敲黑板，重点是</p>
<img src="https://pic.imgdb.cn/item/61f9ec4d2ab3f51d91a3d307.jpg" style="zoom:70%">

<h5 id="2-第二种理解"><a href="#2-第二种理解" class="headerlink" title="2. 第二种理解"></a>2. 第二种理解</h5><p>从”采样信号的傅里叶变换与离散时间信号的傅里叶变换“的关系来理解。从时域采样出发，先看时域上离散时间信号$x(n)$的自变量$n$与连续时间信号$x(t)$的自变量$t$的关系，如下图。</p>
<img src="https://pic.imgdb.cn/item/61f9ed512ab3f51d91a4a253.jpg" style="zoom:70%">

<p>在频域上模拟信号、采样信号、和采样序列(也就是离散时间信号)三者的频谱的关系，如下图所示。看看横轴，时域上，横轴由$t$变成$n$，是按照$n=t/T$的规则；而频域上，横轴由$\Omega$(模拟角频率)变成了$\omega$(数字域频率)，按照$\omega = \Omega × T$的规则。</p>
<img src="https://pic.imgdb.cn/item/61f9ee502ab3f51d91a55e3c.jpg" style="zoom:70%">

<p>数字域频率$\omega$的最高频率是$\pi$，这一点可以结合采样定理来理解。采样间隔$T$，意味着采样角频率为$2\pi/T$，根据采样定理，最高的频率是采样频率的一半，也就是$\pi/T$，再将它转换为数字域频率（(乘以$T$)，不就是$\pi$吗?</p>
<h5 id="3-第三种理解"><a href="#3-第三种理解" class="headerlink" title="3. 第三种理解"></a>3. 第三种理解</h5><p>从z平面与s平面的映射关系上来理解。</p>
<img src="https://pic.imgdb.cn/item/61f9ef592ab3f51d91a62e74.jpg" style="zoom:70%">

<h4 id="二-总结-1"><a href="#二-总结-1" class="headerlink" title="(二) 总结"></a>(二) 总结</h4><p>不管从哪种角度、哪种方式，殊途同归，结论是一样的，那就是——数字域频率是模拟角频率相对于采样频率的归一化。这一结论，是我们能够正确解读采样后的信号它的频谱分析结果的前提。<br>模拟角频率和数字域频率是数字信号处理中非常重要的两个概念，因为经常需要将模拟信号离散化后再进行频域分析，那么，得到的是数字域频率，必须正确转换为模拟角频率后，才能得到分析对象——模拟信号的频域信息。</p>
<h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：个人图书馆/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> <a href="http://www.360doc.com/content/19/0611/18/908538_841808354.shtml">http://www.360doc.com/content/19/0611/18/908538_841808354.shtml</a></p>
<hr>
<h3 id="三、离散时间傅里叶变换DTFT"><a href="#三、离散时间傅里叶变换DTFT" class="headerlink" title="三、离散时间傅里叶变换DTFT"></a>三、离散时间傅里叶变换DTFT</h3><p>首先要需要理解英文缩写DTFT的含义：离散时间DT、傅里叶变换FT，连起来就是DTFT。注意第二个T (也就是Time)，至关重要。它是“离散D”这个特性所描述的主体：也就是，时间是离散的。</p>
<h4 id="一-从z变换到DTFT"><a href="#一-从z变换到DTFT" class="headerlink" title="(一) 从z变换到DTFT"></a>(一) 从z变换到DTFT</h4><p><strong>重点1：从“单位圆上的z变换“这个角度来理解DTFT正变换的定义。</strong><br><strong>重点2：理解DTFT的周期性——离散时间信号的傅里叶变换都是以$2\pi$为周期的。</strong></p>
<img src="https://pic.imgdb.cn/item/61f9f1bb2ab3f51d91a81cbd.jpg">

<h5 id="1-DTFT的正变换："><a href="#1-DTFT的正变换：" class="headerlink" title="1. DTFT的正变换："></a>1. DTFT的正变换：</h5><p>$$<br>\text{DTFT}[x(n)] = X(e^{j\omega}) = \sum_{n = -\infty}^{\infty}x(n)e^{-j\omega n}<br>$$</p>
<h5 id="2-DTFT的基本性质："><a href="#2-DTFT的基本性质：" class="headerlink" title="2. DTFT的基本性质："></a>2. DTFT的基本性质：</h5><p>​    $X(e^{j\omega})$是以$\omega$为自变量的<font color="red"><strong>连续</strong>函数</font>；</p>
<p>​    $X(e^{j\omega})$是以$2\pi$为周期的<font color="red"><strong>周期</strong>函数</font>；</p>
<h5 id="3-DTFT存在的充分条件："><a href="#3-DTFT存在的充分条件：" class="headerlink" title="3. DTFT存在的充分条件："></a>3. DTFT存在的充分条件：</h5><p>$$<br>x(n)绝对可和：\sum_{n = -\infty}^{\infty}|x(n)| &lt; \infty<br>$$</p>
<h4 id="二-DTFT变换对及物理含义"><a href="#二-DTFT变换对及物理含义" class="headerlink" title="(二) DTFT变换对及物理含义"></a>(二) DTFT变换对及物理含义</h4><p><strong>重点1：理解离散信号频谱的物理概念及特点。</strong><br><strong>重点2：会求几种常用信号的DTFT(单位样值信号、矩形脉冲、指数衰减信号、离散Sa函数等)。</strong></p>
<h5 id="1-DTFT公式整理"><a href="#1-DTFT公式整理" class="headerlink" title="1. DTFT公式整理"></a>1. DTFT公式整理</h5><img src="https://pic.imgdb.cn/item/61f9f4c02ab3f51d91aa9178.jpg">

<h5 id="2-物理含义"><a href="#2-物理含义" class="headerlink" title="2. 物理含义"></a>2. 物理含义</h5><p>(1) $x(n)$可以表示成复指数信号的线性组合(只需一个$2\pi$区间内的频率)；</p>
<p>(2) $X(e^{j\omega})$表示了$x(n)$中各个频率分量的相对大小及位置，称为$x(n)$的频谱(以$2\pi$为周期)。<br>$$<br>X(e^{j \omega})=|X(e^{j \omega})| e^{j \angle X(e^{j \omega})}<br>$$</p>
<h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：个人图书馆/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> <a href="http://www.360doc.com/content/19/0611/18/908538_841808425.shtml">http://www.360doc.com/content/19/0611/18/908538_841808425.shtml</a></p>
<hr>
<h3 id="四、离散傅里叶级数DFS"><a href="#四、离散傅里叶级数DFS" class="headerlink" title="四、离散傅里叶级数DFS"></a>四、离散傅里叶级数DFS</h3><h4 id="一-离散时间周期信号的DFS"><a href="#一-离散时间周期信号的DFS" class="headerlink" title="(一) 离散时间周期信号的DFS"></a>(一) 离散时间周期信号的DFS</h4><p><strong>重点1：对照连续时间周期信号的FS的思想，理解离散时间周期信号的FS，二者的相同(离散谱)和不同之处。</strong><br><strong>重点2：理解离散时间周期信号的FS展开式为何只有N项，理解离散时间周期信号频谱的周期性。</strong></p>
<img src="https://pic.imgdb.cn/item/61f9f6e12ab3f51d91ac386f.jpg">

<p>需要说明的是，DFS有两种表示形式，如下面两个式子，这两种方式的区别在于，1/N的系数在正变换(FS系数求解式)中，还是反变换(级数展开式)中。没有实质区别，只是差一个常数N。这里均采用第二种表示形式，即将1/N的系数放在反变换中。<br>$$<br>第一种：\tilde{X} _ k = \frac{1}{N}\sum _ {n = 0}^{N-1}\tilde{x} _ ne^{-j\frac{2\pi}{N}kn}\text{ } - - - - \text{ }\tilde{x}(n) = \sum _ {k=0}^{N-1}\tilde{X} _ ke^{j\frac{2\pi}{N}kn}<br>$$</p>
<p>$$<br>第二种：\tilde{X}(k) =\sum _ {n = 0}^{N-1}\tilde{x} _ ne^{-j\frac{2\pi}{N}kn} \text{ } - - - -\text{ }\tilde{x}(n) =  \frac{1}{N}\sum _ {k=0}^{N-1}\tilde{X}(k)e^{j\frac{2\pi}{N}kn}<br>$$</p>
<h4 id="二-离散时间周期信号的频谱"><a href="#二-离散时间周期信号的频谱" class="headerlink" title="(二) 离散时间周期信号的频谱"></a>(二) 离散时间周期信号的频谱</h4><p><strong>重点1：掌握离散时间周期信号频谱的特点——离散性、谐波性、周期性；</strong><br><strong>重点2：会求常用离散时间周期信号的DFS(见例题1和例题2)。</strong></p>
<img src="https://pic.imgdb.cn/item/61f9faf22ab3f51d91af8e23.jpg" style="zoom:80%">

<h5 id="1-两类典型的求解DFS的题目："><a href="#1-两类典型的求解DFS的题目：" class="headerlink" title="1. 两类典型的求解DFS的题目："></a>1. 两类典型的求解DFS的题目：</h5><p><strong>第一类：</strong>周期信号直接以正弦、余弦之和形式给出(如例1)<br>方法：与标准形式的FS对照，直接得出FS的系数（即频谱)。<br><strong>第二类：</strong>一般的周期信号(如例2)<br>方法：用FS的系数求解公式。</p>
<h5 id="2-DFS与DTFT的关系"><a href="#2-DFS与DTFT的关系" class="headerlink" title="2. DFS与DTFT的关系"></a>2. DFS与DTFT的关系</h5><p><strong>重点：理解DFS与DTFT的关系——周期序列的离散谱是其主值序列连续谱的离散抽样。</strong></p>
<p>与上一讲中离散矩形脉冲的DTFT进行比较：可见，二者在时域上的关系是周期延拓，频域上的关系是离散抽样。如下图所示。 </p>
<img src="https://pic.imgdb.cn/item/61f9fc072ab3f51d91b070dc.jpg">

<img src="https://pic.imgdb.cn/item/61f9fc512ab3f51d91b0a4f4.jpg">

<h5 id="3-四种傅里叶变换的关系"><a href="#3-四种傅里叶变换的关系" class="headerlink" title="3. 四种傅里叶变换的关系"></a>3. 四种傅里叶变换的关系</h5><p><strong>重点：一个域周期，对应另一个域离散。</strong></p>
<img src="https://pic.imgdb.cn/item/61f9fd6e2ab3f51d91b1b54d.jpg">

<h5 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：个人图书馆/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> <a href="http://www.360doc.com/content/19/0611/18/908538_841808371.shtml">http://www.360doc.com/content/19/0611/18/908538_841808371.shtml</a></p>
<hr>
<h3 id="五、离散傅里叶变换DFT"><a href="#五、离散傅里叶变换DFT" class="headerlink" title="五、离散傅里叶变换DFT"></a>五、离散傅里叶变换DFT</h3><h4 id="一-背景介绍"><a href="#一-背景介绍" class="headerlink" title="(一) 背景介绍"></a>(一) 背景介绍</h4><p>为什么需要定义一种“新”的变换?</p>
<p>计算机处理的两个基本条件：<br><strong>第一，只能处理离散的数据(时域和频域都要离散)；</strong><br><strong>第二，要有限长。</strong></p>
<p>DTFT，时域上离散，但频域是连续的；DFS，时域频域都是离散的，但同时又都是周期的，周期序列长度为无限长。但同时我们也注意到，周期序列实际上只有有限个序列值有意义，因而它的离散傅里叶级数也适用于有限长序列，这就得到有限长序列的离散傅里叶变换(DFT)。</p>
<img src="https://pic.imgdb.cn/item/61f9fe8b2ab3f51d91b28d6c.jpg" style="zoom:80%">

<p>所以，<strong>DFT并不是一种新的变换</strong>。它只是将DFS时域和频域上都取一个周期而已。<strong>DFT正反变换的定义式与DFS相同，只是加了一个取值范围的限定而已</strong>。换汤不换药。</p>
<h4 id="二-DFT的定义及物理含义"><a href="#二-DFT的定义及物理含义" class="headerlink" title="(二) DFT的定义及物理含义"></a>(二) DFT的定义及物理含义</h4><p><strong>重点：DFT与DFS、DTFT的关系</strong></p>
<h5 id="1-变换公式"><a href="#1-变换公式" class="headerlink" title="1. 变换公式"></a>1. 变换公式</h5><p>$$<br>正变换：X(k)=\sum_{n=0}^{N-1} x(n) e^{-j \frac{2 \pi}{N} k n}, k=0,1, \ldots, N-1<br>$$</p>
<p>$$<br>逆变换：x(n)=\frac{1}{N} \sum_{k=0}^{N-1} X(k) e^{j \frac{2 \pi}{N} k n}, n=0,1, \ldots, N-1<br>$$</p>
<p>定义<font color="red"><strong>旋转因子$W_N=e^{-j\frac{2\pi}{N}}$</strong></font>，则上式转变为：<br>$$<br>正变换：X(k)=\sum_{n=0}^{N-1} x(n) W_{N}^{k n}, k=0,1, \ldots, N-1<br>$$</p>
<p>$$<br>逆变换：x(n)=\frac{1}{N} \sum_{k=0}^{N-1} X(k) W_{N}^{-k n}, n=0,1, \ldots, N-1<br>$$</p>
<p>总上，这对变换记为：<br>$$<br>x(n)\overset{N点\text{DFT}}{\longleftrightarrow}X(k)<br>$$<br><img src="https://pic.imgdb.cn/item/61fa03b92ab3f51d91b6cb31.jpg" style="zoom:80%"></p>
<p><strong>DFT不是序列x(n)的真正的频谱。x(n)的真正的频谱是DTFT，DFT只是对其真正频谱的一个周期上的离散抽样值。</strong></p>
<h4 id="三-DFT的计算"><a href="#三-DFT的计算" class="headerlink" title="(三) DFT的计算"></a>(三) DFT的计算</h4><p><strong>重点：DFT的两种计算方法。</strong></p>
<h5 id="1-方法一：利用DFT定义式"><a href="#1-方法一：利用DFT定义式" class="headerlink" title="1. 方法一：利用DFT定义式"></a>1. 方法一：利用DFT定义式</h5><p>$$<br>X(k) = \sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi}{N}kn},k=0,1,\cdots,N-1<br>$$</p>
<h5 id="2-方法二：先求DTFT再抽样"><a href="#2-方法二：先求DTFT再抽样" class="headerlink" title="2. 方法二：先求DTFT再抽样"></a>2. 方法二：先求DTFT再抽样</h5><p>$$<br>X(k)=X(e^{j \omega})| _ {\omega=\frac{2 \pi}{N} k} R _ {N}(k)<br>$$</p>
<h5 id="3-例题"><a href="#3-例题" class="headerlink" title="3. 例题"></a>3. 例题</h5><p>下面的例题，分别用这两种方法进行求解。</p>
<html>
    <table style="margin-left: auto; margin-right: auto;">
        <tr>
            <td>
                <!--左侧内容-->
                求5点矩形窗函数$x(n) = R_5(n)$的5点DFT$X_1(k)$和10点DFT$X_2(x)$
            </td>
            <td>
                <!--右侧内容-->
                <img src="https://pic.imgdb.cn/item/61fa05922ab3f51d91b85a37.jpg">
            </td>
        </tr>
    </table>
</html>

<img src="https://pic.imgdb.cn/item/61fa090f2ab3f51d91bb0fba.jpg">

<p>对于本题来说，方法二特别直观，便于理解DFT与DTFT的关系。</p>
<img src="https://pic.imgdb.cn/item/61fa09a32ab3f51d91bb8efb.jpg" style="zoom:70%">

<p>可见，同一个序列的不同点数的DFT，得到的结果不同。DFT的点数$N$越大，$X(k)$越能反映连续频谱的形状。<br>当DFT的点数$N$&gt;序列的长度$N_0$时，相当于在序列后面补上$N-N_0$个零，故称为<strong>”补零DFT“</strong>。</p>
<img src="https://pic.imgdb.cn/item/61fa0a292ab3f51d91bbff68.jpg" style="zoom:70%">

<h4 id="四-DFT性质"><a href="#四-DFT性质" class="headerlink" title="(四) DFT性质"></a>(四) DFT性质</h4><h5 id="1-圆周移位-循环移位"><a href="#1-圆周移位-循环移位" class="headerlink" title="1. 圆周移位(循环移位)"></a>1. 圆周移位(循环移位)</h5><p>首先看，为什么要定义一种新的移位?这种新的移位为什么称为“圆周移位”？它与普通的移位有何异同？见下图。</p>
<img src="https://pic.imgdb.cn/item/61fa0ab42ab3f51d91bc7111.jpg" style="zoom:70%">

<p>可见，圆周移位与普通移位的区别在于：多一个周期延拓、再取主值区间的过程。定义式如下：<br>$$<br>圆周移位(循环移位)——x(n+m)_NR_N(n) = \tilde{x}(n+m)R_N(n)<br>$$<br>圆周移位的步骤：先周期延拓、再移位、最后取主值区间；或者先移位、再周期延拓、最后取主值区间。前两步谁先谁后都可以。见下图。</p>
<img src="https://pic.imgdb.cn/item/61fa0bf72ab3f51d91bd7a9a.jpg" style="zoom:70%">

<p>可见，这种新的移位，相当于先把序列放在一个圆上，然后转圈圈：左移，沿顺时针方向转(即上图中的情况);右移，沿逆时针方向转。<br>**与其他傅里叶变换一样，DFT依然满足：时域移位，频域线性相移；频域移位，时域调制。需要注意的是，这里的移位，都指的是<font color="red">圆周(循环)移位</font>**。</p>
<img src="https://pic.imgdb.cn/item/61fa0cb02ab3f51d91be2ca9.jpg" style="zoom:80%">

<h5 id="2-圆周卷积-循环卷积"><a href="#2-圆周卷积-循环卷积" class="headerlink" title="2. 圆周卷积(循环卷积)"></a>2. 圆周卷积(循环卷积)</h5><p><strong>(1) 圆周卷积的定义</strong><br>仿照上面我们对移位操作做的改进——增加了“周期延拓、取主值区间”的过程，将“移位”改造成“圆周移位”一样，我们也对之前很熟悉的卷积和公式做改进，就得到一种新的卷积”圆周卷积“(或称为循环卷积)的定义。</p>
<p>$x_1(n)$的长度为$N_1$，$x_2(n)$的长度为$N_2$，$N \geq \max(N_1,N_2)$，则$N$点圆周卷积为：<br>$$<br>x_1(n) \odot x_2(n) = \sum_{m=0}^{N-1}x_1(m)x_2(n-m)_NR_N(n)<br>$$<br>为了区分，大家在《信号与系统》中所学习的卷积和，称为”线性卷积“。<br>显然易见，圆周卷积的结果与$N$有关。<br><strong>(2) DFT的圆周卷积定理</strong><br>在圆周卷积的定义下，DFT依然满足”一个域卷积，另外一个域相乘“这一更古不变的关系。</p>
<p><font color="bule"><strong>时域圆周卷积定理：</strong></font><br>$$<br>x_1(n) \odot x_2(n) \overset{N点\text{DFT}}{\longleftrightarrow}X_1(k)X_2(k)<br>$$<br><font color="bule"><strong>频域圆周卷积定理：</strong></font><br>$$<br>x_1(n)  x_2(n) \overset{N点\text{DFT}}{\longleftrightarrow}\frac{1}{N}X_1(k) \odot X_2(k)<br>$$<br><strong>(3) 圆周卷积的计算</strong><br>下面重点来看圆周卷积的计算。</p>
<img src="https://pic.imgdb.cn/item/61fa10de2ab3f51d91c1fa15.jpg" style="zoom:85%">

<p><strong>(4) 圆周卷积与线性卷积的关系</strong><br>上面的例题中，两个序列的线性卷积是多少呢?圆周卷积与之相同吗?为什么?<br>线性卷积，是直接将序列2反转、平移，而没有”周期延拓、再取主值“这两步。可以用图解法或者竖式法得到（信号与系统中已学，此处直接给出结果)，线性卷积的结果如下：<br>$$<br>两序列的5点线性卷积为:x _ 1(n) * x _ 2(n)=[1,3,6,9,12,9,5]<br>$$<br>两种卷积为何不同呢?又有何关系呢?<br>下图从公式上推导圆周卷积与线性卷积的关系</p>
<img src="https://pic.imgdb.cn/item/61fa11ac2ab3f51d91c2b12a.jpg" style="zoom:80%">

<p>我们可以得到以下结论：</p>
<p><strong>圆周卷积是线性卷积周期延拓后的主值序列：</strong><br>$$<br>y_c(n) = \sum_{r=-\infty}^{\infty}y_l(n+rN)R_N(n)<br>$$<br><strong>当$N\geq N_1+N_2-1$时，圆周卷积和线性卷积结果相同。</strong></p>
<p>根据以上结论，我们可以根据线性卷积的结果，直接得到N点圆周卷积的结果。如下图：</p>
<img src="https://pic.imgdb.cn/item/61fa12862ab3f51d91c36961.jpg" style="zoom:70%">

<h5 id="3-圆周共轭对称性"><a href="#3-圆周共轭对称性" class="headerlink" title="3. 圆周共轭对称性"></a>3. 圆周共轭对称性</h5><p>这里不讲证明(教材上都有)，重点讲怎么理解教材上让人眼花缭乱的公式。我们把“公式”翻译成“人话”。<br>首先说明，文中所说的N点长序列，都指的是自变量取值范围为$[0,N-1]$，除此之外的区间，序列值为0。<br>先看第一个。<br><strong>(1) 共轭序列的DFT</strong><br>时频域有这样一个基本对应关系——时域取共轭，对应频域自变量取负然后函数取共轭。具体到DFT呢？“自变量取负”也就是“反转”，而“DFT隐含着周期性”，所以这里的“反转”要加上“周期延拓，再取主值区间”，所以，公式及证明过程如下</p>
<img src="https://pic.imgdb.cn/item/61fa135b2ab3f51d91c41e2a.jpg" style="zoom:70%">

<p><strong>时域取共轭，对应DFT是：先周期延拓，再反转，再取主值区间，最后取共扼。</strong>当然，第一步与第二步可以交换次序，取共轮可以放在任意步骤上。关键是理解这个操作用公式的三种描述方式(上图中画红线处)：<br>第①种：$X^*((-k))_N R_N(k)$，是最直观地展现上述过程的；<br>第②种：$X^*((N-k))_N R_N(k)$，可认为用其周期性(周期延拓得到的当然是以$N$为周期啦)，把$-k$换成$N-k$；<br>第③种：去掉了双括号，也去掉了$R_N(k)$，好像看不出“周期延拓”和“取主值区间”的操作了。大家会心存疑虑，这个等号成立吗?<br>我们用下图的例子来说明一下这个等号成立，为了画图的方便，我们用函数值为实数的情况，图中是以$n$为自变量，换作$k$当然也是一样的。</p>
<img src="https://pic.imgdb.cn/item/61fa223c2ab3f51d91d25487.jpg">

<p>$x(N-n)$可以看作简写形式，优点在于形式简洁明了，缺点在于掩盖了周期延拓再取主值的过程。用这种简写形式，要注意一点，$N$点长序列$x(n)$，$n$的取值范围为$0&lt;n&lt;N-1$，也就是说，本来应该$x(N)=0$。但是，此处，当$n=0$时，$x(N-n)=x(N)$，不能认为$x(N)=0$，而要认为$x(N)=x(0)$。也就是说，要把$x(n)$的这$N$个点，认为是周期序列的主值区间，那么$x(N)$就是下一个周期的第一个点，所以$x(N)=x(0)$。<br>用这种简写形式来描述这个性质，就是：时域取共轭，对应的DFT，相当于把序号$k$与序号$N-k$做一个互换，然后取共轭。<br>下面，看这个性质的两个推论。</p>
<ul>
<li><p><strong>第一个推论：实序列的DFT是圆周共轭对称序列。</strong></p>
<ul>
<li>对于实序列$x(n)$，其DFT即$X(k)$满足<br>$$<br>X(k) = X^*(N-k)_NR_N(k) = X^*(N-k)<br>$$<br><font color="red"><strong>实序列的DFT $X(k)$是圆周共轭对称序列</strong></font>。即：实部圆周偶对称，虚部圆周奇对称；模圆周偶对称，相角圆周奇对称。</li>
</ul>
<p>“圆周共轭对称”是个什么鬼？我们按照以下几步来解释一下：</p>
<p>第一步：从“偶对称、奇对称”到“共轭对称/共轭反对称”</p>
<p>​    偶对称/奇对称地球人都知道吧。共轭对称/反对称就不是地球人都知道了，大学生才知道。</p>
<p>​    对于实函数$x(n)$，如果$x(-n)=x(n)$，称之为偶对称，$x(-n)=-x(n)$称之为奇对称。</p>
<p>​    扩展到复函数$x(n)$，如果$x^*(-n)=x(n)$，称之为共轭对称，$x^*(-n)=-x(n)$称之为共轭反对称。</p>
<p>第二步：从“共轭对称”到“圆周共轭对称”</p>
<p>​    圆周共轭对称的定义：对于$N$点长序列$x(n)$，如果$x(n)=x((N-n))_NR_N(n)$，或者用简写形式：$x(n)=x(N-n)$，那么称之为“圆周共轭对称”。<br>可以理解为：把$x(n)$放在一个圆周的$N$个等分点上，或者说把横轴掰弯成一个圆($n=N-1$与原点重合)，则这$N$个序列值关于原点对称，或者说关于$\dfrac{N}{2}$也对称，如下图所示。</p>
<img src="https://pic.imgdb.cn/item/61fa27d02ab3f51d91d78d3a.jpg" style="zoom:70%">

<p>我们前面求解过的例题：5点矩形脉冲的DFT，如下图，也体现出圆周偶对称的特点。</p>
<img src="https://pic.imgdb.cn/item/61fa28242ab3f51d91d7e051.jpg" style="zoom:70%"></li>
<li><p><strong>第二个推论：实部/虚部与圆周共轭对称/反对称分量的关系</strong><br>首先解释一下什么叫圆周共轭对称分量和圆周共轭反对称分量。需要经过以下几步循序渐进的理解。<br>第一步：实函数可以分解为偶分量+奇分量<br>$$<br>x(n) = x_e(n)+x_o(n)<br>$$<br>其中：偶分量——$x_e = \dfrac{x(n)+x(-n)}{2}$，奇分量——$x_o = \dfrac{x(n)-x(-n)}{2}$</p>
<p>第二步：从“偶分量/奇分量”到复函数可以分解为“共轭对称分量+共轭反对称分量”<br>把上式中的$x(-n)$改为$x^*(-n)$即可<br>$$<br>x(n) = x_e(n)+x_o(n)<br>$$<br>其中：共轭对称分量——$x_e(n) = \dfrac{x(n)+x^*(-n)}{2}$，共轭反对称分量——$x_o = \dfrac{x(n)-x^*(-n)}{2}$</p>
<p>以上两式，无论是对无限长序列，还是有限长序列，都是适用的。如果$x(n)$为$N$点长，并且$0&lt;n&lt;N-1$，那么$x_e(n)$和$x_o(n)$是$2N-1$点长，并且$-(N-1) \leq n \leq N-1$。<br>第三步：改造成适合DFT的<br>凡是涉及到自变量取负(也就是反转)的，都加上“周期延拓，再取主值区间”的操作。也就是把上式中的$x(-n)$改为$x((N-n))_NR_N(n)$，用简写形式表示就是$x(N-n)$  </p>
<p>因此，得到圆周共轭对称分量和圆周共轭反对称分量的定义：</p>
<p>$N$点长的序列$x(n)$，可以分解为<font color="red">圆周共轭对称分量+圆周共轭反对称分量</font><br>$$<br>x(n) = x_{ep}(n) + x_{op}(n)<br>$$<br>其中：圆周共轭对称分量——$x_{ep}(n) = \dfrac{x(n)+x^*(N-n)}{2}$，圆周共轭反对称分量——$x_{op}(n) = \dfrac{x(n)-x^*(N-n)}{2}$</p>
<p>注意，前提是$x(n)$为$N$点长序列，并且n的范围是$0≤n≤N-1$，圆周共轭对称/反对称分量的长度仍是$N$，$n$的范围也不变。而且如前所述，$n=0$时，$x(N-0)=x(N)=x(0)$。<br>上面，是以$x(n)$为例，同样，对于DFT $X(k)$，也可以定义圆周共扼对称/反对称分量，不再赘述。<br>解释完这些，我们的核心公式就出来啦（证明过程省略，直接看结论)。<br>序列$x(n)$及其DFT的实部/虚部与圆周共轭对称/反对称分量之间的关系，见下图：</p>
<img src="https://pic.imgdb.cn/item/61fa317c2ab3f51d91e0bda3.jpg" style="zoom:70%">

<p>(此处省略若干公式)<br>翻译成人话(绕口令)就是:<br>序列实部的DFT是序列DFT的共轭对称分量<br>序列虚部×j的DFT是序列DFT的共轭反对称分量<br>序列共轭对称分量的DFT是序列DFT的实部<br>序列共轭反对称分量的DFT是序列DFT的虚部巧j<br>是不是像绕口令，但总比公式强多了。<br>这—切，意义何在?<br><strong>第一，从图形上可以淋漓尽致地体现DFT隐含的周期性。</strong><br><strong>第二，为DFT的简化运算提供了思路。</strong></p>
</li>
</ul>
<h5 id="4-Parseval定理"><a href="#4-Parseval定理" class="headerlink" title="4. Parseval定理"></a>4. Parseval定理</h5><p>有限长序列的能量：$\sum\limits_{n=0}^{N-1}|x(n)|^{2}=\dfrac{1}{N} \sum\limits_{k=0}^{N-1}|X(k)|^{2}$</p>
<h4 id="五-频域抽样"><a href="#五-频域抽样" class="headerlink" title="(五) 频域抽样"></a>(五) 频域抽样</h4><p>实际上，<font color="red"><strong>DFT就是频域抽样</strong></font>。包括三个问题，这三个问题环环相扣、层层推进。</p>
<h5 id="1-DFT与DTFT、z变换的关系"><a href="#1-DFT与DTFT、z变换的关系" class="headerlink" title="1. DFT与DTFT、z变换的关系"></a>1. DFT与DTFT、z变换的关系</h5><p>先从公式上看三个变换的关系，再结合z平面的单位圆的概念，从图形上理解。如下图:</p>
<img src="https://pic.imgdb.cn/item/61fa339a2ab3f51d91e2d239.jpg" style="zoom:70%">

<img src="https://pic.imgdb.cn/item/61fa33b52ab3f51d91e2eb74.jpg" style="zoom:70%">

<p>毫无疑问，DFT的自变量$k$为离散的，而DTFT的自变量$\omega$、以及z变换的自变量$z$都是连续变量。DFT是另外两种变换的离散采样值。因为这种采样是在频域，所以称为”频域采样“。</p>
<p>那么问题来啦：能否由离散频谱值$X(k)$得到$X(z)$和$X(e^{j\omega})$？</p>
<p>不管在那个域进行抽样，其数学本质都是用一些离散的数值代替原来连续变化的函数，或者说用一些离散的点代表原来连续的曲线。能不能代表取决于两个因素：一是这些离散的点的间隔，即抽样间隔；二是原来那条连续曲线的变化起伏程度，(<font color="red"><strong>频域抽样定理</strong></font>)。</p>
<h5 id="2-频域抽样定理"><a href="#2-频域抽样定理" class="headerlink" title="2. 频域抽样定理"></a>2. 频域抽样定理</h5><p>傅里叶分析方法的好处在于，建立起时域和频域的一种重要的对应关系：一个域离散抽样，另外一个域周期延拓。所以，研究时域抽样时，把问题对应到频域上去研究；那么现在研究频域抽样时，又要把问题对应到时域上去研究。毫无疑问，时域上会周期延拓。如下图：</p>
<img src="https://pic.imgdb.cn/item/61fa34a62ab3f51d91e3d3f7.jpg" style="zoom:70%">

<p>既然是以$N$为周期延拓，条件自然而然就出来了：</p>
<p>对于$M$点长的序列$x(n)$，频域抽样不失真的条件是：<font color="red"> <strong>一个周期内的频域抽样点数$N \geq M$</strong></font> ，此时有：<br>$$<br>x_N(n) = \sum_{r = -\infty}^{\infty}x(n+rN)R_N(n) = x(n)<br>$$<br>即满足该条件时，$N$个频率抽样值$X(k)$（即$x(n)$的$N$点DFT)能够完全代表$x(e^{j\omega})$及$X(z)$。</p>
<p>问题又来了，怎么表示?这就是第三个问题：频域的插值恢复。</p>
<h5 id="3-频域的插值恢复"><a href="#3-频域的插值恢复" class="headerlink" title="3. 频域的插值恢复"></a>3. 频域的插值恢复</h5><p>与时域抽样的恢复完全相同的思路，用离散的样本值乘以一个插值函数，得到一个连续的函数，只不过这里的插值函数是关于$\omega$或$z$的函数。下面的任务就是找这个函数$\varphi(w)$或$\varphi(z)$。</p>
<img src="https://pic.imgdb.cn/item/61fa365f2ab3f51d91e58cc6.jpg" style="zoom:70%">

<p>z变换的形式更为简洁，因此首先解决由$X(k)$得到$X(z)$的问题。<br>以下推导过程的大致思路：把z变换定义式中的$x(n)$用IDFT的公式替换，然后交换求和次序，再利用旋转因子的性质，即可得到。如下图：</p>
<img src="https://pic.imgdb.cn/item/61fa36922ab3f51d91e5bf47.jpg" style="zoom:70%">

<p>解决了由$X(k)$得到$X(z)$的问题，将$z$换成$e^{j\omega}$，自然就得到了$X(e^{j\omega})$。如下图：</p>
<img src="https://pic.imgdb.cn/item/61fa37172ab3f51d91e642e8.jpg" style="zoom:70%">

<p>把内插公式和内插函数总结如下图，这个内插函数的幅度部分的图形我们可以画出来，我们发现，它在一些固定的位置($\dfrac{2\pi}{N}$的整数倍处）是零，而$\dfrac{2\pi}{N}​$恰好是频域抽样时的间隔，这是巧合吗？显然不是，这是必然的。</p>
<img src="https://pic.imgdb.cn/item/61fa377b2ab3f51d91e6a274.jpg" style="zoom:70%">

<p>我们把内插公式展开来看，如下图所示。也就是说，把各个频域抽样值$X(k)$与做相应平移后的内插函数（平移$\dfrac{2\pi}N$的$k$倍）相乘，再相加，就得到连续的频谱函数$X(e^{j\omega})$。与第$k$个抽样值相乘的内插函数，在所有其他抽样点处刚好是零点，只有在第$k$个抽样点处的值不为零(值为1)。所以，重建后的这个连续函数，在每个抽样位置（也就是$\dfrac{2}{N}$的整数倍)上的值，就等于$X(k)$这一点的值，不需要任何其他抽样值参与;而在两个抽样点之间的值（没抽到的地方)，需要所有抽样值来参与共同构成。</p>
<img src="https://pic.imgdb.cn/item/61fa38172ab3f51d91e73dc1.jpg" style="zoom:70%">

<p>这个问题的理解，与“时域抽样后信号的重建”问题是一样的。但有的人可能会说，时域抽样后信号的重建，我记得是通过理想低通滤波器来推导出重建的内插公式，这里怎么不是呢?<br>如果你能提出这样的疑问，要表扬，说明你“信号与系统”学的不错。其实，图7和图8中的内插公式，完全可以用“时域抽样信号重建连续时间信号的内插公式”相同的推导方法推导出来。感兴趣的同学可以试一下哦。</p>
<h5 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：个人图书馆/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> </p>
<p><a href="http://www.360doc.com/content/19/0611/18/908538_841808337.shtml">http://www.360doc.com/content/19/0611/18/908538_841808337.shtml</a></p>
<p><a href="http://www.360doc.com/content/19/0611/18/908538_841808319.shtml">http://www.360doc.com/content/19/0611/18/908538_841808319.shtml</a></p>
<p><a href="http://www.360doc.com/content/19/0611/18/908538_841808298.shtml">http://www.360doc.com/content/19/0611/18/908538_841808298.shtml</a></p>
<p><a href="http://www.360doc.com/content/19/0611/18/908538_841808274.shtml">http://www.360doc.com/content/19/0611/18/908538_841808274.shtml</a></p>
<hr>
<h3 id="六、快速傅里叶变换FFT"><a href="#六、快速傅里叶变换FFT" class="headerlink" title="六、快速傅里叶变换FFT"></a>六、快速傅里叶变换FFT</h3><h4 id="一-改进DFT计算的方法"><a href="#一-改进DFT计算的方法" class="headerlink" title="(一) 改进DFT计算的方法"></a>(一) 改进DFT计算的方法</h4><h5 id="1-DFT计算量分析"><a href="#1-DFT计算量分析" class="headerlink" title="1. DFT计算量分析"></a>1. DFT计算量分析</h5><p>对于$N$点长的序列$x(n)$其DFT变换为<br>$$<br>正变换：X(k) = \text{DFT}[x(n)] = \sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi}{N}kn} = \sum_{n=0}^{N-1}x(n)W_N^{nk}<br>$$</p>
<p>$$<br>逆变换：x(n) = \text{IDFT}[X(k)] = \frac{1}{N}\sum_{k=0}^{N-1}X(k)e^{j\frac{2\pi}{N}kn} = \sum_{k=0}^{N-1}X(k)W_N^{-nk}<br>$$</p>
<p>DFT正反变换的运算方式和运算量是相同的，后面的分析以DFT正变换为例。</p>
<p>观察正变换和反变换的公式可知，二者的运算方式和运算量是完全相同的。下面的分析均以DFT正变换为例。(顺便说一句，大家要像熟悉自己的手机一样熟悉旋转因子，闭着眼睛都知道它)<br>观察DFT正变换的公式，容易看出：每计算一个点的数据，需要$N$次复数乘法、$N-1$次复数加法，所以$N$点DFT，需要$N$的平方次复数乘法，$N(N-1)$次复数加法。我们知道，DFT的点数，至少要取成序列的长度，当序列长度很长时，运算量巨大！如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">序列长度</th>
<th align="center">复数乘法$N^2$</th>
<th align="center">复数加法$N(N-1)$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">64</td>
<td align="center">56</td>
</tr>
<tr>
<td align="center">64</td>
<td align="center">4096</td>
<td align="center">4032</td>
</tr>
<tr>
<td align="center">1024</td>
<td align="center">1048576</td>
<td align="center">1047552</td>
</tr>
<tr>
<td align="center">2048</td>
<td align="center">4194304</td>
<td align="center">4192256</td>
</tr>
</tbody></table>
<p>以1024点为例，复数乘法的次数100万次之多。</p>
<p>1965年，库利(J.w.Cooley)和图基(J.W.Tukey)在《Mathmatics of Computation》上发表了《AnAlgorithm for the Machine Calculation of Complex Fourier Series》，提出一种DFT的快速算法，后人称为快速傅里叶变换(Fast Fourier Transform ——FFT)。</p>
<h5 id="2-改进DFT计算效率的基本途径"><a href="#2-改进DFT计算效率的基本途径" class="headerlink" title="2. 改进DFT计算效率的基本途径"></a>2. 改进DFT计算效率的基本途径</h5><img src="https://pic.imgdb.cn/item/61fa3b0a2ab3f51d91ea2f7a.jpg" style="zoom:70%">

<p>$N$点DFT，直接计算，需要$N$的平方次乘法；分成2个$\dfrac{N}{2}$点DFT分别计算，乘法的次数减少了一半；分成4个$\dfrac{N}{4}$点DFT，乘法的次数又减少了一半。如果能够继续下去，前景很让人向往。<br>为了能够一直分下去，我们限定$N$为2的整数次幂，即：$N=2^M$，称为<strong>基2FFT</strong>。由此可见，<font color="red"><strong>FFT的基本思想是：把长序列分成几个较短的序列</strong></font>。<br>但怎么分?不能随便分，基本原则：要保证这几个短序列的DFT组合起来后能够很方便地构成原来长序列的DFT。<br>所以，DFT快速算法要解决的两个核心问题是：<strong>怎么分？怎么合？</strong><br>根据分与合的方式不同，有两种基2FFT算法，分别称为:</p>
<ul>
<li>按时间抽取的FFT算法———Decimation-in-Time，简称DIT-FFT。</li>
<li>按频率抽取的FFT算法———Decimation-in-Frequency，简称DIF-FFT。</li>
</ul>
<p>下面我们分别来归纳总结两种基2FFT算法。</p>
<h4 id="二-两种基2FFT算法"><a href="#二-两种基2FFT算法" class="headerlink" title="(二) 两种基2FFT算法"></a>(二) 两种基2FFT算法</h4><h5 id="1-按时间抽取DIT-FFT算法"><a href="#1-按时间抽取DIT-FFT算法" class="headerlink" title="1. 按时间抽取DIT-FFT算法"></a>1. 按时间抽取DIT-FFT算法</h5><p>以第一次分解($N$点分为2个$\dfrac{N}{2}$点)为例来说明算法原理。<br>首先解决怎么分的问题。</p>
<img src="https://pic.imgdb.cn/item/61fa3c602ab3f51d91eb7188.jpg" style="zoom:70%">

<p>通俗地说，就是大家列队、报数（从0开始），报偶数的一组，奇数的一组。</p>
<img src="https://pic.imgdb.cn/item/61fa3c902ab3f51d91eba2c8.jpg" style="zoom:70%">

<p>然后解决怎么合的问题。<br>我们略过看似艰苦卓绝实际很简单的推导过程，直接上结论：</p>
<img src="https://pic.imgdb.cn/item/61fa3cbd2ab3f51d91ebcde6.jpg" style="zoom:70%">

<p>公式不好看，有人画了一幅图，并且起了个好听的名字：<strong>蝶形运算符号</strong>。<br>下面的动图演示了蝶形运算的过程:</p>
<img src="https://pic.imgdb.cn/item/61fa3fae2ab3f51d91ee90ff.gif">

<p>以8点长序列为例，我们来看分解为2个4点长DFT，是如何通过蝶形运算合成8点DFT的： </p>
<img src="https://pic.imgdb.cn/item/61fa3ff22ab3f51d91eecd84.gif">

<p>经过第一次分解之后，总的运算量=两个N/2点DFT的运算+N/2个蝶形的运算。而每次蝶形运算，只需要1次乘法，2次加法。所以，总的乘法次数为：<br>$$<br>\frac{N^2}{2}+\frac{N}{2} \approx \frac{N^2}{2}<br>$$<br>总加法次数为：<br>$$<br>N(\frac{N}{2}-1)+N \approx \frac{N^2}{2}<br>$$<br>当$N$很大时，运算量减少了近一半。</p>
<p>这就给了我们信心，说明这种分解思路是可以有效减少运算量的。我们继续分解下去，经过M-1次分解，分解为N/2 个 2 点长序列。</p>
<p>而2点DFT也用蝶形运算来表示（因为计算机最擅长一致而重复的东西），就得到下面的流图：</p>
<img src="https://pic.imgdb.cn/item/61fa40ce2ab3f51d91ef97a2.jpg">

<h5 id="2-按频率抽取DIF-FFT算法"><a href="#2-按频率抽取DIF-FFT算法" class="headerlink" title="2. 按频率抽取DIF-FFT算法"></a>2. 按频率抽取DIF-FFT算法</h5><p>仍以第一次分解（$N$点分为2个$\dfrac N2$点）为例来说明算法原理。</p>
<img src="https://pic.imgdb.cn/item/61fa41312ab3f51d91effcba.jpg" style="zoom:80%">

<p>以8点长序列为例，我们来看分解为2个4点长DFT，是如何通过蝶形运算合成8点DFT的： </p>
<img src="https://pic.imgdb.cn/item/61fa415c2ab3f51d91f02935.gif" style="zoom:120%">

<p>注意到，输出的频率数据，序号是按照偶数一组、奇数一组的顺序排列的，所以这种算法称为：按频率抽取。我们继续分解下去，经过$M-1$次分解，分解为$N/2$ 个 2 点长序列，就得到下面的流图：</p>
<img src="https://pic.imgdb.cn/item/61fa419d2ab3f51d91f0698d.jpg">

<h5 id="3-运算量分析"><a href="#3-运算量分析" class="headerlink" title="3. 运算量分析"></a>3. 运算量分析</h5><p>通过前面的分析可见，两种基2FFT算法，运算量是一样的，N点DFT，就分解成了若干个蝶形的运算而已。多少个蝶形呢？序列长度$N=2^M$，共有 $M$级蝶形，每级$\dfrac N2$个蝶形，共$\dfrac{MN}{2}$个。而每个蝶形是1次复数乘法，2次复数加法。所以总的运算量为：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">FFT</th>
<th align="center">DFT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">复数乘法</td>
<td align="center">$\dfrac{NM}{2} = \dfrac{N}{2}\log_2N$</td>
<td align="center">$N^2$</td>
</tr>
<tr>
<td align="center">复数加法</td>
<td align="center">$NM = N\log_2N$</td>
<td align="center">$N(N-1)$</td>
</tr>
</tbody></table>
<p>频率作为自然界的一个基本物理量，是很多领域研究的重要内容。人们很早就认识到，用DFT的方法可以有效进行信号的频率分析。但是因为DFT算法运算量很大，在数字计算机发明以前，运算效率普遍很低的情况下，DFT也更多的是一种理论分析工具，很难被用于实际的信号处理。</p>
<p>FFT的出现，破解了这一历史性难题，极大地促进了数字信号处理这门学科的应用和发展。有人甚至以FFT算法提出的1965年作为数字信号处理这门学科的诞生之年。</p>
<h5 id="4-算法特点"><a href="#4-算法特点" class="headerlink" title="4. 算法特点"></a>4. 算法特点</h5><p>在计算机看来，这两种算法是非常相像的。两者互为转置。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">DIF-FFT</th>
<th align="center">DIF-FFT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同址运算</td>
<td align="center">将蝶形运算的结果仍然保存在原输入量的存储单元中</td>
<td align="center">将蝶形运算的结果仍然保存在原输入量的存储单元中</td>
</tr>
<tr>
<td align="center">输入/输出顺序</td>
<td align="center">输入倒位序,输出自然顺序</td>
<td align="center">输入自然顺序，输出倒位序</td>
</tr>
<tr>
<td align="center">蝶形运算</td>
<td align="center">先乘旋转因子，后加减第$m$级节点间距离:$2^{m-1}$</td>
<td align="center">先加减，后乘旋转因子第$m$级节点间距离:$2^{L-m}$</td>
</tr>
</tbody></table>
<p>首先来看第一个特点：同址运算（又称同位运算或原位运算），每完成一个蝶形运算，输入的两个数据就没有用的，这就意味着，不需要再重新开辟新的存储单元来保存输出数据，计算结果仍保留在原输入数据占据的存储单元即可。</p>
<p>再来看第二个特点：输入/输出数据的顺序。这是两种算法的不同之处。以DIT-FFT为例来说明为什么会输入倒位序。</p>
<p>还是以8点长数据为例，输入数据的正常顺序是$x(0)、x(1)、x(2)……x(7)$，我们称之为 自然顺序。按照序号的奇偶分为两组，第一组是$x(0)、x(2)、x(4)、x(6)$，第二组是$x(1)、x(3)、x(5)、x(7)$。每个新的组再重新排队报数，按奇偶分，第一组又分成两个组，分别是$x(0)、x(4)$和$x(2)、x(6)$，第二组分成两个组，分别是$x(1)、x(5)$和$x(3)、x(7)$。</p>
<p>也就是说，8点长序列的DIT-FFT，输入数据的顺序是：$x(0)、x(4)、x(2)、x(6)、x(1)、x(5)、x(3)、x(7)$。这个序号的顺序乍看杂乱无章，其实有规律性。0、1、2、3、4、5、6、7的顺序与0、4、2、6、1、3、5、7有何关系的呢？用二进制来写一目了然，看下面的动图：</p>
<img src="https://pic.imgdb.cn/item/61fa439a2ab3f51d91f24b96.gif">

<p>倒位序，是将二进制数的最高有效位到最低有效位的位序进行颠倒排列而得到的二进制数。 </p>
<p>DIT-FFT算法中，对时域序列按照序号的奇偶进行分解，造成输入序列的序号按照倒位序排列。</p>
<p>最后再说一说蝶形运算的规律。两种FFT算法，最终都是转换成了M列、每列N/2个、一共MN/2个蝶形运算。但二者蝶形运算的规律有差异。</p>
<ul>
<li>第一个差异：基本蝶形不同。DIT是先乘旋转因子，再加或减；而DIF是先加或减，再乘旋转因子。</li>
<li>第二个差异：两种算法，蝴蝶翅膀的距离（即节点间的距离）和旋转因子的数目恰好相反。</li>
</ul>
<p>仔细观察两种算法的流图，我们会发现，二者互为转置。</p>
<h4 id="三-其他FFT算法简介"><a href="#三-其他FFT算法简介" class="headerlink" title="(三) 其他FFT算法简介"></a>(三) 其他FFT算法简介</h4><h5 id="1-混合基FFT"><a href="#1-混合基FFT" class="headerlink" title="1. 混合基FFT"></a>1. 混合基FFT</h5><img src="https://pic.imgdb.cn/item/61fa445b2ab3f51d91f30d11.png" style="zoom:80%">

<h5 id="2-Chirp-z变换"><a href="#2-Chirp-z变换" class="headerlink" title="2. Chirp-z变换"></a>2. Chirp-z变换</h5><p>实际应用中，有时只对信号的某一频段感兴趣，即只需要计算单位圆上某一段的频谱值，而不需要计算[0，Π]区间的所有频谱采样值。此时，可以用”Chirp-z变换“（CZT）。</p>
<p>适用场合：窄带信号的DFT。</p>
<h5 id="3-Goertzel算法"><a href="#3-Goertzel算法" class="headerlink" title="3. Goertzel算法"></a>3. Goertzel算法</h5><p>在某些应用场合，只需计算很少几个频率点的频谱值。例如，双音多频信号（DTMF）的检测。此时可以采用卡泽尔（Goertzel）算法。</p>
<p>除此之外，傅里叶变换的快速算法还有很多种。不过应用最广泛的依然能是基2FFT算法，它是数字信号处理最经典算法之一，几乎各种主流的计算机编程语言都有现成的函数可以调用。不同型号的芯片，硬件开发商也都会给出优化后的FFT算法源代码，一般情况下直接调用就可以。</p>
<h5 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：个人图书馆/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> <a href="http://www.360doc.com/content/19/0611/18/908538_841808253.shtml">http://www.360doc.com/content/19/0611/18/908538_841808253.shtml</a></p>
<hr>
<h3 id="七、FFT算法的应用"><a href="#七、FFT算法的应用" class="headerlink" title="七、FFT算法的应用"></a>七、FFT算法的应用</h3><h5 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h5><p><strong>文章转自：个人图书馆/未注明作者，感谢原作者的辛勤付出，如涉及版权，请联系我删除！</strong> </p>
<p><a href="http://www.360doc.com/content/19/0611/18/908538_841808231.shtml">http://www.360doc.com/content/19/0611/18/908538_841808231.shtml</a></p>
<p><a href="http://www.360doc.com/content/19/0611/18/908538_841808103.shtml">http://www.360doc.com/content/19/0611/18/908538_841808103.shtml</a></p>
<hr>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>信号与系统</category>
      </categories>
      <tags>
        <tag>数字信号</tag>
        <tag>频谱分析</tag>
      </tags>
  </entry>
  <entry>
    <title>概率基础系统学习</title>
    <url>/2022/02/12/Probabilistic-Basic-Systems-Learning/</url>
    <content><![CDATA[<div class="bvideo">
    <a href="//www.bilibili.com/video/BV1ot411y7mU" target="_blank">
        <div class="bvideo-box">
            <div class="bvideo-cover">
                <div class="cover-default"></div>
                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/0ccbc2307d31f9fe6d0877ac025a729333823ed8.jpg)">
                    <i class="icon-video"></i>
                </div>
                <span class="duration">65:24:09</span>
            </div>
            <div class="bvideo-info">
                <p class="title">《概率论与数理统计》教学视频全集（宋浩）</p>
                <p class="card-status">
                    <span class="play-num">
                        <i class="fa fa-youtube-play"></i>
                        <span>1912.3万</span></span>
                    <span>
                        <i class="fa fa-list-alt"></i>
                        <span>59.9万</span></span></p>
                <div class="partition">
                    <label class="card-label">视频</label>
                    <label class="up-label"></label>
                    <label class="up-name">宋浩老师官方</label>
                </div>
                <div class="actions hide"></div>
            </div>
        </div>
    </a>
</div>

<h2 id="第一章-随机事件及其概率"><a href="#第一章-随机事件及其概率" class="headerlink" title="第一章 随机事件及其概率"></a>第一章 随机事件及其概率</h2><h3 id="1-1-随机事件"><a href="#1-1-随机事件" class="headerlink" title="1.1 随机事件"></a>1.1 随机事件</h3><h4 id="1-1-1-随机试验与随机事件"><a href="#1-1-1-随机试验与随机事件" class="headerlink" title="1.1.1 随机试验与随机事件"></a>1.1.1 随机试验与随机事件</h4><ul>
<li><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5></li>
</ul>
<p><strong>随机实验：</strong>① 在相同条件下可重复；② 实验结果不只有一个；③ 无法预测。</p>
<p><strong>事件：</strong>随机实验的每一种结果就称为一个事件。</p>
<p><strong>基本事件：</strong>相对于实验目的不可以再分的事件称为基本事件。</p>
<p><strong>复合事件：</strong>几个基本事件的复合。</p>
<p><strong>必然事件：</strong>一定会发生的事件，使用符号$\Omega$表示(全集)。</p>
<p><strong>不可能事件：</strong>一定不会发生的事件，使用符号$\phi$表示(空集)。</p>
<h4 id="1-1-2-样本空间与事件的集合表示"><a href="#1-1-2-样本空间与事件的集合表示" class="headerlink" title="1.1.2 样本空间与事件的集合表示"></a>1.1.2 样本空间与事件的集合表示</h4><ul>
<li><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5></li>
</ul>
<p><strong>样本空间：</strong>所有基本事件的集合，用$\Omega$表示(把样本点是看作一个整体，就可以说样本空间在每次试验中都出现了，因而<strong>样本空间是随机试验的必然事件</strong> )</p>
<p><strong>样本点：</strong>样本空间的元素，使用$\omega$表示。</p>
<h4 id="1-1-3-事件间的关系"><a href="#1-1-3-事件间的关系" class="headerlink" title="1.1.3 事件间的关系"></a>1.1.3 事件间的关系</h4><h5 id="一、事件之间的关系"><a href="#一、事件之间的关系" class="headerlink" title="一、事件之间的关系"></a>一、事件之间的关系</h5><p>1、包含——$\boldsymbol {\subseteq}$</p>
<p>$A \subseteq B$：A发生必然导致B发生。</p>
<p>一定存在的包含关系：$\phi \subseteq A \subseteq \Omega$</p>
<p>2、相等——$\boldsymbol  =$</p>
<p>$A = B$：A事件和B事件相等，即$A \subseteq  B$ AND $B \subseteq A$。</p>
<p>3、并/和——$\boldsymbol  \cup $</p>
<p>$A \cup B = A+B$：A、B中至少有一个发生。</p>
<p>4、交/积——$\boldsymbol \cap$</p>
<p>$A \cap B = AB$：A、B同时发生。</p>
<p>5、差——$\boldsymbol  -$</p>
<p>$A-B$：A发生而B不发生。</p>
<p>$A - B = A - AB = A \bar B$</p>
<p>6、互不相容事件</p>
<p>$AB = \phi$：A、B不会同时发生。</p>
<p>7、对立事件</p>
<p>$A = \bar B$：A、B互不相容$AB = \phi$，且$A \cup B = \Omega$。</p>
<p>8、完备事件组</p>
<p>$A_1,A_2,…,A_n$两两互不相容，且$\bigcup\limits_{i=1}^n = \Omega$</p>
<h5 id="二、集合的运算关系"><a href="#二、集合的运算关系" class="headerlink" title="二、集合的运算关系"></a>二、集合的运算关系</h5><p>1、交换律：$A \cup B = B \cup A$，$A \cap B = B \cap A$</p>
<p>2、结合律：$(A \cup B) \cup C = A \cup (B \cup C)$，$(A \cap B) \cap C = A \cap (B \cap C)$</p>
<p>3、分配率：$(A\cup B) \cap C = (A \cap C) \cup (B \cap C)$，$(A \cap B) \cup C = (A \cup C) \cap (B \cup C)$</p>
<p>4、对偶率：$\overline{A \cup B} = \bar A \cap \bar B$，$\overline{A \cap B} = \bar A \cup \bar B$</p>
<p>$\overline{A_1 \cup A_2 \cup \cdots \cup A_n} = \bar A_1 \cap \bar A_2 \cap \cdots \cap A_n$，$\overline{A_1 \cap A_2 \cap \cdots \cap A_n} = \bar A_1 \cup \bar A_2 \cup \cdots \cup A_n$</p>
<h3 id="1-2-事件的概率"><a href="#1-2-事件的概率" class="headerlink" title="1.2 事件的概率"></a>1.2 事件的概率</h3><h4 id="1-2-1-概率的初等描述"><a href="#1-2-1-概率的初等描述" class="headerlink" title="1.2.1 概率的初等描述"></a>1.2.1 概率的初等描述</h4><p><strong>概率：</strong>随机事件出现的可能性大小。 常用$P(A)$ 表示A事件出现的概率。</p>
<h4 id="1-2-2-古典概率模型"><a href="#1-2-2-古典概率模型" class="headerlink" title="1.2.2 古典概率模型"></a>1.2.2 古典概率模型</h4><h5 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h5><p>古典概率模型要求：有限个样本点(e.g. 掷一枚骰子只有有六种可能)且所有样本点出现的可能性是<strong>相等的</strong>，则古典概率中事件A的概率为：<br>$$<br>P(A) = \frac{A中包含的基本事件个数}{\Omega中包含的基本事件个数}<br>$$</p>
<h5 id="二、排列组合的基础知识"><a href="#二、排列组合的基础知识" class="headerlink" title="二、排列组合的基础知识"></a>二、排列组合的基础知识</h5><p>……</p>
<h5 id="三、古典概率模型的性质"><a href="#三、古典概率模型的性质" class="headerlink" title="三、古典概率模型的性质"></a>三、古典概率模型的性质</h5><p>1、非负性：$0 \leq P(A) \leq 1$；</p>
<p>2、规范性：$P(\Omega) = 1，P(\phi) = 0$；</p>
<p>3、有限可加：$A_1, A_2, \cdots ,A_n $互不相容，则有$P(A_1+A_2+ \cdots +A_n) = P(A_1)+P(A_2)+ \cdots +P(A_n) $；</p>
<h4 id="1-2-3-几何概率模型"><a href="#1-2-3-几何概率模型" class="headerlink" title="1.2.3 几何概率模型"></a>1.2.3 几何概率模型</h4><h5 id="一、定义-1"><a href="#一、定义-1" class="headerlink" title="一、定义"></a>一、定义</h5><p>几何概型是一种概率模型。在这个模型下，随机实验所有可能的结果是无限的，并且每个基本结果发生的概率是相同的。例如一个人到单位的时间可能是8:00~9:00之间的任意一个时刻；往一个方格中投一个石子，石子落在方格中任何一点上……这些试验出现的结果都是无限多个，属于几何概型。一个试验是否为几何概型在于这个试验是否具有几何概型的两个特征——无限性和等可能性，只有同时具备这两个特点的概型才是几何概型。 </p>
<h5 id="二、性质"><a href="#二、性质" class="headerlink" title="二、性质"></a>二、性质</h5><p>1、完全可加性：$A_1, A_2, \cdots ,A_n $互不相容，则有$P(\bigcup\limits_{i=1}^{\infty}A_i) = \sum\limits_{i=1}^{\infty}A_i $；</p>
<h5 id="三、古典概率模型与几何概率模型的区别"><a href="#三、古典概率模型与几何概率模型的区别" class="headerlink" title="三、古典概率模型与几何概率模型的区别"></a>三、古典概率模型与几何概率模型的区别</h5><p>古典概型的基本事件都是有限的，概率为事件所包含的基本事件除以总基本事件个数。 几何概型的基本事件通常不可计数，只能通过一定的测度，像长度，面积，体积的的比值来表示。 </p>
<h5 id="四、随机模拟-蒙特卡洛法："><a href="#四、随机模拟-蒙特卡洛法：" class="headerlink" title="四、随机模拟/蒙特卡洛法："></a>四、随机模拟/蒙特卡洛法：</h5><p>1、基本思想</p>
<p>蒙特卡罗方法是一种计算方法。原理是通过大量随机样本，去了解一个系统，进而得到所要计算的值。 </p>
<p>蒙特卡洛法的基本思想是：为了求解问题，首先建立一个概率模型或随机过程，使它的参数或数字特征等于问题的解；然后通过对模型或过程的观察或抽样试验来计算这些参数或数字特征，最后给出所求解的近似值。解的精确度用估计值的标准误差来表示。蒙特卡洛法的主要理论基础是概率统计理论，主要手段是随机抽样、统计试验。 </p>
<p>2、求解问题的基本步骤 </p>
<ul>
<li>根据实际问题的特点，构造简单而又便于实现的概率统计模型，使所求的解恰好是所求问题的概率分布或数学期望；</li>
<li>给出模型中各种不同分布随机变量的抽样方法；</li>
<li>统计处理模拟结果，给出问题解的统计估计值和精度估计值。</li>
</ul>
<p>3、例子：$\pi$的计算</p>
<p>正方形内部有一个相切的圆，它们的面积之比是$\dfrac{\pi}{4}$。 </p>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9naW1nL2Fzc2V0LzIwMTUvYmcyMDE1MDcyNjExLmpwZw?x-oss-process=image/format,png" style="zoom:70%">

<p>现在，在这个正方形内部，随机产生10000个点（即10000个坐标对 (x, y)），计算它们与中心点的距离，从而判断是否落在圆的内部。 </p>
<img src="https://pic.imgdb.cn/item/620cb0fe2ab3f51d910c4f91.jpg" style="zoom:40%">

<p>如果这些点均匀分布，那么圆内的点应该占到所有点的$\dfrac{\pi}{4}$，因此将这个比值乘以4，就是π的值。通过R语言脚本随机模拟30000个点，π的估算值与真实值相差0.07%。 </p>
<h4 id="1-2-4-频率与概率"><a href="#1-2-4-频率与概率" class="headerlink" title="1.2.4 频率与概率"></a>1.2.4 频率与概率</h4><h5 id="一、频率"><a href="#一、频率" class="headerlink" title="一、频率"></a>一、频率</h5><p>1、定义：做了n次实验，事件A发生了m次，则定义频率为$\omega_n(A) = \dfrac{m}{n}$。</p>
<p>2、性质：</p>
<ul>
<li>非负性——$0 \leq \omega_n(A) \leq 1$；</li>
<li>规范性——$\omega_n(必然事件) = \omega_n(\Omega) = 1$，$\omega_n(不可能事件) = \omega_n(\phi) = 0$；</li>
<li>可加性——设事件$A_1, \cdots, A_k$两两互不相容，则有$\omega_n(A_1 + \cdots +A_k) = \omega_n(A_1)+\cdots + \omega_n(A_k)$；</li>
</ul>
<h5 id="二、概率"><a href="#二、概率" class="headerlink" title="二、概率"></a>二、概率</h5><p>(PS：这里主要是讲频率与概率的关系)</p>
<p>概率可以视为事件的一个属性，先于实验而存在，不随实验的变换而变化，随着实验次数的增加，频率逐渐接近概率。</p>
<h4 id="1-2-5-概率的公理化"><a href="#1-2-5-概率的公理化" class="headerlink" title="1.2.5 概率的公理化"></a>1.2.5 概率的公理化</h4><h5 id="一、概率的定义方法"><a href="#一、概率的定义方法" class="headerlink" title="一、概率的定义方法"></a>一、概率的定义方法</h5><p>描述概率定义、古典概率定义、几何概率定义、统计概率定义</p>
<p>以上这四种定义的概率都有公共的3种性质：① 非负性；② 规范性；③ 可加性；</p>
<h5 id="二、概率的公理化定义"><a href="#二、概率的公理化定义" class="headerlink" title="二、概率的公理化定义"></a>二、概率的公理化定义</h5><p>1、首先提炼出3条公理</p>
<p><strong>公理1(非负性)：</strong>$0 \leq P(A) \leq 1$</p>
<p><strong>公理2(规范性)：</strong>$P(\Omega) = 1$，注意——公理2中没有定义$P(\phi) = 0$</p>
<p><strong>公理3(完全可加性)：</strong>若事件$A_1, A_2, \cdots $不相容，则$P(A_1+A_2+ \cdots) = P(A_1)+P(A_2)+ \cdots$</p>
<blockquote>
<p><strong>可加性性质：有限可加性，可列可加性，完全可加性</strong></p>
<p>其中：可列可加性=完全可加性</p>
<p>可列可加性的理解可能要深入<strong>测度论</strong>的学习</p>
</blockquote>
<p>2、从3条公理推导其他性质</p>
<p><strong>性质1：</strong>$P(\phi) = 0$</p>
<blockquote>
<p>证明：将$\Omega$写为$\Omega = \Omega + \phi + \phi + \phi + \cdots$，易知它们之间互不相容，则有<br>$P(\Omega) = P(\Omega + \phi + \phi + \phi + \cdots) = P(\Omega) + P(\phi) + P(\phi) + \cdots$<br>两边同时减去$P(\Omega)$，则有$0 = P(\phi) + P(\phi) + \cdots$<br>又知$0 \leq P(A) \leq 1$，故$P(\phi) = 0$，得证！</p>
</blockquote>
<p><strong>性质2：</strong>有限可加性——本性质说明完全可加性可以推出有限可加性</p>
<p>若事件$A_1, A_2, \cdots ,A_n$不相容，则$P(A_1+A_2+ \cdots +A_n) = P(A_1)+P(A_2)+ \cdots + P(A_n)$</p>
<blockquote>
<p>证明：$A_1, A_2, \cdots, A_n, \phi + \phi + \phi + \cdots$，易知它们之间互不相容，则有<br>$P(A_1 + A_2 + \cdots + A_n) = P(A_1 + A_2 + \cdots + A_n + \phi + \phi + \phi + \cdots) = P(A_1) + P(A_2) + \cdots + P(A_n)+P(\phi) + P(\phi) + \cdots$<br>又由性质1可知$P(\phi) = 0$，则有$P(A_1 + A_2 + \cdots + A_n) =P(A_1) + P(A_2) + \cdots + P(A_n)$</p>
</blockquote>
<p><strong>性质3：</strong>$P(\bar A) = 1 - P(A)$</p>
<p><strong>性质4：</strong></p>
<p>—— ① $P(A-B) = P(A) - P(AB)$</p>
<p>—— ② $B \subset A, P(A-B) = P(A) - P(B) ,且P(A) \geq P(B)$</p>
<blockquote>
<p>证明①：易知$A = (A-B) \cup AB$，$A-B$与$AB$是互不相容的，则有<br>$P(A) = P(A-B) + P(AB)$，移项得证。</p>
<p>证明②：略</p>
</blockquote>
<p><strong>性质5(加法性质)：</strong>$P(A + B) = P(A) + P(B) - P(AB)$</p>
<blockquote>
<p>证明：略</p>
</blockquote>
<h3 id="1-3-条件概率与乘法公式"><a href="#1-3-条件概率与乘法公式" class="headerlink" title="1.3 条件概率与乘法公式"></a>1.3 条件概率与乘法公式</h3><h4 id="1-3-1-条件概率"><a href="#1-3-1-条件概率" class="headerlink" title="1.3.1 条件概率"></a>1.3.1 条件概率</h4><h5 id="一、定义-2"><a href="#一、定义-2" class="headerlink" title="一、定义"></a>一、定义</h5><p>样本空间为$\Omega$，A、B两个事件，$P(B) &gt; 0$，在B已经发生的条件下A发生的概率叫做A对B的条件概率，记为：$P(A|B)$</p>
<h5 id="二、计算"><a href="#二、计算" class="headerlink" title="二、计算"></a>二、计算</h5><p>$P(A|B) = \dfrac{P(AB)}{P(B)}$</p>
<h4 id="1-3-2-乘法公式"><a href="#1-3-2-乘法公式" class="headerlink" title="1.3.2 乘法公式"></a>1.3.2 乘法公式</h4><p>由条件概率可以推导得：</p>
<p>$P(AB) = P(B)P(A|B) = P(A)P(B|A)$</p>
<p><strong>推广：</strong>$P(A_1 A_2 \cdots A_n) = P(A_1)P(A_2|A_1)P(A_3|A_1 A_2) \cdots P(A_n | A_1 A_2 \cdots A_{n-1})$</p>
<h3 id="1-4-全概率公式与贝叶斯公式"><a href="#1-4-全概率公式与贝叶斯公式" class="headerlink" title="1.4 全概率公式与贝叶斯公式"></a>1.4 全概率公式与贝叶斯公式</h3><h4 id="1-4-1-全概率公式"><a href="#1-4-1-全概率公式" class="headerlink" title="1.4.1 全概率公式"></a>1.4.1 全概率公式</h4><h5 id="一、定义-3"><a href="#一、定义-3" class="headerlink" title="一、定义"></a>一、定义</h5><p>假设$A_1, A_2, \cdots, A_n$是实验E的完备事件组(实际中不一定是完备的，只要能把事件B全部包括进去就行)，则对于某一事件B有：<br>$$<br>P(B) = \sum_{i=1}^{n}P(A_i)P(B|A_i)<br>$$<br><img src="https://pic.imgdb.cn/item/620f368d2ab3f51d919636fb.jpg" style="zoom:40%"></p>
<h4 id="1-4-2-贝叶斯公式"><a href="#1-4-2-贝叶斯公式" class="headerlink" title="1.4.2 贝叶斯公式"></a>1.4.2 贝叶斯公式</h4><h5 id="一、定义-4"><a href="#一、定义-4" class="headerlink" title="一、定义"></a>一、定义</h5><p>假设$A_1, A_2, \cdots, A_n$是实验E的完备事件组，则对于某一事件B有：<br>$$<br>P(A_k | B) = \frac{P(A_k B)}{P(B)} = \frac{P(A_k B)的乘法公式}{P(B)的全概率公式} = \frac{P(A_k)P(B|A_k)}{\sum\limits_{i = 1}^{n}P(A_i)P(B|A_i)}<br>$$<br>其中，$P(A_i)$称为<font color="red"><strong>先验概率</strong></font>，$P(A_i | B)$称为<font color="red"><strong>后验概率</strong></font> </p>
<h5 id="二、与全概率公式的辨析"><a href="#二、与全概率公式的辨析" class="headerlink" title="二、与全概率公式的辨析"></a>二、与全概率公式的辨析</h5><p>全概率公式是<font color="red"><strong>由因求果</strong></font></p>
<p>贝叶斯公式是<font color="red"><strong>由果溯因</strong></font></p>
<h3 id="1-5-事件的独立性与伯努利概型"><a href="#1-5-事件的独立性与伯努利概型" class="headerlink" title="1.5 事件的独立性与伯努利概型"></a>1.5 事件的独立性与伯努利概型</h3><h4 id="1-5-1-事件的独立性"><a href="#1-5-1-事件的独立性" class="headerlink" title="1.5.1 事件的独立性"></a>1.5.1 事件的独立性</h4><h5 id="一、定义-5"><a href="#一、定义-5" class="headerlink" title="一、定义"></a>一、定义</h5><p>A事件发生的概率不受B事件发生与否的影响，用公式可以表述为：$P(A|B) = P(A)$，或者说：<br>$$<br>P(AB) = P(A)P(B)<br>$$<br><strong>推论：</strong></p>
<p>① $\phi,\Omega$与任意事件均独立；</p>
<p>② 若A与B相互独立，则$\bar A 与 B$、$A 与 \bar B$、$\bar A 与 \bar B$也相互独立；</p>
<p>③ 若事件A满足$P(A) = 0 或 P(A) = 1$，则事件A与任意事件都独立；(注意：事件的概率等于0或者1不一定就是空集$\phi$或者全集$\Omega$) </p>
<p>证明略。。。</p>
<h5 id="二、独立与互不相容-互斥-辨析"><a href="#二、独立与互不相容-互斥-辨析" class="headerlink" title="二、独立与互不相容(互斥)辨析"></a>二、独立与互不相容(互斥)辨析</h5><p>1、从定义来讲：</p>
<p>A与B不相容，是$P(AB) = \phi$</p>
<p>A与B独立，是$P(AB) = P(A)P(B)$</p>
<p>2、通俗来讲：</p>
<p>A、B不相容是A发生了，B就一定不能发生，反之亦然；</p>
<p>A、B相互独立是A是否发生并不影响事件A发生的概率，所以A发生了B也可能会发生。 </p>
<p>3、推论：</p>
<p>当$P(A) &gt; 0$、$P(B) &gt; 0$时，互不相容与独立不会同时发生。</p>
<h5 id="三、补充知识——对立"><a href="#三、补充知识——对立" class="headerlink" title="三、补充知识——对立"></a>三、补充知识——对立</h5><p>最后再说一下对立事件，对立是指A、B必然发生一个且仅有一个发生，比如今天下雨或者不下雨，<strong>对立一定互不相容(互斥)，但是互不相容不一定对立</strong></p>
<h4 id="1-5-2-伯努利模型"><a href="#1-5-2-伯努利模型" class="headerlink" title="1.5.2 伯努利模型"></a>1.5.2 伯努利模型</h4><h5 id="一、几个相关概念"><a href="#一、几个相关概念" class="headerlink" title="一、几个相关概念"></a>一、几个相关概念</h5><p>1、独立实验序列：实验$E_1,E_2, \cdots, E_n$相互独立；</p>
<p>2、N重独立实验：把一个实验做N次，每次都是相互独立的；</p>
<p>3、伯努利实验：实验结果只有两种的实验(e.g. 硬币的正反)</p>
<p>4、N重伯努利实验：重复做N次实验，每次实验都相互独立，且实验的结果只有两种的实验。</p>
<h5 id="二、定义"><a href="#二、定义" class="headerlink" title="二、定义"></a>二、定义</h5><p>在伯努利实验模型中，事件A发生的概率是$P$，则$\bar A$的概率为$1-P$，那么在N重伯努利实验中，事件A发生k次的概率为：<br>$$<br>P_N(k) = C_N^k P^k (1-P)^{N-k}<br>$$<br>上面的公式又称为二项概率公式。</p>
<h2 id="第二章-随机变量及其分布"><a href="#第二章-随机变量及其分布" class="headerlink" title="第二章 随机变量及其分布"></a>第二章 随机变量及其分布</h2><h3 id="2-1-随机变量的概念"><a href="#2-1-随机变量的概念" class="headerlink" title="2.1 随机变量的概念"></a>2.1 随机变量的概念</h3><h5 id="一、定义-6"><a href="#一、定义-6" class="headerlink" title="一、定义"></a>一、定义</h5><p><font color="red"><strong>重点：随机变量的本质是函数——样本点的函数</strong></font></p>
<p>设$X(w)$是定义在概率空间$(\Omega, \mathscr{F}, P)$上的单值实函数(也就是说它的自变量就是一个个的样本点，因变量是实函数)，如果对直线上任意一博雷尔点集$B$，有$\begin{Bmatrix} \omega, X(\omega) \in B \end{Bmatrix} \subset \mathscr{F}$则称$X(\omega)$为随机变量(r.v.)。</p>
<h5 id="二、表示"><a href="#二、表示" class="headerlink" title="二、表示"></a>二、表示</h5><p>有了随机变量的概念，我们就可以将一个事件表示为：$\begin{Bmatrix} \omega | X(\omega) = a \end{Bmatrix}$，简记为$\begin{Bmatrix} X = a \end{Bmatrix}$，此时事件的概率可表示为：<br>$$<br>P(X=a)<br>$$<br>为了理解其本质，我将上面的简写形式的完整形式写在下面：<br>$$<br>P(X=a) = P(\begin{Bmatrix} \omega | X(\omega) = a \end{Bmatrix})<br>$$</p>
<h5 id="三、分类"><a href="#三、分类" class="headerlink" title="三、分类"></a>三、分类</h5><p>1、离散型随机变量：变量是离散的，且满足<strong>个数有限</strong>或者<strong>无限但可列</strong>；</p>
<p>2、连续性随机变量：变量是连续的。</p>
<h3 id="2-2-随机变量的分布"><a href="#2-2-随机变量的分布" class="headerlink" title="2.2 随机变量的分布"></a>2.2 随机变量的分布</h3><h4 id="2-2-1-离散型随机变量及其概率分布"><a href="#2-2-1-离散型随机变量及其概率分布" class="headerlink" title="2.2.1 离散型随机变量及其概率分布"></a>2.2.1 离散型随机变量及其概率分布</h4><h5 id="一、定义-7"><a href="#一、定义-7" class="headerlink" title="一、定义"></a>一、定义</h5><p>离散随机变量X的取值为$x_k(k = 1,2, \cdots)$，其概率为$P(X = x_k) = p_k$，则其称为随机变量的概率分布。</p>
<h4 id="2-2-2-连续型随机变量及其概率密度函数"><a href="#2-2-2-连续型随机变量及其概率密度函数" class="headerlink" title="2.2.2 连续型随机变量及其概率密度函数"></a>2.2.2 连续型随机变量及其概率密度函数</h4><p>关于概率分布与概率密度的具体细节，参见自己的博客文章**”概率基础概念本质的辨析理解_三、概率函数P(x)、概率分布函数F(x)、概率密度函数f(x)”部分**</p>
<h4 id="2-2-3-随机变量的分布函数"><a href="#2-2-3-随机变量的分布函数" class="headerlink" title="2.2.3 随机变量的分布函数"></a>2.2.3 随机变量的分布函数</h4><p>关于概率分布与概率密度的具体细节，参见自己的博客文章**”概率基础概念本质的辨析理解_三、概率函数P(x)、概率分布函数F(x)、概率密度函数f(x)”部分**</p>
<h3 id="2-3-常见随机变量的分布"><a href="#2-3-常见随机变量的分布" class="headerlink" title="2.3 常见随机变量的分布"></a>2.3 常见随机变量的分布</h3><h4 id="2-3-1-常见离散型随机变量的分布"><a href="#2-3-1-常见离散型随机变量的分布" class="headerlink" title="2.3.1 常见离散型随机变量的分布"></a>2.3.1 常见离散型随机变量的分布</h4><h5 id="一、0-1分布"><a href="#一、0-1分布" class="headerlink" title="一、0-1分布"></a>一、0-1分布</h5><p>0-1分布是指随机变量X的取值只有0或1，其用公式表示为：<br>$$<br>P(X = k) = p^k (1-p)^{1-k},(k = 0, 1)<br>$$</p>
<h5 id="二、几何分布"><a href="#二、几何分布" class="headerlink" title="二、几何分布"></a>二、几何分布</h5><p>设事件A的发生概率是$P(A) = p$，则重复做实验，在第k次的时候<strong>A首次发生</strong>的概率即为几何分布，记为$X \sim G(p)$<br>$$<br>P(X=k) = (1-p)^{k-1}p<br>$$</p>
<h5 id="三、二项分布"><a href="#三、二项分布" class="headerlink" title="三、二项分布"></a>三、二项分布</h5><p>设事件A的发生概率是$P(A) = p$，则重复做n次实验事件A发生k次的概率即为二项分布，记为$X \sim B(n, p)$<br>$$<br>P(X = k) = C_n^k p^k (1-p)^{n-k}<br>$$</p>
<h5 id="四、泊松分布"><a href="#四、泊松分布" class="headerlink" title="四、泊松分布"></a>四、泊松分布</h5><p>假设在一定时间间隔 (interval)中一个事件可能会发生0,1,2,…次，在一个间隔中平均发生事件的次数由$λ$决定，  $\lambda$ 是事件发生比率 (event rate)。在一定时间间隔中发生k次事件的概率如下，记为$X \sim P(\lambda)$<br>$$<br>P(X=k) = \frac{\lambda^k}{k!}e^{-\lambda},(\lambda &gt; 0, k = 0,1,2,\cdots)<br>$$<br><strong>泊松定理：</strong>n重伯努利实验中，如果$n→\infty，np→\lambda$。</p>
<ul>
<li><strong>二项分布可以用泊松分布来近似</strong><ul>
<li>条件：当二项分布中n比较大，p比较小，np的值适中，则可以用泊松分布来近似计算二项分布；</li>
<li>具体：$n \geq 100, np \leq 10$，此时泊松分布中$\lambda = np$。</li>
</ul>
</li>
</ul>
<h5 id="五、超几何分布"><a href="#五、超几何分布" class="headerlink" title="五、超几何分布"></a>五、超几何分布</h5><p>假设N个元素，其中$N_1$个属于第一类，$N_2$个属于第二类，那么从中任意取n个则其中属于第一类的个数为k的概率为超几何分布，<br>$$<br>P(X = k) = \frac{C_{N_1}^k C_{N_2}^{n-k}}{C_N^n},(k = 0,1,2, \cdots, \min \begin{Bmatrix} n, N_1 \end{Bmatrix})<br>$$</p>
<blockquote>
<p>① 超几何分布有一个比较明显的特征：<strong>实验只有两种情况/两类</strong>；</p>
<p>② 超几何分布可以用来描述不放回抽样实验；</p>
<p>③ 当不放回抽样中总体数量巨大，抽出的数量相对于总体数量远远小于，则超几何分布可以使用二项分布来近似</p>
</blockquote>
<h5 id="六、均匀分布"><a href="#六、均匀分布" class="headerlink" title="六、均匀分布"></a>六、均匀分布</h5><p> 定义式为：<br>$$<br>f(x)=\left{<br>\begin{aligned}<br>\frac{1}{b-a}, &amp;a \leq x \leq b \<br>0, &amp;x&lt;a,x&gt;b<br>\end{aligned}<br>\right.<br>$$<br>记为$X \sim U[a, b]$，其分布函数为：<br>$$<br>F(x) = \left{<br>\begin{aligned}<br>0, &amp;x&lt;a \<br>\frac{x-a}{b-a}, &amp;a \leq x \leq b \<br>1, &amp;x&gt;b<br>\end{aligned}<br>\right.<br>$$</p>
<h5 id="七、指数分布"><a href="#七、指数分布" class="headerlink" title="七、指数分布"></a>七、指数分布</h5><p>定义式为：<br>$$<br>f(x)=\left{<br>\begin{aligned}<br>\lambda e^{-\lambda x}, &amp;x &gt; 0 \<br>0, &amp;x \leq 0<br>\end{aligned}<br>\right.<br>$$<br>其中$\lambda &gt; 0$，记为$X \sim \text{Exp}(\lambda)$，其分布函数为：<br>$$<br>F(x) = \left{<br>\begin{aligned}<br>1-e^{-\lambda x}, &amp;x&gt;0 \<br>0, &amp;x \leq 0<br>\end{aligned}<br>\right.<br>$$<br>指数分布有一个特性：<strong>无记忆性</strong><br>$$<br>P(X&gt;s+t|X&gt;s) = P(X&gt;t),s&gt;0,t&gt;0<br>$$</p>
<h5 id="八、正态分布"><a href="#八、正态分布" class="headerlink" title="八、正态分布"></a>八、正态分布</h5><p>定义式为：<br>$$<br>\phi(x) = \frac{1}{\sqrt{2 \pi} \sigma} e^{-\frac{(x- \mu)^2}{2 \sigma^2}}, -\infty &lt; x &lt; \infty<br>$$<br>记为$X \sim N(\mu, \sigma^2)$，其分布函数为：<br>$$<br>\Phi(x) = \frac{1}{\sqrt{2\pi}\sigma}\int_{-\infty}^x e^{-\frac{(t- \mu)^2}{2 \sigma^2}}dt<br>$$</p>
<ul>
<li><strong>正态分布的性质：</strong><ul>
<li>① 其密度函数$\phi(x)$是以$x = \mu$为对称轴，且在$x = \mu$处取得最大值；</li>
<li>② 其密度函数$\phi(x)$是以x轴为渐近线；</li>
<li>③ $\sigma$固定$\mu$变化，则$\phi(x)$左右移动，$\mu$固定$\sigma$变化，则$\phi(x)$窄宽变化；</li>
</ul>
</li>
</ul>
<p><strong>标准正太分布</strong>：$\mu = 0, \sigma = 1$，其密度函数$\phi_0(x)$为：<br>$$<br>\phi_0(x) = \frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}, -\infty &lt; x &lt; \infty<br>$$<br>记为$X \sim N(0,1)$，其分布函数$\Phi_0(x)$为：<br>$$<br>\Phi(x) = \frac{1}{\sqrt{2\pi}}\int_{-\infty}^x e^{-\frac{t^2}{2}}dt<br>$$<br>一个一般的正态分布转换为标准正态分布：$x \to \dfrac{x-\mu}{\sigma}$。</p>
<h4 id="2-3-2-随机变量函数的分布"><a href="#2-3-2-随机变量函数的分布" class="headerlink" title="2.3.2 随机变量函数的分布"></a>2.3.2 随机变量<font color="red">函数</font>的分布</h4><p>本节要研究的内容可以简单概况为——已知X是某分布，求Y = aX+b的分布。</p>
<h5 id="一、离散型"><a href="#一、离散型" class="headerlink" title="一、离散型"></a>一、离散型</h5><h5 id="二、连续型"><a href="#二、连续型" class="headerlink" title="二、连续型"></a>二、连续型</h5><p>设X的概率密度为$f_X(x)$，令$Y = g(X)$，求Y的密度函数$f_Y(x)$。求解方法步骤：</p>
<ul>
<li>① $F_Y(x) \to F_X(x)$</li>
<li>② $f_Y(x) \leftarrow f_X(x)$</li>
</ul>
<p>集合测试：$\Omega = \begin{Bmatrix} 1, 2, 3 \end{Bmatrix}$、$\begin{Bmatrix} 1, 2, 3 \end{Bmatrix}$</p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p>[1]B站宋浩视频 <a href="https://www.bilibili.com/video/BV1ot411y7mU">https://www.bilibili.com/video/BV1ot411y7mU</a></p>
<p>[2]书籍目录 <a href="https://www.taobao.com/list/item/610183739684.htm">https://www.taobao.com/list/item/610183739684.htm</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>概率基础</tag>
        <tag>概率论学习</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建历程</title>
    <url>/2022/01/18/post-name/</url>
    <content><![CDATA[<h3 id="〇-简要介绍"><a href="#〇-简要介绍" class="headerlink" title="〇. 简要介绍"></a>〇. 简要介绍</h3><p>本博客的搭建不需要什么技术，而且自己截止到当前时间对Git和Github的使用也刚学，所以只是参考网上博客和B站的教学视频来做的。</p>
<h3 id="一-部署Github-Pages"><a href="#一-部署Github-Pages" class="headerlink" title="一. 部署Github Pages"></a>一. 部署Github Pages</h3><p>在自己的Github上创建一个新的<strong>Repositories</strong>，注意命名规则是——Github账号名.github.io。</p>
<h3 id="二-安装Hexo"><a href="#二-安装Hexo" class="headerlink" title="二. 安装Hexo"></a>二. 安装Hexo</h3><h4 id="1-插入注解"><a href="#1-插入注解" class="headerlink" title="1. 插入注解"></a>1. 插入注解</h4><h5 id="1-常见的博客搭建方法"><a href="#1-常见的博客搭建方法" class="headerlink" title="(1) 常见的博客搭建方法"></a>(1) 常见的博客搭建方法</h5><p>据我目前所知，搭建博客总体上分有两种方法：</p>
<ul>
<li>第三方平台：在现有的博客网站、论坛或社区上注册个人主页。如知乎，掘金，简书，segmentFault，csdn，博客园等。特点：无技术门槛，可专注于内容。</li>
<li>静态网站生成技术：在终端执行命令快速生成静态网站，如 Jekyll、Hugo、Hexo等。然后通过 Github Pages、Coding 等展示。特点：通过插件可增加评论、搜索、分析等功能。有多种主题可选。在本地以特定格式书写文章，放置在指定的文件夹。每次发布或修改文章都需要重新生成和部署网站。</li>
<li>其他：<a href="https://juejin.cn/post/6951679886557708302">参考链接-如何搭建个人博客 ：几种方案比较 + 个人实现</a> </li>
</ul>
<h5 id="2-静态网站生成技术比较"><a href="#2-静态网站生成技术比较" class="headerlink" title="(2) 静态网站生成技术比较"></a>(2) 静态网站生成技术比较</h5><p>在该方法当中，也与许多可供选择的方案，像 Jekyll、Hugo、Hexo、Typecho、Wordpress等等，那么它们各有什么优缺点呢，这里我就不说了(不是我的重点)，请参考链接：<a href="https://blog.laoda.de/archives/blog-choosing">Hexo还是Hugo？Typecho还是Wordpress？读完这篇或许你就有答案了！</a></p>
<h4 id="2-安装相应软件"><a href="#2-安装相应软件" class="headerlink" title="2. 安装相应软件"></a>2. 安装相应软件</h4><h5 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="(1) 安装Node.js"></a>(1) 安装Node.js</h5><p>Node.js的官方网站：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a> </p>
<p>下载好了之后直接安装，安装过程中会出现</p>
<p><img src="https://pic.imgdb.cn/item/61e64e022ab3f51d91dc2599.png" alt="&lt;font color=red&gt;图1&lt;/font&gt;  Node安装"></p>
<p>要点第四个，添加到Path(环境变量)。</p>
<h5 id="2-Git安装"><a href="#2-Git安装" class="headerlink" title="(2) Git安装"></a>(2) Git安装</h5><p>Git的安装则是傻瓜式安装即可，虽然步骤多，但是按照默认的来就行；</p>
<p>好的，现在已经全部准备完毕，下面简单测试一下看看是否安装成功。</p>
<h5 id="3-测试"><a href="#3-测试" class="headerlink" title="(3) 测试"></a>(3) 测试</h5><p> 为了验证我们的Node.js和Git是否安装完毕，可以在CMD（win+R，输入“cmd”即可打开）中输入两条命令查看： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">git version</span><br></pre></td></tr></table></figure>

<p>若两条命令没有报错，而且显示了版本号，则安装成功！</p>
<h4 id="3-Hexo本地化"><a href="#3-Hexo本地化" class="headerlink" title="3. Hexo本地化"></a>3. Hexo本地化</h4><h5 id="1-创建新文件夹"><a href="#1-创建新文件夹" class="headerlink" title="(1) 创建新文件夹"></a>(1) 创建新文件夹</h5><p>这个新文件夹在之后会保存Hexo的文件以及你的博客相关内容，十分重要，我是建立在E盘下新文件夹I.myBlog。</p>
<h5 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="(2) 安装Hexo"></a>(2) 安装Hexo</h5><p>打开Windows中使用cmd命令打开命令行，然后更改命令行目录到上一步创建的新文件夹中，然后执行下面的命令安装Hexo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>注意安装过程中网络不要断开，安装完成后文件夹还是一个空的状态，下一步要初始化。</p>
<h5 id="3-初始化Hexo"><a href="#3-初始化Hexo" class="headerlink" title="(3) 初始化Hexo"></a>(3) 初始化Hexo</h5><p> 执行以下代码完成初始化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>这时候文件夹就出现了新文件，不再是空的，文件主要有以下几种：</p>
<ul>
<li>.deploty_git：上传到Github的最终文件，如果不使用Git，则不会生成</li>
<li>.github：一个神秘文件夹</li>
<li>node_modules：一个神秘文件夹</li>
<li>public：上传到Github的最终文件，不安装Git时可以使用这种方法直接部署</li>
<li>scaffolds：存放创建新文章时的模板文件</li>
<li>theme：主题存放文件夹</li>
<li>post：博客文章存放的地方</li>
</ul>
<h3 id="三-基础配置与指令"><a href="#三-基础配置与指令" class="headerlink" title="三. 基础配置与指令"></a>三. 基础配置与指令</h3><h4 id="1-主题配置-美化"><a href="#1-主题配置-美化" class="headerlink" title="1. 主题配置(美化)"></a>1. 主题配置(美化)</h4><p>进入博客文件夹根目录，打开**_config.yml**文件，然后自行进行修改。</p>
<p><img src="https://pic.imgdb.cn/item/61e64e022ab3f51d91dc258c.png" alt="&lt;font color=red&gt; 图2&lt;/font&gt;  _config文件截图示意"></p>
<p>这里是一些基本的，比如说你的网站名（第六行）、描述（第八行）、作者（第十行）、语言（第十一行）等都可以进行自主修改。</p>
<p><img src="https://pic.imgdb.cn/item/61e64e022ab3f51d91dc25a2.png" alt="&lt;font color=red&gt; 图3&lt;/font&gt;  url修改"></p>
<p>如图3所示，这里url的修改十分重要，一定要记得修改。要改成你将来要部署的网站！！！比如你要用GitHub Pages部署，就必须是那一节你部署过的网站链接！！！ </p>
<p><img src="https://pic.imgdb.cn/item/61e64e022ab3f51d91dc2594.png" alt="&lt;font color=red&gt; 图4&lt;/font&gt;  git链接修改"></p>
<p><font color="red"><strong>注意，下面这几处修改十分重要！！！</strong></font></p>
<p>第100行的主题名改为之前让你复制的那个文件夹名(记得空格，在你没有下载新主题之前不用管，默认即可)；</p>
<p>第105行“type”后面填写“git”；</p>
<p>第106行加上“repo”，然后加上链接——不是GitHub Pages的链接，是GitHub Pages的库的链接！！</p>
<blockquote>
<p>注意：这里由于Github在2021年进行了一次更新，应该是不能再使用https协议了，转而应该示意SSH，但是我这里使用了https好像也没什么问题，其实我自己现在对Git、GitHub的使用也还是模模糊糊，对一些操作、概念(如：密钥、公钥、令牌等)不明白，所以也就是稀里糊涂，后面我还要仔细学习学习Git的知识，如果你的使用https不行，建议参考链接进行设置——<a href="https://vabzjaby.github.io/2021/10/05/pwh/#%E7%AC%AC%E5%9B%9B%E6%AD%A5-%E7%BC%96%E8%BE%91">https://vabzjaby.github.io/2021/10/05/pwh/#%E7%AC%AC%E5%9B%9B%E6%AD%A5-%E7%BC%96%E8%BE%91</a> </p>
</blockquote>
<p>第107行加上“branch”，名字起main；</p>
<blockquote>
<p>注意：这里与Github在2021年进行了一次更新有关，之前应该是填写master，现在填写main即可；</p>
</blockquote>
<p>完成这些之后，我们可以再次用“hexo s”这个指令查看预览，发现已经更新主题了。</p>
<h4 id="2-Hexo的常用命令"><a href="#2-Hexo的常用命令" class="headerlink" title="2. Hexo的常用命令"></a>2. Hexo的常用命令</h4><ul>
<li>hexo s：在本地演示网站</li>
<li>hexo g：在本地渲染静态页面(就是将md转换为html)</li>
<li>hexo d：把静态页面一键上传到Github Pages</li>
<li>hexo new：<ul>
<li>标题(直接加标题则是在source/_posts文件夹生成—个”标题.md”文件作为文章)<ul>
<li>建议∶生成新文章和页面时最好用阿拉伯数字或者英文,这样链接不会很长</li>
</ul>
</li>
<li>page+标题(标题前加page则是生成一个新页面,hexo刚开始只有默认的首页和归档页,创建其他页面,例如标签,关于页面,都需要此指令生成)</li>
<li>post+标题(在_config.yml中将post_asset_folder设为true之后hexo new post “first-page”之后新建了一篇文章，就会同时在hexo/source/_post文件夹下生成一个.md文件和一个同名文件夹，文件夹存放文章中的图片)</li>
</ul>
</li>
<li>hexo clean：清理已有的静态页面(不是删干净重来)</li>
</ul>
<h4 id="3-示例配置过程"><a href="#3-示例配置过程" class="headerlink" title="3. 示例配置过程"></a>3. 示例配置过程</h4><p>在执行<code>hexo init</code>之后，可以再执行<code>hexg g</code> 在本地渲染页面，完成后文件夹中会出现<strong>public</strong>文件夹。然后再执行<code>hexo new ts</code> 这时在source文件夹下会生成_post文件夹，里面有hello-world.md(默认自带)和ts.md(代码新生成的)，然后我们可以在ts.md中写一些东西，就是日后的博客文章。还可以使用命令<code>hexo new page about</code> 生成一个新的about文件夹，里面有index.md，可以写一些介绍自己的内容。</p>
<p>弄好上面的之后，我们可以执行命令<code>hexo s</code> 在本地演示网站，此时cmd窗口会生成一个<a href="http://localhost:4000/">http://localhost:4000</a> 的链接，我们在浏览器打开就可以看到渲染的博客页面了。</p>
<h4 id="4-主题的美化"><a href="#4-主题的美化" class="headerlink" title="4. 主题的美化"></a>4. 主题的美化</h4><p>主要是利用<strong>根目录下的_config.yml文件</strong>和<strong>themes文件夹下某一主题文件夹下的_config.yml</strong>进行修改美化页面，可以自己进行探索。</p>
<h5 id="1-关于主题的设置"><a href="#1-关于主题的设置" class="headerlink" title="(1) 关于主题的设置"></a>(1) 关于主题的设置</h5><ul>
<li>存放位置：/themes/主题名/_config.yml(注意：有别于根目录下的_config.yml文件)<ul>
<li>这里需要说明的是：Hexo在渲染静态页面时，themes文件夹的_config.yml文件优先度比根目录的_config.yml高</li>
</ul>
</li>
<li>修改方式：大部分为布尔值(只需要修改true或者false即可)，支持中文的主题大部分会有注释<ul>
<li>这里推荐Hexo的Next与Ayer主题，两者有很清晰明了的中文，页面也很清爽(我的主题是Ayer)</li>
</ul>
</li>
<li>添加自定义js的方式：在/themes/主题名/layout/layout.ejs中添加<ul>
<li>该方法是我在用Next主题时发现的，当时成功了，是后来Ayer主题失败了，还是要按照不同的主题来</li>
</ul>
</li>
</ul>
<p>完成配置后，可以使用<code>hexok s</code> 在本地演示网站看一下配置情况。</p>
<h5 id="2-Markdown语法学习"><a href="#2-Markdown语法学习" class="headerlink" title="(2) Markdown语法学习"></a>(2) Markdown语法学习</h5><p>自己学习，这里不讲。</p>
<h3 id="四-部署与上传"><a href="#四-部署与上传" class="headerlink" title="四. 部署与上传"></a>四. 部署与上传</h3><p>在进行完这一步之后，就可以真正意义上有一个可以在浏览器打开的自己的博客网站！！！</p>
<p>正常情况下，在cmd输入指令<code>npm install hexo-deployer-git --save</code> 之后指令<code>hexo g -d</code> 理论上就可以成功将博客文件上传到Github上了，然后在GitHub网页的settings页面下找到pages，就可以找到对应的网址，打开即可看到自己的博客。<br>但是，由于Github服务器在国外，所以经常出现网络问题，需要搭梯子，下面是失败情况下的一些处理方法。</p>
<ul>
<li>失败则输入指令<code>git config --global credential.helper wincred</code></li>
<li>再次失败，错误原因是spawn的话就是网络有些问题，重启cmd试试</li>
<li>还是失败的话可能是电脑上装了两个hexo</li>
<li>最终还是失败的话可以使用指令<code>hexo g</code>，然后直接在网页端的GitHub上传public文件夹。</li>
</ul>
<h3 id="五-相关链接"><a href="#五-相关链接" class="headerlink" title="五. 相关链接"></a>五. 相关链接</h3><h4 id="1-帮助文档链接"><a href="#1-帮助文档链接" class="headerlink" title="1. 帮助文档链接"></a>1. 帮助文档链接</h4><p>在自己搭建第一个博客中出现了很多问题，有许多博客、视频帮助了我，贴在下面可以可看一下。</p>
<p>听话的便当的B站视频：<a href="https://space.bilibili.com/435364951/channel/seriesdetail?sid=812995">听话的_便当的个人空间_哔哩哔哩_bilibili</a> </p>
<p>听话的便当的博客：<a href="https://byn6.github.io/2021/08/29/gp-h/">https://byn6.github.io/2021/08/29/gp-h/</a></p>
<p>Ayer中文官方文档： <a href="https://shen-yu.gitee.io/2019/ayer">https://shen-yu.gitee.io/2019/ayer</a></p>
<p>Hexo官方文档：<a href="https://hexo.io/zh-cn/docs/asset-folders.html">https://hexo.io/zh-cn/docs/asset-folders.html</a></p>
<p>Hexo常用命令详解及使用方法：<a href="https://www.mabiji.com/hexo/hexocommands.html">https://www.mabiji.com/hexo/hexocommands.html</a></p>
<p>Hexo为文章设置目录与标签的方法：<a href="https://blog.csdn.net/weixin_44543463/article/details/119738094">https://blog.csdn.net/weixin_44543463/article/details/119738094</a></p>
<p>[hexo]如何更换主题、删除文章：<a href="https://www.cnblogs.com/mrwuzs/p/7942689.html">https://www.cnblogs.com/mrwuzs/p/7942689.html</a></p>
<p>hexo搭建博客后图片无法显示的完美解决：<a href="https://blog.csdn.net/weixin_43702620/article/details/118655308">https://blog.csdn.net/weixin_43702620/article/details/118655308</a></p>
<p>不会git就学不会github吗？：<a href="https://www.zhihu.com/question/29566172">https://www.zhihu.com/question/29566172</a></p>
<p>git是干什么的？ sourcetree是干什么的？：<a href="https://www.zhihu.com/question/48322958">https://www.zhihu.com/question/48322958</a></p>
<p>SourceTree的基本使用教程：<a href="https://blog.csdn.net/qq_34129814/article/details/82847753">https://blog.csdn.net/qq_34129814/article/details/82847753</a></p>
<p>Hexo server报错TypeError: Cannot read property ‘utcOffset’ of null解决方法：<a href="http://t.zoukankan.com/mmzuo-798-p-10510225.html">http://t.zoukankan.com/mmzuo-798-p-10510225.html</a></p>
<p>免费图床，看这一篇就够了！：<a href="https://www.duangvps.com/archives/1737">https://www.duangvps.com/archives/1737</a></p>
<h4 id="2-数学公式解决方法"><a href="#2-数学公式解决方法" class="headerlink" title="2. 数学公式解决方法"></a>2. 数学公式解决方法</h4><p>MathJax在Hexo博客中插入数学公式：<a href="https://blog.csdn.net/weixin_39789979/article/details/110806006">https://blog.csdn.net/weixin_39789979/article/details/110806006</a></p>
<p>markdown斜体和数学公式的矛盾：<a href="https://blog.moper.net/2640.html">https://blog.moper.net/2640.html</a></p>
<p>hexo博客MathJax公式渲染问题：<a href="https://www.cnblogs.com/Ai-heng/p/7282110.htm">https://www.cnblogs.com/Ai-heng/p/7282110.htm</a></p>
<p>hexo 如何解决markdown下划线要加反斜杠，以及如何使用其他markdown的渲染引擎？：<a href="https://segmentfault.com/q/1010000003987383">https://segmentfault.com/q/1010000003987383</a></p>
<h4 id="3-优秀博客示例"><a href="#3-优秀博客示例" class="headerlink" title="3. 优秀博客示例"></a>3. 优秀博客示例</h4><p>二十五画生 <a href="https://blog.laoda.de/">https://blog.laoda.de</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>生活休闲</category>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Git</tag>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn Git</title>
    <url>/2022/01/18/learnGit/</url>
    <content><![CDATA[<h3 id="一、Git安装"><a href="#一、Git安装" class="headerlink" title="一、Git安装"></a>一、Git安装</h3><h4 id="1-在Windows上安装Git"><a href="#1-在Windows上安装Git" class="headerlink" title="1. 在Windows上安装Git"></a>1. 在Windows上安装Git</h4><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads">下载安装程序</a>，然后按默认选项安装即可。</p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
<h4 id="2-设置名字-邮箱"><a href="#2-设置名字-邮箱" class="headerlink" title="2. 设置名字+邮箱"></a>2. 设置名字+邮箱</h4><p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h3 id="二、创建版本库"><a href="#二、创建版本库" class="headerlink" title="二、创建版本库"></a>二、创建版本库</h3><h4 id="1-定义与创建"><a href="#1-定义与创建" class="headerlink" title="1. 定义与创建"></a>1. 定义与创建</h4><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure>

<p><code>pwd</code>命令用于显示当前目录。在我的Mac上，这个仓库位于<code>/Users/michael/learngit</code>。</p>
<p>使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名(包括父目录)不包含中文。 </p>
<p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure>

<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库(empty Git repository)，细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>
<h4 id="2-把文件添加到版本库"><a href="#2-把文件添加到版本库" class="headerlink" title="2. 把文件添加到版本库"></a>2. 把文件添加到版本库</h4><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p>
<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<p><font color="red">使用Windows的童鞋要特别注意：</font></p>
<p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="https://code.visualstudio.com/">Visual Studio Code</a>代替记事本，不但功能强大，而且免费！</p>
<p>言归正传，现在我们编写一个<code>readme.txt</code>文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>

<p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p>
<p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p>
<p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>

<p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure>

<p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p>
<p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p>
<p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure>

<h4 id="3-疑难解答"><a href="#3-疑难解答" class="headerlink" title="3. 疑难解答"></a>3. 疑难解答</h4><p>Q：输入<code>git add readme.txt</code>，得到错误：<code>fatal: not a git repository (or any of the parent directories)</code>。</p>
<p>A：Git命令必须在Git仓库目录内执行（<code>git init</code>除外），在仓库目录外执行是没有意义的。</p>
<p>Q：输入<code>git add readme.txt</code>，得到错误<code>fatal: pathspec &#39;readme.txt&#39; did not match any files</code>。</p>
<p>A：添加某个文件时，该文件必须在当前目录下存在，用<code>ls</code>或者<code>dir</code>命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。</p>
<h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h4><p>现在总结一下今天学的两点内容：</p>
<p>初始化一个Git仓库，使用<code>git init</code>命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<ol>
<li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li>
<li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li>
</ol>
<h3 id="三、版本控制"><a href="#三、版本控制" class="headerlink" title="三、版本控制"></a>三、版本控制</h3><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>

<p>现在，运行<code>git status</code>命令看看结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p>
<p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure>

<p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p>
<p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>

<p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p><code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;add distributed&quot;</span><br><span class="line">[master e475afc] add distributed</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p>
<p><strong>小结</strong></p>
<ul>
<li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li>
<li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li>
</ul>
<h4 id="1-版本回退"><a href="#1-版本回退" class="headerlink" title="1. 版本回退"></a>1. 版本回退</h4><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure>

<p>然后尝试提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;append GPL&quot;</span><br><span class="line">[master 1094adb] append GPL</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p>
<p>版本1：wrote a readme file</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>

<p>版本2：add distributed</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>

<p>版本3：append GPL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure>

<p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>

<p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure>

<p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。 </p>
<p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure>

<p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p>
<p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>

<p>果然被还原了。</p>
<p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，让我们用<code>git log</code>再看看现在版本库的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>

<p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure>

<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看<code>readme.txt</code>的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure>

<p>果然，我胡汉三又回来了。</p>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──&gt; ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure>

<p>改为指向<code>add distributed</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──&gt; ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure>

<p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure>

<p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p>
<p><strong>小结</strong></p>
<p>现在总结一下：</p>
<ul>
<li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<h4 id="2-工作区和暂存区"><a href="#2-工作区和暂存区" class="headerlink" title="2. 工作区和暂存区"></a>2. 工作区和暂存区</h4><h5 id="2-1-工作区"><a href="#2-1-工作区" class="headerlink" title="2.1 工作区"></a>2.1 工作区</h5><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区。</p>
<h5 id="2-2-版本库（Repository）"><a href="#2-2-版本库（Repository）" class="headerlink" title="2.2 版本库（Repository）"></a>2.2 版本库（Repository）</h5><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage(或者叫index)的暂存区</strong>，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p><img src="https://pic.imgdb.cn/item/61e67be02ab3f51d91087ff2.jpg" alt="Git指针关系"></p>
<p>分支和<code>HEAD</code>的概念我们以后再讲。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure>

<p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p>
<p>先用<code>git status</code>查看一下状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">	LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>
<p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   LICENSE</span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>现在，暂存区的状态就变成这样了：</p>
<p><img src="https://pic.imgdb.cn/item/61e67c9b2ab3f51d91095d39.jpg" alt="当前暂存区"></p>
<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;understand how stage works&quot;</span><br><span class="line">[master e43a48b] understand how stage works</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure>

<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img src="https://pic.imgdb.cn/item/61e67d0c2ab3f51d9109f1d7.jpg" alt="当前库内情况"></p>
<p><strong>小结</strong></p>
<p>暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</p>
<p>没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。</p>
<h4 id="3-管理修改"><a href="#3-管理修改" class="headerlink" title="3. 管理修改"></a>3. 管理修改</h4><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>
<p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes.</span><br></pre></td></tr></table></figure>

<p>然后，添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git status</span><br><span class="line"># On branch master</span><br><span class="line"># Changes to be committed:</span><br><span class="line">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">#</span><br><span class="line">#       modified:   readme.txt</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>然后，再修改readme.txt：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt </span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure>

<p>提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;git tracks changes&quot;</span><br><span class="line">[master 519219b] git tracks changes</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>提交后，再看看状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>咦，怎么第二次的修改没有被提交？</p>
<p>别激动，我们回顾一下操作过程：</p>
<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p>
<p>你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 76d770f..a9c5755 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure>

<p>可见，第二次修改确实没有被提交。</p>
<p>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：</p>
<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p>
<p>好，现在，把第二次修改提交了，然后开始小结。</p>
<p><strong>小结</strong></p>
<p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p>
<h4 id="4-撤销修改"><a href="#4-撤销修改" class="headerlink" title="4. 撤销修改"></a>4. 撤销修改</h4><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure>

<p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure>

<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p>现在，看看<code>readme.txt</code>的文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure>

<p>文件内容果然复原了。</p>
<p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p>
<p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure>

<p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	readme.txt</span><br></pre></td></tr></table></figure>

<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p>
<p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>还记得如何丢弃工作区的修改吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>整个世界终于清静了！</p>
<p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把<code>stupid boss</code>提交推送到远程版本库，你就真的惨了……</p>
<p><strong>小结</strong></p>
<p>又到了小结时间。</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p>
<h4 id="5-删除文件"><a href="#5-删除文件" class="headerlink" title="5. 删除文件"></a>5. 删除文件</h4><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add test.txt&quot;</span><br><span class="line">[master b84166e] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure>

<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rm test.txt</span><br></pre></td></tr></table></figure>

<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;remove test.txt&quot;</span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure>

<p>现在，文件就从版本库中被删除了。</p>
<p>小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。 </file></file></p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure>

<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p> 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ </p>
<p><strong>小结</strong></p>
<p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p>
<h3 id="四、远程仓库"><a href="#四、远程仓库" class="headerlink" title="四、远程仓库"></a>四、远程仓库</h3><h4 id="1-什么是远程库"><a href="#1-什么是远程库" class="headerlink" title="1. 什么是远程库"></a>1. 什么是远程库</h4><p>到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。</p>
<p>可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。</p>
<p>没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：<font color="red"><strong>远程仓库</strong></font>。</p>
<p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p>
<p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过<font color="red"><strong>SSH加密的</strong></font>，所以需要一点设置：</p>
<p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面。</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容。</p>
<p>点“Add Key”，你就应该看到已经添加的Key。</p>
<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p>
<p><strong>小结</strong></p>
<p>“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机</p>
<h4 id="2-添加远程库"><a href="#2-添加远程库" class="headerlink" title="2. 添加远程库"></a>2. 添加远程库</h4><h5 id="2-1创建并关联远程库"><a href="#2-1创建并关联远程库" class="headerlink" title="2.1创建并关联远程库"></a>2.1创建并关联远程库</h5><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库。</p>
<p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。</p>
<p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure>

<p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.</span><br><span class="line">Total 20 (delta 5), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>

<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样 。</p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>
<h5 id="2-2-SSH警告"><a href="#2-2-SSH警告" class="headerlink" title="2.2 SSH警告"></a>2.2 SSH警告</h5><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>

<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p>
<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning: Permanently added &#x27;github.com&#x27; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>

<p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p>
<h5 id="2-3删除远程库"><a href="#2-3删除远程库" class="headerlink" title="2.3删除远程库"></a>2.3删除远程库</h5><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (push)</span><br></pre></td></tr></table></figure>

<p>然后，根据名字删除，比如删除<code>origin</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote rm origin</span><br></pre></td></tr></table></figure>

<p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p>
<p><strong>小结</strong></p>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>
<p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
<h4 id="3-远程库克隆"><a href="#3-远程库克隆" class="headerlink" title="3. 远程库克隆"></a>3. 远程库克隆</h4><p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>
<p>现在，假设<font color="red"><strong>我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆</strong>。</font></p>
<p>首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code> 。</p>
<p>我们勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件。</p>
<p>现在，远程库已经准备好了，下一步是用命令<code>git clone</code>克隆一个本地库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br><span class="line">Cloning into &#x27;gitskills&#x27;...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3</span><br><span class="line">Receiving objects: 100% (3/3), done.</span><br></pre></td></tr></table></figure>

<p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有<code>README.md</code>文件了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd gitskills</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure>

<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>你也许还注意到，GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p>
<p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p>
<p><strong>小结</strong></p>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p>
<p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p>
<h3 id="五、分支管理"><a href="#五、分支管理" class="headerlink" title="五、分支管理"></a>五、分支管理</h3><h4 id="1-分支管理的概念"><a href="#1-分支管理的概念" class="headerlink" title="1. 分支管理的概念"></a>1. 分支管理的概念</h4><p>分支就是科幻电影里的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p>
<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<h4 id="2-创建与合并分支"><a href="#2-创建与合并分支" class="headerlink" title="2. 创建与合并分支"></a>2. 创建与合并分支</h4><h5 id="2-1-分支概念与实践"><a href="#2-1-分支概念与实践" class="headerlink" title="2.1 分支概念与实践"></a>2.1 分支概念与实践</h5><p>在<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src="https://pic.imgdb.cn/item/61e696dd2ab3f51d91240513.jpg"></p>
<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p>
<p><img src="https://pic.imgdb.cn/item/61e696fd2ab3f51d91242093.jpg"></p>
<p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<p><img src="https://pic.imgdb.cn/item/61e697152ab3f51d912435f0.jpg"></p>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并： </p>
<p><img src="https://pic.imgdb.cn/item/61e697332ab3f51d91245144.jpg"></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p>
<p><img src="https://pic.imgdb.cn/item/61e697492ab3f51d912464db.jpg"></p>
<p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p>
<p>下面开始实战。</p>
<p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure>

<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure>

<p>然后，用<code>git branch</code>命令查看当前分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick.</span><br></pre></td></tr></table></figure>

<p>然后提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;branch test&quot;</span><br><span class="line">[dev b17d20e] branch test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure>

<p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p>
<p><img src="https://pic.imgdb.cn/item/61e697672ab3f51d91248608.jpg"></p>
<p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p>
<p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure>

<p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>
<h5 id="2-2-switch"><a href="#2-2-switch" class="headerlink" title="2.2 switch"></a>2.2 switch</h5><p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p>
<p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p>
<p>创建并切换到新的<code>dev</code>分支，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure>

<p>直接切换到已有的<code>master</code>分支，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br></pre></td></tr></table></figure>

<p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p>
<p><strong>小结</strong></p>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h4 id="3-解决冲突"><a href="#3-解决冲突" class="headerlink" title="3. 解决冲突"></a>3. 解决冲突</h4><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch -c feature1</span><br><span class="line">Switched to a new branch &#x27;feature1&#x27;</span><br></pre></td></tr></table></figure>

<p>修改<code>readme.txt</code>最后一行，改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure>

<p>在<code>feature1</code>分支上提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;AND simple&quot;</span><br><span class="line">[feature1 14096d0] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>切换到<code>master</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br></pre></td></tr></table></figure>

<p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p>
<p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure>

<p>提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;&amp; simple&quot;</span><br><span class="line">[master 5dc6824] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p>
<p><img src="https://pic.imgdb.cn/item/61e69e7a2ab3f51d912a6360.jpg"></p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 2 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">	both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>我们可以直接查看readme.txt的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>

<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure>

<p>再提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;conflict fixed&quot;</span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure>

<p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/61e69ea22ab3f51d912a838f.jpg"></p>
<p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>

<p>最后，删除<code>feature1</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 14096d0).</span><br></pre></td></tr></table></figure>

<p>工作完成。</p>
<p><strong>小结</strong></p>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h4 id="4-分支管理策略"><a href="#4-分支管理策略" class="headerlink" title="4. 分支管理策略"></a>4. 分支管理策略</h4><h5 id="4-1-分支管理"><a href="#4-1-分支管理" class="headerlink" title="4.1 分支管理"></a>4.1 分支管理</h5><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p>
<p>首先，仍然创建并切换<code>dev</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch -c dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure>

<p>修改readme.txt文件，并提交一个新的commit：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;add merge&quot;</span><br><span class="line">[dev f52c633] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在，我们切换回<code>master</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure>

<p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p>
<p>合并后，我们用<code>git log</code>看看分支历史：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p>
<p><img src="https://pic.imgdb.cn/item/61e69fbd2ab3f51d912b56e2.jpg"></p>
<h5 id="4-2-分支策略"><a href="#4-2-分支策略" class="headerlink" title="4.2 分支策略"></a>4.2 分支策略</h5><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><img src="https://pic.imgdb.cn/item/61e69fd92ab3f51d912b6b96.jpg"></p>
<p><strong>小结</strong></p>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<h4 id="5-Bug分支"><a href="#5-Bug分支" class="headerlink" title="5. Bug分支"></a>5. Bug分支</h4><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>

<p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch &#x27;issue-101&#x27;</span><br></pre></td></tr></table></figure>

<p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;fix bug 101&quot;</span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>

<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p>
<p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure>

<p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure>

<p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>

<p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p>
<p>那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？</p>
<p>有木有更简单的方法？</p>
<p>有！</p>
<p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p>
<p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p>
<p>有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p>
<p><strong>小结</strong></p>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<h4 id="6-Feature分支"><a href="#6-Feature分支" class="headerlink" title="6. Feature分支"></a>6. Feature分支</h4><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p>
<p>于是准备开发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch -c feature-vulcan</span><br><span class="line">Switched to a new branch &#x27;feature-vulcan&#x27;</span><br></pre></td></tr></table></figure>

<p>5分钟后，开发完毕：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   vulcan.py</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure>

<p>切回<code>dev</code>，准备合并：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git switch dev</span><br></pre></td></tr></table></figure>

<p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p>
<p>但是！</p>
<p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p>
<p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch &#x27;feature-vulcan&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D feature-vulcan&#x27;.</span><br></pre></td></tr></table></figure>

<p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p>
<p>现在我们强行删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 287773e).</span><br></pre></td></tr></table></figure>

<p>终于删除成功！</p>
<p><strong>小结</strong></p>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h3 id="六、多人协作"><a href="#六、多人协作" class="headerlink" title="六、多人协作"></a>六、多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p>
<p>要查看远程库的信息，用<code>git remote</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<p>或者，用<code>git remote -v</code>显示更详细的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure>

<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<h4 id="1-推送分支"><a href="#1-推送分支" class="headerlink" title="1. 推送分支"></a>1. 推送分支</h4><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>如果要推送其他分支，比如<code>dev</code>，就改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure>

<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<ul>
<li><code>master</code>分支是主分支，因此要时刻与远程同步；</li>
<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>
<h4 id="2-抓取分支"><a href="#2-抓取分支" class="headerlink" title="2. 抓取分支"></a>2. 抓取分支</h4><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p>
<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into &#x27;learngit&#x27;...</span><br><span class="line">remote: Counting objects: 40, done.</span><br><span class="line">remote: Compressing objects: 100% (21/21), done.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40/40), done.</span><br><span class="line">Resolving deltas: 100% (14/14), done.</span><br></pre></td></tr></table></figure>

<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure>

<p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add env&quot;</span><br><span class="line">[dev 7a5e5dd] add env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure>

<p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add new env&quot;</span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure>

<p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>

<p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>

<p>再pull：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344">解决冲突</a>完全一样。解决后，提交，再push：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;fix env conflict&quot;</span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure>

<p>因此，多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p><strong>小结</strong></p>
<ul>
<li>查看远程库信息，使用<code>git remote -v</code>；</li>
<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>
<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>
<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>
<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>
<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>
</ul>
<h3 id="七、Rebase"><a href="#七、Rebase" class="headerlink" title="七、Rebase"></a>七、Rebase</h3><p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p>
<p>每次合并再push后，分支变成了这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure>

<p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p>
<p>其实是可以做到的！</p>
<p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p>
<p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p>
<p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 582d922 (HEAD -&gt; master) add author</span><br><span class="line">* 8875536 add comment</span><br><span class="line">* d1be385 (origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的HEAD和远程origin的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p>
<p>现在我们尝试推送本地分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure>

<p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (1/1), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From github.com:michaelliao/learngit</span><br><span class="line">   d1be385..f005ed4  master     -&gt; origin/master</span><br><span class="line"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> hello.py | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>再用<code>git status</code>看看状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 3 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p>
<p>用<code>git log</code>看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch &#x27;master&#x27; of github.com:michaelliao/learngit</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) set exit=1</span><br><span class="line">* | 582d922 add author</span><br><span class="line">* | 8875536 add comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？</p>
<p>有！</p>
<p>什么问题？</p>
<p>不好看！</p>
<p>有没有解决方法？</p>
<p>有！</p>
<p>这个时候，rebase就派上了用场。我们输入命令<code>git rebase</code>试试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add comment</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: add author</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure>

<p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin/master) set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p>
<p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>
<p>最后，通过push操作把本地分支推送到远程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mac:~/learngit michael$ git push origin master</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 1 local object.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f005ed4..7e61ed4  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>再用<code>git log</code>看看效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>远程分支的提交历史也是一条直线。</p>
<p><strong>小结</strong></p>
<ul>
<li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li>
<li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li>
</ul>
<h3 id="八、标签管理"><a href="#八、标签管理" class="headerlink" title="八、标签管理"></a>八、标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>Git有commit，为什么还要引入tag？</p>
<p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p>
<p>“一串乱七八糟的数字不好找！”</p>
<p>如果换一个办法：</p>
<p>“请把上周一的那个版本打包发布，版本号是v1.2”</p>
<p>“好的，按照tag v1.2查找commit就行！”</p>
<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h4 id="1-创建标签"><a href="#1-创建标签" class="headerlink" title="1. 创建标签"></a>1. 创建标签</h4><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure>

<p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure>

<p>可以用命令<code>git tag</code>查看所有标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure>

<p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>

<p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure>

<p>再用命令<code>git tag</code>查看标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure>

<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p>
<p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure>

<p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p> 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 </p>
<p><strong>小结</strong></p>
<ul>
<li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li>
<li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li>
<li>命令<code>git tag</code>可以查看所有标签。</li>
</ul>
<h4 id="2-操作标签"><a href="#2-操作标签" class="headerlink" title="2. 操作标签"></a>2. 操作标签</h4><p>如果标签打错了，也可以删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag &#x27;v0.1&#x27; (was f15b0dd)</span><br></pre></td></tr></table></figure>

<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure>

<p>或者，一次性推送全部尚未推送到远程的本地标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure>

<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &#x27;v0.9&#x27; (was f52c633)</span><br></pre></td></tr></table></figure>

<p>然后，从远程删除。删除命令也是push，但是格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure>

<p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>
<p><strong>小结</strong></p>
<ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
<h3 id="九、Github"><a href="#九、Github" class="headerlink" title="九、Github"></a>九、Github</h3><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p>
<p>在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。</p>
<p>但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p>
<p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap">https://github.com/twbs/bootstrap</a>，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/bootstrap.git</span><br></pre></td></tr></table></figure>

<p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p>
<p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─ GitHub ────────────────────────────────────┐</span><br><span class="line">│                                             │</span><br><span class="line">│ ┌─────────────────┐     ┌─────────────────┐ │</span><br><span class="line">│ │ twbs/bootstrap  │────&gt;│  my/bootstrap   │ │</span><br><span class="line">│ └─────────────────┘     └─────────────────┘ │</span><br><span class="line">│                                  ▲          │</span><br><span class="line">└──────────────────────────────────┼──────────┘</span><br><span class="line">                                   ▼</span><br><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ local/bootstrap │</span><br><span class="line">                          └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p>
<p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p>
<p>如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：<a href="https://github.com/michaelliao/learngit">https://github.com/michaelliao/learngit</a>，创建一个<code>your-github-id.txt</code>的文本文件，写点自己学习Git的心得，然后推送一个pull request给我，我会视心情而定是否接受。</p>
<p><strong>小结</strong></p>
<ul>
<li>在GitHub上，可以任意Fork开源仓库；</li>
<li>自己拥有Fork后的仓库的读写权限；</li>
<li>可以推送pull request给官方仓库来贡献代码。</li>
</ul>
<h3 id="十、使用Gitee"><a href="#十、使用Gitee" class="headerlink" title="十、使用Gitee"></a>十、使用Gitee</h3><p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。</p>
<p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——<a href="https://gitee.com/?utm_source=blog_lxf">Gitee</a>（<a href="https://gitee.com/?utm_source=blog_lxf">gitee.com</a>）。</p>
<p>和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p>
<p> Gitee的免费版本也提供私有库功能，只是有5人的成员上限。 </p>
<p>使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的<code>.ssh/id_rsa.pub</code>文件的内容粘贴进去，点击“确定”即可完成并看到刚才添加的Key。</p>
<p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？</p>
<p>首先，我们在Gitee上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”。</p>
<p>项目名称最好与本地库保持一致：</p>
<p>然后，我们在本地库上使用命令<code>git remote add</code>把它和Gitee的远程库关联：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure>

<p>之后，就可以正常地用<code>git push</code>和<code>git pull</code>推送了！</p>
<p>如果在使用命令<code>git remote add</code>时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure>

<p>这说明本地库已经关联了一个名叫<code>origin</code>的远程库，此时，可以先用<code>git remote -v</code>查看远程库信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin	git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin	git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure>

<p>可以看到，本地库已经关联了<code>origin</code>的远程库，并且，该远程库指向GitHub。</p>
<p>我们可以删除已有的GitHub远程库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>

<p>再关联Gitee的远程库（注意路径中需要填写正确的用户名）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure>

<p>此时，我们再查看远程库信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin	git@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">origin	git@gitee.com:liaoxuefeng/learngit.git (push)</span><br></pre></td></tr></table></figure>

<p>现在可以看到，origin已经被关联到Gitee的远程库了。通过<code>git push</code>命令就可以把本地库推送到Gitee上。</p>
<p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联Gitee呢？</p>
<p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p>
<p>使用多个远程库时，我们要注意，git给远程库起的默认名称是<code>origin</code>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p>
<p>仍然以<code>learngit</code>本地库为例，我们先删除已关联的名为<code>origin</code>的远程库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>

<p>然后，先关联GitHub的远程库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure>

<p>注意，远程库的名称叫<code>github</code>，不叫<code>origin</code>了。</p>
<p>接着，再关联Gitee的远程库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure>

<p>同样注意，远程库的名称叫<code>gitee</code>，不叫<code>origin</code>。</p>
<p>现在，我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">gitee	git@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">gitee	git@gitee.com:liaoxuefeng/learngit.git (push)</span><br><span class="line">github	git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">github	git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure>

<p>如果要推送到GitHub，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure>

<p>如果要推送到Gitee，使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push gitee master</span><br></pre></td></tr></table></figure>

<p>这样一来，我们的本地库就可以同时与多个远程库互相同步：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────┐ ┌─────────┐</span><br><span class="line">│ GitHub  │ │  Gitee  │</span><br><span class="line">└─────────┘ └─────────┘</span><br><span class="line">     ▲           ▲</span><br><span class="line">     └─────┬─────┘</span><br><span class="line">           │</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ Local Repo  │</span><br><span class="line">    └─────────────┘</span><br></pre></td></tr></table></figure>

<p>Gitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：<a href="https://gitee.com/liaoxuefeng/learngit?utm_source=blog_lxf">https://gitee.com/liaoxuefeng/learngit</a>，创建一个<code>your-gitee-id.txt</code>的文本文件， 写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在Gitee和GitHub做双向同步。</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>本博客主要内容转自廖雪峰大神的Git学习版块，原文链接如下：</p>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
<p>如果涉嫌侵权，著作权人可以联系我，我会立即删除。 </p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>信号与系统概念本质理解</title>
    <url>/2022/01/27/signal-and-system-essence/</url>
    <content><![CDATA[<h3 id="一、模拟频率、模拟角频率、数字频率"><a href="#一、模拟频率、模拟角频率、数字频率" class="headerlink" title="一、模拟频率、模拟角频率、数字频率"></a>一、模拟频率、模拟角频率、数字频率</h3><h4 id="1-模拟频率f"><a href="#1-模拟频率f" class="headerlink" title="1. 模拟频率f"></a>1. 模拟频率f</h4><p>包括在模拟电路、高频电路以及传感器课程上，都是以f作为频率响应函数的横坐标。使用f的好处是其真实反映了实际系统的工作情况，从0到∞，反映了实际模拟信号振荡速度的快慢。  </p>
<h4 id="2-模拟角频率Ω"><a href="#2-模拟角频率Ω" class="headerlink" title="2. 模拟角频率Ω"></a>2. 模拟角频率Ω</h4><p>Ω=2πf，写成cos(Ωt)来描述模拟余弦函数。此时Ω的取值也是从0到∞，这体现出模拟(角)频率没有周期性的特点。</p>
<h4 id="3-数字角频率ω"><a href="#3-数字角频率ω" class="headerlink" title="3. 数字角频率ω"></a>3. 数字角频率ω</h4><p>ω完全颠覆了我们过往对于频率的认识，首先要明确的是数字信号的获得是通过对模拟信号采样的方式。它的引入可以从cos(Ωt)开始。cos(Ωt)中相位变化一个周期(2π)所需的时间为T，那么模拟角频率定义成Ω=2π/T=2πf。对于该余弦信号，采样之后变成了一个离散的数字序列，此时再谈论过了多少时间走完一个周期已经没有意义，而是过了间隔N相位刚好变化一个周期。因此数字角频率推导出为ω=2π/N，余弦信号则为cos(ωn)。既然N是由对应一段时间T采样而来，那么N=T*fs (fs为采样率)=T/ts(ts为对应的采样间隔)，自然而然，ω=Ω/fs=Ω*ts=2πf/fs。</p>
<p><font color="red"><strong>简单来说，数字角频率ω是模拟角频率Ω对于采样率fs的归一化，这是数字角频率ω的核心要义。</strong></font></p>
<blockquote>
<p>注意：Ω和ω具体哪个表示模拟角频率和数字角频率看具体的书籍，理解这个意思就行。</p>
</blockquote>
<h4 id="4-一些涉及本质的问题"><a href="#4-一些涉及本质的问题" class="headerlink" title="4.  一些涉及本质的问题"></a>4.  一些涉及本质的问题</h4><h5 id="1-如何理解数字信号处理中傅里叶变换的周期为2π-？"><a href="#1-如何理解数字信号处理中傅里叶变换的周期为2π-？" class="headerlink" title="1-如何理解数字信号处理中傅里叶变换的周期为2π ？"></a>1-如何理解数字信号处理中傅里叶变换的周期为2π ？</h5><blockquote>
<p>分析信号的频谱特性时，经常要对信号进行傅里叶变换，但傅里叶变换是以2π为周期，而时域里的信号角频率的范围是很宽的，为什么傅里叶变换中的0~2π就可以代表信号整个频率范围呢？</p>
</blockquote>
<p>1、模拟信号的频率：模拟频率越大，信号变化越快。拿构成模拟信号的频率分量来说，比如cos(Ωt)。</p>
<p>2、数字信号是对模拟信号[等间隔]抽样得到的，即cos(Ω*ts*n)=cos(ω*n)，ω=Ω*ts[称为数字频率]，由于**离散[数字]信号的自变量<font color="red">n是整数</font>*<em>，因此数字频率ω与ω+2π*M是同一个数字频率——即cos(ωn)=cos[(ω+2π</em>M)n]。对离散信号作傅里叶变换，实际上是将离散信号[量化后就是数字信号]分解为e^jωn的线性组合，其频谱就具有周期性，频率为ω的频谱等于频率为ω+2πM的频谱。</p>
<p>3、再来看cos(ωn)是构成实数离散信号的基本信号，它最大的频率是多少呢?周期最小N=1，故变化最快的是ω=π；变化最慢的当然是直流ω=0。因此ω=0频率最小，w=π最高频率，对应模拟信号频率为Ω=ω/T=π/T=fs/2[采样频率的一半]。对实数离散信号来说，0~2π的频谱图是以ω=π对称的。</p>
<p>4、根据时域采样定理，采样频率fs最小为被采样模拟信号最高频率的2倍；因此可以认为被采样模拟信号最高频率=fs/2，这个频率对应数字频率的π 。</p>
<p>5、实际中即使模拟信号的最高频率是无穷大，但是可以通过滤波，滤去无用的高频分量，再对他抽样以避免频谱混叠。</p>
<p>e.g. Fs=1Hz，Ω分别等于π/8和π*17/8，得到如下两幅图。可以看出虽然模拟角频率Ω增加了2π，但由于采样点数和采样值都相同，所以实际的离散信号是一回事。 </p>
<p><img src="https://pic1.zhimg.com/80/v2-f23a15fb4a8a85a2c9885597f2d54a70_720w.jpg"> </p>
<p>正是因为数字信号对于ω具有周期性，DSP才增加了额外的很多考虑：</p>
<p>1）DTFT、DFT是将数字信号从时间域n转为频域ω，因此我们只转为ω在[-π,π]区间内复指数信号的叠加。（也可以考虑[0,2π]，不过由于ω=0和2π是低频信号，ω=π是高频信号，考虑[-π,π]更接近模拟信号的频谱分布）</p>
<p>2）我们根据ω=Ω/fs可知，从模拟角频率到数字角频率不只会落在[-π,π]，若转为数字频谱后其频带占用超过了[-π,π]，则由于具有周期性，相互之间会产生混叠。我们要把频谱ω限定在[-π,π]，则，由奈奎斯特采样定理可以知道，fs必须≥信号最高频率的2倍才不会发生信号混叠，因此fs能采样到的信号最高频率为fs/2 </p>
<p>3）在运用频域采样法设计IIR时，我们基于的AD/DA转换就是上述的ω=Ω/Fs（双线性变化法则不是）。上述说到模拟角频率Ω是没有周期性可言的，但是由于采样率的限制(离散化)，导致说数字角频率ω具有周期性。从映射角度理解，数字角频率[-π,π]在模拟角频率上的映射是一对多的。采样间隔T=1/Fs，在给定T时，数字角频率ω受到的影响来源于以2π/T为单位的模拟角频率Ω（Ω=ω/T）。为了使数字频域不发生混叠，我们需要将模拟角频率Ω框在[-π/T,π/T]，这在设计高通/带阻数字滤波器时是复杂的，如下图展示的用频域采样法设计高通FIR时所需要增加的裁剪步骤。 </p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>[1]数字角频率ω与模拟角频率Ω的理解 - 知乎 <a href="https://zhuanlan.zhihu.com/p/53664104">https://zhuanlan.zhihu.com/p/53664104</a></p>
<p>[2]模拟角频率和数字角频率的关系 <a href="https://blog.csdn.net/jyfu2_12/article/details/78650858">https://blog.csdn.net/jyfu2_12/article/details/78650858</a> </p>
<p>[3]如果理解数字信号处理中傅里叶变换的周期为2pi？<a href="http://www.360doc.com/content/18/1008/20/38894361_793066968.shtml">http://www.360doc.com/content/18/1008/20/38894361_793066968.shtml</a></p>
<p>[4]所有的傅里叶变换之后的频域信号周期都是2π吗？ - 尔尔的回答 - 知乎 <a href="https://www.zhihu.com/question/65441510/answer/298234811">https://www.zhihu.com/question/65441510/answer/298234811</a> </p>
<hr>
<h3 id="二、傅里叶级数-傅里叶变换推导"><a href="#二、傅里叶级数-傅里叶变换推导" class="headerlink" title="二、傅里叶级数-傅里叶变换推导"></a>二、傅里叶级数-傅里叶变换推导</h3><h4 id="1-傅里叶级数"><a href="#1-傅里叶级数" class="headerlink" title="1. 傅里叶级数"></a>1. 傅里叶级数</h4><h5 id="1-傅里叶级数的普通形式"><a href="#1-傅里叶级数的普通形式" class="headerlink" title="(1) 傅里叶级数的普通形式"></a>(1) 傅里叶级数的普通形式</h5><p>设信号的周期为$T_1$，对应的$\omega_1 = \dfrac{2\pi}{T_1}$</p>
<p>周期函数可以分解为三角函数系的组合：<br>$$<br>f(t) = \sum_{n=0}^{\infty}a_k\cos n \omega_1 t + \sum_{n = 0}^{\infty}b_n\sin n \omega_1 t \tag{1.1}<br>$$<br>但是我们见到课本上一般是下面这种形式：<br>$$<br>f(t) = \frac{a_0}{2}+\sum_{n=1}^{\infty}[a_n\cos n \omega_1 t + b_n\sin n \omega_1 t]<br>$$<br>将$n = 0$单独分出来化简就可以得到下面的形式，我们就以课本常见的格式求解系数：$a_0, a_n, b_n$<br>$$<br>\frac{a_0}{2} = \frac{1}{T_1}\int_{0}^{T_1}{f(t)dt}<br>$$</p>
<p>$$<br>a_n = \frac{2}{T_1}\int_{0}^{T_1}f(t)\cos n \omega_1 tdt<br>$$</p>
<p>$$<br>b_n = \frac{2}{T_1}\int_{0}^{T_1}f(t)\sin n \omega_1 tdt<br>$$</p>
<h5 id="2-傅里叶级数的复数形式"><a href="#2-傅里叶级数的复数形式" class="headerlink" title="(2) 傅里叶级数的复数形式"></a>(2) 傅里叶级数的复数形式</h5><p>利用欧拉公式：$e^{j\theta} = \cos\theta + j\sin\theta$ 可以将其转换为复指数形式：<br>$$<br>f(t) = \sum_{n = -\infty}^{\infty}C_ne^{jn\omega_0 t}<br>$$<br>其系数为：<br>$$<br>C_n = \frac{1}{T}\int_0^Tf(t)e^{-jn\omega_0 t}dt<br>$$<br>其中：$\omega_0 = \dfrac{2\pi}{T}$</p>
<h4 id="2-傅里叶变换"><a href="#2-傅里叶变换" class="headerlink" title="2. 傅里叶变换"></a>2. 傅里叶变换</h4><p>对于非周期信号，我们可以将其视为一种特殊的周期函数，只不过该周期函数的周期$T \rightarrow \infty$，据此，我们做以下变换，将傅里叶级数转变为傅里叶变换：<br>$$<br>f(t) = \frac{1}{2\pi}\int_{-\infty}^{\infty} F(\omega)e^{j\omega t}d\omega<br>$$<br>其中，$F(\omega)$就是$f(t)$的傅里叶变换：<br>$$<br>F(\omega) = \int_{-\infty}^{\infty}f(t)e^{-j\omega t}dt<br>$$</p>
<h4 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h4><p>[1]纯干货数学推导_傅里叶级数与傅里叶变换 <a href="https://www.bilibili.com/video/BV1Et411R78v?share_source=copy_web">https://www.bilibili.com/video/BV1Et411R78v?share_source=copy_web</a></p>
<p>[2]傅里叶变换系列学习（1）—-从线性变换说起 - 技术派到了中年的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/96521358">https://zhuanlan.zhihu.com/p/96521358</a> </p>
<hr>
<h3 id="三、拉普拉斯变换、Z变换"><a href="#三、拉普拉斯变换、Z变换" class="headerlink" title="三、拉普拉斯变换、Z变换"></a>三、拉普拉斯变换、Z变换</h3><h4 id="1-拉普拉斯变换LT"><a href="#1-拉普拉斯变换LT" class="headerlink" title="1. 拉普拉斯变换LT"></a>1. 拉普拉斯变换LT</h4><p>不是所有的信号都能从时域经过傅里叶变换到频域。必须是满足<strong>狄利赫里条件</strong>的信号才能进行傅里叶变换。</p>
<ul>
<li><p>狄利赫里条件</p>
<p>函数在任意有限区间内连续，或只有有限个第一类间断点；</p>
<p>在一个周期内，函数有有限个极大值或极小值；</p>
<p>函数绝对可积，即$\int_0^\infty |f(t)|&lt; \infty$；</p>
</li>
</ul>
<p>为了将绝对不可积函数可以进行傅里叶变换，我们引入一个衰减因子$e^{-\sigma t}$，将傅里叶变换推广到拉普拉斯变换：<br>$$<br>F(\omega) = \int_{-\infty}^{\infty}f(t)e^{-\sigma t}e^{-j\omega t}dt =  \int_{-\infty}^{\infty}f(t)e^{-(\sigma+j\omega) t}dt<br>$$</p>
<p>$$<br>f(t) = \frac{1}{2\pi} \int_{-\infty}^{\infty}F(\omega)e^{(\sigma+j\omega) t}d\omega<br>$$</p>
<h4 id="2-Z变换ZT"><a href="#2-Z变换ZT" class="headerlink" title="2. Z变换ZT"></a>2. Z变换ZT</h4><p>离散数字信号域的ZT相当于连续时间信号的FT，其也是为了处理不满足绝对可和的数字信号(e.g. $ f(k) = k^2$)，因此我们给它乘以一个衰减因子$e^{-\sigma n}$(另一种理解方法，让离散复指数乘以一个放大因子，不断变大，就能跟上信号的变化，从而降服信号)<br>$$<br>X(z) = \sum_{n = -\infty}^{\infty}x(n)z^{-n} = \sum_{n = -\infty}^{\infty}x(n)e^{-\sigma n}e^{-j\omega n}<br>$$</p>
<p>$$<br>x(n) = \frac{1}{2\pi j} \oint X(z)z^{n-1}dz<br>$$</p>
<p>和拉普拉斯变换一样，z变换也有<strong>收敛域</strong>的概念。 拉普拉斯$s = \sigma +j \omega$ 对应的是直角坐标是一个平面。 Z变换$z = e^{\sigma + j\omega}$对应的是一个极坐标系是一个圆。 </p>
<p><img src="https://pic2.zhimg.com/80/v2-b0771ba027e7d23fed45975f267bb407_720w.jpg?source=1940ef5c"> </p>
<h4 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h4><p>[1]傅里叶变换、拉普拉斯变换、Z 变换的联系是什么？为什么要进行这些变换？ - 知乎 <a href="https://www.zhihu.com/question/22085329">https://www.zhihu.com/question/22085329</a> </p>
<hr>
<h3 id="四-、DFS、DTFT、DFT、FFT"><a href="#四-、DFS、DTFT、DFT、FFT" class="headerlink" title="四 、DFS、DTFT、DFT、FFT"></a>四 、DFS、DTFT、DFT、FFT</h3><p>根据前面的学习，对一些信号采样然后进行DTFT之后，得到的信号在频域上还是连续的（也就是对于我们归一化之后的角频率ω还是连续的，是以2π为周期的，以π为对称中心），这样对于计算机来说还是没有办法处理的，所以再在频域内对其采样，采样之后的得到的就是DFT。<br>DFS是对于时域是离散的周期信号来说的，DFS与DFT的区别就是相对于我们之前时域连续信号中的傅里叶级数与傅里叶变换。</p>
<table>
<thead>
<tr>
<th align="center">变换方法</th>
<th align="center">时域</th>
<th align="center">频域</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\rm{FS}$</td>
<td align="center">连续周期信号</td>
<td align="center">离散非周期频谱</td>
</tr>
<tr>
<td align="center">$\rm{FT}$</td>
<td align="center">连续非周期信号</td>
<td align="center">连续非周期频谱</td>
</tr>
<tr>
<td align="center">$\rm{DFS}$</td>
<td align="center">离散周期信号</td>
<td align="center">离散周期频谱</td>
</tr>
<tr>
<td align="center">$\rm{DTFT}$</td>
<td align="center">离散非周期信号</td>
<td align="center">连续周期频谱</td>
</tr>
<tr>
<td align="center">$\rm{DFT}$</td>
<td align="center">离散非周期信号</td>
<td align="center">离散非周期频谱</td>
</tr>
<tr>
<td align="center">$\rm{FFT}$</td>
<td align="center">离散非周期信号</td>
<td align="center">离散非周期频谱</td>
</tr>
</tbody></table>
<h4 id="1-离散时间傅里叶变换DTFT"><a href="#1-离散时间傅里叶变换DTFT" class="headerlink" title="1. 离散时间傅里叶变换DTFT"></a>1. 离散时间傅里叶变换DTFT</h4><p>严格来说，<strong>DTFT</strong>处理的是离散时间序列信号，这种信号在时间上是离散的，但是信号的幅度是可以任意值，也就是说没有量化，还不是数字信号。非严格的场合，可以认为它是离散信号，并且是非周期信号。<br>$$<br>X(\omega) = \sum_{-\infty}^{\infty}x[n]e^{-j\omega n}<br>$$</p>
<p>$$<br>x[n] = \frac{1}{2\pi}\int_{2\pi} X(\omega)e^{-j\omega n}<br>$$</p>
<h4 id="2-离散傅里叶级数DFS"><a href="#2-离散傅里叶级数DFS" class="headerlink" title="2. 离散傅里叶级数DFS"></a>2. 离散傅里叶级数DFS</h4><p>一个周期为$N$的周期序列，即$x(n)=x(n+kN)$，$k$为任意整数，$N$为周期<br><strong>周期序列不能进行Z变换，因为其在负无穷到正无穷都周而复始永不衰减，即Z平面上没有收敛域。</strong>但是正像连续时间周期信号可用傅氏级数表示，周期序列也可用离散的傅里叶级数来表示，也即用周期为$N$的正弦序列及其谐波来表示。</p>
<p>在连续域，我们的基是$\displaystyle{e^{jk\omega_0 t}}$是周期，其中$k$是整数，一直变化对应到不同的基，$\omega_0 = \dfrac{2\pi}{T}$是周期，t是连续的时间变量。这是我们第一次处理离散信号，离散信号的周期变成了$N$，连续的时间信号$t$换成离散的序列$n$，这样我们的基就变成了$ e^{j\frac{2\pi}{N}kn}$</p>
<p>离散域通常用大写字母序列表示正变换结果，小写字母序列表示原信号。<br>$$<br>X[k] = \frac{1}{N}\sum_{n=0}^{N-1}x[n]e^{-j\frac{2\pi}{N}kn}<br>$$</p>
<p>$$<br>x[n] = \sum_{k=0}^{N-1}X[k]e^{j\frac{2\pi}{N}kn}<br>$$</p>
<p>由上知， <strong>DFS是DTFT在单位圆上的N等分</strong>，其傅里叶级数不仅是离散的，而且还是周期性的(以N为周期) </p>
<h4 id="3-离散傅里叶变换DFT"><a href="#3-离散傅里叶变换DFT" class="headerlink" title="3. 离散傅里叶变换DFT"></a>3. 离散傅里叶变换DFT</h4><p><strong>DFT</strong>才是我们耳熟能详的变换，<strong>DFT</strong>处理的是非周期离散信号，这样的信号计算机比较容易处理，我们再看看<strong>DTFT</strong>，正变换产生了连续信号，这个不利于计算机处理。为了方便计算机处理，必须让正变换的结果也是离散值，这一点<strong>DFS</strong>正满足。<strong>DFS</strong>应对的是周期离散信号，正变换后的序列也是周期离散的。前面我们提到，对于非周期信号，数学家总是先假设其周期为T，然后取极限，让T趋向于无穷大，这样得到了非周期信号的变换结果。细心的你，可能已经发现，非周期信号的变换结果，都是连续的，连续信号对于CPU来说，不是一个好东西。</p>
<p>所以，数学家在这次处理非周期信号的时候，采用了不同的方法。这次的方法是对非周期信号做周期延拓，这样不就变成<strong>DFS</strong>了吗，还要<strong>DFT</strong>做什么呢。别急，DFS变换后是周期离散信号，但是<strong>DFT</strong>只取<strong>DFS</strong>变换后的一个周期。<strong>DFT</strong>在处理的时候投机取巧，方便了计算机处理，所以我们通常听得比较多的就是<strong>DFT</strong>。</p>
<p>另外，<strong>DFT</strong>也可以从<strong>DTFT</strong>抽样过来，<strong>DTFT</strong>作为连续信号，均匀采样$N$个点，就变成<strong>DFT</strong>了。</p>
<p>$$<br>X[k] = \sum_{n = 0}^{N-1} x[n]e^{-j\frac{2\pi}{N}nk}<br>$$</p>
<p>$$<br>x[n] = \frac{1}{N} \sum_{k = 0}^{N-1} X[k]e^{j\frac{2\pi}{N}nk}<br>$$</p>
<p><font color="red"><strong>[6]</strong></font>可以发现，DFT与离散傅里叶级数（DFS）仅有一点点区别，那就是DFT在逆变换时，即在合成源信号时，会乘上1/N，而DFS相反，除开这一点并无区别，所以这就表示是，<font color="red"><strong>DFT实际上是，以信号的N点为周期的信号的DFS</strong></font>，那么DFT和DTFT是什么关系呢？从上述角度上来讲，只能说当DFT所取点数趋于无穷时，那么DFT就可以趋近于DTFT，这也是傅里叶变换的来源，那么书上不是有DFT是DTFT的采样的结论么？该结论是怎样来的？有条件么？</p>
<p>在ω轴上$0 \leq \omega \leq 2\pi$范围内，对DTFT的变换结果$X(e^{j\omega})$以N个等间隔频率$\omega_k = \dfrac{2\pi k}{N}，(0 \leq k \leq N-1)$均匀抽样，可得：<br>$$<br>X(e^{j\omega})|<em>{\omega = \frac{2\pi k}{N}}=\sum</em>{ n= 0}^{N-1}x[n]e^{\frac{j2\pi kn}{N}}，0 \leq k \leq N-1<br>$$<br>个人认为，这也解答了为何DFS与DFT有个系数上的差异，这就是为了在DTFT与DFT的满足采样特点的吻合。</p>
<p>在许多书上，离散时间傅里叶变换都是由是连续信号采样得到的离散信号而得到，这样来介绍，由于有采样频率等的影响，这样会对连续、离散信号产生一定的混淆，个人认为，离散傅里叶变换时离散时间信号的频域特性，并不一定非得和采样、连续信号等产生关系，离散信号可以是由连续信号采样，归一化产生，也可以是其本身就是离散的，如年月日，像素坐标等，如果离散信号是由连续信号采样得到的，那么，当用给定的采样频率，对连续信号采样，归一化后，那么就产生了一个新的离散信号，至于其傅里叶变换和原来的傅里叶变换有何关系，这就是另外一个话题了。</p>
<p>傅里叶变换的核心思想便是能让任意一个信号都可以由一种基本信号来合成，这个基本信号对于**连续时间信号便是：exp(jωt)，离散时间信号便是：exp(jωn)**。</p>
<p>对于DTFT的定义式，可以发现其积分是由[-π, π]，而对于FT的定义式积分是从（-∞, ∞），<font color="red"><strong>其根本原因就是——基本信号存在差异</strong></font>，对于exp(jωt)，由于t可以取任意值因此其不存在周期，当ω取任意值，exp(jωt)都会变为一个独一无二的信号，故FT需要从（-∞, ∞），让每一个exp(jωt)都能成为被合成信号的成分（当然这还得取决于前面系数，即傅里叶系数），而对于DTFT而言，由于其基本信号exp(jωn)中n只能取正整数故周期为2π，故当要合成新信号时，只需要取任何一个2pi区段就可获得合成信号的所有成分，故上式取[-π, π]即可，当然，这样也很容易得出F(exp(jw))也是周期的。<font color="red"><strong>[6]</strong></font></p>
<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p>[1]数字信号处理（DTFT与DFT、DFS的详细讲解以及FFT算法）<a href="https://blog.csdn.net/qq_44554964/article/details/108025590">https://blog.csdn.net/qq_44554964/article/details/108025590</a></p>
<p>[2]傅里叶变换系列学习（3)—-FS,FT,DTFT,DFS,DFT,FFT - 技术派到了中年的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/97835957">https://zhuanlan.zhihu.com/p/97835957</a> </p>
<p>[3]一幅图弄清DFT与DTFT,DFS的关系 <a href="https://www.cnblogs.com/BitArt/archive/2012/11/24/2786390.html">https://www.cnblogs.com/BitArt/archive/2012/11/24/2786390.html</a></p>
<p>[4]学习笔记-DTFT、DFS和DFT的联系 <a href="https://blog.csdn.net/wuyiqingtian/article/details/78838503?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164346473116780269843335%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164346473116780269843335&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-78838503.first_rank_v2_pc_rank_v29&amp;utm_term=dft%E4%B8%8Edfs%E7%9A%84%E5%85%B3%E7%B3%BB&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/wuyiqingtian/article/details/78838503?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164346473116780269843335%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164346473116780269843335&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-78838503.first_rank_v2_pc_rank_v29&amp;utm_term=dft%E4%B8%8Edfs%E7%9A%84%E5%85%B3%E7%B3%BB&amp;spm=1018.2226.3001.4187</a></p>
<p>[5]五种傅里叶变换的分析（FT、FS、DTFT、DFT、DFS）<a href="https://www.codenong.com/cs106440896">https://www.codenong.com/cs106440896</a></p>
<p>[6]关于对傅里叶变换的一些理解 <a href="https://blog.51cto.com/rainlee/1629264">https://blog.51cto.com/rainlee/1629264</a></p>
<p>[7]数字信号处理系列串讲第6篇（离散信号的频域分析之三）——离散傅里叶变换DFT（1）<a href="http://www.360doc.com/content/19/0611/18/908538_841808337.shtml">http://www.360doc.com/content/19/0611/18/908538_841808337.shtml</a></p>
<hr>
<h3 id="五、采样频率、频率分辨率"><a href="#五、采样频率、频率分辨率" class="headerlink" title="五、采样频率、频率分辨率"></a>五、采样频率、频率分辨率</h3><h4 id="1-采样定理"><a href="#1-采样定理" class="headerlink" title="1. 采样定理"></a>1. 采样定理</h4><ul>
<li>时域采样定理的一种表述方式是：当时间信号函数$f(t)$的最高频率分量为$f_M$时，$f(t)$的值可由一系列采样间隔$t_s \leq \dfrac{1}{2×f_M}$的采样值来确定，即采样点的重复频率$f ≥ 2×f_M$。时域采样定理是采样误差理论、随机变量采样理论和多变量采样理论的基础。  </li>
<li>频域采样定理：对于时间上受限制的连续信号$f(t)$ (即当$│t│&gt;t_m $时，$f(t)=0$，这里信号的持续时间是$-t_m,t_m$)，若其频谱为$F(ω)$，则可在频域上用一系列离散的采样值来表示，只要这些采样点的频率间隔$\omega \leq \dfrac{\pi}{t_m}$</li>
</ul>
<h4 id="2-FFT频率分辨率"><a href="#2-FFT频率分辨率" class="headerlink" title="2. FFT频率分辨率"></a>2. FFT频率分辨率</h4><p><font color="red"><strong>[1]</strong></font>这里涉及到两种意义下的分辨率问题，一种叫“波形频率分辨率（Waveform frequency resolution）”，另一种则叫做“FFT分辨率”。虽然，这个分类和命名不一定是很专业的术语，但却有助于对“频率分辨率”概念的理解。在没有补零的情况下，这两个概念通常容易被混淆，因为它们是等价的。</p>
<p>波形频率分辨率是指可以被分辨的2个频率的最小间隔（Spacing）；而FFT 分辨率则是频谱中的数据点数（The number of points in the spectrum），它是与做FFT的点数直接相关的。</p>
<p><strong>(1) 波形分辨率/物理分辨率</strong><br>$$<br>\Delta R_w = \frac{1}{T}<br>$$<br>其中，T是实际信号的时间长度。</p>
<p><strong>(2) FFT分辨率</strong><br>$$<br>\Delta R_f = \frac{f_s}{N_{\rm{FFT}}}<br>$$<br>其中，$f_s$为采样频率(the sampling frequency)，$N_{\rm{FFT}}$为FFT的点数。$\Delta R_f $代表了FFT频率轴上的频率取值的间隔(Spacing)。 </p>
<p>值得注意的是，可能有很好的FFT分辨率，但却不一定能够很好的把2个频率成分简单的分开。同样，可能有很高的波形分辨率，但波形的能量峰值会通过整个频谱而分散开（这是因为FFT的频率泄漏现象）。</p>
<p>我们知道，信号的离散傅里叶变换（DFT）或快速傅里叶变换（FFT）是对波形的任何一边补零形成的无限序列进行计算的。这就是，为什么FFT的每个频率单元（bin）都具有明显的sinc 波的形状。</p>
<p>波形频率分辨率1/<em>T</em>与一个sinc函数空值间隔（the space between nulls）是一样的。<font color="red"><strong>[1]</strong></font></p>
<p><strong>(3) 区别辨析</strong></p>
<p><font color="red"><strong>[2]</strong></font>用MATLAB做FFT并不要求数据点个数必须为以2为基数的整数次方。之所以很多资料上说控制数据点数为以2为基数的整数次方，是因为这样就能采用以2为基的FFT算法，提升运算性能。</p>
<p>如果数据点数不是以2为基数的整数次方，处理方法有两种，一种是在原始数据开头或末尾补零，即将数据补到以2为基数的整数次方，<strong>这是“补零”的一个用处</strong>；第二种是采用以任意数为基数的FFT算法。</p>
<p>而MATLAB的$\rm{fft}(x,N)$函数参数 N 正好就是数据 x 的长度，但又不是以2为基数的整数次方时，并不会采用补零的方法，而是采用以任意数为基数的FFT算法，这样也能得到很好的结果，只不过速度要稍稍慢了一些，但一般的计算量是体现不出来的。 </p>
<p>比如，现在我有一个信号，这个信号中仅包含两个正（余）弦波，一个是$1MHz$，一个是$1.05MHz$，即$x = \cos(2\pi × 1000000t) + \cos(2\pi × 1050000t)$，设采样频率为$f_s = 100MHz$，如果采1000个点，那么对应的时域信号时长为$\rm T = 10\mu s$。</p>
<p><img src="https://pic2.zhimg.com/80/v2-01f2dfe21d8ba98ff8e6c9e40c935d3d_720w.jpg" alt="img"></p>
<p>直接对这1000个数据点其做快速傅里叶变换，将得到频谱图： </p>
<p><img src="https://pic1.zhimg.com/80/v2-2aa8d1c2ea81ceca939656cace132fb0_720w.jpg" alt="img"></p>
<p>可以发现，频谱点稀疏，在1MHz附近根本无法将1 MHz 和1.05 MHz 的两个频率分开。 发现频率成分无法被区分开来，第一反应应该就是：<strong>频率分辨率不够</strong>。那么如何提高频率分辨率呢？这里就涉及两种分辨率的区别了。之所以要区分，是因为后面要进行“补零”操作。<strong>如果不补零，直接对原始数据做FFT，那么这两种分辨率是相等的。</strong><br>$$<br>\Delta R_w = \frac{1}{10\mu s} = \Delta R_{\rm{fft}} = \frac{100MHz}{1000} = 100kHz<br>$$<br>那么，如果现在在原始数据点后补零会有什么效果呢？假设在这 1000个原始数据点后面再补充零达到7000个点，那么数据变成了： </p>
<p><img src="https://pic1.zhimg.com/80/v2-0bed54499d2710feebc61caa15e18ed8_720w.jpg" alt="img"></p>
<p>此时对其做快速傅里叶变换，结果如下： </p>
<p><img src="https://pic3.zhimg.com/80/v2-0a8ad57d53988753f9cd3a988209b78e_720w.jpg" alt="img"></p>
<p>可以发现，频谱点密集了不少，但是在$1MHz$ 附近依然无法将$1MHz$ 和$1.05MHz$  的两个频率成分分开。这是因为从波形分辨率公式可以看出，<strong>波形分辨率只与原始数据的时长 $\rm T$ 有关</strong>，而与参与FFT的数据点数无关。所以，虽然补了很多零，但波形分辨率依然为：$\Delta R_w = \dfrac{1}{10 \mu s} = 100kHz$，该分辨率大于$1MHz$ 和$1.05MHz$ 这两个频率成分之间的距离$50kHz$  。<u>这就好比用筛子分黄豆和大米，分辨率就好像是筛子上孔的大小，如果筛子的孔太大了，就没有办法把这两者分开。&lt;\u&gt;</u></p>
<p>而“时域补零相当于频域插值”，也就是说，补零操作增加了频域的插值点数，让频域曲线看起来更加光滑，也就是增加了FFT频率分辨率， <strong>这是“补零”的另一个原因</strong>。</p>
<p>显然，根据上面的分析可知，在采样频率不变的情况下，要想将$1MHz$ 和$1.05MHz$这两个频率成分分析出来，光靠“补零”是不够的，必须要改变波形分辨率，也就是要延长原始数据的时长。现在以相同的采样频率对信号采 7000个点作为原始信号： </p>
<p><img src="https://pic3.zhimg.com/80/v2-32029919adbe12a30b90c8e98ff27006_720w.jpg" alt="img"></p>
<p>对其做快速傅里叶变换，结果如下： </p>
<p><img src="https://pic1.zhimg.com/80/v2-9556ee10b97ab311bf903a1736f72408_720w.jpg" alt="img"></p>
<p>因为此时的波形分辨率为：$\Delta R_w = \dfrac{1}{70 \mu s} \approx  14kHz$ ，小于两个频率成分之间的距离 $50kHz$ ，所以可以看出有两个明显的峰值。</p>
<p>但是会发现$1MHz$对应的幅值为1，与原始信号中该频率成分的幅值一致，但$1.05MHz$ 对应的幅值明显低于1，但是其周边的点上却都有不小的幅值，这就是所谓的<strong>频谱泄露</strong>，因为数据点的个数影响，使得在$1MHz$ 处有谱线存在，但在$1.05MHz$处没有谱线存在，使测量结果偏离实际值 ,同时在实际频率点的能量分散到两侧的其它频率点上，并出现一些幅值较小的假谱。</p>
<p>为了解决这个问题，可以设法使得谱线同时经过$1MHz$ 和$1.05MHz$ 这两个频率点，找到他们的公约数。</p>
<p>如果原始数据不变，在后面再补充1000个零点：</p>
<p><img src="https://pic2.zhimg.com/80/v2-fe63f79cccb30f13e6ae20bd874aff5d_720w.jpg" alt="img"></p>
<p>那么FFT分辨率就是$12.5kHz$，是这两个频率的公约数，$1MHz = 80×12.5kHz，1.05MHz = 84×12.5kHz$ ，所以谱线同时经过 $1MHz$ 和 $1.05MHz$ 这两个频率点。</p>
<p>对其做快速傅里叶变换，结果如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-47b7734d4bc41139bd63fcd4e5a1c56e_720w.jpg" alt="img"></p>
<p>会发现两个频率对应的幅值均为1，与原始信号一致。</p>
<p>**这也是一种补零操作带来的影响???(这里有点问题，频谱泄露与补零没有关系，后续修改补充)**。 </p>
<p>上图会有一些旁瓣出现，这是因为补零影响了原始信号，如果，直接采8000个点作为原始数据，那么有： </p>
<p><img src="https://pic2.zhimg.com/80/v2-ccb254206114c54cba6d7206d7c3cd09_720w.jpg" alt="img"></p>
<p>并对其做FFT，结果如下 </p>
<p><img src="https://pic3.zhimg.com/80/v2-47cba941d29fc331bde5241921dab2ca_720w.jpg" alt="img"></p>
<p>这样就不存在补零带来的误差了。 <font color="red"><strong>[2]</strong></font></p>
<p><img src="/2022/01/27/signal-and-system-essence/Users\27275\AppData\Local\Temp\1643602118945.png" alt="1643602118945"></p>
<h4 id="参考链接-3"><a href="#参考链接-3" class="headerlink" title="参考链接"></a>参考链接</h4><p>[1]傅里叶变换的波形分辨率与频率分辨率 <a href="https://wap.sciencenet.cn/blog-425437-1043431.html?mobile=1">https://wap.sciencenet.cn/blog-425437-1043431.html?mobile=1</a></p>
<p>[2]快速傅里叶变换(FFT)中为什么要“补零”？ - 李狗嗨的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/85863024">https://zhuanlan.zhihu.com/p/85863024</a> </p>
<p>[3]观察频谱的窗口——物理与计算分辨率 <a href="http://www.360doc.com/content/20/0402/23/32196507_903494495.shtml">http://www.360doc.com/content/20/0402/23/32196507_903494495.shtml</a></p>
<p>[4]傅里叶变换补零与能否提高频率分辨率 <a href="https://blog.csdn.net/chichuhe/article/details/90369651">https://blog.csdn.net/chichuhe/article/details/90369651</a></p>
<p>[5]DFT中人为地补零加长序列对频谱的影响？ - 杨树下的狐狸的回答 - 知乎 <a href="https://www.zhihu.com/question/30312644/answer/47615752">https://www.zhihu.com/question/30312644/answer/47615752</a> </p>
<hr>
<h3 id="六、能量信号、功率信号"><a href="#六、能量信号、功率信号" class="headerlink" title="六、能量信号、功率信号"></a>六、能量信号、功率信号</h3><hr>
<h3 id="七、信号的频谱，频谱密度，能量谱"><a href="#七、信号的频谱，频谱密度，能量谱" class="headerlink" title="七、信号的频谱，频谱密度，能量谱"></a>七、信号的频谱，频谱密度，能量谱</h3><h3 id="N、-其他问题"><a href="#N、-其他问题" class="headerlink" title="N、 其他问题"></a>N、 其他问题</h3><p><strong>如何理解奈奎斯特采样定理</strong></p>
<p>[1]怎样理解Nyquist采样定理？ - 甜草莓的回答 - 知乎 <a href="https://www.zhihu.com/question/28792456/answer/491794439">https://www.zhihu.com/question/28792456/answer/491794439</a> </p>
<p>[2]怎样理解Nyquist采样定理？ - 吃货彪彪的回答 - 知乎 <a href="https://www.zhihu.com/question/28792456/answer/2174692083">https://www.zhihu.com/question/28792456/answer/2174692083</a> </p>
<p><strong>卷积与插值(内插)</strong></p>
<p>在CFA去马赛克和图像旋转放大时都需要进行插值运算。在空间域内，<font color="red"><strong>插值是卷积计算</strong></font>。</p>
<p>当已知数据点位于整数格点上时，插值函数h(x)应该有：h(0)=1;h(n)=0; n是非零整数。</p>
<p>在频率域，以步长1采样的图像中如果含有高于1/2的频率分量将会产生混叠。空间域内的卷积对应在频率域内的相乘运算，可以从中判断插值算法的特性</p>
<p>这是几类插值函数在空间域的曲线：</p>
<p><img src="http://www.baas1995.org/digitalprocessing/interp/interp01.jpg"></p>
<p>对应频率域的变换： </p>
<p><img src="http://www.baas1995.org/digitalprocessing/interp/interp02.jpg"></p>
<p>下面比较一下几类插值算法的特点。</p>
<p>1）邻域插值。即找离插值点最近的格点的值作为插值点的值。<br>插值函数是一个宽度为1的矩形脉冲。在频率域则是一个sinc函数。在-1/2和1/2的频率附近，sinc函数对原频谱中的高频分量进行衰减，使得插值图像变得模糊；而sinc函数在频率轴上向两端无限延伸，减弱缓慢，加入了新的高频分量，对应在插值图像中形成锯齿。</p>
<p>2）线性插值。权重由离插值点的距离线性决定。<br>插值函数是半宽为1的三角脉冲，即两个宽度为1的矩形脉冲的卷积，所以在频率域是一个sinc^2函数。与邻域插值相比，混入的高频有所减少，同时图像也变得模糊。</p>
<p>3）立方插值。<br>插值函数为：((A+2)x-(A+3))x^2+1 (0&lt;x&lt;1) ((Ax-5A)x+8A)x-4A (1&lt;x&lt;2)<br>（选自<a href="http://www.all-in-one.ee/~dersch/interpolator/interpolator.html%EF%BC%89">http://www.all-in-one.ee/~dersch/interpolator/interpolator.html）</a><br>插值函数的特点：第一个节点位于x=1，此处曲线的斜率是A。第二个节点位于x=2，斜率是0。</p>
<p><img src="http://www.baas1995.org/digitalprocessing/interp/interp04.jpg"></p>
<p>在频率域上可以看出，参数A越接近0，原图像中的高频分量衰减得越厉害；A越接近-1，原图像中的高频分量衰减得越少，甚至中间波段还有提升。因此参数可以用来调节图像的锐度。根据这个网页上的数据，认为PS的算法接近于A=-0.75的效果。 </p>
<p><img src="http://www.baas1995.org/digitalprocessing/interp/interp05.jpg"></p>
<p>上面三种插值函数在+-1/2频率处的响应均降为0，从而抑制了混叠效应，同时模糊了图像。</p>
<p>4）sinc插值<br>sinc函数在频率域是一个矩形，看起来似乎最适合做内插。在+-1/2频点，矩形函数的值降低到1/2而非0，因此如果存在混叠则无法得到抑制。从实际来看，很难限制图像的带宽。因此使用sinc函数做插值在图像的边缘等地方会很敏感。另一方面，sinc函数做插值时收敛较慢，需要的采样点要多得多。在采样点较少时，在+-1/2频点会出现振荡，产生失真。</p>
<p><img src="http://www.baas1995.org/digitalprocessing/interp/interp03.jpg"></p>
<p>5）加窗sinc插值（选自<a href="http://www.all-in-one.ee/~dersch/interpolator/interpolator.html%EF%BC%89">http://www.all-in-one.ee/~dersch/interpolator/interpolator.html）</a> 将两个不等宽矩形脉冲做卷积，得到梯形脉冲。使用这个函数在频域做乘积，则图像中的高频分量受到较少的衰减，图像细节被保留，而超出采样带宽较多的分量被阻断，不会产生类似振铃的效应。 在空间域，插值函数为sinc(x)*sinc(x/w)，w是窗口宽度。与立方或线性插值相比，所需要的采样点多很多。 </p>
<p>[1]数字图像处理（九）插值算法之二 <a href="http://www.baas1995.org/digitalprocessing/interp/interp.htm">http://www.baas1995.org/digitalprocessing/interp/interp.htm</a></p>
<p>[2]图像处理中的三次卷积插值(Cubic Convolution) <a href="https://blog.csdn.net/shiyimin1/article/details/80141333">https://blog.csdn.net/shiyimin1/article/details/80141333</a></p>
<p>[3]图像插值算法——双立方（三次）卷积插值 <a href="https://blog.csdn.net/dx199771/article/details/111940754">https://blog.csdn.net/dx199771/article/details/111940754</a></p>
<p><strong>卷积与互相关函数的关系</strong></p>
<p>[1]信号处理中的卷积、深度学习中的卷积和反卷积 - 初识CV的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/366472797">https://zhuanlan.zhihu.com/p/366472797</a> </p>
<p>[2]卷积(convolution)为什么叫「卷」积(「convolut」ion)？ - 初识CV的回答 - 知乎 <a href="https://www.zhihu.com/question/54677157/answer/1849389835">https://www.zhihu.com/question/54677157/answer/1849389835</a> </p>
<p><strong>sinc函数是一组正交基？</strong></p>
<p>[1]信号与系统（5）：采样定理和多分辨分析 <a href="http://www.360doc.com/content/15/0321/23/202378_457041010.shtml">http://www.360doc.com/content/15/0321/23/202378_457041010.shtml</a></p>
<p><strong>为什么Sinc是完美插值函数？</strong></p>
<p>[1]为什么Sinc是完美插值函数 - starimpact的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/150876542">https://zhuanlan.zhihu.com/p/150876542</a> </p>
<p><strong>如何理解非周期的离散时间信号的傅里叶变换在频域上连续？</strong></p>
<p>题主问的是为什么频域上连续，其实频域的连续只和信号在时域上是否是周期信号有关，与信号是否离散还是连续没有关系。 如果题主明白连续非周期信号为什么在频域上连续，可以同理理解离散信号。由于周期的无穷大导致了频率幅度的无穷小，但也导致了频率的连续，但频率幅度之间的相对大小没有发生变化，所以序列傅立叶变换后的幅度值是一个相对值，叫频谱密度。 </p>
<p><strong>补零方式</strong></p>
<p>时域的末尾补零，提高频域计算分辨率，时域的中间补零，相当于是尺度变换，那么在频域，末尾补零，提高时域计算分辨率，中间补零，频域尺度变换，频域之间间隔越小，极限近似于连续，那么时域间断，那么相对的，频域之间间隔越大，时域平滑。 </p>
<p>时域上的f(t)变成f(2t)时，在频域上他的频谱就会压缩。这是时频之间的相反特性。 </p>
<p>[1]实现时域内插可以fft、频域补零，再ifft，那么频域补零为何要在中间部位补零呢？ - 知乎 <a href="https://www.zhihu.com/question/270235354">https://www.zhihu.com/question/270235354</a></p>
<p>[2]信号与系统 时域与频域尺度变换的二个简单问题_百度知道 <a href="http://zhidao.baidu.com/question/357985740?sharesource=weibo">http://zhidao.baidu.com/question/357985740?sharesource=weibo</a></p>
<h4 id="参考链接：-1"><a href="#参考链接：-1" class="headerlink" title="参考链接："></a>参考链接：</h4><p>[1]概率密度函数及其在信号方面的简单理解（上）概率密度函数 <a href="https://blog.csdn.net/weixin_45102840/article/details/105408476">https://blog.csdn.net/weixin_45102840/article/details/105408476</a></p>
<p>[2]信号的频谱，功率谱，能量谱，傅立叶级数，傅立叶展开，这几个有什么区别和联系吗，感觉很懵。？ - 张大侠的回答 - 知乎 <a href="https://www.zhihu.com/question/333121021/answer/738658182">https://www.zhihu.com/question/333121021/answer/738658182</a> </p>
<p>[3]功率谱密度（PSD） - 菜狗的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/417454806">https://zhuanlan.zhihu.com/p/417454806</a> </p>
<p>[4]信号的频谱，频谱密度，能力谱区别 <a href="https://www.cnblogs.com/yongzhewudi/p/5911003.html">https://www.cnblogs.com/yongzhewudi/p/5911003.html</a></p>
<p>[5]能量信号、功率信号、频谱、能量谱、功率谱、及一些定理 <a href="https://www.cnblogs.com/htj10/p/8638275.html">https://www.cnblogs.com/htj10/p/8638275.html</a></p>
<p>[6]功率谱密度（功率信号）、能量谱密度（能量信号）<a href="http://blog.sina.com.cn/s/blog_65d374720100kzms.html">http://blog.sina.com.cn/s/blog_65d374720100kzms.html</a></p>
<hr>
<p><a href="https://zhuanlan.zhihu.com/p/449608778">离散时间傅立叶变换（DTFT） - 知乎 (zhihu.com)</a> </p>
<p>做DFT时频率分辨能力的定义到底是什么？（程佩青《数字信号处理》） - 知乎 <a href="https://www.zhihu.com/question/39196097">https://www.zhihu.com/question/39196097</a> </p>
<p>在离散傅里叶变换（DFT）中如何理解采样频率、模拟频率和数字频率三者之间的关系？ - 知乎 <a href="https://www.zhihu.com/question/489681533">https://www.zhihu.com/question/489681533</a> </p>
<p><a href="https://blog.csdn.net/u010237785/article/details/73881889">关于采样与DFT的一点点思考_u010237785的博客-CSDN博客_dft 采样定理</a> </p>
<p>复信号处理（1）—-复信号理解<a href="https://blog.csdn.net/qq_36756600/article/details/117700771">https://blog.csdn.net/qq_36756600/article/details/117700771</a></p>
<hr>
<p>常见信号的FT</p>
<p>典型信号傅里叶变换 <a href="https://blog.csdn.net/Einstellung/article/details/77579386">https://blog.csdn.net/Einstellung/article/details/77579386</a> </p>
<p>典型信号的傅立叶变换 <a href="https://zhuanlan.zhihu.com/p/36276953">https://zhuanlan.zhihu.com/p/36276953</a></p>
<p>工程中常用到的几个典型周期函数的傅里叶级数展开式 <a href="https://wenku.baidu.com/view/ef3eef4601f69e3143329475.html?rec_flag=defa">https://wenku.baidu.com/view/ef3eef4601f69e3143329475.html?rec_flag=defa</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>学习提升</category>
        <category>信号与系统</category>
      </categories>
      <tags>
        <tag>信号与系统</tag>
      </tags>
  </entry>
</search>
