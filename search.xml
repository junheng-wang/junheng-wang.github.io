<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Github的学习</title>
      <link href="/2025/02/10/Learn-Github/"/>
      <url>/2025/02/10/Learn-Github/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Github介绍"><a href="#1-Github介绍" class="headerlink" title="1 Github介绍"></a>1 Github介绍</h1><h2 id="1-1-Git和Github"><a href="#1-1-Git和Github" class="headerlink" title="1.1 Git和Github"></a>1.1 Git和Github</h2><p>Git是一个版本控制系统。版本控制系统，是设计用于跟踪文件随时间变化的状态的一款软件。<strong>Git是一个分布式的版本控制系统。</strong>在Git中参与项目的每个程序员不仅能够拥有文件的当前状态，还能拥有项目完整的历史记录。</p><p>GitHub是一个网站，可以像该网站上传一个Git数据库副本。使用GitHub可以使你与他人合作一个项目变的更加容易。GitHub提供了如下机制：</p><ul><li><p>共享库的位置</p></li><li><p>分叉（forking：A复制一个B的项目到自己的账户下，修改后再提交，B能看到A修改的内容，但是B原本的项目是不会有变动的）</p></li><li><p>拉取请求（pull request）</p></li><li><p>提出问题（issue）</p></li></ul><blockquote><p><strong>版本控制系统（version control system）</strong>像个数据库，它会记录所有对项目文件的更改（比如一个文件，前天加了三段文字，昨天删了一句话，今天改了几个词，这三个版本历史都能保存下来）。 版本控制系统不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。</p><p><strong>功能</strong>：使用版本控制系统可以协同合作（多人编辑文件或代码而不出错），版本存储（你改动的每一版本都保存下来，如果改错可以回到之前的版本，如果想加上删除的内容也可以返回去找，也可以对比现在和之前的版本，看改了什么），文件备份（服务器和本地都有完整的历史版本，如果服务器坏了，本地还有一份完整的历史记录）。</p></blockquote><p>总结：无论你是不是程序员，你都可以用 GitHub。你可以把它当个网盘存包括代码的文件，可以和团队一起做个项目（文件啥的就不用保存一堆迭代版本啦），可以找资源（里面有很多宝藏资源），可以建个博客，也可以像在微博、知乎、博客一样，分享你的东西。 </p><h2 id="1-2-概念初识"><a href="#1-2-概念初识" class="headerlink" title="1.2 概念初识"></a>1.2 概念初识</h2><center><style type="text/css">.tg  {border-collapse:collapse;border-spacing:0;}.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;  overflow:hidden;padding:10px 5px;word-break:normal;}.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}</style><table class="tg" style="undefined;table-layout: fixed; width: 676px"><colgroup><col style="width: 220px"><col style="width: 500px"></colgroup><thead>  <tr>    <th class="tg-fymr">概念</th>    <th class="tg-fymr">释义</th>  </tr></thead><tbody>  <tr>    <td class="tg-0pky">提交（commit）</td>    <td class="tg-0pky">提交更改到仓库（本地Git仓库与GitHub仓库是两码事）。</td>  </tr>  <tr>    <td class="tg-0pky">提交信息（commit message）</td>    <td class="tg-0pky">每次提交的时候，需要提供一个信息，描述这次提交都做了什么。</td>  </tr>  <tr>    <td class="tg-0pky">主分支（master branch）</td>    <td class="tg-0pky">所有的Git项目在最初创建时，都会默认创建出一个分支，这就是主分支。在开发中，写一个新功能的时候，都是先建立一个分支，在该分支上完成功能并测试，通过后由项目leader将该分支merge到master上。</td>  </tr>  <tr>    <td class="tg-0pky">分支（branch）</td>    <td class="tg-0pky">像树状图一样，每个独立的分支都是项目的一个版本，分支都可以与master合并。</td>  </tr>  <tr>    <td class="tg-0pky">合并（merge）</td>    <td class="tg-0pky">merge可以将一个分支上的全部内容归并到另一个分支上，一般就是将分支merge到主分支。</td>  </tr>  <tr>    <td class="tg-0pky">标签（tag）</td>    <td class="tg-0pky">常用于记录发布版本，在版本发布的时候，给一个tag，这样就能够记录该版本的代码是何时生成的。</td>  </tr>  <tr>    <td class="tg-0pky">查看（check out）</td>    <td class="tg-0pky">一般就是查看某一个分支上操作的记录。</td>  </tr>  <tr>    <td class="tg-0pky">拉取（pull request）</td>    <td class="tg-0pky">一般用来从远程仓库拉取分支中的代码到本地，也可以从本地仓库中拉取分支代码到当前工程中。</td>  </tr>  <tr>    <td class="tg-0pky">提出问题（issue）</td>    <td class="tg-0pky">GitHub的提出问题的功能，一般遇到问题，可以将出现问题的场合，通过issue的方式记录。</td>  </tr>  <tr>    <td class="tg-0pky">克隆（clone）</td>    <td class="tg-0pky">从GitHub上下载一个副本到本地，操作后可以pull上去。</td>  </tr>  <tr>    <td class="tg-0pky">分叉（fork）</td>    <td class="tg-0pky">A复制一个B的项目到自己的账户下，修改后再提交，B能看到A修改的内容，但是B原本的项目是不会有变动的。</td>  </tr></tbody></table></center><h2 id="1-3-注册Github"><a href="#1-3-注册Github" class="headerlink" title="1.3 注册Github"></a>1.3 注册Github</h2><p>官方网站为：<a href="https://github.com/">https://github.com/</a></p><p><img src="https://pic1.imgdb.cn/item/67a9d772d0e0a243d4fdf6b0.png" alt="image.png"></p><p>注册过程很简单，填写相应的信息就行。</p><h2 id="1-4-Github页面介绍"><a href="#1-4-Github页面介绍" class="headerlink" title="1.4 Github页面介绍"></a>1.4 Github页面介绍</h2><p>首先，登录账号之后，可以先创建一个自己的仓库，这个很简单，随便创建一个就行。当我们重新登入Github后可能会看见如下界面：</p><p><img src="https://pic1.imgdb.cn/item/67a9defcd0e0a243d4fdf971.png"></p><p>关闭这些弹窗广告之后，页面变为：</p><p><img src="https://pic1.imgdb.cn/item/67a9e41fd0e0a243d4fdfa06.png"></p><p>点击上图中左上侧的<code>三</code>后，出现的选项如下：</p><p><img src="https://pic1.imgdb.cn/item/67a9e9d7d0e0a243d4fdfc91.png"></p><ul><li><strong>特别注意</strong>：<ul><li><code>Pull requests</code>：你想参与别人的项目或想改进别人的项目，改进后可提交申请，用Pull requests。</li><li><code>Issues</code>：你发现别人项目的 bug，或者有什么问题，怎么和作者交流呢？提一个 Issue ；别人也可以给你的项目提 Issue 反馈问题。Issue 追踪各种想法，增强功能，任务，bug，有点儿像评论功能。</li><li><code>Marketplace</code>：应用商店，里面有免费/收费的开发工具。</li><li><code>Explore</code>：你可以理解成软件里的发现页，点进去推荐一些和你相关的话题、项目、新闻等</li></ul></li></ul><p>点击右上角的 <strong>+图标</strong> 可用于新建：</p><p><img src="https://pic1.imgdb.cn/item/67a9ed85d0e0a243d4fdfd47.png"></p><p>这里简单解释<strong>Repository（仓库）</strong>、<strong>Organization（组织）</strong> 和 <strong>Project（项目）</strong> 三个概念：</p><ul><li><strong>Repository（仓库）</strong><ul><li><strong>定义</strong>：<ul><li>Repository（仓库）是 GitHub 上最基本的存储单元，用于存储和管理代码、文件、文档等与项目相关的所有内容。</li><li>每个仓库可以包含代码文件、提交历史、分支、标签、问题（Issues）、拉取请求（Pull Requests）、Wiki、GitHub Pages 等。</li></ul></li><li><strong>用途</strong>：<ul><li>用于版本控制和协作开发。</li><li>开发者可以将代码推送到仓库中，与团队成员协作开发项目。</li><li>仓库可以设置权限，控制谁可以查看或修改仓库中的内容。</li></ul></li></ul></li><li><strong>Organization（组织）</strong><ul><li><strong>定义</strong>：<ul><li>Organization（组织）是一个包含多个用户的集合，通常用于团队或公司。</li><li>组织可以拥有多个仓库，这些仓库可以是公开的（Public）或私有的（Private）。</li><li>组织可以设置不同的权限级别，控制成员对仓库的访问和操作。</li></ul></li><li><strong>用途</strong>：<ul><li>用于团队协作和项目管理。</li><li>团队成员可以加入组织，共同管理和开发多个仓库。</li><li>组织可以设置团队和角色，分配不同的权限和职责。</li></ul></li></ul></li><li><strong>Project（项目）</strong><ul><li><strong>定义</strong>：<ul><li>Project（项目）是 GitHub 提供的一种项目管理工具，用于帮助团队跟踪任务、计划和进度。</li><li>项目通常以看板（Kanban Board）的形式呈现，可以将任务分为不同的列（如“待办”、“进行中”、“已完成”）。</li></ul></li><li><strong>用途</strong>：<ul><li>用于项目管理和任务跟踪。</li><li>团队成员可以将任务分配给特定的用户，并设置截止日期。</li><li>项目可以与仓库中的 Issues（问题）关联，方便跟踪任务的进展。</li></ul></li></ul></li></ul><p><strong>具体例子</strong></p><p>假设有一个公司 <strong>TechCorp</strong>，他们使用 GitHub 来管理他们的项目和代码。</p><ol><li><strong>Organization（组织）</strong>：<ul><li><strong>TechCorp</strong> 创建了一个 GitHub 组织，名为 <strong>TechCorp</strong>。</li><li>这个组织包含多个团队，如 <strong>开发团队</strong>、<strong>测试团队</strong> 和 <strong>文档团队</strong>。</li><li>每个团队有不同的权限，例如开发团队可以访问和修改所有仓库，而文档团队只能访问和修改文档相关的仓库。</li></ul></li><li><strong>Repository（仓库）</strong>：<ul><li><strong>TechCorp</strong> 组织中有多个仓库，例如：<ul><li><strong>techcorp/website</strong>：存放公司网站的代码。</li><li><strong>techcorp/app</strong>：存放公司主要应用程序的代码。</li><li><strong>techcorp/docs</strong>：存放公司文档的代码。</li></ul></li><li>每个仓库都有自己的版本控制、提交历史、Issues 和 Pull Requests。</li></ul></li><li><strong>Project（项目）</strong>：<ul><li><strong>TechCorp</strong> 创建了一个项目，名为 <strong>TechCorp 2024 年度项目</strong>。</li><li>这个项目是一个看板，用于跟踪公司主要应用程序的开发进度。</li><li>项目中有多个列，如“待办”、“进行中”、“已完成”。</li><li>每个列中有多个任务卡片，例如：<ul><li><strong>待办</strong>：修复用户登录问题、优化数据库查询。</li><li><strong>进行中</strong>：实现新功能、测试新功能。</li><li><strong>已完成</strong>：修复已知漏洞、优化性能。</li></ul></li><li>项目中的任务卡片可以与仓库中的 Issues 关联，例如“修复用户登录问题”可以链接到 <strong>techcorp/app</strong> 仓库中的一个 Issue。</li></ul></li></ol><p><strong>总结</strong></p><ul><li><strong>Repository（仓库）</strong>：用于存储和管理代码和文件，是版本控制和协作开发的核心。</li><li><strong>Organization（组织）</strong>：用于团队协作和项目管理，包含多个用户和仓库。</li><li><strong>Project（项目）</strong>：用于项目管理和任务跟踪，帮助团队更好地组织和管理任务。</li></ul><p>点击右上角的 <strong>个人头像</strong> 可用于查看：</p><p><img src="https://pic1.imgdb.cn/item/67a9f4e3d0e0a243d4fdff6a.png"></p><p><strong>解释1</strong>：<code>Working from Home</code></p><p>GitHub 的 “Working from Home” 功能是一个用户状态设置， 例如，当用户设置自己的状态为“在家工作”时，其他人在提及该用户、分配任务或请求审查时，GitHub 会显示该用户当前的状态，提示他们可能的响应时间或可用性有限。这有助于团队成员在需要协作或沟通时做出合理的预期和安排。 </p><p>总的来说，GitHub 的“Working from Home”功能是一个有用的工具，可以帮助用户在远程工作或有特殊工作安排时，向团队成员传达自己的工作状态和可用性。 </p><p><strong>解释2</strong>：<code>Repositories</code>和<code>Gists</code>的区别</p><ol><li><ul><li><strong>Repositories（仓库）</strong>：主要用于存储项目的全部源代码以及与之相关的文件（如文档、图片等）。它是版本控制的核心，可以包含多个文件和文件夹，支持版本历史、分支、标签、Pull Request（拉取请求）等功能。仓库通常用于完整的软件开发项目。</li><li><strong>Gists（代码片段）</strong>：主要用于分享较小的代码片段或文本。Gist 更加轻量级，通常只包含单个文件，不支持版本历史、分支或 Pull Request。</li></ul></li><li><strong>结构和组织</strong>：<ul><li><strong>Repositories</strong>：有复杂的目录结构，可以包含多个文件夹和文件，以及子模块等。</li><li><strong>Gists</strong>：通常只包含单个文件，结构简单。</li></ul></li><li><strong>协作和版本控制</strong>：<ul><li><strong>Repositories</strong>：支持多人协作，可以设置权限，进行分支管理，有完整的版本控制功能。</li><li><strong>Gists</strong>：虽然可以进行编辑和版本控制，但不支持分支，协作功能较弱。</li></ul></li></ol><p>以上大概是主界面的主要内容了。</p><h2 id="1-5-个人主页"><a href="#1-5-个人主页" class="headerlink" title="1.5 个人主页"></a>1.5 个人主页</h2><p>点击<code>Your profile</code>可进入下面的个人主页：</p><p><img src="https://pic1.imgdb.cn/item/67a9fd1dd0e0a243d4fe01b9.png"></p><h2 id="1-6-一个具体的页面"><a href="#1-6-一个具体的页面" class="headerlink" title="1.6 一个具体的页面"></a>1.6 一个具体的页面</h2><p><strong><font color=blue>具体的某个项目主页</font></strong></p><p><img src="https://pic1.imgdb.cn/item/67aa091ed0e0a243d4fe05d1.png"></p><p><strong><font color=blue>分支、Add file、code下拉列表</font></strong></p><p><img src="https://pic1.imgdb.cn/item/67aa0e64d0e0a243d4fe06bc.png"></p><p><strong>简述上图中各部分的作用</strong>：</p><ul><li>用户名：回到个人主页。</li><li>仓库名：显示该仓库中的文件列表。</li><li>文件列表（code）：仓库的具体内容。</li><li>问题（Isuues）：用于BUG报告、功能添加、方向性讨论等，这些将以issue的形式进行管理。Pull Request时也会创建Issue。旁边显示的数字是当前处于open状态的issue数目。</li><li>拉取请求（Pull requests）：代码的更改和讨论都可以在此进行。指开发者在本地对源代码进行更改后，向 GitHub中 托管的Git仓库请求合并的功能。也可以向别人的仓库提出申请，请求对方合并。</li><li>运行（Actions）：免费的操作系统容器，用于线上自动化构建、测试等等。</li><li>项目（Projects）：当前仓库所在的项目。</li><li>维基（Wiki）：GitHub的维基，可用来管理自己的知识体系。任何人都能随时对一篇文章进行更改并保存，因此可以多人共同完成一篇文章。该功能常用在开发文档或手册的编写中,改版的历史记录也会被切实保存下来。</li><li>安全（Security）：仓库安全的相关设置。</li><li>可视化（insights）：仓库的统计信息的图表，包括</li><li>设置（Setting）：仓库的设置</li><li>通知设置/订阅数（Unwatch）：下拉列表，多种选项选择。该仓库的更新信息就会显示在用户的公开活动中。相当于“订阅”。</li><li>收藏数（Start）：相当于“收藏”该仓库。用户可以在Star标记的列表中找到该仓库</li><li>分支/复制数（Fork）：代表该仓库被Fork至各用户仓库的次数。Fork相当于你在原项目的主分支上又建立了一个分支，你可以在该分支上任意修改，如果想将你的修改合并到原项目中时，可以pull request，这样原项目的作者就可以将你修改的东西合并到原项目的主分支上去，这样你就为开源项目贡献了代码，开源项目就会在大家共同的努力下不断壮大和完善。</li></ul><p><strong>几个概念的辨析</strong>：</p><ul><li><p><code>branch</code> VS <code>tag</code> </p><ul><li><code>branch</code>：在Git中，每个仓库都有一个主分支，通常命名为<code>master</code>。这是一个特殊的分支，因为它代表了项目的主线，也是默认的分支。<ul><li>其他分支，如开发分支、测试分支、功能分支、紧急修复分支等，是从主分支分离出来的。它们允许多个开发人员并行地开发不同的功能，而不会影响主分支。</li><li>对于其他分支，可以在其上进行实验性开发，并在它们完成和稳定后，合并到主分支。在合并前，还可以对其他分支进行代码评审和测试。</li><li>因此，主分支和其他分支的主要区别在于：主分支是项目的主线，它代表了项目的当前状态，而其他分支则是对项目进行实验性开发的地方。</li></ul></li><li><code>tag</code>：标签是指项目中某个特定版本的一个标记，用于标识项目的重要节点，例如发布版本或者里程碑。标签可以附加到任意的提交对象上，通常用于标记项目的稳定版本。</li><li><strong>Git 中 在哪个branch 打tag有关系吗</strong>：<ul><li>其实要取得不同的branch的tag，只需要在相应的分支上打tag就行了。这样的tag就唯一对应了不同的分支。例如，你在master上打了tag为v1，在某个branch上打了tag为v2，则你取出v2代码的时候，自然就是对应的branch分支了。 </li></ul></li><li>参考链接1：<a href="https://www.zhihu.com/question/28784805/answer/1825675165">git tags 和 Branches的区别是什么呀，什么时候应该创建一个Tag？ - halfbusy的回答 - 知乎</a><br>参考链接2：<a href="https://blog.csdn.net/weixin_43715214/article/details/131059079">【Git】Git中 tag 与 branch 的关系与使用 - CSDN</a><br>参考链接3：<a href="https://blog.csdn.net/qq_40424333/article/details/137968115">git中tag和branch的区别，下载最新代码是下载主分支还是最新的tag - CSDN</a></li></ul></li><li><p><code>Isuues</code> VS <code>Pull requests</code></p><ul><li><code>Issues</code>功能用于讨论问题，提交使用问题、提出一些建议或者想法。</li><li><code>Pull request</code>是指你想参与别人的项目，或想改进别人的项目，改进后需要提交申请。通俗的说，就是自己修改了代码，希望合并到别人的Repository(仓库)中，一般有如下四个步骤：<ul><li>先fork别人的仓库，即拷贝一份，生成一个自己的Repository，不会有人让你直接改修原仓库的。</li><li>clone到本地分支，通过修改、commit、push等操作后，将修改的内容，提交到自己仓库。</li><li>发起 pull request 给原仓库，让他看到你修改的bug或者改进。</li><li>原仓库作者查看你提交的内容，如果是正确的话，就会融合(merge)到他自己的项目中。</li></ul></li></ul></li><li><p><code>tag</code> VS <code>releases</code></p><ul><li><code>tag</code>：在一个项目中，我们可能需要阶段性地发布一个版本，比如 V1.0、V1.0.2、V3.2 Beta 之类的，Git的标签可以满足这个需求。</li><li><code>releases</code>：GitHub的releases是 2013 年发布的新功能，旨在协助软件开发者分发新版本给用户。 </li><li>标签是Git中的概念，而releases则是Github、码云等源码托管商所提供的更高层的概念。Git本身是没有releases这个概念，只有tag。两者之间的关系则是，release基于tag，为tag添加更丰富的信息，一般是编译好的文件。(Tag适用于标记重要的提交点，而Release适用于正式发布软件版本)</li><li>参考连接：<a href="https://blog.csdn.net/wangzhae/article/details/108549256">九、Git tag 和 GitHub releases - CSDN</a></li></ul></li><li><p><code>Wiki</code> VS <code>Readme</code></p><ul><li><code>Wiki</code>适用于需要详细文档管理的场景，如技术文档、操作手册等。由于支持版本控制和协作功能，Wiki非常适合团队成员之间的文档共享和更新。 </li><li><code>Readme</code>则更适合作为项目的入门指南和基本介绍。它通常包含项目的概述、安装步骤、使用方法等信息，帮助用户快速了解项目的基本情况和如何开始使用‌  。</li><li><code>Wiki</code>在权限管理上有所限制，默认只有管理员和贡献者可以修改和提交更改，普通用户无法直接推送更改到Wiki仓库。 <code>README</code>则通常对所有贡献者开放，可以自由编辑和更新，因为它主要是项目的基本信息介绍，不需要严格的权限控制‌。</li></ul></li><li><code>Insights</code><ul><li>是 GitHub 提供的一款官方可视化工具，通过一系列图表和数据分析，用户可以清晰地看到项目的进展和各个贡献者的贡献。 </li><li>GitHub Insights提供的自定义报告功能非常强大。管理员可根据团队的具体需求定制各类报告，例如代码提交频率的变化趋势、特定时间段内的拉取请求处理情况、不同贡献者之间的工作量对比等。这些报告可以帮助团队识别潜在的瓶颈和问题，从而更好地分配资源和调整工作计划，提高整体效率。</li></ul></li><li><code>Actions</code><ul><li>是GitHub的持续集成服务，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。 </li><li>举例：比如我的博客就使用了GitHub Action，在我每次commit之后，就能自动编译并打包，然后部署到我的服务器上；这样我就不用自己打包，然后部署到服务器上了，节省了很多时间；如果部署失败了，也会有邮件提醒。</li><li>参考连接1：<a href="https://zhuanlan.zhihu.com/p/731785401">5 分钟快速入门 Github Action - 晓林的文章 - 知乎</a><br>参考连接2：<a href="https://www.bilibili.com/video/BV1aT421y7Ar">GitHub Actions工作流自动化的入门核心 - 哔哩哔哩</a><br>参考连接3：<a href="https://www.bilibili.com/video/BV11e411i7Xx">Github的王炸功能，但很少人知道怎么用？免费运行程序，流水线编译部署 - 哔哩哔哩</a></li></ul></li></ul><h2 id="1-7-个人设置界面"><a href="#1-7-个人设置界面" class="headerlink" title="1.7 个人设置界面"></a>1.7 个人设置界面</h2><p>点击右上角图像列表中的<strong>Settings</strong>可进入个人页面设置。</p><p><a href="https://www.bilibili.com/video/BV1dz421k7kv/">GitHub用户资料配置 - 哔哩哔哩</a></p><p><a href="https://blog.csdn.net/weixin_38673554/article/details/106039790">GitHub 小白入门（一）初识界面 - CSDN</a></p><h1 id="2-Github使用"><a href="#2-Github使用" class="headerlink" title="2 Github使用"></a>2 Github使用</h1>  <div class="bvideo"><a href="//www.bilibili.com/video/BV1yk4y197oM" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/1981beda808305b4993e62b4ee03c6e3ee70eb9b.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">01:45:55</span>            </div>            <div class="bvideo-info">                <p class="title">Github全面详解</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>1.2万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>2</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">码道成功</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div> <p><a href="https://zhuanlan.zhihu.com/p/17802251353">一台主机github多账号登陆 - 工程师焱记的文章 - 知乎</a></p><p><a href="https://www.bilibili.com/video/BV1s54y1o7Ub">4 使用Github（Github Issues） - 哔哩哔哩</a></p><p><a href="https://www.bilibili.com/video/BV1bd4y1J7Vt/">github仓库的fork与pull request - 哔哩哔哩</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机与编程学习 </category>
          
          <category> 相关技术 </category>
          
          <category> Git学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用数学公式</title>
      <link href="/2025/02/08/Common-math-formulas/"/>
      <url>/2025/02/08/Common-math-formulas/</url>
      
        <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><p><a href="https://blog.csdn.net/qq_37263248/article/details/120269831">Latex符号与公式集合 - CSDN</a>：相对较全的latex数学符号，包括基本运算、高级运算、集合运算、三角运算、占位宽度、关系运算符、箭头、矩阵、希腊字符、函数、其他杂七杂八。</p><h1 id="1-高数部分"><a href="#1-高数部分" class="headerlink" title="1 高数部分"></a>1 高数部分</h1><h2 id="1-1-三角函数"><a href="#1-1-三角函数" class="headerlink" title="1.1 三角函数"></a>1.1 三角函数</h2><h3 id="1-1-1-三角函数的基本定义"><a href="#1-1-1-三角函数的基本定义" class="headerlink" title="1.1.1 三角函数的基本定义"></a>1.1.1 三角函数的基本定义</h3><h3 id="1-1-2-三角恒等式"><a href="#1-1-2-三角恒等式" class="headerlink" title="1.1.2 三角恒等式"></a>1.1.2 三角恒等式</h3><p><strong>(一) 两角和与差</strong></p><script type="math/tex; mode=display">\begin{gathered}\cos (\alpha+\beta)=\cos \alpha \cos \beta-\sin \alpha \sin \beta \\\cos (\alpha-\beta)=\cos \alpha \cos \beta+\sin \alpha \sin \beta \\\sin (\alpha+\beta)=\sin \alpha \cos \beta+\cos \alpha \sin \beta \\\sin (\alpha-\beta)=\sin \alpha \cos \beta-\cos \alpha \sin \beta \\\tan (\alpha+\beta)=\frac{\tan \alpha+\tan \beta}{1-\tan \alpha \tan \beta} \\\tan (\alpha-\beta)=\frac{\tan \alpha-\tan \beta}{1+\tan \alpha \tan \beta}\end{gathered}</script><p><strong>(二) 积化和差公式</strong></p><script type="math/tex; mode=display">\begin{aligned}& \cos \alpha \sin \beta=\frac{1}{2}[\sin (\alpha+\beta)-\sin (\alpha-\beta)] \\& \sin \alpha \cos \beta=\frac{1}{2}[\sin (\alpha+\beta)+\sin (\alpha-\beta)] \\& \cos \alpha \cos \beta=\frac{1}{2}[\cos (\alpha+\beta)+\cos (\alpha-\beta)] \\& \sin \alpha \sin \beta=-\frac{1}{2}[\cos (\alpha+\beta)-\cos (\alpha-\beta)]\end{aligned}</script><p><strong>(三) 和差化积公式</strong></p><script type="math/tex; mode=display">\begin{aligned}& \sin \alpha+\sin \beta=2 \sin \left(\frac{\alpha+\beta}{2}\right) \cos \left(\frac{\alpha-\beta}{2}\right) \\& \sin \alpha-\sin \beta=2 \sin \left(\frac{\alpha-\beta}{2}\right) \cos \left(\frac{\alpha+\beta}{2}\right) \\& \cos \alpha+\cos \beta=2 \cos \left(\frac{\alpha+\beta}{2}\right) \cos \left(\frac{\alpha-\beta}{2}\right) \\& \cos \alpha-\cos \beta=-2 \sin \left(\frac{\alpha+\beta}{2}\right) \sin \left(\frac{\alpha-\beta}{2}\right)\end{aligned}</script><p><strong>(四) 二倍角公式</strong></p><script type="math/tex; mode=display">\begin{aligned}& \sin 2 \alpha=2 \sin \alpha \cos \alpha=\frac{2}{\tan \alpha+\cot \alpha} \\& \cos 2 \alpha=\cos ^2 \alpha-\sin ^2 \alpha=2 \cos ^2 \alpha-1=1-2 \sin ^2 \alpha \\& \tan 2 \alpha=\frac{2 \tan \alpha}{1-\tan ^2 \alpha}\end{aligned}</script><p><strong>(五) 半角公式</strong></p><script type="math/tex; mode=display">\begin{aligned}& \sin \left(\frac{\alpha}{2}\right)=\pm \sqrt{\frac{1-\cos \alpha}{2}} \\& \cos \left(\frac{\alpha}{2}\right)=\pm \sqrt{\frac{1+\cos \alpha}{2}} \\& \tan \left(\frac{\alpha}{2}\right)=\pm \sqrt{\frac{1-\cos \alpha}{1+\cos \alpha}}=\frac{\sin \alpha}{1+\cos \alpha}=\frac{1-\cos \alpha}{\sin \alpha}=\csc \alpha-\cot \alpha\end{aligned}</script><p><strong>(六) 辅助角公式</strong></p><script type="math/tex; mode=display">a \sin \alpha+b \cos \alpha=\sqrt{a^2+b^2} \sin (\alpha+\varphi)</script><p>其中，$\varphi$满足$\cos \varphi=\dfrac{a}{\sqrt{a^2+b^2}}, \quad \sin \varphi=\dfrac{b}{\sqrt{a^2+b^2}}$</p><p><strong>(七) 万能公式</strong></p><script type="math/tex; mode=display">\sin \alpha = \frac{2 \tan(\alpha/2)}{1+\tan^2(\alpha/2)}, \quad \cos \alpha = \frac{1-\tan^2(\alpha/2)}{1+\tan^2(\alpha/2)}, \quad \tan \alpha = \frac{2\tan(\alpha/2)}{1-\tan^2(\alpha/2)}</script><p><strong>(八) 降幂公式</strong></p><script type="math/tex; mode=display">\sin^2\alpha = \frac{1-\cos(2\alpha)}{2}, \quad \cos^2\alpha = \frac{1+\cos(2\alpha)}{2}, \quad \tan^2\alpha = \frac{1-\cos(2\alpha)}{1+\cos(2\alpha)}</script><p><strong>(九) 余弦定理</strong></p><center><img src="https://img2023.cnblogs.com/blog/2609360/202309/2609360-20230913153716726-1739385642.png" style="zoom:70%" /></center><div class="table-container"><table><thead><tr><th>余弦定理表达式1</th><th><strong>余弦定理表达式2</strong></th><th>余弦定理表达式3</th></tr></thead><tbody><tr><td>$c^2 = a^2+b^2-2ab \cos \gamma$</td><td>$\cos \gamma = \dfrac{a^2 + b^2 - c^2}{2ab}$</td><td>$\cos \gamma= \dfrac{\sin^2 \alpha + \sin^2 \beta - \sin^2 \gamma}{2\sin \alpha \sin \beta}$</td></tr><tr><td>$b^2 = a^2+c^2-2ac \cos \beta$</td><td>$\cos \beta = \dfrac{a^2 + c^2 - b^2}{2ac}$</td><td>$\cos \beta = \dfrac{\sin^2 \alpha+ \sin^2 \gamma - \sin^2 \beta}{2\sin \alpha \sin \gamma}$</td></tr><tr><td>$a^2 = b^2+c^2-2bc \cos \alpha$</td><td>$\cos \alpha = \dfrac{b^2 + c^2 - a^2}{2bc}$</td><td>$\cos \alpha = \dfrac{\sin^2 \beta + \sin^2 \gamma - \sin^2 \alpha}{2\sin \beta \sin \gamma}$</td></tr></tbody></table></div><h2 id="1-2-导数"><a href="#1-2-导数" class="headerlink" title="1.2 导数"></a>1.2 导数</h2><h3 id="1-2-1-导数的定义式"><a href="#1-2-1-导数的定义式" class="headerlink" title="1.2.1 导数的定义式"></a>1.2.1 导数的定义式</h3><script type="math/tex; mode=display">f'(x) = \frac{\mathrm{d}}{\mathrm{dx}}f(x) = \lim_{\Delta x \to 0}\frac{f(x + \Delta x) - f(x)}{\Delta x}</script><h3 id="1-2-2-常用函数的导数"><a href="#1-2-2-常用函数的导数" class="headerlink" title="1.2.2 常用函数的导数"></a>1.2.2 常用函数的导数</h3><ul><li>指数类函数</li></ul><script type="math/tex; mode=display">f(x) = a^x \quad \Longrightarrow \quad f'(x) = a^x \ln a</script><script type="math/tex; mode=display">f(x) = e^x \quad \Longrightarrow \quad f'(x) = e^x</script><ul><li>对数类函数</li></ul><script type="math/tex; mode=display">f(x) = \log_a x \quad \Longrightarrow \quad f'(x) = \frac{1}{x \ln a}</script><script type="math/tex; mode=display">f(x) = \ln x \quad \Longrightarrow \quad f'(x) = \frac{1}{x}</script><ul><li>正切函数</li></ul><script type="math/tex; mode=display">f(x) = \tan x \quad \Longrightarrow \quad f'(x) = \sec^2 x = \left(\frac{1}{\cos x} \right)^2</script><ul><li>反三角函数类</li></ul><script type="math/tex; mode=display">f(x) = \arcsin x \quad \Longrightarrow \quad f'(x) = \frac{1}{\sqrt{1- x^2}}</script><script type="math/tex; mode=display">f(x) = \arccos x \quad \Longrightarrow \quad f'(x) = - \frac{1}{\sqrt{1- x^2}}</script><script type="math/tex; mode=display">f(x) = \arctan x \quad \Longrightarrow \quad f'(x) = \frac{1}{1 + x^2}</script><h2 id="1-3-泰勒级数-泰勒展开"><a href="#1-3-泰勒级数-泰勒展开" class="headerlink" title="1.3 泰勒级数/泰勒展开"></a>1.3 泰勒级数/泰勒展开</h2><h3 id="1-3-1-标准公式"><a href="#1-3-1-标准公式" class="headerlink" title="1.3.1 标准公式"></a>1.3.1 标准公式</h3><p>（一）在$x=0$处展开(麦克劳林公式)</p><ul><li>佩亚诺余项</li></ul><script type="math/tex; mode=display">f(x) = f(0) + \frac{f'(0)}{1!}x + \frac{f''(0)}{2!}x^2 + \cdots + \frac{f^{(n)}(0)}{n!}x^n + o[x^n]</script><ul><li>拉格朗日余项</li></ul><script type="math/tex; mode=display">f(x) = f(0) + \frac{f'(0)}{1!}x + \frac{f''(0)}{2!}x^2 + \cdots + \frac{f^{(n)}(0)}{n!}x^n + \frac{f^{(n+1)}(\xi)}{(n+1)!}x^{n+1}</script><p>（二）在$x=x_0$处展开</p><ul><li>佩亚诺余项</li></ul><script type="math/tex; mode=display">f(x) = f(x_0) + \frac{f'(x_0)}{1!}(x-x_0) + \frac{f''(x_0)}{2!}(x-x_0)^2 + \cdots + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + o[(x-x_0)^n]</script><ul><li>拉格朗日余项</li></ul><script type="math/tex; mode=display">f(x) = f(x_0) + \frac{f'(x_0)}{1!}(x-x_0) + \frac{f''(x_0)}{2!}(x-x_0)^2 + \cdots + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}</script><p>（三）含有$\Delta x$的展开(常用于论文中的近似)</p><script type="math/tex; mode=display">f(x + \Delta x) = f(x) + \frac{f'(x)}{1!}\Delta x + \frac{f''(x)}{2!}\Delta x + \cdots</script><script type="math/tex; mode=display">\begin{aligned}&f(x_0 + \Delta x, y_0 + \Delta y) \\= & f(x_0, y_0) + \left[\frac{\partial f}{\partial x}(x_0, y_0) \Delta x + \frac{\partial f}{\partial y}(x_0, y_0) \Delta y \right] + \\& \frac{1}{2!} \left[\frac{\partial^2 f}{\partial x^2}(x_0, y_0) \Delta x^2 + 2\frac{\partial^2 f}{\partial x \partial y}(x_0, y_0)  \Delta x \Delta y + \frac{\partial^2 f}{\partial y^2}(x_0, y_0) \Delta y^2 \right] + \cdots\end{aligned}</script><h3 id="1-3-2-常用的带有佩亚诺余项的麦克劳林公式"><a href="#1-3-2-常用的带有佩亚诺余项的麦克劳林公式" class="headerlink" title="1.3.2 常用的带有佩亚诺余项的麦克劳林公式"></a>1.3.2 常用的带有佩亚诺余项的麦克劳林公式</h3><script type="math/tex; mode=display">\sin x = x - \dfrac{x^3}{3!} + \dfrac{x^5}{5!} + o(x^5)</script><script type="math/tex; mode=display">\cos x = 1 - \dfrac{x^2}{2!} + \dfrac{x^4}{4!} + o(x^4)</script><script type="math/tex; mode=display">\tan x = x + \dfrac{x^3}{3} + \dfrac{2x^5}{15} + o(x^5)</script><script type="math/tex; mode=display">\arctan x = x - \dfrac{x^3}{3} + \dfrac{x^5}{5} + o(x^5)</script><script type="math/tex; mode=display">e^x = 1 + x + \dfrac{x^2}{2!}+ \dfrac{x^3}{3!} + o(x^3)</script><script type="math/tex; mode=display">\dfrac{1}{1-x} = 1 + x + x^2 + x^3 + o(x^3)</script><script type="math/tex; mode=display">\dfrac{1}{1+x} = 1 - x + x^2 - x^3 + o(x^3)</script><script type="math/tex; mode=display">(1+x)^\alpha = 1 + \alpha x + \dfrac{\alpha(\alpha-1)}{2!}x^2 + \dfrac{\alpha(\alpha-1)(\alpha-2)}{3!}x^3 + o(x^3)</script><script type="math/tex; mode=display">\ln(1-x) = -x - \dfrac{x^2}{2} - \dfrac{x^3}{3} + o(x^3)</script><script type="math/tex; mode=display">\ln(1 + x) = x - \dfrac{x^2}{2} + \dfrac{x^3}{3} + o(x^3)</script><!--$$\sin x = x - \dfrac{x^3}{3!} + \dfrac{x^5}{5!} + o(x^5) \Longleftrightarrow \sin x = x - \dfrac{x^3}{3!} + \dfrac{x^5}{5!} + \cdots + (-1)^n\dfrac{x^{2n+1}}{(2n+1)!} + o(x^{2n+1})$$--><!--$$\cos x = 1 - \dfrac{x^2}{2!} + \dfrac{x^4}{4!} + o(x^4) \Longleftrightarrow \cos x = 1 - \dfrac{x^2}{2!} + \dfrac{x^4}{4!} + \cdots + (-1)^n\dfrac{x^{2n}}{(2n)!} + o(x^{2n})$$--><!--$$\tan x = x + \dfrac{x^3}{3} + \dfrac{2x^5}{15} + o(x^5) \Longleftrightarrow $$--><!--$$\arctan x = x - \dfrac{x^3}{3} + \dfrac{x^5}{5} + o(x^5) \Longleftrightarrow \arctan x = x - \dfrac{x^3}{3} + \dfrac{x^5}{5} + \cdots + (-1)^n\dfrac{x^{2n+1}}{(2n+1)} + o(x^{2n+1})$$--><!--$$e^x = 1 + x + \dfrac{x^2}{2!}+ \dfrac{x^3}{3!} + o(x^3) \Longleftrightarrow e^x = 1 + x + \dfrac{x^2}{2!}+ \dfrac{x^3}{3!} + \cdots + \dfrac{x^n}{n!} + o(x^n) = \sum_{i=0}^{n}\dfrac{x^i}{i!} + o(x^n)$$--><!--$$\dfrac{1}{1-x} = 1 + x + x^2 + x^3 + o(x^3) \Longleftrightarrow \dfrac{1}{1-x} = 1 + x + x^2 + x^3 + \cdots + x^n + o(x^n) = \sum_{i = 0}^{n}x^i + o(x^n)$$--><!--$$\dfrac{1}{1+x} = 1 - x + x^2 - x^3 + o(x^3) \Longleftrightarrow \dfrac{1}{1+x} = 1 - x + x^2 - x^3 + \cdots + (-1)^n x^n + o(x^n) = \sum_{i = 0}^{n}(-1)^i x^i + o(x^n)$$--><!--$$(1+x)^\alpha = 1 + \alpha x + \dfrac{\alpha(\alpha-1)}{2!}x^2 + \dfrac{\alpha(\alpha-1)(\alpha-2)}{3!} + o(x^3)$$--><!--$$\ln(1-x) = -x - \dfrac{x^2}{2} - \dfrac{x^3}{3} + o(x^3)$$--><!--$$\ln(1 + x) = x - \dfrac{x^2}{2} + \dfrac{x^3}{3} + o(x^3)$$--><blockquote><p>注意：<br>1、记忆常见函数的泰勒展开时候要学会利用函数之间<strong>求导与积分</strong>的关系；<br>2、注意代换方法，比如知道$e^x$的展开，也可以推导出$e^{2x}$的展开。</p></blockquote><h3 id="1-3-3-常用的等价无穷小"><a href="#1-3-3-常用的等价无穷小" class="headerlink" title="1.3.3 常用的等价无穷小"></a>1.3.3 常用的等价无穷小</h3><div class="table-container"><table><thead><tr><th>当$x \to 0$时</th><th>当$x \to 0$时</th></tr></thead><tbody><tr><td>$\sin x \sim x, \tan x \sim x$</td><td>$e^x - 1 \sim x$</td></tr><tr><td>$\ln(1+x) \sim x$</td><td>$a^x - 1 \sim x \ln a, (a&gt;0, a \neq 1)$</td></tr><tr><td>$1-\cos x \sim \dfrac{1}{2}x^2$</td><td>$(1 + \beta x)^\alpha-1 \sim \alpha\beta x$</td></tr><tr><td>$\arcsin x \sim x$</td><td>$x - \ln(1+x) \sim \dfrac{1}{2}x^2$</td></tr><tr><td>$\arctan x \sim x$</td><td>$\ln(x+\sqrt{1+x^2}) \sim x$</td></tr></tbody></table></div><h3 id="1-3-4-两个重要极限"><a href="#1-3-4-两个重要极限" class="headerlink" title="1.3.4 两个重要极限"></a>1.3.4 两个重要极限</h3><ul><li>$e$的定义式(极限)</li></ul><script type="math/tex; mode=display">\lim_{x \to \infty} (1 + \frac{1}{x})^x = e \quad \Longleftrightarrow \quad \lim_{x \to 0} (1 + x)^{\frac{1}{x}} = e</script><ul><li>$\mathrm{sinc}$函数在零点的值</li></ul><script type="math/tex; mode=display">\lim_{x \to 0} \frac{\sin x}{x} = 1</script><h2 id="1-4-数列"><a href="#1-4-数列" class="headerlink" title="1.4 数列"></a>1.4 数列</h2><h3 id="1-4-1-等差数列求和"><a href="#1-4-1-等差数列求和" class="headerlink" title="1.4.1 等差数列求和"></a>1.4.1 等差数列求和</h3><h3 id="1-4-2-等比数列求和"><a href="#1-4-2-等比数列求和" class="headerlink" title="1.4.2 等比数列求和"></a>1.4.2 等比数列求和</h3><p>若数列$\begin{Bmatrix} a_n \end{Bmatrix}$为等比数列，且首项为$a_1$，公比为$q$，前$n$项和为$S_n$，则有：</p><ul><li>当公比为$q = 1$时：</li></ul><script type="math/tex; mode=display">S_n = n a_1</script><ul><li>当公比$q \neq 1$时：</li></ul><script type="math/tex; mode=display">S_n = \frac{a_1 (1 - q^n)}{1-q} \quad \Longleftrightarrow \quad S_n = \frac{a_1 - a_n q}{1-q}</script><h3 id="1-4-3-常见其他数列求和"><a href="#1-4-3-常见其他数列求和" class="headerlink" title="1.4.3 常见其他数列求和"></a>1.4.3 常见其他数列求和</h3><ul><li>$a_n = n^2$的求和公式</li></ul><script type="math/tex; mode=display">S_n = \sum_{i=1}^{n}a_i = \frac{n(n+1)(2n+1)}{6}</script><ul><li>复指数求和</li></ul><p>在计算序列的DFT时候，经常碰到如下形式的求和：已知序列$\boldsymbol x(n) = [1, 1, 1, 1, 1, 0, 0, 0, 0, 0]$，求该序列的DFT。</p><script type="math/tex; mode=display">X(k) = \sum_{n=0}^9 x(n) \exp\left\{-\mathrm j \dfrac{2\pi}{10} kn\right\} = \sum_{n=0}^4 x(n) \exp\left\{-\mathrm j \dfrac{2\pi}{10} kn\right\} = \dfrac{1 - \exp\left\{-\mathrm j \dfrac{2\pi}{10} k \cdot 5\right\}}{1- \exp\left\{-\mathrm j \dfrac{2\pi}{10} k\right\}}</script><p>重点是该分式如何进一步化简，其主要思路参考<a href="https://www.bilibili.com/read/cv9843740">【信号与系统：如何化简、计算两个复指数的和/差 - bilibili】</a>，简单来说，核心思想是<strong>提取和（差）式的两个指数的频率的平均值</strong>：</p><script type="math/tex; mode=display">\begin{aligned}\dfrac{1 - \exp\left\{-\mathrm j \dfrac{2\pi}{10} k \cdot 5\right\}}{1- \exp\left\{-\mathrm j \dfrac{2\pi}{10} k\right\}} = & \dfrac{\exp\left\{-\mathrm j \dfrac{2\pi}{10} k \cdot \dfrac{5}{2}\right\}\left(\exp\left\{\mathrm j \dfrac{2\pi}{10} k \cdot \dfrac{5}{2}\right\} - \exp\left\{-\mathrm j \dfrac{2\pi}{10} k \cdot \dfrac{5}{2}\right\}\right)}{\exp\left\{-\mathrm j \dfrac{2\pi}{10} k \cdot \dfrac{1}{2}\right\}\left(\exp\left\{\mathrm j \dfrac{2\pi}{10} k \cdot \dfrac{1}{2}\right\}- \exp\left\{-\mathrm j \dfrac{2\pi}{10} k \cdot \dfrac{1}{2}\right\}\right)} \\= & \exp\left\{-\mathrm j \dfrac{2\pi}{10} k \cdot 2\right\} \dfrac{\sin\left(\dfrac{\pi}{2} k\right)}{\sin\left(\dfrac{\pi}{10} k\right)}, \quad k = 0, 1, \cdots, 9\end{aligned}</script><h2 id="1-5-积分"><a href="#1-5-积分" class="headerlink" title="1.5 积分"></a>1.5 积分</h2><h3 id="1-5-1-积分换元"><a href="#1-5-1-积分换元" class="headerlink" title="1.5.1 积分换元"></a>1.5.1 积分换元</h3><p><strong>(一) 积分换元</strong></p><p>积分换元需要考虑下面三个方面：</p><ul><li>旧元换新元；</li><li>积分限变化；</li><li>雅可比行列式；</li></ul><p>下面重点说一下雅可比</p><p>假设我们要用换元法计算下面的积分：</p><script type="math/tex; mode=display">\iint f(x,y) \text{ d}x \mathrm{d}y</script><p>所要换的元为</p><script type="math/tex; mode=display">\left\{\begin{aligned}x = x(u, v) \\y = y(u, v)\end{aligned}\right.</script><p>我们把</p><script type="math/tex; mode=display">\boldsymbol J = \left|\dfrac{\partial(x, y)}{\partial(u, v)}\right| = \left|\begin{array}{ll}\dfrac{\partial x}{\partial u} & \dfrac{\partial x}{\partial v} \\\dfrac{\partial y}{\partial u} & \dfrac{\partial y}{\partial v}\end{array}\right|</script><p>那么就可以把这个积分写成：</p><script type="math/tex; mode=display">\iint f(x, y) \text{ d}x \mathrm{d}y = \iint f[x(u, v), y(u, v)] |\boldsymbol J| \text{ d}u \mathrm{d}v</script><p><strong>特别要注意：雅可比行列式要加绝对值</strong>。 </p><p>再比如，用极坐标的积分变换：</p><script type="math/tex; mode=display">\left\{\begin{aligned}x = r \cos \theta \\y = r \sin \theta\end{aligned}\right.</script><p>我们发现$x$和$y$都是关于$r$和$\theta$的二元函数，因此：</p><script type="math/tex; mode=display">\left|\dfrac{\partial(x, y)}{\partial(r, \theta)}\right|=\left|\begin{array}{cc}\cos \theta & -r \sin \theta \\\sin \theta & r \cos \theta\end{array}\right|=r</script><p>所以：</p><script type="math/tex; mode=display">\iint f(x, y) \text{ d}x \mathrm{d}y = \iint f(r \cos \theta, r \sin \theta) r \text{ d}r \mathrm{d}\theta</script><p>我们也可以把这个结论拓展到三维情况，这个交给读者自行推导，这里给出结论：</p><p>若：</p><script type="math/tex; mode=display">\left\{\begin{aligned}x = x(u, v, w) \\y = y(u, v, w) \\z = z(u, v, w)\end{aligned}\right.</script><p>则：</p><script type="math/tex; mode=display">\left|\frac{\partial(x, y, z)}{\partial(u, v, w)}\right|=\left|\begin{array}{lll}\dfrac{\partial x}{\partial u} & \dfrac{\partial x}{\partial v} & \dfrac{\partial x}{\partial w} \\\dfrac{\partial y}{\partial u} & \dfrac{\partial y}{\partial v} & \dfrac{\partial y}{\partial w} \\\dfrac{\partial z}{\partial u} & \dfrac{\partial z}{\partial v} & \dfrac{\partial z}{\partial w}\end{array}\right|</script><p>带回计算，得：</p><script type="math/tex; mode=display">\iiint f(x, y, z) \text{ d}x \mathrm{d}y \mathrm{d}z = \iiint f[x(u, v, w), y(u, v, w), z(u, v, w)] \left|\frac{\partial(x, y, z)}{\partial(u, v, w)}\right| \text{ d}u \mathrm{d}v \mathrm{d}w</script><p><strong>(二) 离散求和换元</strong></p><p>离散求和换元比积分换元要简单，只需考虑下面两个方面即可：</p><ul><li>旧元换新元；</li><li>积分限变化；</li></ul><blockquote><p>积分换元参考资料：<br><a href="https://www.bilibili.com/read/cv15770213">浅谈雅可比行列式和积分换元的原理 - EnemyIncoming - Bilibili</a></p></blockquote><h3 id="1-5-2-变限积分求导公式"><a href="#1-5-2-变限积分求导公式" class="headerlink" title="1.5.2 变限积分求导公式"></a>1.5.2 变限积分求导公式</h3><script type="math/tex; mode=display">\frac{\text{d}}{\text{d}x} \int_{a}^{x} f(t) \text{ d}t = f(x)</script><script type="math/tex; mode=display">\frac{\text{d}}{\text{d}x} \int_{x}^{b} f(t) \text{ d}t = -f(x)</script><script type="math/tex; mode=display">\frac{\text{d}}{\text{d}x} \int_{a}^{\varphi(x)} f(t) \text{ d}t = f(\varphi(x)) \frac{\text{d}}{\text{d}x} \varphi(x)</script><script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d} x} \int_{\psi(x)}^{\varphi(x)} f(t) \mathrm{d} t=\frac{\mathrm{d}}{\mathrm{d} x}\left[\int_{\psi(x)}^a f(t) \mathrm{d} t+\int_a^{\varphi(x)} f(t) \mathrm{d} t\right] =  f(\varphi(x)) \frac{\text{d}}{\text{d}x} \varphi(x) -  f(\psi(x)) \frac{\text{d}}{\text{d}x} \psi(x)</script><h3 id="1-5-3-重要积分"><a href="#1-5-3-重要积分" class="headerlink" title="1.5.3 重要积分"></a>1.5.3 重要积分</h3><p><strong>(一) 复指数函数积分</strong></p><script type="math/tex; mode=display">\int_{-\infty}^{\infty} \mathrm{e}^{ikx} \mathrm{d}x = 2\pi \delta(k)</script><blockquote><p>可以从$\delta(t)$的傅里叶变换推导。</p></blockquote><ul><li><a href="https://www.doc88.com/p-3364686806051.html?r=1">广义傅里叶变换 - 道客巴巴文档</a></li><li><a href="https://tieba.baidu.com/p/3631096878#/">e的ikx次方对x怎么积分 - 百度贴吧</a>、<a href="https://ochicken.top/Library/Physics/Method_of_Mathematical_Physics/%E9%87%91%E7%8E%89%E6%98%8E-%E5%AE%9E%E7%94%A8%E7%A7%AF%E5%88%86%E8%A1%A8-(%E4%B8%AD%E7%A7%91%E5%A4%A7%E5%87%BA%E7%89%88%E7%A4%BE">实用积分表</a>.pdf)</li></ul><p><strong>(二) 伽马$\Gamma$函数积分</strong></p><p>$\Gamma$函数的定义：</p><script type="math/tex; mode=display">\Gamma(\alpha) = \int_0^{\infty} x^{\alpha-1} \mathrm e^{-x} \text{ d}x</script><p>容易证得，该积分对于$\alpha &gt; 0$均收敛。</p><p>$\Gamma$函数的性质：</p><ul><li><p>(1) $\Gamma(1) = 1, \Gamma(\dfrac{1}{2}) = \sqrt{\pi}$；</p></li><li><p>(2) $\Gamma(\alpha+1) = \alpha\Gamma(\alpha)$；</p></li><li><p>(3) $\Gamma(n+1) = n!, \quad n \in \mathbb N$；</p></li></ul><p>$\Gamma$函数的另一种形式：</p><script type="math/tex; mode=display">\Gamma(\alpha) = 2\int_0^{\infty} x^{2\alpha -1} \mathrm e^{-x^2} \text{ d}x</script><blockquote><p>特别注意$\Gamma$函数的各种变形。</p></blockquote><h2 id="1-6-重要不等式"><a href="#1-6-重要不等式" class="headerlink" title="1.6 重要不等式"></a>1.6 重要不等式</h2><h3 id="1-6-1-柯西-施瓦茨不等式"><a href="#1-6-1-柯西-施瓦茨不等式" class="headerlink" title="1.6.1 柯西-施瓦茨不等式"></a>1.6.1 柯西-施瓦茨不等式</h3><ul><li><p>二维形式</p><script type="math/tex; mode=display">ac + bd \leq \sqrt{(a^2 + b^2)(c^2+d^2)}</script><p>等号成立条件：当且仅当$ad = bc$。</p></li><li><p>三角形式</p><script type="math/tex; mode=display">\sqrt{a^2 + b^2} + \sqrt{c^2 + d^2} \geq \sqrt{(a-c)^2 + (b-d)^2}</script><p>等号成立条件：$ad = bc$且$ac + bd \leq 0$</p></li><li><p>概率形式</p><script type="math/tex; mode=display">(E(XY))^2 \leq E(X^2) E(Y^2)</script><p>等号成立条件：当且仅当$P(X+kY=0)=1$时，”=”成立</p></li><li><p>积分形式</p><script type="math/tex; mode=display">\left(\int f(x)g(x) \text{ d}x\right)^2 \leq \int f^2(x) \text{ d}x \int g^2(x) \text{ d}x</script><p>等号成立条件：$f(x) = kg(x)$</p></li><li><p>向量形式</p><script type="math/tex; mode=display">(\boldsymbol x, \boldsymbol y)^2 \leq (\boldsymbol x, \boldsymbol x)(\boldsymbol y, \boldsymbol y)</script><p>等号成立条件：$\boldsymbol x =  k\boldsymbol y$</p></li></ul><h3 id="1-6-2-均值不等式"><a href="#1-6-2-均值不等式" class="headerlink" title="1.6.2 均值不等式"></a>1.6.2 均值不等式</h3><p>均方根QM $\geq$ 算术平均AM $\geq$ 几何平均GM $\geq$ 调和平均HM</p><script type="math/tex; mode=display">\sqrt{\dfrac{x_1^2+ \cdots +x_n^2}{n}} \geq \dfrac{x_1+ \cdots +x_n}{n} \geq \sqrt[n]{x_1 \cdots x_n} \geq \dfrac{n}{\frac{1}{x_1}+\cdots +\frac{1}{x_n}}</script><p>当且仅当$x_1 = x_2 = \cdots = x_n$时，取”=”</p><h2 id="1-7-复数的运算法则"><a href="#1-7-复数的运算法则" class="headerlink" title="1.7 复数的运算法则"></a>1.7 复数的运算法则</h2><h3 id="1-7-1-复数表示方法"><a href="#1-7-1-复数表示方法" class="headerlink" title="1.7.1 复数表示方法"></a>1.7.1 复数表示方法</h3><p>复数主要有三种表示方法：直角坐标系表示，极坐标系表示，三角函数表示</p><script type="math/tex; mode=display">z = a + ib = r \mathrm{e}^{\mathrm{i} \varphi} = r(\cos \varphi + \mathrm{i} \sin \varphi)</script><p>其中，$a$ 和 $b$ 表示复数的实部和虚部，$r$ 和 $\varphi$ 表示复数的模长和辐角。根据定义，可以看到其关系为：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}a = r \cos \varphi \\b = r \sin \varphi \end{array}\right.</script><h3 id="1-7-2-复数的四则运算、共轭运算、模长运算"><a href="#1-7-2-复数的四则运算、共轭运算、模长运算" class="headerlink" title="1.7.2 复数的四则运算、共轭运算、模长运算"></a>1.7.2 复数的四则运算、共轭运算、模长运算</h3><p><strong>(1) 基本四则运算</strong></p><p>设 $z_1 = a+\mathrm{i}b$ 和 $z_2 = c + \mathrm{i}d$ 是任意两个复数，则其基本四则运算为：</p><ul><li>加法运算，复数的加法按照以下规定的法则进行：</li></ul><script type="math/tex; mode=display">z_1 + z_2 = (a+\mathrm{i}b)+(c+\mathrm{i}d) = (a+c) + \mathrm{i}(b+d);</script><ul><li>减法运算，复数的减法按照以下规定的法则进行： </li></ul><script type="math/tex; mode=display">z_1 - z_2 = (a+\mathrm{i}b) - (c+\mathrm{i}d) = (a-c)+\mathrm{i}(b-d)</script><ul><li>乘法运算，复数的乘法按照以下的法则进行： </li></ul><script type="math/tex; mode=display">z_1 \times z_2 = (a+\mathrm{i}b) \times (c+\mathrm{i}d) = (ac-bd)+\mathrm{i}(bc+ad)</script><ul><li>除法运算，复数的除法是通过分母实数化来计算：</li></ul><script type="math/tex; mode=display">\dfrac{z_1}{z_2} = \dfrac{z_1 \times \bar z_2}{z_2 \times \bar z_2} = \dfrac{ (a+\mathrm{i}b) \times (c-\mathrm{i}d)}{ (c+\mathrm{i}d) \times (c-\mathrm{i}d)} = \dfrac{(ac + bd) + \mathrm{i}(bc - ad)}{c^2+d^2}</script><p><strong>(2) 基本共轭运算</strong></p><ul><li>共轭运算，复数的共轭按照以下的法则进行： </li></ul><script type="math/tex; mode=display">\bar z = a - \mathrm{i}b = r \mathrm{e}^{-\mathrm{i} \varphi} = r(\cos \varphi - \mathrm{i} \sin \varphi)</script><p><strong>(3) 基本模长运算</strong></p><ul><li>模长是将复数的实部与虚部的平方和的正的平方根的值称为该复数的模：</li></ul><script type="math/tex; mode=display">|z| = \sqrt{a^2 + b^2} = r</script><p><strong>(4) 混合运算</strong></p><ul><li>复数加减运算后取共轭</li></ul><script type="math/tex; mode=display">\overline{z_1 \pm z_2} = \bar z_1 \pm \bar z_2</script><ul><li>复数乘除运算后取共轭</li></ul><script type="math/tex; mode=display">\overline{z_1 \times z_2} = \bar z_1 \times \bar z_2 \qquad \qquad \overline{\left(\dfrac{z_1}{z_2}\right)} = \dfrac{\bar z_1}{\bar z_2}</script><table><td style="word-wrap:break-word;word-break:break-all;" width="100px"; bgcolor=HoneyDew><font size="3"><strong>小结1：</strong> 若$\mathrm{R}(z_1, z_2, \cdots, z_n)$表示 $n$ 个复数基本四则运算的组合，则它满足规律 ：<br><center>$\overline{\mathrm{R}(z_1, z_2, \cdots, z_n)} = \mathrm{R}(\bar z_1, \bar z_2, \cdots, \bar z_n)$</center></font></td></table><ul><li>复数相乘运算后取模长</li></ul><script type="math/tex; mode=display">|z_1 \times z_1| = |z_1| \times |z_1| \quad \Longrightarrow \quad \left|\prod _{n=1}^N z_n \right| = \prod _{n=1}^N |z_n|</script><ul><li>复数相除运算后取模长</li></ul><script type="math/tex; mode=display">\left|\dfrac{z_1}{z_2} \right| = \dfrac{|z_1|}{|z_2|}</script><table><td style="word-wrap:break-word;word-break:break-all;" width="100px"; bgcolor=HoneyDew><font size="3"><strong>小结2：</strong> 复数模长的一些性质</br>- （1）$|\mathrm{Re} (z)| \leq |z|, \quad |\mathrm{Im} (z)| \leq |z|$</br>- （2）$|z| \leq |\mathrm{Re} (z)| + |\mathrm{Im} (z)|$</br>- （3）$|z|^2 = |\bar z|^2 = z \times \bar z$</br>- （4）$|z_1| - |z_2| \leq |z_1 \pm z_2| \leq |z_1| + |z_2|$</br>- （5）$|z_1 + z_2 + \cdots + z_n| \leq |z_1| + |z_2| + \cdots + |z_n|$</br>- （6）$|z_1 + z_2|^2 + |z_1 - z_2|^2 = 2(|z_1|^2 + |z_2|^2)$</font></td></table><h2 id="1-8-集合"><a href="#1-8-集合" class="headerlink" title="1.8 集合"></a>1.8 集合</h2><h3 id="1-8-1-一些基本概念"><a href="#1-8-1-一些基本概念" class="headerlink" title="1.8.1 一些基本概念"></a>1.8.1 一些基本概念</h3><p><strong>(一) 属于与包含</strong></p><p>属于是指元素与集合的关系，包含是指集合与集合间关系。属于和包含的区别是：</p><ul><li><p>（1）属于用符号$\in$表示：若元素$a$是集合$\mathbb{A}$的元素，则称$a$属于$\mathbb{A}$，记为$a \in \mathbb{A}$；</p></li><li><p>（2）包含是集合与集合间关系，包含于用符号$\subseteq$表示：若集合$\mathbb{B}$是集合$\mathbb{A}$的子集，则称$\mathbb{B}$包含于$\mathbb{A}$，记为$\mathbb{B} \subseteq \mathbb{A}$。</p><ul><li><p>注意1，集合$\mathbb{B}$是集合$\mathbb{A}$的子集也可以用包含符号$\supseteq$表示，称$\mathbb{A}$包含$\mathbb{B}$，记为$\mathbb{A} \supseteq \mathbb{B}$；</p></li><li><p>注意2，$\subsetneqq$表示真包含于，$\subseteq$表示包含于 —— $\mathbb{B}$真包含于$\mathbb{A}$，$\mathbb{B}$不可以等于$\mathbb{A}$，$\mathbb{B}$包含于$\mathbb{A}$，$\mathbb{B}$可以等于$\mathbb{A}$。</p></li><li><p>注意3， 一般情况下，$\subsetneqq$、$\subsetneq$、$\subset$这三个符号都表示真包含于 —— 其中，$\subsetneqq$是真包含于的正统符号，$\subsetneq$不是规范符号(课本没有这个符号，有时候题目有出现，是真包含于的意思)，$\subset$表示空间几何直线、平面之间的位置关系，如$l \subset \alpha$：直线$ l $在平面$\alpha$内。</p></li><li><p>注意4，$\subset$这个符号有一定歧义，有的书上是真包含于(常用)，有的是包含于。</p></li></ul></li></ul><p><strong>(二) 常见集合符号</strong></p><div class="table-container"><table><thead><tr><th>集合符号</th><th>释义</th><th></th></tr></thead><tbody><tr><td>$\emptyset$</td><td>空集</td><td></td></tr><tr><td>$\mathbb{N}$</td><td>全体非负整数的集合，简称非负整数集（或自然数集）</td><td></td></tr><tr><td>$\mathbb{N}^{+} \quad \text{or} \quad \mathbb{N}^{*}$</td><td>非负整数集内排除0的集，也称正整数集</td><td></td></tr><tr><td>$\mathbb{Z}$</td><td>全体整数的集合，通常称作整数集</td><td></td></tr><tr><td>$\mathbb{Q}$</td><td>全体有理数的集合，通常简称有理数集</td><td></td></tr><tr><td>$\mathbb{R}$</td><td>全体实数的集合，通常简称实数集</td><td></td></tr><tr><td>$\mathbb{C}$</td><td>全体复数的集合，通常简称复数集</td></tr></tbody></table></div><h3 id="1-8-2-集合的笛卡尔乘积"><a href="#1-8-2-集合的笛卡尔乘积" class="headerlink" title="1.8.2 集合的笛卡尔乘积"></a>1.8.2 集合的笛卡尔乘积</h3><p><strong>(一) 定义</strong></p><p>设$\mathbb{A}$和$\mathbb{B}$为集合，$\mathbb{A}$与$\mathbb{B}$的笛卡儿积记作$\mathbb{A} \times \mathbb{B}$：</p><script type="math/tex; mode=display">\mathbb{A} \times \mathbb{B} = \{(x, y) \mid x \in \mathbb{A}, y \in \mathbb{B}\}</script><p>例题：设$\mathbb{A} = \{1, 2\}$，$\mathbb{B} = \{a, b, c\}$，则$\mathbb{A} \times \mathbb{B}$和$\mathbb{B} \times \mathbb{A}$分别为：</p><script type="math/tex; mode=display">\begin{aligned}&\mathbb{A} \times \mathbb{B} = \{(1, a), (1, b), (1, c), (2, a), (2, b), (2, c)\} \\&\mathbb{B} \times \mathbb{A} = \{(a, 1), (a, 2), (b, 1), (b, 2), (c, 1), (c, 2)\}\end{aligned}</script><p><strong>推广：</strong>设$\mathbb{A}_1, \mathbb{A}_2, \cdots, \mathbb{A}_n$是$n$个集合，则$n$阶笛卡尔积为：</p><script type="math/tex; mode=display">\mathbb{A}_1 \times \mathbb{A}_2 \times \cdots \times \mathbb{A}_n = \{(x_1, x_2, \cdots, x_n) \mid x_i \in \mathbb{A}_i, i = 1, 2, \cdots, n\}</script><p>如：$(1, 1, 0)$为$3$维空间中的一个矢量，则可称$(1, 1, 0) \in \mathbb{R} \times \mathbb{R} \times \mathbb{R}$。</p><p><strong>(二) 笛卡儿积的性质</strong></p><ul><li><p>（1）若$\mathbb{A}$或$\mathbb{B}$中有一个为空集，则$\mathbb{A} \times \mathbb{B}$就是空集：$\mathbb{A} \times \emptyset = \emptyset \times \mathbb{B} = \emptyset$；</p></li><li><p>（2）不适合交换律：$\mathbb{A} \times \mathbb{B} \neq \mathbb{B} \times \mathbb{A}, \quad \mathbb{A} \neq \mathbb{B}, \mathbb{A} \neq \emptyset, \mathbb{B} \neq \emptyset$；</p></li><li><p>（3）不适合结合律：$(\mathbb{A} \times \mathbb{B}) \times \mathbb{C} \neq \mathbb{A} \times (\mathbb{B} \times \mathbb{C}), \quad \mathbb{A} \neq \emptyset, \mathbb{B} \neq \emptyset, \mathbb{C} \neq \emptyset$；</p></li><li><p>（4）对并或交满足分配律：$\mathbb{A} \times (\mathbb{B} \cup \mathbb{C}) = (\mathbb{A} \times \mathbb{B}) \cup (\mathbb{A} \times \mathbb{C}) \quad \mathbb{A} \times (\mathbb{B} \cap \mathbb{C}) = (\mathbb{A} \times \mathbb{B}) \cap (\mathbb{A} \times \mathbb{C})$</p></li><li><p>（5）若$|\mathbb{A}| = m, |\mathbb{B} = n|$，则$|\mathbb{A} \times \mathbb{B}| = mn$；</p></li></ul><h3 id="1-8-3-测度论简介"><a href="#1-8-3-测度论简介" class="headerlink" title="1.8.3 测度论简介"></a>1.8.3 测度论简介</h3><p>参考链接1：<a href="https://zhuanlan.zhihu.com/p/342579998">【测度论】Ch1. 问题引入 - Dylaaan的文章 - 知乎</a><br>参考链接2：<a href="https://www.zhihu.com/question/22436433">概率论中零测集的意义是什么？ - 知乎</a><br>参考链接3：<a href="https://wenku.baidu.com/view/1264261789d63186bceb19e8b8f67c1cfbd6ee22.html">实分析与复分析零测集所起的作用 - 百度文库</a><br>参考链接4：<a href="https://www.kxting.com/article/20221205/3191476.html">零测集的概念及性质 - 未知来源</a><br>参考链接5：<a href="https://blog.csdn.net/san_fu_su/article/details/113388570">Lebesgue零测度 - CSDN</a><br>参考链接5：<a href="https://www.zhihu.com/question/35231006">为什么有理数测度为0? - 知乎</a></p><h1 id="2-概率部分"><a href="#2-概率部分" class="headerlink" title="2 概率部分"></a>2 概率部分</h1><h2 id="2-1-常用的统计分布模型"><a href="#2-1-常用的统计分布模型" class="headerlink" title="2.1 常用的统计分布模型"></a>2.1 常用的统计分布模型</h2><h3 id="2-1-1-离散分布模型"><a href="#2-1-1-离散分布模型" class="headerlink" title="2.1.1 离散分布模型"></a>2.1.1 离散分布模型</h3><p>(一) <strong>两点分布</strong>(伯努利分布/0-1分布)——$X \sim Bern(p)$</p><ul><li>分布函数与密度函数</li></ul><p>随机变量$X$只可能取 0 or 1 两个值，其分布函数为：</p><center><img src="https://img2022.cnblogs.com/blog/2609360/202209/2609360-20220920203856095-431642081.png" style="zoom:40%" /></center><script type="math/tex; mode=display">\Updownarrow</script><script type="math/tex; mode=display">P(X = k) = p^k (1-p)^{1-k}, k = 0,1</script><ul><li>期望与方差</li></ul><script type="math/tex; mode=display">E(X) = p \qquad D(X) = p(1-p)</script><p>(二) <strong>二项分布</strong>——$X \sim B(n, p)$</p><ul><li>分布函数与密度函数</li></ul><script type="math/tex; mode=display">P(X = k) = C_n^k \text{ }p^k(1-p)^{n-k}</script><ul><li>期望与方差</li></ul><script type="math/tex; mode=display">E(X) = np \qquad D(X) = np(1-p)</script><ul><li>二项分布的性质</li></ul><p>(1) 如果$X \sim B(n,p)$和$Y \sim B(m,p)$，且$X$和$Y$相互独立，那么$X+Y$也服从二项分布，它的分布为：</p><script type="math/tex; mode=display">X+Y \sim B(n+m, p)</script><p>(2) 伯努利分布是二项分布在$n = 1$时的特殊情况。$X \sim B(1,p)$与$X \sim Bern(p)$的意思是相同的。相反，任何二项分布$B(n,p)$都是$n$次独立伯努利试验的和，每次试验成功的概率为$p$。</p><p>(3) 泊松近似，当试验的次数趋于无穷大，而乘积$np$固定时，<strong>二项分布收敛于泊松分布</strong>。因此参数为$λ=np$的泊松分布可以作为二项分布$B(n,p)$的近似，近似成立的前提要求$n$足够大，而$p$足够小，$np$不是很小。</p><blockquote><p><strong>二项展开式：</strong> $(a + b)^n = \sum\limits_{r = 0}^{n} C_n^r a^{n-r}b^r$<br><strong>排列/组合数计算：</strong> $A_n^m = \dfrac{n!}{(n-m)!}, C_n^m = \dfrac{A_n^m}{m!} = \dfrac{n!}{m! (n-m)!}$<br><strong>组合数性质：</strong>$C_n^m = C_n^{n-m}$、$C_{n+1}^m = C_n^m + C_n^{m-1}$、$C_n^0 = 1$</p></blockquote><p>(三) <strong>泊松分布</strong>——$X \sim P(\lambda)$</p><ul><li>分布函数与密度函数</li></ul><script type="math/tex; mode=display">P(X = k) = \frac{\lambda^k}{k!} \mathrm{e}^{-\lambda}, k = 0,1,2,\cdots</script><ul><li>期望与方差</li></ul><script type="math/tex; mode=display">E(X) = \lambda \qquad D(X) = \lambda</script><h3 id="2-1-2-连续分布模型"><a href="#2-1-2-连续分布模型" class="headerlink" title="2.1.2 连续分布模型"></a>2.1.2 连续分布模型</h3><p>(一) <strong>均匀分布</strong>——$X \sim U(a,b)$</p><ul><li>分布函数与密度函数</li></ul><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}\frac{1}{b-a}, & \text{ } a<x<b \\0, & \text{ 其他}\end{aligned}\right.</script><script type="math/tex; mode=display">F(x)=\left\{\begin{aligned}0, & \text{ } x<a \\\frac{x-a}{b-a}, & \text{ } a<x<b \\1, & \text{ } x > b\end{aligned}\right.</script><ul><li>期望与方差</li></ul><script type="math/tex; mode=display">E(X) = \frac{a+b}{2} \qquad D(X) = \frac{(b-a)^2}{12}</script><p>(二) <strong>指数分布</strong>——$X \sim Exp(\lambda)$</p><ul><li>分布函数与密度函数</li></ul><script type="math/tex; mode=display">f(x)=\left\{\begin{aligned}\lambda \mathrm{e}^{-\lambda x}, & \text{ } x>0 \\0, & \text{ } x \leq 0\end{aligned}\right.</script><script type="math/tex; mode=display">F(x)=\left\{\begin{aligned}1-\mathrm{e}^{-\lambda x}, & \text{ } x>0 \\0, & \text{ } x \leq 0\end{aligned}\right.</script><ul><li>期望与方差</li></ul><script type="math/tex; mode=display">E(X) = \frac{1}{\lambda} \qquad D(X) = \frac{1}{\lambda^2}</script><p>(三) <strong>正态分布</strong>——$X \sim N(\mu, \sigma^2)$</p><ul><li>分布函数与密度函数</li></ul><script type="math/tex; mode=display">f(x) = \frac{1}{\sqrt{2 \mathrm{\pi}}\sigma} \exp(-\frac{(x - \mu)^2}{2 \sigma^2})</script><p>-期望与方差</p><script type="math/tex; mode=display">E(X) = \mu \qquad D(X) = \sigma^2</script><ul><li>二维联合正态分布</li></ul><p>假设$(X, Y) \sim (\mu_1, \mu_2, \sigma_1^2, \sigma_2^2, \rho)$，则其联合概率密度函数为：</p><script type="math/tex; mode=display">f(x, y) = \frac{1}{2 \pi \sigma_1 \sigma_2 \sqrt{1-\rho^2}} \exp \left\{-\frac{1}{2\left(1-\rho^2\right)}\left(\frac{\left(x-\mu_1\right)^2}{\sigma_1^2}-2 \rho \frac{\left(x-\mu_1\right)\left(y-\mu_2\right)}{\sigma_1 \sigma_2}+\frac{\left(y-\mu_2\right)^2}{\sigma_2^2}\right)\right\}</script><p>其中$ρ$是$X$与$Y$之间的相关系数，$\sigma_{X}&gt;0$且$\sigma_{Y}&gt;0$。在这种情况下</p><script type="math/tex; mode=display">\boldsymbol{\mu}=\left(\begin{array}{c}\mu_X \\\mu_Y\end{array}\right), \quad \boldsymbol{\Sigma}=\left(\begin{array}{cc}\sigma_X^2 & \rho \sigma_X \sigma_Y \\\rho \sigma_X \sigma_Y & \sigma_Y^2\end{array}\right)</script><ul><li>多元正态分布</li></ul><script type="math/tex; mode=display">f_{\boldsymbol{x}}\left(x_1, \ldots, x_k\right)=\frac{1}{\sqrt{(2 \pi)^k|\mathbf{\Sigma}|}} \mathrm{e}^{-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{\mathrm{T}} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{\mu})}</script><p>注意这里的$|\mathbf{\Sigma}|$表示协方差矩阵的行列式。</p><ul><li><strong><font color=green>高斯分布的几个重要性质</font></strong></li></ul><p>① 根据高斯函数性质知，两个高斯函数卷积的结果仍为高斯函数；</p><p>② 高斯函数的一个积分性质：$\displaystyle\int_{\boldsymbol x} \exp\left\{ -(\boldsymbol{Ax+b})^2\right\} \text{ d}{\boldsymbol x} = \text{Const}$；</p><p>③ 边缘和条件高斯分布：给定$\boldsymbol x$的边缘高斯分布和$\boldsymbol y$在$\boldsymbol x$下的条件高斯分布，则可以推导出$\boldsymbol y$的边缘分布：</p><script type="math/tex; mode=display">\begin{gathered}p(\boldsymbol x) = \mathcal{N}(\boldsymbol x | \boldsymbol \mu, \boldsymbol \Lambda^{-1}) \qquad p(\boldsymbol y | \boldsymbol x) = \mathcal{N}(\boldsymbol y | \boldsymbol{Ax+b}, \boldsymbol L^{-1}) \\\Downarrow\\p(\boldsymbol y) = \mathcal{N}(\boldsymbol y | \boldsymbol{A \mu +b}, \boldsymbol L^{-1} + \boldsymbol A \boldsymbol \Lambda^{-1} \boldsymbol A^{\mathrm T})\end{gathered}</script><p><strong>详细关于高斯正态分布乘积、卷积的公式证明请参考：<a href="https://www.cnblogs.com/shuangli0824/p/10854560.html">高斯函数与正态分布乘积与卷积的性质 - 小信号 - 博客园</a>：<font color=red>强推，写的不错！！！</font></strong></p><p>(四) <strong>瑞利分布</strong></p><p>瑞利分布（Rayleigh distribution），又译为莱利分布，当一个随机二维向量的两个分量呈独立的、有着相同的方差、均值为0的正态分布时，这个向量的模呈瑞利分布。例如，当随机复数的实部和虚部独立同分布于0均值，同方差的正态分布时，该复数的绝对值服从瑞利分布。该分布是以瑞利命名的。</p><ul><li>概率密度函数与分布函数</li></ul><script type="math/tex; mode=display">f_Z(z; \sigma) = \frac{z}{\sigma^2} \exp \left(-\frac{z^2}{2\sigma^2} \right), \quad z \geq 0</script><script type="math/tex; mode=display">F_Z(z) = 1 - \exp \left(- \frac{z^2}{2\sigma^2} \right)</script><p>-期望与方差</p><script type="math/tex; mode=display">E(Z) = \sqrt{\frac{\pi}{2}} \sigma \qquad D(X) = \frac{4-\pi}{2} \sigma^2</script><h2 id="2-2-几个重要性质"><a href="#2-2-几个重要性质" class="headerlink" title="2.2 几个重要性质"></a>2.2 几个重要性质</h2><h3 id="2-2-1-全概率公式"><a href="#2-2-1-全概率公式" class="headerlink" title="2.2.1 全概率公式"></a>2.2.1 全概率公式</h3><script type="math/tex; mode=display">P(A)=\sum_{i}P(A|B=b_i)P(B=b_i)</script><h3 id="2-2-2-全期望公式"><a href="#2-2-2-全期望公式" class="headerlink" title="2.2.2 全期望公式"></a>2.2.2 全期望公式</h3><script type="math/tex; mode=display">E(A)=\sum_{i}E(A|B=b_i)P(B=b_i)</script><h3 id="2-2-3-重期望公式"><a href="#2-2-3-重期望公式" class="headerlink" title="2.2.3 重期望公式"></a>2.2.3 重期望公式</h3><script type="math/tex; mode=display">E(E(X \mid Y)) = E(X)</script><h2 id="2-3-各种矩估计函数的性质"><a href="#2-3-各种矩估计函数的性质" class="headerlink" title="2.3 各种矩估计函数的性质"></a>2.3 各种矩估计函数的性质</h2><h2 id="2-4-相关函数及协方差函数"><a href="#2-4-相关函数及协方差函数" class="headerlink" title="2.4 相关函数及协方差函数"></a>2.4 相关函数及协方差函数</h2><div class="table-container"><table><thead><tr><th style="text-align:left">常用函数</th><th style="text-align:left">表达式</th></tr></thead><tbody><tr><td style="text-align:left">数学期望</td><td style="text-align:left">$\mu_X(t) = E[X(t)]$</td></tr><tr><td style="text-align:left">方差函数</td><td style="text-align:left">$\sigma_X^2 = E[X(t) - \mu_X(t)]^2$</td></tr><tr><td style="text-align:left">自相关函数</td><td style="text-align:left">$R_X(t_1, t_2) = E[X(t_1) X(t_2)]$</td></tr><tr><td style="text-align:left">协方差函数</td><td style="text-align:left">$C_X(t_1, t_2) = \text{Cov}[X(t_1), X(t_2)] = E[(X(t_1) - \mu_X(t_1))(X(t_2) - \mu_X(t_2))]$</td></tr></tbody></table></div><p>&lt;/style&gt;</p><table class="tg"><thead>  <tr>    <th class="tg-0pky">相关/协方差函数</th>    <th class="tg-0lax">表达式</th>  </tr></thead><tbody>  <tr>    <td class="tg-0lax">自协方差</td>    <td class="tg-0lax"> $C_X(t_1, t_2)$ $=$ $E([X(t_1)$ $-$ $\mu_X(t_1)][X(t_2)$ $-$ $\mu_X(t_2)])$ $=$ $E[X(t_1)X(t_2)]$ $-$ $\mu_X(t_1)\mu_X(t_2)$ </td>  </tr>  <tr>    <td class="tg-0lax">互协方差</td>    <td class="tg-0lax"> $C_{XY}(t_1, t_2)$ $=$ $E[X(t_1)$ $-$ $\mu_X(t_1)][Y(t_2)$ $-$ $\mu_Y(t_2)]$ </td>  </tr>  <tr>    <td class="tg-0lax">自相关函数</td>    <td class="tg-0lax"> $R_X(t_1, t_2)$ $=$ $E[X(t_1)X(t_2)]$</td>  </tr>  <tr>    <td class="tg-0lax">互相关函数</td>    <td class="tg-0lax"> $R_{XY}(t_1, t_2)$ $=$ $E[X(t_1)Y(t_2)]$ </td>  </tr>  <tr>    <td class="tg-0lax" colspan="2">注1：特别的若$\begin{Bmatrix} X(t), t \in T\end{Bmatrix}$的期望函数为0，则协方差函数和自相关函数相等。若$X(t_1),X (t_2)$随机程的两状态相互独立，则有$C_X(t_1, t_2) = 0$；<br><br>注2：特别的若$X(t), Y(t)$之一的期望为0，则互协方差等于互相关函数。若$X(t),Y(t)$相互独立，则$C_{XY}(t_1, t_2) = 0$，$X(t), Y(t)$称为互不相关的。相互独立的两个随机过程必是互不相关的。反之如果互相关的不一定相互独立。</td>  </tr></tbody></table><p>&lt;/style&gt;</p><table class="tg"><thead>  <tr>    <th class="tg-0pky">谱密度函数</th>    <th class="tg-0pky">表达式</th>  </tr></thead><tbody>  <tr>    <td class="tg-0lax">自谱密度函数</td>    <td class="tg-0lax"> $S_X(\omega) = \displaystyle\int_{-\infty}^{\infty} R_X(\tau) \text{e}^{-j\omega t} \text{ d}\tau$ </td>  </tr>  <tr>    <td class="tg-0lax">互谱密度函数</td>    <td class="tg-0lax"> $S_{XY}(\omega) = \displaystyle\int_{-\infty}^{\infty} R_{XY}(\tau) \text{e}^{-j\omega t} \text{ d}\tau$ </td>  </tr>  <tr>    <td class="tg-0lax" colspan="2">注：谱密度函数就是相关函数的傅里叶变换式；反之，相关函数就是谱密度函数的傅里反变换。</td>  </tr></tbody></table><h3 id="2-4-2-随机向量期望与协方差"><a href="#2-4-2-随机向量期望与协方差" class="headerlink" title="2.4.2 随机向量期望与协方差"></a>2.4.2 随机向量期望与协方差</h3><p>此处仅给出在经典统计学意义下的随机向量(不考虑在测度论框架下的随机向量定义)，即此处的随机向量的各个分量均为随机变量，且均值为$\mu$，方差为$\sigma^2$，则我们可以按如下方式来定义一个随机向量：</p><p>定义 1 ：设$\boldsymbol X = [X_1, X_2, \cdots, X_n]^{\mathrm T}$为随机向量，若其每个分量$X_i$为随机变量，且称$\boldsymbol X$为$n \times 1$随机向量，记$\mathbb{E}(\boldsymbol X) = [\mathbb{E}(X_1), \mathbb{E}(X_2), \cdots, \mathbb{E}(X_n)]^{\mathrm T}$为$\boldsymbol X$的均值。</p><p>定义 2 ：称$\mathrm{Cov}(\boldsymbol X) = \mathbb{E}[(\boldsymbol X - \mathbb{E} \boldsymbol X)(\boldsymbol X - \mathbb{E} \boldsymbol X)^{\mathrm T}]$为$\boldsymbol X$的自协方差矩阵，<strong><font color=red>自协方差矩阵必为半正定对称矩阵</font></strong>。</p><script type="math/tex; mode=display">c_{ij} = \mathrm{Cov}(X_i, X_j) = \mathbb{E}[(X_i - \mathbb{E} X_i)(\boldsymbol X_j - \mathbb{E} X_j)], \quad i,j=1,2, \cdots, n</script><script type="math/tex; mode=display">\mathrm{Cov}(\boldsymbol X) = \left[\begin{array}{cccc}c_{11} & c_{12} & \cdots & c_{1n} \\c_{21} & c_{22} & \cdots & c_{2n} \\\vdots & \vdots & \ddots & \vdots \\c_{n1} & c_{n2} & \cdots & c_{nn} \\\end{array}\right]</script><p>定义 3 ：设$\boldsymbol X$与$\boldsymbol Y$分别为$n \times 1$和$m \times 1$随机向量，称$\mathrm{Cov}(\boldsymbol X, \boldsymbol Y) = \mathbb{E}[(\boldsymbol X - \mathbb{E} \boldsymbol X)(\boldsymbol Y - \mathbb{E} \boldsymbol Y)^{\mathrm T}]$为$\boldsymbol X$与$\boldsymbol Y$的协方差矩阵。</p><h1 id="3-线性代数-矩阵论部分"><a href="#3-线性代数-矩阵论部分" class="headerlink" title="3 线性代数/矩阵论部分"></a>3 线性代数/矩阵论部分</h1><h2 id="3-1-转置和逆"><a href="#3-1-转置和逆" class="headerlink" title="3.1 转置和逆"></a>3.1 转置和逆</h2><script type="math/tex; mode=display">(\boldsymbol {AB})^{\mathrm T} = \boldsymbol B^{\mathrm T} \boldsymbol A^{\mathrm T}</script><script type="math/tex; mode=display">(\boldsymbol {AB})^{-1} = \boldsymbol B^{-1} \boldsymbol A^{-1}</script><script type="math/tex; mode=display">(\boldsymbol A^{\mathrm T})^{-1} = (\boldsymbol A^{-1})^{\mathrm T}</script><script type="math/tex; mode=display">\boldsymbol A =\left(\begin{array}{ccc}\boldsymbol A_1 & \boldsymbol A_2 & \boldsymbol A_3 \\\boldsymbol A_4 & \boldsymbol A_5 & \boldsymbol A_6 \\\boldsymbol A_7 & \boldsymbol A_8 & \boldsymbol A_9\end{array}\right) \quad \Longrightarrow \quad \boldsymbol A^{\mathrm T} =\left(\begin{array}{ccc}\boldsymbol A_1^{\mathrm T} & \boldsymbol A_4^{\mathrm T} & \boldsymbol A_7^{\mathrm T} \\\boldsymbol A_2^{\mathrm T} & \boldsymbol A_5^{\mathrm T} & \boldsymbol A_8^{\mathrm T} \\\boldsymbol A_3^{\mathrm T} & \boldsymbol A_6^{\mathrm T} & \boldsymbol A_9^{\mathrm T}\end{array}\right)</script><ul><li><strong><font color=blue>Penrose的广义逆矩阵</font></strong></li></ul><p>设矩阵$\boldsymbol A \in \mathbb{C}^{m \times n}$，若矩阵$\boldsymbol X \in \mathbb C^{n \times m}$满足以下4个Penrose方程：</p><script type="math/tex; mode=display">\boldsymbol{AXA} = \boldsymbol{A} \qquad \qquad \boldsymbol{XAX} = \boldsymbol{X}</script><script type="math/tex; mode=display">(\boldsymbol{AX})^{\mathrm H} = \boldsymbol{AX} \qquad \qquad (\boldsymbol{XA})^{\mathrm H} = \boldsymbol{XA}</script><p>则称$\boldsymbol X$为$\boldsymbol A$的Moore-Penrose逆(伪逆)，记为$\boldsymbol{A}^{\dagger}$。</p><ul><li><strong><font color=red>矩阵求逆公式</font></strong></li></ul><script type="math/tex; mode=display">(\boldsymbol A + \boldsymbol{BCD})^{-1} = \boldsymbol A^{-1} - \boldsymbol A^{-1} \boldsymbol B(\boldsymbol C^{-1} + \boldsymbol D \boldsymbol A^{-1}\boldsymbol B)^{-1} \boldsymbol D \boldsymbol A^{-1}</script><h2 id="3-2-矩阵乘法的五种理解方式"><a href="#3-2-矩阵乘法的五种理解方式" class="headerlink" title="3.2 矩阵乘法的五种理解方式"></a>3.2 矩阵乘法的五种理解方式</h2><h3 id="3-2-1-定义的角度"><a href="#3-2-1-定义的角度" class="headerlink" title="3.2.1 定义的角度"></a>3.2.1 定义的角度</h3><p>设$ \boldsymbol{C = AB} $，则矩阵$ \boldsymbol A $的$ (i,j) $处的元素为$ \boldsymbol A $的第$ i $行与$ \boldsymbol B $的第$ j $列的各元素相乘之和，即：</p><script type="math/tex; mode=display"> c_{i j}=a_{i 1} b_{1 j}+a_{i 2} b_{2 j}+\cdots+a_{i n} b_{n j}=\sum_{k=1}^{n} a_{i k} b_{k j}</script><p>也即是$ \boldsymbol A $的第$ i $行与$ \boldsymbol B $的第$ j $列点乘所得到的结果。</p><h3 id="3-2-2-列的角度"><a href="#3-2-2-列的角度" class="headerlink" title="3.2.2 列的角度"></a>3.2.2 列的角度</h3><p>设矩阵$ \boldsymbol B $为$ \boldsymbol B = (\boldsymbol \beta_1, \boldsymbol \beta_2, \cdots, \boldsymbol \beta_n) $则：</p><script type="math/tex; mode=display">\boldsymbol{AB} = \boldsymbol A (\boldsymbol \beta_1, \boldsymbol \beta_2, \cdots, \boldsymbol \beta_n) = (\boldsymbol A \boldsymbol \beta_1, \boldsymbol A \boldsymbol \beta_2, \cdots, \boldsymbol A \boldsymbol \beta_n)</script><p>因此，从列的角度来看，矩阵$ \boldsymbol B $右乘矩阵$ \boldsymbol A $所得到的矩阵的每一列都是$ \boldsymbol A $的列的线性组合，线性组合的系数分别是$ \boldsymbol B $的各列的分量。</p><h3 id="3-2-3-行的角度"><a href="#3-2-3-行的角度" class="headerlink" title="3.2.3 行的角度"></a>3.2.3 行的角度</h3><p>设矩阵$ \boldsymbol A $为：</p><script type="math/tex; mode=display"> \boldsymbol{A}=\left(\begin{array}{c} \boldsymbol{a}_{1}^{\mathrm{T}} \\ \boldsymbol{\alpha}_{2} {\mathrm{T}} \\ \vdots \\ \boldsymbol{\alpha}_{n}^{\mathrm{T}} \end{array}\right)</script><p>则有：</p><script type="math/tex; mode=display">\boldsymbol{AB}=\left(\begin{array}{c}\boldsymbol{a}_{1}^{\mathrm{T}} \boldsymbol B\\\boldsymbol{\alpha}_{2}^{\mathrm{T}} \boldsymbol B\\\vdots \\\boldsymbol{\alpha}_{n}^{\mathrm{T}} \boldsymbol B\end{array}\right)</script><p>因此，从行的角度来看，矩阵$ \boldsymbol A $左乘矩阵$ \boldsymbol B $所得到的矩阵的每一行都是$ \boldsymbol B $的行的线性组合，线性组合的系数分别是$ \boldsymbol A $的各行的分量。</p><h3 id="3-2-4-从列乘以行的角度"><a href="#3-2-4-从列乘以行的角度" class="headerlink" title="3.2.4 从列乘以行的角度"></a>3.2.4 从列乘以行的角度</h3><p>设矩阵$ \boldsymbol A $、$ \boldsymbol B $分别为：</p><script type="math/tex; mode=display">\boldsymbol{A}=\left(\boldsymbol{\alpha}_{1}, \boldsymbol{\alpha}_{2} \cdots, \boldsymbol{\alpha}_{n}\right),  \quad \boldsymbol{B}=\left(\begin{array}{c}\boldsymbol{\beta}_{1}^{\mathrm{T}} \\\boldsymbol{\beta}_{2}^{\mathrm{T}} \\\vdots \\\boldsymbol{\beta}_{n}^{\mathrm{T}}\end{array}\right)</script><p>则有：</p><script type="math/tex; mode=display">\boldsymbol{A B}=\boldsymbol{\alpha}_{1} \boldsymbol{\beta}_{1}^{\mathrm{T}}+\boldsymbol{\alpha}_{2} \boldsymbol{\beta}_{2}^{\mathrm{T}}+\cdots+\boldsymbol{\alpha}_{n} \boldsymbol{\beta}_{n}^{\mathrm{T}}=\sum_{k=1}^{n} \boldsymbol{\alpha}_{k} \boldsymbol{\beta}_{k}^{\mathrm{T}}</script><p>由于列向量乘以行向量得到的是一个矩阵，因此从列乘以行的角度来看，矩阵$ \boldsymbol A $乘以$ \boldsymbol B $得到的是$ n $个矩阵之和，其中第$ i $个矩阵由$ \boldsymbol A $的第$ i $列乘以$ \boldsymbol B $的第$ j $行得到。</p><h3 id="3-2-5-分块乘法-block-multiplication"><a href="#3-2-5-分块乘法-block-multiplication" class="headerlink" title="3.2.5 分块乘法(block multiplication)"></a>3.2.5 分块乘法(block multiplication)</h3><p>矩阵乘法同样可以分块来乘，只要分块的大小能够使乘法有意义即可(分块的大小要相互匹配)如：</p><script type="math/tex; mode=display">\boldsymbol{A B}=\left(\begin{array}{ll}\boldsymbol{A}_{1} & \boldsymbol{A}_{2} \\\boldsymbol{A}_{3} & \boldsymbol{A}_{4}\end{array}\right)\left(\begin{array}{ll}\boldsymbol{B}_{1} & \boldsymbol{B}_{2} \\\boldsymbol{B}_{3} & \boldsymbol{B}_{4}\end{array}\right)=\left(\begin{array}{ll}\boldsymbol{A}_{1} \boldsymbol{B}_{1}+\boldsymbol{A}_{2} \boldsymbol{B}_{3} & \boldsymbol{A}_{1} \boldsymbol{B}_{2}+\boldsymbol{A}_{2} \boldsymbol{B}_{4} \\\boldsymbol{A}_{3} \boldsymbol{B}_{1}+\boldsymbol{A}_{4} \boldsymbol{B}_{3} & \boldsymbol{A}_{3} \boldsymbol{B}_{2}+\boldsymbol{A}_{4} \boldsymbol{B}_{4}\end{array}\right)</script><p>补充，关于对角矩阵的乘积的3个特例：</p><script type="math/tex; mode=display">\text{diag}(\boldsymbol \mu) \boldsymbol v = \text{diag}(\boldsymbol v) \boldsymbol \mu</script><script type="math/tex; mode=display">\boldsymbol x^{\text T} \boldsymbol \Lambda \boldsymbol x = (x_1, \cdots, x_n) \left( {\begin{array}{c}{\lambda _1}& & \\  & \ddots & \\  & &{\lambda _n} \end{array}} \right) \left( \begin{array}{c} x_1 \\  \vdots \\ x_n \end{array} \right) = \sum_{i=1}^n \lambda_i x_i^2</script><script type="math/tex; mode=display">\gamma \boldsymbol{A B} = \boldsymbol{A} \boldsymbol{\Gamma} \boldsymbol{B}</script><p>其中，$ \boldsymbol \Gamma = \gamma * \boldsymbol I $。</p><p>记矩阵$ \boldsymbol \Phi = [\boldsymbol\phi_1, \boldsymbol\phi_2, \cdots, \boldsymbol\phi_N] \in \mathbb C^{M \times N} $，对角矩阵$ \boldsymbol \Lambda = \text{diag}(\lambda_1, \lambda_2, \cdots, \lambda_N) $，则有：</p><p><img src="https://pic1.imgdb.cn/item/67aed7fad0e0a243d4ff1470.png" style="zoom:80%"></p><h3 id="3-2-6-对角矩阵和哈达玛积"><a href="#3-2-6-对角矩阵和哈达玛积" class="headerlink" title="3.2.6 对角矩阵和哈达玛积"></a>3.2.6 对角矩阵和哈达玛积</h3><p><img src="https://pic1.imgdb.cn/item/67aed742d0e0a243d4ff143f.png" style="zoom:90%"></p><h2 id="3-3-矩阵迹、F范数与内积"><a href="#3-3-矩阵迹、F范数与内积" class="headerlink" title="3.3 矩阵迹、F范数与内积"></a>3.3 矩阵迹、F范数与内积</h2><h3 id="3-3-1-基本定义"><a href="#3-3-1-基本定义" class="headerlink" title="3.3.1 基本定义"></a>3.3.1 基本定义</h3><p>矩阵的迹 ：就是矩阵的主对角线上所有元素的和，对于矩阵$ \boldsymbol A \in \mathbb K^{N \times N} $或$ \boldsymbol A \in \mathbb K^{N \times N} $定义式为：</p><script type="math/tex; mode=display"> \text{Tr}(\boldsymbol A) = \sum_{i=1}^N a_{ii}</script><p>对于矩阵$ \boldsymbol A \in \mathbb K^{M \times N} $乘$ \boldsymbol B \in \mathbb K^{N \times M} $的迹： </p><script type="math/tex; mode=display"> \text{Tr}(\boldsymbol{AB}) = \sum_{i=1}^M \sum_{j=1}^N a_{ij}b_{ji}</script><p>其中，$ \mathbb K $表示实数域$ \mathbb R $或者复数域$ \mathbb C $均可。</p><p>矩阵$ \boldsymbol A \in \mathbb K^{M \times N} $的F范数定义式为：</p><script type="math/tex; mode=display"> \| \boldsymbol A \|_F = \sqrt{\sum_{i=1}^M \sum_{j=1}^N |a_{ij}|^2}</script><p>F范数与迹的关系：</p><script type="math/tex; mode=display">| \boldsymbol A |^2_F = \text{Tr}(\boldsymbol A \boldsymbol A^T) = \text{Tr}(\boldsymbol A^T \boldsymbol A) \\| \boldsymbol A |^2_F = \text{Tr}(\boldsymbol A \boldsymbol A^H) = \text{Tr}(\boldsymbol A^H \boldsymbol A)</script><p>对于矩阵$ \boldsymbol A \in \mathbb K^{M \times N} $乘$ \boldsymbol B \in \mathbb K^{M \times N} $的内积定义式为：</p><script type="math/tex; mode=display">\begin{aligned}& \langle \boldsymbol A , \boldsymbol B \rangle = \text{Tr}(\boldsymbol A^T \boldsymbol B)= \text{Tr}(\boldsymbol B \boldsymbol A^T)  = \text{Tr}(\boldsymbol B^T \boldsymbol A) = \text{Tr}(\boldsymbol A \boldsymbol B^T)  \\& \langle \boldsymbol A , \boldsymbol B \rangle = \text{Tr}(\boldsymbol A^H \boldsymbol B) = \text{Tr}(\boldsymbol B \boldsymbol A^H )\end{aligned}</script><p>注意到，两个矩阵求内积必须维度是相同的。此外，特别的对于复数域，有：</p><script type="math/tex; mode=display">\begin{aligned}\langle \boldsymbol A , \boldsymbol B \rangle &= \text{Tr}(\boldsymbol A^H \boldsymbol B) = \text{Tr}(\boldsymbol B \boldsymbol A^H ) \\&= \overline{\text{Tr}(\boldsymbol B^H \boldsymbol A)} = \overline{\text{Tr}(\boldsymbol A \boldsymbol B^H)} \\& = \text{Tr}(\overline{\boldsymbol B^H \boldsymbol A}) = \text{Tr}(\overline{\boldsymbol A \boldsymbol B^H})\end{aligned}</script><p>其中，上划线表示取共轭。</p><p>F范数与内积的关系：</p><script type="math/tex; mode=display"> \| \boldsymbol A \|^2_F = \langle \boldsymbol A , \boldsymbol A \rangle</script><h2 id="3-4-矩阵的求导"><a href="#3-4-矩阵的求导" class="headerlink" title="3.4 矩阵的求导"></a>3.4 矩阵的求导</h2><h3 id="3-4-1-纯向量-矩阵求导"><a href="#3-4-1-纯向量-矩阵求导" class="headerlink" title="3.4.1 纯向量/矩阵求导"></a>3.4.1 纯向量/矩阵求导</h3><h4 id="3-4-1-1-实向量求导"><a href="#3-4-1-1-实向量求导" class="headerlink" title="3.4.1.1 实向量求导"></a>3.4.1.1 实向量求导</h4><p>实向量$ \boldsymbol x \in \mathbb R^{N \times 1} $</p><script type="math/tex; mode=display"> \frac{\partial \boldsymbol x}{\partial \boldsymbol x} = \boldsymbol I, \qquad \frac{\partial \boldsymbol {Ax}}{\partial \boldsymbol x} = \boldsymbol A^{\text{T}}, \qquad \frac{\partial \boldsymbol {x}^{\mathrm T} \boldsymbol{A}}{\partial \boldsymbol x} = \boldsymbol A, \qquad \frac{\partial \boldsymbol {x}^{\mathrm T} \boldsymbol{Ax}}{\partial \boldsymbol x} = (\boldsymbol{A} + \boldsymbol {A}^{\mathrm T}) \boldsymbol {x} \overset{若A为对称阵}{=}2\boldsymbol{Ax}</script><h4 id="3-4-1-2-复向量求导"><a href="#3-4-1-2-复向量求导" class="headerlink" title="3.4.1.2 复向量求导"></a>3.4.1.2 复向量求导</h4><p>复向量$ \boldsymbol w \in \mathbb{C}^{N \times 1} $</p><script type="math/tex; mode=display"> \dfrac{\text{d} \boldsymbol w^T}{\text{d} \boldsymbol w} = \boldsymbol I_{N \times N}, \quad \dfrac{\text{d} \boldsymbol w^H}{\text{d} \boldsymbol w^*} = \dfrac{\text{d} (\boldsymbol w^*)^T}{\text{d} \boldsymbol w^*} = \boldsymbol I_{N \times N} , \quad \dfrac{\text{d} \boldsymbol w^H}{\text{d} \boldsymbol w} = \dfrac{\text{d} (\boldsymbol w^*)^T}{\text{d} \boldsymbol w} = \boldsymbol O_{N \times N}, \quad \dfrac{\text{d} \boldsymbol w^T}{\text{d} \boldsymbol w^*} = \boldsymbol O_{N \times N}</script><script type="math/tex; mode=display"> \dfrac{\partial \boldsymbol b^H \boldsymbol w}{\partial \boldsymbol w} = \left(\dfrac{\partial \boldsymbol w^H \boldsymbol b}{\partial \boldsymbol w^*}\right)^* = \boldsymbol b^* \quad \Longrightarrow \quad \dfrac{\partial \boldsymbol w^H \boldsymbol b}{\partial \boldsymbol w^*} = \boldsymbol b</script><script type="math/tex; mode=display">\dfrac{\partial \boldsymbol b^H \boldsymbol w}{\partial \boldsymbol w^*} = \left(\dfrac{\partial \boldsymbol w^H \boldsymbol b}{\partial \boldsymbol w}\right)^* = \boldsymbol 0 \quad \Longrightarrow \quad \dfrac{\partial \boldsymbol w^H \boldsymbol b}{\partial \boldsymbol w} = \boldsymbol 0</script><script type="math/tex; mode=display"> \dfrac{\partial \boldsymbol w^H \boldsymbol R \boldsymbol w}{\partial \boldsymbol w} = \boldsymbol R^T \boldsymbol w^*, \quad \dfrac{\partial \boldsymbol w^H \boldsymbol R \boldsymbol w}{\partial \boldsymbol w^*} = \boldsymbol R \boldsymbol w, \quad \dfrac{\partial \boldsymbol w^H \boldsymbol R \boldsymbol w^*}{\partial \boldsymbol w^*} = (\boldsymbol R +\boldsymbol R^T ) \boldsymbol w</script><h4 id="3-4-1-3-矩阵对矩阵求导"><a href="#3-4-1-3-矩阵对矩阵求导" class="headerlink" title="3.4.1.3 矩阵对矩阵求导"></a>3.4.1.3 矩阵对矩阵求导</h4><script type="math/tex; mode=display"> \frac{\partial \boldsymbol {AXB}}{\partial \boldsymbol X} = \boldsymbol B \otimes \boldsymbol A^{\text{T}}, \quad \boldsymbol A \in \mathbb R^{p \times m}, \boldsymbol X \in \mathbb R^{m \times n}, \boldsymbol B \in \mathbb R^{n \times q}</script><p>其特例如下：</p><script type="math/tex; mode=display"> \frac{\partial \boldsymbol {AX}}{\partial \boldsymbol X} = \boldsymbol I_n \otimes \boldsymbol A^{\text{T}} \quad \quad \frac{\partial \boldsymbol {XB}}{\partial \boldsymbol X} = \boldsymbol B \otimes \boldsymbol I_m</script><p><a href="https://harryliu.blog.csdn.net/article/details/107231685">[机器学习-数学] 矩阵求导(分母布局与分子布局)，以及常用的矩阵求导公式_矩阵求导分子布局和分母布局-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_35812205/article/details/121635738">【机器学习中的矩阵求导】（五）矩阵对矩阵求导-CSDN博客</a></p><h3 id="3-4-2-矩阵迹的求导"><a href="#3-4-2-矩阵迹的求导" class="headerlink" title="3.4.2 矩阵迹的求导"></a>3.4.2 矩阵迹的求导</h3><script type="math/tex; mode=display"> \frac{\partial  \text{Tr}(\boldsymbol {AB})}{\partial \boldsymbol A} = \boldsymbol B^{\text{T}}, \quad \frac{\partial  \text{Tr}(\boldsymbol {AB})}{\partial \boldsymbol B} = \boldsymbol A^{\text{T}}, \quad \frac{\partial  \text{Tr}(\boldsymbol A^H \boldsymbol B)}{\partial \boldsymbol A} = \boldsymbol O_{M \times N}, \quad \frac{\partial  \text{Tr}(\boldsymbol {AB}^H)}{\partial \boldsymbol B} = \boldsymbol O_{N \times M}</script><script type="math/tex; mode=display"> \frac{\partial  \text{Tr}(\boldsymbol {AA}^H)}{\partial \boldsymbol A} =\frac{\partial  \text{Tr}(\boldsymbol A^H \boldsymbol A)}{\partial \boldsymbol A} = \boldsymbol A^*</script><script type="math/tex; mode=display">\frac{\partial  \text{Tr}(\boldsymbol {ABB}^H \boldsymbol A^H)}{\partial \boldsymbol B} = (\boldsymbol A^{\text{H}}\boldsymbol A)^T \boldsymbol B^*</script><h3 id="3-4-3-矩阵行列式的求导"><a href="#3-4-3-矩阵行列式的求导" class="headerlink" title="3.4.3 矩阵行列式的求导"></a>3.4.3 矩阵行列式的求导</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/40899774/1712477869449-965ed83d-ddd2-46a1-85a5-76b40fe9dfca.png" alt=""></p><h3 id="3-4-4-特殊的矩阵求导"><a href="#3-4-4-特殊的矩阵求导" class="headerlink" title="3.4.4 特殊的矩阵求导"></a>3.4.4 特殊的矩阵求导</h3><p>设矩阵$ \boldsymbol A $的元素是$ t $的函数$ \boldsymbol A = [a_{ij}(t)] $，则关于$ t $的导数为：</p><script type="math/tex; mode=display"> \frac{\mathrm{d}|\boldsymbol A|}{\mathrm{d t}}=|\boldsymbol {A} |\mathrm{Tr}\left(\boldsymbol {A}^{-1}\frac{\mathrm{d} \boldsymbol A}{\mathrm{d t}}\right)</script><p>其逆矩阵关于$ t $的导数为：</p><script type="math/tex; mode=display"> \frac{\mathrm{d} \boldsymbol A^{-1}}{\mathrm{dt}} = -\boldsymbol {A}^{-1} \frac{\mathrm{d} \boldsymbol A}{\mathrm{d t}} \boldsymbol {A}^{-1}</script><h3 id="3-4-5-关于矩阵求导的相关资料链接"><a href="#3-4-5-关于矩阵求导的相关资料链接" class="headerlink" title="3.4.5 关于矩阵求导的相关资料链接"></a>3.4.5 关于矩阵求导的相关资料链接</h3><p><a href="https://zhuanlan.zhihu.com/p/24709748">链接1：矩阵求导术：上篇 - 知乎</a>)、<a href="https://zhuanlan.zhihu.com/p/24863977">下篇</a>) —— 本文基本上是这两篇文章内容的重新整理<br><a href="https://www.cnblogs.com/pinard/p/10750718.html">链接2：刘建平Pinard系列博客</a>) —— 这个博客主要用于查缺补漏<br><a href="https://wzbtech.com/tech/matrix-derivatives2.html">链接3：矩阵求导总结 - 个人博客</a>)<br><a href="https://blog.csdn.net/DengTseng/article/details/111059204">链接4：矩阵行列式求导以及矩阵的逆的求导 - CSDN</a>)<br><a href="https://blog.csdn.net/Lyn_S/article/details/110502548">链接5：复数 标量/向量/矩阵 求导_复数矩阵求导-CSDN博客</a>)<br><a href="https://emrys365.github.io/post/xin-hao-chu-li-zhong-de-fu-shu-ju-zhen-qiu-dao-chu-tan/#%E5%A4%8D%E6%A2%AF%E5%BA%A6%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8">链接6：信号处理中的复数矩阵求导 - Speech 101的博客</a>)<br><a href="https://www.zhihu.com/question/43657719/answer/96307949">链接7：复数矩阵求导的转置和共轭转置问题？（MMSE预编码器推导） - null的回答- 知乎</a></p><p>此外，若碰到实在无法理解的求导，也可应借助下面两个工具：</p><p><a href="https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf">工具1：The Matrix Cookbook - 矩阵烹饪书 </a>)<br><a href="https://www.matrixcalculus.org/">工具2：Matrix Calculus —— 超级强大的在线矩阵求导工具</a> </p><h3 id="3-4-6-矩阵哈达玛积运算求导"><a href="#3-4-6-矩阵哈达玛积运算求导" class="headerlink" title="3.4.6 矩阵哈达玛积运算求导"></a>3.4.6 <font style="color:rgb(25, 27, 31);">矩阵哈达玛积运算求导</font></h3><p><a href="https://www.zhihu.com/question/274581093">矩阵哈达玛积运算求导 - 知乎</a></p><h3 id="3-4-7-矢量求导的链式法则"><a href="#3-4-7-矢量求导的链式法则" class="headerlink" title="3.4.7 矢量求导的链式法则"></a>3.4.7 矢量求导的链式法则</h3><p><a href="https://www.cnblogs.com/yifanrensheng/p/12639539.html">【ML-0-3】矩阵求导-链式法则 - 忆凡人生 - 博客园</a><a href="https://blog.csdn.net/qq_45887327/article/details/105218965">矩阵(矢量)求导的链式法则及应用_矢量对矢量求导-CSDN博客</a><br><a href="https://blog.csdn.net/bitcarmanlee/article/details/105668357">小白都能理解的矩阵与向量求导链式法则_矩阵求导链式法则-CSDN博客</a></p><h2 id="3-5-矩阵和向量求导"><a href="#3-5-矩阵和向量求导" class="headerlink" title="3.5 矩阵和向量求导"></a>3.5 矩阵和向量求导</h2><p>输入向量有的地方使用列向量，也有的使用行向量，其实本质上没有什么不同，只是表示方式不一样。一般情况下可能都是使用<strong>分母布局，就是求导结果按照分母列向量的形式排列</strong>(默认向量都是列向量)。</p><h3 id="3-5-1-向量对向量求导"><a href="#3-5-1-向量对向量求导" class="headerlink" title="3.5.1 向量对向量求导"></a>3.5.1 向量对向量求导</h3><script type="math/tex; mode=display">\frac{\partial \boldsymbol x}{\partial \boldsymbol x} = \boldsymbol I, \qquad \frac{\partial \boldsymbol {Ax}}{\partial \boldsymbol x} = \boldsymbol A^{\text{T}}, \qquad \frac{\partial \boldsymbol {x}^{\mathrm T} \boldsymbol{A}}{\partial \boldsymbol x} = \boldsymbol A, \qquad \frac{\partial \boldsymbol {x}^{\mathrm T} \boldsymbol{Ax}}{\partial \boldsymbol x} = (\boldsymbol{A} + \boldsymbol {A}^{\mathrm T}) \boldsymbol {x} \overset{若A为对称阵}{=}2\boldsymbol{Ax}</script><script type="math/tex; mode=display">\frac{\partial}{\partial \boldsymbol A} \mathrm{Tr}(\boldsymbol{BA}) = \boldsymbol B^{\mathrm T}, \qquad \frac{\partial}{\partial \boldsymbol A} \log \mathrm{det} \boldsymbol{A} = (\boldsymbol A^{-1})^{\mathrm T}</script><h3 id="3-5-2-标量对向量求导"><a href="#3-5-2-标量对向量求导" class="headerlink" title="3.5.2 标量对向量求导"></a>3.5.2 标量对向量求导</h3><script type="math/tex; mode=display">\frac{\partial y}{\partial \boldsymbol x} =\left[\begin{array}{c}\dfrac{\partial y}{\partial x_1} \\\vdots \\\dfrac{\partial y}{\partial x_p}\end{array}\right] = \nabla y</script><blockquote><p><strong>参考链接：</strong></p><ul><li><a href="https://blog.csdn.net/daaikuaichuan/article/details/80620518">矩阵求导、几种重要的矩阵及常用的矩阵求导公式</a></li><li><a href="https://zhuanlan.zhihu.com/p/59133643">矩阵, 矩阵迹求导速查 - Gan Pan的文章 - 知乎</a></li><li><a href="https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf">matrixcookbook.pdf</a></li><li><a href="https://www.cnblogs.com/picassooo/p/12926587.html">矩阵微分系列二：矩阵迹求导</a></li></ul></blockquote><script type="math/tex; mode=display">\frac{\partial\left(\boldsymbol{x}^T \boldsymbol{a}\right)}{\partial \boldsymbol{x}}=\frac{\partial\left(\boldsymbol{a}^T \boldsymbol{x}\right)}{\partial \boldsymbol{x}}=\boldsymbol{a}</script><p>其中，<script type="math/tex">a</script>为常数列向量。</p><script type="math/tex; mode=display">\frac{\partial\left(\boldsymbol{x}^T \boldsymbol{x}\right)}{\partial \boldsymbol{x}} = 2\boldsymbol{x}</script><p><a href="https://zhuanlan.zhihu.com/p/273729929">矩阵求导公式的数学推导（矩阵求导——基础篇） - Iterator的文章 - 知乎</a></p><h3 id="3-5-3-迹的求导"><a href="#3-5-3-迹的求导" class="headerlink" title="3.5.3 迹的求导"></a>3.5.3 迹的求导</h3><p>（一）迹的定义</p><p>设矩阵$\boldsymbol A$为方阵，即$\boldsymbol A_{n \times n}$，矩阵$\boldsymbol B$也为方阵$\boldsymbol B_{n \times n}$，则矩阵的迹为：</p><script type="math/tex; mode=display">\mathrm{tr}(\boldsymbol A) = \sum_{i = 1}^n a_{ii} = \sum_{i=1}^n \lambda_n</script><p>（二）性质</p><ul><li><p>$\mathrm{tr}(\boldsymbol {AB}) = \mathrm{tr}(\boldsymbol {BA})$</p></li><li><p>$\mathrm{tr}(\boldsymbol A) = \mathrm{tr}(\boldsymbol A^{\mathrm T})$</p></li><li><p>$\nabla_{\boldsymbol A} \mathrm{tr}(\boldsymbol {AB}) = \boldsymbol A^{\mathrm T}$</p></li><li><p>$\nabla_{\boldsymbol A} \mathrm{tr}(\boldsymbol {ABA}^{\mathrm T}\boldsymbol {C}) = \boldsymbol {CAB} + \boldsymbol C^{\mathrm T} \boldsymbol A \boldsymbol A^{\mathrm T}$</p></li></ul><h2 id="3-6-求方阵的n次方方法总结"><a href="#3-6-求方阵的n次方方法总结" class="headerlink" title="3.6 求方阵的n次方方法总结"></a>3.6 求方阵的n次方方法总结</h2><h3 id="3-6-1-对角化"><a href="#3-6-1-对角化" class="headerlink" title="3.6.1 对角化"></a>3.6.1 对角化</h3><p>若矩阵$\boldsymbol {A}$可以相似对角化后，那么先相似对角化再求$\boldsymbol {A}^n$，这属于常规思路。</p><p>（一）矩阵可对角化的条件(3个)</p><ul><li><p>$n$阶矩阵可对角化的充分必要条件是有个线性无关的特征向量。若 阶矩阵定理2 矩阵 的属于不同特征值的特征向量是线性无关的。</p></li><li><p>若$n$阶矩阵有个互不相同的特征值，则可对角化。</p></li><li><p>$n$阶矩阵可对角化的充分必要条件是：每个特征值对应的特征向量线性无关的最大个数等于该特征值的重数(即的每个特征值对应的齐次线性方程组的基础解系所含向量个数等于该特征值的重数,也即的每个特征子空间的维数等于该特征值的重数）。</p></li></ul><p>（二）矩阵对角化</p><p>设$n×n$矩阵有$n$个线性无关的特征向量$\boldsymbol x_1, \boldsymbol x_2, \cdots, \boldsymbol x_n$，令矩阵$\boldsymbol S = (\boldsymbol x_1, \boldsymbol x_2, \cdots, \boldsymbol x_n)$，则有</p><script type="math/tex; mode=display">\boldsymbol{A S}=\boldsymbol{A}\left(\boldsymbol x_1, \ldots, \boldsymbol x_n\right)=\left(\lambda_1 \boldsymbol x_1, \ldots, \lambda_n \boldsymbol x_n\right)=\left(\boldsymbol x_1, \ldots, \boldsymbol x_n\right)\left(\begin{array}{lll}\lambda_1 & & \\& \ldots & \\& & \lambda_n\end{array}\right)</script><p>即，矩阵可对角化为</p><script type="math/tex; mode=display">\boldsymbol{A S}=\boldsymbol {S \Lambda} \quad \Longrightarrow \quad \boldsymbol S^{-1} \boldsymbol{A S}=\boldsymbol \Lambda</script><h2 id="3-7-矩阵特征值求解"><a href="#3-7-矩阵特征值求解" class="headerlink" title="3.7 矩阵特征值求解"></a>3.7 矩阵特征值求解</h2><h3 id="3-7-1-特征值分解理论基础"><a href="#3-7-1-特征值分解理论基础" class="headerlink" title="3.7.1 特征值分解理论基础"></a>3.7.1 特征值分解理论基础</h3><p>$\boldsymbol A$为$n$阶矩阵，若数$λ$和$n$维非0列向量$\boldsymbol x$满足$\boldsymbol{Ax} = λ \boldsymbol x$，那么数$λ$称为$\boldsymbol A$的特征值，$\boldsymbol x$称为$\boldsymbol A$的对应于特征值λ的特征向量。式$\boldsymbol{Ax} = λ \boldsymbol x$也可写成$(\boldsymbol{A} - λ\boldsymbol{E})\boldsymbol{x} = \boldsymbol 0$，并且$|λ\boldsymbol E - \boldsymbol A|$叫做$\boldsymbol A$的特征多项式。当特征多项式等于0的时候，称为$\boldsymbol A$的特征方程，特征方程是一个齐次线性方程组，求解特征值的过程其实就是求解特征方程的解。</p><h3 id="3-7-2-特征值分解实例计算"><a href="#3-7-2-特征值分解实例计算" class="headerlink" title="3.7.2 特征值分解实例计算"></a>3.7.2 特征值分解实例计算</h3><p><strong>例子1：</strong>计算矩阵$\boldsymbol A = \left(\begin{array}{ccc} 4 &amp; 6 &amp; 0 \\ -3 &amp; -5 &amp; 0 \\ -3 &amp; -6 &amp; 1 \end{array}\right)$的特征值和特征向量</p><p><strong>解：</strong></p><ul><li><strong>STEP 1：</strong>计算$|\boldsymbol A - λ\boldsymbol I|$</li></ul><script type="math/tex; mode=display">|\boldsymbol A - λ\boldsymbol I|=\left|\begin{array}{ccc}4-\lambda & 6 & 0 \\-3 & -5-\lambda & 0 \\-3 & -6 & 1-\lambda\end{array}\right|=(\lambda - 1)^2(\lambda + 2) = 0</script><p>$\quad$解得：$\lambda_1 = -2, \lambda_2 = \lambda_3 = 1$</p><ul><li><strong>STEP 2:</strong> 把每个特征值$\lambda$带入到下方的线性方程组$(\boldsymbol A - \lambda \boldsymbol I) \boldsymbol x = \boldsymbol 0$，求出特征向量</li></ul><p>$\quad$(1) 当$\lambda_{1} = -2$时，解线性方程组：$(\boldsymbol A - (-2)\boldsymbol I)\boldsymbol x = \boldsymbol 0$。</p><script type="math/tex; mode=display">|\boldsymbol{A} + 2 \boldsymbol I|=\left(\begin{array}{ccc}6 & 6 & 0 \\-3 & -3 & 0 \\-3 & -6 & 3\end{array}\right) \stackrel{\text{先变成增广矩阵}}{\Longrightarrow}\left(\begin{array}{cccc}6 & 6 & 0 & 0 \\-3 & -3 & 0 & 0 \\-3 & -6 & 3 & 0\end{array}\right) \stackrel{\text{再初等行变换}}{\Longrightarrow}\left(\begin{array}{cccc}1 & 1 & 0 & 0 \\0 & 0 & 0 & 0 \\0 & -1 & 1 & 0\end{array}\right)</script><p>$\qquad$所以，$\left\{\begin{array}{r} x_{1} + x_{2} = 0 \\ -x_{1} + x_{3} = 0 \end{array}\right.$。可以看到$x_3$为自由变量，因此：</p><p>$\qquad$取$x_3 = 1$，可解得$\left\{\begin{array}{l} x_{1} = -1 \\ x_{2} = 1 \\ x_{3} = 0 \end{array}\right.$，所以$\lambda_1$的特征向量为：$\boldsymbol{p}_1=\left(\begin{array}{c} -1 \\ 1 \\ 1 \end{array}\right)$。</p><p>$\quad$(2) 当$\lambda_{2}=\lambda_{3}=1$时，解线性方程组：$(\boldsymbol A − \boldsymbol I) \boldsymbol x = \boldsymbol 0$</p><script type="math/tex; mode=display">|\boldsymbol{A} - \boldsymbol I| = \left(\begin{array}{ccc}3 & 6 & 0 \\-3 & -6 & 0 \\-3 & -6 & 0\end{array}\right) \stackrel{\text{先变成增广矩阵}}{\Longrightarrow}\left(\begin{array}{cccc}3 & 6 & 0 & 0 \\-3 & -6 & 0 & 0 \\-3 & -6 & 0 & 0\end{array}\right) \stackrel{\text{再初等行变换}}{\Longrightarrow}\left(\begin{array}{cccc}1 & 2 & 0 & 0 \\0 & 0 & 0 & 0 \\0 & 0 & 0 & 0\end{array}\right)</script><p>$\qquad$所以，$x_{1}+2x_{2}=0$。可以看到$x_2$、$x_3$为自由变量，因此：</p><p>$\qquad$先取$x_{2} = 1$、$x_{3} = 0$，可解得$\left\{\begin{array}{l} x_{1} = -2 \\ x_{2} = 1 \\ x_{3} = 0 \end{array}\right.$，所以$\lambda_2$的特征向量为：$\boldsymbol{p}_2 = \left(\begin{array}{c} -2 \\ 1 \\ 0 \end{array}\right)$</p><p>$\qquad$再取$x_{2} = 0$、$x_{3} = 1$，可解得$\left\{\begin{array}{l} x_{1} = 0 \\ x_{2} = 0 \\ x_{3} = 1 \end{array}\right.$，所以$\lambda_3$的特征向量为：$\boldsymbol p_3 = \left(\begin{array}{c} 0 \\ 0 \\ 1 \end{array}\right)$</p><p>综上所述：矩阵$\boldsymbol A$的特征值为$\lambda_{1}=-2，\lambda_{2}=\lambda_{3}=1$，对应的特征向量为：</p><script type="math/tex; mode=display">\boldsymbol{p}_1=\left(\begin{array}{c}-1 \\1 \\1\end{array}\right), \boldsymbol{p}_2=\left(\begin{array}{c}-2 \\1 \\0\end{array}\right), \boldsymbol{p}_3=\left(\begin{array}{l}0 \\0 \\1\end{array}\right)</script><h2 id="3-8-线性变换-基变换"><a href="#3-8-线性变换-基变换" class="headerlink" title="3.8 线性变换/基变换"></a>3.8 线性变换/基变换</h2><p><img src="https://img2022.cnblogs.com/blog/2609360/202211/2609360-20221109000153263-1273562267.jpg" alt=""></p><blockquote><p><strong>参考资料：</strong><br><a href="https://zhuanlan.zhihu.com/p/335306189">3 相似与对角化 - 御手洗洁精的文章 - 知乎</a><br><a href="https://www.douban.com/group/topic/186164511/?_i=7917596e0j3PyT">求线性变换A在基下的矩阵 - 豆瓣</a>：实例计算！<br><a href="https://wenwen.sogou.com/z/q738215063.htm">线性变换在不同基下的矩阵相同吗</a><br><a href="https://www.zhihu.com/question/38313443/answer/77220109">为什么基变换是右乘一个过渡矩阵，而不是左乘一个过渡矩阵? - 王涛的回答 - 知乎</a><br><a href="https://blog.csdn.net/fennudecainiao/article/details/122034178">变换矩阵的左乘与右乘区别 - CSDN</a><br><a href="https://max.book118.com/html/2021/1102/7026134146004033.shtm">基变换与坐标变换 - 原创力文档</a></p></blockquote><h2 id="3-9-正定矩阵"><a href="#3-9-正定矩阵" class="headerlink" title="3.9 正定矩阵"></a>3.9 正定矩阵</h2><h3 id="3-9-1-正定矩阵定义"><a href="#3-9-1-正定矩阵定义" class="headerlink" title="3.9.1 正定矩阵定义"></a>3.9.1 正定矩阵定义</h3><h3 id="3-9-2-正定矩阵性质"><a href="#3-9-2-正定矩阵性质" class="headerlink" title="3.9.2 正定矩阵性质"></a>3.9.2 正定矩阵性质</h3><h3 id="3-9-3-正定矩阵意义"><a href="#3-9-3-正定矩阵意义" class="headerlink" title="3.9.3 正定矩阵意义"></a>3.9.3 正定矩阵意义</h3><p>看论文，看书，总是会发现突然作者来一句，我们可以证明矩阵正定，所以balabala。证明如下…</p><p>往往这个时候，我们会很纳闷，上网一搜，会发现都是证明矩阵正定的各种方法，而很少有人去讨论，到底为什么我们要去证明一个矩阵是正定的，以及矩阵正定到底意味着什么。然后往往看了一大圈回来还是一脸问号。</p><p>那今天本文就非常简单的定性讨论下为什么大家要去证明一个矩阵是正定的，以及正定的意义。</p><p><strong>(一) 可以将正定矩阵理解为矩阵版标量正系数</strong></p><p>在标量中：$y = ax$，当$a&gt;0$时，$y$将与$x$的正负号相同，即如果$x&gt;0$则$y&gt;0$，$x&lt;0$则$y&lt;0$。与$a$相乘不会改变正负号。</p><p>那该性质如何在多维空间中表示呢？这里我们说，简单理解正定矩阵便是符合标量中$a$性质的矩阵。</p><p>也则是$\boldsymbol x^{\mathrm T} \boldsymbol{Ax}&gt;0$的含义。$\boldsymbol A$正定，则其中一个性质是$\boldsymbol A$与$\boldsymbol x$同向夹角小于九十度，所以$\boldsymbol{Ax}$将会与$\boldsymbol x$同向，而不会将$\boldsymbol x$变换到与之完全相反的方向。</p><p>总结：在标量空间中我们有$y=ax$， 我们可以规定$a&gt;0$。而在多维空间中，$\boldsymbol{y=Ax}$, 我们定义矩阵”$\boldsymbol A&gt;0$”的方式便是正定，而矩阵$\boldsymbol A&gt;0$不能这么定义，$\boldsymbol x^{\mathrm T} \boldsymbol{Ax}&gt;0$便是正确的定义方式，其在标量空间中等价于 $a&gt;0$。</p><blockquote><p>正定矩阵意味着对于任意向量的变换后夹角都是锐角，这意味着对于任何的迭代（优化、搜索）过程，迭代前后两个点充分的近。除了优化外，在微分方程迭代计算中，一般状态迭代矩阵满足$M = E + \Delta U$，$\Delta U$是微分矩阵近似得到的差分矩阵，通常都是正定的，这样才能保证变化的微小型，从而确保迭代的稳定性。</p></blockquote><p><strong>(二) 系统(求解的问题)具有全局最小值</strong></p><p>从系统角度看，如果一个矩阵是正定的，那么我们可以简单理解这个系统拥有全局最小值。而绝大部分问题都可以抽象为解决一个优化问题，如果能证明或者将问题用正定矩阵表示，那么从理论上该问题便拥有全局最优解。</p><p>比如如果矩阵二阶导为正定矩阵$\boldsymbol x^{\mathrm T} \boldsymbol{Ax}&gt;0$，则证明其具有局部最小值解，反之$\boldsymbol x^{\mathrm T} \boldsymbol{Ax}&lt;0$，则证明其具有局部最大值解，如果不满足上述两种则证明函数会有鞍点（saddle point）。</p><center><img src="https://pic.imgdb.cn/item/63e5aa4b4757feff3381b9cf.jpg"></center><p>从上图可以看A为最小值，B为鞍点，C为最大值。</p><p>而如果理论上拥有全局最优解，便会给我们使用很多已知成熟的方式去求解最优值的方法，（简单举个例子：比如使用Hessian矩阵求解最优等），这也是机器学习，优化问题最喜欢去研究和解决的情况。</p><p><strong>(三) 数学角度</strong></p><p>从数学视角看，当我们说矩阵正定，相当于对矩阵做了相当强的一种限制，那么在这个限制里就会发现相当多有趣的性质，另外有许多矩阵是正定的，比如协方差矩阵，动力矩阵等等。这就给了数学家研究归纳性质的强烈兴趣。</p><p>上文转载自：<a href="https://zhuanlan.zhihu.com/p/345077039">一个矩阵正定(Possitive definite) 到底能说明什么，能解决什么问题？ - 若辰的文章 - 知乎</a></p><p>其他比较好的文章：<a href="https://zhuanlan.zhihu.com/p/432613136">正定矩阵的几何意义 - Flyingpie的文章 - 知乎</a></p><h2 id="3-10-矩阵行列式的相关性质"><a href="#3-10-矩阵行列式的相关性质" class="headerlink" title="3.10 矩阵行列式的相关性质"></a>3.10 矩阵行列式的相关性质</h2><p><strong>(一) The Matrix Determinant Lemma(MDL)定理</strong></p><script type="math/tex; mode=display">|\boldsymbol{A + BC}| = |\boldsymbol{A}| \cdot |\boldsymbol{I} + \boldsymbol{A}^{-1}\boldsymbol{BC}| = |\boldsymbol{A}| \cdot |\boldsymbol{I} + \boldsymbol{C} \boldsymbol{A}^{-1}\boldsymbol{B}|</script><script type="math/tex; mode=display">|\boldsymbol{A + uv}^{\mathrm T}| = |\boldsymbol{A}| \cdot |1 + \boldsymbol{v}^{\mathrm T}\boldsymbol{A}^{-1} \boldsymbol{u}|</script><p><strong>(二)</strong></p><p>当矩阵$\boldsymbol A(t)$可逆时，有如下：</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}}{\mathrm dt} \log \det \boldsymbol{A}(t) = \dfrac{\mathrm{d}}{\mathrm dt} \log |\boldsymbol{A}(t)| = \mathrm{trace}\left(\boldsymbol{A}^{-1} \dfrac{\mathrm{d}}{\mathrm dt} \boldsymbol{A}(t)\right)</script><h2 id="3-11-矩阵求逆引理-伍德伯里矩阵恒等式"><a href="#3-11-矩阵求逆引理-伍德伯里矩阵恒等式" class="headerlink" title="3.11 矩阵求逆引理/伍德伯里矩阵恒等式"></a>3.11 矩阵求逆引理/伍德伯里矩阵恒等式</h2><script type="math/tex; mode=display"> \left(\boldsymbol A+\boldsymbol U\boldsymbol C\boldsymbol V\right)^{-1}=\boldsymbol A^{-1}-\boldsymbol A^{-1}\boldsymbol U\left(\boldsymbol C^{-1}+\boldsymbol V\boldsymbol A^{-1}\boldsymbol U\right)^{-1}\boldsymbol V\boldsymbol A^{-1}</script><p><a href="https://blog.csdn.net/Louis___Zhang/article/details/103483743">伍德伯里矩阵恒等式（Woodbury matrix identity）-CSDN博客</a></p><h2 id="3-12-矩阵形式的高斯分布-多元高斯分布"><a href="#3-12-矩阵形式的高斯分布-多元高斯分布" class="headerlink" title="3.12 矩阵形式的高斯分布(多元高斯分布)"></a>3.12 矩阵形式的高斯分布(多元高斯分布)</h2><h3 id="3-12-1-一元高斯分布"><a href="#3-12-1-一元高斯分布" class="headerlink" title="3.12.1 一元高斯分布"></a>3.12.1 一元高斯分布</h3><script type="math/tex; mode=display">x \sim \mathcal{CN}(\mu, \sigma^2) \quad  \Longleftrightarrow \quad f(x) = \frac{1}{\sqrt{2\pi}\ \sigma} \exp \left[-\frac{(x - \mu )^2}{2\sigma ^2} \right]</script><p>其中，$ \mu $是分布的的<strong>平均值</strong>，$ \sigma^2 $是<strong>方差</strong>，$ \sigma $是标准差。  </p><h3 id="3-12-2-多元高斯分布"><a href="#3-12-2-多元高斯分布" class="headerlink" title="3.12.2 多元高斯分布"></a>3.12.2 多元高斯分布</h3><p>对于$ M $维的随机向量$ \boldsymbol x = [x_1, x_2, \cdots, x_M]^T $ 多元高斯分布(Multivariate Gaussian Distribution)为：</p><script type="math/tex; mode=display"> \boldsymbol x \sim \mathcal{CN}(\boldsymbol \mu, \boldsymbol \Sigma) \quad \Longleftrightarrow \quad f(\boldsymbol x) = \dfrac{1}{(2\pi)^{M/2}} \dfrac{1}{|\boldsymbol \Sigma|^{1/2}} \exp\left[-\dfrac{(\boldsymbol x - \boldsymbol \mu)^H \boldsymbol  \Sigma^{-1} (\boldsymbol x - \boldsymbol \mu)}{2}\right]</script><p>其中，$ \boldsymbol \mu $是分布的的<strong>均值向量</strong>，$ \boldsymbol \Sigma $是<strong>协方差矩阵</strong>。</p><h3 id="3-12-3-高斯分布的几个性质"><a href="#3-12-3-高斯分布的几个性质" class="headerlink" title="3.12.3 高斯分布的几个性质"></a>3.12.3 高斯分布的几个性质</h3><p>期望与均值的关系：$ \mathbb D(x) = \mathbb E(x^2) - [\mathbb E(x)]^2 $，据此可得$ x^2 $的均值为：</p><script type="math/tex; mode=display"> \mathbb E(x^2) = \mathbb D(x) + [\mathbb E(x)]^2 = \sigma^2 + \mu^2</script><p>拓展到矢量形式：</p><script type="math/tex; mode=display"> \mathbb E(|\boldsymbol x|.^2) = \mathbb D(\boldsymbol x) + [\mathbb E(\boldsymbol x)].^2 = \text{diag}(\boldsymbol \Sigma) + \boldsymbol \mu.^2</script><p>注意，下标$ . $表示按照向量各个元素分别求解。</p><p>进一步拓展到矢量范数，设$ \boldsymbol x \sim \mathcal{CN}(\boldsymbol 0, \boldsymbol \Sigma) $且$ \boldsymbol x $的各分量相互独立，矢量$ \boldsymbol y $和矩阵$ \boldsymbol \Phi $视为常量，则有：</p><script type="math/tex; mode=display"> \mathbb E\left[\|\boldsymbol y - \boldsymbol \Phi \boldsymbol x \|_2^2\right] = \| \boldsymbol y - \boldsymbol \Phi \boldsymbol \mu \|_2^2 + \text{Tr}(\boldsymbol \Sigma \boldsymbol \Phi^H \boldsymbol \Phi)</script><p>高斯函数的一个<strong>积分性质</strong>：$ \displaystyle\int_{\boldsymbol x} \exp\left\{ -(\boldsymbol{Ax+b})^2\right\} \text{ d}{\boldsymbol x} = \text{Const} $；</p><p><a href="https://wuli.wiki/changed/GausPD.html#eq_GausPD_1">高斯分布（正态分布） - 小时百科</a>：高斯积分。</p><h1 id="4-微分方程"><a href="#4-微分方程" class="headerlink" title="4 微分方程"></a>4 微分方程</h1><h2 id="4-1-常数变异法"><a href="#4-1-常数变异法" class="headerlink" title="4.1 常数变异法"></a>4.1 常数变异法</h2><p>求解非齐次线性微分方程的常用方法便是常数变易法，下面，我们首先以一阶非齐次线性微分方程来引入常数变易法。</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}y}{\mathrm{d}x} + P(x)y = Q(x)</script><p>我们联想一阶齐次线性微分方程的解法：</p><script type="math/tex; mode=display">\dfrac{\mathrm{d}y}{\mathrm{d}x} + P(x)y = 0</script><p>分离变量法：</p><ul><li><p>STEP 1：两边同时除以$y$：$\dfrac{\mathrm{d}y}{y} = - P(x)\mathrm{d}x$</p></li><li><p>STEP 2：两边积分得：$\ln y = \displaystyle\int -P(x)\mathrm{d}x + C$</p></li><li><p>STEP 3：求的结果：$y = C\mathrm{e}^{-\int P(x)\mathrm{d}x}$</p></li></ul><p>下面进行常数变异：$C \longrightarrow C(x)$</p><p>接下来就是将$y = C(x)\mathrm{e}^{-\int P(x)\mathrm{d}x}$带回$\dfrac{\mathrm{d}y}{\mathrm{d}x} + P(x)y = Q(x)$，求解出$C(x)$。</p><p>最后，根据初始条件，得到解。</p><h2 id="4-2-拉普拉斯变换"><a href="#4-2-拉普拉斯变换" class="headerlink" title="4.2 拉普拉斯变换"></a>4.2 拉普拉斯变换</h2><p>拉普拉斯变换的导数定理（见拉普拉斯变换）使得我们可以把常系数线性微分方程化为代数方程，不论是否齐次。在常系数齐次线性微分方程中，我们通过把方程写为算子$\dfrac{\mathrm{d}}{\mathrm{d}t}$的代数方程，实现了化微分方程为代数方程，但这种操作对非齐次方程没有用。拉普拉斯变换是另一种化为代数方程的思路，而且不拘泥于齐次与否。</p><h3 id="4-2-1-拉普拉斯变换的导数定理"><a href="#4-2-1-拉普拉斯变换的导数定理" class="headerlink" title="4.2.1 拉普拉斯变换的导数定理"></a>4.2.1 拉普拉斯变换的导数定理</h3><p>设$[0, +\infty]$上有$k$次可导函数$f(t)$，其拉普拉斯变换为:</p><script type="math/tex; mode=display">\mathcal{L}(f(t)) = F(s) = \int_{0}^{\infty} f(t) \mathrm{e}^{-st} \mathrm{d}t</script><p>则有</p><script type="math/tex; mode=display">\mathcal{L}(\dfrac{\mathrm{d}}{\mathrm{d}t} f(t)) = sF(s) - f(0)</script><p>进一步推广的到2阶：</p><script type="math/tex; mode=display">\mathcal{L}(\dfrac{\mathrm{d}^2}{\mathrm{d}t^2} f(t)) = s\mathcal{L}(\dfrac{\mathrm{d}}{\mathrm{d}t} f(t)) - f'(0) = s^2 F(s) - sf(0) - f'(0)</script><h3 id="4-2-2-函数乘以一个指数函数后的拉普拉斯变换"><a href="#4-2-2-函数乘以一个指数函数后的拉普拉斯变换" class="headerlink" title="4.2.2 函数乘以一个指数函数后的拉普拉斯变换"></a>4.2.2 函数乘以一个指数函数后的拉普拉斯变换</h3><p>对于$f(t)$，若设其拉普拉斯变换为$F(s)$，则</p><script type="math/tex; mode=display">\mathcal{L}(\mathrm{e}^{at}f(t)) = F(s-a)</script><h3 id="4-2-3-常见信号的拉氏变换"><a href="#4-2-3-常见信号的拉氏变换" class="headerlink" title="4.2.3 常见信号的拉氏变换"></a>4.2.3 常见信号的拉氏变换</h3><script type="math/tex; mode=display">\mathcal{L}(\delta(t)) =1 \quad \mathcal{L}(1)=\dfrac{1}{s} \quad \mathcal{L}(t^m) =\dfrac{m!}{s^{m+1}} \quad \mathcal{L}(\mathrm{e}^{-at}) =\dfrac{1}{s+a}</script><p><a href="https://wenku.baidu.com/view/68cdb719964bcf84b9d57b84.html?_wkts_=1676792848876">常见Laplace拉氏变换对公式表及反变换法 - 百度文库</a><br><a href="https://www.cnblogs.com/yuankai-ren/p/11622815.html">常用拉氏变换表 - 博客园</a><br><a href="https://zhuanlan.zhihu.com/p/69261474">冲激偶 的 拉普拉斯变换 - 八卦掌的文章 - 知乎</a></p><h3 id="4-2-4-利用拉普拉斯变换求解常系数微分方程"><a href="#4-2-4-利用拉普拉斯变换求解常系数微分方程" class="headerlink" title="4.2.4 利用拉普拉斯变换求解常系数微分方程"></a>4.2.4 利用拉普拉斯变换求解常系数微分方程</h3><p><strong>例子1：</strong> 求方程$x’’’＋3x’’+3x’+x=1$的满足初始条件$x(0) = x’(0) = x’’(0)$的解。</p><p><strong>解：</strong>根据初始条件对方程两端进行Laplace变换得：</p><script type="math/tex; mode=display">(s^3 + 3s^2 + 3s + 1) X(s) = \frac{1}{s} \quad \Longrightarrow \quad X(s) = \frac{s^3 + 3s^2 + 3s + 1}{s}</script><p>把上式分解为：</p><script type="math/tex; mode=display">X(s) = \frac{1}{s} - \frac{1}{s+1} - \frac{1}{(s+1)^2} - \frac{1}{(s+1)^3}</script><p>进行逆Laplace变换得：</p><script type="math/tex; mode=display">x(t) = 1 - \mathrm{e}^{-t} - t\mathrm{e}^{-t} - \frac{1}{2}t^2 \mathrm{e}^{-t}</script><p>参考链接：<a href="https://www.doc88.com/p-2754891093463.html">拉普拉斯变换求解微分方程(组)典型范例</a><br><a href="https://www.cnblogs.com/wreng/p/15306133.html">部分分式展开法</a></p><h1 id="5-物理部分"><a href="#5-物理部分" class="headerlink" title="5 物理部分"></a>5 物理部分</h1><h2 id="5-1-散度旋度定理与几个重要等式"><a href="#5-1-散度旋度定理与几个重要等式" class="headerlink" title="5.1 散度旋度定理与几个重要等式"></a>5.1 散度旋度定理与几个重要等式</h2><h3 id="5-1-1-散度定理"><a href="#5-1-1-散度定理" class="headerlink" title="5.1.1 散度定理"></a>5.1.1 散度定理</h3><div class="table-container"><table><thead><tr><th style="text-align:center">散度</th><th style="text-align:center">旋度</th></tr></thead><tbody><tr><td style="text-align:center">$\text{div }  \vec{F} = \lim\limits_{\Delta V \to 0} \dfrac{ \displaystyle\oint_S \vec{F}\mathrm{d}\vec{S}}{\Delta V}$</td><td style="text-align:center">$\text{rot }  \vec{F} = \lim\limits_{\Delta S \to 0} \dfrac{ \displaystyle\oint_l \vec{F}\mathrm{d}\vec{l}}{\Delta S}$</td></tr></tbody></table></div><h3 id="5-1-2-哈密顿算子"><a href="#5-1-2-哈密顿算子" class="headerlink" title="5.1.2 哈密顿算子"></a>5.1.2 哈密顿算子</h3><script type="math/tex; mode=display">\nabla = \frac{\partial}{\partial x} \vec{e}_x + \frac{\partial}{\partial y} \vec{e}_y + \frac{\partial}{\partial z} \vec{e}_z</script><blockquote><p>哈密顿算子的两个性质：<strong><font color = red>矢量性</font></strong>和<strong><font color = blue>微分性</font></strong></p></blockquote><h3 id="5-1-3-拉普拉斯算子"><a href="#5-1-3-拉普拉斯算子" class="headerlink" title="5.1.3 拉普拉斯算子"></a>5.1.3 拉普拉斯算子</h3><p>(一) 标量拉普拉斯算子——$\nabla^2 \mu$</p><script type="math/tex; mode=display">\nabla^2 u = \nabla \cdot (\nabla u)</script><p>在直角坐标系中的展开形式</p><script type="math/tex; mode=display">\nabla^2 = \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2} + \frac{\partial^2}{\partial z^2}</script><p>(二) 矢量拉普拉斯算子——$\nabla^2 \vec{A}$</p><blockquote><p>简记为“旋了又旋(玄了又玄)”</p></blockquote><script type="math/tex; mode=display">\nabla^2 \vec{A} = \nabla (\nabla \cdot \vec{A}) - \nabla \times (\nabla \times \vec{A})</script><blockquote><p>注意：不要把拉普拉斯算子中的上角标看成是“平方”，因为一是本身的意义就不是平方，二是这就是一个符号。</p></blockquote><h3 id="5-1-4-几个重要算式"><a href="#5-1-4-几个重要算式" class="headerlink" title="5.1.4 几个重要算式"></a>5.1.4 几个重要算式</h3><p>(1) 变换1：$\nabla \cdot (\vec{A} \times \vec{B}) = \vec{B} \cdot (\nabla \times \vec{A}) - \vec{A} \cdot (\nabla \times \vec{B})$</p><p>(2) 变换2：$\nabla \times {u \vec{A}} = u \nabla \times \vec{A} + \nabla u \times \vec{A}$</p><p>(3) 恒等式1：$\nabla \times (\nabla u) \equiv 0$</p><p>(4) 恒等式2：$\nabla \cdot (\nabla \times \vec{A}) \equiv 0$</p><h2 id="5-2-麦克斯韦方程组"><a href="#5-2-麦克斯韦方程组" class="headerlink" title="5.2 麦克斯韦方程组"></a>5.2 麦克斯韦方程组</h2><h1 id="6-信号处理部分"><a href="#6-信号处理部分" class="headerlink" title="6 信号处理部分"></a>6 信号处理部分</h1><h2 id="6-1-常用傅氏变换及其性质"><a href="#6-1-常用傅氏变换及其性质" class="headerlink" title="6.1 常用傅氏变换及其性质"></a>6.1 常用傅氏变换及其性质</h2><p><a href="https://pan.baidu.com/disk/pdfview?path=%2F%E6%88%91%E7%9A%84%E8%B5%84%E6%BA%90%2F9%E3%80%81%E7%8E%8B%E6%88%90%E4%BC%98%E8%80%81%E5%B8%88%E8%B5%84%E6%96%99%2F%E7%8E%8B%E6%88%90%E4%BC%98_%E2%80%9C%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E2%80%9D%E5%B8%B8%E7%94%A8%E5%8F%98%E6%8D%A2%E5%AF%B9%E5%8F%8A%E6%80%A7%E8%B4%A8%E6%A2%B3%E7%90%86.pdf&amp;fsid=961177522762453&amp;size=160247">信号与系统”常用变换对及性质梳理 - 王老师 - 百度网盘</a></p><p><a href="https://www.bilibili.com/video/BV1Fq4y1x7S4">【重要知识】常用信号的傅里叶变换+重要口诀总结 - Bilibili</a></p><p><a href="https://www.cnblogs.com/wreng/tag/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/">信号与系统 - Wreng - 博客园</a>：总结了傅里叶变换和拉普拉斯变换的基础知识。</p><p><a href="https://www.cnblogs.com/vinsonnotes/">Vinson88 - 博客园</a>：这个博主主要记录了几篇(数字)信号处理、通信方向的知识，其中有几篇博客文章正好是我比较疑惑的问题，可以看看该博主的见解。</p><h2 id="6-2-常见信号的运算"><a href="#6-2-常见信号的运算" class="headerlink" title="6.2 常见信号的运算"></a>6.2 常见信号的运算</h2><h3 id="6-2-1-常见的信号空间"><a href="#6-2-1-常见的信号空间" class="headerlink" title="6.2.1 常见的信号空间"></a>6.2.1 常见的信号空间</h3><p><strong>(一) 希尔伯特空间</strong></p><p>希尔伯特空间(Hilbert space)指的其实就是完备的内积空间，即希尔伯特空间是一种特殊的内积空间，其特殊性就体现在其完备性上，因为一个内积空间不一定是完备空间。而非完备的内积空间又称为准希尔伯特空间(pre-Hilbert space)。</p><p>那么，这其中包含有两个概念，即：“完备空间”和“内积空间”，两者的交集即为“完备的内积空间”，下面分开进行解释。</p><p><strong>(二) 完备空间</strong></p><p>在数学分析中，完备空间又称完备度量空间或称柯西空间(Cauchy space)。如果一个度量空间$\mathbb M$中的所有柯西序列都收敛在该空间$\mathbb M$中的一点，则称该空间$\mathbb M$为完备空间。</p><p>这个定义中又涉及到两个的概念，即“度量空间(Metric space)”和“柯西序列(Cauchy sequence)”</p><ul><li><strong>度量空间</strong></li></ul><p>在数学中，度量空间是个具有距离函数的集合，该距离函数定义集合内所有元素间之距离。此距离函数被称为集合上的度量。度量空间中最符合人们对于现实直观理解的是三维欧几里得空间(Euclidean space)。</p><p>这里的“距离”是一个抽象概念，不仅仅指两点间的直线距离，还包括向量距离、函数距离、曲面距离等。定义为：</p><p>设$\mathbb W$是一个非空集合，对中任意两点$x$和$y$，在度量$d$的作用下，有一实数$d(x, y)$与该两点对应且满足：</p><p>(1) 正定性：$d(x,y) \geq 0$，当且仅当$x=y$时取等号；<br>(2) 对称性：$d(x,y) = d(y,x)$；<br>(3) 三角不等性：$d(x,y) \leq d(x,z) + d(y, z)$；</p><p>那么就称$d(x,y)$为$\mathbb W$中的一个距离（度量），称$\mathbb W$为一个对于度量$d$而言的度量空间。</p><ul><li><strong>柯西序列</strong></li></ul><p>在数学中，柯西序列、柯西列、柯西数列或基本列是指这样一个数列，它的元素随着序数的增加而愈发靠近。任何收敛数列必然是柯西列，任何柯西列必然是有界序列。</p><p><strong>完备性</strong></p><p>前面提到“如果一个度量空间$\mathbb M$中的所有柯西序列都收敛在该空间$\mathbb M$中的一点，则称该空间$\mathbb M$为完备空间。”可以把实数和有理数作为具体的例子。由实数$\mathbb R$定义的序列在通常定义的距离意义下是完备的。而由有理数$\mathbb Q$定义的序列在通常定义的距离意义下则不是完备的。</p><p>例如一个由有理数构成的序列：$x_0 = 1, x_{n+1} = \dfrac{1}{2}\left(x_n + \dfrac{x_n}{2}\right)$，也即：$\left(1, \dfrac{3}{2}, \dfrac{17}{12}, \cdots \right)$，可以用巴比伦方法证明其结果收敛于$\sqrt{2} \notin \mathbb Q$</p><blockquote><p>说了这么多，用一句通俗但不严谨的话来表达就是：通常见到的空间中，<strong>实数空间是完备空间</strong>。</p></blockquote><center><img src="https://pic.imgdb.cn/item/648efcb61ddac507cce826d9.png" style="zoom:30%" /></center><p><strong>(三) 内积空间</strong></p><p>指的是添加了一个“运算方法”(或称“结构”)的向量空间（或称为“线性空间”，两者同义），这个新添加的运算方法即“内积（Inner product）”又称“标量积（Scalar product）”或称“点积（Dot product）”。内积将一对向量与一个纯量连接起来，允许我们严格地谈论向量的“夹角”和“长度”，并进一步谈论向量的正交性。</p><p>这其中又涉及了“向量空间（Vector space）”的概念。 </p><p>而且，内积空间具有基于空间本身的内积所自然定义的范数，$| x | = \sqrt{\langle x, x \rangle}$，且其满足平行四边形定理，也就是说内积可以诱导一个范数，所以内积空间一定是“赋范空间”。这其中又涉及了“赋范空间（Normed vector space）”的概念。 一步一步来，先说说向量空间（或称“线性空间”，两者同义）。</p><ul><li><strong>向量空间</strong></li></ul><p>一般向量空间的定义如下：定义在一个域$\mathbb F$(例如，实数域$\mathbb R$、复数域$\mathbb C$)上的向量空间$\mathbb V$是由向量组成的一个集合，并赋予该集合向量与向量之间的加法：$\mathbb{V} + \mathbb{V} \to \mathbb V$ ；和标量与向量之间乘法：$\mathbb{F} \times \mathbb{V} \to\mathbb{V}$ 。向量空间中向量加法与标量乘法运算满足基本的8条性质(自行去网上检索，这里不再列出)。</p><p>8条性质中并不包含向量与向量之间的乘法。而这也是正是内积作为区别内积空间与一般向量空间的附加条件的原因。这也是为什么内积空间包含三个运算：向量与向量之间的加法，标量与向量之间的乘法，以及向量与向量之间的乘法。 在了解了向量空间的基础上，再反过头来，补充一下赋范空间的概念和这几个空间之间的关系。由于赋范空间定义在向量空间的基础之上，所以也称为线性赋范空间，简称赋范空间。注意，前面提到向量空间就是线性空间，两者同义。</p><ul><li><strong>(线性)赋范空间</strong></li></ul><p><strong>范数</strong>常常被用来度量某个向量空间(或矩阵)中的每个向量的长度或大小。其定义是：设$\mathbb V$是定义在一个域$\mathbb F$上的向量空间，函数$| \cdot |$作用于$\mathbb V$，且满足条件：</p><p>(1) 正定性：$\forall x \in \mathbb V, | x | \geq 0$，当且仅当$x = 0$时取等号；<br>(2) 齐次性：$\forall x \in \mathbb V, \alpha \in \mathbb F$，有$| \alpha x | = |\alpha| | x |$；<br>(3) 三角不等式：$\forall x,y \in \mathbb V$，有$| x+y | \leq |x| + |y|$；</p><p>称$| \cdot |$是$\mathbb V$上的一个范数，定义了范数$| \cdot |$的向量空间$\mathbb V$称为(线性)赋范空间。通过将赋范空间和上面的度量空间相比较，可知“范数”与“距离”之间的区别有：</p><p>① 距离（或称“度量”）是定义在任意非空集合上的，而范数则定义在向量空间上；<br>② 在向量空间中，范数可以诱导距离（或称“度量”），反之不成立，这也意味着赋范空间一定属于度量空间；<br>③ 范数的“齐次性”表明范数可以看做是强化后的距离概念。</p><center><img src="https://img2023.cnblogs.com/blog/2609360/202306/2609360-20230618212403100-533483687.png" style="zoom:50%" /></center><p><strong>(四) 总结</strong></p><p>说了这么多感觉有点乱，所以再总结一下各个空间之间的关系：</p><ul><li><p>范数运算 + 向量空间 = (线性)赋范空间</p></li><li><p>(线性)赋范空间 + 内积运算 = 内积空间</p></li><li><p>(线性)赋范空间 + 完备性 = 巴拿赫空间</p></li><li><p>内积空间 + 完备性 + 有限维 = 欧几里得空间</p></li><li><p>内积空间 + 完备性 = 希尔伯特空间</p></li></ul><center><img src="https://img2023.cnblogs.com/blog/2609360/202306/2609360-20230618222531501-352705110.png" style="zoom:50%" /></center><blockquote><p>最后补充一句：希尔伯特空间(Hilbert space)是有限维欧几里得空间(Euclidean space)的一个推广，使之不局限于<strong>实数的情形和有限的维数</strong>，但又不失完备性（不像一般的非欧几里得空间那样破坏了完备性）。</p><p>而且从上面的关系可知，希尔伯特空间可以看做是增加了内积运算的巴拿赫空间(Banach space)。</p></blockquote><center><img src="https://img2023.cnblogs.com/blog/2609360/202306/2609360-20230618225956092-420556036.png" style="zoom:60%" /></center><p>参考链接1：<a href="https://www.zhihu.com/question/332144499/answer/731866608">希尔伯特空间、内积空间的定义有什么关系和区别？ - 李狗嗨的回答 - 知乎</a><br>参考链接2：<a href="https://www.zhihu.com/question/19967778/answer/184073198">如何理解希尔伯特空间？ - TimXP的回答 - 知乎</a><br>参考链接3：<a href="https://zhuanlan.zhihu.com/p/113197869">希尔伯特空间 - yang的文章 - 知乎</a><br>参考链接4：<a href="https://www.zhihu.com/question/306963432/answer/568946759">向量的夹角为什么可以用内积来算，是巧合吗？ - 川南雁的回答 - 知乎</a></p><h3 id="6-2-2-内积"><a href="#6-2-2-内积" class="headerlink" title="6.2.2 内积"></a>6.2.2 内积</h3><p>任意信号$x(t)$与$y(t)$的内积定义为：</p><script type="math/tex; mode=display">\langle x(t), y(t)\rangle = \int_{-\infty}^{\infty}x(t)\overline{y(t)}\mathrm{d}t</script><p>特别的，对于实信号$x(t)$与$y(t)$的内积定义为：</p><script type="math/tex; mode=display">\langle x(t), y(t)\rangle = \int_{-\infty}^{\infty}x(t)y(t)\mathrm{d}t</script><table><td style="word-wrap:break-word;word-break:break-all;" width="100px"; bgcolor=AliceBlue><font size="3"><strong>时域内积等于频域内积：</strong>设信号$x(t)$与$y(t)$的傅氏变换为$X(f)$和$Y(f)$，则有：</br>$$\int_{-\infty}^{\infty}x(t)\overline{y(t)}\mathrm{d}t = \int_{-\infty}^{\infty}X(f)\overline{Y(f)}\mathrm{d}f$$如果两个信号在时域正交，那么它们在频域也是正交的。</font></td></table><table><td style="word-wrap:break-word;word-break:break-all;" width="100px"; bgcolor=LightPink><font size="3"><strong>信号能量与内积的关系：</strong>信号能量是信号与其自身的内积：</br>$$E_x = \int_{-\infty}^{\infty}|x(t)|^2\mathrm{d}t = \int_{-\infty}^{\infty}x(t)\overline{x(t)}\mathrm{d}t$$</font></td></table><table><td style="word-wrap:break-word;word-break:break-all;" width="100px"; bgcolor=LightGreen><font size="3"><strong>互能量与内积的关系：</strong>两个信号的内积也称为互能量：</br>$$E_{xy} = \int_{-\infty}^{\infty}x(t)\overline{y(t)}\mathrm{d}t \qquad E_{yx} = \int_{-\infty}^{\infty}y(t)\overline{x(t)}\mathrm{d}t$$此时，有：$$E_{xy} = \overline{E_{yx}}$$特别的，对于实信号：$$E_{xy} = E_{yx}$$</font></td></table><h3 id="6-2-3-相关函数"><a href="#6-2-3-相关函数" class="headerlink" title="6.2.3 相关函数"></a>6.2.3 相关函数</h3><p>能量信号$x(t)$与$y(t)$的互相关函数：</p><script type="math/tex; mode=display">R_{xy}(\tau) = \int_{-\infty}^{\infty}x(t)\overline{y(t+\tau)}\mathrm{d}t \qquad R_{yx}(\tau) = \int_{-\infty}^{\infty}y(t)\overline{x(t+\tau)}\mathrm{d}t</script><p>特别的，对于实信号的互相关函数：</p><script type="math/tex; mode=display">R_{xy}(\tau) = \int_{-\infty}^{\infty}x(t)y(t+\tau)\mathrm{d}t \qquad R_{yx}(\tau) = \int_{-\infty}^{\infty}y(t)x(t+\tau)\mathrm{d}t</script><table><td style="word-wrap:break-word;word-break:break-all;" width="100px"; bgcolor=AntiqueWhite><font size="3"><strong>互相关函数的共轭对称性：</strong>$$R_{xy}(\tau) = \overline{R_{yx}(-\tau)}$$<strong>实信号互相关函数的对称性：</strong>$$R_{xy}(\tau) = R_{yx}(-\tau)$$</font></td></table><p>能量信号$x(t)$的自相关函数：</p><script type="math/tex; mode=display">R_{x}(\tau) = \int_{-\infty}^{\infty}x(t)\overline{x(t+\tau)}\mathrm{d}t</script><p>特别的，对于实信号的自相关函数：</p><script type="math/tex; mode=display">R_{x}(\tau) = \int_{-\infty}^{\infty}x(t)x(t+\tau)\mathrm{d}t</script><table><td style="word-wrap:break-word;word-break:break-all;" width="100px"; bgcolor=HoneyDew><font size="3"><strong>自相关函数的共轭偶对称性：</strong>$$R_{x}(\tau) = \overline{R_{x}(-\tau)}$$<strong>实信号的自相关函数是偶函数：</strong>$$R_{x}(\tau) = R_{y}(-\tau)$$</font></td></table><table><td scroll="no"; style="word-wrap:break-word;word-break:break-all;" width="100px"; bgcolor=Aqua><font size="3"><strong>自相关函数和能量的联系：</strong>$x(t)$的能量是自相关函数在$\tau=0$处的值$$E_x = R_{x}(0) = \int_{-\infty}^{\infty}x(t)\overline{x(t+0)}\mathrm{d}t = \int_{-\infty}^{\infty}|x(t)|^2\mathrm{d}t$$</font></td></table><blockquote><p>参考链接：<a href="https://www.jianshu.com/p/33434078662c/">总结一下通信原理的前置知识 - 萍水间人 - 博客园</a></p></blockquote><h3 id="6-2-4-卷积"><a href="#6-2-4-卷积" class="headerlink" title="6.2.4 卷积"></a>6.2.4 卷积</h3><p>卷积的本质是两个序列/函数的平移，加权叠加。</p><p>对于函数$x(t)$和$h(t)$，卷积的结果是：</p><script type="math/tex; mode=display">y(t) = x(t)\otimes h(t) = \int_{-\infty}^{\infty} x(\tau)h(t-\tau)\mathrm{d}\tau = \int_{-\infty}^{\infty} x(t-\tau)h(\tau)\mathrm{d}\tau</script><table><td style="overflow-x:hidden; word-wrap:break-word;word-break:break-all;" width="100px"; bgcolor=AntiqueWhite><font size="3"><strong>冲激函数$\delta(t)$的性质和卷积特性：</strong></br>(1) 抽样性/筛选性$$f(t)\delta(t) = f(0)\delta(t) \qquad \int_{-\infty}^{\infty}f(t)\delta(t) \mathrm{d}t = f(0)$$对于位移情况：$$f(t-t_0)\delta(t) = f(-t_0)\delta(t) \qquad \int_{-\infty}^{\infty}f(t)\delta(t-t_0) \mathrm{d}t = f(t_0)$$(2) 奇偶性$$\delta(t) = \delta(-t)$$(3) 尺度变换$$\delta(at) = \frac{1}{|a|}\delta(t)$$(4) 卷积性$$f(t) = f(t)\otimes \delta(t) = \int_{-\infty}^{\infty} x(\tau)\delta(t-\tau)\mathrm{d}\tau$$</font></td></table><h2 id="6-3-噪声的白化"><a href="#6-3-噪声的白化" class="headerlink" title="6.3 噪声的白化"></a>6.3 噪声的白化</h2><p>噪声白化是指对噪声数据进行去相关，且噪声协方差被单位化的过程。若$\boldsymbol a$为$m×1$维随机向量序列(均值=0)，则其协方差矩阵可表示为一个$m×m$维的矩阵$\boldsymbol C_a$，如果该协方差矩阵$\boldsymbol C_a$非奇异且不为单位矩阵，则称随机向量$\boldsymbol a$为有色(或非白)随机向量。</p><p>令协方差矩阵特征值分解为：</p><script type="math/tex; mode=display">\boldsymbol C_a = \boldsymbol{VDV}^{\mathrm T}</script><p>记：</p><script type="math/tex; mode=display">\boldsymbol W = \boldsymbol{VD}^{-\frac{1}{2}}\boldsymbol{V}^{\mathrm T} = \boldsymbol C_a^{-1/2}</script><p>此时，令变换：</p><script type="math/tex; mode=display">\boldsymbol b = \boldsymbol{Wa} = \boldsymbol C_a^{-1/2} \boldsymbol{a}</script><p>则$\boldsymbol b$的协方差矩阵为单位矩阵$\boldsymbol I$，即随机向量$\boldsymbol b$是标准白色随机向量，换言之，有色的随机向量$\boldsymbol a$经过线性变换后变成了白色随机向量。一般将线性变换矩阵$\boldsymbol W$称为随机向量$\boldsymbol a$的<font color=blue><strong>白化矩阵</strong></font>。</p><p>通过研究发现，对于某一随机变量，能使其进行白化的变换矩阵并不是唯一存在的例如上述分析的$\boldsymbol W$矩阵和通常<strong>MNF变换(最小噪声分离变换)</strong>中使用的白化矩阵$\boldsymbol F^{\mathrm T}$都可以达到使$\boldsymbol a$白化的效果。进一步的研究显示，当采用不同的白化矩阵所得的白化结果$\boldsymbol b$并不一样。</p><p>虽然变换矩阵$\boldsymbol W$和$\boldsymbol F^{\mathrm T}$都可以使随机变量$\boldsymbol a$“白化”，但白化矩阵$\boldsymbol W$的变换结果并不改变变量$\boldsymbol a$原有的分布特征，而白化矩阵$\boldsymbol F^{\mathrm T}$则不论变量$\boldsymbol a$原有的分布特征如何，变化后均呈<strong>高斯分布</strong>。</p><blockquote><p>张颢老师说过：在很多情况下，噪声是不是白的不本质，因为可以通过白化矩阵转换为“白的”。</p></blockquote><p>参考资料：<a href="https://d.wanfangdata.com.cn/periodical/gtzyyg201702009">基于噪声白化的高光谱数据子空间维数算法 - 万方</a><br>参考资料：<a href="https://blog.csdn.net/jiumi123/article/details/40423773">数据白化 - CSDN</a><br>参考资料：<a href="https://blog.csdn.net/weixin_42528089/article/details/104044129">白噪声和有色噪声 - CSDN</a><br>参考资料：<a href="https://blog.csdn.net/qq_43045275/article/details/106533453">随机信号处理笔记之色噪声及白化滤波器 - CSDN</a></p><h2 id="6-4-分贝-dB"><a href="#6-4-分贝-dB" class="headerlink" title="6.4 分贝(dB)"></a>6.4 分贝(dB)</h2><h3 id="6-4-1-分贝的基本定义"><a href="#6-4-1-分贝的基本定义" class="headerlink" title="6.4.1 分贝的基本定义"></a>6.4.1 分贝的基本定义</h3><p>分贝 $\text{dB}$ 定义为两个数值的对数比率，这两个数值分别是测量值和参考值(也称为基准值)，存在两种定义情况。 </p><ul><li>一种为<strong>功率</strong>之比： </li></ul><script type="math/tex; mode=display">1 \text{dB} = 10 \log_{10} \left(\dfrac{P}{P_0} \right)</script><ul><li>一种为<strong>幅值</strong>之比： </li></ul><script type="math/tex; mode=display">1 \text{dB} = 10 \log_{10} \left(\dfrac{U}{U_0} \right)^2 = 20 \log_{10} \left(\dfrac{U}{U_0} \right)</script><p>其中，$P_0$和$U_0$为功率和幅值的参考值。</p><blockquote><p>使用功率之比公式进行计算的例子如：声功率($\mathrm{W}$)，声强($\mathrm{W/m}^2$)，电功率，电强等。</p><p>使用幅值之比公式进行例子如：声压($\mathrm{Pa}$)，电压($\mathrm{V}$)，加速度($\mathrm{m/s}^2$)，温度等。 </p></blockquote><p>分贝值完全依赖于测量值与参考值之比，因此计算时选择合适的参考值很关键。 <font color=green><strong>没有特殊要求时，参考值通常为1</strong></font>。 </p><blockquote><p>通常，参考功率被定义为标准参考值，如1毫瓦($\text{mW}$)或1瓦($\text{W}$)，具体取决于特定的应用或标准。 </p></blockquote><h3 id="6-4-2-分贝的性质"><a href="#6-4-2-分贝的性质" class="headerlink" title="6.4.2 分贝的性质"></a>6.4.2 分贝的性质</h3><p>贝尔最初是用来表示电信功率讯号的增益和衰减的单位，1个贝尔的增益是以功率在放大后与放大前的比值。所以，电压增益的分贝表达式是从功率的角度来考虑的，即<strong>分贝应该理解为功率的增大或衰减情况</strong>。 </p><ul><li>当用对数 $\text{dB}$ 表达增益随频率变化的曲线时，可大大扩大线性增益变化的区间。例如：人耳可听的声压幅值波动范围为$2×10^{-5} \mathrm{Pa} \sim 20\mathrm{Pa}$，而用幅值 $\text{dB}$ 表示时对应的 $\text{dB}$ 数值仅仅为$0 \sim 120 \text{ dB}$。</li><li>计算多级放大的总增益时，可将乘法化为加法进行运算。</li><li>$\text{dB}$ 值可正可负。<strong>正值表示增大，负值表示衰减</strong>。若$\dfrac{X}{X_0}&lt;1$，则 $\text{dB}$ 值为负值。也就是说测量值大于参考值的为正，小于参考值的为负。</li><li>幅值比互为倒数时， $\text{dB}$ 值互为正负。这是因为：</li></ul><script type="math/tex; mode=display">20 \log_{10}\left(\dfrac{X}{X_0}\right) = 20 \log_{10}\left(\dfrac{1}{X_0/X}\right) = -20 \log_{10}\left(\dfrac{X_0}{X}\right)</script><ul><li>$\text{dB}$ 值与线性幅值比的关系如下表所示</li></ul><center><img src="https://pic2.imgdb.cn/item/646108660d2dde5777ad71d6.jpg"></center><blockquote><p>红色字体表示的是几个比较重要的 $\text{dB}$ 值，我们应该要记住，因为我们经常要用到它们。像增大 $+6\text{ dB}$ 表示线性幅值增大一倍。 </p></blockquote><h3 id="6-4-3-特别说明-3-text-dB-和-0-text-dB"><a href="#6-4-3-特别说明-3-text-dB-和-0-text-dB" class="headerlink" title="6.4.3 特别说明$-3\text{ dB }$和$0 \text{ dB}$"></a>6.4.3 特别说明$-3\text{ dB }$和$0 \text{ dB}$</h3><p>通过上表易知$-3\text{ dB }$对应的幅值比为$0.707$，即$\dfrac{\sqrt 2}{2}$倍，也就是说幅值是原来的$\dfrac{\sqrt 2}{2}$倍。若按功率比来计算，则功率比为$\dfrac{1}{2}$，也就是原功率的一半，故$-3\text{ dB }$称为<font color=red>“<strong>半功率点</strong>”或者“<strong>截止频率点</strong>”</font>。这时功率是正常时的一半，电压或电流是正常时的$0.707$。在电声系统中，$\pm 3 \text{ dB}$ 的差别被认为不会影响总特性。所以各种设备指标，如频率范围，输出电平等，不加说明的话都可能有$\pm 3 \text{ dB}$的出入。</p><p>$0 \text{ dB}$ 表示输出与输入或两个比较信号<strong>一样大</strong>。分贝是一个相对大小的量，没有绝对的量值。 </p><h3 id="6-4-4-text-dB-、-text-dBm-、-text-dBc-之间的区别"><a href="#6-4-4-text-dB-、-text-dBm-、-text-dBc-之间的区别" class="headerlink" title="6.4.4 $\text{dB}$、$\text{dBm}$、$\text{dBc}$之间的区别"></a>6.4.4 $\text{dB}$、$\text{dBm}$、$\text{dBc}$之间的区别</h3><p><strong>(1) dBm</strong></p><p>$\text{dBm}$ 是一个考征功率<strong>绝对值</strong>的值，计算公式为：</p><script type="math/tex; mode=display">10 \log_{10} \dfrac{P}{1 \text{ mW}}</script><p>其中，$P$代表信号的功率。</p><p>[例1] 如果发射功率$P$为$1 \text{ mw}$，折算为 $\text{dBm}$ 后为 $ 0 \text{ dBm}$ 。</p><p>[例2] $40 \text{ W}$的功率，$\text{dBm}$ 折算值：$10\log_{10} \dfrac{40\text{ W}}{1\text{ mw}} =10 \log_{10}(40000) = 46 \text{ dBm}$。</p><p><strong>(2) dBi和dBd</strong></p><p>$\text{dBi}$ 和 $\text{dBd}$ 是考征增益的值(功率增益)，两者都是一个<strong>相对值</strong>， 但参考基准不一样。$\text{dBi}$ 的参考基准为全方向性天线，$\text{dBd}$ 的参考基准为偶极子，故两者略有不同。一般认为表示同一增益，用 $\text{dBi}$ 表示比用 $\text{ dBd}$ 表示要大 $2. 15$。 </p><p>[例3] $0 \text{ dBd} = 2.15 \text{ dBi}$。</p><p>[例4] 一面增益为$16 \text{ dBd}$ 的天线，其增益折算成单位为 $\text{dBi}$ 时，为 $18.15 \text{ dBi}$ (一般忽略小数位，为 $18\text{ dBi}$)。</p><p><strong>(3) dB</strong></p><p>$\text{dB}$ 表示<strong>相对值</strong>。在计算信号$A$的功率$P_A$大于或小于信号$B$的功率$P_B$多少 $\text{dB}$ 时，可按公式 $10 \log_{10} \dfrac{P_A}{P_B}$ 计算。 </p><p>[例5] 甲功率比乙功率大一倍，则$10 \log_{10} \dfrac{P_{甲}}{P_{乙}} = 10 \log_{10} 2 = 3\text{ dB}$。也就是说甲的功率比乙的功率大$3\text{ dB}$。</p><p>[例6] 如果信号$A$的功率为$46 \text{ dBm}$，信号$B$的功率为$40 \text{ dBm}$，则可以说$A$比$B$大$6 \text{ dB}$。</p><p>[例7] 如果$A$天线为$12\text{ dBd}$，$B$天线为$14 \text{ dBd}$，则可以说A比B小$2 \text{ dB}$。  </p><p><strong>(4) dBc</strong></p><p>有时也会看到 $\text{dBc}$，它也是一个表示<strong>功率相对值</strong>的单位，与 $\text{dB}$ 的计算方法完全一样。一般来说，$\text{dBc}$ 是相对于载波 (Carrier) 功率而言，在许多情况下，用来度量与载波功率的相对值，如用来度量干扰(同频干扰、互调干扰、交调干扰、带外干扰等)以及耦合、杂散等的相对量值。在采用 $\text{dBc}$ 的地方，原则上也可以使用 $\text{dB}$ 替代。</p><h3 id="6-4-5-分贝的基本计算"><a href="#6-4-5-分贝的基本计算" class="headerlink" title="6.4.5 分贝的基本计算"></a>6.4.5 分贝的基本计算</h3><p>$\text{dB}$ 的意义其实再简单不过了，就是把一个很大(后面跟一长串$0$的)或者很小(前面有一长串$0$的)的数比较简短地表示出来。如(此处以功率为例)： </p><script type="math/tex; mode=display">P = 100000 = 10^5 \quad \Longrightarrow \quad P(\text{dB}) = 10\log_{10}(P) \text{dB}= 50 \text{dB}</script><script type="math/tex; mode=display">P = 0.00000001 = 10^{-8} \quad \Longrightarrow \quad  P(\text{dB}) = 10\log_{10}(P) \text{dB}= -80 \text{dB}</script><p>$\text{dB}$ 的引入是为了将乘除关系变为加减关系，更便于工程运算。因此一般来讲，在工程中 $\text{dB}$ 之间只有加减，没有乘除。  </p><p>一般来讲，在工程中，$\text{dB}$ 和 $\text{dB}$ 之间只有加减，没有乘除，而用得最多的是减法。 </p><p>$\text{dBm}$ 减 $\text{dBm}$ 是两个功率<strong>相除</strong>，信号功率和噪声功率相除就是信噪比(SNR)。比如：</p><script type="math/tex; mode=display">30 \text{dBm} - 0 \text{dBm} = \dfrac{1000 \text{mW}}{1 \text{mW}} = 1000 = 30dB</script><p>$\text{dBm}$ 加 $\text{dBm}$ 实际上是两个功率<strong>相乘</strong>，没有实际的物理意义。 </p><p>那么 $\text{dB}$ 可以任意相加吗？怎么相加？如$70\text{ dB } + 60 \text{ dB }$等于$130 \text{ dB }$吗？在信号处理中，如果要将两个信号的分贝相加，可以使用以下公式进行计算(以功率计算公式为例)：  </p><script type="math/tex; mode=display">\text{Ltotal} = 10 * \log_{10}(10^{L1/10} + 10^{L2/10})</script><p>对于上面提到的例子，将$70\text{ dB } + 60 \text{ dB }$，可以进行如下计算： </p><script type="math/tex; mode=display">\begin{aligned}\text{Ltotal} & = 10 * \log_{10}(10^{70/10} + 10^{60/10}) \\&= 10 * \log_{10}(10^7 + 10^6) \\&= 10 * \log_{10}(11000000) \\&≈ 10 * 7.041 \\&≈ 70.41 \text{ dB}\end{aligned}</script><p>可以看到得到的结果为$70.41 \text{ dB}$，<strong>记住不是$130\text{ dB}$</strong>。</p><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/22821588">什么是分贝dB？ - linmue-谭祥军的文章 - 知乎</a><br>参考链接：<a href="https://www.eet-china.com/mp/a122565.html">好问题：-3dB、0.707、截止频率，三者啥关系？- 芯语 - 面包板</a><br>参考链接：<a href="http://www.bias-t.com/m/news/industry/54682913393.html">dB、dBm、dBc的解释说明</a><br>参考链接： <a href="https://blog.csdn.net/u013346007/article/details/51607004">【Get深一度】信号处理（三）——3db带宽 - CSDN</a><br>参考链接： <a href="https://xueying.blog.csdn.net/article/details/109206208">带宽、特征频率、截止频率、-3dB什么意思 - CSDN</a><br>参考链接：<a href="https://blog.csdn.net/dddxxxx/article/details/53673836">分贝（dB）的概念辨析- CSDN</a><br>参考链接：<a href="https://www.espressif.com/zh-hans/media/blog/%E5%A2%9E%E7%9B%8A%E6%AF%94%E5%80%BC-db-%E4%BB%A5%E5%8F%8A-dbw-dbmv-%E7%AD%89%E4%B9%8B%E8%AF%A6%E8%A7%A3">增益比值 dB 以及 dBw-dBmv 等之详解 - 乐鑫科技</a></p><h2 id="6-5-自由度-Degrees-of-Freedom-DoF"><a href="#6-5-自由度-Degrees-of-Freedom-DoF" class="headerlink" title="6.5 自由度(Degrees of Freedom, DoF)"></a>6.5 自由度(Degrees of Freedom, DoF)</h2><h3 id="6-5-1-统计中的自由度"><a href="#6-5-1-统计中的自由度" class="headerlink" title="6.5.1 统计中的自由度"></a>6.5.1 统计中的自由度</h3><p>在传统的统计学中，自由度原本的意思是一个随机向量中能够发生变化的分量的维度数量，例如：如果一个向量$\boldsymbol x \in \mathbb{R}^n$中有$p$个分量可以自由发生变化，那这个向量$\boldsymbol x$的自由度为$p$。下面结合一个简单的例子理解。</p><blockquote><p>考虑以下情况中进行线性回归拟合模型：$\boldsymbol y \in \mathbb{R}^n, \boldsymbol X \in \mathbb{R}^{n \times p}$且$\boldsymbol X$是列满秩的，则利用拟合模型所得的预测结果$\hat{\boldsymbol y} = \boldsymbol X \hat{\beta}$即为$\boldsymbol y$在$\boldsymbol X$的$p$维列空间上的正交投影，而其残差$\boldsymbol r = \boldsymbol y - \hat{\boldsymbol y}$即为$\boldsymbol y$在$\boldsymbol X$的$p$维列空间的正交补上的投影，维度为$n-p$。则我们可以说这个线性模型的<strong>自由度(DoF)</strong>或模型自由度为$p$、而其残差自由度为$n-p$。</p><p>对于残差自由度而言，顾名思义，如果用$\sigma^2$来表示误差的方差的话，那残差$\boldsymbol r$实际上在$p$个方向上的投影均为0、而在剩余的$n-p$个方向上自由的变化。</p></blockquote><h3 id="6-5-2-矩阵自由度"><a href="#6-5-2-矩阵自由度" class="headerlink" title="6.5.2 矩阵自由度"></a>6.5.2 矩阵自由度</h3><p><strong>(一) 自由度概念再解释</strong></p><p>下面是两个比较好理解的自由度定义：</p><ul><li>自由度是$n$个变量在某个(些)约束下，能够自由变化的最多变量个数$m$为该约束下的自由度；</li><li>自由度是用约束式求解矩阵所需要的最少个数。</li></ul><p>维基百科的解释：数学上，自由度是一个随机向量的维度数，也就是一个向量能被完整描述所需的最少单位向量数。举例来说，从电脑屏幕到厨房的位移能够用三维向量$a\boldsymbol i + b\boldsymbol j + c\boldsymbol k$来描述，因此这个位移向量的自由度是3。自由度也通常与这些向量的坐标平方和，以及卡方分布中的参数有所关联。</p><blockquote><p>再来看两个例子：</p><p>若存在2个变量$a$和$b$，而$a+b=6$，那么他的自由度为1。因为其实只有$a$才能真正的自由变化，$b$会被$a$选值的不同所限制。在这个例子中$a+b=6$就是约束，可以自由变化的变量最多个数为1。所以自由度为1；</p><p>对于一个二维旋转矩阵， $\boldsymbol{M}_{\mathrm{rot2d}}=\left(\begin{array}{cc} \cos \theta &amp; -\sin \theta \\ \sin \theta \sigma_Y &amp; \cos \theta \end{array}\right)$，虽然这个$2\times 2$的矩阵有四个变量，但是一旦其中的一个值确定了，其他三个值就确定了。比如说当知道$(0, 0)$位置下的 $\cos \theta = 1$，那么则有$\sin\theta = 0$，不会等于其他数字。所以在二维旋转矩阵这个约束下，可以自由变化的最多变量个数为1，矩阵自由度为1。用几何的方式来思考也很好理解，在一个二维平面下的旋转，只有一个变量就是旋转角度$\theta$值。</p></blockquote><p><strong>(二) 矩阵自由度</strong></p><p>可以依据上文对自由度的解释应用到矩阵中。比如一个$3 \times 3$的矩阵，具有9个元素，那么它的自由度最高就是9。但是9个元素可能由几个变量通过一定方式组合而成，比如旋转矩阵，只有$\alpha,\beta,\gamma$三个旋转变量，通过三角函数组成了旋转矩阵，自由度只有3而不是9。</p><p>以下是一个<a href="https://math.stackexchange.com/questions/2771591/degrees-of-freedom-for-a-matrix">Stack Overflow</a>上的回答，以下是翻译，也可以增加对矩阵自由度的理解：</p><p>有几种方式来思考矩阵的自由度：</p><ul><li><p>考虑一个$m \times n$的矩阵。这个矩阵有$mn$个元素/变量。在没有任何约束条件下，我们可以任意改变$mn$个数值来构造出$mn$个互相不同的矩阵，所以它有$mn$个自由度。</p></li><li><p>一个上三角矩阵，维度是$m \times m$，我们知道在这个矩阵里很多值都是0，实际上只有$m+(m-1)+ \cdots +2+1$个非0元素/变量，所以这个值就是上三角矩阵的自由度。</p></li><li><p>一个$2 \times 2$的旋转矩阵，自由度等于多少？这对矩阵中可能的值施加了巨大的限制。确实，一旦其中一个值确定了之后，其他的所有值都被确定了。这个旋转矩阵只有一个自由度。</p></li><li><p>如果我们“equivalence classes”即“等价类”呢？如果我们知道任意矩阵的所有缩放都是相等的呢？我们还剩多少个自由度？对于任意矩阵，当位置$(1,1)$上的元素非0，我们就可以对矩阵的所有元素除以这个元素，这时$(1,1)$上的元素就等于1。现在考虑有两个矩阵$\boldsymbol A$和$\boldsymbol B = 2\boldsymbol A$，当我们缩放这两个矩阵使得它们的第一个元素为1，我们会发现这两个矩阵是等价的。因此，我们消除了一个自由度。这就是单应(矩阵)的例子。所以，对于一个$3\times 3$的单应矩阵，只有8个自由度。这些自由度也可以用几何的方式来解释。</p></li></ul><table><td style="word-wrap:break-word;word-break:break-all;" width="100px"; bgcolor=HoneyDew><font size="3">$n$阶方阵的秩等于$r$，也就是等价于它的列/行秩等于$r$，因此，为了构造一个秩为$r$的方阵，可以先选$r$个线性无关的$n$维向量作为它的列/行向量，这就有$n \times r$的自由度，另外剩下的$n-r$个列/行向量必须能用已选定的$r$个列/行向量线性表出，也就是它们要分别能写成已选定的$r$个列/行向量的线性组合，每一个线性组合有$r$个系数，也就是有$r$个自由度，$n-r$个向量就有$(n-r)\times r$个自由度，这样这个矩阵就能被确定下来了，所以一共的自由度是: $$n \times r + (n-r) \times r = (2n-r) \times r$$而且这个结论可以推广到非方阵的情形.</font></td></table><h3 id="6-5-3-方程自由度"><a href="#6-5-3-方程自由度" class="headerlink" title="6.5.3 方程自由度"></a>6.5.3 方程自由度</h3><p>自由度是指变量比方程多的情况。如果有10个变量和7个方程就有3个自由度。也就是说，其中3个变量可以假设你想要的任何值，对于这3个变量的任何给定值，剩下的7个变量都有一个特定的解。</p><p>也就是说，方程的数量+自由度总是会给出你有多少变量。</p><p>如果方程的数量大于变量的数量你就没有任何自由度方程组通常是完全不可解的。</p><p>如果你有自由度，你通常需要找到一些额外的约束来添加额外的方程。它的思想是让方程和变量的数量完全相同在这种情况下只有一个解。这是在方程是线性无关的假设下。在计算自由度之前，你必须先去掉所有线性相关的方程。</p><p>例如，$2x + 3y = 5$和$4x + 6y = 10$是两个方程，但它们不是线性独立的，所以当你去掉一个，你看到只有一个方程有两个变量，所以你有一个方程和一个自由度。</p><p>参考链接1：<a href="https://zhuanlan.zhihu.com/p/445334438">漫谈统计学习-自由度（DoF） - Chunxi Huang的文章 - 知乎</a><br>参考链接2：<a href="https://blog.csdn.net/CSSDCC/article/details/122005456">关于矩阵的自由度DOF的理解 - LYF0816LYF的文章 - CSDN</a><br>参考链接3：<a href="https://blog.csdn.net/hhl317/article/details/119273245">矩阵、方程自由度的理解 - 迪迦谁占了的文章 - CSDN</a></p><h2 id="6-6-信号子带划分"><a href="#6-6-信号子带划分" class="headerlink" title="6.6 信号子带划分"></a>6.6 信号子带划分</h2><p>子带技术的基本思想是利用分析滤波器组，将待处理的全带信号划分为子带信号，从而将相应的信号处理转移至子带域，最后再利用综合滤波器组将处理后的子带信号进行重构得到输出信号。将输入信号划分为多个子带信号，这种结构可以更有效地对信号进行处理，并且能够降低复杂度以及减少自适应滤波器的阶数。</p><h2 id="6-7-信号去相关"><a href="#6-7-信号去相关" class="headerlink" title="6.7 信号去相关"></a>6.7 信号去相关</h2><p>雷达到目标的不同散射体之间的相对路径长度就会发生变化，导致每个脉冲的回波相位发生变化，合成回波的幅度也发生波动，这就是去相关现象。对于刚体目标，RCS的去相关现象主要是由距离和视角变化引起的。而对于非刚体目标，比如地面灌木丛、草地、树木、海面、海浪等，除了与距离和视角变化有关外，还与目标本身的特性有关，如目标内部发生运动等。</p><p>相干雷达高度表与目标之间存在相对运动或者目标为非刚体目标，则会出现去相关现象，也就是信号相位并非一致，这样使得回波幅度不能相干积累。</p><h2 id="6-8-Capon谱-最小方差谱估计-MVDR算法"><a href="#6-8-Capon谱-最小方差谱估计-MVDR算法" class="headerlink" title="6.8 Capon谱/最小方差谱估计(MVDR算法)"></a>6.8 Capon谱/最小方差谱估计(MVDR算法)</h2><p>最小方差谱估计方法(MVDR)也称作Capon方法，其基本思想是设计与输入数据相关的带通滤波器组的过程。Capon方法应用一个带通滤波器来计算一个估计的谱值。为了得到统计稳定的谱估计值，需要将原始样本分成子序列进行处理，并将每一个子序列所获得的结果取平均值。</p><blockquote><p><a href="https://www.python100.com/html/118604.html">Capon算法</a>又被称为最小方差无偏估计算法(MVDR)，是一种空间谱估计算法，通过对接收到的信号进行处理，实现信号源的空间定位。它是基于波束成型技术发展而来，具有很高的方向性和性能可靠性，广泛应用于雷达、通信、声学等领域中。</p></blockquote><p>对一个长度为$m$的有限长脉冲响应滤波器$\boldsymbol h = [h_0, h_1, h_2, \cdots, h_m]^{\mathrm T}$，当输入原始数据序列$\{x(t)\}$时，滤波器在$t$时刻的输出为：</p><script type="math/tex; mode=display">y(t) = \boldsymbol h^{\mathrm H} \boldsymbol x = \sum_{k=0}^m h^*_k x(t-k) = \boldsymbol h^{\mathrm H} \left(\begin{array}{c} x(t) \\ x(t-1) \\ \vdots \\ x(t-m) \end{array}\right)</script><p>则滤波器输出的功率表示为：</p><script type="math/tex; mode=display">E\{|y(t)|^2\} = E\{\boldsymbol h^{\mathrm H} \boldsymbol x \boldsymbol x^{\mathrm H} \boldsymbol h\} = \boldsymbol h^{\mathrm H} E\{\boldsymbol x \boldsymbol x^{\mathrm H}\} \boldsymbol h = \boldsymbol h^{\mathrm H} \boldsymbol R~ \boldsymbol h</script><p>式中$\boldsymbol R$表示数据矢量的协方差矩阵。</p><p>滤波器$\boldsymbol h$对频率为$\omega$的正弦分量的响应为：</p><script type="math/tex; mode=display">H(\omega) = \boldsymbol h^{\mathrm H} \boldsymbol a(\omega) = \sum_{k=0}^m h_k \mathrm e^{-\mathrm j \omega k}</script><p>式中$\boldsymbol a(\omega) = [1, \mathrm e^{-\mathrm j \omega}, \cdots, \mathrm e^{-\mathrm j m \omega}]^{\mathrm T}$。</p><p>如果想使滤波器对于当前值$\omega$周围的频带具有良好的选择性，则可以考虑最小化滤波器输出噪声均方值，其约束条件为滤波器使频率$\omega$无失真地通过，即：</p><script type="math/tex; mode=display">\begin{cases}\min\limits_{\boldsymbol h} & \boldsymbol h^{\mathrm H} \boldsymbol R ~ \boldsymbol h \\ \text { s.t. } & \boldsymbol h^{\mathrm H} \boldsymbol a(\omega) = 1\end{cases}</script><p>由拉格朗日乘子法可以解得滤波器响应为：</p><script type="math/tex; mode=display">\boldsymbol h = \dfrac{\boldsymbol R^{-1} \boldsymbol a(\omega)}{\boldsymbol a^{\mathrm H}(\omega) \boldsymbol R^{-1} \boldsymbol a(\omega)}</script><p>代入可求得滤波器的输出功率为：</p><script type="math/tex; mode=display">E\{|y(t)|^2\} = \dfrac{1}{\boldsymbol a^{\mathrm H}(\omega) \boldsymbol R^{-1} \boldsymbol a(\omega)}</script><p>因此信号在通带的中心频率处的功率谱密度估计式为：</p><script type="math/tex; mode=display">P(\omega) \simeq \dfrac{E\{|y(t)|^2\}}{\beta} = \dfrac{1}{\beta \boldsymbol a^{\mathrm H}(\omega) \boldsymbol R^{-1} \boldsymbol a(\omega)}</script><p>式中$\beta$为带通滤波器的频率带宽。由于带通滤波器的设计是依赖于数据的，所以$\beta$未必是与数据独立的，也未必是与频率独立的，因此并不能简单地被当作一个缩放比例。</p><p>最简单的一种可能性是$\beta = \dfrac{1}{m+1}$，这是由时间带宽积决定的。而关于$\beta$的一个更加精确的表达式可以如下获得：一人带通滤波器的(等效)带宽可以被定义为中心为$W$的矩形脉宽，在滤波器的频率响应中，其集中了信号的全部能量。根据此定义，可以假定$\beta$满足：</p><script type="math/tex; mode=display">\int_{-\pi}^{\pi} |H(\psi)|^2 \text{ d}\psi = |H(\omega)|^2 2\pi \beta</script><p>在当前情况下，$H(w)= 1$，因此可以得到：</p><script type="math/tex; mode=display">\beta = \dfrac{1}{2 \pi} \int_{-\pi}^\pi\left|\boldsymbol h^{\mathrm H} \boldsymbol a(\psi)\right|^2 \mathrm{~d} \psi = \boldsymbol h^{\mathrm H} \left[\dfrac{1}{2 \pi} \int_{-\pi}^\pi \boldsymbol a(\psi) \boldsymbol a^{\mathrm H}(\psi) \mathrm{~d} \psi \right] \boldsymbol h</script><p>上式中二次型中矩阵的第$(k, p)$个元素由下式给出：</p><script type="math/tex; mode=display">\dfrac{1}{2 \pi} \int_{-\pi}^\pi \mathrm{e}^{-\mathrm{j} \psi(k-p)} \mathrm{~d} \psi=\delta_{k, p}</script><p>则有：</p><script type="math/tex; mode=display">\beta = \boldsymbol h^{\mathrm H} \boldsymbol h = \dfrac{\boldsymbol  a^{\mathrm H}(\omega) \boldsymbol R^{-2} \boldsymbol a(\omega)}{\left[\boldsymbol a^{\mathrm H}(\omega) \boldsymbol R^{-1} \boldsymbol a(\omega)\right]^2}</script><p>这里$\beta$的表达式是基于这样的假设，即曲线$|H(\psi)|^2 = |\boldsymbol h^{\mathrm H} \boldsymbol a(\psi)|^2, \psi \in [-\pi, \pi]$下的绝大多数区域都位于中心频率$\omega$的周围。</p><p>在上面的推导中，假定可以获得真实的数据协方差矩阵$\boldsymbol R$。为了在实际中应用，必须用样本估计值代替公式中的$\boldsymbol R$。例如应用:</p><script type="math/tex; mode=display">\hat{\boldsymbol R} = \dfrac{1}{N-m} \sum_{t=M+1}^N\left[\begin{array}{c}y(t) \\\vdots \\y(t-m)\end{array}\right]\left[\begin{array}{lll}y^*(t) & \cdots & y^*(t-m)\end{array}\right]</script><p>则根据不同的$\beta$，得到下列两种Capon谱估计器，分别为：</p><script type="math/tex; mode=display">\begin{aligned}&\hat{\phi}(\omega)=\dfrac{m+1}{\boldsymbol a^{\mathrm H}(\omega) \hat{\boldsymbol R}^{-1} \boldsymbol a(\omega)}\\&\hat{\phi}(\omega)=\dfrac{\boldsymbol a^{\mathrm H}(\omega) \hat{\boldsymbol R}^{-1} \boldsymbol a(\omega)}{\boldsymbol a^{\mathrm H}(\omega) \hat{\boldsymbol R}^{-2} \boldsymbol a(\omega)}\end{aligned}</script><p>为了使$\hat{\boldsymbol R}^{-1}$存在，要求$m &lt; \dfrac{N}{2}$，其确定了Capon方法所能达到的分辨率极限。当$m$减小时，Capon方法的分辨率将会变差，但是方的估计精确性会得以提高。</p><p><strong>转载自：<a href="https://www.zgbk.com/ecph/words?SiteID=1&amp;ID=113917&amp;Type=bkzyb&amp;SubID=101562">最小方差谱估计 - 中国大百科全书</a></strong></p><p>参考链接1：<a href="https://blog.csdn.net/yhcwjh/article/details/108272214">关于Capon最优加权系数和MVDR加权系数等价的证明 - CSDN</a><br>参考链接2：<a href="https://blog.csdn.net/qq_42330141/article/details/123806809">Capon波束形成器推导和仿真 - CSDN</a><br>参考链接3：<a href="https://wenku.baidu.com/view/964cfa6c783e0912a2162a68">第五章功率谱估计第5节 - 百度文库</a><br>参考链接4：<a href="https://www.eet-china.com/mp/a123703.html">阵列信号的（空间谱）DOA估计概述 - 芯语 - 面包板</a><br>参考链接5：<a href="https://blog.csdn.net/pwang95/article/details/104999880">阵列信号DOA估计系列(一).概述 - CSDN</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研课题学习 </category>
          
          <category> 公式手册等 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见用电设备功率(未完结)</title>
      <link href="/2025/02/06/Power-of-electrical-equipment/"/>
      <url>/2025/02/06/Power-of-electrical-equipment/</url>
      
        <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><p>本文主要是记录一下电功率的基础知识以及常见的用电设备功率。</p><h1 id="1-功率的概念"><a href="#1-功率的概念" class="headerlink" title="1 功率的概念"></a>1 功率的概念</h1><h2 id="1-1-功率介绍"><a href="#1-1-功率介绍" class="headerlink" title="1.1 功率介绍"></a>1.1 功率介绍</h2><p>‌<strong>功率是指物体在单位时间内所做的功，即功率是描述做功快慢的物理量</strong>‌。具体来说，功率是单位时间内传递或转换的能量，用来衡量体系做功的快慢。功率是一个标量，只用来衡量做功的快慢，其正负号常用来表示体系是接受外界做功还是对外做功。‌  </p><ul><li><strong>功率的定义和计算公式</strong></li></ul><p>功率的定义为：单位时间内所做的功称为功率，用$P$表示。其计算公式为：</p><script type="math/tex; mode=display">P = \dfrac{W}{t}</script><p>其中，$P$表示功率，$W$表示功，$t$表示时间。这个公式适用于各种形式的能量转化过程，无论是力学中的动能转化为势能，还是电学中的电能转化为热能或光能等‌ </p><p>此外，功率也可以通过其他公式计算，例如： $P=Fv \cos⁡ \theta$，其中，$F$表示作用力，$v$表示速度，$\theta$表示力与速度间的夹角。 </p><ul><li><strong>功率的单位和测量方法</strong></li></ul><p>功率的单位是瓦特（W），简称瓦。此外，功率还可以用马力（PS）或千瓦（kW）来表示。1马力等于0.735千瓦。测量功率的方法通常是通过测量在特定时间内所做的功或消耗的能量来计算。</p><h2 id="1-2-电功率介绍"><a href="#1-2-电功率介绍" class="headerlink" title="1.2 电功率介绍"></a>1.2 电功率介绍</h2><h3 id="1-2-1-电功率"><a href="#1-2-1-电功率" class="headerlink" title="1.2.1 电功率"></a>1.2.1 电功率</h3><p>电功率则是功率在电学领域中的具体应用，它描述的是<strong>电流在单位时间内所做的功，即电能转化的速率</strong>。电功率的计算公式有多种，其中最常见的是‌（在纯电阻电路中）：</p><script type="math/tex; mode=display">P = UI = I^2R = \dfrac{U^2}{R}</script><p>其中，$P$表示电功率，$U$表示电压，$I$表示电流，$R$表示电阻。该公式适用于不同电路条件下的电功率计算，如直流电路、交流电路等‌ 。</p><h3 id="1-2-2-用电度数-电量"><a href="#1-2-2-用电度数-电量" class="headerlink" title="1.2.2 用电度数/电量"></a>1.2.2 用电度数/电量</h3><p>用电度数，即电量，是衡量电能消耗量的单位。在中国，家庭用电常用千瓦时（kWh）作为电量的单位。<strong>1千瓦时表示功率为1千瓦的电器工作1小时所消耗的电能</strong>。换句话说，如果一个电器的功率是1千瓦，并且它工作了1小时，那么它就消耗了1千瓦时的电能，也就是1度电。 </p><h3 id="1-2-3-电功率和用电度数之间的关系"><a href="#1-2-3-电功率和用电度数之间的关系" class="headerlink" title="1.2.3 电功率和用电度数之间的关系"></a>1.2.3 电功率和用电度数之间的关系</h3><p>电功率的单位是瓦特（W）或千瓦（kW），而用电度数（电量）的单位是千瓦时（kWh），它们之间的关系可以通过如下公式来表示‌：</p><script type="math/tex; mode=display">\text{度数 = 电量(kWh) = 功率(kW) × 时间(h)}</script><p>举例1：飞利浦电灯E27的功率是50W，请计算该电灯工作一天(24h)的用电度数。</p><script type="math/tex; mode=display">\text{单位转换为kW}：\dfrac{50W}{1000} = 0.05kW \qquad \\\text{计算用电度数}：0.05kW \times 24h = 1.2 \text{度}</script><blockquote><p>PS：假设居民用电为<strong>0.57元/千瓦时</strong> ，则此电灯开一天花费：$1.2 \times 0.57=0.684$(元)。</p></blockquote><p>举例2：如果一个电器的功率是2千瓦，并且它工作了3小时，那么它消耗的电能就是2千瓦乘以3小时，即6千瓦时，也就是6度电。</p><h3 id="1-2-4-家庭用电功率的计算"><a href="#1-2-4-家庭用电功率的计算" class="headerlink" title="1.2.4 家庭用电功率的计算"></a>1.2.4 家庭用电功率的计算</h3><p>电路中串并联功率的计算公式是$P=UI$，无论是<strong>串联电路还是并联电路，总功率都等于各导体的电功率之和</strong>。 </p><p>一般来说，家中所有电器都是<strong>并联的</strong>，各支路电压相等，电流与功率是成正比的。我们只要统计好各个电器的功率，然后直接相加就可得到总的功率。</p><h1 id="2-常见用电器的功率"><a href="#2-常见用电器的功率" class="headerlink" title="2 常见用电器的功率"></a>2 常见用电器的功率</h1><h2 id="2-1-空调"><a href="#2-1-空调" class="headerlink" title="2.1 空调"></a>2.1 空调</h2><p>一般来说，家用空调的瓦数范围在800瓦到6000瓦之间。其中，常见的空调瓦数有1匹、1.5匹、2匹、3匹、4匹等。具体来说：</p><ul><li>1匹空调的制冷量大约为2200瓦，制热量约为2600瓦；</li><li>1.5匹空调的制冷量大约为3200瓦，制热量约为3600瓦；</li><li>2匹空调的制冷量大约为4200瓦，制热量约为4600瓦；</li><li>3匹空调的制冷量大约为5600瓦，制热量约为6200瓦；</li><li>4匹空调的制冷量大约为7200瓦，制热量约为7800瓦。 </li></ul><p>比如，以我家的空调为例，我家空调是2匹的，写此篇博客正值2025年春节期间，用于冬季制热，所以开10个小时的用电度数大概为：$4.6kW \times 10h = 46 \text{度}$，那么大概一天花费：$0.57 \times 46 \text{度} = 26.22\text{元}$。</p><p>参考链接1：<a href="https://g.pconline.com.cn/x/1692/16922315.html">一般空调是多少瓦数的 选择合适的空调瓦数方法【详解】</a></p><h2 id="2-2-冰箱"><a href="#2-2-冰箱" class="headerlink" title="2.2 冰箱"></a>2.2 冰箱</h2><p>以我家冰箱上面标注的综合平均功率：35.45W为例，可知运行一天用电量为：$0.03545kW \times 24h = 0.8508  \text{度}$，那么大概一天花费：$0.57 \times 0.8508 \text{度} = 0.485\text{元}$。</p><h2 id="2-3-笔记本电脑"><a href="#2-3-笔记本电脑" class="headerlink" title="2.3 笔记本电脑"></a>2.3 笔记本电脑</h2><p>这里就以我的笔记本电脑为例，经查看，我的笔记本充电器上标注功率为150W，虽然不一定实际如此，但就简单这么算了，充电一天的用电量为：$0.15kW \times 24h = 3.6 \text{度}$，那么大概一天花费：$0.57 \times 3.6 \text{度} = 2.052\text{元}$。</p>]]></content>
      
      
      <categories>
          
          <category> 我的生活记录 </category>
          
          <category> 爱好与提升 </category>
          
          <category> 生活小常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 功率 </tag>
            
            <tag> 基础概念 </tag>
            
            <tag> 生活常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github个人博客搭建</title>
      <link href="/2025/02/04/Hexo-blog-building/"/>
      <url>/2025/02/04/Hexo-blog-building/</url>
      
        <content type="html"><![CDATA[<h1 id="1-博客参考教程"><a href="#1-博客参考教程" class="headerlink" title="1 博客参考教程"></a>1 博客参考教程</h1><p>本博客的制作重点参考了两个视频教程，地址如下：</p><p><a href="https://www.bilibili.com/video/BV1Hi421a7K4/?share_source=copy_web&amp;vd_source=5cb8e8e385b900f1a132ca50a9d46ab5">【零基础搭建个人博客！手把手教你用Hexo+GitHub+Zeabur打造属于你的网站!】- 哔哩哔哩</a></p><p><a href="https://www.bilibili.com/video/BV1JP411P7gc/?share_source=copy_web&amp;vd_source=5cb8e8e385b900f1a132ca50a9d46ab5">【第3期：Butterfly主题的基础配置】- 哔哩哔哩</a></p><h1 id="2-一些插件和问题"><a href="#2-一些插件和问题" class="headerlink" title="2 一些插件和问题"></a>2 一些插件和问题</h1><h2 id="2-1-官方的主题"><a href="#2-1-官方的主题" class="headerlink" title="2.1 官方的主题"></a>2.1 官方的主题</h2><p><a href="https://hexo.io/themes/">Themes | Hexo</a> </p><h2 id="2-2-博客加密与隐藏"><a href="#2-2-博客加密与隐藏" class="headerlink" title="2.2 博客加密与隐藏"></a>2.2 博客加密与隐藏</h2><p>请参考1：<a href="https://blog.yxyang.top/posts/24498.html">Hexo：建立自己的日记本并隐藏（加密） | 阳小楊</a> </p><p>请参考2：<a href="https://blog.csdn.net/qq_50082325/article/details/144447909">【Hexo】文章加密 - 時光心向阳 - CSDN</a></p><p>请参考3：<a href="https://blog.csdn.net/qq_42777659/article/details/126516780">同时支持置顶和隐藏文章的 hexo 生成器插件 - 0o酱 - CSDN</a></p><p>请参考4：<a href="https://insectmk.cn/posts/9c83ed78/">无需更改源码！让你的Hexo的文章在首页隐藏 | InsectMk的个人空间</a> </p><p>请参考5：<a href="https://blog.justlovesmile.top/posts/43010.html?time=1738807975162">Hexo博客 | 加密！给你的文章添加密码 | Justlovesmile’s BLOG</a> </p><p>请参考6：<a href="https://blog.csdn.net/gitblog_00859/article/details/142278713">Hexo 博客加密插件 hexo-blog-encrypt 教程 - 吴毓佳 -CSDN博客</a> </p><h2 id="2-3-博客文章封面的设置"><a href="#2-3-博客文章封面的设置" class="headerlink" title="2.3 博客文章封面的设置"></a>2.3 博客文章封面的设置</h2><p>请参考1：<a href="https://blog.csdn.net/qq_43857095/article/details/108306164">Hexo  butterfly 自定义文章封面   &amp;&amp;  主页顶部图片更改 - Moqiqiuzi - CSDN</a></p><p>请参考2：<a href="https://blog.csdn.net/zzq0523/article/details/122954271">Hexo-Butterfly主题优化-设置网站首页显示背景、文章最上方不显示背景 - zzqwtc - CSDN</a></p><h2 id="2-4-Hexo博客中数学公式"><a href="#2-4-Hexo博客中数学公式" class="headerlink" title="2.4 Hexo博客中数学公式"></a>2.4 Hexo博客中数学公式</h2><p>请参考1：<a href="https://blog.51cto.com/u_15917702/5953692">搭建Hexo博客遇到的问题（2）_51CTO博客_hexo搭建博客</a> </p><p>请参考2： <a href="http://wangcong.net/article/HexoWihLaTeX.html">Hexo中LaTeX公式渲染 | 旋律信</a> </p><p>请参考3： <a href="https://zhuanlan.zhihu.com/p/35988761">Hexo构建blog时渲染LaTeX数学公式的问题 - 知乎</a> </p><h2 id="2-5-博客搬运至hexo图片无法显示"><a href="#2-5-博客搬运至hexo图片无法显示" class="headerlink" title="2.5 博客搬运至hexo图片无法显示"></a>2.5 博客搬运至hexo图片无法显示</h2><p>请参考1：<a href="https://blog.csdn.net/qq_50082325/article/details/144531539">图片防盗链导致图片无法加载解决方法 - 時光心向阳 - CSDN</a></p><p>请参考2：<a href="https://blog.csdn.net/qq_73690037/article/details/145288299">解决CSDN博客搬运至hexo图片无法显示问题 - 木目515 - CSDN</a></p><p>请参考3：<a href="https://www.cnblogs.com/ranxi169/p/16711700.html">Hexo github 博客无法显示从其他博客（博客园）索引的图片 - 博客园</a></p><p>请参考4：<a href="https://cloud.tencent.com/developer/article/1952245">解决 hexo 博客的图片链接失效问题 - 腾讯云</a></p><h2 id="2-6-豆瓣、B站卡片超链接"><a href="#2-6-豆瓣、B站卡片超链接" class="headerlink" title="2.6 豆瓣、B站卡片超链接"></a>2.6 豆瓣、B站卡片超链接</h2><p>请参考1：<a href="https://dyphire.github.io/undefined/7e42bc76">Hexo 上的豆瓣、哔哩哔哩和 Steam 插件</a></p><p>请参考2：<a href="https://kaidashao1.github.io/2/">博客搭建日记：豆瓣、B站插件</a></p><h2 id="2-7-常用颜色名称"><a href="#2-7-常用颜色名称" class="headerlink" title="2.7 常用颜色名称"></a>2.7 常用颜色名称</h2><p>请参考1：<a href="http://www.360doc.com/content/15/0920/12/9060464_500270643.shtml">HTML颜色名称及色样表 - 360个人图书馆</a></p><h2 id="2-8-外挂链接"><a href="#2-8-外挂链接" class="headerlink" title="2.8 外挂链接"></a>2.8 外挂链接</h2><p>请参考1：<a href="https://blog.zhheo.com/p/ccaf9148.html">Hexo的Butterfly魔改教程：网址卡片外置标签</a></p><div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://blog.zhheo.com/p/ccaf9148.html">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/blog.zhheo.com/p/ccaf9148.html.png);"></div>        <div class="tag-link-right">            <div class="tag-link-title">Hexo的Butterfly魔改教程：网址卡片外置标签</div>            <div class="tag-link-sitename">Heo</div>        </div>        <i class="fa-solid fa-angle-right"></i>    </div>    </a></div><h1 id="3-一些命令和解释"><a href="#3-一些命令和解释" class="headerlink" title="3 一些命令和解释"></a>3 一些命令和解释</h1><ul><li><code>hexo new page</code>和<code>hexo new post</code>的区别 <ul><li><code>hexo new post</code>：此命令用于创建一篇新的文章。在Hexo中，文章（post）是博客的主要内容，通常按照时间顺序排列显示。当你执行<code>hexo new post</code>命令时，Hexo会在<code>source/_posts</code>目录下创建一个新的Markdown文件，这个文件用于编写你的文章内容。文章可以使用主题提供的布局和样式进行渲染，并显示在博客的主页或文章列表。</li><li><code>hexo new page</code>‌：此命令用于创建一个新的页面。与文章不同，页面（page）在Hexo中通常用于静态内容，如关于页面、联系页面或其他不经常更新的信息。当你执行<code>hexo new page</code>命令时，Hexo会在<code>source</code>目录下创建一个新的文件夹（与页面名称相同），并在该文件夹中创建一个index.md文件。这个index.md文件用于编写页面的内容。与文章不同，页面通常不会按照时间顺序排列，而是根据需要在博客的导航菜单或其他位置进行链接‌ </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 我的生活记录 </category>
          
          <category> 爱好与提升 </category>
          
          <category> HEXO博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习中的显卡介绍</title>
      <link href="/2025/01/22/Introduce-GPU-in-deep-learning/"/>
      <url>/2025/01/22/Introduce-GPU-in-deep-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="1-用于深度学习的GPU介绍"><a href="#1-用于深度学习的GPU介绍" class="headerlink" title="1 用于深度学习的GPU介绍"></a>1 用于深度学习的GPU介绍</h1><h2 id="1-1-目前常用于深度学习的GPU型号和性能参数"><a href="#1-1-目前常用于深度学习的GPU型号和性能参数" class="headerlink" title="1.1 目前常用于深度学习的GPU型号和性能参数"></a>1.1 目前常用于深度学习的GPU型号和性能参数</h2><p><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122132526446-1653093349.png"><br><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122143120655-1500705632.png"></p><p>补充说明：</p><p><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122143533665-1205926068.png"></p><h2 id="1-2-显卡选购建议"><a href="#1-2-显卡选购建议" class="headerlink" title="1.2 显卡选购建议"></a>1.2 显卡选购建议</h2><h3 id="1-2-1-入门级-初学者或轻度用户"><a href="#1-2-1-入门级-初学者或轻度用户" class="headerlink" title="1.2.1 入门级 - 初学者或轻度用户"></a>1.2.1 入门级 - 初学者或轻度用户</h3><p>如果你刚开始接触深度学习，或者只是做一些简单的实验和小规模模型训练，那么以下显卡可能就足够了：</p><p><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122150555080-1422318081.png"></p><h3 id="1-2-2-中级-研究员或开发者"><a href="#1-2-2-中级-研究员或开发者" class="headerlink" title="1.2.2 中级 - 研究员或开发者"></a>1.2.2 中级 - 研究员或开发者</h3><p>对于那些需要更强大的计算能力来进行更复杂的模型训练或研究工作的人群来说，可以考虑以下显卡：</p><p><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122150925178-965391835.png"></p><h3 id="1-2-3-高级-专业级-高端研究机构或企业"><a href="#1-2-3-高级-专业级-高端研究机构或企业" class="headerlink" title="1.2.3 高级/专业级 - 高端研究机构或企业"></a>1.2.3 高级/专业级 - 高端研究机构或企业</h3><p>当涉及到非常大的数据集、极其复杂的模型架构以及需要快速迭代和高吞吐量时，应该选择最顶级的专业级显卡：</p><p><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122151337225-1813608360.png"></p><h1 id="2-CUDA概念介绍"><a href="#2-CUDA概念介绍" class="headerlink" title="2 CUDA概念介绍"></a>2 CUDA概念介绍</h1>  <div class="bvideo"><a href="//www.bilibili.com/video/BV1DFg8eDELg" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i1.hdslb.com/bfs/archive/ffbf8e395913cff83180585475a71e6e71ebf7b2.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:07:26</span>            </div>            <div class="bvideo-info">                <p class="title">13-大模型是如何在GPU中运行的</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>8919</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>5</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">泡澡的龙</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div> </br>  <div class="bvideo"><a href="//www.bilibili.com/video/BV1Jx4y1S7de" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/19713b43fb063e9ab2c60898bc6d48e979bf200d.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:53:04</span>            </div>            <div class="bvideo-info">                <p class="title">CUDA 简明教程</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>5211</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>8</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">大模型成长之路</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><h2 id="2-1-转载自其他网站的Cuda概念"><a href="#2-1-转载自其他网站的Cuda概念" class="headerlink" title="2.1 转载自其他网站的Cuda概念"></a>2.1 转载自其他网站的Cuda概念</h2><table><td style="word-wrap:break-word;word-break:break-all;" width=100%; bgcolor=HoneyDew><font size="3"><font color=red><strong>🐹 什么是CUDA：</strong> </font></br>CUDA —— 英伟达2006年推出的计算API，相当于是一种可以调用英伟达GPU的一个平合。一般计算机最重要的芯片有两个：CPU和GPU。CPU是中央处理器，GPU是图形处理器。</br>编程语言（C/C++等）只能调用CPU，不能调用GPU。我们想让GPU强大的并行化能力充分发挥，编写一些可以并行化的程序在GPU上运行能够快速获得运行结果，所以<strong>需要一个在编程语言（C/C++等）和底层GPU这个物理芯片之间有一个可以沟通连接的东西</strong>，因此英伟达NVIDIA搞出了一个叫做<font color=red><strong>Cuda的平台</strong></font>。简单来说，可以认为Cuda是对C/C++语言进行了扩展，允许开发者编写运行在NVIDIA GPU上的代码。</br>有了这个平台，你就可以使用编程语言（C/C++等）调用GPU处理大量的并行化任务，而不需要重新设计一个全新的能直接在GPU上直接运行的编程语言，节省了大量的学习成本。有了Cuda平台，就可以使得显卡不仅仅是进行图像像素等的处理，还能进行一些更加通用的运算，比如人工智能等算法需要大量的矩阵运算，这需要很强的并行化处理能力来加快运算，于是我们可以利用Cuda编写程序让这部分需要并行运算的代码在GPU上跑，而不是在并行化能力较弱的CPU上跑。</br><!DOCTYPE html><html lang="zh-CN"><body style="font-family: Arial, sans-serif; background-color: #f4f4f9; padding: 20px;">    <a href="https://www.bilibili.com/video/BV1Fn4y1972c" target="_blank"        style="display: inline-block; padding: 10px 20px; margin-top: 20px;              background-color: #007bff; color: white; text-decoration: none;               border-radius: 5px; transition: background-color 0.3s ease;">        什么是CUDA - 苦魔-浪人 - 哔哩哔哩    </a></body></html></font></td></table><table><td style="word-wrap:break-word;word-break:break-all;" width=100%; bgcolor=HoneyDew><font size="3"><font color=red><strong>🎅 Cuda是什么：</strong> </font></br>没有CUDA就没有今天人工智能产业的繁荣，那CUDA它是个啥、它是如何诞生的。</br>我们先从老黄和他的英伟达说起。黄仁勋1963年生于台南，1993年喜欢游戏的黄仁勋和另外两位芯片设计师Chris Malachowsky、Curtis Priem共同创立了英伟达，他们的眼光瞄准了正在蓬勃成长的个人电脑与游戏机市场，此时一些3D游戏开始崭露头角，而3D游戏必须有专业的图形显示处理器来帮助CPU加速图像渲染，这也就是我们今天常说的显卡原型。显卡中的核心就是图形计算器GPU，不过GPU这个词语出现和流行要晚一点。1999年英伟达发布其革命性产品 —— <strong>Geforce 256</strong>，其芯片采用220纳米制造，拥有2300万个晶体管，并首次把以往需要CPU处理的坐标转换和光源计算直接集成到显卡这个硬件中。这款显卡计算性能大幅跃升的同时减少了游戏对CPU计算的依赖，它也因此常被宣称为世界上第一个GPU。这时期接连涌现的GPU，为了满足市场对画面真实感的需求，允许开发人员编写在每个像素上运行的程序，这些程序很简单，可能只有几条指令，但是它们在屏幕上的每个像素背后运行：</br><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122110524971-1067628694.png" style="zoom:60%">想象一下，如果一个游戏画面是100万像素，每个像素每秒运行60次，那么这个游戏画面本质上是一个大规模并行的程序，而这种大规模的并行计算让眼尖的人看到了其中蕴含的线性代数的矩阵乘法的影子，而涉及这类数学的领域往往都是数值建模、科学计算等，而今天极为重要的人工智能更是离不开这类数学。</br>能不能把GPU从专用的图形计算变为适合这类数学的通用计算呢？当然可能有人这时候会想起电脑的中央处理器CPU就是通用计算，刚刚提到的科学计算人工智能等等不能用CPU算吗？</br>答案是：能是能，只是虽然CPU的核心计算和处理复杂任务的能力相比GPU更强，但CPU核心的数量比GPU少得多：</br><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122111303311-173261623.png" style="zoom:60%">> PS：既然GPU核心这么多，可能会有人想把CPU做大，给CPU堆核心数量不行吗？</br>>> 回答：物理特性限制，cpu不能做那么大。良品率等原因导致核心大小和数量有极限，一般cpu是要比gpu物理尺寸大的，显卡只是散热模具大，核心和cpu差不多大，其他的你想象成主板也可以。</br>CPU更适合做一个接一个的串行指令，GPU更适合做同时的并行指令，所以GPU的这种能力更适合。但是此时的程序员想在GPU上编程进行通用计算是很难的事情，想要将图形处理器从游戏渲染部署应用到一般计算领域，这就需要把这些通用计算的算法转化映射到这些GPU的纹理、三角形、像素等图形基元。而这种任务即便是对高级的图形开发人员来说也很难。</br>斯坦福大学图形实验室的伊恩·巴克不畏难，他带领团队搞了一个<strong> BrookGPU项目</strong> ，这个项日主要就是研究在GPU上进行通用编程并为开发人员提供更方便的GPU编程工具。这个项目在ATI(今AMD)、英伟达、IBM、索尼以及国防部幸能源部等机构的技术和资金支持下取得了不错的成果。他们通过引入Brook编程语言，使得C语言可以拓展涵盖简单的数据并行构造，从而实现GPU作为流处理协处理器的通用计算功能。</br>而老黄也看到了这个项目的潜力，因为显卡想模拟显示更加真实的现实世界，就需要引入更多的物理规律，而这些规律的科学计算很依赖GPU的通用计算能力，所以老黄想借助伊恩·巴克，把英伟达的GPU打造成强大的超级计算机。伊恩·巴克毕业后顺势加入了英伟达，并从04年开始主导新项目——<font color=red><strong>CUDA(统一计算设备架构, Compute Unified Device Architeeture)</strong></font>。这是一种并行计算架构和编程模型，专门用于英伟达的GPU。<strong>通过CUDA，开发人员可以基于C语言等编程语言拓展，编写可以调用GPU进行通用计算的程序</strong>。但是Cuda的科学计算功能对于当时大部分买来打游戏的消费者来说压根用不到，英伟达一度要破产。直到2011年曾经因曼哈顿计划建立的橡树岭国家实验室正在升级打造超级计算机泰坦，他们看到了GPU作为通用计算的价值，所以采购了大量英伟达的GPU，泰坦也是世界上第一台以通用图形处理器作为主要数据处理器的超级计算机。并在2012年11月到2013年6月间，保持了世界上最快超级计算机的称号。</br><!DOCTYPE html><html lang="zh-CN"><body style="font-family: Arial, sans-serif; background-color: #f4f4f9; padding: 20px;">    <a href="https://www.bilibili.com/video/BV1hb4y1P7j9" target="_blank"        style="display: inline-block; padding: 10px 20px; margin-top: 20px;              background-color: #007bff; color: white; text-decoration: none;               border-radius: 5px; transition: background-color 0.3s ease;">        英伟达的王牌杀手：CUDA的诞生 - 哔哩哔哩    </a></body></html></font></td></table><table><td style="word-wrap:break-word;word-break:break-all;" width=100%; bgcolor=HoneyDew><font size="3"><font color=red><strong>🚀 一文揭开NVIDIA CUDA神秘面纱：</strong> </font></br>今天我们来聊一下人工智能生态相关技术：用于加速构建AI核心算力的GPU编程框架 —— CUDA。</br>你一定听说过CUDA，并了解这玩意与NVIDIA GPU密切相关。然而，关于CUDA的具体定义和功能，许多人仍然心存疑惑，一脸懵逼。CUDA是一个与GPU进行通信的库吗？如果是，它属于C++还是 Python库？或者，CUDA实际上是一个用于GPU的编译器？了解这些问题有助于更好地掌握CUDA的核心特性及其在GPU加速中的作用。</br>CUDA，全称为 “ Compute Unified Device Architecture”，即“计算统一设备架构”，是NVIDIA推出的一套强大并行计算平台和编程模型框架，为开发人员提供了加速计算密集型应用的完整解决方案。<strong>CUDA包含运行时内核、设备驱动程序、优化库、开发工具和丰富的API组合，使得开发人员能够在支持CUDA的GPU上运行代码</strong>，大幅提升应用程序的性能。这一平台尤为适合用于<strong>处理大规模并行任务</strong>，如深度学习、科学计算以及图像处理等领域。</br>通常而言，“CUDA” 不仅指平台本身，也可指为充分利用NVIDIA GPU的计算能力而编写的代码，这些代码多采用C++和Python等语言编写，以充分发挥GPU加速的优势。借助CUDA，开发人员能够更加轻松地将复杂的计算任务转移至GPU运行，极大提升应用程序的运行效率。</br> 因此，总结起来，可以得出如下结论：CUDA不仅仅是一个简单的库，它是一个完整的平台，为开发者提供了利用GPU进行高效并行计算的全方位支持。这个平台的核心组件包括：</br> <img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122122612020-1063566655.png" style="zoom:45%"><strong> CUDA到底是什么：</strong></br> （1）CUDA C/C++：这是CUDA为并行编程所扩展的C++语言，专为在GPU上编写并行代码而设计。开发者可以使用熟悉的C++语法结构，通过特定的编程模型定义GPU任务，让代码更高效地在多线程环境中执行。</br> （2）CUDA 驱动程序：这一组件连接操作系统与GPU，提供底层硬件访问接口。驱动程序的主要作用是管理CPU与GPU之间的数据传输，并协调它们的计算资源。它确保了硬件和操作系统的兼容性，是CUDA代码高效运行的基础。</br> （3）CUDA 运行时库（cudart）：运行时库为开发者提供了丰富的API，便于管理GPU内存、启动GPU内核（即并行任务）、同步线程等。它简化了开发者的工作流程，使得在GPU上运行并行程序的流程更加流畅和高效。</br> （4）CUDA 工具链（ctk）：包括编译器、链接器、调试器等工具，这些工具用于将CUDA代码编译成GPU可执行的二进制指令。工具链中的编译器将C++代码和CUDA内核代码一同处理，使其适应GPU的架构；而调试器和分析工具帮助开发者优化性能和排查问题。</br> 相关的环境变量可参考如下：</br> 1. <code>$CUDA_HOME</code>是系统CUDA的路径，看起来像<code>/usr/local/cuda</code>，它可能链接到特定版本<code>/usr/local/cuda-X.X</code>。</br> 2. <code>`$LD_LIBRARY_PATH/`</code>是一个帮助应用程序查找链接库的变量。您可能想要包含<code>$CUDA_HOME/lib</code>的路径。</br> 3. <code>`$PATH`</code>应该包含一个通往<code>$CUDA_HOME/bin</code>的路径。</br> 借助这一完整的开发平台，开发者能够充分挖掘NVIDIA GPU的计算潜力，将复杂的并行计算任务高效地分配至GPU上执行，从而实现应用程序性能的极大提升。</br> <strong>CUDA是如何工作的</strong> 现代GPU由数千个小型计算单元组成，这些单元被称为CUDA核心。CUDA核心能够高效并行工作，使GPU能够快速处理那些可以分解为多个小型独立操作的任务。这种架构使得GPU不仅适用于图形渲染任务，也适用于计算密集型的科学计算和机器学习等非图形任务。</br>  作为NVIDIA提供的一个计算平台和编程模型，CUDA专门为GPU开放了这些强大的并行处理能力。通过CUDA，开发者可以编写代码，将复杂的计算任务移交给GPU。以下是CUDA的工作原理：</br>  &nbsp;&nbsp;&nbsp;&nbsp;并行处理</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CUDA将计算任务分解为多个可以独立运行的小任务，并将这些任务分配到多个CUDA核心上并行执行。这样一来，与传统CPU顺序执行的模式相比，GPU可以在相同时间内完成更多的计算，从而极大地提升计算效率。</br>&nbsp;&nbsp;&nbsp;&nbsp;线程和块的架构</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在CUDA编程模型中，计算任务被进一步划分为线程，每个线程独立处理一部分数据。这些线程被组织成块，每个块中包含一定数量的线程。这种层次化结构不仅便于管理海量线程，还提高了执行效率。多个线程块可以同时运行，使得整个任务可以快速并行完成。</br>&nbsp;&nbsp;&nbsp;&nbsp;SIMD架构</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CUDA核心采用<strong>单指令多数据(Single Instruction Multiple Data，SIMD)</strong>架构。这意味着单条指令可以对多个数据元素同时执行操作。例如，可以用一条指令对大量数据元素进行相同的计算，从而加快数值计算的速度。这种架构对矩阵运算、向量处理等高并行任务极为高效，特别适用于深度学习模型训练、图像处理和模拟仿真等领域。</br>基于这些特性，CUDA不仅为高性能并行计算提供了直接途径，也将NVIDIA GPU的强大计算潜力拓展至科学计算、人工智能、图像识别等领域。</br>  <strong>CUDA编程模型</strong> </br>在CUDA编程中，开发者通常需要编写两部分代码：<font color=blue><strong>主机代码（Host Code）</strong></font>和<font color=purple><strong>设备代码（Device Code）</strong> </font>。主机代码在CPU上运行，负责与GPU进行交互，包括数据传输和资源管理；而设备代码则在GPU上执行，承担主要计算任务。二者相互配合，充分利用CPU和GPU的协同处理能力，以达到高效并行计算的目的。</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=blue><strong>主机代码（Host Code）</strong></font></br>主机代码运行在CPU上，负责控制整个程序的逻辑流程。它管理CPU和GPU之间的数据传输，分配和释放GPU资源，并配置GPU内核参数。这部分代码不仅定义了如何组织数据并将其发送到GPU，还包含了启动设备代码的指令，从而让GPU接管计算密集的任务。主机代码起到管理和协调的作用，确保CPU与GPU之间的高效协作。</br>此部分包括数据传输、内存管理、以及启动 GPU 内核等，具体功能可参考如下所示：</br>1. 数据传输管理：主机代码负责在 CPU 和 GPU 之间传输数据。由于 CPU 和 GPU 通常使用不同的内存系统，主机代码需要在两者之间复制数据。例如，将需要处理的数据从主机内存（CPU 内存）传输到设备内存（GPU 内存），并在处理完成后将结果从 GPU 内存传回 CPU 内存。这种数据传输是耗时的，因此在实际应用中需要尽量减少传输频率，并优化数据大小，以降低延迟。</br>2. 内存分配与管理：主机代码分配 GPU 内存空间，为后续的计算提供储存资源。CUDA API 提供了多种内存管理函数（如 cudaMalloc 和 cudaFree），允许开发者在 GPU 上动态分配和释放内存。合理的内存分配策略可以有效提高内存使用效率，防止 GPU 内存溢出。</br>3. 内核配置与调度：在主机代码中，开发者可以配置内核启动参数（如线程数和线程块数）并决定内核在 GPU 上的执行方式。通过优化这些参数，主机代码能够显著提升程序的执行效率</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=purple><strong>设备代码（Device Code）</strong> </font></br><strong>设备代码编写的核心部分是在GPU上执行的计算函数</strong>，通常被称为<font color=orange><strong>内核（Kernel）</strong></font>。每个内核函数在GPU的众多CUDA核心上并行执行，能够快速处理大量数据。设备代码专注于数据密集型的计算任务，在执行过程中充分利用GPU的并行计算能力，使得计算速度比传统的串行处理有显著提升。</br>设备代码定义了GPU的计算逻辑，使用CUDA内核来并行处理大量数据。</br>1. 内核函数（Kernel Function）：<strong>设备代码的核心是内核函数</strong>，即在GPU的多个线程上同时执行的函数。内核函数由<code>__global__</code>关键字标识，表示该函数将在设备端（GPU）执行。内核函数与普通的 C/C++ 函数不同，它必须是无返回值的，因为所有输出结果都要通过修改传入的指针或GPU内存来传递。</br>2. 线程和线程块的组织：在设备代码中，计算任务被分解为多个线程，这些线程组成线程块（Block），多个线程块组成一个线程网格（Grid）。CUDA 提供了 threadIdx、blockIdx 等内置变量来获取线程的索引，从而让每个线程在数据中找到属于自己的计算任务。这种方式使得设备代码可以非常高效地并行处理数据集中的每个元素。</br>3. 并行算法优化：在设备代码中，CUDA编程可以实现多个并行优化技术，如减少分支、优化内存访问模式（如减少全局内存访问和提高共享内存利用率），这些优化有助于最大化利用GPU计算资源，提高设备代码执行速度。</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=DeepPink><strong>内核启动</strong></font></br>内核启动是CUDA编程的关键步骤，由主机代码启动设备代码内核，在GPU上触发执行。内核启动参数指定了GPU上线程的数量和分布方式，使内核函数可以通过大量线程并行运行，从而加快数据处理速度。通过适当配置内核，CUDA编程能以更优的方式利用GPU资源，提高应用的计算效率。</br>在整个体系中，这一步骤至关重要，它控制了设备代码的并行性、效率及运行行为。具体可参考如下：</br>1. 内核启动语法：CUDA 使用特殊的语法<code><<<Grid, Block>>></code>启动内核函数。例如：<code>kernel<<<numBlocks, threadsPerBlock>>>(parameters);</code>，其中<code>numBlocks</code>表示线程块的数量，<code>threadsPerBlock</code>表示每个线程块中包含的线程数。开发者可以根据数据集的大小和GPU的计算能力选择合适的线程块和线程数量。</br>2. 并行化控制：通过指定线程块数和线程数，内核启动控制了GPU的并行粒度。较大的数据集通常需要更多的线程和线程块来充分利用GPU的并行能力。合理配置内核启动参数，可以平衡GPU的并行工作负载，避免资源浪费或过载现象。</br>3. 同步与异步执行：内核启动后，GPU可以异步执行任务，CPU继续进行其他操作，直至需要等待GPU完成。开发者可以利用这种异步特性，使程序在CPU和GPU间并行执行，达到更高的并行效率。此外，CUDA提供了同步函数（如<code>cudaDeviceSynchronize</code>），确保CPU在需要时等待GPU完成所有操作，避免数据不一致的问题。</br>通过有效协调这三者，CUDA编程能够实现对数据密集型任务的高速并行处理，为高性能计算提供了一个极具扩展性的解决方案。</br><strong>CUDA内存层次结构体系</strong></br>在CUDA编程中，GPU内存的结构是多层次的，具有不同的速度和容量特性。CUDA提供了多种内存类型，用于不同的数据存储需求。合理利用这些内存可以显著提升计算效率。以下是各类内存的详细描述：</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=blue><strong>全局内存（Global Memory）</strong></font>全局内存是GPU上容量最大的存储空间，通常为几GB，并且是GPU的主要数据存储区。全局内存可以被所有线程访问，也可以与CPU共享数据，但其访问速度相对较慢（相对于其他GPU内存类型而言），因此需要避免频繁访问。数据传输操作也较耗时，因此全局内存常用于存储较大的数据集，但会优先考虑数据访问的批处理或其他缓存策略来减少其频繁调用。</br>通常而言，全局内存主要适用于存储程序的大部分输入输出数据，尤其是需要GPU和CPU共享的大容量数据。</br>示例：在矩阵乘法中，两个矩阵的元素可以存储在全局内存中，以便所有线程都可以访问。</br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">matrixMultiplication</span><span class="params">(<span class="type">float</span> *A, <span class="type">float</span> *B, <span class="type">float</span> *C, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> row = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line">    <span class="type">int</span> col = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        sum += A[row * N + i] * B[i * N + col];</span><br><span class="line">    &#125;</span><br><span class="line">    C[row * N + col] = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=purple><strong>共享内存（Shared Memory）</strong></font></br>共享内存是分配在GPU每个线程块内部的高速缓存，其访问速度远高于全局内存，但容量较小（通常为每块48 KB或更少）。共享内存是线程块内线程共享的，适合存储需要在一个线程块内频繁访问的数据。由于它存储在各自的块内，每个块内的线程可以在共享内存中快速读写数据，从而减少对全局内存的访问。</br>相对于全局内存，共享内存更多适用于多线程间的数据交换，尤其是需在一个线程块内反复使用的数据。</br>示例：在矩阵乘法中，A和B的子块可以加载到共享内存中，以便线程块中的所有线程都可以快速访问。</br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__shared__ <span class="type">float</span> sharedA[TILE_SIZE][TILE_SIZE];</span><br><span class="line">__shared__ <span class="type">float</span> sharedB[TILE_SIZE][TILE_SIZE];</span><br></pre></td></tr></table></figure>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=DarkTurquoise><strong>本地内存（Local Memory）</strong></font></br>本地内存是分配给每个线程的私有内存，主要用于存储线程的私有变量。尽管称为“本地”，它实际上是分配在全局内存中，因此访问速度较慢，接近全局内存的访问速度。由于本地内存容量有限且其访问开销较高，建议只在必要时使用。</br>通常情况下，本地内存适用于存储线程的临时变量、私有数据或不适合在寄存器中保存的数据。</br>示例：对于复杂计算中的中间变量，可以放置在本地内存中，以便线程之间不发生冲突。</br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> localVariable = <span class="number">0</span>;  <span class="comment">// 本地内存中的变量</span></span><br></pre></td></tr></table></figure>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=Goldenrod><strong>常量和纹理内存（Constant and Texture Memory）</strong></font></br>常量内存和纹理内存分别是 CUDA 提供的专用于只读数据的内存类型，具有特殊的缓存机制，能够在特定访问模式下加快数据读取。常量内存用于存储不会更改的常量数据，而纹理内存适合存储二维或三维数据，通过纹理缓存可以提高访问速度。</br>1. 常量内存（Constant Memory）：仅可由CPU写入，但可被所有GPU线程读取。适合存储小规模的、不变的数据（如配置信息、系数等）。</br>2. 纹理内存（Texture Memory）：专门优化以支持二维或三维数据的读取，对于非顺序或稀疏访问模式的数据（如图像数据）具有较高的访问效率。</br>示例：在图像处理应用中，将像素数据加载到纹理内存中，让 GPU 利用其特定的缓存机制来优化访问效率。</br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__constant__ <span class="type">float</span> constData[<span class="number">256</span>];  <span class="comment">// 常量内存</span></span><br><span class="line"></span><br><span class="line">cudaArray* texArray;</span><br><span class="line">cudaChannelFormatDesc channelDesc = <span class="built_in">cudaCreateChannelDesc</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line"><span class="built_in">cudaMallocArray</span>(&amp;texArray, &amp;channelDesc, width, height);  <span class="comment">// 纹理内存</span></span><br></pre></td></tr></table></figure><strong>小结</strong></br>CUDA平台为开发人员提供了对CUDA GPU并行计算资源的深度访问，允许直接操作GPU的虚拟指令集和内存。通过使用CUDA，GPU可以高效地处理数学密集型任务，从而释放CPU的计算资源，使其能够专注于其他任务。这种架构与传统GPU的3D图形渲染功能有着本质的区别，开创了GPU在计算领域的新用途。</br>在CUDA平台的架构中，CUDA核心是其核心组成部分。每个CUDA核心都是一个独立的并行处理单元，负责执行各种计算任务。GPU中的CUDA核心数量越多，它能够并行处理的任务就越多，从而显著提升计算性能。通过这种并行计算，CUDA平台能够在复杂的计算过程中实现大规模任务的并行处理，提供卓越的性能和高效性。</br><!DOCTYPE html><html lang="zh-CN"><body style="font-family: Arial, sans-serif; background-color: #f4f4f9; padding: 20px;">    <a href="https://news.qq.com/rain/a/20241110A01ZQO00" target="_blank"        style="display: inline-block; padding: 10px 20px; margin-top: 20px;              background-color: #007bff; color: white; text-decoration: none;               border-radius: 5px; transition: background-color 0.3s ease;">        一文揭开 NVIDIA CUDA 神秘面纱 - 架构驿站 - 腾讯网    </a></body></html></font></td></table><table><td style="word-wrap:break-word;word-break:break-all;" width=100%; bgcolor=HoneyDew><font size="3"><font color=red><strong>🌈 关于CUDA理解的其他连接：</strong> </font></br>  <a href="https://cloud.tencent.com/developer/article/2414140">英伟达CUDA介绍及核心原理 - 腾讯云</a></br><a href="https://blog.csdn.net/j8267643/article/details/136200206">【深入理解 Linux 调度（GPU）虚拟化】【转载】- CSDN</a></br><a href="https://www.zhihu.com/question/649201833">CUDA到底是什么东西，能不能通俗易懂地解释一下？ - 知乎</a></br><a href="https://blog.csdn.net/chenby186119/article/details/144557642">CUDA（Compute Unified Device Architecture）介绍 - CSDN</a></br><a href="https://www.bilibili.com/opus/880800210758926361">Nvidia的cuda是如何垄断的，三个软件护城河，一个芯片和软件协同 - 哔哩哔哩</a></br><a href="https://www.bilibili.com/video/BV1YN4y1K719">一张图看懂CPU、GPU、NPU - 哔哩哔哩</a></br><a href="https://space.bilibili.com/517221395/lists/1388713?type=season">合集·【AI芯片】GPU详解 - ZOMI酱 - 哔哩哔哩视频</a></br><a href="https://space.bilibili.com/517221395/lists/1420176?type=season">合集·【AI芯片】NPU芯片 - ZOMI酱 - 哔哩哔哩视频</a></br><a href="https://www.bilibili.com/video/BV1wbcdeWENh">都是处理器！CPU GPU NPU的区别到底是什么？- 哔哩哔哩</a></br><a href="https://www.bilibili.com/video/BV15Q4y1i7Bp/?share_source=copy_web">【PyTorch】B站首个，终于有人把 GPU/ CUDA/ cuDNN 讲清楚了- 哔哩哔哩</a></br></font></td></table><h2 id="2-2-关于BrookGPU的介绍"><a href="#2-2-关于BrookGPU的介绍" class="headerlink" title="2.2 关于BrookGPU的介绍"></a>2.2 关于BrookGPU的介绍</h2><h3 id="2-2-1-BrookGPU是什么"><a href="#2-2-1-BrookGPU是什么" class="headerlink" title="2.2.1 BrookGPU是什么"></a>2.2.1 BrookGPU是什么</h3><p>BrookGPU是一种针对图形处理器（GPU）的编程语言扩展，基于ANSI C(ANSI C标准,也称为C89或C90标准,是C语言的一种标准规范)语言，旨在简化和优化数据并行计算。它由斯坦福大学图形实验室开发，最初是<strong>为了在GPU上进行通用计算而设计</strong>。</p><ul><li><p><strong>核心概念</strong>，BrookGPU的核心概念包括<strong>流（Streams）</strong>和<strong>内核（Kernels）</strong>：</p><ol><li>流（Streams）：流是BrookGPU中的一种数据类型，代表一系列可以并行处理的数据。流的声明类似于C语言中的数组，但具有并行处理的特性。</li><li>内核（Kernels）：内核是在GPU上执行的函数，用于处理流中的数据。</li></ol></li><li><p><strong>设计目标</strong></p><ol><li>BrookGPU的设计目标是将GPU作为流式协处理器，通过流式编程模型将数据并行计算和算术密集型计算集成到一个熟悉的语言中。它通过编译器和运行时系统抽象化了GPU的硬件细节，使得开发者可以更方便地利用GPU的并行计算能力。</li></ol></li><li><p><strong>特点</strong></p><ol><li>数据并行性：允许开发者指定如何在不同数据上并行执行相同的操作。</li><li>算术密集型计算：鼓励开发者指定数据上的操作，以减少全局通信，增加局部计算。</li><li>简化编程模型：通过流和内核的概念，BrookGPU简化了GPU编程，降低了对图形硬件知识的要求。</li></ol></li><li><p><strong>应用场景</strong></p><ol><li>BrookGPU适用于多种高性能计算场景，如图像处理、物理模拟、傅里叶变换（FFT）等。它通过利用GPU的大规模并行性，能够显著提升计算效率。</li></ol></li><li><p><strong>开源与支持</strong><br>1.BrookGPU作为一个开源项目，提供了编译器和运行时系统，支持在多种GPU硬件上运行。它为开发者提供了一个通用的工具，用于探索GPU在通用计算中的潜力。</p></li></ul><p>总的来说，BrookGPU是早期探索GPU通用计算的重要工具之一，为后续的GPU编程模型（如CUDA）奠定了基础。 </p><h3 id="2-2-2-BrookGPU的底层源代码"><a href="#2-2-2-BrookGPU的底层源代码" class="headerlink" title="2.2.2 BrookGPU的底层源代码"></a>2.2.2 BrookGPU的底层源代码</h3><p>BrookGPU是一种软件，具体来说，它是一个编译器和运行时系统，用于在图形处理器（GPU）上进行通用计算。</p><p>BrookGPU的底层源代码主要是用<strong>C语言</strong>编写的。它的编译器（brcc）基于一个开源的C解析器cTool，并被修改以支持Brook语言的特定语法。此外，BrookGPU的运行时系统（BRT）提供了一个跨平台的接口，支持多种后端，包括OpenGL、DirectX以及CPU参考实现。</p><ul><li><p><strong>流（Streams）</strong>是BrookGPU中的一种<strong>数据结构</strong>，用于表示可以并行处理的数据集合。<strong>流的声明类似于C语言中的数组</strong>，但有一些特殊的规则和限制：</p><ul><li>流使用尖括号<code>&lt;&gt;</code>声明，例如<code>float s&lt;10, 10&gt;</code>表示一个二维流，包含100个浮点元素。</li><li>流的形状（Shape）指的是其维度，例如<code>&lt;10, 10&gt;</code>表示一个<code>10×10</code>的二维流。</li><li>流的元素只能在内核（Kernels）中访问，或用<code>streamRead</code>和<code>streamWrite</code>操作符在内存和流之间传输数据。</li><li>流不支持静态初始化，例如不能使用<code>float s&lt;100&gt; = &#123;1.0f, 2.0f, ...&#125;</code>的方式初始化。</li></ul></li><li><p><strong>内核（Kernels）</strong>是BrookGPU中的一种<strong>特殊函数</strong>，用于对流中的数据进行并行操作。内核定义和调用方式为：</p><ul><li>内核函数以<code>kernel</code>关键字声明，返回类型为<code>void</code>，并且至少有一个流参数。</li><li>调用内核时，BrookGPU会隐式地对流中的每个元素执行内核函数。</li><li>内核可以接受输入流（只读）和输出流（只写），还可以接受常量参数。</li></ul></li></ul><p>以下是一个简单的BrookGPU程序示例，展示了流和内核的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个内核函数，用于计算向量的线性组合</span></span><br><span class="line">kernel <span class="type">void</span> <span class="title function_">saxpy</span><span class="params">(<span class="type">float</span> a, float4 x&lt;&gt;, float4 y&lt;&gt;, out float4 result&lt;&gt;)</span> &#123;</span><br><span class="line">    result = a * x + y;  <span class="comment">// 对每个流元素执行操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">2.0f</span>;  <span class="comment">// 系数</span></span><br><span class="line">    float4 X[<span class="number">100</span>], Y[<span class="number">100</span>], Result[<span class="number">100</span>];  <span class="comment">// 主机内存中的数组</span></span><br><span class="line">    float4 x&lt;<span class="number">100</span>&gt;, y&lt;<span class="number">100</span>&gt;, result&lt;<span class="number">100</span>&gt;;  <span class="comment">// 声明流</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据...</span></span><br><span class="line">    <span class="comment">// 将数据从主机内存传输到流</span></span><br><span class="line">    streamRead(x, X);</span><br><span class="line">    streamRead(y, Y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用内核函数，对流中的每个元素执行操作</span></span><br><span class="line">    saxpy(a, x, y, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结果从流传输回主机内存</span></span><br><span class="line">    streamWrite(result, Result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个例子中：<ul><li><code>float4 x&lt;100&gt;</code>, <code>y&lt;100&gt;</code>, <code>result&lt;100&gt;</code>声明了三个流，分别用于输入和输出。</li><li><code>saxpy</code>内核函数对每个流元素执行操作，计算<code>a*x + y</code>。</li><li><code>streamRead</code>和<code>streamWrite</code>用于在主机内存和流之间传输数据。</li></ul></li></ul><p>通过流和内核的概念，BrookGPU提供了一种高效且简洁的方式来利用GPU的并行计算能力，适用于图像处理、科学计算等场景。</p><h1 id="3-各GPU支持的CUDA版本"><a href="#3-各GPU支持的CUDA版本" class="headerlink" title="3 各GPU支持的CUDA版本"></a>3 各GPU支持的CUDA版本</h1><h2 id="3-1-查看显卡驱动版本号"><a href="#3-1-查看显卡驱动版本号" class="headerlink" title="3.1 查看显卡驱动版本号"></a>3.1 查看显卡驱动版本号</h2><p>当显卡驱动安装完成后，需要使用<code>nvidia-smi</code>命令查看英伟达显卡驱动版本。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显卡驱动信息，主要看driver API的CUDA版本，即Runtime API CUDA支持的最高版本</span></span><br><span class="line">nvidia-smi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前使用的CUDA的版本</span></span><br><span class="line">nvcc -V</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看安装了几个CUDA，当前使用哪个版本的CUDA</span></span><br><span class="line">ll /usr/local/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看已安装的包的版本</span></span><br><span class="line">conda list | grep cuda</span><br><span class="line">conda list | grep torch</span><br></pre></td></tr></table></figure><br><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122170845475-1893288545.png" style="zoom:50%"></p><p>如上图所示，英伟达驱动版本为<code>520.61.05</code>，CUDA最高支持的版本为<code>11.8</code>。</p><h2 id="3-2-查看显卡驱动版本号和CUDA版本对应关系"><a href="#3-2-查看显卡驱动版本号和CUDA版本对应关系" class="headerlink" title="3.2 查看显卡驱动版本号和CUDA版本对应关系"></a>3.2 查看显卡驱动版本号和CUDA版本对应关系</h2><p>查看英伟达显卡驱动版本和CUDA版本的对应关系 —— 点击该链接：<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html</a></p><p>下图为CUDA工具包和CUDA小版本兼容性所需的最低驱动程序版本：</p><p><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122171215959-30652988.png"></p><p>由于我工作站（Ubuntu 20.04 LTS）的英伟达驱动版本为<code>520.61.05</code>，从上图可以看出，我最高可以安装的CUDA版本为<code>11.8.x</code>。（注：<code>CUDA 12.0.x</code>和<code>CUDA 12.1.x</code>都要求英伟达驱动版本大于等于<code>525.60.13</code>，因此我的<code>520.61.05</code>不符合，所以我最高只能安装<code>CUDA 11.8.x</code>的版本）。</p><h2 id="3-3-查看经典的CUDA版本号"><a href="#3-3-查看经典的CUDA版本号" class="headerlink" title="3.3 查看经典的CUDA版本号"></a>3.3 查看经典的CUDA版本号</h2><p>由于我们最终是要安装pytorch，因此选取合适的CUDA进行安装是有必要的。CUDA和PyTorch之间存在版本依赖关系，这是因为PyTorch可以使用CUDA加速深度学习模型的训练和推理，需要与特定版本的CUDA兼容才能正常工作。以下是CUDA和PyTorch版本之间的关系：</p><ul><li>CUDA和PyTorch的版本兼容性：<ul><li>不同版本的PyTorch需要与特定版本的CUDA兼容，以确保能够利用GPU的计算能力。这是因为PyTorch使用CUDA来执行深度学习操作。</li><li>在使用PyTorch之前，你应该查看PyTorch官方文档或GitHub仓库中的文档，以了解当前版本所支持的CUDA版本。通常，PyTorch的文档会明确说明支持的CUDA版本范围。<br>-示例：<ul><li>例如，如果你使用的是<code>PyTorch 1.8.0</code>，官方文档可能会明确指出支持<code>CUDA 11.1</code>，因此你需要安装<code>CUDA 11.1</code>或兼容版本的CUDA驱动来与<code>PyTorch 1.8.0</code>一起使用。</li></ul></li></ul></li></ul><div class="table-container"><table><thead><tr><th>pytorch版本</th><th>torchvision版本</th><th>cuda版本</th><th>python版本</th><th>备注</th></tr></thead><tbody><tr><td>0.4.0</td><td>0.2.2</td><td>Cuda8.0 / 9.0 / 9.1</td><td>[3.5, 3.7]</td><td></td></tr><tr><td>0.4.1</td><td>0.2.2</td><td>Cuda8.0 / 9.0 / 9.2</td><td>[3.5, 3.7]</td><td></td></tr><tr><td>1.0.0</td><td>0.2.1</td><td>Cuda8.0 / 9.0 / 10.0</td><td>[3.5, 3.7]</td><td></td></tr><tr><td>1.0.1</td><td>0.2.2</td><td>Cuda9.0 / 10.0</td><td>[3.5, 3.7]</td><td></td></tr><tr><td>1.1.0</td><td>0.3.0</td><td>Cuda9.0 / 10.0</td><td>[3.5, 3.7]</td><td></td></tr><tr><td>1.2.0</td><td>0.4.0</td><td>Cuda9.2 / 10.0</td><td>[3.5, 3.7]</td><td></td></tr><tr><td>1.3.0</td><td>0.4.1</td><td>Cuda9.2 / 10.0 / 10.1</td><td>[2.7, 3.7]</td><td></td></tr><tr><td>1.3.1</td><td>0.4.2</td><td>Cuda9.2 / 10.0 / 10.1</td><td>[2.7, 3.7]</td><td></td></tr><tr><td>1.4.0</td><td>0.5.0</td><td>Cuda9.2 / 10.1</td><td>[3.5, 3.8]</td><td></td></tr><tr><td>1.5.0</td><td>0.6.0</td><td>Cuda9.2 / 10.1 / 10.2</td><td>[3.5, 3.8]</td><td></td></tr><tr><td>1.5.1</td><td>0.6.1</td><td>Cuda9.2 / 10.1 / 10.2</td><td>[3.5, 3.8]</td><td></td></tr><tr><td>1.6.0</td><td>0.7.0</td><td>Cuda9.2 / 10.1 / 10.2</td><td>[3.5, 3.8]</td><td></td></tr><tr><td>1.7.0</td><td>0.8.1</td><td>Cuda10.1 / 10.2/ 11.0</td><td>[3.6, 3.8]</td><td></td></tr><tr><td>1.7.1</td><td>0.8.2</td><td>Cuda10.1 / 10.2 / 11.0</td><td>[3.6, 3.9]</td><td></td></tr><tr><td>1.8.0</td><td>0.9.0</td><td>Cuda10.1 / 10.2 / 11.1</td><td>[3.6, 3.9]</td><td></td></tr><tr><td>1.8.1</td><td>0.9.1</td><td>Cuda10.1 / 10.2 / 11.1</td><td>[3.6, 3.9]</td><td></td></tr><tr><td>1.9.0</td><td>0.10.0</td><td>Cuda10.2 / 11.1</td><td>[3.6, 3.9]</td><td></td></tr><tr><td>1.9.1</td><td>0.10.1</td><td>Cuda10.2 / 11.1</td><td>[3.6, 3.9]</td><td></td></tr><tr><td>1.10.0</td><td>0.11.1</td><td>Cuda10.2 / 11.1 / 11.3</td><td>[3.6, 3.9]</td><td></td></tr><tr><td>1.10.1</td><td>0.11.2</td><td>Cuda10.2 / 11.1 / 11.3</td><td>[3.6, 3.9]</td><td></td></tr><tr><td>1.10.2</td><td>0.11.3</td><td>Cuda10.2 / 11.1 / 11.3</td><td>[3.6, 3.9]</td><td></td></tr><tr><td>1.11.0</td><td>0.12.0</td><td>Cuda11.1 / 11.3 / 11.5</td><td>[3.7, 3.10]</td><td></td></tr><tr><td>1.12.0</td><td>0.13.0</td><td>cuda10.2 / 11.3 / 11.6</td><td>[3.7, 3.10]</td><td></td></tr><tr><td>1.13.0</td><td>0.14.0</td><td>cuda11.6 / 11.7</td><td>[3.7, 3.11]</td><td></td></tr><tr><td>1.13.1</td><td>0.14.1</td><td>cuda11.6 / 11.7</td><td>[3.7, 3.11]</td><td></td></tr><tr><td>2.0.0</td><td>0.15.0</td><td>cuda11.7 / 11.8</td><td>[3.8, 3.11]</td><td></td></tr><tr><td>2.0.1</td><td>0.15.2</td><td>cuda11.7 / 11.8</td><td>[3.8, 3.11]</td><td></td></tr><tr><td>2.1.0</td><td>0.16.0</td><td>cuda11.8 / 12.1</td><td>[3.8, 3.11]</td><td></td></tr><tr><td>2.1.1</td><td>0.16.1</td><td>cuda11.8 / 12.1</td><td>[3.8, 3.11]</td></tr></tbody></table></div><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h2><p>确定PyTorch、CUDA和显卡驱动的版本并确保它们兼容，可以按照以下步骤进行：</p><ul><li><p><strong>确定显卡驱动版本</strong>：</p><ul><li>在终端中执行<code>nvidia-smi</code>命令。这个命令会显示当前系统上的NVIDIA显卡驱动版本以及相关信息。</li><li>记下显示的 NVIDIA 驱动版本号。例如，版本号可能类似于<code>465.19.01</code>。</li></ul></li><li><p><strong>确定 CUDA 版本</strong>：</p><ul><li>通常，NVIDIA显卡驱动与CUDA版本一起安装。所以，你可以通过查看CUDA的版本来确定。</li><li>在终端中执行<code>nvcc --version</code>命令来查看CUDA版本。</li><li>记下显示的CUDA版本号。例如，版本号可能类似于<code>11.1</code>。</li></ul></li><li><p><strong>确定 PyTorch 版本</strong>：</p><ul><li>使用Python代码来查看PyTorch的版本：<code>import torch; print(torch.__version__)</code></li><li>记下显示的PyTorch版本号。例如，版本号可能类似于<code>1.8.1</code>。</li></ul></li><li><p><strong>检查兼容性</strong>：</p><ul><li>一旦你确定了各个组件的版本号，你可以查阅PyTorch的官方文档，了解哪个版本的PyTorch与哪个版本的CUDA和显卡驱动兼容。通常，PyTorch的文档会明确说明支持的CUDA版本范围。</li><li>如果你的PyTorch版本与你的CUDA版本和显卡驱动版本不兼容，你可能需要升级或降级其中一个或多个组件，以确保它们能够良好地协同工作。</li></ul></li></ul><blockquote><p>往往我们在实际项目时，起始首先确定的是PyTorch的版本，进而确定CUDA的版本，再根据CUDA的版本去查看自己平台的驱动是否支持。</p></blockquote><p>参考链接1：<a href="https://cloud.tencent.com/developer/article/2334017">深度学习|如何确定 CUDA+PyTorch 版本 - 腾讯云</a></p><h1 id="4-CUDA、CUDA-toolkit、CUDNN、NVCC关系"><a href="#4-CUDA、CUDA-toolkit、CUDNN、NVCC关系" class="headerlink" title="4 CUDA、CUDA toolkit、CUDNN、NVCC关系"></a>4 CUDA、CUDA toolkit、CUDNN、NVCC关系</h1><h2 id="4-1-CUDA-cudnn-CUDA-Toolkit-NVCC区别简介"><a href="#4-1-CUDA-cudnn-CUDA-Toolkit-NVCC区别简介" class="headerlink" title="4.1 CUDA/cudnn/CUDA Toolkit/NVCC区别简介"></a>4.1 CUDA/cudnn/CUDA Toolkit/NVCC区别简介</h2><ul><li>CUDA：为“GPU通用计算”构建的运算平台。</li><li>cudnn：为深度学习计算设计的软件库。</li><li>CUDA Toolkit (nvidia)： CUDA完整的工具安装包，其中提供了Nvidia驱动程序、开发CUDA程序相关的开发工具包等可供安装的选项。包括CUDA程序的编译器、IDE、调试器等，CUDA程序所对应的各式库文件以及它们的头文件。</li><li>CUDA Toolkit (Pytorch)： CUDA不完整的工具安装包，其主要包含在使用CUDA相关的功能时所依赖的动态链接库。不会安装驱动程序。</li><li>NVCC是CUDA的编译器，只是CUDA Toolkit中的一部分</li></ul><blockquote><p>注：CUDA Toolkit完整和不完整的区别：在安装了CUDA Toolkit (Pytorch)后，只要系统上存在与当前的CUDA Toolkit所兼容的Nvidia驱动，则已经编译好的CUDA相关的程序就可以直接运行，不需要重新进行编译过程。如需要为Pytorch框架添加CUDA相关的拓展时（Custom C++ and CUDA Extensions），需要对编写的CUDA相关的程序进行编译等操作，则需安装完整的Nvidia官方提供的CUDA Toolkit。</p></blockquote><h2 id="4-2-CUDA-Toolkit具体组成"><a href="#4-2-CUDA-Toolkit具体组成" class="headerlink" title="4.2 CUDA Toolkit具体组成"></a>4.2 CUDA Toolkit具体组成</h2><p>一般的结构中，include 包含头文件，bin 包含可执行文件，lib 包含程序实现文件编译生成的library，src包含源代码，doc或help包含文档，samples包含例子。</p><ol><li>Compiler：NVCC</li><li>Tools：分析器profiler、调试器debuggers等</li><li>Libraries：科学库和实用程序库</li><li>CUDA Samples：CUDA和library API的代码示例</li><li>CUDA Driver：驱动，需要与“有CUDA功能的GPU”和“CUDA”都兼容。CUDA工具包都对应一个最低版本的CUDA Driver，CUDA Driver向后兼容。</li></ol><h2 id="4-3-NVCC简介"><a href="#4-3-NVCC简介" class="headerlink" title="4.3 NVCC简介"></a>4.3 NVCC简介</h2><ul><li>NVCC其实就是CUDA的编译器，CUDA程序有两种代码， 在cpu上的host代码和在gpu上的device代码。</li><li><code>.cu后缀</code>：cuda源文件，包括host和device代码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nvcc编译例子</span></span><br><span class="line">nvcc –cuda x.cu –keep</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">x.cudafe1.gpu</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">x.cudafe2.gpu</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">x.cudafe1.cpp</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-4-Runtime-API-CUDA（nvcc-—version）"><a href="#4-4-Runtime-API-CUDA（nvcc-—version）" class="headerlink" title="4.4 Runtime API CUDA（nvcc —version）"></a>4.4 Runtime API CUDA（nvcc —version）</h2><p>对于 Pytorch 之类的深度学习框架而言，其在大多数需要使用 GPU 的情况中只需要使用 CUDA 的动态链接库支持程序的运行( Pytorch 本身与 CUDA 相关的部分是提前编译好的 )，就像常见的可执行程序一样，不需要重新进行编译过程，只需要其所依赖的动态链接库存在即可正常运行。<br>Anaconda 在安装 Pytorch 等会使用到 CUDA 的框架时，会自动为用户安装对应版本的 Runtime API cudatoolkit，其主要包含应用程序在使用 CUDA 相关的功能时所依赖的动态链接库。在安装了 Runtime API cudatoolkit 后，只要系统上存在与当前的Runtime API cudatoolkit 所兼容的 Nvidia 驱动，则已经编译好的 CUDA 相关的程序就可以直接运行，而不需要安装完整的 Nvidia 官方提供的 CUDA Toolkit .</p><p>pytorch和cudatoolkit版本并不是一一对应的关系，一个pytorch版本可以有多个cudatoolkit版本与之对应。例如1.5.1版本的pytorch，既可以使用9.2版本的cudatoolkit，也可以使用10.2版本的cudatoolkit。</p><p>可以查看pytorch官网对应的：<a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a></p><p>只指定pytorch版本来安装不一定是能work的，例如执行conda install pytorch=X.X.X -c pytorch时，conda会自动为你选择合适版本的 Runtime API cudatoolkit。但conda只能保证你的pytorch和cudatoolkit版本一定是对应的，但并不能保证pytorch可以正常使用，因为系统的Nvidia Driver有可能不支持你所安装的cudatoolkit版本。</p><p>所以，除非你对你的Nvidia driver版本很有自信，否则，还是先查看系统Driver API CUDA的版本</p><p>当然，如果你对pytorch版本有特别的要求，你可以同时指定pytorch和cudatoolkit的版本。如果这两个版本不能兼容，系统会报错</p><p>参考链接1：<a href="https://blog.csdn.net/qq_41094058/article/details/116207333">一文讲清楚CUDA、CUDA toolkit、CUDNN、NVCC关系 - CSDN</a><br>参考链接2：<a href="https://zhuanlan.zhihu.com/p/91334380">显卡，显卡驱动,nvcc, cuda driver,cudatoolkit,cudnn到底是什么？ - marsggbo的文章 - 知乎</a></p><h1 id="5-安装CUDA"><a href="#5-安装CUDA" class="headerlink" title="5 安装CUDA"></a>5 安装CUDA</h1><h2 id="5-1-下载CUDA安装包"><a href="#5-1-下载CUDA安装包" class="headerlink" title="5.1 下载CUDA安装包"></a>5.1 下载CUDA安装包</h2><p>CUDA官方下载链接：<a href="https://developer.nvidia.com/cuda-toolkit-archive">https://developer.nvidia.com/cuda-toolkit-archive</a></p><p>进入CUDA官方的下载链接后，查找自己需要下载的版本（以CUDA 11.3.1为例）：</p><p><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122180007447-3486066.png" style="zoom:50%"></p><p>点击自己需要下载的版本，一次选择操作系统、系统架构、系统版本和安装方式，在这里推荐使用 runfile(local) 的安装方式。</p><p><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122180053406-1868919368.png" style="zoom:70%"></p><p>完成上述操作后，网页下方弹出安装的命令，如下图所示：</p><p><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122180121597-1561022275.png"></p><h2 id="5-2-执行CUDA安装"><a href="#5-2-执行CUDA安装" class="headerlink" title="5.2 执行CUDA安装"></a>5.2 执行CUDA安装</h2><p>在Ubuntu 20.04 LTS系统的命令行中，按照以下命令进行安装。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：使用wget命令下载安装包</span></span><br><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.3.1/local_installers/cuda_11.3.1_465.19.01_linux.run`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：执行安装脚本</span></span><br><span class="line"><span class="built_in">sudo</span> sh cuda_11.3.1_465.19.01_linux.run</span><br></pre></td></tr></table></figure><br>执行上述命令后，等待1分钟左右，系统会弹出安装的协议，问你Do you accept the above EULA? 你需要在后面的光标处，填写accept，然后敲回车。</p><p><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122180226705-241142197.png" style="zoom:50%"></p><p>然后系统询问安装的内容，注意！！！ 一定要把Driver驱动这个给去掉（按空格键可以将 X 去掉），如果[ ]内是X说明是要安装的；如果[ ]是空，说明不安装。选择完成后，然后移动至Install 处，敲击回车。</p><p><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122180348780-1133238924.png" style="zoom:50%"></p><p>安装完成后，会在<code>/usr/local</code>目录下产生cuda-11.3目录，如下图所示：</p><p><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122180420130-923035408.png" style="zoom:50%"></p><p>这样说明CUDA-11.3版本安装完成了！</p><h2 id="5-3-配置环境变量"><a href="#5-3-配置环境变量" class="headerlink" title="5.3 配置环境变量"></a>5.3 配置环境变量</h2><p>使用 vim ~/.bashrc 命令进行编辑，在文件末尾添加下列代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cuda</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/local/cuda/lib64</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/cuda/bin</span><br></pre></td></tr></table></figure><p>然后执行 source ~/.bashrc 刷新文件使其生效。</p><h2 id="5-4-CUDA多版本管理"><a href="#5-4-CUDA多版本管理" class="headerlink" title="5.4 CUDA多版本管理"></a>5.4 CUDA多版本管理</h2><p>从图中可以看出，系统安装了11.1、11.3和11.6版本。</p><center><img src="https://img2024.cnblogs.com/blog/2609360/202501/2609360-20250122182157980-1256101233.png" style="zoom:50%"></center><p>由于环境变量的地址为<code>/usr/local/cuda</code>，且我们可以从图中发现目录下存在一个软链接，即：<code>/usr/local/cuda</code>指向了<code>/usr/local/cuda-11.6</code>链接，说明此时尽管安装了<code>CUDA 11.1</code>和 <code>CUDA 11.3</code>版本，但系统默认的环境版本为<code>11.6</code>。如何进行多版本的切换呢，比如想把CUDA版本切换成<code>11.3</code>版本（但是要保留<code>CUDA 11.1</code>和<code>11.6</code>版本），我们只需要修改软链接即可，将<code>CUDA 11.3</code>的软链接链接到cuda目录下，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除原有的软链接</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf cuda  </span><br><span class="line"><span class="comment"># 将cuda-11.3链接到cuda下</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/local/cuda-11.3 /usr/local/cuda  </span><br></pre></td></tr></table></figure><p>软链接重新生成后，使用<code>nvcc -V</code>命令可以查看当前的CUDA版本，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2021 NVIDIA Corporation</span><br><span class="line">Built on Sun_Mar_21_19:15:46_PDT_2021</span><br><span class="line">Cuda compilation tools, release 11.3, V11.3.58</span><br><span class="line">Build cuda_11.3.r11.3/compiler.29745058_0</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机与编程学习 </category>
          
          <category> 计算机介绍 </category>
          
          <category> 计算机硬件介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 硬件 </tag>
            
            <tag> GPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机主要硬件介绍</title>
      <link href="/2025/01/17/Introduce-major-computer-hardware/"/>
      <url>/2025/01/17/Introduce-major-computer-hardware/</url>
      
        <content type="html"><![CDATA[<p>作为专栏的第一篇文章，我想从计算机硬件的概念开始，后面再介绍各种计算机技术、软件的学习。注意：我这里只是简单介绍硬件概念，可能会涉及一点基本的原理，但不会太过深入各个硬件的内部原理。</p>  <div class="bvideo"><a href="//www.bilibili.com/video/BV1TL4y1N7ZM" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/afbb53bf20dc3fca23a4bd60d40c92f85bc8183f.png)">                    <i class="icon-video"></i>                </div>                <span class="duration">05:51:42</span>            </div>            <div class="bvideo-info">                <p class="title">计算机硬件基础</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>27.3万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>3564</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">Micro_Frank</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div> <h1 id="1-计算机分类"><a href="#1-计算机分类" class="headerlink" title="1 计算机分类"></a>1 计算机分类</h1><h2 id="1-1-台式机"><a href="#1-1-台式机" class="headerlink" title="1.1 台式机"></a>1.1 台式机</h2><p><img src="https://pica.zhimg.com/v2-3c4378ac35855f92f5312d87a56a3fe4_r.jpg" alt=""></p><h2 id="1-2-笔记本"><a href="#1-2-笔记本" class="headerlink" title="1.2 笔记本"></a>1.2 笔记本</h2><p><strong>笔记本电脑</strong>是自带屏幕和字母数字键盘的小型便携式个人电脑（PC），重量通常在1至3kg左右，屏幕尺寸大多在280至430毫米（11至17英寸）之间。</p><p>就现在来看，笔记本电脑从用途上一般可分为4种类型：<strong>商务型</strong>、<strong>性能型</strong>、<strong>多媒体型</strong>、<strong>特殊用途</strong>。</p><h2 id="1-3-服务器"><a href="#1-3-服务器" class="headerlink" title="1.3 服务器"></a>1.3 服务器</h2><p><strong>服务器</strong>（英语：server）指：</p><ul><li>一个管理资源并为用户提供服务的计算机软件，通常分为文件服务器（能使用户在其它计算机访问文件），数据库服务器和应用程序服务器。</li><li>运行以上软件的<strong>计算机</strong>，或称为<strong>网络主机</strong>（host）。</li></ul><p>服务器通常以<strong>网络</strong>作为介质，既可以通过<strong>内部网对内提供服务</strong>，也可以通过<strong>互联网对外提供服务</strong>。服务器的最大特点就是其强大的运算能力或是具备大量磁盘存储空间的电脑，使其能在短时间内完成大量工作及负载大量的文件资料存储，并为大量用户提供服务。20世纪90年代之后，随着调制解调器技术的发展，互联网由窄带的电话拨接，升级成为<strong>宽带网络</strong>。</p><p><img src="https://pica.zhimg.com/v2-d9bc061815ef80a083efb2c34b90a6de_r.jpg" alt=""></p><h3 id="1-3-1-具体定义"><a href="#1-3-1-具体定义" class="headerlink" title="1.3.1 具体定义"></a>1.3.1 具体定义</h3><p>服务器作为硬件来说，通常是指那些具有较高计算能力，能够提供给多个用户使用的计算机。服务器与PC机的不同点很多，例如PC机在一个时刻通常只为一个用户服务。服务器与主机不同，主机是通过终端给用户使用的，服务器是通过网络给客户端用户使用的，所以除了要拥有终端设备，还要利用网络才能使用服务器电脑，但用户连上线后就能使用服务器上的特定服务了。</p><p>和普通的个人电脑相比， 服务器需要<strong>连续的工作在7×24小时环境</strong>。这就意味着服务器需要更多的稳定性技术RAS，比如支持使用ECC存储器。</p><h3 id="1-3-2-主机与服务器的概念及区别"><a href="#1-3-2-主机与服务器的概念及区别" class="headerlink" title="1.3.2 主机与服务器的概念及区别"></a>1.3.2 主机与服务器的概念及区别</h3><ul><li><strong>主机</strong>：通常指的是个人计算机或工作站，它主要是通过终端（如显示器、键盘、鼠标等）直接给用户提供使用。用户坐在主机前，通过操作终端设备来使用主机上的各种软件和资源，例如在个人电脑上安装办公软件、游戏等，用户直接在电脑前进行操作。</li><li><strong>服务器</strong>：是一种为客户端用户提供特定服务的计算机。它不直接通过终端设备给用户提供使用，而是通过网络与客户端用户进行连接和交互。服务器上运行着各种服务程序，如Web服务、数据库服务、文件服务等，客户端用户通过网络请求服务器上的服务来获取所需资源或完成特定任务。</li></ul><p>参考连接：<a href="https://www.bilibili.com/video/BV1o8411n7Qn">什么是服务器？为什么卖这么贵？- 谈三圈 - 哔哩哔哩</a>：<strong>讲的特别好！！！</strong></p><h2 id="1-4-工作站"><a href="#1-4-工作站" class="headerlink" title="1.4 工作站"></a>1.4 工作站</h2><p><img src="https://pic4.zhimg.com/v2-67e5afae599c42ff3822fd9e60ade1a1_r.jpg" alt=""></p><p>是一种高端的微型计算机，它是为专业领域而设计的，主要供个人用户使用，提供了较主流普通个人计算机更高的性能，它们配置了专业级或高性能的CPU和GPU，较大的内存容量和大量的接囗。这使它们的多任务处理能力以及图型处理能力非常优越。 </p><p>简单来说，工作站有以下两个定义： </p><ol><li>比普通个人电脑性能更强大的电脑；</li><li>连接到服务器、大型机或超级计算机的终端，该终端通常是台式机，也可以是市场的收银机。</li></ol><p>参考连接：<a href="https://www.bilibili.com/video/BV1Q34y1P7sE">随便聊聊：工作站和服务器的十个区别点 - 哔哩哔哩</a></p><h1 id="2-个人电脑以及主板的用途"><a href="#2-个人电脑以及主板的用途" class="headerlink" title="2 个人电脑以及主板的用途"></a>2 个人电脑以及主板的用途</h1><h2 id="2-1-机箱"><a href="#2-1-机箱" class="headerlink" title="2.1 机箱"></a>2.1 机箱</h2><p><strong>机箱</strong>（computer case或chassis）是个人电脑中用来容纳大部分硬件的<strong>外壳</strong>，装在机箱内的部件（中央处理器、主板、存储设备、显卡、声卡等）通常称作内部硬件，与外部设备（显示器、音箱、键盘、鼠标等）通过电缆相连。<strong>机箱与其容纳的硬件形成的总体被称为主机</strong>。</p><p><img src="https://pic1.zhimg.com/v2-7343bf1959502940a5b4faed819af0bc_r.jpg" alt=""></p><h2 id="2-2-主板"><a href="#2-2-主板" class="headerlink" title="2.2 主板"></a>2.2 主板</h2><h3 id="2-2-1-主板的概念"><a href="#2-2-1-主板的概念" class="headerlink" title="2.2.1 主板的概念"></a>2.2.1 主板的概念</h3><p>主板是计算机的主要<strong>电路板（PCB）</strong>。计算机的其他硬件一般直接插入到主板中来交换信息。主板通常由<strong>芯片组</strong>、<strong>BIOS</strong>、<strong>印表端口</strong>、<strong>各种周边设备连接端口</strong>（如网络端口、Audio、USB）、<strong>PS/2键盘/鼠标接口</strong>和<strong>PCIe/PCI扩展插槽</strong>等组成。</p><p><img src="https://pic2.zhimg.com/v2-596d671d101cd3a38f6bf8fa36e88105_r.jpg" alt=""></p><h3 id="2-2-2-主板主要组成"><a href="#2-2-2-主板主要组成" class="headerlink" title="2.2.2 主板主要组成"></a>2.2.2 主板主要组成</h3><p>下图的LGA 1366主板包含南桥和北桥，这是最后一代使用双芯片的主板。之后所有Intel与AMD的主板仅有南桥，北桥已集成到CPU。</p><p><img src="https://pic2.zhimg.com/v2-bbc1c24f10e7bb3770bdcc1456f034c3_r.jpg" alt=""></p><p>1、CPU插座 (LGA 1366)；2、北桥（被散热片覆盖）；3、南桥（被散热片覆盖）；4、存储器插座（三通道）；5、PCI扩展槽；6、PCI Express扩展槽；7、跳线；8、控制面板（开关掣、LED等）；9、20+4pin主板电源；10、4+4pin处理器电源；11、背板I/O；12、前置USB针脚；13、前置面板音效针脚；14、SATA插座；<br>15、ATA插座（大部分Intel Sandy Bridge微架构以后的家用主板都已舍弃IDE接口）；<br>16、软盘驱动器插座（2010年代起，绝大多数主板已舍弃软盘驱动器接口）</p><p>选购主板时候，最重要的一个部分就是看<strong>接口和频率</strong>。</p><h3 id="2-2-3-主板上常见接口与频率"><a href="#2-2-3-主板上常见接口与频率" class="headerlink" title="2.2.3 主板上常见接口与频率"></a>2.2.3 主板上常见接口与频率</h3><p><strong>（一）主板接口</strong></p><p><strong>（二）主板频率</strong></p><ul><li>主板频率通常指的是主板处理器总线的频率，它是主板上各个组件之间通信的速度基准。</li><li>主板频率并不直接决定计算机的整体性能，但它对内存和其他组件的兼容性有重要影响。</li></ul><blockquote><p>注意1：主板频率和CPU频率是两个独立的参数，它们之间没有直接的决定关系。主板频率主要指的是主板上处理器总线的频率，它是主板上各个组件之间通信的速度基准。而CPU频率，即处理器的主频，表示CPU每秒钟可以执行的指令周期数，是CPU性能的关键指标之一。</p><p>注意2：内存条作为主板上的一个硬件，而主板控制不同硬件之间的通信频率，因此与CPU不同，<strong>主板频率会影响内存频率</strong>‌。主板对内存频率的影响主要体现在主板的芯片组支持的内存频率范围上。芯片组决定了主板可以支持的最高内存频率，如果选择了超出主板支持范围的内存，它可能无法正常工作或者只能以主板所支持的最高频率运行‌。</p><p>此外，主板的电源供应能力也会对内存模块的稳定性产生影响。一些高频率的内存模块需要较高的电压供应以保持稳定运行，如果主板的电源供应能力不足，内存模块可能无法正常工作或者频繁出现错误‌。</p></blockquote><h3 id="2-2-4-主板的购买"><a href="#2-2-4-主板的购买" class="headerlink" title="2.2.4 主板的购买"></a>2.2.4 主板的购买</h3><p>常见的主板厂商有：‌‌华硕（ASUS）、‌技嘉（GIGABYTE）、‌微星（MSI）、‌映泰（BIOSTAR）‌、‌华擎、‌七彩虹（Colorful）、‌昂达（ONDA）、‌梅捷（SOYO）、‌艾尔莎‌等。</p><h1 id="3-CPU处理器"><a href="#3-CPU处理器" class="headerlink" title="3 CPU处理器"></a>3 CPU处理器</h1><h2 id="3-1-CPU的定义"><a href="#3-1-CPU的定义" class="headerlink" title="3.1 CPU的定义"></a>3.1 CPU的定义</h2><p><strong>中央处理器</strong>（英语：<strong>C</strong>entral<strong>P</strong>rocessing<strong>U</strong>nit，缩写：<strong>CPU)</strong>，简称处理器，是整个计算机系统中最重要的部件之一，控制整个电脑主要的<strong>算术逻辑单元（arithmetic logic unit，简称ALU）</strong>，使得计算机程序和操作系统可在它上面执行，其性能直接影响计算机系统的工作效率，位于图5中的1区域。</p><h2 id="3-2-CPU常见指标"><a href="#3-2-CPU常见指标" class="headerlink" title="3.2 CPU常见指标"></a>3.2 CPU常见指标</h2><h3 id="3-2-1-CPU核心与线程"><a href="#3-2-1-CPU核心与线程" class="headerlink" title="3.2.1 CPU核心与线程"></a>3.2.1 CPU核心与线程</h3><p><strong>（一）核心（Cores）和线程（Threads）的定义</strong></p><ul><li><p><strong>CPU核心的定义：</strong>是指CPU内部能够独立执行程序指令的<strong>物理单元</strong>。每个核心可被看作是一个小型处理器，它有自己的算术逻辑单元（ALU）、浮点运算单元（FPU）、寄存器等组件。</p><ul><li>功能：多核处理器可以在同一时间并行运行多个进程或线程，从而提高系统的整体性能。例如，在一个多核系统中，一个核心可以处理视频播放，另一个核心可以处理文档编辑，而第三个核心可以进行网络浏览。</li></ul></li><li><p><strong>CPU线程的定义</strong>：是在操作系统层面定义的一个执行路径，它是比进程更小的调度单位。在单个核心上，线程表现为一系列指令序列的执行；而在多核或多线程环境中，不同线程可以在不同的核心上同时执行。</p><ul><li><strong>超线程技术（Hyper-Threading Technology, HTT）</strong>：这是英特尔的一项技术，它使得单个物理核心看起来像是两个逻辑核心给操作系统。这样，操作系统就可以为每个“虚拟”核心分配不同的线程。这并不意味着实际性能会翻倍，但在某些情况下，比如当一个线程处于等待状态时，另一个线程可以利用这个空闲的时间片来执行任务，从而提高效率。</li></ul></li><li><p><strong>区别与联系</strong></p><ul><li>区别：核心是硬件上的实体结构，而线程则是操作系统用来管理和调度的任务单位。简单来说，核心负责真正的工作，而线程是告诉核心要做什么的方式。</li><li>联系：通过超线程技术，一个物理核心可以模拟出两个逻辑核心，即两条线程。这意味着即使在一个核心内，也可以同时处理更多的任务。然而，真正的并行性来自于多个物理核心的存在，因为它们可以在完全相同的时间点上各自处理不同的任务。</li></ul></li></ul><p><strong>（二）举例说明</strong></p><p>如下面的图8所示，图中显示该CPU为16核24线程。</p><ul><li><strong>核心数：16</strong>，这意味着该CPU拥有16个物理核心（cores），其中包含了性能核心（Performance Cores, P-cores）和能效核心（Efficient Cores, E-cores）。对于i9-12900K来说，它有8个P-cores和8个E-cores。</li><li><strong>线程数：24</strong>，24线程（threads）是指由于超线程技术（Hyper-Threading Technology），每个性能核心可以处理两个线程。所以，8个性能核心提供16个线程，加上8个能效核心各自处理一个线程，总共提供了24个线程。</li></ul><h3 id="3-2-2-主频-VS-单核睿频"><a href="#3-2-2-主频-VS-单核睿频" class="headerlink" title="3.2.2 主频 VS 单核睿频"></a>3.2.2 主频 VS 单核睿频</h3><p><strong>主频（Base Frequency）：</strong>是指CPU在标准工作条件下稳定运行的基础频率，即CPU设计时所设定的一个长期工作的安全频率。它通常是衡量CPU性能的一个基础指标。<strong>表现形式</strong>：通常以GHz（千兆赫兹）为单位表示，例如3.2 GHz意味着每秒钟可以执行32亿个周期或指令。</p><p><strong>Turbo Boost（睿频加速）技术</strong>：当CPU检测到系统工作负载较低，且温度、功耗和电流都在安全范围内时，Turbo Boost技术允许某些或全部核心以高于其标称的基础频率的速度运行。这种频率的提升是自动的，并根据当前的工作负载进行调整。</p><p><strong>单核睿频是指处理器中的一个单独核心所能达到的最大睿频频率</strong>。对于某些高端处理器型号，如下面图8中的CPU提到的Intel i9-12900K，它的单核睿频至高可达5.2GHz，这意味着在特定条件下，如果有任务被分配给一个核心，该核心可以加速到最高5.2GHz来快速完成任务。</p><p><strong>应用场景：</strong>单核睿频特别适用于那些对单线程性能要求极高的应用，例如视频编辑软件中的编码过程、3D渲染、科学计算等。在这种情况下，即使其他核心没有满载，也可以将一个核心推到极限，以便更快地完成任务。</p><ul><li><strong>小结：主频　VS　睿频</strong></li><li><strong>主频</strong>是CPU的“默认”频率，代表了CPU在正常工作状态下能够稳定运行的速度。</li><li><strong>睿频</strong>则是CPU为应对瞬时高负载而临时提升频率，它允许CPU在短时间内突破基础频率，提供额外的性能。</li></ul><h3 id="3-2-3-一级、二级、三级缓存"><a href="#3-2-3-一级、二级、三级缓存" class="headerlink" title="3.2.3 一级、二级、三级缓存"></a>3.2.3 一级、二级、三级缓存</h3><p><strong>（一）一级、二级、三级缓存的概念解析</strong></p><ul><li><strong>位置和容量</strong><ul><li>‌<strong>一级缓存（L1 Cache）</strong>‌：位于CPU核心内部，是距离CPU最近的一层缓存。由于其位置接近CPU核心，访问速度非常快，通常在几十KB到几百KB之间。一级缓存主要用于存储当前正在执行的指令和即将要处理的数据，容量较小但访问速度极快。‌</li><li>‌<strong>二级缓存（L2 Cache）</strong>‌：位于CPU芯片内部但距离核心稍远，访问速度比一级缓存慢但仍然比内存快很多。二级缓存的容量通常在几百KB到几MB之间，用于存储CPU接下来可能会用到的数据和指令。</li><li>‌<strong>三级缓存（L3 Cache）</strong>‌：位于CPU和内存之间，容量比二级缓存更大，通常为几MB到几十MB。三级缓存用于存储多个CPU核心共享的数据，以提高多核CPU的计算性能。‌</li></ul></li><li><strong>速度和对性能的影响</strong><ul><li>‌<strong>一级缓存</strong>‌：由于其位置接近CPU核心，访问速度最快，延迟极低。高命中率的一级缓存对于提高CPU执行单个指令的效率至关重要，能够减少等待数据传输的时间，提升程序运行初期的流畅度和效率。</li><li>‌<strong>二级缓存</strong>‌：访问速度比一级缓存慢，但仍然比内存快很多。二级缓存充当了一级缓存和内存之间的缓冲区域，用于存储CPU接下来可能会用到的数据和指令，扩大缓存的数据储备量。</li><li>‌<strong>三级缓存</strong>‌：访问速度较慢，但其容量更大，用于存储多个CPU核心共享的数据。三级缓存的设计提高了多核CPU的计算性能，减少了从内存中读取数据的次数。</li></ul></li></ul><p><strong>（二）内存 VS 缓存</strong></p><ol><li>位置与层次结构<br><strong>缓存</strong>：位于CPU内部或非常接近CPU的位置，分为多个层级（L1、L2、L3），越靠近CPU核心的缓存层级访问速度越快，缓存（Cache）通常位于CPU与内存之间，用于提高数据访问速度，减少CPU对内存的访问次数。<br><strong>内存</strong>：位于主板上，距离CPU相对较远，通过内存控制器与CPU通信。</li><li>容量<br><strong>缓存</strong>：容量较小，通常从几十KB到几十MB不等，具体取决于CPU型号和架构。<br><strong>内存</strong>：容量较大，现代计算机系统的内存可以从几GB到数百GB甚至更多。</li><li>访问速度<br><strong>缓存</strong>：由于其物理位置靠近CPU且设计优化，缓存的访问速度极快，延迟低至几个纳秒。<br><strong>内存</strong>：虽然比硬盘快得多，但相比缓存，内存的访问速度较慢，延迟通常在数十纳秒到几百纳秒之间。</li><li>成本与技术实现<br><strong>缓存</strong>：采用更昂贵的SRAM（静态随机存取存储器）技术实现，这种技术提供了高速度和低延迟，但成本较高且单位容量的价格也高。<br><strong>内存</strong>：也称为RAM（随机存取存储器），一般使用DDR SDRAM（双倍速率同步动态随机存取存储器）等技术，提供较大的容量和相对较低的成本。<br>与之相对，非易失性存储器（如硬盘、闪存等）在断电后仍能长期保存数据，因此更适合用于长期存储‌。</li><li>数据持久性<br><strong>缓存</strong>：是易失性的，即断电后缓存中的数据会丢失，但它不是为长期存储设计的，而是作为临时存储区域来加速数据访问。<br><strong>内存</strong>：同样是易失性的，在断电后也会丢失数据，主要用于运行时的数据存储，如程序代码、变量等。</li><li>功能角色<br><strong>缓存</strong>：充当CPU和主内存之间的桥梁，用来存放最近或最有可能被再次访问的数据副本，以减少CPU等待时间，提高系统效率。<br><strong>内存</strong>：是操作系统和应用程序的主要工作空间，所有正在执行的程序和数据都必须先加载到内存中才能被CPU处理。</li><li>管理机制<br><strong>缓存</strong>：由硬件自动管理，CPU和缓存控制器根据算法决定哪些数据应该保留在缓存中，用户通常不需要直接干预。<br><strong>内存</strong>：可以通过操作系统的虚拟内存管理和编程语言提供的内存分配函数进行一定程度的手动控制，尽管大部分情况下也是透明地由操作系统管理。</li></ol><h3 id="3-2-4-什么是锁倍频和不锁倍频"><a href="#3-2-4-什么是锁倍频和不锁倍频" class="headerlink" title="3.2.4 什么是锁倍频和不锁倍频"></a>3.2.4 什么是锁倍频和不锁倍频</h3><p><strong>锁倍频</strong>和<strong>不锁倍频</strong>是 CPU 中与 倍频（Multiplier）相关的两个概念，主要影响 CPU 的超频能力。要理解这两个概念，先了解以下基础知识：</p><ul><li>什么是倍频（Multiplier）<ul><li>倍频是CPU时钟频率计算的参数之一，公式为：<code>CPU频率 = 外频（Base Clock） × 倍频（Multiplier）</code> 外频：主板提供的基础时钟频率，通常是固定的（如 100MHz）。<br>倍频：CPU 内部的一个乘数，用来将外频放大，最终决定 CPU 的运行频率。</li><li>例如：外频 = 100MHz，倍频 = 40，则 CPU频率 = 100 × 40 = 4.0GHz。</li></ul></li></ul><p><strong>（一）锁倍频</strong></p><p>锁倍频的 CPU 意味着其倍频值被硬件或固件限制，用户无法自由调节，只有固定的外频和倍频可以使用。</p><ul><li>特点：<ul><li>限制用户调节倍频：用户不能通过 BIOS 或其他工具更改倍频值来提升 CPU 频率。</li><li>限制超频能力：锁倍频的 CPU 只能通过调整外频进行超频，但外频调节会影响整个系统（如内存、总线等），难度更大且风险更高。</li><li>通常是标准版本：大多数普通消费者级 CPU 都是锁倍频的，例如 Intel Core i5-12400。</li></ul></li><li>适用场景：不追求超频的用户，只需要稳定运行的办公或日常使用场景。</li></ul><p><strong>（二）不锁倍频</strong></p><p>不锁倍频的CPU意味着其倍频值是开放的，用户可以自由调节，进而改变 CPU 的工作频率。</p><ul><li>特点：<ul><li>支持倍频调节：用户可以通过 BIOS 或超频工具自由调节倍频值，从而提高 CPU 性能。</li><li>超频潜力大：可在外频固定的情况下，调整倍频实现更高的频率，超频更加稳定且安全。</li><li>通常是高性能版本：如Intel的K系列（如 i7-13700K）和 AMD的X系列（如 Ryzen 7 7800X）处理器。</li></ul></li><li>适用场景：性能要求高且有超频需求的用户（如游戏玩家、内容创作者）；喜欢折腾硬件、优化性能的爱好者。</li></ul><h2 id="3-3-主要的CPU生产厂商"><a href="#3-3-主要的CPU生产厂商" class="headerlink" title="3.3 主要的CPU生产厂商"></a>3.3 主要的CPU生产厂商</h2><h3 id="3-3-1-英特尔Intel"><a href="#3-3-1-英特尔Intel" class="headerlink" title="3.3.1 英特尔Intel"></a>3.3.1 英特尔Intel</h3><p>英特尔公司成立于 1968 年，是全球半导体行业的领导者之一，在 CPU 领域更是长期占据着重要地位。</p><p>英特尔在 CPU 发展史上有着众多里程碑式的成就。早期，其推出的<strong>4004处理器</strong>是世界上第一款商用微处理器，标志着个人计算机时代的开端。随后，英特尔不断迭代升级，如<strong>8086</strong>、80286、80386和80486等系列处理器逐渐提升了性能并扩大了应用范围。进入<strong>奔腾（Pentium）</strong>时代，英特尔更是凭借强大的研发实力和市场推广，使其 CPU 广泛应用于全球个人电脑市场。</p><ul><li><strong>产品系列</strong><ul><li><strong>酷睿(Core)系列</strong>：面向主流桌面和笔记本电脑市场，包括酷睿i3、i5、i7 和 i9 等不同定位的产品线。<ul><li>酷睿 i3 主要针对入门级用户，提供基本的办公和娱乐性能；</li><li>酷睿 i5 则在性能上有所提升，适合一般游戏玩家和对性能有一定要求的专业软件用户；</li><li>酷睿 i7 具备更强大的多核性能，常用于高性能工作站和游戏主机；</li><li>酷睿 i9 是旗舰产品，有超多核心和超高频率，满足极端专业应用如3D渲染、视频编辑等对计算需求高的。</li></ul></li><li><strong>至强系列</strong>：主要应用于<strong>服务器和工作站</strong>领域。至强处理器具备强大的计算能力、高可靠性和稳定性，支持多路并行处理，能够应对大规模数据中心、云计算等复杂计算任务。例如，至强可扩展处理器家族在数据处理、人工智能训练等方面表现卓越，为企业级应用提供了坚实的计算基础。</li><li><strong>奔腾和赛扬系列</strong>：定位入门级市场，价格较为亲民。奔腾系列相对赛扬系列性能略高，主要满足简单办公、上网浏览等基本应用场景，常用于一些低成本台式机和笔记本电脑，在新兴市场和教育等领域有着广泛的应用。</li></ul></li></ul><p><img src="https://pic1.zhimg.com/v2-beb13d791aa21a6d1a1187faadf44856_r.jpg" alt=""></p><h3 id="3-3-2-超威半导体（AMD）"><a href="#3-3-2-超威半导体（AMD）" class="headerlink" title="3.3.2 超威半导体（AMD）"></a>3.3.2 超威半导体（AMD）</h3><p>AMD 是英特尔在 CPU 市场的主要竞争对手之一，成立于 1969 年，在半导体领域也有着深厚的技术底蕴和丰富的发展历程。</p><p>AMD 在早期主要以生产英特尔兼容的 CPU 产品起步。在发展过程中，AMD经历了起伏，例如在与英特尔的技术竞争中，曾在某些时期落后，但也不断推出创新产品实现逆袭。如<strong>K7系列</strong>处理器是AMD的重要突破，采用了新的架构设计，性能上有了显著提升。近年来AMD凭借<strong>锐龙（Ryzen）系列</strong>处理器的成功，重新在高性能CPU市场占据重要地位，并且在服务器市场也逐渐扩大影响力，对英特尔的传统优势地位形成了强有力的挑战。</p><ul><li><strong>产品系列</strong><ul><li><strong>锐龙(Ryzen)系列：</strong>面向桌面和笔记本电脑市场的高性能产品。锐龙桌面处理器涵包括锐龙3、锐龙5、锐龙7 到锐龙9等多个级别，与<strong>英特尔酷睿系列</strong>形成了竞争。<ul><li>锐龙 3 适合入门级游戏和日常办公；</li><li>锐龙 5 的性价比表现好，能满足大多数游戏玩家和普通专业软件使用；</li><li>锐龙 7 具备强大的多核性能，可与英特尔酷睿i7相媲美；</li><li>锐龙 9 则是顶级的桌面处理器产品，拥有超多核心和高频率，在高端游戏和专业工作站中表现卓越。</li></ul></li><li><strong>霄龙系列：</strong>主要针对服务器市场。霄龙处理器具有高核心数、大内存带宽和出色的I/O性能等特点，能够满足数据中心大规模数据处理、云计算、虚拟化等复杂业务需求。例如，霄龙处理器在一些超大规模数据中心中被广泛应用，与<strong>英特尔至强系列</strong>在服务器市场展开激烈竞争。</li></ul></li></ul><h3 id="3-3-3-苹果"><a href="#3-3-3-苹果" class="headerlink" title="3.3.3 苹果"></a>3.3.3 苹果</h3><p>后期有需要再更新，这就不详述苹果的CPU了，因为我没有用过苹果的产品。</p><h2 id="3-4-CPU命名分析"><a href="#3-4-CPU命名分析" class="headerlink" title="3.4 CPU命名分析"></a>3.4 CPU命名分析</h2><p><img src="https://pic1.zhimg.com/v2-7521b5a4b74c302cb08d099c93ab7d20_r.jpg" alt=""></p><h3 id="3-4-1-Intel-CPU命名"><a href="#3-4-1-Intel-CPU命名" class="headerlink" title="3.4.1 Intel CPU命名"></a>3.4.1 Intel CPU命名</h3><p>Intel CPU的命名结构通常为：<code>品牌 + 产品线 + 系列 + 代数 + 具体型号 + 后缀</code> 。</p><p>例如：图9中的Intel Core i9-12900K。</p><p><img src="https://pic4.zhimg.com/v2-0b0729b7e7bfcea96c80bb538b7ae3ed_r.jpg" alt=""></p><blockquote><p>其他系列命名：<br>至强*Xeon*：用于服务器和工作站，型号示例：Intel Xeon Platinum 8280<br>—— Platinum 表示性能等级（Platinum &gt; Gold &gt; Silver &gt; Bronze）。<br>—— 后续数字表示代数和性能。<br>Pentium 和 Celeron：Pentium Gold G7400，简单直接，Gold 表示性能稍高。</p></blockquote><h3 id="3-4-2-AMD-CPU命名"><a href="#3-4-2-AMD-CPU命名" class="headerlink" title="3.4.2 AMD CPU命名"></a>3.4.2 AMD CPU命名</h3><p>AMD CPU的命名结构通常为：<code>品牌 + 产品线 + 系列 + 代数 + 具体型号 + 后缀</code></p><p>例如：AMD Ryzen 7 7800X。</p><p><img src="https://pic4.zhimg.com/v2-6a91922cd98d1ff0f0cfa8e2b15a5183_r.jpg" alt=""></p><h3 id="3-4-3-Intel-与-AMD-命名对比"><a href="#3-4-3-Intel-与-AMD-命名对比" class="headerlink" title="3.4.3 Intel 与 AMD 命名对比"></a>3.4.3 Intel 与 AMD 命名对比</h3><p><img src="https://pic2.zhimg.com/v2-3d1f6bea27be6399ab63d564fdf96919_r.jpg" alt=""></p><p>本小节参考连接1：<a href="https://blog.csdn.net/weixin_73012949/article/details/143997602">CPU命名那些事_cpu命名规则标识的含义-CSDN博客</a><br>本小节参考连接2：<a href="https://www.intel.cn/content/www/cn/zh/processors/processor-numbers.html">关于我们的最新处理器和命名规则更新的简要指南 - Intel官方</a><br>本小节参考链接3：<a href="https://www.amd.com/zh-cn/products/specifications/processors.html">AMD 产品规格 处理器规格 - AMD官方</a><br>本小节参考连接4：<a href="https://www.bilibili.com/video/BV17u4y1979X">【硬核科普】CPU是如何命名的，数字更大就一定更好吗？- 哔哩哔哩</a></p><h2 id="3-5-CPU性能天梯图"><a href="#3-5-CPU性能天梯图" class="headerlink" title="3.5 CPU性能天梯图"></a>3.5 CPU性能天梯图</h2><p><a href="https://www.mydrivers.com/zhuanti/tianti/cpu/">桌面CPU性能天梯图 - 驱动之家(快科技)</a></p><h2 id="3-6-关于CPU的一些个人感兴趣问题"><a href="#3-6-关于CPU的一些个人感兴趣问题" class="headerlink" title="3.6 关于CPU的一些个人感兴趣问题"></a>3.6 关于CPU的一些个人感兴趣问题</h2><h3 id="3-6-1-CPU为什么不把面积做大一些，用面积、数量换性能？"><a href="#3-6-1-CPU为什么不把面积做大一些，用面积、数量换性能？" class="headerlink" title="3.6.1 CPU为什么不把面积做大一些，用面积、数量换性能？"></a>3.6.1 CPU为什么不把面积做大一些，用面积、数量换性能？</h3><p>参考回答1：<a href="https://www.zhihu.com/question/629140018">CPU为什么不把面积做大一些，用面积、数量换性能？ - 知乎</a><br>参考回答2：<a href="https://www.zhihu.com/question/390598095">芯片为什么不把体积做大点呢？- 知乎</a><br>参考回答3：<a href="http://m.iweb-edu.com/news/xuexijiqiao/566.html">把个人电脑上的 CPU 拔下来插到服务器上行不行？</a></p><h1 id="4-内存"><a href="#4-内存" class="headerlink" title="4 内存"></a>4 内存</h1><h2 id="4-1-内存的概念"><a href="#4-1-内存的概念" class="headerlink" title="4.1 内存的概念"></a>4.1 内存的概念</h2><p><img src="https://pic4.zhimg.com/v2-5ab1d7be84241d717a7510d4bb34e4a7_r.jpg" alt=""></p><p><strong>随机存储器</strong>（Random-access memory，<strong>RAM</strong>），又称RAM存储器，又称 $\large{\boldsymbol{\color\red{\text{运行内存}}}}$ ，是一种可随机读写的存储器，与只读存储器（ROM）一起构成主存储器， $\large{\boldsymbol{\color\orange{\text{与CPU直接交换数据}}}}$ 。与ROM不同，RAM在电源关闭时<strong>会丢失存储数据</strong>，是一种 $\large{\boldsymbol{\color\green{\text{易失性（volatile）}}}}$ 存储器。它可以随时读写（刷新时除外，见下文），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时资料存储介质。 </p><blockquote><p>RAM就是所说的<strong>运行内存</strong>，之前一直不知道之前买手机中的指标：8+256、12+512等。<br>其中，前面的8、12就是运行内存。</p></blockquote><h2 id="4-2-RAM的分类"><a href="#4-2-RAM的分类" class="headerlink" title="4.2 RAM的分类"></a>4.2 RAM的分类</h2><p>RAM 存储器可以进一步分为<strong>静态随机存储器（SRAM）</strong>和<strong>动态随机存储器（DRAM）</strong>两大类。SRAM 具有快速访问的优点，但生产成本较为昂贵，一个典型的应用是 $\large{\boldsymbol{\color\purple{\text{缓存}}}}$ 。而 DRAM 由于具有较低的单位容量价格，所以被大量的采用作为系统的主存储器。 </p><p><img src="https://pic3.zhimg.com/v2-d3cdbfa59871cd6f12b14f37ad7763fa_r.jpg" alt=""></p><h2 id="4-3-查看内存的使用"><a href="#4-3-查看内存的使用" class="headerlink" title="4.3 查看内存的使用"></a>4.3 查看内存的使用</h2><p>最简单的一种方法是使用电脑的任务管理器，如如14所示。</p><p><img src="https://picx.zhimg.com/v2-c26aa8777983d5dc07a127f5989b55bf_r.jpg" alt=""></p><h2 id="4-4-购买内存条"><a href="#4-4-购买内存条" class="headerlink" title="4.4 购买内存条"></a>4.4 购买内存条</h2><h3 id="4-4-1-常见的内存条厂商"><a href="#4-4-1-常见的内存条厂商" class="headerlink" title="4.4.1 常见的内存条厂商"></a>4.4.1 常见的内存条厂商</h3><p>常见的内存条品牌包括金士顿、威刚、美商海盗船、宇瞻、芝奇、十铨、海力士、英睿达、骇客和金泰克‌‌。可以去<a href="https://www.cnpp100.com/">品牌Top100网站</a>上查看内存条的品牌排行。</p><h3 id="4-4-2-一个京东网页的内存条界面"><a href="#4-4-2-一个京东网页的内存条界面" class="headerlink" title="4.4.2 一个京东网页的内存条界面"></a>4.4.2 一个京东网页的内存条界面</h3><p><img src="https://pic1.imgdb.cn/item/67a60d9ed0e0a243d4fc9ef3.png"></p><ul><li><strong>图中参数简介：</strong><ul><li><code>DDR 4</code>：表示使用的是第4代DDR技术；</li><li><code>3200</code>：表示此内存条的频率是3200Hz。 </li><li>内存频率指的是内存模块的工作速度，用MHz（兆赫）表示。</li><li>内存频率越高，内存的数据传输速度就越快，从而提高计算机的整体性能。</li><li><strong>内存的实际工作频率通常由主板芯片组决定，而不是CPU</strong>。</li></ul></li><li><strong>购买的注意事项：</strong><ul><li>要注意主板支持的内存条型号</li><li>主板的频率主要通过其芯片组和电源供应能力来影响内存频率。‌<strong>芯片组决定了主板可以支持的最高内存频率范围</strong>‌，例如，某个主板可能支持DDR4内存，频率范围为2133MHz至3200MHz。如果选择了超出这个范围的内存，它可能无法正常工作或者只能以主板所支持的最高频率运行。</li></ul></li></ul><h2 id="4-5-内存技术"><a href="#4-5-内存技术" class="headerlink" title="4.5 内存技术"></a>4.5 内存技术</h2><p>内存条技术经历了SIMM、FPMDRAM、EDODRAM、SDRSDRAM、RambusDRAM等时代，一直发展到现代的<strong>DDR技术</strong>。</p><h3 id="4-5-1-最早的内存"><a href="#4-5-1-最早的内存" class="headerlink" title="4.5.1 最早的内存"></a>4.5.1 最早的内存</h3><p>最早的内存可追溯到1951年，J.  Presper  Eckert在20世纪40年代为EDVAC计算机发明了延迟线存储器，是世界第一条内存，采用水银延迟线制作的易失性存储器，分布在32个槽中，每个槽5英尺长，里面包含32个内存位置，共1024个位置。不过，建造时只实现了一半，仅有512个字节大小。其工作原理就是通过用压力波的传播延迟来存储数据。</p><p><img src="https://pica.zhimg.com/v2-d10b7fb1dc4a42e1b4d08c2de90715ae_r.jpg" alt=""></p><h3 id="4-5-2-古老的SIMM时代"><a href="#4-5-2-古老的SIMM时代" class="headerlink" title="4.5.2 古老的SIMM时代"></a>4.5.2 古老的SIMM时代</h3><p>其实在最初的个人电脑上是没有内存条的，内存是直接以DIP芯片的形式安装在主板的DRAM插座上面，需要安装8到9颗这样的芯片，容量只有64KB到256KB，要扩展相当困难。直到80286的出现硬件与软件都在渴求更大的内存，只靠主板上的内存已经不能满足需求了，于是内存条就诞生了。</p><p>SIPP很快就被SIMM（Single In-line Memory  Modules）取代了，两侧金手指传输相同的信号，早期的内存频率与CPU外频是不同步的，是异步DRAM，细分下去的话包括FPM  DRAM（Fast Page Mode DRAM）与EDO DRAM（Extended data out DRAM），常见的接口有30pin  SIMM与72pin SIMM，工作电压都是5V第一代SIMM内存有30个引脚，单根内存的数据总线也只有8bit，后续又诞生了72个引脚的SIMM内存，单根内存位宽也增加到了32位，<strong>古早的奔腾系列处理器用的就是这种内存</strong>。</p><p><img src="https://pic1.zhimg.com/v2-f81f6f947b37ce221a39d802ec63de5a_r.jpg" alt=""></p><h3 id="4-5-3-FPM-DRAM"><a href="#4-5-3-FPM-DRAM" class="headerlink" title="4.5.3 FPM DRAM"></a>4.5.3 FPM DRAM</h3><p>FPM DRAM是从早期的Page Mode DRAM上改良过来的，当它在读取同一列数据是可以连续传输行位址，不需要再传输列位址，可读出多笔资料，这种方法当时是很先进的，不过现在看来就很没效率。</p><p><img src="https://pic4.zhimg.com/v2-98f964fcd2e9bcf5e77489b834b962af_r.jpg" alt=""></p><h3 id="4-5-4-EDO-DRAM"><a href="#4-5-4-EDO-DRAM" class="headerlink" title="4.5.4 EDO DRAM"></a>4.5.4 EDO DRAM</h3><p>再往后，EDO DRAM则在90年代时一直盛行，凭借着制造工艺的飞速发展，EDO内存在成本和容量上都有了很大的突破，单条EDO内存容量从4MB到16MB不等。</p><p><img src="https://pic4.zhimg.com/v2-0d1f15c747060a2138351e6205ef006f_r.jpg" alt=""></p><h3 id="4-5-5-SDR-SDRAM内存"><a href="#4-5-5-SDR-SDRAM内存" class="headerlink" title="4.5.5 SDR SDRAM内存"></a>4.5.5 SDR SDRAM内存</h3><p>然而随着CPU的升级EDO内存已经不能满足系统的需求了，内存技术也发生了大革命，插座从原来的SIMM升级为DIMM（Dual  In-line Memory Module），两边的金手指传输不同的数据，SDR  SDRAM内存插座的接口是168Pin，单边针脚数是84，进入到了经典的SDR SDRAM（Single Data Rate SDRAM）时代。</p><p><strong>SDRAM其实就是同步DRAM的意思，内存频率与CPU外频同步</strong>，这大幅提升了数据传输效率。SDR SDRAM的存在时间也相当的长，Intel从奔腾2、奔腾3与奔腾4（Socket 478），以及Slot 1、Socket 370与Socket 478的赛扬处理器，AMD的K6与K7处理器都可以SDR SDRAM。</p><p><img src="https://picx.zhimg.com/v2-0d031f4a69f92a2e568af7d2d345edf9_r.jpg" alt=""></p><h3 id="4-5-6-Rambus-DRAM内存"><a href="#4-5-6-Rambus-DRAM内存" class="headerlink" title="4.5.6 Rambus DRAM内存"></a>4.5.6 Rambus DRAM内存</h3><p>在选择SDR SDRAM继任者的时候Intel选择了与Rambus合作并推出了Rambus DRAM内存，通常都会被简称为RDRAM，它与SDRAM不同，采用了新的高速简单内存架构，基于RISC理论，这样可以减少数据复杂性提高整个系统的性能。</p><p><img src="https://pic3.zhimg.com/v2-0cbf4cd2049c7634813c32de174ed7d6_r.jpg" alt=""></p><p>由于一些其他原因，以及RDRAM的制造成本高，很多内存厂都没有兴趣，这直接导致RDRAM的零售价居高不下，奔腾4平台的成本相对高，消费者也不买单，最终就是导致RDRAM完败于DDR SDRAM，最终Intel抛弃RDRAM投奔到DDR阵营。</p><h3 id="4-5-7-DDR内存"><a href="#4-5-7-DDR内存" class="headerlink" title="4.5.7 DDR内存"></a>4.5.7 DDR内存</h3><p>DDR内存的正式名字是DDR SDRAM（Dual  Date Rate SDRAM），顾名思义就是<strong>双倍速率SDRAM</strong>，从名字上就知道它是SDR SDRAM的升级版，DDR  SDRAM在时钟周期的上升沿与下降沿各传输一次信号，使得它的数据传输速度是SDR  SDRAM的两倍，而且这样做还不会增加功耗，至于定址与控制信号与SDR  SDRAM相同，仅在上升沿传输，这是对当时内存控制器的兼容性与性能做的折中。</p><p>其中标准DDR就是我们日常所熟知的，在电脑上应用的DDR内存，支持更宽的通道宽度、更高的密度和不同的形状尺寸，面向服务器、云计算、网络、笔记本电脑、台式机等消费类应用，目前JEDEC已公布的最高标准是DDR5。</p><p><img src="https://pic1.zhimg.com/v2-650c937a9d3773ff47362f9925c42cd8_r.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/v2-21c7f8ebbd56d03a4852fed1b0267c77_r.jpg" alt=""></p><p>关于内存技术的发展，详细请参考下面几篇文章：<br>参考链接1：<a href="https://news.qq.com/rain/a/20240505A009Y500">【硬件编年史】内存的前世今生，跨越时代的存储之旅_腾讯新闻</a><br>参考链接2：<a href="http://www.360doc.com/content/22/0517/18/32515739_1031806751.shtml">电脑内存DDR3和DDR4有什么区别？- 360个人图书馆</a><br>参考链接3：<a href="https://www.chinafix.com/portal.php?mod=view&amp;aid=9018">从KB到GB，内存条所经过的7个历程  - 迅维网</a></p><h2 id="4-6-CPU-Z软件给出的几个参数"><a href="#4-6-CPU-Z软件给出的几个参数" class="headerlink" title="4.6 CPU-Z软件给出的几个参数"></a>4.6 CPU-Z软件给出的几个参数</h2><ul><li>内存通道数：双通道<ul><li><strong>内存条的双通道是指主板的北桥芯片中设计了两个独立的内存控制器，每个控制器控制一个内存通道，CPU可以对这两个内存分别寻址，从而增加内存的带宽和速度</strong>‌‌。这种设计使得内存的带宽翻倍，数据存取速度也相应增加，理论上可以提高系统的整体性能‌。</li></ul></li><li>内存带宽（Memory Bandwidth）指的是单位时间内从内存中读取或写入数据的最大速率，通常以每秒传输的字节数（Bytes per second, B/s）来衡量，更常见的单位是GB/s（Gigabytes per second）。内存带宽反映了系统在给定时间窗口内能够处理的数据量，对于系统的整体性能至关重要，尤其是在多任务处理、图形渲染和大型数据集操作等场景下。</li><li>串行存在检测(SPD)<ul><li>在cpu-z软件中，spd是串行存在检测的意思，它指的是内存模块上内置的一个小型芯片，它包含了内存模块的配置信息，如内存的类型、大小、速度、电压和其他参数。(参考链接：<a href="https://in.ali213.net/yjjc/202409/23728.html">cpuz里面spd是什么意思_游侠网</a>)</li></ul></li></ul><h1 id="5-电源"><a href="#5-电源" class="headerlink" title="5 电源"></a>5 电源</h1><p>电源供应器属外设之一，作用为将家用交流电源转换为个人电脑硬件所需的直流电。</p><p><img src="https://picx.zhimg.com/v2-d3d5857ec3eb5e63c5d143a0a1539e03_r.jpg" alt=""></p><h2 id="5-1-功能与作用"><a href="#5-1-功能与作用" class="headerlink" title="5.1 功能与作用"></a>5.1 功能与作用</h2><ul><li><strong>电压转换</strong>：将家庭或办公室中提供的110V或230V交流电转换为+12V、+5V和+3.3V等不同等级的直流电，以满足主板、CPU、GPU、硬盘和其他扩展卡的需求。</li><li><strong>电流输出</strong>：根据连接设备的要求提供足够的电流，保证所有硬件都能正常工作。</li><li><strong>稳压功能</strong>：维持输出电压的稳定性，即使在输入电压波动的情况下也能保持输出电压恒定，保护敏感电子元件免受损坏。</li><li><strong>过载保护</strong>：内置电路可以防止因电流过大而导致的硬件故障或火灾风险。</li></ul><h2 id="5-2-主要规格参数"><a href="#5-2-主要规格参数" class="headerlink" title="5.2 主要规格参数"></a>5.2 主要规格参数</h2><ul><li><strong>功率额定值（Wattage）</strong>：表示电源能够提供的最大功率输出，单位为瓦特（W）。常见的家用PC电源功率范围从300W到1200W不等，具体需求取决于计算机配置。<ul><li>功率额定值一般越大越好，越大负载能力越强，比如3070显卡需要700W电源，而4090显卡就需要1000W电源，但同时耗电量也越高。</li></ul></li><li><strong>效率认证</strong>：80 PLUS标准定义了一系列效率级别，包括白牌、铜牌、银牌、金牌、铂金和钛金等。高效电源可以在减少能量浪费的同时降低散热需求。</li><li><strong>模组化设计</strong>：非模组化电源带有固定的电缆，而模组化电源允许用户根据需要连接所需的线缆，有助于整理线材和改善气流。</li><li><strong>尺寸与外形</strong>：标准ATX电源的尺寸通常是150mm x 86mm x 140mm，但也存在SFX、TFX等其他规格，适用于小型机箱。</li></ul><h1 id="6-硬盘"><a href="#6-硬盘" class="headerlink" title="6 硬盘"></a>6 硬盘</h1><p><img src="https://pic4.zhimg.com/v2-0e1e77facf8a5fbc21be37f05b372567_r.jpg" alt=""></p><h2 id="6-1-硬盘的分类"><a href="#6-1-硬盘的分类" class="headerlink" title="6.1 硬盘的分类"></a>6.1 硬盘的分类</h2><p>硬盘的基本分类标准。根据接口、尺寸和用途，硬盘大致可分为以：机械硬盘（HDD）、固态硬盘（SSD）、混合硬盘（HHD）、移动硬盘、外置硬盘等。每一种硬盘都有其独特的特点和适用场景。</p><h2 id="6-2-机械硬盘（HDD）"><a href="#6-2-机械硬盘（HDD）" class="headerlink" title="6.2 机械硬盘（HDD）"></a>6.2 机械硬盘（HDD）</h2><h3 id="6-2-1-基本概念"><a href="#6-2-1-基本概念" class="headerlink" title="6.2.1 基本概念"></a>6.2.1 基本概念</h3><p><strong>硬盘驱动器</strong>（Hard Disk Drive，HDD），简称<strong>硬盘</strong>（hard disk），又称“<strong>机械硬盘</strong>”或“<strong>传统硬盘</strong>”，是电脑上使用坚硬的旋转磁性盘片为基础的非依电性存储器，它在平整的磁性表面存储和检索数字数据， $\large{\boldsymbol{\color\red{\text{数据通过离磁性表面很近的磁头由电磁流来改变极性的方式被写入到磁盘上}}}}$ ，数据可以通过盘片被读取，原理是<strong>磁头经过盘片的上方时盘片本身的磁场导致读取线圈中电气信号改变</strong>。硬盘的读写是采用<strong>半随机存取</strong>的方式，可以以任意顺序读取硬盘中的资料，但<strong>读取不同位置的资料速度不相同</strong>。硬盘包括一至数片高速转动的盘片以及放在执行器悬臂上的磁头。 </p><p><img src="https://pic4.zhimg.com/v2-acacb6046d90d9142de7a41ee58e613f_r.jpg" alt=""></p><h3 id="6-2-2-按接口分类"><a href="#6-2-2-按接口分类" class="headerlink" title="6.2.2 按接口分类"></a>6.2.2 按接口分类</h3><p><strong>硬盘</strong>按数据接口不同，大致分为ATA（又称IDE）和SATA以及SCSI和SAS。接口速度不是实际硬盘数据传输的速度，目前普通硬盘的实际数据传输速度一般不超过300MB/s。 </p><ul><li><p><strong>ATA，</strong>全称<strong>A</strong>dvanced <strong>T</strong>echnology <strong>A</strong>ttachment</p><ul><li>是用传统的40-pin并口数据线连接主板与硬盘的，接口速度最大为133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已被SATA所取代。 </li></ul></li><li><p><strong>SATA，</strong>全称<strong>S</strong>erial <strong>ATA</strong></p><ul><li>也就是使用串口的ATA接口，特点是抗干扰性强，对数据线的要求比ATA低很多，且支持热插拔等功能。SATA-II的接口速度为300MiB/s，而新的SATA-III标准可达到600MiB/s的传输速度。SATA的数据线也比ATA的细得多，有利于机箱内的空气流通，整理线材也比较方便。</li><li>$\large{\boldsymbol{\color\red{\text{可以在前面的主板上找到SATA接口}}}}$ </li></ul></li><li><p><strong>SCSI</strong>，全称<strong>S</strong>mall <strong>C</strong>omputer <strong>S</strong>ystem <strong>I</strong>nterface（小型机系统接口）</p><ul><li>SCSI硬盘广为工作站级个人电脑以及服务器所使用，因此会使用较为先进的技术，如盘片转速15000rpm的高转速，且资料传输时CPU占用率较低，但是单价也比相同容量的ATA及SATA硬盘更加昂贵。 </li></ul></li><li><p><strong>SAS，</strong>全称<strong>S</strong>erial <strong>A</strong>ttached <strong>S</strong>CSI</p><ul><li>是新一代的SCSI技术，可兼容SATA硬盘，同样支持热插拔，采用序列式技术以获得更高的传输速度，可达到12Gb/s，盘片转速也较快。而较小的连接线，可改善系统内部空间空气流通。通常应用于服务器等企业级产品。 </li><li>此外，由于SAS硬盘可以与SATA硬盘共享同样的背板，因此在同一个SAS存储系统中，可以用SATA硬盘来取代部分昂贵的SAS硬盘，节省整体的存储成本。但SATA存储系统并不能连接SAS硬盘。 </li></ul></li><li><strong>FC，</strong>全称<strong>F</strong>ibre <strong>C</strong>hannel（光纤通道接口）<ul><li>拥有此接口的硬盘在使用光纤联接时具有热插拔性、高速带宽（4Gb/s或8Gb/s或16Gb/s）、远程连接等特点；内部传输速率也比普通硬盘更高。但其价格高昂，因此FC接口通常只用于高端服务器领域。 </li></ul></li></ul><h3 id="6-2-3-机械硬盘结构"><a href="#6-2-3-机械硬盘结构" class="headerlink" title="6.2.3 机械硬盘结构"></a>6.2.3 机械硬盘结构</h3><p><strong>（一）物理结构</strong></p><p><img src="https://pic1.zhimg.com/v2-7c18e7acc29745459e7bed3d83765364_r.jpg" alt=""></p><p>硬盘的物理结构一般由磁头与盘片、电动机、主控芯片与排线等部件组成；当主电动机带动盘片旋转时，副电动机带动一组（<strong>磁头</strong>）到相对应的盘片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与盘片同心的圆形轨道（<strong>磁道</strong>或称<strong>柱面</strong>），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位<strong>扇区</strong>，从而得到该扇区的数据内容。</p><ul><li><strong>磁道（Track）</strong><ul><li>当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。资料存储手段从LMR进展到PMR这中又有CMR、SMR等技术。 </li></ul></li><li><strong>柱面（Cylinder）</strong><ul><li>在有多个盘片构成的盘组中，由不同盘片的面，但处于同一半径圆的多个磁道组成的一个圆柱面。 </li></ul></li><li><strong>扇区（Sector）</strong><ul><li>磁盘上的每个磁道被等分为若干个弧段，弧段就称为扇区。 ${\boldsymbol{\color\red{\text{硬盘第一个扇区，叫做引导扇区}}}}$ 。</li></ul></li></ul><p><strong>（二）逻辑结构</strong></p><p>操作系统对硬盘进行读写时需要用到<strong>文件系统把硬盘的扇区组合成簇</strong>，并<strong>建立文件和树形目录制度</strong>，使操作系统对其访问和查找变得容易，这是因为操作系统直接对数目众多的扇区进行寻址会十分麻烦。 </p><ul><li><strong>主引导记录</strong>（Master  Boot  Record，MBR），又叫做主引导扇区<ul><li>是电脑开机后访问硬盘时所必须要读取的首个扇区，主引导扇区记录着硬盘本身的相关消息以及硬盘各个分割的大小及位置消息，是资料消息的重要入口。如果它受到破坏，硬盘上的基本数据结构消息将会丢失，需要用繁琐的方式试探性的重建数据结构消息后才可能重新访问原先的资料</li></ul></li><li><strong>全局唯一标识分区表</strong>（GUID Partition Table，GPT）<ul><li>是一个实体硬盘的分区表的结构布局的标准。它是可扩展固件接口（EFI）标准（<strong>被Intel用于替代个人计算机的BIOS</strong>）的一部分。GPT分配64bits给逻辑块地址，因而使得最大分区大小为264-1个扇区。对于每个扇区大小为512字节的磁盘，相当于9.4ZB（9.4 x 1021字节）或8 ZiB-512字节。</li></ul></li></ul><h2 id="6-3-固态硬盘（SSD）"><a href="#6-3-固态硬盘（SSD）" class="headerlink" title="6.3 固态硬盘（SSD）"></a>6.3 固态硬盘（SSD）</h2><p><strong>固态盘</strong>（solid-state disk, <strong>SSD</strong>），是一种以集成电路制作的电脑存储设备，虽然价格及存储容量与机械硬盘有少许差距，但<strong>固态盘读取的速度可比机械式硬盘的快200倍</strong>。</p><p><img src="https://pic4.zhimg.com/v2-f541694457d456ca09466549407ba933_r.jpg" alt=""></p><p>固态硬盘的存储介质分为两种，可以用非易失性存储器（主要以<strong>闪存</strong>中的 NAND Flash）作为永久性存储设备，也可以用易失性存储器（例如<strong>DRAM</strong>）作为临时性存储设备。 </p><p>固态硬盘的接口规范和定义、功能及使用方法上与普通硬盘几近相同，外形和尺寸也基本与普通的2.5英寸硬盘一致。固态硬盘性能的几个因素主要是：主控芯片、NAND闪存介质和固件。在上述条件相同的情况下，采用何种接口也可能会影响SSD的性能。固态硬盘常采用<strong>SATA</strong>、PCI Express、mSATA、<strong>M.2(目前的主流)</strong>、ZIF、IDE、U.2、CF、CFast等接口。 </p><ul><li><strong>接口和协议这两个概念的区别</strong><ul><li><strong>接口（Interface）</strong>：<ul><li>接口是指两个系统或组件之间进行交互的边界。在<strong>硬件层面</strong>，接口通常指的是物理连接点，如插槽、端口或连接器，它们允许不同的硬件设备相互连接和通信。例如，USB接口、HDMI接口和前面提到的M.2接口都是硬件接口的例子。</li></ul></li><li>在<strong>软件层面</strong>，接口可以指应用程序编程接口（API），它定义了软件组件之间交互的方式，包括可用的函数、数据结构、对象类等。</li></ul></li><li><strong>协议（Protocol）</strong>：<ul><li>协议是指一系列规则和标准，它们定义了数据如何在通信系统中传输和接收。协议确保了不同设备和系统之间的有效通信，即使它们由不同的制造商生产或运行不同的操作系统。</li></ul></li><li><strong>接口和协议的区别</strong>：<ul><li>接口关注的是“如何连接”，它提供了<strong>物理或逻辑的连接方式</strong>，使得不同的系统或组件能够相互接触和交互。</li><li>协议关注的是“如何通信”，它规定了数据交换的格式和顺序，确保信息能够被正确理解和处理。</li></ul></li></ul><p><strong>举例说明</strong>：</p><ul><li>以M.2接口为例，它定义了固态硬盘与主板之间的物理连接方式，包括插槽的形状、尺寸和电气特性。</li><li>而SATA、PCIe和NVMe则是协议，它们定义了数据如何通过M.2接口在固态硬盘和主板之间传输。SATA和PCIe是传输层的协议，而NVMe是应用层的协议，它利用了PCIe协议的高带宽特性来优化闪存存储的数据传输。</li></ul><ol><li>SATA (Serial ATA)</li></ol><ul><li><strong>定义</strong>：串行高级技术附件（Serial Advanced Technology Attachment），是目前最广泛使用的存储设备接口之一。</li><li><strong>版本与速度</strong>：<ul><li><strong>SATA I (1.5 Gbps)</strong>：理论最大传输速率为150 MB/s。</li><li><strong>SATA II (3.0 Gbps)</strong>：理论最大传输速率为300 MB/s。</li><li><strong>SATA III (6.0 Gbps)</strong>：理论最大传输速率为600 MB/s，这是当前最常见的版本。</li></ul></li><li><strong>物理特性</strong>：7针连接器，通常使用2.5英寸或3.5英寸规格的硬盘托架安装在计算机内部。</li><li><strong>优势</strong>：成本较低，兼容性强，几乎所有现代主板都配备有多个SATA端口。</li><li><strong>局限性</strong>：由于受到总线带宽限制，即使是最快的SATA III接口也难以满足高性能SSD的需求。</li></ul><ol><li>M.2</li></ol><ul><li><strong>定义</strong>：一种紧凑型接口标准，最初被称为NGFF（Next Generation Form Factor），主要用于笔记本电脑和平板电脑，但现在也被广泛应用于台式机。</li><li><strong>尺寸</strong>：常见的长度为22mm宽度，长度有2230、2242、2260、2280等不同规格，其中2280最为普遍。</li><li><strong>支持协议</strong>：<ul><li><strong>SATA协议</strong>：通过M.2接口连接，但仍然受限于SATA III的速度上限（600 MB/s）。</li><li><strong>NVMe协议</strong>：非易失性内存主机控制器接口规范，能够充分利用PCIe通道提供的高带宽，实现极高的读写速度。例如，PCIe 3.0 x4可以提供大约4 GB/s的理论带宽，而PCIe 4.0 x4则可达8 GB/s甚至更高。</li></ul></li><li><strong>优势</strong>：体积小巧，便于集成到小型化设计中；当搭配NVMe协议时，可获得远超SATA SSD的性能表现。</li><li><strong>局限性</strong>：部分老款主板可能仅支持SATA模式下的M.2 SSD，无法享受NVMe带来的高速度。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M.2接口支持的协议包括SATA、PCIe和NVMe。</span><br><span class="line">其中，SATA和PCIe是传输层的协议，而NVMe是应用层的协议，它运行在PCIe协议之上，</span><br><span class="line">专门为高性能的闪存存储设计。</span><br></pre></td></tr></table></figure><ol><li>U.2 (原名SFF-8639)</li></ol><ul><li><strong>定义</strong>：统一扩展接口（Universal Serial Interface），旨在为服务器和数据中心提供一种标准化的SSD连接方式。</li><li><strong>物理特性</strong>：25针连接器，外形类似于传统的SAS/SATA接口，但更宽，支持热插拔功能。</li><li><strong>支持协议</strong>：主要与NVMe协议结合使用，通过PCIe通道进行数据传输。</li><li><strong>优势</strong>：适合企业级应用，提供更高的可靠性和易于维护的特点。</li><li><strong>局限性</strong>：相比M.2，占用更多空间，并且需要特定的插槽或适配器才能在普通消费级主板上使用。</li></ul><ol><li>PCIe 直插式</li></ol><ul><li><strong>定义</strong>：直接插入主板上的PCI Express扩展槽，完全绕过了传统的存储控制器。</li><li><strong>物理特性</strong>：根据所需的带宽选择不同长度的插槽，如x1, x4, x8或x16。对于SSD来说，通常是x4配置。</li><li><strong>支持协议</strong>：几乎总是采用NVMe协议，利用PCIe通道的全部潜力来达到最高的读写速度。</li><li><strong>优势</strong>：理论上可以获得最高的性能，因为没有额外的瓶颈限制。非常适合追求极致性能的用户，如游戏玩家和专业内容创作者。</li><li><strong>局限性</strong>：占用宝贵的PCIe插槽资源，可能影响其他硬件组件的安装；此外，由于散热问题，这种类型的SSD往往需要额外的冷却措施。</li></ul><p><img src="https://pic4.zhimg.com/v2-68ac7a959aaf973ce43e7ccb844f162f_r.jpg" alt=""></p><h2 id="6-4-混合硬盘（HHD）"><a href="#6-4-混合硬盘（HHD）" class="headerlink" title="6.4 混合硬盘（HHD）"></a>6.4 混合硬盘（HHD）</h2><p>混合硬盘则是机械硬盘和固态硬盘的结合体，它既有HDD的大容量存储优势，又有SSD的快速读写性能。HHD内部集成了小容量的SSD作为缓存，用于存储常用数据和系统文件，从而大幅提升系统响应速度和程序启动速度。</p><h2 id="6-5-移动硬盘"><a href="#6-5-移动硬盘" class="headerlink" title="6.5 移动硬盘"></a>6.5 移动硬盘</h2><p>移动硬盘是一种可移动存储设备，通常采用USB接口连接电脑。它结合了HDD或SSD的存储技术，便于携带和传输数据。无论是出差、旅行还是临时存储文件，移动硬盘都是你的得力助手。</p><p>移动硬盘，主要指采用USB或IEEE1394接口，可以随时插上或拔下，小巧而便于携带的硬盘存储器，以较高的速度与系统进行数据传输。在USB1.1接口规范的产品上，在传输较大数据量时，耗时较长。而USB2.0、IEEE1394、cSATA移动硬盘接口就相对好很多。USB 2.0接口传输速率是60MB/s，USB 3.0接口传输速率是625 MB/s，IEEE 1394接口传输速率是50～100 MB/s。移动硬盘的优点：容量大；兼容性好，即插即用；速度快；体积小，质量小；安全可靠。</p><p><img src="https://pic4.zhimg.com/v2-3521db9675cf0f4259bf628c4c35bd8b_r.jpg" alt=""></p><h2 id="6-6-外置硬盘"><a href="#6-6-外置硬盘" class="headerlink" title="6.6 外置硬盘"></a>6.6 外置硬盘</h2><p>外置硬盘则是一种通过网络连接的存储设备，通常用于远程存储和备份数据。它可以通过有线或无线方式连接到电脑或服务器，实现数据的共享和访问。外置硬盘特别适合需要跨设备、跨地点共享数据的场景，如家庭、办公室或小型企业。</p><h2 id="6-7-硬盘（HDD）VS-内存（RAM）"><a href="#6-7-硬盘（HDD）VS-内存（RAM）" class="headerlink" title="6.7 硬盘（HDD）VS 内存（RAM）"></a>6.7 硬盘（HDD）VS 内存（RAM）</h2><p><strong>硬盘：</strong>作为非易失性的长期存储介质，用于保存各种类型的文件和数据，确保即使在关机后这些数据也不会丢失。</p><p><strong>内存：</strong>作为易失性的短期工作空间，提供极高的访问速度，专门用于存放那些需要被CPU即时处理的数据，从而提高系统的整体性能。</p><ul><li><strong>存储数据的类型</strong><ul><li><strong>硬盘</strong>：<ul><li><strong>操作系统</strong>：例如Windows、macOS或Linux的安装文件。</li><li><strong>应用程序</strong>：如浏览器、办公软件、游戏等。</li><li><strong>用户文件</strong>：文档、图片、视频、音频等。</li><li><strong>系统设置和驱动程序</strong>：用于管理硬件设备和系统运行的配置文件。</li></ul></li><li><strong>内存</strong>：<ul><li><strong>操作系统的核心进程</strong>：如任务管理器、系统服务等。</li><li><strong>正在运行的程序数据</strong>：例如，当你打开一个文档时，文档的内容会被加载到内存中，以便快速处理。</li><li><strong>临时数据</strong>：如程序运行时生成的中间结果、缓存数据等。</li></ul></li></ul></li></ul><p>举例：一个应用程序在不运行的时候是以文件的形式存储在硬盘（HDD或SSD）上的，当启动这个应用程序时，操作系统会将该程序的部分或全部代码和数据加载到内存（RAM）中以便CPU可以快速访问和执行。</p><h2 id="6-8-购买页面"><a href="#6-8-购买页面" class="headerlink" title="6.8 购买页面"></a>6.8 购买页面</h2><p><img src="https://picx.zhimg.com/v2-c3ebeca3479ac0aebef599041ad4953b_r.jpg" alt=""></p><h2 id="6-9-其他存储设备"><a href="#6-9-其他存储设备" class="headerlink" title="6.9 其他存储设备"></a>6.9 其他存储设备</h2><p>软盘、光盘、U盘</p><h1 id="7-显卡"><a href="#7-显卡" class="headerlink" title="7 显卡"></a>7 显卡</h1><h2 id="7-1-显卡的定义"><a href="#7-1-显卡的定义" class="headerlink" title="7.1 显卡的定义"></a>7.1 显卡的定义</h2><p><strong>显示卡</strong>（英语：Display Card）简称<strong>显卡</strong>，也称<strong>图形卡</strong>（Graphics Card），是个人电脑上以图形处理器（GPU）为核心的扩展卡，用途是提供中央处理器以外的微处理器帮助计算图像信息，并将计算机系统所需要的显示信息进行转换并提供逐行或隔行扫描信号给显示设备，是连接显示器和个人电脑主板的重要组件。</p><p>独立显卡以<strong>Nvidia</strong>和<strong>AMD</strong>之间的双头垄断为主要格局。随着计算性能的提升，显卡也开始被用在其它非图像处理的用途上，比如<a href="https://zh.wikipedia.org/wiki/炒卖">炒卖</a>加密货币（所谓的“挖矿”）和AI强化学习（例如ChatGPT）。</p><h2 id="7-2-工作原理及基本组成结构"><a href="#7-2-工作原理及基本组成结构" class="headerlink" title="7.2 工作原理及基本组成结构"></a>7.2 工作原理及基本组成结构</h2><h3 id="7-2-1-总体介绍"><a href="#7-2-1-总体介绍" class="headerlink" title="7.2.1 总体介绍"></a>7.2.1 总体介绍</h3><p>显卡是插在主板上的扩展槽里的（现在一般是<strong>PCI-E插槽</strong>，此前还有AGP、PCI、ISA等插槽），主要负责把主机向显示器发出的显示信号转化为一般电器信号，使得显示器能明白个人电脑在让它做什么。显卡的主要芯片叫“显示芯片”（Video Chipset）也叫GPU或VPU（图形处理器或视觉处理器），是显卡的主要处理单元。显卡上也有和存储器相似的存储器，称为“显示内存 VRAM”，简称<strong>显存</strong>。   </p><p>显卡通常由总线接口、PCB板、显示芯片、显示内存、RAMDAC、VGABIOS、VGA端子及其他外围组件构成，现在的显卡大多使用VGA、DVI、HDMI接口或DisplayPort接口。 </p><p><img src="https://pica.zhimg.com/v2-4923696a5f86381be3a3c53b60a113ec_r.jpg" alt=""></p><h3 id="7-2-2-显卡的核心指标"><a href="#7-2-2-显卡的核心指标" class="headerlink" title="7.2.2 显卡的核心指标*"></a>7.2.2 显卡的核心指标*</h3><ol><li><strong>图形处理器（GPU）</strong>：显卡的核心组件，负责执行图形处理和计算任务。它具有高度并行的处理能力，适合处理大量的图形数据和复杂计算。</li><li><strong>显存（VRAM）</strong>：用于存储图形数据和帧缓冲区。显存的容量和速度对显卡性能有很大影响，常见规格有4GB、8GB、16GB等。</li><li><strong>显存带宽</strong>：显存与GPU之间数据传输的速度，带宽越高，性能越好。</li><li><strong>CUDA核心/流处理器数量</strong>：反映GPU并行计算能力，数量越多，性能越强。</li><li><strong>频率</strong>：包括核心频率和显存频率，频率越高，性能越强（通常和功耗、发热成正比）。</li><li><strong>电路板（PCB）</strong>：显卡的基础结构，承载着GPU、显存和其他电子元件，并提供电源和信号传输通道。</li><li><strong>接口</strong>：显卡通过接口与计算机主板和显示器连接。常见的接口有PCIe（与主板连接）和HDMI、DisplayPort、DVI（与显示器连接）。</li><li><strong>散热系统</strong>：主要分为风冷和水冷两种，用于冷却GPU和显存，确保显卡在高负载下稳定运行。</li></ol><h2 id="7-3-显卡根据其用途和性能几类"><a href="#7-3-显卡根据其用途和性能几类" class="headerlink" title="7.3 显卡根据其用途和性能几类"></a>7.3 显卡根据其用途和性能几类</h2><ul><li><strong>集成显卡：</strong>集成在CPU或主板上的图形处理单元，性能较低，适合普通办公和基础娱乐用途。</li><li><strong>独立显卡：</strong>独立的显卡，性能较高，适合游戏、专业图形处理和科学计算等需要高图形处理能力的应用。</li><li><strong>专业显卡：</strong>专为专业应用设计，如CAD、3D建模、视频编辑和科学计算等，具有更高的精度和稳定性。</li></ul><h2 id="7-4-显卡品牌型号与命名介绍"><a href="#7-4-显卡品牌型号与命名介绍" class="headerlink" title="7.4 显卡品牌型号与命名介绍"></a>7.4 显卡品牌型号与命名介绍</h2><h3 id="7-4-1-品牌型号"><a href="#7-4-1-品牌型号" class="headerlink" title="7.4.1 品牌型号"></a>7.4.1 品牌型号</h3><p><strong>GPU设计商</strong>：NVIDIA（GeForce、Quadro系列）、AMD（Radeon系列）、Intel（Arc系列）。</p><p><strong>显卡制造商</strong>：华硕、技嘉、微星、索泰、影驰等。</p><p><strong>型号</strong>：显卡通常以系列和数字命名，例如 NVIDIA GeForce RTX 4080 或 AMD Radeon RX 7800，数字越大性能通常越高。</p><p>$\large{\boldsymbol{\color\red{\text{N卡（NVIDIA显卡）}}}}$  VS $\large{\boldsymbol{\color\purple{\text{A卡（AMD显卡）}}}}$ </p><h3 id="7-4-2-命名介绍"><a href="#7-4-2-命名介绍" class="headerlink" title="7.4.2 命名介绍"></a>7.4.2 命名介绍</h3><p><strong>（一）英伟达NVIDIA</strong></p><p><img src="https://pic4.zhimg.com/v2-45b97107b8626fa44d26105588784aef_r.jpg" alt=""></p><p>与CPU的命令类似，显卡的命名大致上也可分为：<code>品牌 + 产品线 + 系列 + 代数 + 性能 + 后缀</code></p><p>例如：上面图32中的NVIDIA GeForce RTX 4060 Ti。</p><ul><li><strong>命名结构分析</strong></li></ul><p><img src="https://picx.zhimg.com/v2-0288667df4085dd612c187a4cd3028d9_r.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/v2-3d179473cf117e2b9a65be3753f9b5a7_r.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/v2-c49150bcd6ec2d0b06becbc848c5665f_r.jpg" alt=""></p><ul><li><strong>在售产品参数</strong></li></ul><p>这个参数表是NVIDIA官方规格：<a href="https://www.nvidia.cn/geforce/graphics-cards/30-series/">GEFORCE RTX 30 系列显卡采用 Ampere 架构 | NVIDIA</a></p><p><img src="https://picx.zhimg.com/v2-b99e3aa06865cc5051dc184c2603b39f_r.jpg" alt=""></p><p>可以参考一下该知乎博主的关于N卡的购买建议：<a href="https://zhuanlan.zhihu.com/p/589329498">何峰：DIY Weekly—显卡选购—NVIDIA</a></p><p><strong>（二）AMD显卡</strong></p><p><img src="https://pic3.zhimg.com/v2-d0b9e1377552d97688cf8f3d11ccff14_r.jpg" alt=""></p><p><img src="https://pica.zhimg.com/v2-2f07a64d30933059bafc2902b9a31282_r.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/v2-cd41607b64541e37b8454831f81005fd_r.jpg" alt=""></p><p><img src="https://pic1.zhimg.com/v2-d6218cffdfc6f205ce1ddd0523af4fc8_r.jpg" alt=""></p><h2 id="7-5-核显、独显的区别以及用途"><a href="#7-5-核显、独显的区别以及用途" class="headerlink" title="7.5 核显、独显的区别以及用途"></a>7.5 核显、独显的区别以及用途</h2><h3 id="7-5-1-核显（集成显卡）"><a href="#7-5-1-核显（集成显卡）" class="headerlink" title="7.5.1 核显（集成显卡）"></a>7.5.1 核显（集成显卡）</h3><ul><li><strong>定义</strong>：<ul><li>核显是集成在CPU芯片或主板上的图形处理单元。它与CPU共享系统内存（RAM）作为显存，通常用于满足基本的图形处理需求。</li></ul></li><li><strong>性能</strong>：<ul><li>适合日常使用，如网页浏览、文档编辑、视频播放等。</li><li>对于轻度游戏和一些不太复杂的图形任务（如高清视频解码）也能胜任，但无法满足高性能游戏或专业图形设计的需求。</li></ul></li><li><strong>功耗</strong>：<ul><li>功耗较低，通常集成在低功耗的CPU或主板上。</li></ul></li><li><strong>成本</strong>：<ul><li>由于不需要额外的独立显卡，整体成本较低。</li></ul></li><li><strong>散热</strong>：<ul><li>由于功耗低，散热需求也较低，适合轻薄笔记本和小型台式机。</li></ul></li><li><strong>应用场景</strong>：<ul><li>适合普通办公、家庭娱乐、教育等场景，尤其是对图形性能要求不高的用户。</li></ul></li><li><strong>示例</strong><ul><li>Intel的核显：如Intel HD Graphics、Intel Iris Xe Graphics。</li><li>AMD的核显：如Radeon Vega Graphics、Radeon Graphics。</li></ul></li></ul><h3 id="7-5-2-独显（独立显卡）"><a href="#7-5-2-独显（独立显卡）" class="headerlink" title="7.5.2 独显（独立显卡）"></a>7.5.2 独显（独立显卡）</h3><ul><li><strong>定义</strong><ul><li>独显是独立于CPU的专用图形处理单元，通常以PCIe扩展卡的形式安装在主板上。它有自己的显存（如GDDR6、GDDR6X、HBM等），不依赖系统内存。</li></ul></li><li><strong>性能</strong>：<ul><li>性能远高于核显，能够轻松应对高性能游戏、3D建模、视频编辑等复杂图形任务。</li><li>高端独显（如NVIDIA GeForce RTX系列、AMD Radeon RX系列）支持光线追踪、DLSS等先进技术。</li></ul></li><li><strong>功耗</strong>：<ul><li>功耗较高，尤其是高端显卡，需要良好的散热系统和充足的电源支持。</li></ul></li><li><strong>成本</strong>：<ul><li>独显价格较高，尤其是高性能型号，会显著增加设备的整体成本。</li></ul></li><li><strong>散热</strong>：<ul><li>需要额外的散热设计（如风扇、散热片等），适合高性能需求的台式机和游戏笔记本。</li></ul></li><li><strong>应用场景</strong>：<ul><li>适合游戏玩家、专业图形设计师、视频编辑师、科学家等对图形处理能力有高要求的用户。</li></ul></li><li><strong>示例</strong><ul><li>NVIDIA GeForce系列（如RTX 4090、RTX 4070 Ti）。</li><li>AMD Radeon系列（如RX 7900 XTX、RX 7600）。</li></ul></li></ul><p><img src="https://pic4.zhimg.com/v2-8db4628ac49493fb52395162c1e2c235_r.jpg" alt=""></p><h2 id="7-6-GPU性能天梯图"><a href="#7-6-GPU性能天梯图" class="headerlink" title="7.6 GPU性能天梯图"></a>7.6 GPU性能天梯图</h2><p><a href="https://www.mydrivers.com/zhuanti/tianti/gpu/">桌面显卡性能天梯图</a></p><p>参考链接1：<a href="https://blog.csdn.net/qq_39512532/article/details/140526709">一文搞懂显卡-CSDN博客</a><br>参考链接2：<a href="https://blog.csdn.net/qq_51392112/article/details/129793840">【显卡】一文搞懂显卡_一台主机上的多台显卡设备的标识符相同吗-CSDN博客</a><br>参考链接3：<a href="https://blog.csdn.net/weixin_73012949/article/details/143983870">从零开始认识显卡-CSDN博客</a></p><h1 id="8-显示器"><a href="#8-显示器" class="headerlink" title="8 显示器"></a>8 显示器</h1><h2 id="8-1-基本定义"><a href="#8-1-基本定义" class="headerlink" title="8.1 基本定义"></a>8.1 基本定义</h2><p><strong>显示器</strong>（英语：display device或monitor）是一种输出设备，用于显示影像及色彩。常见的显示器是电脑及电视的屏幕。电子视觉显示器的常见应用是电视机或计算机监视器。</p><p><img src="https://pica.zhimg.com/v2-af9b5db46b8a9af3194be1522d932de2_1440w.jpg"></p><h2 id="8-2-性能指标"><a href="#8-2-性能指标" class="headerlink" title="8.2 性能指标"></a>8.2 性能指标</h2><p>显示器的性能一般由以下性能指标决定：（和通常使用的单位）</p><ul><li>屏幕尺寸（一般采用英寸）：可视面积、实际面积、纵横比（水平：垂直，较常见为4:3，16:9和16:10）</li><li>分辨率（点/平方英寸；dpi）：1080p、2K、4K等<ul><li><strong>1080p</strong>是一种全高清分辨率，分辨率为1920×1080，适合日常办公、网络浏览和观看高清视频。其画面清晰度和色彩还原度较高，但在大尺寸显示器上可能会显得不够细腻。</li><li><strong>2K分辨率</strong>（2560×1440）提供了更高的清晰度和细节表现，适合需要细腻画质的设计师和游戏玩家。</li><li><strong>4K分辨率</strong>（3840×2160）则是目前最高的分辨率之一，提供极其细腻的画面效果和丰富的色彩，适合专业视频编辑、3D建模和追求极致画质的游戏玩家。‌</li></ul></li><li>点距（毫米；通常为0.18-0.25mm）</li><li>刷新率（赫兹；Hz）：一个显示器在一秒内页面刷新的次数，目前主流的有60Hz、120Hz、144Hz、240Hz 。此值越大越好。</li><li>亮度（流明；Lux），亮度太高会影响视力</li><li>对比度：最高亮度比最低亮度</li><li>能耗（瓦特；W）：显示器进入待机状态下的能耗较小。</li><li>响应时间（毫秒；ms）：一个像素从活动（黑）到静止（白）状态，再返回到活动状态所用的时间。数值越小越好。</li><li>可视角度：在纵横方向可以看到影像的最大角度。</li></ul><p>显示器性能指标越好，对显卡的要求也越高。</p><h2 id="8-3-一个具体的例子"><a href="#8-3-一个具体的例子" class="headerlink" title="8.3 一个具体的例子"></a>8.3 一个具体的例子</h2><p><img src="https://pic4.zhimg.com/v2-ee2b8c6ab1ba012b0fd3e8bbf47c97e3_r.jpg" alt=""></p><ul><li><p><strong>显示器全名解析</strong></p><ul><li><strong>华硕 (ASUS)</strong>：<ul><li><strong>含义</strong>：这是显示器的品牌，表示该显示器由华硕（Asus）制造。华硕是一家知名的台湾电子制造商，以其高质量的显示器和其他计算机硬件而闻名。</li></ul></li><li><strong>VG34VQL3A 战影</strong>：<ul><li><strong>含义</strong>：这是华硕的一个产品系列名称，“VG”通常代表面向游戏玩家的产品线，“战影”是华硕为该系列产品起的中文名称，强调其游戏性能和设计风格。</li></ul></li></ul></li><li><p><strong>参数解析</strong></p><ul><li><strong>尺寸：34英寸</strong><ul><li><strong>含义</strong>：屏幕对角线长度为34英寸，属于较大尺寸的显示器，适合需要宽广视野的应用场景，如多任务处理、视频编辑或沉浸式游戏体验。</li></ul></li><li><strong>分辨率</strong>：<strong>2K WQHD (3440 x 1440)</strong><ul><li><strong>含义</strong>：提供比标准1080p更高的分辨率，具体为3440 x 1440像素。这种宽屏分辨率非常适合“带鱼屏”（即超宽屏幕），能提供更细腻的画面细节和更多的显示空间。</li></ul></li><li><strong>曲面设计</strong>：<strong>曲面带鱼屏</strong><ul><li><strong>含义</strong>：曲面屏设计，能够减少边缘失真并增强沉浸感，适合长时间观看或玩游戏时提供更自然的视觉体验。</li></ul></li><li><strong>刷新率</strong>：<strong>180Hz高刷</strong><ul><li><strong>含义</strong>：屏幕每秒可以刷新180次图像帧数，远高于传统的60Hz显示器。这对于快速移动的场景（如射击游戏、赛车游戏）尤为重要，能够显著减少运动模糊，使画面更加流畅。</li></ul></li><li><strong>HDR支持</strong>：<strong>HDR400 </strong><ul><li><strong>含义</strong>：支持HDR（高动态范围）技术，达到VESA DisplayHDR 400认证标准。这表示显示器能够在亮度、对比度和色彩准确性方面提供更好的表现，尤其是亮部和暗部细节的表现更为出色。</li><li>参考链接：<a href="https://www.160.com/article/7297.html">显示器HDR是什么意思？一文读懂HDR技术</a></li></ul></li><li><strong>色域覆盖</strong>：<strong>125% sRGB广色域</strong><ul><li><strong>含义</strong>：sRGB是一种常见的色彩空间标准，125%的覆盖率意味着该显示器能够显示比标准sRGB更广泛的色彩范围，确保颜色更加鲜艳和准确。换句话说，它不仅能够准确地再现所有sRGB色彩空间内的颜色，还能额外显示一些超出这个范围的颜色。</li></ul></li><li><strong>面板类型</strong>：<strong>HVA屏</strong><ul><li><strong>含义</strong>：HVA（Highly Vertical Alignment）是一种改进型的VA（垂直排列）面板技术，结合了IPS（平面转换）和TN（扭曲向列）面板的优点，提供较好的视角、对比度和响应时间。</li><li><strong>优势</strong>：HVA面板通常具有较高的对比度和黑色水平，同时保持较快的响应时间和较宽的视角，适合需要兼顾画质和性能的应用。</li></ul></li><li><strong>响应时间</strong>：<strong>1ms</strong><ul><li><strong>含义</strong>：灰阶到灰阶（GTG, Gray to Gray）响应时间为1毫秒，表示从一个颜色过渡到另一个颜色所需的时间非常短。</li><li><strong>优势</strong>：极短的响应时间可以有效减少拖影现象，使得快速移动的画面依然清晰锐利，特别适合竞技类游戏。</li></ul></li></ul></li></ul><h1 id="9-键盘"><a href="#9-键盘" class="headerlink" title="9 键盘"></a>9 键盘</h1><h1 id="10-鼠标"><a href="#10-鼠标" class="headerlink" title="10 鼠标"></a>10 鼠标</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机与编程学习 </category>
          
          <category> 计算机介绍 </category>
          
          <category> 计算机硬件介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基本概念 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 硬件基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言概要学习</title>
      <link href="/2024/10/16/Assembly-language-learning/"/>
      <url>/2024/10/16/Assembly-language-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><h2 id="1-1-这门课学什么"><a href="#1-1-这门课学什么" class="headerlink" title="1.1 这门课学什么"></a>1.1 这门课学什么</h2><ul><li>定位：理解硬件结构，掌握指令集，理解程序的运行过程。</li><li>内容：选取8088、8086指令集进行汇编语言程序设计的学习。</li></ul><h2 id="1-2-机器语言与汇编语言"><a href="#1-2-机器语言与汇编语言" class="headerlink" title="1.2 机器语言与汇编语言"></a>1.2 机器语言与汇编语言</h2><p>机器语言是机器指令的集合。<br>机器指令是一台机器可以正确执行的命令。<br>机器指令由一串二进制数表示，例 01010000。</p><p>汇编语言的主体是汇编指令。<br>汇编指令和机器指令的差别在于指令的表示方法上：① 汇编指令是机器指令便于记忆的书写格式； ② 汇编指令是机器指令的助记符。</p><div class="table-container"><table><thead><tr><th>机器指令</th><th>汇编指令</th><th>操作</th></tr></thead><tbody><tr><td>1000100111011000</td><td>MOV AX, BX</td><td>将寄存器BX的内容送到AX中</td></tr></tbody></table></div><p><img src="https://pic.imgdb.cn/item/670f217bd29ded1a8cc2f8f0.png"></p><p>用汇编语言编写程序的工作过程：程序员编写汇编指令→编译器编译为二进制机器码→计算机执行程序。</p><h2 id="1-3-计算机的组成"><a href="#1-3-计算机的组成" class="headerlink" title="1.3 计算机的组成"></a>1.3 计算机的组成</h2><p><img src="https://pic.imgdb.cn/item/670f2352d29ded1a8cc44843.png" style="zoom:60%"></p><p>CPU是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在<strong>存储器(内存，不是外存)</strong>中存放。离开了内存，性能再好的CPU也无法工作。</p><ul><li><strong>指令和数据的表示</strong></li></ul><p>计算机中的数据和指令，存储在内存或磁盘(外存)上。数据和指令都是二进制信息。</p><p>问题是如何判断一串二进制数字表示的是数据还是指令呢？由CPU决定。</p><ul><li><strong>计算机中的存储单元</strong></li></ul><p>存储器被划分为多个存储单元，存储单元从0开始编号。例如：8086有20条数据线，寻址空间为$2^{20} = 1\text{MB}$。</p><p><img src="https://pic.imgdb.cn/item/670f2914d29ded1a8cc81537.png" alt="存储单元编号"></p><blockquote><p><strong>简单补充：寄存器、缓存、内存、硬盘、存储器的理解</strong></p><p><strong>寄存器内置于CPU内部</strong>，是CPU内部的小型存储区域。它们通常由多个触发器构成，可以分为内部寄存器和外部接口寄存器。而<strong>内存则位于处理器外部是独立的硬件设备</strong>。它由内存芯片、电路板、金手指等部分组成，通过数据线与CPU相连。 </p><p>存取速度的比较：CPU(包含寄存器，缓存)&gt;内存 &gt; 硬盘<br>内存和硬盘之间的速度，差 3~4 个数量级；寄存器和内存之间的速度也差了 3~4 个数量级。由于寄存器和内存的速度差异很大，所以现代的 CPU 往往还提供了“缓存”模块。</p><p><a href="https://www.elecfans.com/d/2805654.html">寄存器和内存的区别 - 电子发烧友</a><br><a href="https://blog.csdn.net/zunguitiancheng/article/details/134870059">寄存器、缓存、内存、硬盘、存储器的理解 - CSDN</a><br><a href="https://blog.csdn.net/linsc_05/article/details/136913090">硬盘、内存、缓存（CPU）和寄存器 空间大小与存取速度的区别及设计原理 - CSDN</a></p></blockquote><ul><li><strong>计算机中的总线(BUS)</strong></li></ul><p>在计算机中专门有连接CPU和其他芯片的导线，通常称为总线。物理上：一根根导线的集合。逻辑上课划分为：<strong>地址总线、数据总线、控制总线</strong>。</p><p><strong>地址总线</strong>：CPU是通过地址总线来指定存储单元的。地址总线宽度决定了可寻址的存储单元大小，即$N$根地址总线(宽度为$N$)对应寻址空间$2^N$。</p><p><strong>数据总线</strong>：CPU与内存或其它器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。例：向内存中写入数据89D8H时的数据传送。</p><p><strong>控制总线</strong>：CPU通过控制总线对外部器件进行控制。控制总线是一些不同控制线的集合控制总线宽度决定了CPU对外部器件的控制能力。</p><h2 id="1-4-内存的读写与地址空间"><a href="#1-4-内存的读写与地址空间" class="headerlink" title="1.4 内存的读写与地址空间"></a>1.4 内存的读写与地址空间</h2><h3 id="1-4-1-CPU对存储器的读写"><a href="#1-4-1-CPU对存储器的读写" class="headerlink" title="1.4.1 CPU对存储器的读写"></a>1.4.1 CPU对存储器的读写</h3><ul><li>CPU要想进行数据的读写，必须和外部器件进行三类信息的交互<ul><li>存储单元的地址(地址信息 )；</li><li>器件的选择，读或写命令(控制信息 )；</li><li>读或写的数据(数据信息 )；</li></ul></li></ul><p>例如：</p><div class="table-container"><table><thead><tr><th>机器指令</th><th>汇编指令</th><th>操作</th></tr></thead><tbody><tr><td>101000000000001100000000</td><td>MOV AL, [3]</td><td>从3号内存存储单元读取数据送入寄存器AL</td></tr></tbody></table></div><h3 id="1-4-2-内存地址空间"><a href="#1-4-2-内存地址空间" class="headerlink" title="1.4.2 内存地址空间"></a>1.4.2 内存地址空间</h3><ul><li>什么是内存地址空间</li></ul><p>CPU地址总线宽度为$N$，寻址空间为$2^N$个字节。8086CPU的地址总线宽度为20，那么可以寻址$1\text{MB}$个内存单元，其内<strong>存地址空间</strong>为$1\text{MB}$。</p><ul><li>从CPU角度看地址空间分配</li></ul><p><img src="https://pic.imgdb.cn/item/670f2e7ad29ded1a8cccfcc3.png"></p><p><strong><font color=blue>将各类存储器看作一个逻辑存储器——进行统一编址</font></strong>，即所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。</p><p><img src="https://pic.imgdb.cn/item/670f2facd29ded1a8cce26b4.png" style="zoom:60%"></p><p>内存地址空间的分配方案——以8086PC机为例(640+128+256=1024KB = 20根地址总线)：</p><div class="table-container"><table><thead><tr><th>00000H~9FFFFH(RAM)</th><th>A0000H~BFFFFH(RAM)</th><th>C0000H~FFFFFH(ROM)</th></tr></thead><tbody><tr><td>主存储器地址空间 640KB</td><td>显存地址空间 128KB</td><td>各类ROM地址空间 256KB</td></tr></tbody></table></div><blockquote><p><strong>RAM指的是随机存取存储器，ROM指的是只读存储器。</strong></p><p><strong>1、RAM：</strong></p><p>随机存取存储器，缩写：RAM，也叫主存，是与CPU直接交换数据的内部存储器。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。</p><p><strong>2、ROM：</strong></p><p>只读存储器以非破坏性读出方式工作，只能读出无法写入信息。其中保存的数据是在制造计算机的时候就写好的，信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器。ROM所存数据通常是装入整机前写入的，整机工作过程中只能读出，不像随机存储器能快速方便地改写存储内容。</p></blockquote><h1 id="2-访问寄存器和内存"><a href="#2-访问寄存器和内存" class="headerlink" title="2 访问寄存器和内存"></a>2 访问寄存器和内存</h1><h2 id="2-1-寄存器以及数据存储"><a href="#2-1-寄存器以及数据存储" class="headerlink" title="2.1 寄存器以及数据存储"></a>2.1 寄存器以及数据存储</h2><p><img src="https://pic.imgdb.cn/item/670f6315d29ded1a8cf56703.png"></p><ul><li>寄存器是CPU内部的信息存储单元，以8086CPU为例，8086CPU有14个寄存器：<ul><li>通用寄存器：AX(AH + AL)、BX(BH + BL)、CX(CH + CL)、DX(DH + DL)</li><li>变址寄存器：SI、DI</li><li>指针寄存器：SP、BP</li><li>指令指针寄存器：IP</li><li>段寄存器：CS、SS、DS、ES</li><li>标志寄存器：PSW</li></ul></li><li>8086CPU所有的寄存器都是<strong>16位的</strong>，可以存放两个字节。</li></ul><p><strong>“字”在寄存器中的存储</strong></p><p>8086 CPU是16位微处理器，数据总线为16位，地址总线为20位。表明<strong>8086的字长为16bit</strong>。</p><p>一个字(word)可以存在一个16位寄存器中，这个字的高位字节存在这个寄存器的高8位寄存器，这个字的低位字节存在这个寄存器的低8位寄存器。</p><h2 id="2-2-mov和add指令"><a href="#2-2-mov和add指令" class="headerlink" title="2.2 mov和add指令"></a>2.2 mov和add指令</h2><div class="table-container"><table><thead><tr><th>汇编指令</th><th>对应操作</th><th>人为描述</th></tr></thead><tbody><tr><td>mov ax, 18</td><td>将18送入AX</td><td>AX = 18</td></tr><tr><td>mov ah, 78</td><td>将78送入AH</td><td>AH = 78</td></tr><tr><td>add ax, 8</td><td>将寄存器AX中的数值加上8</td><td>AX = AX + 8</td></tr><tr><td>mov ax, bx</td><td>将寄存器BX中的数据送入寄存器AX</td><td>AX = BX</td></tr><tr><td>add ax, bx</td><td>将AX,BX中的内容相加，结果存在AX中</td><td>AX = AX + BX</td></tr></tbody></table></div><h2 id="2-3-确定物理地址的方法"><a href="#2-3-确定物理地址的方法" class="headerlink" title="2.3 确定物理地址的方法"></a>2.3 确定物理地址的方法</h2><p>CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。每一个内存单元在这入空间中都有唯一的地址，这个唯一的地址称为物理地址</p><p>8086有20位地址总线，可传送20位地址，寻址能力为<strong><font = color=green>1M</font></strong>。但是，8086是16位结构的CPU，运算器一次最多可以处理16位的数据，寄存器的最大宽度为16位。在8086内部处理的、传输、暂存的地址也是16位，寻址能力也只有<strong>64KB</strong>。</p><p>问题：8086如何处理在寻址空间上的这个矛盾？<br>解决：用两个16位地址(段地址、偏移地址)合成一个20位的物理地址。</p><p>地址加法器合成物理地址的方法：</p><script type="math/tex; mode=display">物理地址=段地址 × 16+偏移地址</script><p>段地址乘以16就相当于向右移动4位，空出的位置补0。</p><h2 id="2-4-内存的分段表示法"><a href="#2-4-内存的分段表示法" class="headerlink" title="2.4 内存的分段表示法"></a>2.4 内存的分段表示法</h2><p>用<strong>分段</strong>的方式管理内存，8086CPU用“(段地址x16)+偏移地址=物理地址”的方式给出内存单元的物理地址。<br>内存并没有分段，段的划分来自于CPU！！！。</p><ul><li>段地址 ×16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数。</li><li>偏移地址为16位，16位地址的寻址能力为64K，所以一个段的长度最大为64K。</li><li>同一物理地址，可以由不同的段地址和偏移地址组成。</li></ul><p>在8086PC机中存储单元地址的表示方法：例：数据在21F60H内存单元中，段地址是2000H，说法：</p><p>(a) 数据存在内存$\text{ 2000 : 1F60 }$单元中；<br>(b) 数据存在内存的$\text{2000H}$段中的$\text{1F60H}$单元中；</p><p><strong>段地址很重要 —— 用专门的寄存器存放段地址</strong>：4个段寄存器<br>CS：代码段寄存器；SS：栈段寄存器；DS：数据段寄存器；ES：附加段寄存器。</p><p>偏移地址可以用多种方法提供——8086丰富的取址方式。</p><h2 id="2-5-CS、IP与代码段"><a href="#2-5-CS、IP与代码段" class="headerlink" title="2.5 CS、IP与代码段"></a>2.5 CS、IP与代码段</h2><p>CS：代码段寄存器，IP：指令指针寄存器，<code>CS:IP</code>：CPU将内存中<code>CS:IP</code>指向的内容当作指令执行（也即CS相当于段地址，IP相当于偏移地址）。</p><p>执行何处的指令，取决于<code>CS:IP</code>，可以通过改变CS、IP中的内容，来控制CPU要执行的目标指令，那么如何改变CS、IP的值呢？由于<strong>8086CPU不提供对CS和IP修改的指令</strong>，因此需要使用<code>jmp</code>指令：</p><div class="table-container"><table><thead><tr><th>转移指令jmp</th></tr></thead><tbody><tr><td>jmp 段地址:偏移地址 —— 这是同时修改CS和IP的内容</td></tr><tr><td>jmp 某一寄存器 —— 仅仅改变偏移地址IP中的内容</td></tr></tbody></table></div><h2 id="2-6-内存中字的存储"><a href="#2-6-内存中字的存储" class="headerlink" title="2.6 内存中字的存储"></a>2.6 内存中字的存储</h2><p>事实：对8086CPU而言，16位作为一个字。<br>问题：16位的字存储在一个16位的寄存器中，如何存储？<br>回答：高8位放高字节，低8位放低字节。<br>问题：16位的字在内存中需要2个连续字节存储，怎么存放？<br>回答：低位字节存在低地址单元，高位字节存在高地址单元，例：20000D(4E20H)存放在0、1两个单元，18D(0012H)存放在2、3两个单元，这两个单元怎么存储可分为：<strong>大端存储</strong> VS <strong>小端存储</strong>。</p><p><img src="https://pic.imgdb.cn/item/67106c78d29ded1a8cbdf3d4.png"></p><ul><li><strong>字单元</strong></li></ul><p>由两个地址连续的内存单元组成，存放一个字型数据(16位)</p><ul><li>用DS和[address]实现字的传送</li></ul><p>要解决的问题：CPU从内存单元中要读取数据<br>要求：CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址<br>原理：在8086PC中，内存地址曲段地址和偏移地址组成(段地址:偏移地址)<br>解决方案：DS和[address]配合 —— 用DS寄存器存放要访问的数据的段地址，偏移地址用[…]形式直接给出。</p><div class="table-container"><table><thead><tr><th>汇编程序示例</th><th>解释</th></tr></thead><tbody><tr><td>mov bx, 1000H<br />mov ds, bx<br />mov al, [0]</td><td>将10000H(1000:0)中的数据读到al寄存器中</td></tr></tbody></table></div><p>8086CPU不支持将数据直接送入段寄存器（这是硬件设计的问题）。<br>套路：数据→ 通用寄存器 → 段寄存器</p><h2 id="2-7-DS与数据段"><a href="#2-7-DS与数据段" class="headerlink" title="2.7 DS与数据段"></a>2.7 DS与数据段</h2><p>用DS存放数据段的段地址用相关指令访问数据段中的具体单元，单元地址由[address]指出。</p><h2 id="2-8-栈及栈操作的实现"><a href="#2-8-栈及栈操作的实现" class="headerlink" title="2.8 栈及栈操作的实现"></a>2.8 栈及栈操作的实现</h2><p>栈是一种只能在一端进行插入或删除操作的数据结构。</p><p>栈有两个基本的操作：① 入栈 ② 出栈。</p><p>入栈：将一个新的元素放到栈顶；出栈：从栈顶取出一个元素。</p><p>栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。</p><p>栈的操作规则：<strong>LIFO(LastIn First out，后进先出)</strong>。</p><p>CPU提供的栈机制：现今的CPU中都有栈的设计，8086CPU提供相关的指令，支持用栈的方式访问内存空间。基于8086CPU的编程，可以将一段内存当作栈来使用。</p><div class="table-container"><table><thead><tr><th>汇编指令</th><th>释义</th></tr></thead><tbody><tr><td>push ax</td><td>将ax中的数据送入栈中【以字(16位=2字节)为单位对栈进行操作】</td></tr><tr><td>pop ax</td><td>从栈顶取出数据送入ax【以字(16位=2字节)为单位对栈进行操作】</td></tr></tbody></table></div><p>问题<br>1、CPU如何知道一段内存空间被当作栈使用?<br>2、执行push和pop的时候，如何知道哪个单元是栈顶单元 ?</p><p>回答：<br>8086CPU中，有两个与栈相关的寄存器 —— 栈段寄存器SS存放栈顶的段地址，栈顶指针寄存器SP存放栈顶的偏移地址。</p><p>在汇编语言中使用栈要特别注意<strong>溢出</strong>问题：</p><p>8086CPU不保证对栈的操作不会超界。<br>8086CPU 只知道栈顶在何处(由SS:SP指示)，不知道程序安排的栈空间有多大。<br>程序员在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界；防止出栈时栈空了仍然继续出栈而导致的超界。</p><h2 id="2-9-“段”的小结"><a href="#2-9-“段”的小结" class="headerlink" title="2.9 “段”的小结"></a>2.9 “段”的小结</h2><ul><li><p>三种段</p><ul><li><p>数据段<br>将段地址放在DS中<br>用mov、add、sub等访问内存单元的指令时，CPU将我们定义的数据段中的内容当作数据段来访问；</p></li><li><p>代码段</p><p>将段地址放在CS中，将段中第一条指令的偏移地址放在IP中<br>CPU将执行我们定义的代码段中的指令;</p></li><li><p>栈段</p><p>将段地址放在SS中，将栈顶单元的偏移地置放在SP中<br>CPU在需要进行栈操作(push、pop)时，就将我们定义的栈段当作栈空间来用。</p></li></ul></li></ul><blockquote><p>CS 是代码段寄存器，DS 是数据段寄存器，ES 是附加段(Extra Segment)寄存器。附加段的意思是，它是额外赠送的礼物，当需要在程序中同时使用两个数据段时，DS 指向一个，ES 指向另一个。可以在指令中指定使用 DS 和 ES 中的哪-个，如果没有指定，则默认是使用 DS。</p><p>SS 是栈段寄存器。IP 是指令指针(Instruction Pointer)寄存器，它只和 CS 一起使用，而且只有处理器才能直接改变它的内容。当一段代码开始执行时，CS 指向代码段的起始地址，IP则指向段内偏移。这样，由 CS 和 IP 共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令。然后处理器会自动根据当前指令的长度来改变 IP 的值，使它指向下一条指令。</p></blockquote><h1 id="3-汇编语言程序"><a href="#3-汇编语言程序" class="headerlink" title="3 汇编语言程序"></a>3 汇编语言程序</h1><h2 id="3-1-汇编程序概况"><a href="#3-1-汇编程序概况" class="headerlink" title="3.1 汇编程序概况"></a>3.1 汇编程序概况</h2><p>汇编程序：包含汇编指冷和伪指令的文本。</p><p><img src="https://pic.imgdb.cn/item/67107aebd29ded1a8ccc8935.png" alt="汇编程序的组成"></p><p><img src="https://pic.imgdb.cn/item/67107b69d29ded1a8ccce7e1.png" alt="汇编程序中包含的三种伪指令"></p><p><img src="https://pic.imgdb.cn/item/67107ee8d29ded1a8ccfe440.png"></p><h2 id="3-2-Loop指令"><a href="#3-2-Loop指令" class="headerlink" title="3.2 Loop指令"></a>3.2 Loop指令</h2><p>功能：实现循环(计数型循环)</p><p>指令的格式：loop 标号</p><p>CPU执行loop指令时要进行的操作：① (cx)=(cx)-1； ② 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;loop指令示例程序</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,2</span><br><span class="line">mov cx,11; 存放循环次数</span><br><span class="line">s:add ax ax; s为标号，循环跳转到此处</span><br><span class="line">1oop s</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="3-3-段前缀的使用"><a href="#3-3-段前缀的使用" class="headerlink" title="3.3 段前缀的使用"></a>3.3 段前缀的使用</h2><div class="table-container"><table><thead><tr><th>代码</th><th>释义</th></tr></thead><tbody><tr><td>mov ax, 2000<br />mov ds, ax<br />mov bx, 0<br />mov al, ds:[bx]</td><td>这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址<br />的“ds:” “cs:” “ss:” 或 “es:”，在汇编语言中称为段前缀</td></tr></tbody></table></div><h2 id="3-4-在代码段中使用数据"><a href="#3-4-在代码段中使用数据" class="headerlink" title="3.4 在代码段中使用数据"></a>3.4 在代码段中使用数据</h2><p>数据不能随意地在内存中存放，这是很危险的，容易导致重要内存存放的内容被修改。</p><p>应用案例：编程计算以下8个数据的和，结果存在ax存器中<br>0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H<br>只要求数据本身，并未指定在哪些内存单元中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0fedH, 0cbaH, 0987H</span><br><span class="line">; 在代码段中定义数据</span><br><span class="line">; dw: define word, 表示定义字型数据</span><br><span class="line">; dw 定义一个字</span><br><span class="line">; db 定义一个字节</span><br><span class="line">; dd 定义一个双字</span><br><span class="line">; 前面是人为定义在代码段中的数据，因此前面这部分肯定是不能被翻译为指令，而IP默认是为0的，怎么办呢？</span><br><span class="line">; 解决方法：定义一个标号start,指示代码开始的位置。</span><br><span class="line">start:mov bx, 0</span><br><span class="line">mov ax, 0</span><br><span class="line">mov cx, 8</span><br><span class="line">s: add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start; end的作用:除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。</span><br></pre></td></tr></table></figure><h2 id="3-5-在代码段中使用栈"><a href="#3-5-在代码段中使用栈" class="headerlink" title="3.5 在代码段中使用栈"></a>3.5 在代码段中使用栈</h2><p>问题：利用栈，将程序中定义的数据逆序存放。</p><p>程序的思路大致如下：<br>程序运行时，定义的数据存放在cs:0-cs:8单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆序存放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0.0,0,0,0</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">; 设置栈地址和指针 </span><br><span class="line">mov ax,cs</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,30h</span><br><span class="line">;入栈</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line">;出栈</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s1: pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s1</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="3-6-将数据、代码、栈放入不同段"><a href="#3-6-将数据、代码、栈放入不同段" class="headerlink" title="3.6 将数据、代码、栈放入不同段"></a>3.6 将数据、代码、栈放入不同段</h2><ul><li><p>上面这个将数据逆序存放的程序有如下特点和缺陷：</p><ul><li><p>特点：数据、栈和代码都在一个段。</p></li><li><p>问题：程序显得混乱，编程和阅读时都要注意何处是数据，何处是栈，何处是代码。</p><p>只适合应用于要处理的数据很少，用到的栈空间也小，加上没有多长的代码。</p></li></ul></li></ul><p>处理方法：数据段、代码段、栈端分开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line">; 数据段</span><br><span class="line">data segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">data ends</span><br><span class="line">; 栈段</span><br><span class="line">stack segment</span><br><span class="line">dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">stack ends</span><br><span class="line">; 代码段</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">; 初始化各段寄存器</span><br><span class="line">; 注意：cs代码段不用手动初始化，编译器自动完成代码段的初始化</span><br><span class="line">mov ax, stack</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 20h</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line">;入栈</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 8</span><br><span class="line">s0:push cs:[bx]</span><br><span class="line">add bx, 2</span><br><span class="line">loop s0</span><br><span class="line">;出栈</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 8</span><br><span class="line">s1: pop cs:[bx]</span><br><span class="line">add bx, 2</span><br><span class="line">loop s1</span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ul><li><strong>程序段前缀PSP</strong></li></ul><p>程序段前缀PSP(Pogram segment Prefix)是DOS 加载一个外部命令或应用程序(EXE、COM类型)时，在该程序段之前自动设置的一个具有256(100H)个字节的信息区域。</p><p><strong>当 DOS 把控制权转交给外部命令或应用程序时，数据段寄存器DS和附加段寄存器ES首先被设置为指向程序段前缀，即与PSP含有相同的段值，而不是一开始就指向程序的数据段和附加段。堆栈段寄存器SS和代码段寄存器CS的段地址要比 DS 和 ES 高/大0100H。</strong></p><p>PSP 含有许多的可用信息，其中偏移地址000H~007FH 范围为格式化区域，即加载程序时自动设置的各种信息区域；0080H~00FFH 区域为PSP的非格式化区域，即用来存储被加载程序的输入参数(DOS 加载一个外部命令或应用程序时，允许在被加载的程序名之后输入包括回车符在内的最多127个字符参数)。其中偏移地址0000H~0001H 内容为程序终止退出命令INT20H，0080H单元存储命令行参数的长度(字节数)，由0081H地址开始存储命令行参数，如无命令行参数则为0。</p><blockquote><p>当一个<code>.EXE</code>可执行文件加载到内存时，内存会被划分为几个区域：程序段前缀（PSP）、用户数据区、用户堆栈区以及用户代码段。PSP区域包含了关于可执行文件的控制信息，其开头的<code>INT 20H</code>指令用于结束程序。程序的执行通常始于将<code>DS</code>和<code>ES</code>段寄存器设置为PSP的地址，并在程序结束时使用<code>RET</code>指令将控制权转回DOS。   <a href="https://download.csdn.net/download/qq_37174420/29651038?utm_medium=distribute.pc_relevant_download.none-task-download-2~default~OPENSEARCH~Rate-8-29651038-download-4203060.257%5Ev16%5Epc_dl_relevant_base1_b&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-download-2~default~OPENSEARCH~Rate-8-29651038-download-4203060.257%5Ev16%5Epc_dl_relevant_base1_b&amp;spm=1003.2020.3001.6616.10">链接</a></p></blockquote><h1 id="4-内存寻址方式"><a href="#4-内存寻址方式" class="headerlink" title="4. 内存寻址方式"></a>4. 内存寻址方式</h1><h2 id="4-1-处理字符问题"><a href="#4-1-处理字符问题" class="headerlink" title="4.1 处理字符问题"></a>4.1 处理字符问题</h2><p>汇编程序中，用<code>&#39;...&#39;</code>的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的ASCII码.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line">; 数据段</span><br><span class="line">data segment</span><br><span class="line">db &#x27;unIx&#x27;</span><br><span class="line">db &#x27;foRk&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov al, &#x27;a&#x27;</span><br><span class="line">mov bl, &#x27;b&#x27;</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="4-2-bx-idata-方式寻址"><a href="#4-2-bx-idata-方式寻址" class="headerlink" title="4.2 [bx+idata]方式寻址"></a>4.2 [bx+idata]方式寻址</h2><p><code>[bx+idata]</code>表示一个内存单元，它的偏移地址为<code>(bx)+idata</code>（即bx中的数值加上idata）。</p><p>mov ax, [bx+200] / mov ax, [200+bx]的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，内存单元的段地址在ds中，偏移地址为200加上bx中的数值。</p><h2 id="4-3-SI和DI寄存器"><a href="#4-3-SI和DI寄存器" class="headerlink" title="4.3 SI和DI寄存器"></a>4.3 SI和DI寄存器</h2><p>首先，简单回顾一下CPU内部的寄存器</p><ul><li>8086CPU有14个寄存器<ul><li>通用寄存器：AX、BX、CX、DX</li><li>变址寄存器：SI、DI</li><li>指针寄存器：SP、BP</li><li>指令指针寄存器：IP</li><li>段寄存器：CS、SS、DS、ES</li><li>标志寄存器：PSW</li></ul></li></ul><p><strong>Sl和DI常执行与地址有关的操作</strong>：SI和DI是8086CPU中和Bx功能相近的寄存器；区别在于SI和DI不能够分成两个8位寄存器来使用。</p><blockquote><p>BX：通用寄存器，在计算存储器地址时，常作为基址寄存器用。<br>Sl(source index)：源变址寄存器。<br>Dl(destination index)：目标变址寄存器。</p></blockquote><p>下面的三组指令实现了相同的功能</p><div class="table-container"><table><thead><tr><th>指令1</th><th>指令2</th><th>指令3</th></tr></thead><tbody><tr><td>mov bx, 0<br />mov ax, [bx]</td><td>mov si, 0<br />mov ax, [si]</td><td>mov di, 0<br />mov ax, [di]</td></tr></tbody></table></div><ul><li><strong>[bx+si]和[bx+di]方式寻址</strong></li></ul><p>指令<code>mov [bx+si]</code>的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中。</p><ul><li><strong>[bx+si+idata]和[bx+di+idata]方式寻址</strong></li></ul><p>指令<code>mov [bx+si+idata]</code>的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中。</p><p><img src="https://pic.imgdb.cn/item/6711ce83d29ded1a8c18899f.png" alt="对内存的寻址方式小结"></p><h2 id="4-4-用于内存寻址的寄存器"><a href="#4-4-用于内存寻址的寄存器" class="headerlink" title="4.4 用于内存寻址的寄存器"></a>4.4 用于内存寻址的寄存器</h2><p>只有bx、bp、si、di可以用在[…]对内存单元寻址，通用寄存器除了bx，其他(ax、cx、dx)都不可用于寻址。</p><p><strong>bx、bp区别：</strong>bx默认指ds段，bp默认指ss段。</p><h2 id="4-5-汇编语言中数据位置的表达"><a href="#4-5-汇编语言中数据位置的表达" class="headerlink" title="4.5 汇编语言中数据位置的表达"></a>4.5 汇编语言中数据位置的表达</h2><p><img src="https://pic.imgdb.cn/item/6711f7aed29ded1a8c53fc0f.png" alt="汇编语言中数据位置的表达"></p><p><img src="https://pic.imgdb.cn/item/6711f874d29ded1a8c54a5ab.png" alt="指令要处理的数据有多长"></p><h2 id="4-6-用div指令实现除法"><a href="#4-6-用div指令实现除法" class="headerlink" title="4.6 用div指令实现除法"></a>4.6 用div指令实现除法</h2><ul><li><code>div</code>是除法指令，使用div作除法的时候<ul><li>被除数：默认放在AX 或 DX和AX中</li><li>除数：8位或16位，在寄存器或内存单元中</li><li>结果：……</li></ul></li></ul><div class="table-container"><table><thead><tr><th>被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>AX</td><td>8位内存或寄存器</td><td>AL</td><td>AH</td></tr><tr><td>AX和DX</td><td>16位内存或寄存器</td><td>AX</td><td>DX</td></tr></tbody></table></div><p>切记提前在默认的寄存器中设置好被除数，且默认寄存器不作别的用处。</p><h2 id="4-7-用dup设置内存空间"><a href="#4-7-用dup设置内存空间" class="headerlink" title="4.7 用dup设置内存空间"></a>4.7 用dup设置内存空间</h2><p>功能：dup和db、dw、dd 等数据定义伪指令配合使用，用来进行数据的重复。</p><div class="table-container"><table><thead><tr><th>指令</th><th>功能</th><th>相当于</th></tr></thead><tbody><tr><td>db 3 dup (0)</td><td>定义了3个字节，它们的值都是0</td><td>db 0,0,0</td></tr><tr><td>db 3 dup (0,1,2)</td><td>定义了9个字节，由0、1、2重复3次构成</td><td>db 0,1,2,0,1,2,0,1,2</td></tr><tr><td>db 3 dup (‘abc’,ABC’)</td><td>定义了18个字节，构成’abcABCabcABCabcABC</td><td>db ‘abcABCabcABCabcABC’</td></tr></tbody></table></div><h1 id="5-流程转移与子程序"><a href="#5-流程转移与子程序" class="headerlink" title="5. 流程转移与子程序"></a>5. 流程转移与子程序</h1><h2 id="5-1-转移综述"><a href="#5-1-转移综述" class="headerlink" title="5.1 转移综述"></a>5.1 转移综述</h2><ul><li>背景：一般情况下指令是顺序地逐条执行的，而在实际中，常需要改变程序的执行流程</li><li>转移指令<ul><li>可以控制CPU执行内存中某处代码的指令</li><li>可以修改IP，或同时修改CS和IP的指令</li></ul></li></ul><p><strong>转移指令的分类</strong></p><p><img src="https://pic.imgdb.cn/item/671203ded29ded1a8c65f09c.png" alt="转移指令的分类"></p><h2 id="5-2-操作符offset"><a href="#5-2-操作符offset" class="headerlink" title="5.2 操作符offset"></a>5.2 操作符offset</h2><p>用操作符offset取得标号的<strong>偏移地址</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; offset的使用：offset 标号</span><br><span class="line">assume cs:codeseg</span><br><span class="line"></span><br><span class="line">codeseg segment</span><br><span class="line">start:mov ax,offset start; 相当于mov ax,0</span><br><span class="line">    s:mov ax,offset s; 相当于mov ax,3</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="5-3-jmp指令——无条件转移"><a href="#5-3-jmp指令——无条件转移" class="headerlink" title="5.3 jmp指令——无条件转移"></a>5.3 jmp指令——无条件转移</h2><p>jmp指令的功能：无条件转移，可以只修改IP，也可以同时修改CS和IP。</p><ul><li>jmp指令要给出两种信息<ul><li>① 转移的目的地址；</li><li>② 转移的距离<ul><li>段间转移(远转移)：<code>jmp 2000:1000</code></li><li>段内短转移：<code>jmp short 标号</code>，IP的修改范围为 -128到127，8位的位移</li><li>段内近转移：<code>jmp near ptr 标号</code>，IP的修改范围为-32768到32767，16位的位移</li></ul></li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/67120bd4d29ded1a8c73d25d.png" alt="image.png"></p><ul><li><p><strong>转移地址在寄存器中的jmp指令</strong></p><ul><li>指令格式：jmp 16位寄存器</li><li>功能：IP=(16位寄存器)</li><li>举例：jmp ax；jmp bx</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/67121ce2d29ded1a8c8eb5ab.png"></p><h2 id="5-4-其他转移指令"><a href="#5-4-其他转移指令" class="headerlink" title="5.4 其他转移指令"></a>5.4 其他转移指令</h2><h3 id="5-4-1-jcxz指令"><a href="#5-4-1-jcxz指令" class="headerlink" title="5.4.1 jcxz指令"></a>5.4.1 jcxz指令</h3><p>指令格式：<code>jcxz 标号</code><br>功能：如果(cx)=0，则转移到标号处执行；若(cx)≠0，什么也不做(程序向下执行 )</p><p>jcxz是有<strong>条件转移指令</strong>，所有的有条件转移指令都是短转移，即对IP的修改范围都为-128~127。在对应的机器码中包含转移的位移，而不是目的地址。</p><h3 id="5-4-2-loop指令"><a href="#5-4-2-loop指令" class="headerlink" title="5.4.2 loop指令"></a>5.4.2 loop指令</h3><p>指令格式：<code>loop 标号</code><br>功能：循环，如果(cx)=0，跳出循环，；若(cx)≠0，则cx = cx-1，则转移到标号处执行。</p><h2 id="5-5-call指令和ret指令"><a href="#5-5-call指令和ret指令" class="headerlink" title="5.5 call指令和ret指令"></a>5.5 call指令和ret指令</h2><p>调用子程序：cal指令<br>返回：ret指令<br>实质：流程转移指令，它们都修改P，或同时修改CS和IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 0</span><br><span class="line">call s</span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">s:add ax, 0</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p><strong>（一）call指令介绍</strong></p><ul><li>CPU执行cal指令，进行两步操作<ul><li>(1) 将当前的IP或 CS和IP 压入栈中；</li><li>(2) 转移到标号处执行指令。</li></ul></li><li><code>call 标号</code><ul><li>16位位移 = “标号”处的地址-cal指令后的第一个字节的地址</li><li>16位位移的范围为-32768~32767，用补码表示</li><li>16位位移由编译程序在编译时算出。</li></ul></li><li>指令<code>call far ptr 标号</code>实现的是<strong>段间转移</strong><ul><li>(CS)=标号所在的段地址</li><li>(IP)=标号所在的偏移地址</li><li>该条指令相当于<ul><li>push CS → push lP → jmp far ptr 标号</li></ul></li></ul></li><li>转移地址在<strong>寄存器</strong>中的call指令<ul><li>显指令格式：<code>call 16位寄存器</code></li></ul></li><li>转移地址在<strong>内存</strong>中的call指令<ul><li><code>call word ptr 内存单元地址</code><ul><li>相当于：push IP → jmp word ptr 内存单元地址</li></ul></li><li><code>call dword ptr 内存单元地址</code><ul><li>相当于：push CS → push lP → jmp dword ptr 内存单元地址</li></ul></li></ul></li></ul><p><strong>（二）ret指令介绍</strong></p><div class="table-container"><table><thead><tr><th></th><th>ret指令</th><th>retf指令</th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>用栈中的数据修改IP的内容，从而实现近转移</td><td>用栈中的数据，修改CS和IP的内容，从而实现远转移</td></tr><tr><td><strong>相当于</strong></td><td>pop IP</td><td>pop IP; pop CS</td></tr></tbody></table></div><p><img src="https://pic.imgdb.cn/item/67131884d29ded1a8ce11dc3.png" style="zoom:60%"></p><p>此外，<code>ret</code>指令后面还可以<strong>直接跟数字</strong>，其作用相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret n ⇿ pop IP</span><br><span class="line">add sp, n</span><br></pre></td></tr></table></figure><h2 id="5-6-mul乘法指令"><a href="#5-6-mul乘法指令" class="headerlink" title="5.6 mul乘法指令"></a>5.6 mul乘法指令</h2><div class="table-container"><table><thead><tr><th></th><th><strong>8位乘法</strong></th><th><strong>16位乘法</strong></th></tr></thead><tbody><tr><td><strong>被乘数(默认)</strong></td><td>AL</td><td>AX</td></tr><tr><td><strong>乘数</strong></td><td>8位寄存器或内存字节单元</td><td>16位寄存器或内存字单元</td></tr><tr><td><strong>结果</strong></td><td>AX</td><td>DX(高位)和AX(低位)</td></tr></tbody></table></div><h2 id="5-7-标志寄存器PSW-FLAGS"><a href="#5-7-标志寄存器PSW-FLAGS" class="headerlink" title="5.7 标志寄存器PSW/FLAGS"></a>5.7 标志寄存器PSW/FLAGS</h2><h3 id="5-7-1-认识标志寄存器的特殊之处"><a href="#5-7-1-认识标志寄存器的特殊之处" class="headerlink" title="5.7.1 认识标志寄存器的特殊之处"></a>5.7.1 认识标志寄存器的特殊之处</h3><p>标志寄存器flag的结构：</p><p>flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p><p>8086CPU中标志寄存器flag是16位的，其中没有使用flag的1、3、5、12、13、14、15位，这些位不具有任何含义。</p><p><img src="https://pic.imgdb.cn/item/67134d48d29ded1a8c2cbdcc.png" style="zoom:50%"></p><h3 id="5-7-2-直接访问标志寄存器的方法"><a href="#5-7-2-直接访问标志寄存器的方法" class="headerlink" title="5.7.2 直接访问标志寄存器的方法"></a>5.7.2 直接访问标志寄存器的方法</h3><p><code>pushf</code>：将标志寄存器的值压栈；</p><p><code>popf</code>：从栈中弹出数据，送入标志寄存器中。</p><h3 id="5-7-3-ZF-零标志-Zero-Flag"><a href="#5-7-3-ZF-零标志-Zero-Flag" class="headerlink" title="5.7.3 ZF-零标志(Zero Flag)"></a>5.7.3 ZF-零标志(Zero Flag)</h3><ul><li>ZF标记相关指令的计算结果是否为0<ul><li>ZF=1，表示“结果是0”，1表示“逻辑真”</li><li>ZF=0，表示“结果不是0”，0表示“逻辑假“</li></ul></li></ul><p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：add、sub、mul、div、inc、or、and等，它们大都是运算指令，进行逻辑或算术运算；</p><p>有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，它们大都是传送指令。</p><p>使用一条指令的时候，要注意这条指令的全部功能其中包括执行结果对标记寄存器的哪些标志位造成影响。</p><h3 id="5-7-4-PF-奇偶标志-Parity-Flag"><a href="#5-7-4-PF-奇偶标志-Parity-Flag" class="headerlink" title="5.7.4 PF-奇偶标志(Parity Flag)"></a>5.7.4 PF-奇偶标志(Parity Flag)</h3><ul><li>PF记录指令执行后，结果的所有二进制位中1的个数：<ul><li>1的个数为偶数，PF=1</li><li>1的个数为奇数，PF=0。</li></ul></li></ul><h3 id="5-7-5-SF-符号标志-Sign-Flag"><a href="#5-7-5-SF-符号标志-Sign-Flag" class="headerlink" title="5.7.5 SF-符号标志(Sign Flag)"></a>5.7.5 SF-符号标志(Sign Flag)</h3><ul><li>SF记录指令执行后，将结果视为有符号数<ul><li>结果为负，SF=1</li><li>结果为非负，SF=0</li></ul></li></ul><h3 id="5-7-6-CF-进位标志-Carry-Flag"><a href="#5-7-6-CF-进位标志-Carry-Flag" class="headerlink" title="5.7.6 CF-进位标志(Carry Flag)"></a>5.7.6 CF-进位标志(Carry Flag)</h3><p>在进行<strong>无符号数运算</strong>的时候，CF记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p><ul><li>CF记录指令执行后<ul><li>有进位或借位，CF = 1</li><li>无进位或借位，CF = 0</li></ul></li></ul><h3 id="5-7-7-OF-溢出标志-Overflow-Flag"><a href="#5-7-7-OF-溢出标志-Overflow-Flag" class="headerlink" title="5.7.7 OF-溢出标志(Overflow Flag)"></a>5.7.7 OF-溢出标志(Overflow Flag)</h3><p>在进行<strong>有符号数运算</strong>的时候，如结果超过了机器所能表示的范围称为溢出</p><ul><li>OF记录有符号数操作指令执行后<ul><li>有溢出，OF=1</li><li>无溢出，OF=0</li></ul></li></ul><h2 id="5-8-带进-借-位的加减法"><a href="#5-8-带进-借-位的加减法" class="headerlink" title="5.8 带进(借)位的加减法"></a>5.8 带进(借)位的加减法</h2><h3 id="5-8-1-adc带进位加法指令"><a href="#5-8-1-adc带进位加法指令" class="headerlink" title="5.8.1 adc带进位加法指令"></a>5.8.1 adc带进位加法指令</h3><ul><li>adc是带进位加法指令，它利用了CF位上记录的进位值。<ul><li>格式：adc 操作对象1, 操作对象2</li><li>功能：操作对象1= 操作对象1+操作对象2+CF</li></ul></li></ul><h3 id="5-8-2-sbb带借位减法指令"><a href="#5-8-2-sbb带借位减法指令" class="headerlink" title="5.8.2 sbb带借位减法指令"></a>5.8.2 sbb带借位减法指令</h3><ul><li>格式：sbb 操作对象1, 操作对象2<ul><li>功能：操作对象1=操作对象1-操作对象2-CF</li><li>与sub区别：利用CF位上记录的借位值 </li></ul></li></ul><h2 id="5-9-cmp与条件转移指令"><a href="#5-9-cmp与条件转移指令" class="headerlink" title="5.9 cmp与条件转移指令"></a>5.9 cmp与条件转移指令</h2><h3 id="5-9-1-cmp指令"><a href="#5-9-1-cmp指令" class="headerlink" title="5.9.1 cmp指令"></a>5.9.1 cmp指令</h3><ul><li>cmp是比较指令，功能相当于减法指令，但不保存结果。cmp指令执行后，将<strong>对标志寄存器产生影响</strong>。<ul><li>格式：cmp 操作对象1,操作对象2</li><li>功能：计算 操作对象1-操作对象2</li></ul></li></ul><h3 id="5-9-2-条件转移指令jxxx"><a href="#5-9-2-条件转移指令jxxx" class="headerlink" title="5.9.2 条件转移指令jxxx"></a>5.9.2 条件转移指令jxxx</h3><p>格式：<code>jxxx 标号</code></p><p><img src="https://pic.imgdb.cn/item/67135b0dd29ded1a8c3f3a55.png" alt="根据单个标志位转移的指令" style="zoom:60%"></p><p><img src="https://pic.imgdb.cn/item/67135bd5d29ded1a8c411805.png" alt="根据无符号数比较结果进行转移的指令" style="zoom:60%"></p><p><img src="https://pic.imgdb.cn/item/67135c3fd29ded1a8c420f98.png" alt="根据有符号数比较结果进行转移的指令" style="zoom:60%"></p><p><strong>条件转移指令通常都和cmp相配合使用，cmp指令改变标志位，jxxx根据相应的标志寄存器判断是否跳转。</strong></p><h2 id="5-10-DF标志和串传送指令"><a href="#5-10-DF标志和串传送指令" class="headerlink" title="5.10 DF标志和串传送指令"></a>5.10 DF标志和串传送指令</h2><h3 id="5-10-1-DF-方向标志位-Direction-Flag"><a href="#5-10-1-DF-方向标志位-Direction-Flag" class="headerlink" title="5.10.1 DF-方向标志位(Direction Flag)"></a>5.10.1 DF-方向标志位(Direction Flag)</h3><ul><li>功能：在串处理指令中，控制每次操作后si，di的增减。<ul><li>DF=0：每次操作后si，di递增；</li><li>DF=1：每次操作后si，di递减。</li></ul></li><li>对DF位进行设置的指令<ul><li><code>cld指令</code>：将标志寄存器的DF位设为0(clear)</li><li><code>std指令</code>：将标志寄存器的DF位设为1(setup)</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/671369dbd29ded1a8c58d454.png" style="zoom:50%"></p><h3 id="5-10-2-rep指令"><a href="#5-10-2-rep指令" class="headerlink" title="5.10.2 rep指令"></a>5.10.2 rep指令</h3><ul><li>rep指令常和串传送指令搭配使用<ul><li>功能：根据cx的值，重复执行后面的指令</li><li>例如：<code>rep movsb</code></li><li>等价于：<br>wjh：movsb<br>loop wjh </li></ul></li></ul><p>补充：<code>movsb</code>字节传送指令</p><p>格式：movsb<br>功能：执行movsb指令相当于进行下面几步操作:<br>（1）((es)×16+(di))=((ds)×16+(si))</p><p>（2） 如果<code>df=0</code>则：(si)=(si)+1，(di)=(di)+1；如果<code>df=1</code>则：(si)=(si)-1，(di)=(di)-1</p><h1 id="6-中断及外部设备操作"><a href="#6-中断及外部设备操作" class="headerlink" title="6. 中断及外部设备操作"></a>6. 中断及外部设备操作</h1><h2 id="6-1-移位指令"><a href="#6-1-移位指令" class="headerlink" title="6.1 移位指令"></a>6.1 移位指令</h2><div class="table-container"><table><thead><tr><th>移位指令</th><th>示例代码</th><th>释义</th><th>是否影响CF位</th></tr></thead><tbody><tr><td>逻辑左移<br />SHL OPR,CNT</td><td>mov al,01001000b<br />shl al,1</td><td>二进制数字向左移动一位，<br />末尾补0，移出的一位进到CF中</td><td>是</td></tr><tr><td>循环左移<br />ROL OPR, CNT</td><td>mov al,01001000b<br />rol al,1</td><td>二进制数字向左移动一位，<br />然后补到末尾，移出的一位进到CF中</td><td>是</td></tr><tr><td>逻辑右移<br />SHR OPR,CNT</td><td>mov al,01001000b<br />shr al,1</td><td>二进制数字向右移动一位，<br />开头补0，移出的一位进到CF中</td><td>是</td></tr><tr><td>循环右移<br />ROR OPR,CNT</td><td>mov al,01001000b<br />ror al,1</td><td>二进制数字向右移动一位，<br />然后补到开头，移出的一位进到CF中</td><td>是</td></tr><tr><td>算术左移<br />SAL OPR,CNT</td><td>mov al,01001000b<br />sal al,1</td><td>二进制数字向左移动一位，<br />末尾补0，移出的一位进到CF中</td><td>是</td></tr><tr><td>算术右移<br />SAR OPR,CNT</td><td>mov al,01001000b<br />sar al,1</td><td>二进制数字向右移动一位，<br />但是开头一位保持不变，移<br />出的一位进到CF中</td><td>是</td></tr><tr><td>带进位循环左移<br />RCL OPR,CNT</td><td>mov al,01001000b<br />rcl al,1</td><td>二进制数字向左移动一位，<br />原CF中的数值回到末尾，移<br />出的一位进到CF中</td><td>是</td></tr><tr><td>带进位循环右移<br />RCR OPR,CNT</td><td>mov al,01001000b<br />rcr al,1</td><td>二进制数字向右移动一位，<br />原CF中的数值回到开头，移<br />出的一位进到CF中</td><td>是</td></tr></tbody></table></div><p>注意①：当移动的位数大于1时，必须使用cl寄存器中转移动的位数。</p><p>注意②：逻辑左移相当于乘以2，逻辑右移相当于除以2。</p><h2 id="6-2-操作显存数据"><a href="#6-2-操作显存数据" class="headerlink" title="6.2 操作显存数据"></a>6.2 操作显存数据</h2><p><strong>屏慕上的内容=显存中的数据</strong></p><p>根据前面的图可知，8086CPU的显存地址空间位于：A0000到BFFFF区间。其中B8000h~BFFFFh共32K的空间，是8*25 彩色字符模式第0页的显示缓冲区。</p><blockquote><p>B8000h~BFFFFh共32K的空间的简单解释</p><p><code>BFFFFh-B8000h = 7FFFH = 8000H → 2^3*2^12 = 2^3*2^2*2^10 = 32*1Kb</code></p></blockquote><p><img src="https://pic.imgdb.cn/item/6715ae36d29ded1a8c32e3ab.png" alt="显示缓冲区结构"></p><blockquote><p>‌<strong>在显存中，一个字符确实占两个字节。</strong>‌ 在80*25彩色字符模式下，每个字符由两个字节组成，一个字节存储字符的ASCII码，另一个字节存储字符的属性（如背景色、前景色等）‌。</p><p>在显存中，每个字符占用两个字节的原因是因为：</p><ul><li>‌<strong>字符的ASCII码</strong>‌：一个字节(低位)用于存储字符的ASCII码，表示字符本身。</li><li>‌<strong>字符的属性</strong>‌：另一个字节(高位)用于存储字符的属性，如背景色、前景色、闪烁、高亮等。</li></ul><p>这种设计使得每个字符不仅可以显示出来，还可以通过属性字节来控制其显示效果。</p></blockquote><p>例：编程序，在屏幕的中间，自底蓝字，显示Welcome to masm!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codeseg, ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;welcome to masm!&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codeseg segment</span><br><span class="line">start:</span><br><span class="line">; 初始化寄存器</span><br><span class="line">mov ax, datasg</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, 0B800H</span><br><span class="line">mov es, ax</span><br><span class="line">mov si, 0</span><br><span class="line">mov di, 160*12+80-16</span><br><span class="line">; 显示字符串</span><br><span class="line">mov cx,16</span><br><span class="line">w:  mov al, [si]</span><br><span class="line">mov es:[di], al</span><br><span class="line">inc di</span><br><span class="line">mov al, 71H</span><br><span class="line">mov es:[di], al</span><br><span class="line">inc si</span><br><span class="line">inc di</span><br><span class="line">loop w</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="6-3-描述内存单元的标号"><a href="#6-3-描述内存单元的标号" class="headerlink" title="6.3 描述内存单元的标号"></a>6.3 描述内存单元的标号</h2><h3 id="6-3-1-关于标号"><a href="#6-3-1-关于标号" class="headerlink" title="6.3.1 关于标号"></a>6.3.1 关于标号</h3><p>代码段中的标号可以用来标记指令、段的起始地址。</p><p>代码段中的数据也可以用标号。</p><h3 id="6-3-2-数据标号——去了冒号的数据标号"><a href="#6-3-2-数据标号——去了冒号的数据标号" class="headerlink" title="6.3.2 数据标号——去了冒号的数据标号"></a>6.3.2 数据标号——去了冒号的数据标号</h3><p>数据标号标记了存储数据的单元的地址和长度<br>数据标号不同于仅仅表示地址的地址标号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">;数据标号a、b前面不加:，注意这段数据定义在数据段也是可以这样用的</span><br><span class="line">a db 1 2,3,4 5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">start : mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s: mov al,a[si];相当于[si+a]</span><br><span class="line">mov ah,0</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="6-3-3-扩展用法：二级指针：将标号当作数据来定义"><a href="#6-3-3-扩展用法：二级指针：将标号当作数据来定义" class="headerlink" title="6.3.3 扩展用法：二级指针：将标号当作数据来定义"></a>6.3.3 扩展用法：二级指针：将标号当作数据来定义</h3><p><img src="https://pic.imgdb.cn/item/6715b66dd29ded1a8c43abce.png"></p><h2 id="6-4-直接定址表"><a href="#6-4-直接定址表" class="headerlink" title="6.4 直接定址表"></a>6.4 直接定址表</h2><h3 id="6-4-1-数据的直接定址表"><a href="#6-4-1-数据的直接定址表" class="headerlink" title="6.4.1 数据的直接定址表"></a>6.4.1 数据的直接定址表</h3><p>直接定址表：用查表的方法解决问题。</p><p>有如下问题：以十六进制的形式在屏幕中间显示给定的byte型数据。</p><p>新方按：建立一张表，表中依次存储字符“0” ~ “F”，我们可以通过数值0~15直接查找到对应的字符<br><code>table db &#39;0123456789ABCDEF&#39; ;字符表</code></p><h3 id="6-4-2-代码的直接定址表"><a href="#6-4-2-代码的直接定址表" class="headerlink" title="6.4.2 代码的直接定址表"></a>6.4.2 代码的直接定址表</h3><p><strong><font color=red>函数指针数组</font></strong>，示例如下</p><p><img src="https://pic.imgdb.cn/item/6715c067d29ded1a8c5b45ec.png"></p><h2 id="6-5-中断及其处理"><a href="#6-5-中断及其处理" class="headerlink" title="6.5 中断及其处理"></a>6.5 中断及其处理</h2><h3 id="6-5-1-中断的概念"><a href="#6-5-1-中断的概念" class="headerlink" title="6.5.1 中断的概念"></a>6.5.1 中断的概念</h3><p>中断：CPU不再接着(刚执行完的指令)向下执行，而是转去处理中断信息</p><p>内中断：由CPU内部发生的事件而引起的中断</p><p>外中断：由外部设备发生的事件引起的中断</p><p><img src="https://pic.imgdb.cn/item/6715c75bd29ded1a8c6a63ec.png"></p><h3 id="6-5-2-8086的内中断"><a href="#6-5-2-8086的内中断" class="headerlink" title="6.5.2 8086的内中断"></a>6.5.2 8086的内中断</h3><ul><li>CPU内部产生的中断信息<ul><li>(1) 除法错误，比如:执行div指令产生的除法溢出</li><li>(2) 单步执行</li><li>(3) 执行<code>into 指令</code></li><li>(4) 执行<code>int 指令</code></li></ul></li><li>8086的中断类型码<ul><li>(1) 除法错误：0</li><li>(2) 单步执行：1</li><li>(3) 执行into指令：4</li><li>(4) 执行 int n指令，立即数n为中断类型码</li></ul></li><li>中断处理程序<ul><li>CPU接到中断信息怎么办?<ul><li>执行中断处理程序</li></ul></li><li>中断处理程序在哪里 ?<ul><li>中断信息和其处理程序的入口地址之间有某种联系，CPU根据中断信息可以找到要执行的处理程序。</li></ul></li><li>中断向量表<ul><li>由中断类型码查表得到中断处理程序的入口地址，从而定位中断处理程序。</li></ul></li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/6715c9bbd29ded1a8c6fce83.png" style="zoom:50%"></p><ul><li>中断过程<ul><li>中断过程由CPU的硬件自动完成</li><li>用中断类型码找到中断向量，并用它设置CS和IP</li></ul></li><li>8086CPU的中断过程<ul><li>(1) 从中断信息中取得中断类型码</li><li>(2) 标志寄存器的值入栈——中断过程中要改变标志寄存器的值，需要先行保护</li><li>(3) 设置标志寄存器的第8位TF和第9位IF的值为0</li><li>(4) CS寄存器的内容入栈</li><li>(5) IP寄存器的内容入栈</li><li>(6) 从中断向量表读取中断处理程序的入口地址，设置IP和CS。</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/6715f000d29ded1a8cb9b64d.png" style="zoom:60%"></p><h2 id="6-6-中断处理程序及其结构"><a href="#6-6-中断处理程序及其结构" class="headerlink" title="6.6 中断处理程序及其结构"></a>6.6 中断处理程序及其结构</h2><p>CPU随时都可能检测到中断信息，所以中断处理程序必须常驻内存(一直存储在内存某段空间之中)。<br>中断处理程序的入口地址，即<strong>中断向量</strong>，必须存储在对应的中断向量表表项中(<code>0000:0000-0000:03FF</code>)。</p><h3 id="6-6-1-编制中断处理程序—以除法错误中断为例"><a href="#6-6-1-编制中断处理程序—以除法错误中断为例" class="headerlink" title="6.6.1 编制中断处理程序—以除法错误中断为例"></a>6.6.1 编制中断处理程序—以除法错误中断为例</h3><p>问题：如何编制中断处理程序?<br>方案：通过对 0号中断，即除法错误的中断处理，体会中断处理程序处理的技术问题<br>预期效果：编写一个0号中断处理程序，它的功能是在屏幕中间显示“overflow!”后，然后返回到操作系统。</p><ul><li><strong>问题1：中断处理子程序应该放在哪里？</strong></li></ul><p>中断处理子程序应该存放在内存的确定位置，但这里我们是模拟中断处理，要重新找个地方，不破坏系统的中断处理函数。</p><p>在操作系统之上使用计算机，所有的硬件资源都在操作系统的管理之下，应该向操作系统申请获得存放中断处理子程序的内存。</p><p>使用汇编语言可以<strong>绕过操作系统</strong>，直接在找到一块别的程序不会用到的内存区，将中断处理子程序传送到其中即可。（注意：不是工程化的方法，但也体现实用技巧）</p><p>内存<code>0000:0000~0000:03FFF</code>大小为1KB的空间是系统存放中断向量表，DOS系统和其他应用程序都不会随便使用这段空间。8086支持256个中断，但实际上系统中要处理的中断事件远没有达到256个。利用中断向量表中的空闲单元来存放我们的程序。估计出，中断处理子程序的长度不可能超过256个字节，就选用从0000:0200至0000:02FF的256个字节的空间。</p><div class="table-container"><table><thead><tr><th>地址</th><th>内容</th></tr></thead><tbody><tr><td>0000：0000</td><td>IP 0200</td></tr><tr><td>0000：0002</td><td>CS 0000</td></tr></tbody></table></div><ul><li><strong>问题2：怎么写安装程序?</strong></li></ul><p>(1) 编写可以显示“overflow!”的中断处理程序，命名为：do0<br>(2) 安装程序：将do0送入内存0000:0200处<br>(3) 将do0中断处理程序的入口地址0000:0200存储在中断向量表0号表项中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; 程序框架</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">do0安装程序</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">do0: 显示字符串 &quot;overflow !&quot;</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">do0end: nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;; do0安装程序</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0; 设置ds:si指向源地址cs:do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h; 设置es:di指向目的地址0000:0200h</span><br><span class="line">mov cx, offset do0end - offset do0; 设置cx为传输长度为do0部分代码的长度</span><br><span class="line">cld; 设置传输方向为正</span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure><ul><li><strong>问题3：中断处理函数do0怎么写？</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;; do0中断处理子函数体</span><br><span class="line">do0: jmp short do0start</span><br><span class="line">db &#x27;overflow!&#x27;</span><br><span class="line">do0start:</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, 202h; jmp short do0start这个语句占2字节，故是200+2=202h</span><br><span class="line"></span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,12*160+36*2</span><br><span class="line">mov cx,9</span><br><span class="line">s:mov al,[si]</span><br><span class="line">mov es:[di],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><ul><li><strong>问题4：如何设置中断向量表？</strong></li></ul><p>设置中断向量表任务：将do0的入口地址0:200h，写到中断向量表的0号表项中即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200h</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br></pre></td></tr></table></figure><h3 id="6-6-2-单步中断"><a href="#6-6-2-单步中断" class="headerlink" title="6.6.2 单步中断"></a>6.6.2 单步中断</h3><p>由Debug中的t命令说起…</p><p>程序的正常执行：取指令、改变CS:IP、执行指令、取指令……</p><p>Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。</p><ul><li>是什么，让CPU能执行一条指令就停下来？<ul><li>Debug利用了CPU提供的单步中断的功能</li><li>使用t命令时，Debug将TF标志设为1，使CPU工作在单步中断方式下…</li><li>自定义单步中断处理程序，还可以实现特殊的功能。</li></ul></li></ul><p><strong>单步中断过程与处理</strong></p><ul><li>两个和中断相关的寄存器标志位<ul><li>TF-陷阱标志(Trap flag)：用于调试时的单步方式操作。<ul><li>当TF=1时，每条指令执行完后产生陷阱，由系统控制计算机</li><li>当TF=0时，CPU正常工作，不产生陷阱。</li></ul></li><li>IF-中断标志(Iinterrupt flag)<ul><li>当IF=1时，允许CPU响应可屏蔽中断请求;</li><li>当IF=0时，关闭中断</li></ul></li></ul></li></ul><p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断(中断类型码为1)，引发中断过程，执行中断处理程序。</p><ul><li>中断过程<ul><li>(1)取得中断类型码1;</li><li>(2) 标志寄存器入栈，TF、IF设置为0;<ul><li>中断处理程序也由一条条指令组成的。如果在执行中断处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，转去执行单步中断的中断处理程序的第一条指令……<br>上面的过程将陷入一个永远不能结束的循环CPU永远执行单步中断处理程序的第一条指令所以，在进入中断处理程序之前，设置TF=0。</li></ul></li><li>(3) CS、IP入栈;</li><li>(4) (IP)=(1×4), (CS)=(1×4+2)</li></ul></li></ul><p><strong>应用：中断不响应的情况</strong></p><p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应。</p><p>例如：在执行完向 ss寄存器传送数据的指令后，即便是发生中断，CPU 也不会响应。<br>原因：<code>ss:sp</code>联合指向栈顶，而对它们的设置应该<strong>连续完成，不能被中断打断</strong>。</p><h2 id="6-7-由int指令引发的中断"><a href="#6-7-由int指令引发的中断" class="headerlink" title="6.7 由int指令引发的中断"></a>6.7 由int指令引发的中断</h2><p>int格式：<code>int n</code>，n为<strong>立即数</strong>，表示中断类型码</p><p>功能：引发中断过程</p><ul><li>CPU执行intn指令，相当于引发一个n号中断的中断过程，执行过程如下<ul><li>(1) 取中断类型码n；</li><li>(2) 标志寄存器入栈，IF=0，TF=0；</li><li>(3) CS、IP入栈；</li><li>(4) (IP)=(n×4)，(CS)=(n×4+2)。</li></ul></li></ul><p>小小结：<br><code>int</code>指令的最终功能和<code>call</code>指令相似，都是调用一段程序。一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。</p><p>编写供应用程序调用的中断例程<br>技术手段：编程时，可以用<code>int</code>指令调用子程序；此子程序即中断处理程序，简称为中断例程。可以自定义中断例程实现特定功能。</p><ul><li><strong>中断处理程序的常规的步骤</strong><ul><li>(1) 保存用到的寄存器。</li><li>(2) 处理中断。</li><li>(3) 恢复用到的寄存器。</li><li>(4) 用 iret指令返回。</li></ul></li></ul><h2 id="6-8-BIOS和DOS中断处理"><a href="#6-8-BIOS和DOS中断处理" class="headerlink" title="6.8 BIOS和DOS中断处理"></a>6.8 BIOS和DOS中断处理</h2><h3 id="6-8-1-BIOS-——-基本输入输出系统"><a href="#6-8-1-BIOS-——-基本输入输出系统" class="headerlink" title="6.8.1 BIOS —— 基本输入输出系统"></a>6.8.1 BIOS —— 基本输入输出系统</h3><p><img src="https://pic.imgdb.cn/item/671611ffd29ded1a8cf80eca.png" style="zoom:60%"></p><p><strong>（一）BIOS，是在系统板的ROM中存放着一套程序</strong></p><p>容量：8KB，地址：从FE000H开始</p><blockquote><p>BIOS是一个芯片，焊在主板上的，计算机(主板)一通电，BIOS芯片就开始工作，也即开始检查各个硬件是否正常。</p></blockquote><ul><li>BIOS中的主要内容<ul><li>(1) 硬件系统的检测和初始化程序</li><li>(2) 外部中断和内部中断的中断例程</li><li>(3) 用于对硬件设备进行I/0操作的中断例程</li><li>(4) 其他和硬件系统相关的中断例程</li></ul></li><li>BIOS的意义<ul><li>使用BIOS功能调用，程序员不用了解硬件操作细节，直接使用指令设置参数，并中断调用BIOS例程，即可完成相关工作!</li><li>使用BIOS功能调用：(1) 方便编程；(2) 能写出简洁、可读性好、易于移植的程序。</li></ul></li></ul><p><strong>（二）BIOS中断调用示例</strong></p><p>任务：在屏幕的5行12列显示3个红底高亮闪烁绿色的a。</p><p>方案：<strong>用BIOS的10h中断</strong>。</p><p>当<code>ah=2</code>时，调用第10h中断例程的2号子程序，设置光标位置；<br>当<code>ah=9</code>时，调用第10h中断例程的9号子程序，在光标位置显示字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ah,2;置光标功能</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov dh,5;dh中放行号</span><br><span class="line">mov dl,12;dl中放列号</span><br><span class="line">int 10h;调用BIOS的10h中断</span><br><span class="line"></span><br><span class="line">mov ah,9;显示字符功能</span><br><span class="line">mov al,&#x27;a&#x27;;字符a</span><br><span class="line">mov bl,11001010b;颜色属性</span><br><span class="line">mov bh,0;第o页</span><br><span class="line">mov cx,3;字符重复个数</span><br><span class="line">int 10h;调用BIOS的10h中断</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>（三）有哪些BIOS中断，怎么用</strong></p><p><img src="https://pic.imgdb.cn/item/671616ebd29ded1a8c02bba0.png"></p><h3 id="6-8-2-DOS中断"><a href="#6-8-2-DOS中断" class="headerlink" title="6.8.2 DOS中断"></a>6.8.2 DOS中断</h3><p>常见的DOS中断：</p><p><img src="https://pic.imgdb.cn/item/67161a4ed29ded1a8c0a3965.png"></p><p>BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时常用到的功能。<br>和硬件设备相关的DOS中断例程中，一般都调用BIOS的中断例程。</p><h3 id="6-8-3-BIOS和DOS中断例程的安装过程"><a href="#6-8-3-BIOS和DOS中断例程的安装过程" class="headerlink" title="6.8.3 BIOS和DOS中断例程的安装过程"></a>6.8.3 BIOS和DOS中断例程的安装过程</h3><p>(1) CPU一加电，初始化<code>(CS)=0FFFFH，(IP)=0</code>，自动从<code>FFFF:0</code>单元开始执行程序。<code>FFFF:0</code>处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</p><p>(2) 初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。</p><p>(3) 硬件系统检测和初始化完成后，调用<code>int 19h</code>进行操作系统的引导。从此将计算机交由操作系统控制。</p><p>(4) DOS启动后，除完成其它工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</p><h2 id="6-9-端口的读写"><a href="#6-9-端口的读写" class="headerlink" title="6.9 端口的读写"></a>6.9 端口的读写</h2><h3 id="6-9-1-引入——用端口访问外设：以发声为例"><a href="#6-9-1-引入——用端口访问外设：以发声为例" class="headerlink" title="6.9.1 引入——用端口访问外设：以发声为例"></a>6.9.1 引入——用端口访问外设：以发声为例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codeseg</span><br><span class="line">codeseg segment</span><br><span class="line"></span><br><span class="line">start: mov al, 08h;设置声音的频率</span><br><span class="line">out 42h, al</span><br><span class="line">out 42h, al</span><br><span class="line">in al, 61h;读设备控制器端口原值</span><br><span class="line"></span><br><span class="line">mov ah, al;保存原值</span><br><span class="line">or al, 3;打开扬声器和定时器</span><br><span class="line">out 61h, al;接通扬声器，发声</span><br><span class="line"></span><br><span class="line">mov cx,60000 ;延时</span><br><span class="line">delay:nop</span><br><span class="line">loop delay</span><br><span class="line"></span><br><span class="line">mov al, ah;恢复端口原值</span><br><span class="line">out 61h, al</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ul><li><strong>补充：CPU的邻居</strong>——CPU可以直接读写3个地方的数据<ul><li>(1) CPU 内部的寄存器；</li><li>(2) 内存单元；</li><li>(3) (物理外设)端口<ul><li>各种接口卡，网卡、显龙等</li><li>主板上的接口芯片</li><li>其他芯片</li></ul></li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/67161f83d29ded1a8c1564ce.png" style="zoom:50%"></p><p><img src="https://pic.imgdb.cn/item/671620f3d29ded1a8c189a25.png" style="zoom:60%"></p><h3 id="6-9-2-端口的读写指令"><a href="#6-9-2-端口的读写指令" class="headerlink" title="6.9.2 端口的读写指令"></a>6.9.2 端口的读写指令</h3><ul><li>读写内存与寄存器的指令<ul><li><code>mov, add, push...</code></li></ul></li><li>读写端口的指令<ul><li><code>in</code>： CPU从端口读取数据</li><li><code>out</code>：CPU往端口写入数据</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/6716226cd29ded1a8c1c00a0.png"></p><ul><li><p>端口的读写指令示例</p><ul><li><p>对0~255以内的端口进行读写，端口号用立即数给出</p><ul><li>```assembly<br>in al, 20h    ;从20h端口读入一个字节<br>out 21h, al    ;往21h端口写入一个字节<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 显对256~65535的端口进行读写时，端口号放在dx中</span><br><span class="line"></span><br><span class="line">  - ```assembly</span><br><span class="line">    mov dx,3f8h;将端口号3f8送入dx</span><br><span class="line">    in al,dx;从3f8h端口读入一个字节</span><br><span class="line">    out dx,al;向3f8h端口写入一个字节</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>注意：在in和out指令中，只能使用<code>ax</code>或<code>al</code>来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用<code>al</code>，访问16位端口时用<code>ax</code>。</p><h3 id="6-10-操作CMOS-RAM芯片"><a href="#6-10-操作CMOS-RAM芯片" class="headerlink" title="6.10 操作CMOS RAM芯片"></a>6.10 操作CMOS RAM芯片</h3><h3 id="6-10-1-CMOS-RAM-芯片"><a href="#6-10-1-CMOS-RAM-芯片" class="headerlink" title="6.10.1 CMOS RAM 芯片"></a>6.10.1 CMOS RAM 芯片</h3><p><img src="https://pic.imgdb.cn/item/6716376ad29ded1a8c44e4cb.png"  alt="系统开机BIOS界面" style="zoom:70%"></p><p>我们在操作计算机的时候，电脑一开始的时候呢，我们按f8可以进入一个叫做bios设置当中，在设置里边包含了一些时间呀包括其他的一些整个系统的信息，如果没有这些信息的话呢，计算机是不能够启动起来的。</p><p>那么其实做出这些工作，它得益于在整个的主板上有这么一个所谓的<strong>cmos ram芯片</strong>，它包含着一个实时的时钟和一个有128个存储单元的ram存储器。</p><ul><li>CMOS RAM 芯片<ul><li>(1) 包含一个实时钟和一个有128个存储单元的RAM存储器</li><li>(2) 128 个字节的 RAM 中存储：内部实时钟、系统配置信息，相关的程序(用于开机时配置系统信息，引导系统启动)。</li><li>(3) CMOS RAM 芯片靠电池供电，关机后其内部的实时钟仍可正常工作 ，特别的是，此块RAM中的信息不丢失（一般RAM掉电丢失信息，这个其实是因为在这里边有一块纽扣电池为其供电）。</li><li>(4) 该芯片内部有两个端口，端口地址为70h和71h，CPU通过这两个端口读写CMOS RAM。<ul><li>70h地址端口，存放要访问的CMOS RAM单元的地址</li><li>71h数据端口，存放从选定的单元中读取的数据，或要写入到其中的数据。</li></ul></li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/67163932d29ded1a8c46ac79.png" style="zoom:70%"></p><h3 id="6-10-2-端口操作示例：提取CMOSRAM中存储的时间信息"><a href="#6-10-2-端口操作示例：提取CMOSRAM中存储的时间信息" class="headerlink" title="6.10.2 端口操作示例：提取CMOSRAM中存储的时间信息"></a>6.10.2 端口操作示例：提取CMOSRAM中存储的时间信息</h3><p>问题描述：在屏幕中间显示当前的月份</p><p><img src="https://pic.imgdb.cn/item/67163d3bd29ded1a8c4fc97b.png"></p><h2 id="6-11-外设连接与中断"><a href="#6-11-外设连接与中断" class="headerlink" title="6.11 外设连接与中断"></a>6.11 外设连接与中断</h2><p>CPU通过端口与外部设备“连接”，CPU 在执行指令过程中，可以检测到发送过来的中断信息，引发<strong>中断</strong>过程，处理外设的输入。</p><h3 id="6-11-1-外中断：由外部设备发生的事件引起的中断"><a href="#6-11-1-外中断：由外部设备发生的事件引起的中断" class="headerlink" title="6.11.1 外中断：由外部设备发生的事件引起的中断"></a>6.11.1 外中断：由外部设备发生的事件引起的中断</h3><ul><li>可屏蔽中断<ul><li>可屏蔽中断是CPU 可以不响应的外中断。</li><li>CPU 是否响应可屏蔽中断，要看标志寄存器的IF 位的设置。</li><li>当CPU检测到可屏蔽中断信息时：<ul><li>如果<code>IF=1</code>，则CPU在执行完当前指令后响闻应中断，引发中断过程;</li><li>如果<code>IF=0</code>，则不响应可屏蔽中断。</li></ul></li><li>几乎所有由外设引发的外中断，都是可屏蔽中断，比如键盘输入、打印机请求。</li></ul></li><li>不可屏蔽中断<ul><li>CPU 必须响应的外中断，当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。</li><li>对于8086CPU不可屏蔽中断的中断类型码固定为2。</li><li>不可屏蔽中断在系统中有必须处理的紧急情况发生时用来通知CPU 的中断信息。</li></ul></li></ul><h3 id="6-11-2-外中断处理过程"><a href="#6-11-2-外中断处理过程" class="headerlink" title="6.11.2 外中断处理过程"></a>6.11.2 外中断处理过程</h3><ul><li><p>可屏蔽中断所引发的中断过程</p><ul><li>(1) 取中断类型码n；<ul><li>可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU（对比内中断:中断类型码是在CPU内部产生的）。</li></ul></li><li>(2) 标志寄存器入栈，<code>IF=0，TF=0</code>;<ul><li>将IF置0的原因：进入中断处理程序后，禁止其他的可屏蔽中断。如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF 置1 。</li></ul></li><li>(3) CS、IP入栈;</li><li>(4) (IP)=(n×4)，(CS)=(n×4+2)</li></ul></li></ul><ul><li><p>不可屏蔽中断的中断过程(中断值固定为2，不必取中断码)</p><ul><li>(1) 标志寄存器入栈，<code>IF=0，TF=0</code>;</li><li>(2) CS、IP入栈;</li><li>(3) (IP)=(8),(CS)=(0AH)。</li></ul></li></ul><blockquote><p>8086CPU提供的设置IF的指令：</p><p><code>sti</code>——用于设置<code>IF=1</code>;</p><p><code>cli</code>——用于设置<code>IF=0</code>。</p></blockquote><h3 id="6-11-3-PC机键盘的处理过程"><a href="#6-11-3-PC机键盘的处理过程" class="headerlink" title="6.11.3 PC机键盘的处理过程"></a>6.11.3 PC机键盘的处理过程</h3><p>键盘输入的处理过程：① 键盘输入；② 引发9号中断；③ 执行<code>int 9</code>中断例程</p><p><strong>（一）键盘输入</strong></p><ul><li>键盘上的每一个键相当于一个开关，键盘中有一芯片对键盘上的每一个键的开关状态进行扫描。</li><li>按下一个键时的操作<ul><li>开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。</li><li>扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为<code>60H</code>。</li></ul></li><li>松开按下的键时的操作<ul><li>产生一个扫描码，扫描码说明了松开的键在键盘上的位置。</li><li>松开按键时产生的扫描码也被送入<code>60H</code>端口中。</li></ul></li><li>扫描码——长度为一个字节的编码<ul><li>按下一个键时产生的扫描码——<strong>通码</strong>，通码的第7位为0</li><li>松开一个键时产生的扫描码——<strong>断码</strong>，断码的第7位为1</li><li><strong>断码 = 通码+80H</strong></li><li>例：g键的通码为22H，断码为a2H</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/671643e4d29ded1a8c5eb818.png"></p><p><strong>（二）引发9号中断</strong></p><p>键盘的输入到达60H端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。</p><p>CPU检测到该中断信息后，如果<code>IF=1</code>，则响应中断，引发中断过程，转去执行<code>int 9</code>中断例程。</p><ul><li><p><strong>输入的字符键值如何保存?</strong></p><ul><li>有BIOS键盘缓冲区!<ul><li>BIOS键盘缓冲区：是系统启动后，BIOS用于存放<code>int9</code>中断例程所接收的键盘输入的内存区。</li><li>BIOS键盘缓冲区：可以存储15个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码(ASCII)。</li></ul></li></ul></li><li><p><strong>输入了控制键和切换键，如何处理 ?</strong></p><ul><li><p>0040:17对应的内存单元存放：<strong>键盘状态字节</strong></p><p>| 7      | 6        | 5       | 4          | 3    | 2    | 1       | 0       |<br>| ——— | ———— | ———- | ————— | —— | —— | ———- | ———- |<br>| Insert | CapsLock | NumLock | ScrollLock | alt  | ctrl | 左shift | 右shift |</p></li></ul></li></ul><p><strong>（三）执行<code>int 9</code>中断例程</strong></p><ul><li>BIOS 中提供的处理键盘输入的<code>int 9</code>中断例程的工作<ul><li>(1) 读出60H 端口中的扫描码</li><li>(2) 根据扫描码分情况对待<ul><li>如果是字符键的扫描码，将该扫描码和它所对应的字符码(即 ASCI码)送入内存中的BIOS键盘缓冲区</li><li>如果是控制键(比如 Ctrl)和切换键(比如 CapsLock)的扫描码，则将其转变为状态字节(用二进制位记录控制键和切换键状态的字节 )写入内存中存储状态字节的单元。 </li></ul></li><li>(3) 对键盘系统进行相关的控制，如向相关芯片发出应答信息。</li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/67164990d29ded1a8c637dd9.png"></p><h3 id="6-11-4-定制键盘输入处理"><a href="#6-11-4-定制键盘输入处理" class="headerlink" title="6.11.4 定制键盘输入处理"></a>6.11.4 定制键盘输入处理</h3><p><strong>（一）PC机键盘的处理过程(int9中断例程)</strong></p><p><img src="https://pic.imgdb.cn/item/67164a11d29ded1a8c63fec7.png"></p><p><strong>（二）编程任务</strong></p><p>在屏幕中间依次显示’a’~’z’，并可以让人看清，在显示的过程中，按下Esc键后，改变显示的颜色。</p><p>方案：尽可能忽略硬件处理细节，充分利用BIOS提供的<code>int9</code>中断例程对这些硬件细节进行处理；在改写后的中断例程中满足特定要求，并能调用BIOS的原<code>int9</code>中断例程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">;依次显示&#x27;a&#x27;~&#x27;z&#x27;</span><br><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,128</span><br><span class="line"></span><br><span class="line">;显示字符</span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov ah,&#x27;a&#x27;</span><br><span class="line">s:   mov es:[160*12+40*2],ah</span><br><span class="line">call delay</span><br><span class="line">inc ah</span><br><span class="line">cmp ah,&#x27;z&#x27;</span><br><span class="line">jna s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">;定义延时函数</span><br><span class="line">delay: push ax</span><br><span class="line">push dx</span><br><span class="line">mov dx,10h</span><br><span class="line">mov ax,0</span><br><span class="line">s1: sub ax, 1</span><br><span class="line">sbb dx, 0</span><br><span class="line">cmp ax,0</span><br><span class="line">jne s1</span><br><span class="line">cmp dx,0</span><br><span class="line">jne s1</span><br><span class="line">pop dx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>接下来的工作：按下 ESc键后，改变显示的颜色!<br>原理：键盘输入到达60h端口后，就会引发 9号中断，CPU 则转去执行int 9中断例程。</p><ul><li>按下 Esc键后改变显示的颜色<ul><li>编写int 9中断例程改变显示的颜色<ul><li>(1) 从60h端口读出键盘的输入<ul><li><code>in al 60h</code></li></ul></li><li>(2) 调用BlOS的int9中断例程，处理硬件细节<ul><li>① 关于中断处理程序入口地址面对的问题<ul><li>要将中断向量表中的<code>int 9</code>中断例程的入口地址改为自编的中断处理程序的入口地址。</li><li>在新中断处理程序中调用原来的<code>int 9</code>中断例程，还需要是原来的<code>int9</code>中断例程的地址。</li><li>解决方法：保存原中断例程入口地址</li><li>将原来<code>int 9</code>中断例程的偏移地址和段地址保存在<code>ds:[0]</code>和<code>ds:[2]</code>单元中，在需要调用原来的<code>int 9</code>中断例程时候，到<code>ds:[0]、ds:[2]</code>找到</li></ul></li><li>② 如何调用原<code>int 9</code>指令的中断例程口<ul><li><code>int 9</code>己改，但仍然需要调用原<code>int 9</code>指令功能</li><li>解决方法：模拟对原中断例程的调用<br>(1) 标志寄存器入栈<br>(2) IF=0，TF=0<br>(3) CS、IP入栈<br>(4) (IP)=((ds)×16+0)，(CS)=((ds)×16+2)</li></ul></li></ul></li><li>(3) 判断是否为Esc的扫描码，如果是，改变显示的颜色后返回；如果不是，则直接返回。</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: mov ax, stack</span><br><span class="line">mov ss,aX</span><br><span class="line">mov sp,128</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">;改变中断例程入口地址</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">push es:[9*4]</span><br><span class="line">pop ds:[0]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop ds:[2]</span><br><span class="line">mov word ptr es:[9*4], offset int9</span><br><span class="line">mov es:[9*4+2],cs</span><br><span class="line"></span><br><span class="line">;显示&#x27;a&#x27;~&#x27;z</span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov ah,&#x27;a&#x27;</span><br><span class="line">s:mov es:[160*12+40*2],ah</span><br><span class="line">call delay</span><br><span class="line">inc ah</span><br><span class="line">cmp ah,&#x27;z&#x27;</span><br><span class="line">jna s</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">; 恢复原来的地址</span><br><span class="line">push ds:[0]</span><br><span class="line">pop es:[9*4]</span><br><span class="line">push ds:[2]</span><br><span class="line">pop es:[9*4+2]</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">;定义延迟程序</span><br><span class="line">delay: push ax</span><br><span class="line">push dx</span><br><span class="line">mov dx,10h</span><br><span class="line">mov ax,0</span><br><span class="line">s1: sub ax, 1</span><br><span class="line">sbb dx, 0</span><br><span class="line">cmp ax,0</span><br><span class="line">jne s1</span><br><span class="line">cmp dx,0</span><br><span class="line">jne s1</span><br><span class="line">pop dx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">;定义中断例程</span><br><span class="line">int9: push ax</span><br><span class="line">push bx</span><br><span class="line">push es</span><br><span class="line">in al,60h</span><br><span class="line">pushf</span><br><span class="line">;pushf</span><br><span class="line">pop bx</span><br><span class="line">and bh,11111100b</span><br><span class="line">push bx</span><br><span class="line">popf</span><br><span class="line">call dword ptr ds:[0];call的存在说明只是给esc增加了一个功能，并没有替换原有功能</span><br><span class="line"></span><br><span class="line">cmp al,1;ESC扫描码1</span><br><span class="line">jne int9ret</span><br><span class="line">;改变颜色</span><br><span class="line">mov ax,0bg00h</span><br><span class="line">mov es,ax</span><br><span class="line">inc byte ptr es:[160*12+40*2+1]</span><br><span class="line"></span><br><span class="line">int9ret:pop es</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="6-11-5-改写中断例程的方法"><a href="#6-11-5-改写中断例程的方法" class="headerlink" title="6.11.5 改写中断例程的方法"></a>6.11.5 改写中断例程的方法</h3><h3 id="6-11-6-用中断响应外设"><a href="#6-11-6-用中断响应外设" class="headerlink" title="6.11.6 用中断响应外设"></a>6.11.6 用中断响应外设</h3><p><strong>（一）如何操作外部设备</strong></p><p>以典型输入设计——键盘操作为例</p><div class="table-container"><table><thead><tr><th>硬件中断 int 9h</th><th>BIOS中断 int 16h</th><th>DOS中断 int 21h</th></tr></thead><tbody><tr><td>由键盘上按下或松开一个键<br />时，如果中断是允许的，就<br />会产生int 9h中断，并转到<br />BIOS的键盘中断处理程序。</td><td>BIOS中断提供基本的键盘操作<br />功能号(AH)=<br />00H、10H 一从键盘读入字符<br />01H、11H 一读取键盘状态<br />02H、12H 一读取键盘标志<br />03H 一设置重复率<br />04H一设置键盘点击<br />05H 一字符及其扫描码进栈<br />在使用功能键和变换键的程序中很重要。</td><td>Dos中断提供丰富、便捷的功能调用<br />功能号(AH)=<br />01H 一 从键盘输入一个字符并回显<br />06H 一 读键盘字符<br />07H 一 从键盘输入一个字符不回显<br />08H 一 从键盘输入一个字符，不回显，检测CTRL-Break<br />0AH 一 输入字符到指定地址的缓冲<br />0BH - 读键盘状态<br />0CH -清除键盘缓冲区，并调用一种键盘功能</td></tr></tbody></table></div><blockquote><p>键盘缓冲区的实现<br>① 共16字<br>② 用<strong>环形队列</strong>，先进先出<br>③ 可存储15个按键扫描码</p></blockquote><p>对键盘输入的处理的<code>int 9h</code>中断和<code>int 16h</code>中断：</p><p>（1）<code>int 9h</code>将键盘输入存入缓冲或改变状态字，键盘输入将引发9号中断，BIOS提供了int 9中断例程。</p><p>int 9中断例程从60h端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。</p><p>键盘缓冲区中有16 个字单元，可以存储15个按键的扫描码和对应的入ASCII 码。</p><p>（2）BIOS提供了<code>int 16h</code>中断例程供程序员调用，以完成键盘的各种操作。</p><p>例：当<code>(AH)=0</code>时，读取键盘缓冲区功能：从键盘缓冲区中读取一个键盘输入，并且将其从缓冲区中删除。</p><p>（3）BIOS的<code>int 9h</code>中断例程和<code>int 16h</code>中断例程是一对相互配合的程序，<code>int 9h</code>中断例程向键盘缓冲区中写入，<code>int 16h</code>中断例程从缓冲区中读出。它们写入和读出的时机不同，<code>int 9h</code>中断例程在有键按下的时候向键盘缓冲区中写入数据而<code>int 16h</code>中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。</p><blockquote><p>补充解释：</p><p><code>int 9h</code>是<strong>硬件中断</strong>，这个中断历程呢是在有键摁下去的时候，向键盘缓冲区里边呢去写入数据，这个过程<strong>不受CPU控制</strong>，是单纯的外设键盘触发的外部硬件中断；</p><p><code>int 16h</code>是<strong>软件中断</strong>，它是在应用程序里边对它进行调用的时候，才将数据从键盘缓冲区中读出。</p><p>从cpu角度来讲，我不管你键盘什么时候去产生这样的呃动作，我需要的时候，我就通过<code>int 16h</code>去调用它，而对于<code>int 9h</code>号中断来讲，它和cpu没有关系，只要说有键摁下去了，就把它记下来。当这两个中断在应用程序里边我们合理的去设置的时候呢，他们相互配合呢帮助我们去读取这样一些数据。</p></blockquote><p><strong>（二）应用示例：更改屏幕颜色</strong></p><p>要求：接收用户的键盘输入<br>输入“r”，将屏幕上的字符设置为红色；输入“g”，将屏幕上的字符设置为绿色；输入“b”，将屏幕上的字符设置为蓝色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">;调用中断，等待输入</span><br><span class="line">mov ah,0</span><br><span class="line">int 16h</span><br><span class="line"></span><br><span class="line">;识别按键</span><br><span class="line">mov ah,1</span><br><span class="line">cmp al,&#x27;r&#x27;</span><br><span class="line">je red</span><br><span class="line">cmp al,&#x27;g&#x27;</span><br><span class="line">je green</span><br><span class="line">cmp al,&#x27;b&#x27;</span><br><span class="line">je blue</span><br><span class="line">jmp short sret</span><br><span class="line"></span><br><span class="line">;设置屏幕颜色</span><br><span class="line">red:shl ah,1</span><br><span class="line">green:shl ah,1</span><br><span class="line">blue:mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">and byte ptr es:[bx],11111000b</span><br><span class="line">or es:[bxl,ah</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">sret: mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><strong>（三）应用：字符串的输入</strong></p><p>问题：设计一个最基本的字符串输入程序，需要具备下面的功能：</p><p>(1) 在输入的同时需要显示这个字符串<br>(2) 一般在输入回车符后，字符串输入结束<br>(3) 能够删除已经输入的字符——用退格键。</p><p>程序的处理过程</p><p>(1) 调用<code>int 16h</code>读取键盘输入；<br>(2) 如果不是字符：①如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符，继续执行(1)；②如果是Enter键，向字符栈中压入0，返回；<br>(3) 如果是字符键：字符入栈，显示字符栈中的所有字符，继续执行(1)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">; 该程序未完成</span><br><span class="line">assume cs:code, ds:data</span><br><span class="line">data segment;“栈”空间</span><br><span class="line">db 32 dup (?)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax</span><br><span class="line">mov si, 0</span><br><span class="line">mov dh, 12</span><br><span class="line">mov dl, 20</span><br><span class="line">call getstr</span><br><span class="line"></span><br><span class="line">return: mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">;完整的接收字符串输入的子程序</span><br><span class="line">getstr:push ax</span><br><span class="line">getstrs:</span><br><span class="line">;调用int 16h读取键盘输入</span><br><span class="line">mov ah,0</span><br><span class="line">int 16h</span><br><span class="line"></span><br><span class="line">cmp al,20h</span><br><span class="line">jb nochar ;小于20h为非字符</span><br><span class="line">;字符入栈</span><br><span class="line">;显示栈中的字符</span><br><span class="line">jmp getstrs</span><br><span class="line"></span><br><span class="line">;处理非字符</span><br><span class="line">nochar:</span><br><span class="line">cmpah,oeh;退格键的扫描码</span><br><span class="line">je backspace</span><br><span class="line">cmp ah,1ch;回车键的扫描码</span><br><span class="line">je enter</span><br><span class="line">jmp getstrs</span><br><span class="line"></span><br><span class="line">;对退格键、回车键的处理</span><br><span class="line">;退格</span><br><span class="line">backspace:</span><br><span class="line">;字符出栈</span><br><span class="line">;显示栈中的字符</span><br><span class="line">jmp getstrs</span><br><span class="line">;回车</span><br><span class="line">enter:mov al,0</span><br><span class="line">;0字符入栈</span><br><span class="line">;显示栈中的字符</span><br><span class="line"></span><br><span class="line">pop ax</span><br><span class="line">ret;getstr结束</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="6-12-读写磁盘"><a href="#6-12-读写磁盘" class="headerlink" title="6.12 读写磁盘"></a>6.12 读写磁盘</h2><p>磁盘，包括“软盘”、“硬盘”（不过软盘已经退出历史舞台了）</p><p><img src="https://pic.imgdb.cn/item/67175f8cd29ded1a8c1f079d.png"></p><p><strong>（一）BIOS对磁盘的操作</strong></p><ul><li>用BlOS <code>int 13h</code>对磁盘进行读操作<ul><li>入口参数：<ul><li>(ah) = 2(2表示读扇区)</li><li>(al)=读取的扇区数</li><li>(ch)=磁道号 ，(cl)=扇区号</li><li>(dh)=磁头号(对于软盘即面号，一个面用一个磁头来读写)</li><li>(dl)=驱动器号:软驱从0开始，0:软驱A，1:软驱B，硬盘从80h开始，80h:硬盘C，81h:硬盘D</li><li>es:bx指向接收从扇区读入数据的内存区</li></ul></li><li>返回参数：<ul><li>操作成功：(ah)=0，(al)=读入的扇区数</li><li>操作失败：(ah)=出错代码</li></ul></li></ul></li></ul><p>例子：读取c盘0面0道1扇区的内容到内存单元0:200</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h;读入0:200h</span><br><span class="line">mov al,1;1个扇区</span><br><span class="line">mov ch,0;0磁道</span><br><span class="line">mov cl,1;1扇区</span><br><span class="line">mov dl,80h;C盘</span><br><span class="line">mov dh,0;0面</span><br><span class="line">mov ah,2;读扇区</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure><ul><li>用BlOS <code>int 13h</code>对磁盘进行写操作</li></ul><p><img src="https://pic.imgdb.cn/item/67176239d29ded1a8c2140f6.png" style="zoom:60%"></p><p>例子：将0:200中的内容写入C盘0面0道1扇区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h;写0:200h</span><br><span class="line">mov al,1;写1个扇区</span><br><span class="line">mov ch,0;0磁道</span><br><span class="line">mov cl,1;1扇区</span><br><span class="line">mov dl,80h;C盘</span><br><span class="line">mov dh,0;0面</span><br><span class="line">mov ah,3;3号写入功能</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure><p><strong>（二）DOS中断对磁盘文件的支持—<code>int 21H</code></strong></p><p><img src="https://pic.imgdb.cn/item/6717635dd29ded1a8c233b61.png"></p><ul><li>功能39H<ul><li>功能描述：用指定的驱动器和路径创建一个新目录</li><li>入口参数：<ul><li>AH = 39H</li><li>DS:DX=指定路径的字符串地址(以0为字符串的结束标志)</li></ul></li><li>出口参数：<ul><li>CF=0——创建成功</li><li>CF=1——创建失败，AX=错误号(03H或05H)，其含义见错误代码表</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机与编程学习 </category>
          
          <category> 汇编与C/C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学速成课</title>
      <link href="/2024/07/29/Computer-science-crash-course/"/>
      <url>/2024/07/29/Computer-science-crash-course/</url>
      
        <content type="html"><![CDATA[<h3 id="1-计算机早期历史"><a href="#1-计算机早期历史" class="headerlink" title="1 计算机早期历史"></a>1 计算机早期历史</h3><h4 id="1-1-计算机的重要性"><a href="#1-1-计算机的重要性" class="headerlink" title="1.1 计算机的重要性"></a>1.1 计算机的重要性</h4><p>计算机是当今世界的命脉，如果突然关掉所有计算机，那么世界将会直接乱套。我们生活中很多产品也都是依靠计算机生产出来的。所以说，<strong>计算机改变了我们生活几乎所有方面，计算机对我们社会的重要性不言而喻。</strong></p><h4 id="1-2-计算机的发展"><a href="#1-2-计算机的发展" class="headerlink" title="1.2 计算机的发展"></a>1.2 计算机的发展</h4><p>略。。。</p><h3 id="2-电子计算机"><a href="#2-电子计算机" class="headerlink" title="2 电子计算机"></a>2 电子计算机</h3><p>上节提到，用于特定场景的计算设备，如制表机，大大提高了企业和政府的工作效率。但是随着社会的发展，交通运输、科学研究甚至航空航天等发展，人民需要计算能力更强的机器。这种计算能力更强的机器，往往体积巨大，耗电量巨大，这为后面的创新埋下伏笔。</p><h4 id="2-1-传统大型计算机的缺点"><a href="#2-1-传统大型计算机的缺点" class="headerlink" title="2.1 传统大型计算机的缺点"></a>2.1 传统大型计算机的缺点</h4><p>传统计算机主要有<strong>两个缺点</strong></p><ul><li>运算速度慢，进行普通的加减乘除的耗时都很长；</li><li>齿轮等计算机机械组件磨损，导致早期计算机容易出现Bug。</li></ul><p>最大的机电计算机是<strong>哈佛马克一号</strong>，由IBM公司完成，它由着数十万组件、上百万连接点和几百英里的导线，这台机器最早是用于给“曼哈顿计划”跑模拟。这台机器的大脑是<strong>继电器。</strong></p><p><strong>什么是继电器</strong></p><p>继电器是用电控制的机械开关。继电器有根“控制线路”，控制电路是开还是关。当螺线圈通过电时，其会产生磁场，吸引上面的线闭合，达到连通的目的。这个继电器可以用于机器进行控制。</p><p><img src="https://pic.imgdb.cn/item/66a75235d9c307b7e9f96b38.png"></p><p>糟糕的是，继电器开关有一定质量，这会影响其闭合。其一秒能够闭合50次，<strong>导致计算机的运算非常慢（完成一次加减乘除需要几秒钟）</strong>。</p><p><strong>除了速度慢，另一个限制是齿轮磨损。</strong>随着机器的不断运行，器件的磨损不可避免。哈佛马克一号有上千的继电器，任何一个发生故障，就会导致计算出错。</p><p>此外，黑色的温暖的环境，也会使虫子滋生。虫子，英文命Bug。<strong>虫子附着在大型计算机的组件上，会导致其运行出错。那么，机器故障（Bug）的来源也是此。</strong></p><h4 id="2-2-电子管"><a href="#2-2-电子管" class="headerlink" title="2.2 电子管"></a>2.2 电子管</h4><p>显然，未来要想继续制造出更强大的计算机，就必须用其他东西代替继电器。幸运的是，一个新的电子组件出现了——“<strong>热电子管</strong>”。这种电子管只能运行电流单向运动，当电流反向时，电子管不能发光。这种管叫“<strong>二极管</strong>”。</p><p>但是，要怎么利用电子管进行开关控制呢？答案就是——<strong>真空三极管</strong></p><p>聪明的人民在二极管中添加了一根导线。利用这跟导线，可以控制向电子添加正电荷或者负电荷，来控制电流的流通。</p><p><img src="https://pic.imgdb.cn/item/66a75337d9c307b7e9fa5127.png" alt="三极管" style="zoom:50%"></p><p>三极管和继电器有着相同的功能，但是由于没有部件的物理移动，所以它的磨损很少，开闭速度可以达到上千次每秒。这种真空三极管，在电子设备中大量运用，持续了近半个世纪。</p><p>刚开始时，这种三极管造价昂贵，而且一个计算机需要上千个电气开关。不过随着时间推移，一些政府部门可以承担这种价格，这种三极管开始应用计算机。标志着<strong>计算机从机电转向电子。</strong></p><h4 id="2-3-电子计算机"><a href="#2-3-电子计算机" class="headerlink" title="2.3 电子计算机"></a>2.3 电子计算机</h4><p>世界上第一台电子计算机造成于英国，名叫<strong>“巨人一号”</strong>，它有1600个真空管。最初是英国政府用来破解纳粹的通信加密密码的。<strong>巨人，被认为是第一个可编程的计算机。</strong></p><p><strong>世界上第一个真正的通用的可编程计算机，是ENIAC。</strong>不过由于真空管很多，它几乎半天就会出现一次故障。</p><h4 id="2-4-晶体管"><a href="#2-4-晶体管" class="headerlink" title="2.4 晶体管"></a>2.4 晶体管</h4><p>为了降低成本和大小，同时提高可靠性和速度，我们需要一种新的电子开关。<strong>1947年，贝尔实验室发明了晶体管（晶体三极管）。</strong>一个全新的计算机时代来临了。</p><p><img src="https://pic.imgdb.cn/item/66a764fdd9c307b7e90b4dd4.png" alt="晶体管" style="zoom:50%"></p><p>晶体管的物理性特别复杂，涉及到量子力学。简单地来说，晶体管的制造需要半导体材料，通过控制基极电荷，控于控制半导体材料的导电性，来是否允许电流的流动。</p><p>晶体管具有很好的开关速度，且其为固态的，比起易碎的玻璃电子管。其体积也远小于继电器或者真空管。<strong>这样我们就能制造出更小更便宜的计算机</strong>。</p><p>如今，晶体管小至几十纳米，运算次数达到几十上百万，并且有几十年的寿命。</p><h3 id="3-布尔逻辑和逻辑门"><a href="#3-布尔逻辑和逻辑门" class="headerlink" title="3 布尔逻辑和逻辑门"></a>3 布尔逻辑和逻辑门</h3><h4 id="3-1-什么是二进制"><a href="#3-1-什么是二进制" class="headerlink" title="3.1 什么是二进制"></a>3.1 什么是二进制</h4><p>前文我们提到，计算机最早是机电设备，一般用十进制计数，比如用齿轮数代表十进制，再到晶体管计算机。</p><p>幸运的是，只用开关两种状态也可以代表信息。这种叫做<strong>二进制，意思是用两种状态表示</strong>。</p><p>你可能认为只用两种状态能表示的信息不多，不过这对计算机来说有很多好处。对于电子元件：电路闭合，有电流通过，代表真；电路断开，无电流通过，代表假。二进制也可以写成0和1。</p><h4 id="3-2-为什么使用二进制？"><a href="#3-2-为什么使用二进制？" class="headerlink" title="3.2 为什么使用二进制？"></a>3.2 为什么使用二进制？</h4><ul><li>二进制表示的状态相对于其他进制更容易区分。</li><li>二进制已经有一个专门研究的数学分支——<strong>布尔代数</strong>，在此方面已经有较大的发展了。</li></ul><p>当初，一些早期的计算机是三进制的，甚至是五进制的。问题是状态越多，越难区分不同的状态，信号可能会发生交叠。所以，<strong>我们用信号的开和闭，尽可能地减少这种问题</strong>。</p><p><strong>另一个使用二进制的原因，就是有一整个数学分支，专门处理“真”和“假”</strong>。它已经解决了所有法则和符号问题，这个数学分支叫“<strong>布尔代数</strong>”。</p><h4 id="3-3-布尔代数及基本逻辑门单元"><a href="#3-3-布尔代数及基本逻辑门单元" class="headerlink" title="3.3 布尔代数及基本逻辑门单元"></a>3.3 布尔代数及基本逻辑门单元</h4><p>布尔代数的基本单元不是数学中的数字，而是<strong>非（NOT）</strong>，<strong>与（AND）</strong>、<strong>或（OR）</strong>和<strong>异或（XOR）</strong>等。那么这几种符号的作用，学数字电路中已经接触很多了。下面简单这几种逻辑门介绍：</p><p><strong>非（NOT）</strong>：输出与输入相反，输入真，输出假，反之亦然。<br><strong>与（AND）</strong>：两个输入仅同真输出真，若有一假则为假。<br><strong>或（OR）</strong>：两个输入只要有一个是真，则输入为真。<br><strong>异或（XOR）</strong>：两输入相异则输出真，两输入相同则输出假。 </p><p>不过，设计师在设计电路和芯片时，不需要考虑这些晶体管是如何设计或电子是怎么流过半导体的。他们需要考虑的是抽象层次的东西，很少在晶体管层次考虑，而是考虑逻辑门或者更大的组件。 </p><h3 id="4-二进制"><a href="#4-二进制" class="headerlink" title="4 二进制"></a>4 二进制</h3><h4 id="4-1-二进制的数字表示"><a href="#4-1-二进制的数字表示" class="headerlink" title="4.1 二进制的数字表示"></a>4.1 二进制的数字表示</h4><p>要想表示更多的信息，就要增加数字表示的位数，类似十进制那样。多位数字，如“263”，就能表示比10更大的数。这种逢十进一的数字表示方法，就是十进制（基于十的表示法）。</p><p><strong>二进制也一样，它是基于2的表示法，其只有两个数字，0和1。</strong>多位二进制表示法，应该按权值展开，如下图所示：</p><p><img src="https://pic.imgdb.cn/item/66a769b9d9c307b7e91029b0.png" style="zoom:50%"></p><h4 id="4-2-二进制的加法"><a href="#4-2-二进制的加法" class="headerlink" title="4.2 二进制的加法"></a>4.2 二进制的加法</h4><p>二进制的加法和十进制一样，满足条件则进一。如下图的二进制加法。</p><p><img src="https://pic.imgdb.cn/item/66a76a20d9c307b7e910750f.png" style="zoom:50%"></p><h4 id="4-3-字节"><a href="#4-3-字节" class="headerlink" title="4.3 字节"></a>4.3 字节</h4><p>二进制中，一个1或0叫做一位，即一个位(bit)有两个不同状态0和1，<strong>8位叫做一个字节</strong>。即1字节=8位。我们的32为或64位电脑，指的是一次能进行32位的或64位的同时计算。</p><p>除了字节外，还有KB、MB和TB等，转化关系如下表所示。</p><script type="math/tex; mode=display">1 \text{ Byte} = 8 \text{ bit} \\1 \text{ KB} = 2^{10} \text{ Byte} \\1 \text{ MB} = 2^{10} \text{ KB} \\1 \text{ GB} = 2^{10} \text{ MB} \\1 \text{ TB} = 2^{10} \text{ GB}</script><h4 id="4-4-计算机中的正负表示"><a href="#4-4-计算机中的正负表示" class="headerlink" title="4.4 计算机中的正负表示"></a>4.4 计算机中的正负表示</h4><p>计算机中，大多<u>用第一位表示正负，1是负，0是正</u>。</p><p>后面，我们还会讲到，计算机会给内存中的每一个位置，做一个标记，这个标记叫位址，目的是为了方便存取数据。因为现在的数据量越来越大，内存地址也有64位。</p><h4 id="4-5-计算机中的浮点数"><a href="#4-5-计算机中的浮点数" class="headerlink" title="4.5 计算机中的浮点数"></a>4.5 计算机中的浮点数</h4><p>我们有几种方法表示浮点数，最常用的是<strong><font color=red>IEEE 754标准</font></strong>。它用类似科学计数法的方法，来存十进制数。对于32位浮点数，第一位表示正负，后面8位表示指数，最后23位表示有效数。</p><p>例如，$625.9 = 0.6259*10^3$，其中，$6259$为有效位数，$3$是指数，其在计算机中的表示如下图。</p><p><img src="https://pic.imgdb.cn/item/66a76dafd9c307b7e9131b3f.png" style="zoom:50%"></p><h4 id="4-6-ASCII-计算机中的文字表示"><a href="#4-6-ASCII-计算机中的文字表示" class="headerlink" title="4.6 ASCII-计算机中的文字表示"></a>4.6 ASCII-计算机中的文字表示</h4><p>不同于书面用符号来表示文字信息，计算机中用数字表示文字。一种方法是，用1表示A，2表示B，3表示C，以此类推。美国科学家曾用5位来表示字母，因为$2^5$为32，这对26个字母来说够了，但这不能表示标点符号、数字和大小写字母。</p><p><strong>ASCII，美国信息交换标准代码</strong>，发明于1963年，ASCII码是7位代码，足够存储128个不同的值。扩展范围后，足够表示大小写字母、数字和标点符号等。</p><p>因为ASCII码值发明地较早，所以被广泛使用，这样，可以让不同公司制作的计算机，能够交换数据。这种交换信息的能力叫互用性。我们知道一个字节有8位，在值为128以后的数字，可以由各国自己根据情况使用。在美国，这些额外的数字主要用于编码附加符号，比如数字符号，图形元素和常用的重音字符，而在希腊，则用于表示希腊字母等。 </p><h4 id="4-7-Unicode-解决不同标准编码下的乱码问题"><a href="#4-7-Unicode-解决不同标准编码下的乱码问题" class="headerlink" title="4.7 Unicode-解决不同标准编码下的乱码问题"></a>4.7 Unicode-解决不同标准编码下的乱码问题</h4><p>不过虽然ASCII码已经能很好地应用于计算机了，但是对于亚洲一些国家（如中国和日本），他们有着上千的文字，ASCII码显然不够用。此外，各个国家设置了相应的字符编码表，但是互不兼容。<strong>字码不兼容的问题经常出现，以致于出现一个专门形容这种情况的名词，“mojibake”，意为“乱码”。</strong></p><p>所以，<strong>Unicode</strong>诞生了，统一了所有的编码标准，设计于1992年，解决了不同国家不同标准的问题，Unicode用一个统一的编码。最常见的Unicode是16位的，有超过一百万个位置，这对所有语言的字符都够用了，能很好地<strong>解决字符不兼容导致乱码的问题</strong>。</p><p>对于其他格式的信息如MP3或GIF，就像ASCII用二进制表示字母一样，我们用二进制编码声音/颜色，表示照片，电影和音乐。</p><p>最后，我们要知道，对于计算机，网页、短信、视频甚至操作系统，都是一长串01字符。</p><h3 id="5-算术逻辑单元"><a href="#5-算术逻辑单元" class="headerlink" title="5 算术逻辑单元"></a>5 算术逻辑单元</h3><h4 id="5-1-什么是ALU"><a href="#5-1-什么是ALU" class="headerlink" title="5.1 什么是ALU"></a>5.1 什么是ALU</h4><p>上一节课我们提到如何用二进制表示数据，如010表示2等。我们知道，<strong>表示和存储数据</strong>是计算机的重要功能。但真正的目标是计算处理有意义的数据，这些操作由计算机的“<strong>算术逻辑单元</strong>”处理，简称<strong>ALU</strong>。</p><p>ALU是计算机的数学大脑，理解了ALU的设计和功能后，你就理解了现代计算机的基石。ALU就是计算机中负责运算的组件，基本上其他组件都需要用到它。</p><p>最著名的ALU，就是<strong>英特尔的74181</strong>，1970年发布，是第一个封装在单个芯片内的完整ALU。</p><p><img src="https://pic.imgdb.cn/item/66a773cad9c307b7e917a162.png" alt="英特尔的74181芯片" style="zoom:40%"></p><p>接下来，我们将利用我们之前学过的逻辑门，设计一个功能与74181相同的组件，然后甚至用此设计CPU。 </p><h4 id="5-2-ALU单元之一：算术单元"><a href="#5-2-ALU单元之一：算术单元" class="headerlink" title="5.2 ALU单元之一：算术单元"></a>5.2 ALU单元之一：算术单元</h4><p>ALU有两个单元，1个算术单元，1个逻辑单元。</p><h5 id="5-2-1-什么是算术单元"><a href="#5-2-1-什么是算术单元" class="headerlink" title="5.2.1 什么是算术单元"></a>5.2.1 什么是算术单元</h5><p><strong>算术单元负责计算机里的所有数字操作</strong>，比如加减法，或者给某个数+1（这个叫增量运算），不过今天我们重点要理解的是加法运算。</p><p>设计时，我们不在晶体管层次出发，而是用更高层的抽象——逻辑门。我们需要用到<strong>AND，OR，NOT和XOR</strong>逻辑门。</p><h5 id="5-2-2-半加器"><a href="#5-2-2-半加器" class="headerlink" title="5.2.2 半加器"></a>5.2.2 半加器</h5><p>对于二进制加法，1+0=1，0+1=1，0+0=0，1+1=10。如下图：</p><p><img src="https://pic.imgdb.cn/item/66a77525d9c307b7e918a958.png" style="zoom:50%"></p><p>我们只看前三个和第四个的第一位，发现它和异或（XOR）操作一样。不过对于1+1，我们还需要一个进位，这里就用到了与操作（AND）。设计如下： </p><p><img src="https://pic.imgdb.cn/item/66a775c4d9c307b7e9191ae8.png" style="zoom:50%"></p><p>它只能处理一位计算，我们称为半加器。我们也可以将其封装起来，变成只有输入和输出的“黑盒操作”，如下图： </p><p><img src="https://pic.imgdb.cn/item/66a77602d9c307b7e9194c2c.png" style="zoom:50%"></p><h5 id="5-2-3-全加器"><a href="#5-2-3-全加器" class="headerlink" title="5.2.3 全加器"></a>5.2.3 全加器</h5><p>如果想要处理超过1+1的运算，我们需要“全加器”。半加器输出了进位，着意味着，我们处理时，还需要将进位考虑进去，才能设计全加器。</p><p>全加器要考虑三位数字的和，如下图所示。全加器有三输入（这里是ABC），两输出（进位和总和）。</p><p><img src="https://pic.imgdb.cn/item/66a7769fd9c307b7e91af540.png" style="zoom:50%"></p><p>我们可以用半加器进行A+B，再把C输入到第二个半加器上，然后用一个或门（OR）计算进位，最终我们得到<strong>全加器</strong>。设计如下： </p><p><img src="https://pic.imgdb.cn/item/66a776ced9c307b7e91b19f8.png" style="zoom:50%"></p><p>我们一样可以将全加器封装起来，这样只能看到输入（ABC）和输出（SUM总和，CARRY进位），方便我们进行更高层次的设计。 </p><p><img src="https://pic.imgdb.cn/item/66a7771cd9c307b7e91b52c1.png" alt="全加器" style="zoom:50%"></p><h5 id="5-2-4-8位加法器设计"><a href="#5-2-4-8位加法器设计" class="headerlink" title="5.2.4 8位加法器设计"></a>5.2.4 8位加法器设计</h5><p>有了全加器，我们可以进行多位加法器设计。这主要是利用半加器和全加器进行，刚开始因为没有高位的进位，我们使用半加器，接下来我们全部使用全加器，因为需要考虑进位。如下图：</p><p><img src="https://pic.imgdb.cn/item/66a777b1d9c307b7e91bcab4.png" alt="8位加法器(行波进位加法器)" style="zoom:40%"></p><p>因为是一个进位一个进位地往下输入的，所以叫“8位行波进位加法器”，当然，最后一位可能会发生进位，<strong>表示相加的两个数字和太大了，超过了8位，这叫做“溢出”</strong>。这会导致错误和不可预测的结果。</p><p>我们可以用更多的全加器，可以操作16位或32位数字，让溢出更难发生。不过代价是更多的逻辑门和更多的耗时。所以，现代电路用的加法器不同，叫“<strong><font color=blue>超前进位加法器</font></strong>”。</p><p>简单的ALU单元可以进行多种加减操作，如半加、全加、减法、增1等，但是没有乘除操作。这是因为，简单的ALU没有专门的电路来处理，而是<strong>把乘法用多次加法来实现</strong>。不过对于强大的手机和电脑，有专门的乘法处理电路。没有多困难，只是逻辑门更多，造价更昂贵而已。</p><h4 id="5-3-ALU单元之二：逻辑单元"><a href="#5-3-ALU单元之二：逻辑单元" class="headerlink" title="5.3 ALU单元之二：逻辑单元"></a>5.3 ALU单元之二：逻辑单元</h4><p>现在，我们讲ALU的另一部分，逻辑单元。逻辑单元执行逻辑操作，比如之前的AND，OR和NOT等操作。它也能做一些简单的判断，比如结果是不是0，是否为负数等。</p><p>例如下图就是检查ALU输出是不是0的电路，很简单，多个或操作，然后最后取反便可，因为只有输出位数全为0，结果才为0。</p><p><img src="https://pic.imgdb.cn/item/66a779b3d9c307b7e91d53b3.png" alt="判断输入是否为0" style="zoom:40%"></p><p>前面我们讲的英特尔公司发明的74181，不过只能处理4位输入，也就是说，我们做了一个比英特尔74181还好的ALU！！ </p><p><img src="https://pic.imgdb.cn/item/66a77a51d9c307b7e91dc287.png" alt="英特尔74181内部结构" style="zoom:60%"></p><h4 id="5-4-ALU"><a href="#5-4-ALU" class="headerlink" title="5.4 ALU"></a>5.4 ALU</h4><p>74181用了大概70个逻辑门，但不能执行乘法操作。但它向小型化迈出了一大步，可以让计算机更强大更便宜。ALU需要大量的逻辑，我们用一个符号来代替，它看起来像一个大“V”，如下图所示。</p><p><img src="https://pic.imgdb.cn/item/66a77b3dd9c307b7e91e661c.png" style="zoom:30%"></p><p>ALU有两个8位的输入，然后用一个操作代码来控制其是加法还是减法操作，操作代码告诉ALU进行什么操作。</p><p>ALU的输出是8位的，ALU还输出一堆标志（Flag）。一些操作介绍如下：</p><ul><li><strong>ZERO</strong>：若ALU输出是0，那么ZERO标志就变成1。</li><li><strong>NEGATIVE</strong>：我们可以用ALU做减法，然后用NEGATIVE判断其是不是小于0，从而进行比较大小。</li><li><strong>OVERFLOW：</strong>ALU还有溢出单元，判断有没有进位。</li></ul><p>ALU有很多Flag，这三个是最常用的。</p><h3 id="6-寄存器与内存"><a href="#6-寄存器与内存" class="headerlink" title="6 寄存器与内存"></a>6 寄存器与内存</h3><p>上节课，我们用逻辑门做了一个简单的ALU，它能执行算术运算（Arithmetic）和逻辑运算（Logic），ALU里的A和L因此得名。当然，算出来后将结果扔掉的话那就没什么意义了，得找个办法存起来，这就需要用到计算机的内存了。</p><h4 id="6-1-计算机中的存储器"><a href="#6-1-计算机中的存储器" class="headerlink" title="6.1 计算机中的存储器"></a>6.1 计算机中的存储器</h4><p>当我们正在使用电脑时，比如打游戏、看视频，如果突然断开电源，进度将会中断且不难复原。我们会损失数据的原因是，电脑使用的是“随机存取存储器”，简称“RAM”。它只能在有电的情况下存储东西。</p><p>另一种存储叫持久存储，关掉电脑数据也不好丢失。</p><p>本节课，我们将从简单开始，做出存储1的器件，之后再扩大，做出我们的内存模块。下次再和ALU结合，做出CPU。</p><h4 id="6-2-存储器的原理与制作"><a href="#6-2-存储器的原理与制作" class="headerlink" title="6.2 存储器的原理与制作"></a>6.2 存储器的原理与制作</h4><h5 id="6-2-1-存0电路与存1电路"><a href="#6-2-1-存0电路与存1电路" class="headerlink" title="6.2.1 存0电路与存1电路"></a>6.2.1 存0电路与存1电路</h5><p><strong>(1) 存1电路</strong></p><p>至今，我们所说的电路都是单向的，总是向前流动，但是我们也可以把输出连回输入。如下图所示的连法，当输出是1后，无论输入是0还是1，因为将输出连回了输入，最终的输出都是1。那么，<strong>这个电路元件就可以存储1</strong>。*<u>然而问题是，无论怎么试，都没法将1变回0</u>*。</p><p><img src="https://pic.imgdb.cn/item/66a77dfcd9c307b7e9205c36.png" alt="存1电路"></p><p><strong>(2) 存0电路</strong></p><p>那么，我们来看看将这个电路里的OR门换成AND门会怎么样，如图。当输出是0后，无论再对A输入0还是1，输出都是0，就是说，<strong>这个电路了可以存储0</strong>。这里就不绘制动态分析过程了，可参照存0电路。</p><p><img src="https://pic.imgdb.cn/item/66a77e93d9c307b7e920c18b.png" alt="存0电路" style="zoom:30%"></p><h5 id="6-2-2-锁存器与门所"><a href="#6-2-2-锁存器与门所" class="headerlink" title="6.2.2 锁存器与门所"></a>6.2.2 锁存器与门所</h5><p><strong>(1) 锁存器</strong></p><p>现在，我们用了存1存储器和存0存储器了，我们将其都利用起来，如下图，这个叫做“<strong>AND-OR锁存器</strong>”。它有两个输入，“设置”输入，把输出变成1，“复位”输入把输出变成“0”。如果“设置”和“复位”都是0，电路会输出最后放入的内容。这就是说它存住了一位的信息，这叫“锁存”，因为他锁住了一个值。</p><p><img src="https://pic.imgdb.cn/item/66a77f3fd9c307b7e9212f7e.png" alt="锁存器示意图" style="zoom:40%"></p><ul><li>若<code>SET=1,RESET=0</code>，则输出为1；</li><li>若<code>SET=0,RESET=1</code>，则输出为0；</li><li>若<code>SET=0,RESET=0</code>，则输出不变，也即会保存上一个状态的输出，也即它锁住了1位的信息（<strong>存储</strong>）；</li><li>若<code>SET=1,RESET=1</code>，则输出为0，个人认为这种操作没有什么太大的意义；</li></ul><p><strong>放入数据的操作叫“写入”，拿出数据的操作叫读取。</strong> </p><p><strong>(2) 门锁</strong></p><p>麻烦的是，用两条线“设置”和 “复位”来输入，有点难理解。为了更容易用，我们希望只有一条输入线，进行输入数据。然后设置另一条线，叫允许写入线，用来启用内存，启用时允许写入，没启用时就锁定。外加一些逻辑门，就可以做出这个电路。这个叫<strong>门锁，因为门可以打开和关上。</strong></p><p><img src="https://pic.imgdb.cn/item/66a7818fd9c307b7e922d709.png" alt="门锁示意图" style="zoom:50%"></p><p>其中，DATA INPUT表示输入要保存的数据；WRITE ENABLE表示允许写入线，此线输入1时为启用(允许写入数据)，此线输入为0时为锁定(存储数据，此时不论DATA INPUT如何变输出都不变)。</p><p>但是，我们不想直接面对这个电路，我们想用一个“黑盒”将其框住，这就成为了一个组件。这个门锁只有当“允许写入线”为1时才可以写入和输出数据。 </p><p><img src="https://pic.imgdb.cn/item/66a782b2d9c307b7e923c022.png" style="zoom:40%"></p><h5 id="6-2-3-寄存器"><a href="#6-2-3-寄存器" class="headerlink" title="6.2.3 寄存器"></a>6.2.3 寄存器</h5><p>虽然一个门锁只能存储一位数字，但是我们并排放8个锁存器，就可以存8位信息。</p><p>一组这样的锁存器叫“<strong><font color=green>寄存器</font></strong>”，寄存器能存储一个数字，这个数字有多少位，叫位宽。</p><p>早期计算机用8位寄存器，后来到16位、32位和如今的64位。</p><p>写入寄存器时，我们需要先将所有的“允许写入线”设为1，这里我们可以引一条总线统一控制。然后我们将数据输入，完成输入后再将所有的“允许写入线”设为0。</p><p><img src="https://pic.imgdb.cn/item/66a78464d9c307b7e9251a30.png" alt="8位寄存器" style="zoom:40%"></p><h5 id="6-2-4-矩阵网络优化门锁放置"><a href="#6-2-4-矩阵网络优化门锁放置" class="headerlink" title="6.2.4 矩阵网络优化门锁放置"></a>6.2.4 矩阵网络优化门锁放置</h5><p>如果只有很少的位(bits)，把锁存器并排放置，也勉强够用了。64 位寄存器要 64 根数据线，64 根连到输出端，幸运的是，我们只要1根线(“总线”)启用所有锁存器，但加起来也有 129 条线了。如果存 256 位要 513 条线！非常耗材。</p><p>解决方法就是<strong>矩阵</strong>，在计算机中，<strong>寄存器并不并排放，而是成矩阵网络</strong>。存256位的寄存器，就将门锁摆成16*16形式，要用某个寄存器，就打开想应的行线和列线。</p><p><img src="https://pic.imgdb.cn/item/66a785c9d9c307b7e92629c4.png" alt="门锁矩阵网络" style="zoom:40%"></p><p>要启用某个锁存器，就打开相应的行线和列线，放大看看怎么做的。</p><p>我们只想打开交叉处锁存器的”允许写入线”，所有其他锁存器，保持关闭。我们可以用 AND 门！只有行线和列线均为1，AND门才输出 1。所以可以用选择单个锁存器，这种行/列排列法，用一根“允许写入线(总线)”连所有锁存器。</p><p><img src="https://pic.imgdb.cn/item/66a787cfd9c307b7e9279e4b.png" alt="放大示意图" style="zoom:50%"></p><p>为了让锁存器变成“允许写入”，行线，列线和“允许写入线”都必须是 1，每次只有行列号对应的那1个锁存器会这样。同时，有了这种电路连接结构，使得我们可以只用一根”数据线”(类似于允许写入线的总线)连所有锁存器来传数据，因为只有一个锁存器会启用，只有那个会存数据。其他锁存器会忽略数据线上的值，因为没有“允许写入”。</p><p>我们可以用类似的技巧，做<strong>“允许读取线(READ ENABLE)”</strong>来读数据。</p><p>所以对于 256 位的存储只要 35 条线，具体计算如下：</p><script type="math/tex; mode=display">1条数据线 + 1条允许写入线 + 1条允许读取线 + 16条行线 + 16条列线 = 35条线</script><p>不过，我们怎么将计算机的二进制数据传给这个“矩阵”呢？因此，我们需要用到<strong>多路复用器</strong>，它能够连通所给输入对应的线，比如若输入“1010”，那么多路复用器就会将第10路连通，达到选线路的目标。 </p><p><img src="https://pic.imgdb.cn/item/66a78ac5d9c307b7e929d0e7.png" alt="多路复用器" style="zoom:60%"></p><p>那么，更高的一层抽象来了，256位内存，如下。其分别有上文提到的8位地址线、数据线、允许写入线和允许读取线： </p><p><img src="https://pic.imgdb.cn/item/66a78b91d9c307b7e92a7601.png" alt="256位寄存器的抽象" style="zoom:50%"></p><p>这样，我们就做成了一个内存了。</p><h4 id="6-3-如何利用多个内存完成数据存取"><a href="#6-3-如何利用多个内存完成数据存取" class="headerlink" title="6.3 如何利用多个内存完成数据存取"></a>6.3 如何利用多个内存完成数据存取</h4><p>利用这个256位的内存，我们可以存许多数据。具体的存法如下：</p><p><img src="https://pic.imgdb.cn/item/66a78cb4d9c307b7e92b5b80.png" style="zoom:60%"></p><p>我们将8个256位的内存并排在一起，用同样地址线将其连接。那么，一个内存可以存一位（<strong>单独</strong>），8个并在一起就可以*<u>同时存8位（1Byte）</u>*。<strong>为了存8位的数据，我们给8个内存同样的地址，也就是一个8位数据，分给8个内存分别存储</strong>。因为是256位的内存，所以可以存256个八位，也就是<strong>256 Byte</strong>的数据。 </p><p>我们将其抽象，也就是说，这8给内存，可以有256有地址，每个地址可以读写一个8位数据。 </p><p><img src="https://pic.imgdb.cn/item/66a78d5ad9c307b7e92be137.png" style="zoom:60%"></p><p>内存的一个重要特征是可以随时访问任何位置，因此叫“<strong>随机存取存储器</strong>”（RAM），RAM就像人类的短期记忆，记录计算机当时正在干嘛。 </p><p><img src="https://pic.imgdb.cn/item/66a7901dd9c307b7e92e37aa.png" style="zoom:70%"></p><p>上面真实的内存条中，有8颗芯片，每个芯片有32个内存方块，每个内存方块4个矩阵，所以1个方格有8192×4=32768位，总之，总位数约为：</p><script type="math/tex; mode=display">32768 \times 32 \times 8 = 8388608 ≈ 800 \text{万位} ≈ 1 \text{兆字节}</script><p>所以，这节课，我们做了一个SRAM（<strong>静态随机存取存储器</strong>），还有其他比如DRAM、闪存等等，他们在功能上与SRAM相似，但用不同的电路存单个位，比如用不同的逻辑门、电容器、电荷捕获或忆阻器等等。但根本上，这些技术都是矩阵层次嵌套，来存储大量信息。</p><p>就像计算机中的很多事情，底层其实都很简单。让人难以理解的是一层层精妙的抽象，像一个越来越小的俄罗斯套娃。</p><h3 id="7-中央处理器CPU"><a href="#7-中央处理器CPU" class="headerlink" title="7 中央处理器CPU"></a>7 中央处理器CPU</h3><h4 id="7-1-CPU与指令"><a href="#7-1-CPU与指令" class="headerlink" title="7.1 CPU与指令"></a>7.1 CPU与指令</h4><p>前面课程已经提到，我们已经做了一个算术逻辑单元（ALU），输入二进制，它会执行计算。我们还做了两种内存：寄存器，很小的内存，能存一个值；RAM，能在不同地址存大量数字。现在，我们是时候把他们放在一起，组建计算机的“心脏”了，<strong>这个“心脏”叫“中央处理单元”，简称CPU。</strong></p><p>CPU负责执行程序，这些程序可能是浏览器、社交软件和音乐等等。这些程序是由一个个操作组成的，这种“操作”叫“指令”，因为它“指示”计算机要做什么。如果是计算指令如加或者减，CPU会让ALU进行数学运算。也可能是内存指令，CPU会和内存通信，然后读/写值。</p><p>当我们用一条线连接两个组件时，这条线只是所有必须线路的一个抽象，这种高层次视角叫”微体系架构“。意思就是，我们从微观部件考虑整体同类型部件，以更高抽象层次去看代问题。</p><h4 id="7-2-CPU指令体系"><a href="#7-2-CPU指令体系" class="headerlink" title="7.2 CPU指令体系"></a>7.2 CPU指令体系</h4><p>我们已经知道数据是以二进制值存在内存里，程序也可以存在内存里。我们可以给CPU 支持的所有指令，分配一个 ID，下图为计算机指令表。下表中，我们看到，前四位存储指令的”操作代码“，如0010、0001等，后面四位代表数据来源于哪里（地址或者寄存器）</p><p><img src="https://pic.imgdb.cn/item/66a793ecd9c307b7e931919c.png" alt="CPU指令表" style="zoom:40%"></p><p>我们还需要两个寄存器来完成CPU指令<strong>，一个寄存器追踪程序运行到哪了</strong>，我们叫它”指令地址寄存器“，顾名思义，存当前指令的内存地址。<strong>另一个寄存器存当前指令</strong>，叫”指令寄存器“。指令体系如下： </p><p><img src="https://pic.imgdb.cn/item/66a796a2d9c307b7e933d695.png" alt="指令系统示意图" style="zoom:60%"></p><h4 id="7-3-指令的运行流程"><a href="#7-3-指令的运行流程" class="headerlink" title="7.3 指令的运行流程"></a>7.3 指令的运行流程</h4><p>一条指令的运行，有三个阶段，分别是<strong>取指令阶段、解码和执行</strong>。这里，我们会在RAM里放一个程序，过一遍流程。</p><p>CPU的第一个阶段叫”<strong>取指令阶段</strong>“。指令地址寄存器连接到RAM，RAM得到指令地址寄存器的内容，将对应地址的数据传到指令寄存器中，下图中显示的是”0010 1110“。</p><p>然后是<strong>解码</strong>，根据前文的指令表，知道0010是LOAD_A指令。后四位是RAM的地址（如表），1110是14，那么我们就取得RAM中地址是14的值3。这是一个LOAD_A指令，会将这个值放入A寄存器中，而其他寄存器不受影响。</p><p>最后是<strong>执行</strong>，通过检验电路和输入运行线开关，就将3写入了寄存器A中。执行完后，指令地址寄存器地址+1，进行下一个指令。</p><p>当然，每一个指令都会有对应的逻辑电路来判断其是否要进行。这些控制单元可能非常复杂，我们将其抽象一层，以一个整体部件（控制单元Control Unit）代替。</p><p><img src="https://pic.imgdb.cn/item/66a797ead9c307b7e934f7e5.png" style="zoom:70%"></p><p>这个控制单元就行交响乐的指挥使，控制CPU的所有组件。”取指令-解码-执行“完成后，我们可以再来一次其他指令，从”取指令开始“。上面介绍的指令只涉及到寄存器的存取，其他指令如ADD，会用到<strong>ALU部件</strong>。利用ALU将值计算出来后，再传回对应的寄存器中。<strong>也就是说，寄存器加ALU，就可以做成CPU。</strong> </p><h4 id="7-4-CPU的节奏把控者——时钟"><a href="#7-4-CPU的节奏把控者——时钟" class="headerlink" title="7.4 CPU的节奏把控者——时钟"></a>7.4 CPU的节奏把控者——时钟</h4><p>我们刚才走的是一个人工的流程，但是计算机中没有”人工“，所以<strong>计算机中靠的是时钟来负责管理CPU的节奏</strong>。时钟以精确的时间间隔，触发电信号。控制单元会用这个信号，推进CPU的内部操作，确保一切按节奏进行。</p><p>时间间隔不能太短，因为电信号的传输也需要一定的时间。<strong><font color=red>CPU进行“取指令-解码-执行”的速度叫“时钟速度”，单位是Hz，1Hz表示一秒一个周期</font></strong>。</p><p><img src="https://pic.imgdb.cn/item/66a79d37d9c307b7e939973a.png" style="zoom:60%"></p><p>第一个单芯片CPU是“英特尔4004”，1971年发布的4位CPU，它的微架构很像我们之前所说的CPU。虽然是第一个小型CPU，但他的时钟速度达到740千赫兹——每秒740万个周期。</p><p><img src="https://pic.imgdb.cn/item/66a79b79d9c307b7e937f9e7.png" style="zoom:70%"></p><ul><li><p><strong>超频</strong><br>你可能听过有人会把计算机超频，意思是<strong>修改时钟速度</strong>，加快CPU的速度，就像罗马帆船要撞另一艘船时，鼓手会加快敲鼓速度。芯片制造商经常给CPU留一点余地，可以接受一点超频！但超频大多会让CPU过热或产生乱码，因为信号跟不上时钟。</p></li><li><p><strong>降频</strong><br>你可能很少听说降频，但降频其实很有用，有时没必要让处理器全速运行(例如，可能用户走开了，或者在跑一个性能要求较低的程序)。把 CPU 的速度降下来，可以省很多电，省电对用电池的设备很重要，比如笔记本和手机</p></li><li><strong>动态调频</strong><br>很多现代处理器可以按需求，加快或者减慢时钟速度，这叫“<strong>动态调整频率</strong>”，加上时钟后，CPU才完整，这样我们又提升了一层抽象。<strong>CPU和RAM独立，两者用地址线、数据线和允许读写线进行通信。</strong> </li></ul><h4 id="7-5-小小结"><a href="#7-5-小小结" class="headerlink" title="7.5 小小结"></a>7.5 小小结</h4><p>加上时钟后，CPU才是完整的，现在可以放到盒子里，抽象成一个独立组件。</p><p><img src="https://pic.imgdb.cn/item/66a79d8fd9c307b7e939ea7d.png" style="zoom:60%"></p><h3 id="8-指令和程序"><a href="#8-指令和程序" class="headerlink" title="8 指令和程序"></a>8 指令和程序</h3><h4 id="8-1-更加丰富的指令系统"><a href="#8-1-更加丰富的指令系统" class="headerlink" title="8.1 更加丰富的指令系统"></a>8.1 更加丰富的指令系统</h4><p>上节课中，我们把ALU，控制单元，RAM和时钟结合在一起，做了一个基本但可用的“中央处理单元”，简称CPU，它是计算机的核心。这次，我们给CPU一些指令来运行。</p><p>CPU之所以强大，是因为它是可编程的，如果写入不同指令，就会执行不同任务。所以，CPU是一块硬件，可以被软件控制。在上节课的指令系统中，我们只有4条语句，这节课我们会增加几条指令，如下</p><ol><li><strong>SUB</strong>：与ADD一样，操作两个寄存器相减，放在第二个寄存器上。</li><li><strong>JUMP</strong>：让程序跳转到新位置，如果想改变一些指令或者跳过一下指令，这个很有用。JUMP的底层实现方式是，把需要的指令后四位代表的内存地址的值覆盖掉“指令地址寄存器”里的值。</li><li><strong>JUMP_NEG</strong>：它只在ALU的“负数标志”为真时（即此时计算结果为负数），进行JUMP。</li><li><strong>HALT</strong>：计算机和程序停下来。</li></ol><p><img src="https://pic.imgdb.cn/item/66a82c68d9c307b7e9979f4f.png" alt="更加丰富的指令集" style="zoom:70%"></p><p>值得一提的是，指令和数据都是存在同一个内存里面的，他们在根本上毫无区别，都是二进制数。</p><p><strong>利用更多的指令，我们可以使CPU的程序更加丰富。</strong></p><h4 id="8-2-无限循环与条件指令"><a href="#8-2-无限循环与条件指令" class="headerlink" title="8.2 无限循环与条件指令"></a>8.2 无限循环与条件指令</h4><p>当指令顺序出现问题时，程序可能进入<strong>无限循环</strong>，这个程序会永远跑下去。所以，我们需要更多<strong>其它类型的JUMP</strong>以满足我们的需要，这样只在特定条件下才会发生，程序不会出现无限循环。前面提到的<code>JUMP_NEG</code>就是，此外还有 <code>JUMP_IF_EQUAL</code>（如果相等）、<code>JUMP_IF_GREATER</code>（如果更大）等等。这些指令，同样使我们的CPU程序更加丰富。</p><p>软件还可以让我们做到硬件做不到的事，ALU没有除法功能，是程序给了这个功能。别的程序也可以用我们的除法程序，来做其他事情。</p><h4 id="8-3-指令长度"><a href="#8-3-指令长度" class="headerlink" title="8.3 指令长度"></a>8.3 指令长度</h4><p>我们这里假设的CPU很基础，所有指令都是8位，操作码只占了前四位，即便用尽4位，也只能代表16个指令。同时，因为4位最大为16，说明我们最多可以操纵16个地址，这非常少。</p><p>因此现代计算机用两种办法来解释此，① 最直接的方法是用更多位来代表指令，比如32位或者64位，这叫做<strong>指令长度</strong>。② 第二个策略是“可变指令长度”，举例，比如某个CPU用8位长度的操作码，看到HALT指令，HALT不需要额外的数据，那么会立马执行。如何看到JUMP，它得知道位置值，这个值在JUMP后面，这叫做“立即值”。这样设计，指令可以是任意长度。</p><h4 id="8-4-现代计算机的指令系统"><a href="#8-4-现代计算机的指令系统" class="headerlink" title="8.4 现代计算机的指令系统"></a>8.4 现代计算机的指令系统</h4><p>上面都是假设的例子，现在讲一个真实的例子。1971年，英特尔发明的4004处理器，这是第一次把CPU做成芯片，它支持46个指令，包括JUMP、ADD等。CPU发展到现在，功能越来越强大。比如，英特尔的酷睿i7，有上千个指令和指令变种，长度从1到15字节。</p><p><img src="https://pic.imgdb.cn/item/66a830c2d9c307b7e99a8d82.png" alt="第一个CPU4004的指令集 "></p><h3 id="9-高级CPU设计"><a href="#9-高级CPU设计" class="headerlink" title="9 高级CPU设计"></a>9 高级CPU设计</h3><h4 id="9-1-早期CPU提速方式"><a href="#9-1-早期CPU提速方式" class="headerlink" title="9.1 早期CPU提速方式"></a>9.1 早期CPU提速方式</h4><p>随着本系列的进展，我们知道计算机进步巨大，从1秒一次运算，到现在有千hz甚至兆hz的CPU。</p><h5 id="9-1-1-减少晶体管切换时间"><a href="#9-1-1-减少晶体管切换时间" class="headerlink" title="9.1.1 减少晶体管切换时间"></a>9.1.1 减少晶体管切换时间</h5><p>早期计算机的提速方式是，减少晶体管的切换时间。晶体管组成了逻辑门，ALU以及前几集的其他组件，但这种提速方式终究会遇到困难。所以厂商和科学家们发明各种新的技术来提高性能。</p><h5 id="9-1-2-利用复杂电路设计除法"><a href="#9-1-2-利用复杂电路设计除法" class="headerlink" title="9.1.2 利用复杂电路设计除法"></a>9.1.2 利用复杂电路设计除法</h5><p>上节课我们做了一个CPU除法器，不断减去同一个数，直到小于等于0才停下。但这种方法需要多个时钟，很低效。所以<strong>现代CPU直接在硬件层面上设计了除法，可以直接给ALU除法指令。虽然这让CPU更大更复杂，但也让运行速度更快。</strong></p><h4 id="9-2-缓存——解决CPU与RAM传输问题"><a href="#9-2-缓存——解决CPU与RAM传输问题" class="headerlink" title="9.2 缓存——解决CPU与RAM传输问题"></a>9.2 缓存——解决CPU与RAM传输问题</h4><p>现代计算机几千兆的时钟速度，带来了另一个问题，<u>如何传递数据给CPU</u>？这时，RAM成了一大阻力，RAM是CPU之外的独立组件，意味着数据要用线来传递，叫<strong>总线(BUS)</strong>。虽然电信号可以以光速快速快速传输，但是很小的延迟也会造成问题，RAM还需要时间找地址、取数据、配置和输出数据，这样会占用太多时间。</p><p>解决延迟的方法之一是，给CPU加一点RAM，叫<strong><font color=red>缓存(CACHE)</font></strong>。</p><p><img src="https://pic.imgdb.cn/item/66a835d8d9c307b7e99dfb4a.png" alt="CPU与RAM之间添加“缓存”" style="zoom:60%"></p><p>因为处理器空间不大，所以缓存一般只有几KB或MB。缓存提高了运行速度，CPU从RAM拿数据时，RAM不用传一个，可以传一批。这很实用，<strong>因为数据常常是一个一个按顺序处理的，将要处理的数据提前传入缓存，可以大大提升CPU运行速度</strong>。*<u>因为缓存离CPU近</u>*，传输时间大大降低，这比直接反复去RAM拿数据快得多。</p><blockquote><p>注意：这里的近就是指物理上的近，RAM与CPU通信的总线BUS物理长度可能1cm，但是CACHE与CPU通信的物理距离可能只有0.01cm。</p></blockquote><p>如果想要的数据已经在缓存中，叫“<strong>缓存命中</strong>”，否则叫缓存未命中。缓存可以当临时空间，存一些中间值，适合长\复杂的运算。</p><p>计算完后的值要想存储，不会直接存入RAM，而是存入缓存中。因此，缓存里的数据要对RAM里的数据进行更新，缓存里每块空间，有一个特殊标记，叫“<strong>脏位</strong>”。</p><p>同步缓存与RAM的数据一般是当缓存满了，而又需要存更多的数据时发生。这时会检查缓存中的“脏位”，如果是脏的，就会把数据写回RAM中。</p><h4 id="9-3-指令流水线"><a href="#9-3-指令流水线" class="headerlink" title="9.3 指令流水线"></a>9.3 指令流水线</h4><p>CPU在处理指令时，不一定要完全按照串行流程，可以按照并行方式进行。意思是，当此条指令正在“执行”时，可以处理下一个指令的“解码”，下下条指令的“读取”，这样可以同时利用上CPU里的所有部分。这样进行执行，吞吐量*3。如下图所示。</p><p><img src="https://pic.imgdb.cn/item/66a8393cd9c307b7e9a05e10.png" alt="指令流水线"></p><p>当然，这样也可能出现问题，首先是因为<strong>上一条指令可能会改变下一条指令的运行方式</strong>，所以CPU在运行前需要解析这些指令，必要时还需要停下来等待上一条指令完成后在继续。</p><p>高端CPU，比如笔记本和手机那种，会进一步，动态排序有依赖关系的指令，最小化流水线停工时间，这叫“乱序执行”。这种电路非常复杂，但因为高效，几乎所有现代处理器都有流水线。</p><p>第二个问题是<strong>条件跳转</strong>，比如JUMP Negative这些，这些指令会改变程序的执行流。简单的流水线处理器，看到JUMP指令会停一会，等待条件值确定下来，一旦JUMP的结果出了，处理器就继续流水线。因为等待会消耗很多时间，<strong>高级的流水线处理器会提前猜测哪个条件可能性大，然后提前把指令放在流水线上，这叫“推测执行”</strong>。如果猜测正确，则立即执行，错误则会清空刚才加载的指令，重新加载。为了减少清空次数，CPU开发了高级方法来猜测哪条分支更有可能，叫“分支预测”。现代计算机的猜测正确率高达90%。</p><ul><li><strong>超标量处理器</strong></li></ul><p>理想情况下，流水线一个时钟周期完成1条指令，然后“超标量处理器”出现了，一个时钟周期可以完成多条指令。即便有流水线涉及，在指令执行阶段，处理器里有些区域还是可能会空闲，例如：有一条指令是“从内存中取出某地址存放的数据”，执行这条指令期间ALU会闲置，所以一次性处理多条指令(取指令+解码)会更好（此句子也可翻译为：那么，为什么不一次获取和解码多个指令，并尽可能地执行指令呢）。也就是说，如果多条指令要 CPU 的不同部分，就多条同时执行。我们可以再进一步，加多几个相同的电路执行出现频次很高的指令——<strong>举例，很多 CPU 有4个、8个甚至更多完全相同的ALU结构，可以同时执行多个数学运算</strong>。</p><p><img src="https://pic.imgdb.cn/item/66a83ecbd9c307b7e9a45e3c.png" alt="超标量流水线处理器" style="zoom:40%"></p><p><a href="https://blog.csdn.net/youzhangjing_/article/details/132278054">参考连接1：一文解析超标量处理器 - CSDN</a><br><a href="https://blog.csdn.net/zhizhengguan/article/details/121271156">参考连接2：计算机组成原理：超标量，让CPU的吞吐率超过1 - CSDN</a><br><a href="https://blog.csdn.net/a201577F0546/article/details/84726912">参考连接3：一个时钟周期执行一条指令的过程理解（单周期CPU） - CSDN</a><br><a href="https://blog.csdn.net/weixin_69884785/article/details/136208031">参考连接4：计算机组成原理（6）——-指令执行过程 - CSDN</a></p><h4 id="9-4-多核处理器"><a href="#9-4-多核处理器" class="headerlink" title="9.4 多核处理器"></a>9.4 多核处理器</h4><p>以上的指令流水线工作都是对于一个流水线来说的。另一个方法是<strong>同时运行多个指令流，叫多核处理器</strong>。多核意思是，CPU芯片有多个独立处理单元，就像有多个CPU。多个CPU之间可以合作运算。</p><p><img src="https://pic.imgdb.cn/item/66a8417ad9c307b7e9a61ce8.png" alt="多核处理器" style="zoom:70%"></p><p>你应该听过双核或四核处理器，意思是一个 CPU 芯片里，有多个独立处理单元，很像是有多个独立’CPU，但因为它们整合紧密，可以共享一些资源，比如缓存，使得多核可以合作运算</p><p><img src="https://pic.imgdb.cn/item/66a841d4d9c307b7e9a6582f.png" style="zoom:30%"></p><p>当多核不够时，可以用多个CPU，比如视频网站的服务器。</p><p>2个和4个核的计算机是最常用的（现在可能有8核了），但人们还需要更多的，所以有了<strong>超级计算机。目前世界上最快的计算机位于中国超算中心，神威·太湖之光</strong>，有40960个CPU，每个CPU有256个核心，总共超过1千万个核心，可以进行超级运算或者宇宙大模拟。</p><h3 id="10-早期的编程方式"><a href="#10-早期的编程方式" class="headerlink" title="10 早期的编程方式"></a>10 早期的编程方式</h3><p>前几集我们把重点放在计算机的原理，怎么从内存读写数据，执行操作。还讲了指令的执行。但是，我们还没讲程序如何“进入”计算机。</p><h4 id="10-1-最早的编程——可编程纺织机"><a href="#10-1-最早的编程——可编程纺织机" class="headerlink" title="10.1 最早的编程——可编程纺织机"></a>10.1 最早的编程——可编程纺织机</h4><p>给计算机编程这个需求，早在计算机出现之前就有了，最著名的来自于纺织行业。如果想要织一件红色衣服，我们只需要将红线放入纺织机中，但是如果想要图案怎么办？开始时，工人要经常改变纺织方向以作图案，所以早期有团案的衣服较为贵。后来发明了可编程纺织机，用孔板进行控制。这个纺织机叫“雅卡尔织布机”，被认为是最早的编程。</p><h4 id="10-2-穿孔卡片编程"><a href="#10-2-穿孔卡片编程" class="headerlink" title="10.2 穿孔卡片编程"></a>10.2 穿孔卡片编程</h4><p>近1个世纪后，穿孔纸用于1890年美国人口普查。每张纸都可以存个人信息，用孔来表示信息，比如种族、婚姻等。穿孔纸存的是数据，不是程序。</p><h4 id="10-3-插线编程"><a href="#10-3-插线编程" class="headerlink" title="10.3 插线编程"></a>10.3 插线编程</h4><p>为了用计算机正确执行不同计算，程序员需要某种控制面板。面板有很多小插孔，程序员可以插电线，控制让机器的不同部分，互相穿数据和信号，因此也叫“插线板”。不幸的是，这意味着，运行不同程序要重新接线。所以到1920年，控制面板变成了可拔插，让编程更方便，可以给计算机插入不同程序。但是插线板编程很复杂，不过它在大多机电计算机很常见，世界上第一台电子计算机也是用插线板编程。</p><h4 id="10-4-冯诺依曼结构"><a href="#10-4-冯诺依曼结构" class="headerlink" title="10.4 冯诺依曼结构"></a>10.4 冯诺依曼结构</h4><p>插线编程非常复杂，也非常耗时，这对计算机设计程序很麻烦。后来，内存的出现与发展，出现了“<u>存储程序计算机</u>”，能在内存里存储程序。如果内存足够，不仅可以存程序，还可以存数据。<strong>程序和数据都存在一个地方，叫“冯诺伊曼结构”</strong>。冯诺依曼计算机的标志是：</p><script type="math/tex; mode=display">一个处理器+数据寄存器+指令寄存器+指令地址寄存器+内存(负责存数据和指令)</script><p>第一台冯诺依曼结构计算机叫“宝宝”，由曼彻斯特大学于1948年建成。直到1980年代，人们还是主要用穿孔卡片进行程序写入，计算机可以吸入一张卡片，把卡片内容写进内存。卡片输入非常麻烦，要是不小心弄乱了，要花几小时甚至几天来整理。数据由计算机输出，依然是需要用到卡片，方式是打孔。</p><h4 id="10-5-面板编程"><a href="#10-5-面板编程" class="headerlink" title="10.5 面板编程"></a>10.5 面板编程</h4><p>到了1980年代，还有一种常见的编程方式，面板编程。面板编程，用一大堆开关进行控制。通过开关控制进行二进制代码的编写，然后就可以运行程序。</p><p>不管是插线、穿孔纸片还是面板，早期编程都是专家活，需要非常了解底层硬件，比如操作码和寄存器等等。所以当时编程很难。下节课，讲到编程语言，是一种更简单的编程方法。 </p><h3 id="11-编程语言发展历史"><a href="#11-编程语言发展历史" class="headerlink" title="11 编程语言发展历史"></a>11 编程语言发展历史</h3><p>之前，我们把重点放在硬件——组成计算机的物理组件上，比如电、电路、寄存器、RAM、ALU和CPU，但是在硬件层面上编程非常麻烦。所以程序员想要一种更加通用的方法编程，一种更软的媒介。所以，这节课，我们将要讲<strong>软件和高级语言</strong>。</p><h4 id="11-1-机器语言、汇编语言和编译器"><a href="#11-1-机器语言、汇编语言和编译器" class="headerlink" title="11.1 机器语言、汇编语言和编译器"></a>11.1 机器语言、汇编语言和编译器</h4><p>第8节课，我们一步步讲了一个简单程序。前面我们讲到用二进制代码表示不同的操作和地址，其实这只是一种数据的表现方式。就像英语和摩斯密码，虽然二者的符号和表达不同，但是可以传达相同的信息，计算机语言也类似。</p><h5 id="11-1-1-机器语言"><a href="#11-1-1-机器语言" class="headerlink" title="11.1.1 机器语言"></a>11.1.1 机器语言</h5><p>计算机能处理二进制，二进制是处理器的“母语”。这叫“<strong>机器语言”或者“机器码”</strong>。在计算机早期阶段，必须用机器码写程序。具体地来讲，会先在纸上用英语写一个高层次版本，<strong>这种对程序的高层次描述，叫伪代码</strong>，然后，用“<strong>操作码表</strong>”把伪代码转成二进制机器码，翻译完成后，程序就可以喂入计算机并运行。</p><h5 id="11-1-2-汇编语言"><a href="#11-1-2-汇编语言" class="headerlink" title="11.1.2 汇编语言"></a>11.1.2 汇编语言</h5><p>但这种方法太麻烦了，所以在1940-1950年代，程序员开发一种新语言，更可读更高层次。它为每个操作码分配一个简单名字，叫“<strong>助记符</strong>”，助记符后面紧跟数据，形成完整指令。程序员可以用“LOAD_A 14”写代码，而不是用01二进制写代码了。</p><p><img src="https://pic.imgdb.cn/item/66a8486ad9c307b7e9aaacf1.png" alt="部分汇编语言表" style="zoom:60%"></p><h5 id="11-1-3-汇编器"><a href="#11-1-3-汇编器" class="headerlink" title="11.1.3 汇编器"></a>11.1.3 汇编器</h5><p>当然，计算机并不认识助记符，它只认得二进制码，所以程序员写了一个二进制程序来帮忙。<strong>它可以读懂文字指令，自动转换成二进制指令，这种程序叫“汇编器”</strong>。汇编器读取用汇编语言写的程序，然后转成“机器码”。随着时间推移，汇编器能够帮助人类完成的事情越来越多。其中一个就是自动分析JUMP地址，程序员写程序时，只需写入可跳转的标签，汇编器就会自己跳转分析。</p><p>因此，程序员可以专心编程，不用管底层细节。</p><p>汇编语言直接对应机器码，虽然已经很方便了。但是，汇编器仍然强迫程序员思考，用什么寄存器和内存地址，如果我们突然要用额外一个数，可能要改很多代码。这时候，需要更加高级的语言出现。</p><h4 id="11-2-A-0语言"><a href="#11-2-A-0语言" class="headerlink" title="11.2 A-0语言"></a>11.2 A-0语言</h4><p>为了更加方便编程，历史上有计算机科学家发明了A-0语言。这种语言相对汇编语言更加高级(一般一条汇编指令对应一条机器指令)，一行高级编程语言，可能会转成几十条二进制指令。同时，这名科学家还做了<strong>编译器</strong>，可以专门把高级语言转成低级语言，比如汇编或者机器码（CPU可以直接执行机器码）。虽然这个想法很先进，但是在当时并没有被大众所广泛使用。</p><h4 id="11-3-高级语言的思想"><a href="#11-3-高级语言的思想" class="headerlink" title="11.3 高级语言的思想"></a>11.3 高级语言的思想</h4><p>幸运的是，这种思想开始流行，很多人尝试创建新的编程语言。比如我们用高级语言Python为例，计算两个值的和，如果用汇编语言，我们得从内存取值，和寄存器打交道以及其他底层细节。但同样的程序用Python可以这样写，不用管内存和寄存器位置。</p><p>程序员只需要创建<strong>“代表内存地址的抽象”，叫变量。</strong>上图，我们把变量存在A和B中，然后相加两个数，把结果存在C中。在底层操作时，编译器可能把变量A存在寄存器A中，但这些，程序员已经不需要自己思考放在哪了。</p><h4 id="11-4-Fortran语言"><a href="#11-4-Fortran语言" class="headerlink" title="11.4 Fortran语言"></a>11.4 Fortran语言</h4><p>Fortran语言，名字来源于“公式翻译”，IBM发布于1957年，其主宰了早期计算机编程。平均来说，Fortran语言写的代码，比同等的手写汇编代码短20倍，然后Fortran编译器会把代码转成机器码。语言更加高级，所以运行速度会慢一点，但是代码编写速度会大大提高。Fortran语言开始时只能运行在IBM计算机上。</p><h4 id="11-5-通用编程高级语言"><a href="#11-5-通用编程高级语言" class="headerlink" title="11.5 通用编程高级语言"></a>11.5 通用编程高级语言</h4><p>50年代的大部分编程语言和编译器只能运行在一种计算机上。如果升级电脑，所有的代码都可能要重写。因此，工业界、学术界和政府计算机专家，在1959年组成一个联盟——<strong>数据系统语言委员会</strong>。开发了一种通用编程语言，可以在不同机器上通用。最后，诞生一门通用商业语言，Cobol。为了兼容不同硬件，每个计算机都需要对应的编译器，但是这些编译器可以接收相同的Cobol代码。这种叫<strong>一次编写，多处运行</strong>。</p><p>由于高级语言的出现，原来只有计算机科学家才能的编程，到后来各个专业的人们都可以学会编程。下面是不同年代出现的主要重要语言，可以以此来瞧瞧编程语言的发展。</p><ol><li>从1959年开始，编程语言的时代开始了。</li><li>在1960年代，有Algol、Lisp、Basic等语言。</li><li>70年代有Pascal、C和Smalltalk语言等。</li><li>80年代有C++、Objective-C（扩充C的面向对象语言）等。</li><li>90年代有Python、Java和Ruby等语言。</li><li>在新千年，Swift、C#和Go在崛起。</li></ol><p>新语言使用更加聪明的抽象，使得其在某些方面更容易和强大。</p><h3 id="12-编程原理-语句和函数"><a href="#12-编程原理-语句和函数" class="headerlink" title="12 编程原理-语句和函数"></a>12 编程原理-语句和函数</h3><p>上节课讲到机器码写程序需要处理底层细节，写大型程序非常麻烦。为了脱离底层细节，开发了编程语言以让程序员专心解决问题，不用管硬件细节。这节课，我们讨论大部分编程语言都有的<strong>语法和函数</strong>。</p><h4 id="12-1-语句与语法"><a href="#12-1-语句与语法" class="headerlink" title="12.1 语句与语法"></a>12.1 语句与语法</h4><p><strong>语法，是用来规定句子结构的一系列规则。</strong>英语有语法，所有的编程语言也都有语法。a=5是一句语言，意思是，创建一个变量a，把数字5放进去。这叫赋值语句，把一个值赋给一个变量。注意，变量名称可以随便取（不重名即可），当然取名最好有点意义，这样可以方便别人读懂。程序和做菜一样，会一步步运行到程序尾部。</p><p>为了不只是顺序执行程序，我们需要流程控制语句。最常见的流程控制语句是if语句，if语句需要判断语句，因此这些表达式又叫“<strong>条件语句</strong>”，下面是一些流行语言的if语句。if语句是指，如果if里的条件为真，那么就执行if下面的代码；否则执行else下面的代码。</p><p><img src="https://pic.imgdb.cn/item/66a85205d9c307b7e9b2349b.png" alt="常见编程语言的if-else语法"></p><p>if语句只执行一次，如果要执行多次，则要用<strong>while语句</strong>。当while条件为真时，就会重复执行代码。另一个常用的循环结构是<strong>for结构</strong>。for结构不判断条件，会判断次数，会循环特定次数。 </p><h4 id="12-2-函数"><a href="#12-2-函数" class="headerlink" title="12.2 函数"></a>12.2 函数</h4><p><strong>为了隐藏程序的复杂度，我们可以把代码打包成函数，有些编程语言也叫“方法”或“子程序”</strong>。若其他地方想用这个函数，直接写函数名即可。当然，我们可以在函数里面加其他函数，这样可以设计更加简洁的代码。所以现代软件，是由上千个函数组成的，每个负责不同的事情。</p><p>这种模块化编程，不仅可以让单个程序员独立制作APP，也可以让团队协作写更大型的程序。不同程序员写不同的函数，只需要保证自己的代码正确，把所有人的拼起来，整个程序应该就能正常运行。</p><p>现在，我们不需要写指数函数这些普遍的函数。现代编程语言，有很多预先写好的函数集合，叫“<strong>库</strong>”，由专业人员编写，不仅效率高，而且经过了仔细检查。这样可以方便我们开发程序。本节结束，下节讲函数。 </p><h3 id="13-算法入门"><a href="#13-算法入门" class="headerlink" title="13 算法入门"></a>13 算法入门</h3><p>前面两集尝试了高级编程语言，我们讨论了几种语句，赋值语句、if语句、循环语句等，以及打包的函数。算法，是解决某种问题的具体方法，一般而言所需时间越少越好，有时我们也关注其他方面，比如所占空间等。</p><h4 id="13-1-排序算法"><a href="#13-1-排序算法" class="headerlink" title="13.1 排序算法"></a>13.1 排序算法</h4><p>最常见的算法就是排序，比如给数字排序。排序也是应用非常广泛，非常常见的算法。排序算法有很多，为的是更快地进行排序。视频讲了选择排序。<strong>选择排序</strong>是指，对于每一次范围（这个范围逐渐减少）从中选择最小的放在最首。</p><p>算法的输入大小与运行步骤之间的关系，叫算法复杂度，代表运c行速度的量级。算法复杂度叫大O表示法。选择排序的复杂度是O(n^2)。此外，更低的排序有<strong>归并排序，时间复杂度是O(n*logn)。</strong></p><h4 id="13-2-迪杰斯特拉算法"><a href="#13-2-迪杰斯特拉算法" class="headerlink" title="13.2 迪杰斯特拉算法"></a>13.2 迪杰斯特拉算法</h4><p>用于图搜索的算法，对于一个有权图，要找最短路径，如果全部穷举，那么会是O(n!)的复杂度，这是一个非常糟糕的复杂度。所以，迪杰斯特拉发明了一种求最短路的算法，叫迪杰斯特拉算法。其算法复杂度是O（n^2）。</p><p>算法无处不在，并广泛应用于生活中各个地方，算法设计，也是计算机科学中一个很重要的方向。本节完，这节内容比较少，是因为这些知识数据结构中基本都学过了，就不需要着重记笔记。 </p><h3 id="14-数据结构"><a href="#14-数据结构" class="headerlink" title="14 数据结构"></a>14 数据结构</h3><p>本集高能，基本上一分钟一个数据结构。</p><p>上节课讲了一写算法，比如数组排序、最短路径。不过，上节没讲的是，算法处理的数据，存在内存里的格式是什么。我们希望数据是结构化的，方便读取。所以，科学家发明了<strong>数据结构。</strong></p><h4 id="14-1-数组"><a href="#14-1-数组" class="headerlink" title="14.1 数组"></a>14.1 数组</h4><p><strong>数组的值一个个连续存在内存里面</strong>，所以不像之前，一个变量里只存一个值，我们可以把多个值存在数组变量里。我们用下标<code>[i]</code>取值，下标一般从0开始。<strong>数组变量表示的是首元素地址</strong>，后面通过偏移得到其他元素坐标。</p><p><img src="https://pic.imgdb.cn/item/66a86421d9c307b7e9c0ddf0.png" alt="数组"></p><p>现在很多语言自带了数组的一些算法，比如排序算法等，不需要我们直接写。</p><h4 id="14-2-字符串"><a href="#14-2-字符串" class="headerlink" title="14.2 字符串"></a>14.2 字符串</h4><p>和数组相似的就是字符串，它是<strong>由字母、数字和标点等组成的数组</strong>。写代码时，用括号括起来就可以了，<code>j=&quot;START&quot;</code>。在字符串末尾，有<code>NULL</code>项，这一项表示字符串到此结束。</p><p>因为计算机经常处理字符串，所以会有很多字符串函数，比如连接字符串strcat（接收两个字符串，把第二个放在第一个末尾）。</p><h4 id="14-3-矩阵"><a href="#14-3-矩阵" class="headerlink" title="14.3 矩阵"></a>14.3 矩阵</h4><p>有时，我们需要处理图像或者表格，此时我们需要矩阵。我们<strong>可以把矩阵看做是数组的数组</strong>。多维数组里的元素，其实也是像一维数组那样顺序排列的，只不过提取数组方式不一样。</p><p><img src="https://pic.imgdb.cn/item/66a86560d9c307b7e9c20aa8.png"></p><h4 id="14-4-结构体"><a href="#14-4-结构体" class="headerlink" title="14.4 结构体"></a>14.4 结构体</h4><p><strong>把多种不同类型的数据打包放在一起，就叫结构体</strong>。甚至我们可以做一个结构体数组。结构体数组和普通数组一样，创建时便有固定的空间，不能动态增加容量。</p><h4 id="14-5-链表"><a href="#14-5-链表" class="headerlink" title="14.5 链表"></a>14.5 链表</h4><p>我们将值和指针放在一个节点（结构体）里面，就可以实现动态添加元素。指针是一种特殊变量，指向一个内存地址。<strong>多个连成的节点，就叫链表</strong>。有多种链表，比如循环链表和单向链表等等。</p><p><img src="https://pic.imgdb.cn/item/66a8663fd9c307b7e9c2ba99.png" alt="链表"></p><p>不同于数组的长度固定，链表可以通过改变指针指向动态添加元素。 </p><ul><li><strong>队列和栈</strong></li></ul><p>队列和栈都是基于链表的（好像有数组类型的不过不常用）。</p><p>队列就像排队一样，谁先来谁先上，这叫<strong>先进先出（FIFO）</strong>。有<strong>入队和出队</strong>操作，入队在队尾进行，出队在队首进行。</p><p>栈是<strong>先进后出</strong>的结构。栈元素的出入叫<strong>入栈和出栈</strong>。入栈和出栈在栈顶进行。</p><h4 id="14-6-树"><a href="#14-6-树" class="headerlink" title="14.6 树"></a>14.6 树</h4><p>如果节点有两个指针，分别指向左树和右树。最高的叫<strong>根节点</strong>，其余都叫子节点。没有任何子节点的节点，叫叶节点。若每个节点最多两个子节点，那么就叫<strong>二叉树</strong>。</p><p><img src="https://pic.imgdb.cn/item/66a86712d9c307b7e9c35a99.png" alt="二叉树" style="zoom:60%"></p><p>树的一个重要特性是，从根到叶是单向的。</p><h4 id="14-7-图"><a href="#14-7-图" class="headerlink" title="14.7 图"></a>14.7 图</h4><p>不同于树，如果数据可以随意相连，包括循环，就叫<strong>图</strong>。</p><p><img src="https://pic.imgdb.cn/item/66a8678ed9c307b7e9c3bbe2.png" alt="图" style="zoom:60%"></p><p>上面就是主要的数据结构，此外还有堆和红黑树等等。最后，利用好数据结构，可以帮助我们更加高效地完成一些任务开发。 </p><h3 id="15-阿兰·图灵"><a href="#15-阿兰·图灵" class="headerlink" title="15 阿兰·图灵"></a>15 阿兰·图灵</h3><h4 id="15-1-图灵机"><a href="#15-1-图灵机" class="headerlink" title="15.1 图灵机"></a>15.1 图灵机</h4><p>前几集我们讲了基础，比如函数、算法和数据结构。今天，我们来看一个对计算机理论贡献巨大的人，计算机科学之父——阿兰·图灵。</p><p>图灵于1912年出生在伦敦。当时一个很著名的问题是“<strong>可判定性问题</strong>”：是否存在一种算法，输入正确逻辑语句，输出准确的“是”或“否”。美国数学家阿隆佐·丘奇于1913年首先提出解决办法，他开发了一个叫“<strong>lambda算子</strong>”的系统，证明了这样的算法不存在。</p><p>但是lambda算子系统过于复杂，大洋彼岸的图灵提出一种假想计算机——后来被称为图灵计算机。图灵机的原理更加简单，更容易被人接受。图灵是一台理论计算设备。</p><p><img src="https://pic.imgdb.cn/item/66a86990d9c307b7e9c52364.png" alt="图灵机" style="zoom:30%"></p><p>图灵机有无限长的纸带，纸带可以存储符号。图灵机可以读入和写入纸带上的符号，还有一个状态变量，保存当前状态，还有规则。<strong>图灵证明只要有足够多的规则、状态和纸带，可以创造任何东西。</strong>没有计算机能比图灵机更强大。现在的计算机、手表和手机啥的，都是<strong>图灵完备的。</strong></p><ul><li><strong>停机问题</strong></li></ul><p>图灵利用图灵机完成了可判定性问题的证明。</p><p>有没有办法在不执行的情况，弄清会不会停机？</p><p>图灵通过一个巧妙逻辑矛盾证明了停机问题是无法解决的，我们来看看他的推理。想象有一个假想图灵机，输入:问题的描述+纸带的数据，输出 Yes 代表会”停机”，输出 No 代表不会停机。不用担心它具体怎么工作，假设这样的机器存在就好，毕竟重点是推论。</p><p>图灵推理说：如果有个程序，此图灵机无法判断是否会”停机”，意味着”停机问题”无法解决。为了找到这样的程序，图灵用这台图灵机设计了另一个图灵机。如果一开始的图灵机说程序会”停机”(YES)，那么新设计机器会永远运行(即不会停机)；如果一开始的图灵机的结果为 No，代表不会停机，那么让新机器输出 No，然后”停机”。也就是说新设计的图灵机和一开始的图灵机的输出正好相反。如果程序不停机，就停机，如果程序停机，就永远运行下去。</p><p>…………剩下的内容看视频吧。</p><p>总之，长话短说，丘奇和图灵证明了计算机的能力有极限，无论有多少时间或内存，有些问题是计算机无法解决的。</p><h3 id="16-软件工程"><a href="#16-软件工程" class="headerlink" title="16 软件工程"></a>16 软件工程</h3><p>大型软件，代码往往很多。开发软件需要很强的科学性，由此，一个关于软件的学问出现了，软件工程。</p><h4 id="16-1-面向对象"><a href="#16-1-面向对象" class="headerlink" title="16.1 面向对象"></a>16.1 面向对象</h4><p>前文我们提到了，把大项目分解成小函数，可以让很多人同时工作。每个人不需要关心整个工程，只需要关心自己的部分即可。</p><p>但是仅仅把打包成函数还不够，就像office有上千万行代码，就算打包成函数也有几十万个。解决办法是：<strong>把函数打包成层级，把相关代码都放在一起，打包成对象。这就是面向对象的由来。</strong></p><p><strong>一个对象可以包含其他对象、函数和变量。</strong>我们要访问某个函数时，要通过对象不断向内索引。这样通过封装组件，可以<strong>隐藏复杂度</strong>。</p><h4 id="16-2-开发文档"><a href="#16-2-开发文档" class="headerlink" title="16.2 开发文档"></a>16.2 开发文档</h4><p>开发完成项目后，团队需要完成解释文档，帮助理解代码都在做什么，以及定义好<strong><font color=red>”程序编程接口”，简称API</font></strong>。</p><p><u>API帮助不同程序员合作，不用知道具体细节，只知道怎么使用就行了。API还控制哪些函数和数据让外部访问，哪些仅供内部访问。“面向对象”的编程语言，可以指定函数是public或private来设置权限</u>。</p><p>“面向对象”的核心是，<strong>隐藏复杂度和选择性的公布功能</strong>。现在大部分软件或者游戏都是面向对象编程语言写的，比如C++，C#等。</p><h4 id="16-3-IDE"><a href="#16-3-IDE" class="headerlink" title="16.3 IDE"></a>16.3 IDE</h4><p>现代软件的开发，一般需要借助开发器。<strong>开发器集成了编译、调试、整理代码等功能，因为集成了所有的东西，因此叫集成开发环境，简称IDE</strong>。</p><p><img src="https://pic.imgdb.cn/item/66a871d8d9c307b7e9cbc775.png" alt="Pycharm：较流行的Python的IDE" style="zoom:50%"></p><p>IDE还可以直接编译和运行代码。如果代码错误，IDE会定位到错误代码并给出提示来解决问题，这叫调试debug。</p><p>程序员工作的另一个重要部分是给代码写文档，这个文档写在readme里面。文档也可以直接注释在程序里面。<strong>注释很重要</strong>。</p><h4 id="16-4-源代码管理"><a href="#16-4-源代码管理" class="headerlink" title="16.4 源代码管理"></a>16.4 源代码管理</h4><p>IDE还有另一个功能，叫<strong>源代码管理</strong>，也叫<strong>版本控制</strong>。大型程序有源代码管理，他们还会将代码放到一个中心服务器上，叫代码仓库。</p><p>要修改代码时，就从代码仓库里取出来，修改完成后再放入。</p><p>当代码出现错误时，源代码管理也可以帮助程序员恢复到未修改的版本，并定位是谁修改了代码。</p><h4 id="16-5-测试"><a href="#16-5-测试" class="headerlink" title="16.5 测试"></a>16.5 测试</h4><p>测试代码和写代码一样重要，测试一般有个人或者小团队完成。测试统称为“质量保存测试”，简称QA。它严格测试软件的方方面面，模拟各种情况，看看软件会不会出错，就是找Bug。</p><h4 id="16-6-alpha版本和beta版本"><a href="#16-6-alpha版本和beta版本" class="headerlink" title="16.6 alpha版本和beta版本"></a>16.6 alpha版本和beta版本</h4><p>beta版本是接近完成的版本，此版本可以向大众开放，进行免费测试。alpha版本的粗糙的版本。</p><h3 id="17-集成电路与摩尔定律"><a href="#17-集成电路与摩尔定律" class="headerlink" title="17 集成电路与摩尔定律"></a>17 集成电路与摩尔定律</h3><p>过去几集我们学了软件、编程语言等，软件科学有着巨大的发展，但是如果没有硬件的大幅度进步，软件是不可能做到这些的。</p><h4 id="17-1-集成电路IC的出现"><a href="#17-1-集成电路IC的出现" class="headerlink" title="17.1 集成电路IC的出现"></a>17.1 集成电路IC的出现</h4><p>电子计算机时代，计算机有独立部件组成，叫”分立元件“，然后不同组件再用线连在一起。这时候计算机非常大而且很昂贵。在1950年中期，<strong>晶体管</strong>开始商业化，开始用于计算机。晶体管比真空管更小，但是元件依然是分立的。</p><p>晶体管的到来，标志着”计算2.0时代“的到来。但是晶体管的出现并没有完全解决电脑元件多线路复杂的问题。解决办法就是，讲计算机所有元件集成。<strong>简单地来说，把多个组件包在一起，变成一个新的独立组件，这就是集成电路。</strong></p><p>1959年的仙童半导体，让集成电路变成现实。仙童半导体用硅作为材料，其更稳定更可靠，价格也更低。<strong>Noyce因为发明了仙童半导体，被公认为现代集成电路之父</strong>。电子时代出现。</p><p><img src="https://pic.imgdb.cn/item/66a874b8d9c307b7e9cf050d.png" alt="IC的早期样品：只有几个晶体管" style="zoom:60%"></p><p>IC 就像电脑工程师的乐高积木，可以组合出无数种设计，但最终还是需要连起来，创造更大更复杂的电路，比如整个计算机。所以，PCB被创造出来了。</p><h4 id="17-2-印刷电路板——PCB"><a href="#17-2-印刷电路板——PCB" class="headerlink" title="17.2 印刷电路板——PCB"></a>17.2 印刷电路板——PCB</h4><p>集成电路可以把多个电路元件集成在一块芯片上，但是依然要将电路连接起来以制造计算机。所以工程师再度创新：印刷电路板，简称PCB。PCB可以大规模生产，<strong>无需焊接或用一大堆线。它通过蚀刻金属线的方式，把零件连接到一起。</strong>PCB和IC结合使用，可以大幅度减少独立组件和线路，但做到同样的功能。而且更小、更便宜更可靠。</p><h4 id="17-3-光刻"><a href="#17-3-光刻" class="headerlink" title="17.3 光刻"></a>17.3 光刻</h4><p>早期的元件，无法集成大量晶体管。所以需要全新的制造工艺——光刻。简单来说，就是用光把复杂图案印到材料上，比如半导体。它只有几个基础操作，但可以制作出复杂电路。</p><p><img src="https://pic.imgdb.cn/item/66a8766cd9c307b7e9d067a7.png" style="zoom:30%"></p><p>光刻机光刻电路的流程是，对于一块硅（晶圆），上面加氧化层，光刻胶，和光掩膜，然后用强光照射，强光能照射的地方光刻胶消失，然后把露出部分的氧化层清洗掉，最后再清洗掉光刻胶，就可以进行材料<strong>掺杂</strong>了。 </p><p><img src="https://pic.imgdb.cn/item/66a8770ed9c307b7e9d0f996.png" style="zoom:30%"></p><blockquote><p>我们想修改硅露出来的区域让它导电性更好，所以用一种化学过程来改变它，称为“掺杂”。</p></blockquote><p>由于光刻机和集成电路的出现，一片IC由原来的5个晶体管增加到1960年中期的上百个。</p><h4 id="17-4-摩尔定律"><a href="#17-4-摩尔定律" class="headerlink" title="17.4 摩尔定律"></a>17.4 摩尔定律</h4><p>1965年，摩尔看到了趋势：<strong>每两年左右，得益于材料和制造技术的发展，同样大小的空间，能塞进两倍数量的晶体管。这叫摩尔定律</strong>。芯片的价格也不断下降。</p><p>芯片集成地小，可以减少电的损耗，信号延迟更低，时钟速度加快。仅仅1950年左右，用分立元件会占满整个屋子，到集成电路出现，元件越来越小。尤其是集成电路用于微处理器，开启了计算3.0时代。到2010年，10亿个晶体管集成在一片芯片。光刻机分辨率也从几毫米到15纳米。</p><p>如今的处理器，比如iPhone7的A10CPU，有33亿个晶体管。</p><p>集成芯片的设计当然不是手工的，从1970年开始，<strong><font color=blue>超大规模集成（VLSI）</font></strong>软件来自动生产芯片设计。</p><h4 id="17-5-未来集成电路面临的挑战"><a href="#17-5-未来集成电路面临的挑战" class="headerlink" title="17.5 未来集成电路面临的挑战"></a>17.5 未来集成电路面临的挑战</h4><p>不幸的是，摩尔定律受到越来越多的挑战，现在已经达到极限。进一步做小，会<strong>面临两个问题。</strong></p><ol><li>用光掩膜把图案加到晶圆上，因为光的波长，精度已经达到极限。</li><li>当晶体管非常小，电极之间可能只距离几个原子，电子会跳过间隙，叫<strong>量子隧道贯穿效应</strong>。</li></ol><h3 id="18-操作系统"><a href="#18-操作系统" class="headerlink" title="18 操作系统"></a>18 操作系统</h3><h4 id="18-1-操作系统简介"><a href="#18-1-操作系统简介" class="headerlink" title="18.1 操作系统简介"></a>18.1 操作系统简介</h4><p>1940、1950年代的电脑，每次只能运行一个程序，程序员通过在打孔纸板上写程序来进行。打好孔后，再放入计算机中运行程序。但是，这种方法较慢。我们需要一种方法，让计算机自动运行程序，”<strong>操作系统</strong>“因此而生。</p><p><strong>操作系统，也叫OS，其实也是一种程序</strong>。但是它有操作硬件和特殊权限，可以运行和管理其他程序。操作系统一般是开机第一个启动的程序。其他程序，都由操作系统启动。</p><h4 id="18-2-操作系统的作用"><a href="#18-2-操作系统的作用" class="headerlink" title="18.2 操作系统的作用"></a>18.2 操作系统的作用</h4><p>早期的操作系统，一次只能运行一个程序，现在可以运行多个。<strong>系统运行完一个程序后，会自动运行下一个程序，不会浪费时间在更换程序上，这叫”批处理“</strong>。</p><p>当时，不同的CPU甚至相同的，可能配备着不同的打印机。程序员不仅需要考虑如何写程序，还有考虑如何和打印机和键盘等”<strong>外部设备</strong>“的交互。程序员需要考虑外部设备如何使用，以进行写代码。如今，操作系统充当软件和硬件之间的媒介。更具体地说，操作系统提供API来抽象硬件，叫”<strong><font color=blue>设备驱动程序</font></strong>”。程序员可以用标准化机制和输入输出硬件(I/O)交互。比如，程序员只需要调用<code>print(highscore)</code>，然后操作系统会处理输出到纸上的具体细节。</p><h4 id="18-2-多任务处理"><a href="#18-2-多任务处理" class="headerlink" title="18.2 多任务处理"></a>18.2 多任务处理</h4><p>如果一个系统只能运行一个程序的话，那么很多设备将会闲置，只能等待其他I/O设备完成后，才用。所以，后来开发了能在单个CPU上<strong>同时运行几个程序的操作系统</strong>。这种能力叫做操作系统的”<strong>多任务处理</strong>“。</p><h4 id="18-3-操作系统的内存管理"><a href="#18-3-操作系统的内存管理" class="headerlink" title="18.3 操作系统的内存管理"></a>18.3 操作系统的内存管理</h4><p>不同的程序数据，在计算机中存放于不同的位置，甚至可能同一个程序的数据分别处于计算机中的不同位置。这种存法导致程序员要追踪这些地址很麻烦。<strong>为了隐藏这种复杂性，操作系统会把内存地址进行”虚拟化“，这叫<font color=purple>虚拟内存</font></strong>。程序可以假定内存总是从地址0开始的。而内存实际的物理地址，被操作系统隐藏和抽象了。</p><p><img src="https://pic.imgdb.cn/item/66a89026d9c307b7e9e950ba.png" alt="虚拟内存" style="zoom:70%"></p><p>操作系统会自动地将程序的物理地址与虚拟地址进行映射（有一个映射表，存储了虚拟内存和真实内存的映射关系）。一个在不同物理地址的程序，可能映射为统一顺序。这种机制可以使程序的内存大小可以灵活增减，叫”<strong>动态内存分配</strong>“。</p><p>我们会给一个程序一定的内存范围，如果程序出错开始乱写数据，那么这些错误的数据不会到其他内存下，这叫“<strong><font color=green>内存保护</font></strong>”。这对防止恶意软件(如病毒)也很有用，例如，我们不希望其他程序有能力读或改邮件程序的内存，如果有这种权限，恶意软件可能以你的名义发邮件，甚至窃取个人信息。</p><h4 id="18-4-分时操作系统"><a href="#18-4-分时操作系统" class="headerlink" title="18.4 分时操作系统"></a>18.4 分时操作系统</h4><p>在1970年代，计算机开始变得越来越便宜。这时，计算机不仅可以多个程序运行，而且可以多个用户访问。用户通过“<strong>终端</strong>”访问电脑，*<u>终端只是键盘和屏幕，本身没有处理能力</u>*。冰箱大小的计算机可能有50个终端，能让50个用户使用，这时操作系统不但要处理多个程序，还要处理多个用户。</p><p>为了能够让多用户使用计算机而不会使一个用户占满计算机，开发了<strong>分时操作系统。意思是每个用户只能用一小部分处理器、内存等</strong>，因为电脑很快，即使拿到1/50的资源也足以完成许多任务。</p><p>早期分时操作系统中，最有影响力的是<strong>Multics</strong>（多任务信息与计算系统），它是第一个从设计时就考虑到安全的操作系统。开发人员不希望恶意用户访问不该服务的数据。不过由于其系统过度设计了（功能太多），导致其所占内存过多，不能流行起来。</p><h4 id="18-5-Unix操作系统"><a href="#18-5-Unix操作系统" class="headerlink" title="18.5 Unix操作系统"></a>18.5 Unix操作系统</h4><p>所以为了简化操作系统的复杂度，设计者开发了<strong>Unix</strong>，Unix把操作系统分成两个部分：</p><ol><li>首先是操作系统的核心功能，如<u>内存管理、多任务处理和输入/输出处理</u>，这叫“<strong>内核</strong>”；</li><li>第二部分是一堆有用的工具，如程序和运行库，但他们不是内核的一部分。紧凑的内核，意味着功能没有那么全面。</li></ol><p>Unix的简单使得它可以用于很多计算机，越来越多的开发人员用Unix写程序和运行程序。Unix系统也在贝尔实验室大受欢迎。甚至在1970年代，有人还写了在Unix下的不同编程语言的编译器，这些使得Unix成为了1970-80年代最受欢迎的计算机操作系统。</p><h4 id="18-6-个人电脑和现代操作系统"><a href="#18-6-个人电脑和现代操作系统" class="headerlink" title="18.6 个人电脑和现代操作系统"></a>18.6 个人电脑和现代操作系统</h4><p>随着计算机水平的发展，出现了个人电脑和家庭电脑。这些电脑的操作系统比较简单，缺乏“多任务“、”内存保护“等功能，若遇到程序错误，就会发生<strong>崩溃（蓝屏）</strong>。幸运的是，1980年代开发的windows系统，有更好的保护，不会经常崩溃。</p><h3 id="19-内存和储存介质"><a href="#19-内存和储存介质" class="headerlink" title="19 内存和储存介质"></a>19 内存和储存介质</h3><p>本节重点，存储技术的发展。</p><h4 id="19-1-内存和存储器区别"><a href="#19-1-内存和存储器区别" class="headerlink" title="19.1 内存和存储器区别"></a>19.1 内存和存储器区别</h4><p>本系列中，我们多次谈到内存，甚至设计了一个简单内存（锁存器）。一般来说，电脑内存是”非永久性“，如果电源线不小心拔掉了，内存里所有数据都会丢失，所以内存叫”易失性“存储器。</p><p>不过，存储器和内存有所不同。任何写入存储器的数据，比如电脑硬盘，数据会一直存着，直到被覆盖删除，断电也不会丢失。存储是”非易失的“。比如一个小小的U盘，能够低成本+可靠+长时间地存储上GB的数据。</p><h4 id="19-2-早期的存储器——延迟线存储器"><a href="#19-2-早期的存储器——延迟线存储器" class="headerlink" title="19.2 早期的存储器——延迟线存储器"></a>19.2 早期的存储器——延迟线存储器</h4><p>最早的存储介质是打孔纸片和打孔纸带。纸片用了十几年，因为不用电而且便宜耐用。坏处就是读取慢，只能写入一次，打的孔无法修复，若要存储临时值，纸卡不好用。</p><p><img src="https://pic.imgdb.cn/item/66a89931d9c307b7e9f1439e.png" alt="纸卡片存储器" style="zoom:40%"></p><p>由于纸片的缺陷，人们发明了延迟线存储器。原理是，拿一个管子装满液体，管子一端放扬声器，另一端放麦克风，扬声器发出的声波，发送到麦克风需要一定时间，麦克风将压力波转换回电信号，我们可以用压力波的传播延迟来存储数据。若有压力则表示1，无则表示0，麦克风受到这些压力波后，把其转换为1010之类的二进制数据。若用线路+放大器将其接回，那么就可以存储这段信号了。 </p><p><img src="https://pic.imgdb.cn/item/66a89a4ed9c307b7e9f23ae9.png" alt="延迟线存储器" style="zoom:30%"></p><p>但是，延长线存储器的缺点是，每个时刻只能读一位数据。如果你想访问第100位数据，你只能等待第100位数据出现，这种叫做”顺序存储器“或”循环存储器“，而我们想要的是”随机存取存储器“，可以随时访问任何位置。</p><h4 id="19-3-磁芯存储器"><a href="#19-3-磁芯存储器" class="headerlink" title="19.3 磁芯存储器"></a>19.3 磁芯存储器</h4><p>后面还出现了如”磁致伸缩延迟存储器“，但是延迟线存储器在1950年代中期就基本过时了，因为出现了性能、可靠性和成本都更好的”<strong>磁芯存储器</strong>“。当磁圈加正电，就可以磁化，加反向电，就可以反向磁化，可以用这个来表示01存储信息。当然，用1位不行，需要用到磁圈网络。</p><p><img src="https://pic.imgdb.cn/item/66a89cd8d9c307b7e9f47620.png" alt="磁圈网络"></p><p>下图是一个实际的磁芯存储器，每个黄色方格有32行x32列的磁芯，每个磁芯存1位数据，所以能存1024 位(bit)(32x32=1024)。</p><p><img src="https://pic.imgdb.cn/item/66a89d17d9c307b7e9f4ac28.png" alt="现实中的磁芯存储器" style="zoom:60%"></p><p>最重要的是，磁芯存储器不像延迟线存储器，磁芯存储器能随时访问任何一位，这时非常有用的。磁芯存储器于1950开始，流行了20多年。 </p><h4 id="19-4-磁带"><a href="#19-4-磁带" class="headerlink" title="19.4 磁带"></a>19.4 磁带</h4><p>即使如此，磁芯存储器能存储的数据还是太少了。1951年，还发明了一直存储器，叫”<strong>磁带</strong>“。磁带是纤薄柔软的一长条磁性带子，卷在轴上。磁带可以在”磁带驱动器“内前后移动。磁带的存储空间相比之前的几kb大小，大了很多，可达几mb。因为磁带驱动器很贵，但是磁带很便宜，所以磁带一般用于数据存储。磁带的主要缺点是访问速度。</p><p><img src="https://pic.imgdb.cn/item/66a89e73d9c307b7e9f76763.png" alt="磁带的简要原理" style="zoom:60%"></p><h4 id="19-5-现代存储器——硬盘、软盘、光盘"><a href="#19-5-现代存储器——硬盘、软盘、光盘" class="headerlink" title="19.5 现代存储器——硬盘、软盘、光盘"></a>19.5 现代存储器——硬盘、软盘、光盘</h4><p>1950，60年代，有个类似的“磁鼓存储器”，磁鼓持续旋转，可以读取数据。但到1970年代，磁鼓存储器不再生产。然而磁鼓导致了<strong>硬盘</strong>的发展，因为硬盘和磁鼓很像。磁盘有磁性，其优点就算薄，可以进行堆叠。1970年代，磁盘大幅度改进并变得普遍，如今硬盘可以轻易容纳1TB的数据。</p><p><img src="https://pic.imgdb.cn/item/66a89f67d9c307b7e9f85747.png" alt="实际中的硬盘" style="zoom:80%"></p><p>软盘，除了磁盘是软的，其他基本一样。软盘是为了便携。你可能对光盘（CD）产品更熟悉，功能和硬盘一样，都是存储数据，不过原理不同，光盘主要用的是光学技术。如今，存储器朝固态前进，如硬盘和U盘，里面都是集成电路。如果机械硬盘被固态硬盘代替，简称SSD。 </p><h3 id="20-文件系统"><a href="#20-文件系统" class="headerlink" title="20 文件系统"></a>20 文件系统</h3><p>上集我们讲了数据存储，磁带和硬盘这样的技术。他们可以在断电的情况下存储上万亿个位，非常适合存储一整块相关的文件。我们见过很多文件，比如音乐文件，视频文件。这节课我们要讲，什么是文件，计算机如何管理文件。</p><h4 id="20-1-计算机中的文件格式"><a href="#20-1-计算机中的文件格式" class="headerlink" title="20.1 计算机中的文件格式"></a>20.1 计算机中的文件格式</h4><h5 id="20-1-1-数据格式与TXT文本文件"><a href="#20-1-1-数据格式与TXT文本文件" class="headerlink" title="20.1.1 数据格式与TXT文本文件"></a>20.1.1 数据格式与TXT文本文件</h5><p>数据可以随意摆放，但是按照一定规律和格式会更好，这叫数据格式。你可以发明自己的格式，但是最好按照已有的格式更好，比如JPG。</p><p>最简单的是文本文件，简称TXT，其本质也是二进制。我们可以把二进制转换为十进制，再由ASCII值转换为字符。</p><h5 id="20-1-2-波形文件WAV"><a href="#20-1-2-波形文件WAV" class="headerlink" title="20.1.2 波形文件WAV"></a>20.1.2 波形文件WAV</h5><p>更复杂的文件，比如波形文件（wave），简称wav，它存音频文件。在正确读取数据前，需要知道一些信息，如码率，单声道还是立体声。数据的数据，叫<strong><font color=green>元数据</font></strong>。元数据在文件开头，在实际数据前面，因此也叫文件头。音频数据紧跟在元数据后面，是一长串数字，数字代表每秒捕获多次的声音幅度。</p><p><img src="https://pic.imgdb.cn/item/66a8a235d9c307b7e9fafa37.png" alt="wav文件格式"></p><p>比如，对于一段声音，我们可以得到其波形如下。通过电脑或者手机，每秒可以对声音进行上千次采样，每次采样可以用一个数字表示，声压越高数字越大，也叫“振幅”，wave文件里存的就是这些数据。在播放声音文件时，扬声器会产生相同的波形，播出声音。</p><h5 id="20-1-3-位图文件BMP"><a href="#20-1-3-位图文件BMP" class="headerlink" title="20.1.3 位图文件BMP"></a>20.1.3 位图文件BMP</h5><p>位图（Bitmap），后缀.bmp，它存图片，计算机上，图片由很多个叫”像素“的方块组成，每个像素有三种颜色组成：<strong>红，绿，蓝，叫”加色三原色“</strong>，混在一起可以创造其他颜色。如图wav文件一样，bmp文件开头也是元数据，有图像宽度，图像高等，颜色深度信息。BMP文件是一串二进制代码，每三位分别表示红绿蓝的深度。</p><p>不管是文本文件，WAV文件，BMP，或者其他文件，其在底层都是一长串二进制。要想知道文件是什么样的，就得先知道文件格式是什么样的。 </p><h4 id="20-2-计算机如何存储文件"><a href="#20-2-计算机如何存储文件" class="headerlink" title="20.2 计算机如何存储文件"></a>20.2 计算机如何存储文件</h4><h5 id="20-2-1-目录文件"><a href="#20-2-1-目录文件" class="headerlink" title="20.2.1 目录文件"></a>20.2.1 目录文件</h5><p>虽然硬件可能是磁盘、磁带或者硬盘等，不过通过抽象后，都可以看成一排能存数据的桶。早期计算机只能存一个文件，它会顺序放置，从头存到尾。但随着计算能力和存储容量的提高，存多个文件变得非常有用。最简单的是，多个文件连续存储。这时，知道不同文件的开头和结尾在哪就变得很重要。<strong>需要记录文件的位置，这里叫”目录文件“</strong>。这个文件通常存储在开头。</p><p><img src="https://pic.imgdb.cn/item/66a8a437d9c307b7e9fcbb9f.png"></p><p>目录文件中，存所有文件的名称，还有创建时间、能否都写等等，最重要的是，目录文件中写明了文件起始位置和文件大小信息。如果更改了文件信息，就必须更新目录文件。这个例子叫”<strong>平面文件系统</strong>“，因为文件都在同一个层次。</p><p><img src="https://pic.imgdb.cn/item/66a8a481d9c307b7e9fcfc10.png" alt="目录文件结构"></p><h5 id="20-2-2-文件分块——碎片化存储"><a href="#20-2-2-文件分块——碎片化存储" class="headerlink" title="20.2.2 文件分块——碎片化存储"></a>20.2.2 文件分块——碎片化存储</h5><p>现代文件系统可能会出现问题，比如因为文件连续存储，那么前一个文件存储信息过多，可能会覆盖后一个文件。所以出现了两者解决方案：</p><ol><li>把空间划分成一块块，导致有一些”<strong>预留空间</strong>“，可以方便移动和管理；</li><li>拆分文件在多个块里面，目录文件中会记录拆分后文件所在的块。这听起来很像前面讲的虚拟内存。</li></ol><p><img src="https://pic.imgdb.cn/item/66a8a52dd9c307b7e9fd998e.png" alt="分块存储"></p><p>若要删除某个文件<strong>，</strong>计算机会将”目录文件“里的对应文件的信息删除，<strong>注意这里实际的文件并没有被删除，只是可以被其他新文件覆盖。所以计算机取证团队可以利用这点”恢复数据“。</strong></p><p>不过，文件因为这种存储方式会变成多个块，我们称他为<strong>碎片</strong>。碎片化的文件不利于读取，就出现了”<strong>碎片化管理</strong>“技术。<strong>碎片化整理</strong>就是将原来的分散在多个块里的数据，按顺序整理好，方便整理。</p><h5 id="20-2-3-分层文件系统"><a href="#20-2-3-分层文件系统" class="headerlink" title="20.2.3 分层文件系统"></a>20.2.3 分层文件系统</h5><p>平面层的数据不利于文件查看，所以出现了”分层文件系统“，所以出现一个根目录。根目录可以索引下面的文件夹，这样就可以做一个无限深度的文件夹。如果想把数据移动，我们只需要把一个目录文件的信息删除，然后添加在另一个目录文件下即可。</p><p><img src="https://s3.bmp.ovh/imgs/2024/07/30/e96acd5d7a9ba9ae.png" alt="分层文件结构" style="zoom:70%"></p><p>文件系统使我们不必关心文件在磁带或磁盘的具体位置，整理和访问文件更加方便。 </p><h3 id="21-压缩"><a href="#21-压缩" class="headerlink" title="21 压缩"></a>21 压缩</h3><p>上集我们讨论了文件格式，如何编码文字、声音和图片，还举例了txt、wav、bmp，这些格式虽然有用，但是其效率并不高。我们希望文件能小一点，这样能存大量文件，传输也会更快。解决办法就是压缩，把数据变小。</p><h4 id="21-1-无损压缩技术"><a href="#21-1-无损压缩技术" class="headerlink" title="21.1 无损压缩技术"></a>21.1 无损压缩技术</h4><p>我们以图像为例，每个像素的颜色是三种原色：红绿蓝的组合。每个颜色用一个字节存，数字范围是0到255。如果红绿蓝都是255会得到白色。</p><h5 id="21-1-1-游程编码压缩"><a href="#21-1-1-游程编码压缩" class="headerlink" title="21.1.1 游程编码压缩"></a>21.1.1 游程编码压缩</h5><p>为了减少所占内存，<strong>一种方法是减少重复信息</strong>。最简单的方法是<strong>游程编码</strong>，适合经常出现相同值的文件。比如，若有连续多个统一颜色，我们可以在最开始的颜色前加一个数字表示重复次数。为了区分哪个是数字，哪个是颜色，我们将所有颜色前面加数字表示重复次数。</p><p><img src="https://pic.imgdb.cn/item/66a979b9d9c307b7e9a6431a.png" alt="游程编码示例" style="zoom:60%"></p><p>我们在没有损失的情况下，完成了压缩，这叫<strong>无损压缩</strong>。解压后，数据和没有压缩一模一样。</p><h5 id="21-1-2-字典编码压缩"><a href="#21-1-2-字典编码压缩" class="headerlink" title="21.1.2 字典编码压缩"></a>21.1.2 字典编码压缩</h5><p>另一种无损压缩，它用更紧凑的方式表示数据块，叫“字典编码”。我们需要一个字典，存储”代码“和”数据“间的对应关系。</p><p>比如，我们有四种不同的色组如下，我们需要为这四对色组，生产紧凑代码。</p><p><img src="https://pic.imgdb.cn/item/66a97a4ad9c307b7e9a68bc9.png" alt="颜色对"></p><p>1950年，霍夫曼发明了一种高效的编码方式，叫<strong>霍夫曼树</strong>。方法是这样，<strong>列出所有块和出现频率，每轮选两个最低频率，然后将其组成一个树，总频率是2，然后不断重复这个过程</strong>。最后得到如下结果，它有一个属性，按频率排列，然后将每个数分支用01表示，就得到了二进制与颜色块的字典。厉害的是，它们决定不会冲突，因为每条路径是唯一的。这意味在代码是”<strong>无前缀的</strong>”，没有代码是以另一个代码开头的。然后，就可以将原来的颜色二进制码压缩。 </p><p><img src="https://pic.imgdb.cn/item/66a97b0ad9c307b7e9a6e9b2.png" alt="哈夫曼树编码" style="zoom:40%"></p><p>“消除冗余法”和“用更紧凑的表示方法”，这两种方法通常会组合使用。几乎所有的无损格式都用了它们，比如GIF、PNG、PDF、ZIP。<strong>游程编码和字典编码，都是无损压缩，压缩不会丢失位信息，解压可以完全恢复。</strong></p><h4 id="21-2-有损压缩技术"><a href="#21-2-有损压缩技术" class="headerlink" title="21.2 有损压缩技术"></a><strong>21.2</strong> 有损压缩技术</h4><p>但有时候，丢失一些数据也可以，因为人们可能看不出。大多数<strong>有损压缩技术</strong>，都用到了这点。</p><h5 id="21-2-1-感知编码"><a href="#21-2-1-感知编码" class="headerlink" title="21.2.1 感知编码"></a>21.2.1 感知编码</h5><p>以声音为例，<strong>我们的耳朵有一些频率的声音不能听到，比如超声波，那么录音乐的时候，超声波数据都可以扔掉，因为人类听不到超声波。</strong>另一方面，人们对人声很敏感，所以应该尽可能保持。有损音频编码就是如此，用不同精度编码不同频段。这种删掉人类无法感知的数据的方法，叫“<strong>感知编码</strong>”。</p><h5 id="21-2-2-图像与视频压缩编码"><a href="#21-2-2-图像与视频压缩编码" class="headerlink" title="21.2.2 图像与视频压缩编码"></a>21.2.2 图像与视频压缩编码</h5><ul><li><strong>图片压缩</strong></li></ul><p>最著名的有损压缩图像格式是JPEG，人的视觉也与听觉一样不完美，我们善于发现尖锐对比，比如物体边缘，然后看不出不大的颜色变化。JPEG就是利用这点，将负责的8*8像素块，变成简单的像素块，如下所示…………</p><p>（这里就不详细说了，有兴趣直接去搜JPEG图像压缩原理即可）。</p><ul><li><strong>视频压缩</strong></li></ul><p>视频也是如此，视频就是一长串的连续图片，所以很多方面，图片的技术也使用于视频。因为视频之间帧与帧之间有时变化很小，比如背景(基本会保持一段时间背景不变或变化很小)，这叫“<strong>时间冗余</strong>”，视频不用每一帧都存这些像素，可以只存变化的部分。还有的通过帧分析，用多个补丁代表物体，然后帧之间直接移动这些补丁。MP4就是一种很流行的视频压缩格式。</p><p>不过当压缩太严重时就会出错，没有足够空间更新补丁内的像素。</p><p>总而言之，压缩对大部分的数据有用，学习压缩也非常重要，因为可以高效存储图片、音乐、视频，这也帮助一些娱乐的兴起，不然宽带可能太贵。</p><h3 id="22-命令行界面"><a href="#22-命令行界面" class="headerlink" title="22 命令行界面"></a>22 命令行界面</h3><p>我们之前讨论过输入输出，但是都是计算机组件相互输入输出，比如RAM输出数据、或输指令进CPU，这节课讲用户如何输入和获得数据。我们有设备用于显示信息，如今有个专门的学科叫“人机交互”。</p><h4 id="22-1-早期的输入方式——齿轮旋钮开关、纸带"><a href="#22-1-早期的输入方式——齿轮旋钮开关、纸带" class="headerlink" title="22.1 早期的输入方式——齿轮旋钮开关、纸带"></a>22.1 早期的输入方式——齿轮旋钮开关、纸带</h4><p>早期机械计算设备，用齿轮、旋钮和开关等机械结构来输入输出。这些就是交互界面，甚至一些早期电子计算机，也是用一大堆机械面板和线来操作。其输出是打印在纸上。</p><p><img src="https://pic.imgdb.cn/item/66a97e77d9c307b7e9a96d25.png" alt="利用机械齿轮进行输入" style="zoom:30%"></p><p>然而，到1950年代，机械输入完全消失，因为出现了打孔纸卡和磁带，但输出依然是打印在纸上。当时的计算机输入，<strong>是以计算机为照顾对象输入的</strong>（尽可能迁就机器，对人类好不好用是其次），因为纸带方便计算机读取信息，但是不适合人类了解纸带里的信息。人类输入程序和信息，但是<strong>计算机不会交互式地回应</strong>。程序开始运行后会一直进行，直到结束。 </p><h4 id="22-2-输入设备——键盘"><a href="#22-2-输入设备——键盘" class="headerlink" title="22.2 输入设备——键盘"></a>22.2 输入设备——键盘</h4><p>这种情况一直持续到1950年代末，一方面小型计算机变得足够便宜，另一方面计算机变得更快，能同时支持多个程序和用户，这叫“<strong>多任务”和“分时系统</strong>”。计算机需要人类的数据输入，这时有了键盘。由于“QWERTY”型<strong>打字机</strong>已经流行于市面上了，所以键盘也是“QWERTY”型的。</p><p>打字机的流行过程也比较曲折。打字机的发明者刚开始没想到会流行于市场，只不过由于十指打字的出现，才使得打字机开始流行。这种打字方式比一个手指快很多，之后还有人学会了盲打。</p><p>不过计算机如何使用打字机呢？早期的计算机使用了一种特殊打字机，是专门用于发电报的，叫电传打字机。利用电传打字机，一方的人打的字，可以在另一方显示，使得两个人可以长距离通信。</p><p><img src="https://pic.imgdb.cn/item/66a980ead9c307b7e9ab24d7.png" alt="电传通信" style="zoom:30%"></p><p>因为电传打字机有电子接口，稍作修改就能用于计算机。电传交互界面在 1960~1970 很常见。</p><p>用起来很简单，利用键盘，输入一个命令，然后按回车，计算机就会输出回来，用户和计算机来回“对话”这叫“<strong><font color=red>命令行界面</font></strong>”。比如，输入ls，计算机就会列出所有文件到打印机上。这就是早期的交互界面。</p><p><img src="https://pic.imgdb.cn/item/66a98369d9c307b7e9acc4db.png" alt="ls命令" style="zoom:40%"></p><p>它是最主要的人机交互方式，一直到 1980 年代。</p><h4 id="22-3-显示设备——屏幕"><a href="#22-3-显示设备——屏幕" class="headerlink" title="22.3 显示设备——屏幕"></a>22.3 显示设备——屏幕</h4><p>随着电视剧开始量产，同时处理器和内存也在发展，到1970年代屏幕代替电传打字机进行交互变得可行。但与其为屏幕专门做全新的标准，工程师直接用现有的电传打字机协议，这样<u>屏幕就像无限长的纸</u>，除了输入输出文字，没有其他东西，协议是一样的，所以计算机分不出是纸张还是电子屏幕（也就相当于用电子屏幕<strong>虚拟</strong>实际的电传打字机纸张）；而输入数据依然使用的是键盘。这些包括了屏幕的“虚拟电传打字机”，叫“<strong><font color=blue>终端(Terminal)</font></strong>”。</p><p><img src="https://pic.imgdb.cn/item/66a98553d9c307b7e9ae0722.png" alt="配备“屏幕”和“键盘”的计算机" style="zoom:30%"></p><p>到1970年代末，屏幕成了计算机的标配。那时候，还发明了文字交互游戏，如“zork”。</p><p>现在，我们计算机中还有命令行交互界面，比如windows系统中的CMD命令行界面就是如此，可见<strong>早期计算机对我们现在的计算机运行方式影响巨大</strong>。</p><p>命令行界面虽然简单但十分强大，由于编程大部分是打字活，所以程序员们使用命令行也比较自然，因此，即使是现在大多数程序员工作中依然用命令行界面。而且<strong><font color=orange>用命令行访问远程计算机，是最常见的方式</font></strong>，比如服务器在另一个国家。</p><h3 id="23-屏幕和2D图形显示"><a href="#23-屏幕和2D图形显示" class="headerlink" title="23 屏幕和2D图形显示"></a>23 屏幕和2D图形显示</h3><h4 id="23-1-早期的图形屏幕"><a href="#23-1-早期的图形屏幕" class="headerlink" title="23.1 早期的图形屏幕"></a>23.1 早期的图形屏幕</h4><p>早期文本任务与图形任务是分开的，早期的屏幕无法清晰地显示图像，还不如将其打印的纸上。<strong>早期屏幕的典型用途，是跟踪程序的运行情况，比如寄存器的值</strong>。因为屏幕更新很快，这对临时值显示简直完美。但是屏幕很少用于显示结果，结果值还是主要用纸打印出来。</p><p>这台 1960 年的 PDP-1是一个早期图形计算机的好例子。</p><p><img src="https://pic.imgdb.cn/item/66a98b22d9c307b7e9b1e5bf.png" alt="显示屏幕和打字机分开" style="zoom:30%"></p><p>图中三个组件是分开的，因为当时文本任务和图像任务是相互分离的。事实上，早期的屏幕性能太差无法清晰地显示文字，而打印到纸上有更高地对比度和分辨率。早期屏幕的典型用途是跟踪程序的运行情况，例如：寄存器的值。</p><h4 id="23-2-CRT显示技术"><a href="#23-2-CRT显示技术" class="headerlink" title="23.2 CRT显示技术"></a>23.2 CRT显示技术</h4><p>最早最有影响力的显示技术是<strong>阴极射线管（CRT）</strong>，原理是把电子发射到有磷光体涂层的屏幕上，当电子撞击涂层时，会发光几分之一秒，由于电子是带电粒子，路径可以用磁场控制，屏幕内用板子或线圈，把电子引导到想要的位置上。</p><p>这样，就有两种方法绘制图形：</p><ul><li>1.<strong>引导电子束描绘出形状，这叫矢量扫描</strong>，如果重复地够快就可以显示出现图形；</li><li>2.按照固定路径，<strong>一行行来，从上到下，从左到右</strong>，不断重复，只在特定路径扫描，叫“光栅扫描”。</li></ul><h4 id="23-3-像素"><a href="#23-3-像素" class="headerlink" title="23.3 像素"></a>23.3 像素</h4><p>随着技术发展，我们终于可以<strong>在屏幕上显示清晰的点，叫“像素”</strong>。</p><p>液晶显示技术（LCD）和以前的技术相当不同，但LCD也用光栅扫描，每秒更新多次像素里红绿蓝的颜色。</p><p><img src="https://pic.imgdb.cn/item/66a993fdd9c307b7e9b931a9.png" alt="液晶（LCD）像素显示" style="zoom:30%"></p><h4 id="23-4-符号显示"><a href="#23-4-符号显示" class="headerlink" title="23.4 符号显示"></a>23.4 符号显示</h4><p>不过，早期计算机显示不用像素，因为就算二值400×400的显示，也有16万bits，这已经超过了电脑当时最大存储空间。所以早期电脑是<strong>存符号</strong>，80×25个符号最典型，每个符号用8位ASCII码表示，也才16000bits，这样才合理。</p><p><img src="https://pic.imgdb.cn/item/66a99512d9c307b7e9b9e55b.png" alt="存储的符号" style="zoom:20%"></p><p>这样计算机需要额外的硬件从内存读取符号，转换成光栅图像，才能显示图像。<strong><font color=red>这个硬件叫“符号生成器”，基本上算是第一代显卡</font></strong>。它内部只要一小块<strong>只读存储器(ROM)</strong>，存着每个字符的图形，叫“点阵图案”。如果图形卡看到一个 8位二进制，发现是字母 K，那么会把字母 K 的点阵图案光栅扫描显示到屏幕的适当位置。为了显示，“字符生成器”会访问内存中的一块特殊区域，这块区域专为图形保留，叫屏幕缓冲区。程序想显示文字时，修改这快区域的值就行。</p><p>但是字符集实在太小了，不能显示很多东西。因此对ASCII进行了各种扩展，加新字符。此外，还可以改变背景颜色。</p><h4 id="23-5-矢量扫描法"><a href="#23-5-矢量扫描法" class="headerlink" title="23.5 矢量扫描法"></a>23.5 矢量扫描法</h4><p>但是，上面这种方法不能绘制任意图案。科学家想到了<strong>“矢量扫描法”，若要显示文字，就用线条画出来，而不是存一个像素矩阵那样占用大量内存</strong>。这个方法用命令来画线段，因为可以不断改变命令，所以这图案甚至可以是动态的。</p><p><img src="https://pic.imgdb.cn/item/66a99783d9c307b7e9bba995.png" alt="利用画线条显示图形" style="zoom:30%"></p><h4 id="23-6-Sketchpad"><a href="#23-6-Sketchpad" class="headerlink" title="23.6 Sketchpad"></a>23.6 Sketchpad</h4><p>1962是一个大里程碑，<strong>Sketchpad</strong>诞生，<strong>一个交互式图形界面，用途是计算机辅助设计（CAD）</strong>。用户可以用光笔，进行画图，程序里面还自带了许多元件，帮助进行设计图案。这个发明有巨大意义，它们代表了人机交互的关键转折点。</p><h4 id="23-7-像素与位图显示"><a href="#23-7-像素与位图显示" class="headerlink" title="23.7 像素与位图显示"></a>23.7 像素与位图显示</h4><p>1960年代末，计算机存储技术的发展，可以利用像素矩阵来表示图形。<strong>计算机把像素数据存在一个特殊区域，叫“帧缓冲区”</strong></p><p>位图显示（BMP）的灵活性，为交互式开启了全新可能，但它的高昂成本持续了十几年。所幸的是，<strong>Sketchpad</strong>等的诞生为图形化交互界面的发展做出了巨大贡献。</p><h3 id="24-冷战和消费主义"><a href="#24-冷战和消费主义" class="headerlink" title="24 冷战和消费主义"></a>24 冷战和消费主义</h3><p>之前讲了很多计算机的知识，比如编译器、语言、操作系统、算法和存储等等，这些全部在1940-70年代出现。本节课注意讲一下这个时代的历史，更好地帮我我们理解计算机和计算机的发展。</p><h4 id="24-1-二战后的科技发展"><a href="#24-1-二战后的科技发展" class="headerlink" title="24.1 二战后的科技发展"></a>24.1 二战后的科技发展</h4><p>二战之后，两个超级大国关系越来越紧张，美国和苏联出现了冷战。这时期，国家花了大量资金在科学与工程学上，计算机技术发展迅速。</p><p>当时发明的计算机，大部分应用于政府和国家，因为只有国家能够承担巨额经费用于计算。计算机和以前的机器不同，以前的机器如蒸汽机和纺织机等等，他们增强了人民的物理能力，而<u>计算机增强的是人类智力</u>。</p><h4 id="24-2-Memax假想计算机"><a href="#24-2-Memax假想计算机" class="headerlink" title="24.2 Memax假想计算机"></a>24.2 Memax假想计算机</h4><p><strong>Memex是一台假想的计算机设备</strong>，由范内瓦·布什发表。Memax可以存储数据，帮助人信息交流。他还预测未来会出现一种新的百科全书，信息之间相互连接（维基百科）。Memax的出现，促进了人民对计算机的未来的思考。</p><p>在范内瓦·布什建议下，美国建立了国家科学基金会，负责给科学研究提供政府资金，美国的科技领先全球，主要原因就是这个机构。</p><h4 id="24-3-日本的收音机崭露头角"><a href="#24-3-日本的收音机崭露头角" class="headerlink" title="24.3 日本的收音机崭露头角"></a>24.3 日本的收音机崭露头角</h4><p>1950年代，消费者开始买晶体管设备，其中值得注意的是收音机。他小而便携，受到大家欢迎。</p><p>日本也想从二战后恢复，他们从贝尔实验室获得了晶体管的授权，帮助振兴日本的半导体和电子行业。1955年，索尼的收音机问世，他们把重心放在质量和价格上。因此，短短5年内，日本公司就占领了美国收音机市场的一半。</p><p><img src="https://pic.imgdb.cn/item/66a99bced9c307b7e9bfa1ac.png" alt="索尼第一台收音机——TR-55" style="zoom:40%"></p><p>苏联此时在计算机方面的计算落后西方几年，但是苏联的太空技术远超他国。</p><h4 id="24-4-太空计划促进集成电路发展"><a href="#24-4-太空计划促进集成电路发展" class="headerlink" title="24.4 太空计划促进集成电路发展"></a>24.4 太空计划促进集成电路发展</h4><p>苏联在1957年把第一个卫星送上轨道，1961年把人类送上了太空。所以，美国为了追赶苏联，开始了登月计划。美国花了大量的资金用于资助太空计划。</p><p>太空计划一个重要的问题是，如何给太空船导航，这需要电脑计算复杂度轨道。太空电脑需要小、快、可靠，所以NASA采用全新工艺，集成电路。太空计划的阿波罗导航计算机，首先使用了集成电路。太空计划，促进了世界计算机工艺发展。</p><h4 id="24-5-消费级电子发展"><a href="#24-5-消费级电子发展" class="headerlink" title="24.5 消费级电子发展"></a>24.5 消费级电子发展</h4><p>其实，对集成电路发展更促进的是军事，特别是洲际导弹和核弹。超级计算机，就是用于服务美国的政府机构。</p><p>最初，美国的半导体行业靠着高利润和政府合作起步，消费市场被忽略了。日本此时抓住机会，大力发展消费级电子设备，提升质量和工作效率。1970年代，太空竞赛和军事渐渐减少，美国半导体企业发现无法在消费领域竞争过日本，因为日本的产品更便宜和质量更高。这时很多美国公司倒闭，英特尔和仙童半导体都面临巨大危机。</p><p>美国公司的无力，造就了日本如卡西欧、索尼等快速发展，比如手持计算机等。很快，日本产品开始大量占领市场，计算器、手表等等。这些促进了微处理器的发展。同时，街机游戏也因此发展。70年代，家用计算机和游戏机出现。</p><h4 id="24-6-结语"><a href="#24-6-结语" class="headerlink" title="24.6 结语"></a>24.6 结语</h4><p>从大到人类可以随意行走，到手持电子设备，这种巨大的变化由两种力量推动，政府和消费者。政府资金促进了早期发展，消费者促进了行业持续发展。政府和消费者对科技的促进，这种关系直到现在依然存在。</p><h3 id="25-个人计算机革命"><a href="#25-个人计算机革命" class="headerlink" title="25 个人计算机革命"></a>25 个人计算机革命</h3><h4 id="25-1-为什么个人计算机时代能到来"><a href="#25-1-为什么个人计算机时代能到来" class="headerlink" title="25.1 为什么个人计算机时代能到来"></a>25.1 为什么个人计算机时代能到来</h4><p>随着集成技术和CPU的发展，把整台计算机做到一张电路板上成为可能，大大降低了制造成本。并且，那时有便宜可靠的存储介质，比如磁带和软盘。还有低成本的显示器，通常是电视剧稍作改装而成。这时候做成的计算机叫“微型处理器”，并且计算机的成本也不断降低，这使得一个人的计算机成为可能。个人计算机时代到来。</p><p><img src="https://pic.imgdb.cn/item/66a99f46d9c307b7e9c22284.png" alt="电视机改装的显示器" style="zoom:20%"></p><p>综上，计算机成本下降+性能提升，让个人计算机成为可能。</p><h4 id="25-2-商业计算机与Basic语言"><a href="#25-2-商业计算机与Basic语言" class="headerlink" title="25.2 商业计算机与Basic语言"></a>25.2 商业计算机与Basic语言</h4><p>1975年出现了第一台可以说是商业计算机。这台计算机需要自己购买配备组件，所以组件买卖在这时候兴起。</p><p><img src="https://pic.imgdb.cn/item/66a99fedd9c307b7e9c2a137.png" alt="计算机组件（键盘、打印机等）" style="zoom:30%"></p><p>更困难的是，计算机的编程语言依然是机器语言，这对大部分人来说都是非常困难的。比尔盖茨和他的同伴，开发了能运行<strong>basic语言</strong>，为此，他们需要一个机器，把Basic语言转换为机器语言，这叫“<strong>解释器</strong>”。</p><blockquote><p>“解释器”和”编译器”类似，区别是”解释器”在程序运行的同时转换编码，而””编译器”提前转换好整个程序文件的编码，然后一次性整体运行。</p></blockquote><p>这时，乔布斯开始出售原型机，用户需要自己加键盘、电源和机箱，这叫Apple1，苹果计算机公司的第一个产品。</p><h4 id="25-3-整体机的出现"><a href="#25-3-整体机的出现" class="headerlink" title="25.3 整体机的出现"></a>25.3 整体机的出现</h4><p>不过此时的电脑是要自己组配各个组件的，不过后来出现了整体机，如Apple2。这种集成了电脑、键盘和屏幕的全套整体计算机，吸引了大量的人购买。</p><p><img src="https://pic.imgdb.cn/item/66a9a1e9d9c307b7e9c41e2e.png" alt="整体机计算机" style="zoom:20%"></p><p>Apple2以及当时出现的其他整体计算机，配备了basic语言，用户可以利用此编写自己的程序。同时，各种各样的软件开始发展。这次计算机革命，最重要的是他们是面向普通消费者的，而不是政府和企业。</p><h4 id="25-4-IBM兼容框架"><a href="#25-4-IBM兼容框架" class="headerlink" title="25.4 IBM兼容框架"></a>25.4 IBM兼容框架</h4><p>IBM公司为了抓住市场，也开发了自己的计算机，这台计算机最与众不同的是，它可以添加其他外设设备，比如显卡、声卡和游戏控制杆等等。这种开发架构叫“<strong>IBM兼容</strong>”。大量公司开始使用IBM兼容，IBM兼容体系的计算机越来越多。不使用IBM兼容的计算机大部分都失败了，除了苹果公司。</p><h4 id="25-5-苹果公司——封闭框架"><a href="#25-5-苹果公司——封闭框架" class="headerlink" title="25.5 苹果公司——封闭框架"></a>25.5 苹果公司——封闭框架</h4><p>苹果公司最终选择了相反方式，“<strong>封闭架构</strong>”，用户无法加新设备到计算机中。苹果的封闭框架可以使他们做出来的产品更加照顾用户的体验感。</p><p><img src="https://pic.imgdb.cn/item/66a9a38dd9c307b7e9c58057.png" alt="具有重要意义的苹果计算机产品——Macintosh" style="zoom:30%"></p><p>为了和IBM兼容体系的计算机对抗，苹果公司需要非常具有体验感的产品出现。他们的答案是<strong>Macintosh</strong>，于1984年发布，一台突破性且价格适中的一体式计算机，用的不是命令行界面，而是图形界面。</p><h3 id="26-图形用户界面GUI"><a href="#26-图形用户界面GUI" class="headerlink" title="26 图形用户界面GUI"></a>26 图形用户界面GUI</h3><h4 id="26-1-图形用户界面GUI"><a href="#26-1-图形用户界面GUI" class="headerlink" title="26.1 图形用户界面GUI"></a>26.1 图形用户界面GUI</h4><p>上集我们说，苹果在1984年发布的Macintosh，是普通人可以买到的第一台图形用户界面的计算机，还带一个鼠标。<strong>那时的计算机全是命令行的，图形界面是个革命性的进展</strong>。</p><p>我们不需要记住指令，只需要在屏幕上点击即可完成想要的功能，计算机突然变直观了，不仅仅是计算机科学家，普通人也能用计算机。这就是图形用户界面GUI。</p><p>人们认为是Macintosh把图形用户界面（GUI）变成主流，但实际上图形界面是几十年努力的结果。</p><h4 id="26-2-恩格尔巴特"><a href="#26-2-恩格尔巴特" class="headerlink" title="26.2 恩格尔巴特"></a>26.2 恩格尔巴特</h4><p>恩格尔巴特设计了一个现代化的计算机，包括图形界面、鼠标等等。1968年，恩格尔巴特演示了这台计算机，它可以进行视频通话、多人文档操作和多窗口等等。</p><p><img src="https://pic.imgdb.cn/item/66a9a4a3d9c307b7e9c66365.png" alt="恩格尔巴特制作的计算机可视频通话" style="zoom:30%"></p><p>不过由于这种设计太过超前了，最终还是失败了。但是他对于计算机科学家思维上的启发却是实在的，恩格尔巴特因此于1997年获得图灵奖。</p><h4 id="26-3-施乐奥托与WIMP桌面"><a href="#26-3-施乐奥托与WIMP桌面" class="headerlink" title="26.3 施乐奥托与WIMP桌面"></a>26.3 施乐奥托与WIMP桌面</h4><p>第一台真正带GUI的计算机是施乐奥托，于1973年完成。施乐计算机将2D屏幕当作“桌面”，用户可以打开多个程序，<strong>每个程序都在一个框里，叫“<font color=blue>窗口</font>”</strong>。窗口可以重叠，挡住后面的东西。还有桌面组件，比如计算器和时钟。这台计算机的发明者用窗口、图标、菜单和指针来设计界面，因此叫WIMP桌面。</p><p>施乐奥托团队大约制造了2000台，有的在施乐公司内部使用，有的给大学实验室，从来没有商业出售过。施乐卖的是印刷机，但在文本和图形制造工具领域也有领先。例如，他们首先使用了“剪切”“复制”“粘贴”这样的术语。施乐公司后来开发的“施乐之星系统”，不过依然过于超前并且价格昂贵，而没有流行。</p><h4 id="26-4-苹果和微软"><a href="#26-4-苹果和微软" class="headerlink" title="26.4 苹果和微软"></a>26.4 苹果和微软</h4><p>苹果公司的乔布斯看到了施乐团队作品的闪光之处，于是和施乐团队合作。苹果公司先后发布了Apple Lisa和<strong>Macintosh</strong>（1980年代），前者由于太贵没有太多人购买，后者在市场上火爆，可以说是<strong>第一台商业图形用户界面的计算机</strong>。</p><p>不幸的是，苹果公司的产品虽然大受欢迎，但是因为没有人在苹果电脑上制作软件，所以销量逐渐下来了。乔布斯与苹果公司股东关系愈发紧张，不久被苹果公司赶了出来。</p><p>在这期间，微软公司的Windows1.0出现了，并且站稳了市场，十年内，95%的个人计算机都有微软的Windows。刚开始的Windows系统还不像苹果一样有GUI，不过后来微软开发了面向消费者的GUI操作系统——<strong>Windows95</strong>，Windows95系统有许多至今还在用的设计，比如开始菜单、任务栏和Windows文件管理器。</p><p><img src="https://pic.imgdb.cn/item/66a9a7f8d9c307b7e9c89c25.png" alt="Windows95系统" style="zoom:30%"></p><p><mark>现在的系统，无论是Windows、Linux还是Mac，都是施乐奥托WIMP的变化版本</mark>。未来，计算机科学家和界面设计师会设计更强大的GUI。 </p><h3 id="27-3D图形"><a href="#27-3D图形" class="headerlink" title="27 3D图形"></a>27 3D图形</h3><p>之前讲的图形界面都是二维的，但我们生活的世界是3维的，本节课我们讲三维图形。</p><h4 id="27-1-图像投影"><a href="#27-1-图像投影" class="headerlink" title="27.1 图像投影"></a>27.1 图像投影</h4><p>三维空间用到的是三维坐标，但是计算机无法表示三维坐标，所以要将三维图形投影到二维上来。三维投影有很多，比如<strong>正交投影、透视投射</strong>。</p><p><img src="https://pic.imgdb.cn/item/66a9aa81d9c307b7e9cb54c6.png" alt="正交和透视投影"></p><blockquote><p>PS：透视投影可以类比现实生活中看马路会交于一点的情景。</p></blockquote><p>如果想画立方体这种简单的几何图形，直线就够了；但更复杂的图形，三角形更好，如下图所示。在3D图形学中<br>我们称三角形为“多边形”(Polygons)，一堆多边形的集合叫 网格。网格越密，表面越光滑，细节越多，但意味着更多计算量。</p><p><img src="https://pic.imgdb.cn/item/66a9ab9fd9c307b7e9cc244d.png"></p><blockquote><p>PS：为什么使用三角形：是因为空间3个点可以确定唯一一个平面，具体请参考本节视频内容。</p></blockquote><p>设计三维图形时，设计师要考虑细节的程度，如果过于复杂的细节的图形（三角形过多），就会导致帧率下降，画面卡顿。</p><h4 id="27-2-图像填充"><a href="#27-2-图像填充" class="headerlink" title="27.2 图像填充"></a>27.2 图像填充</h4><p>填充图形的经典算法叫<strong>扫描线渲染</strong>，就是通过一条线的交点来进行图形填充，当然这样可能导致边缘不精细，边缘出现锯齿形状。一种减轻锯齿的方法叫<strong>抗锯齿</strong>。<strong>也就是如果在三角形内部的方块，直接填充，在交线处，虚化填充。</strong>抗锯齿在计算机文字和图标中大量使用。</p><p><img src="https://pic.imgdb.cn/item/66a9adffd9c307b7e9cdf47f.png" alt="抗锯齿原理和例子" style="zoom:50%"></p><p>图像里面不同的物体有的会<strong>遮挡</strong>，这很常见。要渲染图片时，类似排序算法，计算机根据由远到近一次渲染覆盖，这叫“<strong><u>画家算法</u></strong>”，因为画家也是先画背景，然后再画更贴近的东西。</p><p>此外，还有<strong><u>深度缓存算法</u></strong>，就是根据距离一步步地加载最小的数字到对应的格子中。最后得到的图形，既有哪里需要填充图块，也有哪种颜色是最终需要填充的。</p><p><img src="https://pic.imgdb.cn/item/66a9af7ed9c307b7e9cf0bcd.png" alt="深度缓存算法" style="zoom:70%"></p><p>3D游戏里面有个优化叫<strong>背景剔除</strong>，也就是三角形的两面，游戏只加载玩家能看到的那一面，另一面不加载，这样若穿到另一面，容易产生透视BUG。比如穿越火线里面的卡BUG进行透视就是这样的。 </p><p><img src="https://pic.imgdb.cn/item/66a9b02ad9c307b7e9cfa640.png" alt="背景透视BUG" style="zoom:70%"></p><h4 id="27-3-明暗处理"><a href="#27-3-明暗处理" class="headerlink" title="27.3 明暗处理"></a>27.3 明暗处理</h4><p>我们讲灯光，也叫<strong>明暗处理</strong>。我们将图像，经过平面着色，也就是根据光源，给不同的部分设置不同程度的阴影，达到三维的目的。</p><p><img src="https://pic.imgdb.cn/item/66a9b16ed9c307b7e9d0894c.png" style="zoom:70%"></p><p>此外，还有<strong>高洛德着色和冯氏着色法</strong>，帮助形成更好的三维图像。</p><p><img src="https://pic.imgdb.cn/item/66a9b1a8d9c307b7e9d0b103.png" alt="高洛德着色" style="zoom:70%"></p><h4 id="27-4-纹理与图像处理单元"><a href="#27-4-纹理与图像处理单元" class="headerlink" title="27.4 纹理与图像处理单元"></a>27.4 纹理与图像处理单元</h4><p>此外，图像的纹理也有多种算法，最简单的是<strong>纹理映射。</strong>以上这些图像算法，我们可以通过硬件加速得到更快的运算。此外，可以将图像分块，然后多块并行渲染。CPU不是为此设计的，因此图形运算不快，所以计算机工程师为图形做了专门的处理器——<strong>GPU“图形处理单元”</strong>，就是专门用于图形渲染和处理的。GPU在显卡上，周围有专用的RAM(显存)，所有网格和纹理都在里面，让 GPU 的多个核心可以高速访问。现代显卡，如 GeForce GTX 1080 TI有3584个处理核心，提供大规模并行处理，每秒处理上亿个多边形！</p><p><img src="https://pic.imgdb.cn/item/66a9b28dd9c307b7e9d15efb.png" alt="英伟达GPU" style="zoom:70%"></p><h3 id="28-计算机网络"><a href="#28-计算机网络" class="headerlink" title="28 计算机网络"></a>28 计算机网络</h3><p>早期的计算机和网络是分开的，不过随着时间发展，第一个计算机网络出现了。计算机网络的发展，帮助人们有了更快的信息交互方式，极大地改变了人们的生活，这节课我们就来讲计算机网络的发展。</p><p>第一个计算机网络出现在1950-60年代，通常在公司或研究室内部使用，为了方便信息交互，这叫“<strong>球鞋网络</strong>”。第二个好处是能共享物理资源，比如与其用多台打印机，不如用一台联网的打印机。<strong><mark>计算机近距离构成的小型网络，叫局域网，简称LAN</mark></strong>。局域网能小到是同一个房间里的两台机器或大到校园里的上千台机器。</p><p>尽管开发和部署了很多不同 LAN 技术，其中最著名的局域网是“<strong>以太网</strong>”，开发于1970年代，至今仍被使用。以太网是这样设计的，将要组成网络的计算机用电缆相互连接，如果一台计算机想要发送数据时，就将数据以电信号形式传到电缆，以太网链路上任何一台计算机都可以看见数据。</p><p><img src="https://pic.imgdb.cn/item/66a9ba0ed9c307b7e9d79eec.png" style="zoom:30%"></p><p>为了解决定向问题，以太网需要为每台计算机设置唯一的媒体访问控制地址，简称<strong>MAC地址</strong>。这个数据放在数据头部作为数据的前缀发送到网络中，所以，计算机只需要监听以太网电缆只有看到自己的 MAC 地址，才处理数据。这运作得很好，现在制造的每合计算机都自带唯一的MAC地址用于以太网和无线网。</p><p>多台电脑共享一个传输媒介，这种方法叫“<strong>载波侦听多路访问</strong>”，简称CSMA。载体指运输数据的共享媒介，以太网数据传输的载体是铜线，WiFi的载体是无线空间。很多计算机同时侦听载体，所以叫“侦听”和“多路访问”。载体传输数据的速度叫<strong>“<font color=red>带宽</font>”</strong>。</p><p>不过问题是，在同一链路上传输，可能会出现同时发送的情况，造成数据冲突。最明显的解决办法是停止传输，然后等待后再传输。但是这个有一个问题，就是如果冲突过多的话，就会产生麻烦。以太网有个简单有效的解决办法，就是在同一个等待时间下加一个随机时间。此外，还有<strong>指数退避法</strong>，就是当再次检测到冲突的话，就等待原来的双倍的时间。以太网和WiFi都用这种方法，很多其他传输协议也用。</p><p>此外，用同一根网线链接整个区域的计算机还是不可能的，我们需要减少同一载体中设备的数量，载体和其中的设备总称“冲突域”。为了减少冲突 我们可以用<strong>交换机(Switch)</strong>把它拆成两个冲突域：</p><p><img src="https://pic.imgdb.cn/item/66a9bc99d9c307b7e9d979ee.png" style="zoom:30%"></p><p>交换机位于两个更小的网络之间，必要时才在两个网络间传数据。交换机会记录一个列表写着哪个 MAC 地址在哪边网络。大型网络(包括最大的互联网)的底层也是类似的原理。</p><p><img src="https://pic.imgdb.cn/item/66a9bd91d9c307b7e9da2ba9.png" style="zoom:30%"></p><p>这些大型网络有趣之处是：从一个地点到另一个地点通常有多条路线。这就带出了另一个话题——<strong>路由</strong>。连接两合相隔遥远的计算机或网路，最简单的办法是分配一条专用的通信线路（早期电话系统就是这样运作的），这叫”<strong><mark>电路交换</mark></strong>”，因为是把电路连接到正确目的地，能用倒是能用，但不灵活而且价格昂贵，因为总有闲置的线路，好处是如果有一条专属于自己的线路你可以最大限度地随意使用，无需共享。因此军队，银行和其他一些机构，依然会购买专用线路来连接数据中心。</p><blockquote><p>交换机是连接若干个主机的机器，用来解决冲突域问题。</p><p>路由器是连接主机、路由器或交换机的机器，用来构建数据传输的线路。 </p></blockquote><p>传输数据的另一个方法是“<strong><mark>报文交换</mark></strong>”。“报文交换”就像邮政系统一样，不像之前A和B有一条专有线路，消息会经过好几个站点，如下图所示：</p><p><img src="https://pic.imgdb.cn/item/66a9bf73d9c307b7e9db936e.png" style="zoom:40%"></p><p>每个站点都知道下一站发哪里因为站点有表格，记录到各个目的地，信件该怎么传。报文交换的好处是：可以用不同路由使通信更可靠更能容错，对于上面的例子，若<code>HOP2</code>站点被破坏了，由图容易知道还有很多其他路线可走。在这个例子中，各个<code>城市HOP</code>就像路由器一样，消息沿着路由跳转的次数叫做“跳数”。记录跳数很有用，因为可以分辨出路由问题，如果看到某条消息的跳数很高就知道路由肯定哪里错——这被称为“<strong>跳数限制</strong>”。</p><p>报文交换的缺点之一是有时候报文比较大会堵塞网络，因为要把整个报文从一站传到下一站后才能继续传递其他报文。传输一个大文件时，整条路都阻塞了，导致即便你只有一个1KB的电子邮件要传输，也只能等大文件传完，或是选另一条效率稍低的路线。解决方法是 将大报文分成很多小块，叫”<strong>数据包</strong>“。就像报文交换，每个数据包都有目标地址，因此路由器知道发到哪里。<strong><font color=red>报文具体格式由”互联网协议”定义，简称IP</font></strong>，这个标准创建于 1970 年代。每台联网的计算机都需要一个IP地址。数百万台计算机在网络上不断交换数据，瓶颈的出现和消失是毫秒级的，路由器会平衡与其他路由器之间的负载，以确保传输可以快速可靠，这叫”<strong>阻塞控制</strong>“。</p><p>有时，同一个报文的多个数据包会经过不同线路，到达顺序可能会不一样，这对一些软件是个问题。幸运的是，在IP 之上还有其他协议，例如：TCP/IP可以解决乱序问题。</p><p>将数据拆分成多个小数据包，然后通过灵活的路由传递，非常高效且可容错，如今互联网就是这么运行的，这叫<strong>”分组交换“</strong>。有个好处是：它是去中心化的，没有中心杈威机构，没有单点失败问题。</p><p>如今，全球的路由器协同工作，找出最高效的线路，用各种标准协议运输数据，比如“因特网控制消息协议(ICMP)”和”边界网关协议(BGP)“。世界上第一个分组交换网络以及现代互联网的祖先是ARPANET。</p><p><img src="https://pic.imgdb.cn/item/66a9c522d9c307b7e9e134eb.png" alt="ARPANET" style="zoom:50%"></p><h3 id="29-互联网"><a href="#29-互联网" class="headerlink" title="29 互联网"></a>29 互联网</h3><p>任意计算机都和一个巨大的分布式网络连接在一起，称为<strong>互联网（Internet）</strong>。</p><h4 id="29-1-数据在互联网上的传输过程"><a href="#29-1-数据在互联网上的传输过程" class="headerlink" title="29.1 数据在互联网上的传输过程"></a>29.1 数据在互联网上的传输过程</h4><p>当你在家中通过计算机观看网上视频时，你的计算机首先需要连接到局域网LAN，这个局域网是由家里WiFi路由器连接的所有设备组成的。然后家里的局域网再通过路由器连接到<strong>广域网（Wide Area Network，WAN</strong>），广域网的路由器一般属于你的<strong>互联网服务提供商（Internet Service Provider，ISP）</strong>。在广域网里，首先会有一个区域性路由器，比如覆盖你所在街区的一个路由器，然后该路由器会连接到一个更大的广域网中，比如覆盖你所在的城市，可能再跳跃几次，最终会到达互联网主干，一般由一群超大型、带宽超高的路由器组成。</p><blockquote><p>即首先会连接到你家里的WiFi路由器构建的局域网，然后该路由器再连接到ISP提供的广域网中，该广域网是由很多层层递进的路由器构成的。</p><p>比如要从YouTube中获得视频，数据包首先会到达互联网主干，沿着主干到达对应保存该视频文件的YouTube服务器，可能这里会跳4次到达互联网主干，然后跳两次穿过互联网主干，最终再跳4次到达YouTube服务器，所以总共会跳跃10次。</p></blockquote><p> 我们可以通过<code>traceroute</code>来看跳跃了几次： </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Windows上的Traceroute</span><br><span class="line">1.按开始按钮</span><br><span class="line">2.输入“ CMD”，然后按“ Enter”</span><br><span class="line">3.在命令提示符下，键入“ tracert dftba.com”</span><br><span class="line"></span><br><span class="line">在Mac上的Traceroute</span><br><span class="line">1.点击“转到”下拉菜单</span><br><span class="line">2.点击“实用程序”</span><br><span class="line">3.打开终端</span><br><span class="line">4.键入“ traceroute dftba.com”</span><br><span class="line"></span><br><span class="line">Linux上的Traceroute</span><br><span class="line">1.通过键入CTRL + Alt + T打开终端</span><br><span class="line">2.输入：“ traceroute dftba.com”</span><br></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/66a9de34d9c307b7e9f7f21a.png" alt="在印第安访问加州的DFTBA服务器，经历11次中转"></p><p>但是数据包到底是怎么传递过去的呢？如果传输时数据包丢失了，会发生什么？当我们在浏览器中输入网址时，浏览器怎么知道服务器的地址是什么呢？ </p><p>就像上节介绍的，互联网是一个巨大<strong>分布式网络</strong>，如果要发送的数据较大，分组传输就会将数据拆成一个个较小的数据包进行传输。其中数据包要想在互联网上进行传输，就要符合<strong>互联网协议（Internet Protocol，IP）</strong>。</p><blockquote><p>类似于邮寄手写信一般，每封信都需要一个地址，并且地址必须是唯一的，并且信的大小和重量也是有限制的，否则信件就无法送达。</p></blockquote><h4 id="29-2-用户数据报协议UDP"><a href="#29-2-用户数据报协议UDP" class="headerlink" title="29.2 用户数据报协议UDP"></a>29.2 用户数据报协议UDP</h4><p>IP数据包也是如此，因为IP是一个非常底层的协议，数据包的头部只包含目标地址（IP地址），意味着当数据包到达对方电脑时，计算机不知道要把数据包交给哪个程序（比如QQ或微信或者浏览器），因此需要在IP之上，开发更高级的协议。</p><p><img src="https://pic.imgdb.cn/item/66a9dfa0d9c307b7e9f91b97.png" style="zoom:80%"></p><p>最简单常见的协议称为用户数据报协议（User Datagram Protocol，UDP）。UDP也有头部，位于data payload里面，在data之前。UDP头部里面包含了很多有用的信息，其中之一就是<strong>端口号（Port Number）</strong>，*<u>每个想访问网络的程序都要向操作系统申请一个端口号。所以当数据包到达时，接收方的操作系统会读取UDP头部里的端口号，来确定该数据包是要交给哪个软件的</u>*。</p><blockquote><p>示例：每个想访问网络的程序，都要向操作系统申请一个端口，例如QQ会申请端口3478，当一个数据包到达时，接收方的操作系统会读 UDP 头部，读里面的端口号，如果看到端口号为3478，就把数据包交给QQ。</p></blockquote><p> 简单来说，<strong>IP协议通过IP地址把数据包送到正确的计算机内；UDP通过数据包里的端口号送到正确的程序</strong>。 </p><p><img src="https://pic.imgdb.cn/item/66a9e3aad9c307b7e9fdde9e.png" alt="image.png"></p><p>同时UDP的头部中还有<strong>校验和（Checksum）</strong>，通过对数据求和来检查数据是否正确。假设UDP数据包里原始数据是<code>89 111 33 32 58 41</code>， 最简单的计算校验和的方式就是，在发送数据包之前，计算机会把所有数据加在一起，计算出校验和364。在UDP中，校验和是以16位形式存储的，如果计算出来的和超过16位能表示的最大值，则高位数会被丢弃，只保留低位。当接收方计算机接收到这个数据包时，也会重复以上过程，如果计算出来的校验和和UDP中保存的校验和相同，代表数据是正常的，否则数据是出错的。</p><h4 id="29-3-传输控制协议（Transmission-Control-Protocol，TCP）"><a href="#29-3-传输控制协议（Transmission-Control-Protocol，TCP）" class="headerlink" title="29.3 传输控制协议（Transmission Control Protocol，TCP）"></a>29.3 传输控制协议（Transmission Control Protocol，TCP）</h4><p>但是，UDP不提供数据修复或数据重发机制，当接收方知道数据损坏后，一般只是丢弃这个数据包。并且当发送方使用UDP协议发送数据包时，是无法得知数据包是否到达目的地的。</p><p>有些程序并不在意以上问题，因为UDP十分简单且快速。比如视频通常使用UDP协议，当数据包丢失时，也就造成视频卡顿。</p><p>但是有些数据不能接受数据包丢失的问题，比如发送电子邮件时，所有数据必须到达，所以就需要<strong>传输控制协议（Transmission Control Protocol，TCP）</strong>。和UDP一样，它的头部也保存在数据之前，人们通常将IP协议和TCP协议统称为<strong>TCP/IP协议</strong>。TCP的头部中也包含端口号和校验和，并且TCP协议还提供更高级的功能(这里只简单介绍几个重要的)：</p><ol><li>TCP的数据包是有序号的<br>使得接收方可以通过这个序号将数据包排成正确顺序，即使到达时间不同。</li><li>TCP要求接收方收到数据包并校验和检查无误后，要给发送方发送一个<strong>确认码（Acknowledgement，ACK）</strong>，代表数据包已经正确接收。<br>当发送方接收到确认码后，就知道上一个数据包成功抵达了，发送方就会发送下一个数据包，如果这次发送方过了一段时间没有接收到确认码，则会重新发送一次。即使这里只是由于确认码延迟了，使得接收方那里有重复的数据包，但是通过序列号，可以直接删除重复的数据包。</li></ol><p><img src="https://pic.imgdb.cn/item/66a9e6a1d9c307b7e900760e.png" style="zoom:50%"></p><p>并且数据包并不会一个个数据包进行传输，而是<strong>同时发送多个</strong>数据包，同时接收多个确认码，这将大大提高效率，不用浪费时间等待确认码。并且通过确认码的成功率和来回时间，我们可以推测网络的拥塞程度，TCP通过这个信息，来调整同时发包数量来解决拥塞问题。 </p><p>简而言之，TCP可以处理乱序和丢包问题，并且可以根据拥塞情况自动调整传输率。但是由于确认码数据包的存在，使得TCP需要传输的数据包数量翻了一倍，并且并没有传输更多信息，这对时间要求很高的程序代价太高，所以这类程序就会使用UDP协议。</p><h4 id="29-4-域名DNS"><a href="#29-4-域名DNS" class="headerlink" title="29.4 域名DNS"></a>29.4 域名DNS</h4><p>当计算机访问一个网站时，需要两个东西：① IP地址（目标网站的地址）和 ② 端口号（对应于你使用的计算机浏览器）。</p><p>但是通过IP地址访问网站十分不方便，所以互联网提供一个特殊服务，来将<strong>域名（Domain Name）</strong>和IP地址一一对应，称为<strong>域名系统（Dimain Name System，DNS）</strong>，一般DNS服务器都是由ISP提供的。当你在浏览器中输入网站域名时，浏览器就会去访问DNS服务器，DNS就会去查表，如果域名存在，则会返回浏览器对应IP地址，然后浏览器就会给这个IP地址发送TCP请求。</p><p>因为当前域名特别多，所以DNS不会将其保存成列表形式，而是将其保存成树状结构。最顶层是<strong>顶级域名（Top Level Domain，TLD）</strong>，比如<code>.com</code>和<code>.gov</code>；下一层是<strong>二级域名（Second Level Domain）</strong>， 比如<code>google.com</code>和<code>dftba.com</code>；再下一层是<strong>子域名（Sub-domain）</strong>，比如<code>images.google.com</code>等等。由于这个树结构特别大，因此这些数据分布在很多DNS服务器上，不同服务器负责树的不同部分。</p><p><img src="https://pic.imgdb.cn/item/66a9e8b0d9c307b7e90249a2.png" alt="域名的树结构" style="zoom:80%"></p><ul><li><strong>物理层</strong>：过去两集里，我们讲了线路里的电信号，以及无线网络里的无线信号，这被称为“物理层”。</li><li><strong>数据链路层</strong>：负责操控“物理层”，数据链路层有：媒体访问控制地址(MAG)、碰撞检测、指数退避以及其他一些底层协议。</li><li><strong>网络层</strong>：负责各种报文交换和路由。</li><li><strong>传输层</strong>：负责在计算机之间进行点到点的传输，而且还会检测和修复错误；本小节的UDP和TCP协议都属于本层。</li><li><strong>会话层</strong>：会使用TCP和UDP来创建连接，传递信息，然后关掉连接。</li></ul><p>以上是<strong>开放式系统互联通信参考模型（Open System Interconnection model，OSI）</strong>下的5层，这个框架将网络通信划分成了很多层，每一层处理各自的问题。这种抽象可以使得分工改进多个层，而无需考虑整体复杂性。并且OSI还有额外两层：<strong>表示层（Presentation Layer）</strong>和<strong>应用层（Application Layer）</strong>，在下一节中进行介绍。</p><p><img src="https://pic.imgdb.cn/item/66a9eb60d9c307b7e9048afb.png" alt="开放式系统互联通信参考模型" style="zoom:70%"></p><h3 id="30-万维网"><a href="#30-万维网" class="headerlink" title="30 万维网"></a>30 万维网</h3><p>前两节深入讨论了电线 信号 交换机 数据包路由器以及协议，它们共同组成了互联网。这一节将向上抽象一层，来讨论<strong>万维网（World Wide Web）</strong>。万维网和互联网的概念完全不同，万维网是运行于互联网之上的，还有其他比如Skype、Instagram等也是运行在互联网之上的。互联网是用来传输数据的管道，各种程序都会使用到，其中传输最多数据的程序就是万维网，我们可以使用特殊的程序——<strong><font color=orange>浏览器（Web Browser）</font></strong>来访问万维网。</p><h4 id="30-1-超链接"><a href="#30-1-超链接" class="headerlink" title="30.1 超链接"></a>30.1 超链接</h4><p>万维网的最基本单位是单个页面，页面里面包含内容，也有访问其他页面的链接，这些链接称为<strong>超链接（Hyperlink）</strong>。这些超链接形成巨大的互联网络，这也是万维网名字的由来。</p><blockquote><p>现在说起来觉得很简单，但在超链接做出来之前，计算机上每次想看另一个信息时，你需要在文件系统中找到它或是把地址输入搜索框，有了超链接，你可以在相关主题间轻松切换。</p></blockquote><p>并且由于文字超链接的强大，它有一个特殊的名字——<strong>超文本（Hypertext）</strong>。如今超文本最常指向的是另一个页面，这些页面会被获取并由浏览器进行渲染。</p><p>为了使网页能够互相连接，每个网页需要一个唯一的地址，这个地址称为<strong>统一资源定位器（Uniform Resource Locator，URL）</strong>，比如<code>thecrashcourse.com/courses</code>就是一个页面URL。</p><p>当你访问<code>thecrashcourse.com</code>网址时，计算机首先会进行DNS查询，这里输入一个域名，然后DNS就会返回给浏览器对应的计算机IP地址。然后浏览器就会打开一个TCP连接到这个IP地址对应的计算机上，而这个计算机运行着一个特殊的软件——<strong>网络服务器（Web Server）</strong>，网络服务器的标准端口是80。此时，你的计算机就连接到了<code>thecrashcourse.com</code>对应的服务器了，下一步是向服务器请求<code>courses</code> 页面，这里就会用到<strong>超文本传输协议（Hypertext Transfer Protocol，HTTP）</strong>。</p><h4 id="30-2-超文本传输协议-HTTP"><a href="#30-2-超文本传输协议-HTTP" class="headerlink" title="30.2 超文本传输协议 HTTP"></a>30.2 超文本传输协议 HTTP</h4><p>HTTP的第一个标准是1991年创建的HTTP 0.9，只有一个指令<code>GET</code> 。因为这里我们想要获取<code>courses</code>页面， 我们可以直接向服务器发送指令<code>GET/courses</code>， 该指令以ASCII编码发送到服务器，服务器会返回该网址对应的页面，然后浏览器就会将其渲染到屏幕上。如果用户点击了另一个链接，计算机就会重新发送一个GET请求。</p><p><img src="https://pic.imgdb.cn/item/66a9ef86d9c307b7e90921b4.png"></p><p>在之后的版本中，HTTP添加了新的状态码，会将其放在请求页面的前面，比如状态码200表示网页被正确找到了，状态码400-499代表客户端出错。</p><p>因为超文本的存储和发送都是以普通文本形式进行的，编码可能是ASCII或者UTF-8，这样就无法表明什么是链接，什么只是普通的文本了，所以必须开发一种标记方法，因此出现了<strong><font color=green>超文本标记语言（Hypertext Markup Language，HTML）</font></strong>，第一代HTML创建于1990年的0.8版本，有18种指令。</p><p><img src="https://pic.imgdb.cn/item/66a9f1c9d9c307b7e90b48be.png" alt="编写一个简单网页"></p><p>如果把这些文字存入记事本或文本编辑器，然后文件取名<code>test.html</code>，就可以拖入浏览器打开。当然，如今的网页更复杂一些，最新版的：HTML，HTML5，有100多种标签（图片标签，表格标签，表单标签，按钮标签，等等），还有其他相关技术（比如 层叠样式表CSS、JavaScript）这里就不展开讲了。</p><p>综上，网络浏览器可以和网络服务器沟通，不仅获取网页和媒体，并且还负责显示。</p><p>随着后期万维网日益繁荣，人们越来越需要搜索。起初人们会维护一个目录，来链接到其他网站，但是随着网络越来越大，人工编辑目录变得很不方便，所以开发了<strong>搜索引擎</strong>。</p><p>最早的搜索引擎是JumpStation，它有3个部分：</p><ol><li>通过爬虫来将新链接添加进自己的列表中。</li><li>不断扩张的索引，用来记录访问过的网页上出现了哪些词。</li><li>查询索引的搜索算法，比如输入了某个关键字，则包含这个关键字的网页就会显示出来。</li></ol><p>早期的搜索引擎的排名方式直接取决于搜索词在页面上的出现次数，但是有的网页会通过在页面中重复该关键字来提高排名。Google成名的很大原因就是提出了一种算法来解决这个问题，与其信任页面上的内容，搜索引擎会看其他网页有没有连接到这个网页。</p><p>最后提一个概念——<strong>网络中立性（Network Neutrality）</strong>，它指的是要对所有数据包都平等对待，速度和优先级都应该一样。</p><h3 id="31-计算机安全"><a href="#31-计算机安全" class="headerlink" title="31 计算机安全"></a>31 计算机安全</h3><h4 id="31-1-保密性、完整性和可用性"><a href="#31-1-保密性、完整性和可用性" class="headerlink" title="31.1 保密性、完整性和可用性"></a>31.1 保密性、完整性和可用性</h4><p>计算机安全的范围和计算能力的发展速度一样快，我们可以把计算机安全，看成是保护系统和数据的<strong>保密性、完整性和可用性</strong>。</p><ul><li><strong>保密性（Secrecy）：</strong>只有有权限的人才能读取计算机系统和数据，比如黑客泄露别人的信用卡信息，就是攻击保密性。</li><li><strong>完整性（Integrity）：</strong>只有有权限的人才能使用和修改系统和数据，比如黑客假冒你发送邮件，就是攻击完整性。</li><li><strong>可用性（Availability）：</strong>有权限的人应该随时可以访问系统和数据，<strong>拒绝服务攻击（DDOS</strong>）就是黑客发送大量的假请求到服务器上，使得网站很慢或者直接挂掉，这就是攻击可用性。</li></ul><p>为了实现这三个目标，安全专家会从抽象层面想想敌人可能是谁，这个称为<strong>威胁模型分析（Threat Model）</strong>。模型会对攻击者有个大致的描述：能力如何、目标是什么、可能使用什么手段。攻击手段又称为<strong>攻击矢量（Attack Vector）</strong>。威胁模型分析能够让你为特定情境做好准备，不被可能的攻击手段所淹没。换句话说，要怎么保护，具体看要对抗谁。</p><blockquote><p>假设你想确保笔记本计算机的“物理安全”，你的威胁模型是”好管闲事的室友”。</p></blockquote><p>通常威胁模型分析中，会以能力水平进行区分。在给定的威胁模型下，安全架构师要提供解决方案，来保持系统安全。</p><h4 id="31-2-安全保护机制"><a href="#31-2-安全保护机制" class="headerlink" title="31.2 安全保护机制"></a>31.2 安全保护机制</h4><p>有很多保护计算机系统、网络和数据的方法。很多安全问题可以总结成<strong>两个问题</strong>：</p><ol><li>你是谁？</li><li>你能访问什么？</li></ol><p>权限应该给适合的人而拒绝错误的人，所以为了区分谁是谁，我们使用<strong>身份认证（Authentication）</strong>来让计算机得知使用者是谁。通常身份认证有三种，各有利弊：</p><ol><li><strong>你知道什么：</strong>这个是基于某种只有用户和计算机知道的秘密，比如用户名和密码。这是如今使用最广最容易实现的方法。但是如果黑客知道了你的密码就惨了，或者可以通过暴力攻击试了密码的所有可能来获取你的密码，有些系统会在你尝试若干次错误后阻止你继续尝试。即使增长密码也很容易破解，所以现在很多网站都要求大小写字母加特殊字符，来增加可能的密码。</li><li><strong>你有什么：</strong>这是基于用户特定的物体，比如钥匙和锁。这种方法可以避免被人猜中密码的问题，而且通常需要人在现场，所以远程攻击就更加困难了。</li><li><strong>你是什么：</strong>这是基于你，通过你自己的特征展示给计算机来进行验证，比如指纹识别器和红膜扫描仪，这些方法特别的安全，但是最好的识别技术十分昂贵。“你知道什么”和“你有什么”是确定性的，但是来自传感器的数据每次都不相同，所以“你是什么”是概率性的，系统可能认不出你，或者将其他人认成了你。并且这种方法另一个问题就是无法重设，你无法修改自己的指纹或者虹膜。</li></ol><p>每种方法都有优缺点，一般建议使用两种或两种以上的认证方式。</p><h4 id="32-3-访问控制"><a href="#32-3-访问控制" class="headerlink" title="32.3 访问控制"></a>32.3 访问控制</h4><p>当系统知道了你是谁，接下来就需要知道你能访问什么，这个称为<strong>访问控制（Access Control）</strong>，因此需要一个规范，来说明谁能访问什么、修改什么和使用什么。这个可以通过<strong>权限（Permission）</strong>或<strong>访问控制列表（Access Control List，ACL）</strong>来实现，其中描述了用户对每个文件、文件夹和程序的访问权限。</p><ol><li><strong>读权限</strong>：允许用户查看文件内容。</li><li><strong>写权限</strong>：允许用户修改文件内容。</li><li><strong>执行权限</strong>：运行用户运行文件，比如程序。</li></ol><p>有些阻止需要不同层次的权限，则ACL的正确配置就十分重要。假设我们有三个访问级别：<strong>公开、机密和绝密</strong>。有个经典模型称为<strong>Bell-LaPadula模型</strong>，其中包含两条规则：</p><ol><li>用户不能<strong>read up</strong>，即不能读等级更高的信息。</li><li>用户不能<strong>write down</strong>，即用户不能写更低权限的信息，这样能避免高级别的信息不会泄漏到低级别的文件中。</li></ol><p>通过身份认证和权限控制，可以让计算机知道你是谁和你能访问什么，但是必须先保证做这些事的软硬件必须是可信的。但是仍然无法保证程序或计算机系统的安全，因为安全软件在理论上可能是安全的，但是实现时可能会不小心留下漏洞。但是我们有办法减少漏洞出现的可能性，比如一发现漏洞就马上修补。</p><p>大部分漏洞都是具体实现时出错了，所以为了减少执行错误，就要减少执行。系统级安全的圣杯之一是“安全内核”或“可信计算基础”：一组尽可能少的操作系统软件，这个安全性是接近可验证的。</p><p>构建安全内核的挑战在于，要决定内核应该有什么（代码越少越好）。当最小化代码数量后，要是能保证代码是安全的，那就很好了。现在最好的验证代码安全性的手段是<strong>独立安全监察和质量验证（Independent Verification and Validation）</strong>，让一群安全行业内的软件开发者来审计代码，这也是为什么安全型代码几乎都是开源的。</p><p>但是即使这样，还是有可能被黑客攻破，因此程序开发者需要控制损失的最大程度，这个称为<strong>隔离（Ioslation）</strong>。要实现隔离，可以<strong>“沙盒”（sandbox）</strong>程序，*<u>操作系统通过给每个程序独立的内存块，使得别的程序是无法触及的，这样就能把程序放到沙盒中，即使沙盒被破坏了，也不会影响别的程序执行</u>*。并且一台计算机可以运行多个<strong>虚拟机（Virtual Machine）</strong>，使得每个虚拟机都在自己的沙盒中。</p><h3 id="32-黑客与攻击"><a href="#32-黑客与攻击" class="headerlink" title="32 黑客与攻击"></a>32 黑客与攻击</h3><p>这里只介绍一些入侵原理，提供一个大概的概念。</p><h4 id="32-1-社会工程学"><a href="#32-1-社会工程学" class="headerlink" title="32.1 社会工程学"></a>32.1 社会工程学</h4><p>黑客入侵最常见的方式不是通过技术，而是欺骗别人，这个称为<strong>社会工程学（Social Engineering）</strong>，通过欺骗别人来让人泄露秘密，或让人配置电脑系统来变得易于攻击。最常见的攻击是<strong>网络钓鱼（Phishing）</strong>，其次还有<strong>假托（Pretexting）</strong>，攻击者给某个公司打电话，假装是IT部门的人，攻击者的第一通电话一般会叫人转接，这样另一个接的时候，电话看起来就像内部的，然后让别人把电脑配置得易于入侵，或者让他们泄露机密信息，比如密码或网络配置。</p><p>邮件里带<strong>木马（trojan horse）</strong>也是常见手段，木马通常会伪装成无害的东西，比如照片或发票，但实际上是恶意软件，有的会偷数据，有的会加密文件。</p><h4 id="32-2-暴力破解、NAND镜像、缓冲区溢出"><a href="#32-2-暴力破解、NAND镜像、缓冲区溢出" class="headerlink" title="32.2 暴力破解、NAND镜像、缓冲区溢出"></a>32.2 暴力破解、NAND镜像、缓冲区溢出</h4><p>如果攻击者无法用木马或电话欺骗，攻击者只能被迫使用其他手段，方法之一就是暴力破解，尝试所有可能的密码，直到进入系统，大多数现代系统会加长等待时间来抵御这种攻击。现在出现了一种攻破方法称为<strong>NAND镜像</strong>，如果能物理接触到电脑，可以往内存上接几根线，复制整个内存，然后暴力尝试密码，知道设备让你等待，这时只要把复制的内容覆盖掉内存，就无需等待，继续尝试密码。</p><h5 id="32-2-1-缓冲区溢出漏洞"><a href="#32-2-1-缓冲区溢出漏洞" class="headerlink" title="32.2.1 缓冲区溢出漏洞"></a>32.2.1 缓冲区溢出漏洞</h5><p>如果无法物理接触到设备，就需要远程攻击，比如通过互联网，这一般需要攻击者利用系统漏洞，来获得某些能力或访问权限，称为<strong>漏洞利用（Exploit）</strong>。一种常见的漏洞利用叫<strong>缓冲区溢出（Buffer Overflow）</strong>，这里的缓冲区是指预留的一块内存空间，比如我们在系统登录界面输入用户名和密码，而系统是用缓冲区来存储输入值的，假设缓冲区大小为10，并且缓冲区前后肯定还有其他数据，当用户输入用户名和密码时，这些值就会被复制到缓冲区中来进行验证，而该方法会溢出缓冲区，比如输入超过10个字符的密码，会覆盖掉相邻的数据，有时会让程序或系统崩溃，因为重要值被垃圾数据覆盖掉了。这里只是让系统崩溃，但是攻击者可以输入有意义的新值到程序的内存中，比如把<code>is_admin</code>标志位的值改为true，有了任意修改内存的能力，黑客就可以绕过登录这类东西，甚至使用那个程序劫持整个系统。</p><h5 id="32-2-2-缓冲区溢出的组织方法"><a href="#32-2-2-缓冲区溢出的组织方法" class="headerlink" title="32.2.2 缓冲区溢出的组织方法"></a>32.2.2 缓冲区溢出的组织方法</h5><p>有许多方法阻止缓冲区溢出，最简单的方法就是复制到内存之前先检查长度，称为<strong>边界检查（Bounds checking</strong>），许多现代编程语言都自带边界检查，程序也会随机存放变量在内存中的位置，这样黑客就不知道应该覆盖内存的哪部分，使得更容易让程序崩溃，而不是获得访问权限。程序也可以在缓冲区后，预留一些不用的空间，然后跟踪里面的值，看是否发生变化，来判断是否有攻击，这些不用的内存空间称为<strong>金丝雀（Canaries）</strong>。</p><h4 id="32-3-代码注入"><a href="#32-3-代码注入" class="headerlink" title="32.3 代码注入"></a>32.3 代码注入</h4><p>另一种经典手段是<strong>代码注入（Code Injection）</strong>，最常用于攻击用数据库的网站。下面是一个很简单的示例，我们会用“结构化查询语言”，也叫SQL（一种流行的数据库API）。</p><p>假设网页上有登录提示，当用户点击“登录”，输入文本就会发送服务器，服务器就会运行代码，检查用户名是否存在，如果存在就看密码是否匹配。为此服务器会执行一段sql查询代码，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT password FROM users WHERE username=&#x27;___&#x27;;</span><br></pre></td></tr></table></figure><p>这里语句就是要从<code>users</code>表中查找<code>username</code>为<code>___</code>的密码<code>password</code>。 这里的<code>___</code>就是用户输入的用户名。由此攻击者就能把sql命令输入到用户名中，比如<code>whatever&#39;;DROP TABLE users;&#39;</code>，这时上面的查询语句就会变成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT password FROM users WHERE username=&#x27;whatever&#x27;;DROP TABLE users;&#x27;;</span><br></pre></td></tr></table></figure><p>如果服务器存在用户名<code>wharever</code>，数据库就会返回密码， 当然我们无法得知密码是什么，所以服务器会拒绝我们；如果不存在用户名<code>wharever</code>，服务器会返回空密码或者直接错误，服务器也会拒绝我们。 但是我们关心的是后面的代码<code>DROP TABLE users;</code>，这个是我们注入的命令，这个命令是删掉users这张表。如今几乎所有服务器都会防御这种手段。</p><p>程序员需要认识到从外界输入的信息都是危险的，必须要好好检查，很多用户名和密码表单，不会让你直接输入特殊符号，比如分号或括号，来作为第一道防御。好的服务器也会清理输入，比如修改或删除特殊字符，然后才放到数据库查询语句中。</p><p>当软件制造者不知道的新漏洞被发现时，称为<strong>0day漏洞（Zero Day Vulnerability）</strong>，黑客就会抢在白帽程序员做出补丁之前尽可能利用漏洞。</p><p>如果有足够多的电脑有漏洞，让恶意程序可以自动地在电脑之间互相传播，称为<strong>蠕虫（Worm）</strong>。如果黑客拿下大量电脑，这些电脑可以组成<strong>僵尸网络（Botnet）</strong>，可以用于很多目的，比如发大量垃圾邮件等，用别人电脑的计算能力来挖比特币，或发起DDOS来攻击服务器。DDOS就是僵尸网络里的所有电脑发一大堆垃圾信息到服务器上，造成服务器的阻塞。</p><h3 id="33-加密"><a href="#33-加密" class="headerlink" title="33 加密"></a>33 加密</h3><p>这节将介绍计算机安全中最常见的防御形式——密码学。</p><h4 id="33-1-加密算法"><a href="#33-1-加密算法" class="headerlink" title="33.1 加密算法"></a>33.1 加密算法</h4><p>为了加密信息，要用<strong>加密算法（Cipher）</strong>将明文转换为密文，除非知道如何解密，否则密文看起来就是一堆乱码，这种将明文专为密文的过程叫做<strong>加密（Encryption）</strong>，而相反过程称为<strong>解密（Decryption）</strong>。</p><p>加密算法早在计算机出现之前就存在了，凯撒使用我们如今称为<strong>凯撒加密（Caesar Cipher）</strong>的方法来加密私人信件，他会将信件中的字母向前移动3个位置，所以a变成d，brutus变成euxwxv。为了解密，接受者要知道使用了什么算法，以及偏移的字母位数作为钥匙。</p><h5 id="33-1-1-替换加密"><a href="#33-1-1-替换加密" class="headerlink" title="33.1.1 替换加密"></a>33.1.1 替换加密</h5><p>有一大类算法称为<strong>替换加密（Substitution Cipher）</strong>，凯撒密码就是其中一种，算法把每个字母替换成其他字母。但是有一个巨大的缺点是，字母出现的频率是不一样的，比如英语中字母E出现的频率最高，如果将E替换成了X，则密文中X的出现频率就会很高，通过统计字母频率，就有可能破译密码。</p><h5 id="33-1-2-移位加密"><a href="#33-1-2-移位加密" class="headerlink" title="33.1.2 移位加密"></a>33.1.2 移位加密</h5><p>另一类加密算法叫<strong>移位加密（Permutation Cipher）</strong>，比如<strong>列移位加密（Columnar Transposition Cipher）</strong>，我们这里将明文填入网格，比如选择5x5大小的网格。为了加密信息，我们换一个顺序来读取，比如从左边开始，从下往上一次读一列，就会变成图2的形式，这样加密后的字母排列是不同的，，但是字母出现的频率没有变化。这里解密的关键是要知道读取方向和网格大小。</p><p><img src="https://pic.imgdb.cn/item/66aa0e2ad9c307b7e9259eb9.png" alt="移位加密的例子"></p><h4 id="33-2-硬件加密"><a href="#33-2-硬件加密" class="headerlink" title="33.2 硬件加密"></a>33.2 硬件加密</h4><p>到了1900年代，人们用密码学做了加密机器，比如德国的Enigma用来加密通讯信息。Enigma是一台类似打字机的机器，包含键盘和灯板，这两个都有完整的字母表，而且它还有一系列转子，这些是加密的关键。首先我们看一个转子，它一面有26个接触点，代表26个字母，然后线会连接到另一面来替换字母，其实这个就是替换加密。但是Enigma更加复杂，它有更多的转子，一个转子的输出作为下一个转子的输入，并且转子还有26个起始位置，还可以按不同顺序加入转子，来提供更多字母替换映射。转子之后是一个叫反射器的特殊电路，它每个引脚会连接另一个引脚，并把信号发回转子，最后机器前方有一个插板，可以把输入键盘的字母预先进行替换来增加一层复杂度。图中显示的是输入H后，经过加密会输出L，因为线路是双向的，所以输入L也会被加密成H，所以加密和解密步骤是一样的，直接将密文输入机器就能得到对应的明文。</p><p> 但是这个机器有个缺点，就是字母加密后，一定会变成另一个字母。</p><p>最后，为了让Enigma不只是简单的替换加密，每输入一个字母，转子就会转一格，这样比如你输入<code>AAA</code>，可能会输出<code>BDK</code>，映射会随着每次按键发生改变。 </p><h4 id="33-3-软件加密"><a href="#33-3-软件加密" class="headerlink" title="33.3 软件加密"></a>33.3 软件加密</h4><p>随着计算机出现，加密从硬件转向了软件。</p><p>早期应用最广的加密算法是IBM和NSA于1977年开发的<strong>数据加密标准（Data Encryption Standard，DES）</strong>，DES最初用56位二进制密钥，但到了1999年，计算机能将DES所有可能密钥都试一遍，所以DES不再安全。所以在2001年出现了<strong>高级加密标准（Advanced Encryption Standard，AES）</strong>，AES使用128/192/256位密钥，使得暴力破解更加困难。</p><p>AES将数据切成一块一块，每块16个字节，然后用密钥进行一系列替换加密和移位加密，再加上一些其他操作，进一步加密信息，并且每块数据会重复这个过程10次以上。因为加密是需要时间的，如果使用过长的密钥或者加密次数过多，虽然更加安全，但是加密时间过长。目前AES被广泛应用，比如iPhone上加密文件，用WPA2协议在WiFi中访问HTTPS网站。</p><h4 id="33-4-密钥交换"><a href="#33-4-密钥交换" class="headerlink" title="33.4 密钥交换"></a>33.4 密钥交换</h4><p>上面讨论的加密技术，都依赖于发送方和接收方都知道密钥，发送方用密钥进行加密，而接收方使用相同密钥来解密。现在我们需要某种方法，在公开的互联网上传递密钥给对方，但是这种方法不是很安全，密钥可能会被黑客拦截。解决方案就是<strong>密钥交换（Key Exchange）</strong>，这是一种不发送密钥，但依然让两台计算机在密钥上达到共识的算法。我们可以使用<strong>单向函数（One-way Function）</strong>来实现，这是一种数学操作，很容易计算出结果，但是想从结果逆向推算出输入非常困难。</p><blockquote><p>以颜料为例，我们可以很容易地将多个颜料混合得到最终的颜色，但是想要从最终颜色推算出用了哪些颜料进行混合是非常困难的。在这个例子中，我们的密钥就是一种独特的颜色。首先有一个公开的颜色，所有人都可以看到，然后对方和我自己各自选择一个秘密颜色，为了交换密钥，我先将我的颜色和公开颜色进行混合，然后发送给对方，并且对方也将他的颜色和公开颜色混合后发送给我，当我收到对方发来的颜色后，也将自己的颜色混入，并且对方也这么操作，这样我们就都得到了由3中颜色混合的一样的最终颜色，我们就可以将这个最终颜色当做密钥。</p></blockquote><p>计算机中，我们可以用<strong><font color=red>Diffie-Hellman密钥交换</font></strong>，在Diffie-Hellman中，单向函数是<strong>模幂运算</strong>，首先将一个数作为基数（Base），再拿另一个数作为指数（Exponent），然后将其结果除以第三个数就得到我们想要的余数：</p><script type="math/tex; mode=display">B^x \text{ mod } M</script><p>这样，如果只给$B$、$M$和余数，很难知道指数$x$是多少，并且如果将数字变得很长，比如几百位，想要找到秘密指数几乎是不可能的。</p><p>在Diffie-Hellman中，我们有公开的数——基数$B$和模数$M$。为了安全地给对方发送信息，可按下面的步骤进行：</p><ol><li>我们选择一个秘密指数$X$，然后将计算结果$B^X \text{ mod } M$发送给对方，对方同样也选择一个秘密指数$Y$，然后也将计算结果$B^Y \text{ mod } M$发送给我。</li><li>为了算出双方共用的密钥，我将对方的结果作为新的基数$B_Y$，再取$X$指数并求余，即$(B_Y)^X \text{ mod } M = (B^Y \text{ mod } M)^X  \text{ mod } M = B^{XY} \text{ mod } M$，而对方也用相同方法进行计算，得到的也是相同结果，也即最终都是$ B^{XY} \text{ mod } M$。</li><li>这样就可以将这个计算结果当做密钥，使用AES之类的加密技术进行加密通信。</li></ol><h4 id="33-5-对称加密和非对称加密"><a href="#33-5-对称加密和非对称加密" class="headerlink" title="33.5 对称加密和非对称加密"></a>33.5 对称加密和非对称加密</h4><p>Diffie-Hellman密钥交换是建立共享密钥的一种方法，双方使用一样的密钥加密和解密信息，称为<strong>对称加密（Symmetric Encryption）</strong>，因为加密和解密使用的密钥是一样的，前面的凯撒加密、Enigma和AES都是对称加密。</p><p>同样还存在<strong>非对称加密（Asymmetric Encryption）</strong>，这里有两个不同的密钥，一个是公开的，一个是私有的，人们可以用公钥加密消息，而只有有私钥的人才能解密，所以知道公钥只能进行加密不能进行解密，而通过公钥加密后，也只能用私钥进行解密，所以它是不对称的。</p><blockquote><p>非对称加密的形象化理解：</p><p>比如有一个带锁的箱子，我们可以将锁和箱子给别人，他将信息放入箱子并上锁后还给我，我就可以通过自己的钥匙将其打开。</p></blockquote><p>过程反过来也是可以的，可以用私钥加密再用公钥解密，这个通常用于签名。*<u>服务器可以用私钥进行加密，任何人都可以用服务器的公钥进行解密来获得信息</u>*，这使得私钥相当于一个签名，只有有私钥的人才能进行加密，只有当公钥能正确解密，才能证明数据来自正确的服务器或个人(差不多是<strong>数字签名</strong>的原理)。</p><p>总之，① 公钥加密只能私钥解密；② 私钥加密只能公钥解密。</p><p>目前最流行的非对称加密技术是RSA。现在我们简单了解了现代密码学的所有”关键”部分：对称加密，密钥交换，公钥密码学。</p><p>当你访问一个安全的网站，比如银行官网：</p><p><img src="https://pic.imgdb.cn/item/66aa248fd9c307b7e93849f6.png" style="zoom:70%"></p><p>图中绿色锁图标代表使用了公钥密码学，验证服务器的密钥，然后建立临时密钥，然后用对称加密保证通信安全。</p><p> 【原文链接】<br><a href="https://zhuanlan.zhihu.com/p/460879375">计算机科学速成课笔记 - 问夏的文章 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/103664879">读书笔记_计算机科学速成课——计算机网络（28、29、30） - 深度人工dazed的文章 - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机与编程学习 </category>
          
          <category> 计算机介绍 </category>
          
          <category> 计算机发展史和相关技术原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基本概念 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 基本原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经济学速成课</title>
      <link href="/2023/09/27/Economics-crash-course/"/>
      <url>/2023/09/27/Economics-crash-course/</url>
      
        <content type="html"><![CDATA[<h3 id="1-经济学简介"><a href="#1-经济学简介" class="headerlink" title="1 经济学简介"></a>1 经济学简介</h3><h4 id="1-1-什么是经济学"><a href="#1-1-什么是经济学" class="headerlink" title="1.1 什么是经济学"></a>1.1 什么是经济学</h4><p>经济学不是研究金钱和致富的科学，尽管理解经济学可以帮助你，经济学研究的不是股票市场，经济学是研究人与决策的科学，著名的经济学家阿尔弗雷德·马歌尔把经济学定义为：在日常生活中，研究人，关注他如何获得收入，如何花钱，因此，经济学一方面是研究财富的科学，另一方面是研究人。</p><p><a href="https://open.163.com/newview/movie/free?pid=FHJP2BSM7&amp;mid=PIALBAMVP">【合集】10分钟速成课：经济学【预告+全35集+花絮】</a></p><h3 id="2-基金"><a href="#2-基金" class="headerlink" title="2 基金"></a>2 基金</h3><h4 id="2-1-基金的基本概念和分类"><a href="#2-1-基金的基本概念和分类" class="headerlink" title="2.1 基金的基本概念和分类"></a>2.1 基金的基本概念和分类</h4><h5 id="2-1-1-股票与债券"><a href="#2-1-1-股票与债券" class="headerlink" title="2.1.1 股票与债券"></a>2.1.1 股票与债券</h5><p>基金最常见的2种投资品类：“股票”和“债券”。</p><p><strong>（一）什么是债券</strong></p><p>债券是发行方为筹集资金发行的，在约定时间支付一定比例的利息，并在到期时偿还本金的一种有价证券。</p><blockquote><p>小贴士：<a href="https://www.zhihu.com/question/21860482">欠条属于证券吗? - 知乎</a>、<a href="https://baijiahao.baidu.com/s?id=1771105911249618399&amp;wfr=spider&amp;for=pc">三分钟金融小知识：债券 - 百度文章</a></p></blockquote><p>债券不论何种形式，大家都可以在市场上进行买卖，据此形成了债券市场。债券又可分为3类：“政府债券”、“金融债券”和“公司债券”。</p><ul><li><p>政府债券：有政府税收作为保障，因而风险相对最小，但收益也相对最小。我们最常听说的国债就是政府债的一种。</p></li><li><p>公司债券：风险相对最大，理论上可获得的收益也相对最大。</p></li></ul><p>因此，债券具有如下的特点：</p><ol><li>偿还性：规定有偿还期限，发行人必须按债券约定条件偿还本金并支付利息。</li><li>流通性：债券一般都可以在流通市场上自由转让。</li><li>安全性：与股票相比，债券通常规定有固定的利率。与企业绩效没有直接联系，收益比较稳定。风险较小。</li><li>优先性：在企业破产时，债券持有者享有优先于股票持有者对企业剩余资产的索取权。</li><li>收益性：债券的收益性主要表现在两个方面：① 利息收入；② 买卖债券赚取的差额。</li></ol><p><strong>（二）什么是股票</strong></p><p>当公司需要筹措长期资金，因此将股票发给投资者作为公司资本部分所有权的凭证，成为股东以此获得股息(股利)，并分享公司成长或交易市场波动带来的利润，但也要共同承担公司运作错误所带来的风险。因此从定义可以看出，股票有如下特点：</p><ol><li>无偿还性：需要共同承担公司的运作错误带来的风险，意味着是有损失本金的风险的。</li><li>流通性：股票也是可以在流通市场上自由转让的。</li><li>高风险：刚才提到过。在企业破产时债券持有者享有优先于股票持有者对企业剩余资产的索取权，从这个角度看股票的风险也要远高于债券。</li><li>收益性：股票的收益性主要表现在两个方面：① 股息收入(取决于公司是否发放)；② 买卖股票赚取差额。</li></ol><p>下面通过一个生活小例子体会一下债券和股票的区别：</p><p>假如我打算开一家酒店，开这家酒店需要50万人民币，而我目前手里只有30万元。还缺少20万元，怎么办？我的好朋友小李刚好有10万元闲钱想去投资。这时候我去找小李商议。想要借来他的10万。我们最终达成一个共识。他把这10万元借给我，我每年给他6%利息，3年后归还本金给他。最后我给他打了一份借条作为借款的凭证。这时候我手里便有了40万，但是显然我还缺10万元呀，正在我发愁的时候，隔壁老王听说我最近打算开酒店这个事，他相信我的能力，他打算资助我10万元和我一起开这家酒店，就算他入股了，他同样获得了这家酒店的部分所有权。我们需要签署合同，并在合同里写清楚每个人的股份占比。由于我出了50万中的40万，那么我就算持有了这家酒店的80%的股权，他买了20%的股权，那么以后酒店盈利的20%自然也就得分给老王，那如果酒店亏损了我们自然也应该一同承担</p><p>小李和老王其实都投资了10万元，他们的区别在哪呢？接下来假设我的酒店第二年盈利了10万，我之前向小李借了10万，应支付给小李$100000 \times 6 \% = 6000$元，而老王有20%的股权，我应付给老王$100000 \times 20 \% = 20000$元的股息分红。到了第二年酒店盈利只有1万，这时候按照之前的约定，我仍然需要向小李支付6000元的利息。而老王的分红金额则变成了$10000 \times 20\%  2000$元。到了第三年，由于酒店经营不善倒闭了，变卖了资产后就剩下10万元了。这时候我依然要付给小李6000元的利息，并在到期时归还小李的10万元本金。而老王就没那么幸运了，他投入的10万本金就没法要回来了。但是反过来，如果酒店经营的非常好，第三年甚至盈利达到100万，那么老王就能赚到20万的分红，甚至远高于他的本金，而小李始终只能得到6000元的利息，与酒店经营状况无关。</p><p><strong>小结：</strong>我们从上面的例子中，就能清晰的理解了债券和股票的区别了，可以简单理解为小李购买的是酒店发行的债券，就相当于把钱借给我的酒店，提前约定好回报率，与酒店的经营状况无关，所以债券更加强调的是：① 本金相对安全；② 收益相对稳定，属于固收类产品；③ 利息高于银行存款，但也不会太高。那么老王就可以理解为买了我酒店的股票了，和我共同拥有这家酒店，和我共同享受酒店盈利，自然也要共同承担酒店的亏损。股票更加强调的是：① 高风险，有本金损失风险；② 高收益，理论上收益可以无限高。</p><h5 id="2-1-2-基金的概念"><a href="#2-1-2-基金的概念" class="headerlink" title="2.1.2 基金的概念"></a>2.1.2 基金的概念</h5><p><strong>（一）基本概念</strong></p><p>上面主要介绍了股票和债券，不管是股票还是债券其实都属于直接投资，相当于我们直接用钱购买了这两类特殊的“商品”。而接下来要重点讨论的<strong>基金就应该可以称为间接投资了，也可以称基金为一种委托关系</strong>。因为你的钱并不是直接用来购买某种商品，而是委托给专业的基金管理机构，让他们来代替你去投资，那么下面我们就来好好聊一聊基金吧!</p><p>基金的英文为fund，广义是指为了某种目的而设立的具有一定规模的资金，我们平时讲的公积金、保险基金、退休基金广义来看其实都基金的一种。而我们大多数普通人口中所说的基金其实指的是狭义概念上的基金 —— 主要指的是证券投资基金。</p><p>那么什么又是证券呢，我们口中常说的债券、股票、期货等都是证券。那么问题就来了，在基金的概念出来前我们就可以直接投资股票、债券这类证券，而基金也是投资股票、债券，我们为什么要通过基金来投资证券而不是直接投资呢？</p><p>下面我们就来探讨—下这个问题</p><p><strong>（二）投资基金 OR 直接投资证券</strong></p><p>这里以股票为例。相信了解过股票的朋友都知道，在购买某家企业的股票时最低也要一次性购买100股，也被称为“一手”。那么假设我想购买腾讯公司的股票，腾讯现在—股的价格是623元，如果我现在手里有1000元想投资腾讯，我连2股都买不起，更别说最少要买一手了。另外，我们知道100%重仓一家公司的股票风险也是极高的，我这手里的1000元或者甚至说10万元都根本没办法做到<strong>分散投资</strong>。因为一般分散投资怎么也得需要上百万上千万的资金才能做到，对于普通人来说门槛太高了。同理，债券和期货等其他的证券类产品，也是有不低的准入门槛的，普通人很难参与投资。所以直接投资证券并不适合我们这—类普通投资者。</p><p>我总结为以下几个原因：</p><ol><li>准入门槛高，需要大额资金；</li><li>风险高，不易做分散投资；</li><li>普通人没精力盘，买卖股票、期货等需要消耗不小精力；</li><li>普通人不够专业，并不具备选股能力，直接交易股票、期权无异于赌博。</li></ol><p>而证券投资基金帮助我们普通人解决了上面提到大多数问题。证券投资基金是由一些基金公司、保险公司或者银行推出的，从众多投资者那里募集巨额资金并组建专门的管理团队，形成一个投资组合产品，这个组合中可以只包含股票、债券，也可以同时包含股票、债券、期货等。举一个极端的例子，假设有一个基金组合中70%投资了股票，20%投资了债券，10%投资了现金等价物，那么即使你只投资了10元钱，你的这10元钱依然会被按照比例，分别投资于手上面提到的不同产品，也就是7元投资股票，2元投资债券，1元投资现金及现金等价物，这样我们相当于把我们的钱放入这支基金的资金池中。同时有很多很多的人和我们一样，把钱放进了这个资金池，积少成多，可能这个池子中已经有了几亿、几十亿的资金，基金经理会拿着这些资金去进行分散投资，获得收益回报后再按照每个人的，资金占比把利润返还给每个投资者，而基金公司每年会按照合同中约定好的比例，从资金中拿走一部分作为基金的管理费用。</p><p>所以基金帮我们解决了下面上面提到的问题：</p><ol><li>大大降低了准入门槛，让普通人也可以参与证券投资；</li><li>小资金也可以做分散投资，可以适当降低风险；</li><li>投资购买场外基金的话不需要盘消耗精力，适合职场人；</li><li>有更专业的人帮我们管理投资资金；</li></ol><p>可以说基金的出现，使得普通人也可以参与证券投资，使普通人也有享受中国经济以及国内外优秀企业发展带来的红利的机会，随着国内居民储蓄证券化的进程加快，基金投资必定会是未来的大势所趋，只有通过不断学习才能让我们做到理性投资，智慧投资。</p><h5 id="2-1-3-基金的分类"><a href="#2-1-3-基金的分类" class="headerlink" title="2.1.3 基金的分类"></a>2.1.3 基金的分类</h5><p>通过简单介绍债券、股票、基金的概念，相信大家有了一个大体的了解，那么本节就接着聊一聊基金的分类。</p><p>在第一部分介绍过，各种金融产品的风险和收益都是不同的，有高风险的股票、期货、大宗商品等，也有相对低风险的债券、货币、银行定存等。而每个人对于风险的承受能力是不同的，所以为了适应不同风险承受等级的投资者，目前市面上的基金种类也是越来越多。下面只简单的介绍几种适合普通投资者的基金类型，关于每种基金的详细介绍之后会具体介绍。</p><p><strong>（一）货币基金</strong></p><p>首先是货币基金，其主要投向风险小的货币市场，也可能有一定的比例投资于风险小的短期债券。货币基金具有高安全性、高流动性、稳定收益性<strong>特征</strong>，货币基金的利率主要受到央行的利率的影响，我们大家都熟知且广泛使用的余额宝就属于货币基金。评价货币基金时主要有两个<strong>指标</strong>：① 7日年化收益率（<a href="https://baijiahao.baidu.com/s?id=1777334570697274009&amp;wfr=spider&amp;for=pc">支付宝7日年化收益率是什么意思？ - 百度文章</a>）；② 万份收益。自前由于全世界持续低利率的货币宽松大环境下，利率持续走低，多数货币基金的七日年化率维持在1.9%上下的水平，略高于银行定期存款，万份收益维持在0.55元上下的水平(即购入1万元每日可以获得0.55元的利息)，虽然不多但比银行定存利息要多，而且余额宝还是随用随取的。但是投资货币基金时投资者需要摆脱一个误区 —— 大多数的货币基金并不是具备随存随取的特性的。余额宝只是一个特殊的例子，相反大多数货币基金都是<strong>T+1</strong>的买卖规则，即当日申购，第二日开始计算收益，当日赎回，第二日才能到账。</p><p>由于货币基金属于低风险低收益类产品，且不同的货币基金的收益率相差并不大，所以个人建议直接使用余额宝就可以，没必要花大量精力研究并挑选其他的货币基金。这部分我就不做过多的介绍了。</p><p><strong>（二）债券基金</strong></p><p>根据中国证监会对基金类别的分类标准，基金资产80%以上投资于债券的为债券基金，债券基金也可以有一小部分资金投资于股票市场。另外，投资于可转债和打新股也可以是债券基金获得收益的重要渠道。在国内债券基金的<strong>投资对象</strong>主要是国债、金融债和企业债。通常，债券为投资人提供<strong>固定的回报</strong>和<strong>到期还本</strong>，具有收益稳定风险较低的特点，所以债券基金一般会被评级为中低风险产品。</p><p>那么债券基金会有什么风险呢？影响债券基金业绩表现的两大因素：①是利率风险，即所投资的债券对利率变动的敏感程度；②是信用违约风险，一般适合我们普通投资者投资的债券基金有以下三种类型：</p><ol><li>标准型（纯债基金），纯债基金就是只投资债券市场的基金，不投资股市。例如广发纯债债券A(此处郑重声明以上出现的基金均为举例并非推荐)。</li><li>普通型（偏债基金），偏债基金又称为二级债基金，可以用最高不超过20%的仓位投资股票二级市场，也就是可以直接买卖股票。比如易方达裕丰回报债券。</li><li>可转债基金，主要投资于可转债，也可以打新可转债。例如兴全可转债基金。可转债可以看成既有债券属性，可以拿利息到期退还本金，也可以按照发行时约定的价格，将债券转换成公司的普通股票的一种债券。</li><li>混合型基金，指在投资组合中既有股票又有债券等固定收益投资的共同基金。</li></ol><p>其中，混合型基金设计的目的是让投资者通过选择一款基金品种就能实现投资的多元化，而无需去分别购买风格不同的股票型基金、债券型基金和货币基金。回报和风险要低于股票型基金，高于债券和货币基金，是一种风险适中的理财产品。其实混合型基金根据股票、债券投资比例以及投资策略的不同，又可以分为下面三种主要类型：① 偏股型基金(组合中股票的占比超过50%的混合基金)；② 偏债型基金(组合中债卷的占比超过50%但低于80%的基金); ③ 配置型基金(组合中债券和股票占比都低于50%的基金)。其实一些运作良好的混合型基金，回报甚至会超过股票基金的水平。大家细品混合型基金不就是我们梦以求的分散投资策略的基金哦，省去了我们的很多麻烦，但是挑选时仍然有很多需要注意的地方，感兴趣的朋友可以关注基金小课堂第四期的内容，那里会详细介绍。</p><p><strong>（三）股票基金</strong></p><p>股票型基金是指投资于股票市场的基金，是指股票型基金的股票仓位不能低于80%的基金，股票基金属于高风险高收益类的基金。股票基金还可以简单地分为以下两种类型：</p><ol><li><strong>主动型基金</strong>，主动型基金是基金经理根据基金投资理念主动选股并进行人为地管理，一般主动型基金目标是取得超越市场业绩表现的收益。</li><li><strong>被动型基金（指数基金）</strong>，纯粹的指数基金是资产几乎全部投入所跟踪的指数的成分股中，几乎永远是满仓，即使市场可以清晰看到在未来将持续下跌，它也保持满仓状态，不作任何行情判断，完全排除人为的干扰；另外也有一种增强型指数基金，这种类型的基金在保证跟踪指数的大方向上，加入适当的人为操作，根据股票市场的具体情况进行适当的调整，例如调整仓位，调整成分股比例等。</li></ol><blockquote><p>相关链接：<a href="https://baijiahao.baidu.com/s?id=1675716566735763583&amp;wfr=spider&amp;for=pc">深度：股票和股票型基金有什么区别？ - 百度文章</a></p></blockquote><p>除了上面提到的几种基金以外还有几种基金我简单地提一下：</p><ol><li>QDII基金，是指在在咱们国内设立，但主要投资国外证券市场的股票、债券等有价证券业务的证券投资基金。所以希望投资海外市场的朋友，例如港股、美股、美债等需要好好了解一下QDII基金；</li><li>FOF基金，又称基金中的基金，与上面提到的基金的最大的区别在于，<strong>FOF基金是以基金为投资标的</strong>，而普通基金是以股票、债券等有价证券为投资标的，专业机构对基金进行筛选，帮助投资者优化基金投资效果，简单理解为指数基金是一篮子股票，而FOF基金相当于一篮子基金，也是为了达到分散投资的目的，投资FoF基金等于同时投资多只基金，但比分别投资的成本大大降低了；</li><li>MOM基金，又称为管理人的管理人基金，是指该基金的基金经理不直接管理基金投资，而是将基金资产委托给其他的一些基金经理来进行管理，直接授予他们投资决策权限，MOM本身的基金经理仅负责挑选和跟踪监督受委托基金经理的表现，并在需要的时候进行更换。</li></ol><p>所以我们能看出FOF基金策略对象是基金，目的是挑选一篮子优质基金，而MOM基金的策略对象是基金经理，自的是挑选一篮子优秀的基金经理。</p><h5 id="2-1-4-债基的分类"><a href="#2-1-4-债基的分类" class="headerlink" title="2.1.4 债基的分类"></a>2.1.4 债基的分类</h5><p>本节聊一聊债券基金，今天这一期我计划探讨两个内容：① 影响债券收益的因素有哪些？② 探讨一下如何快速筛选出适合投资的优质债基。</p><p><strong>（一）影响债券收益的因素</strong></p><p>首先来谈一谈影响债券收益的因素，我认为影响债券收益的主要因素有两个：① 债券风险评级的高低；② 无风险利率的高低。下面我们就分别探讨这两个因素是如何影响债券收益的。</p><p>先来分析一下债券风险等级的影响，债券主要有三类：政府债券、金融债券和企业债券。国债是最常被提到的一种政府债，国债就是以国家信用为基础发行的一种债券，由于违约的风险极低，因此经常又被称为无风险利率。金融债和企业债风险都比国债要高，毕竟一个企业的信用违约风险要远高于一个国家。那么如果一个企业发行债券，想吸引投资人来购买，那么势必要给出比国债更高的利率才会有人购买，这就引出了我们常听到的一个概念 —— <strong>风险补偿</strong>，债劵风险越高，投资者承担风险就越高，就需要给出更高的风险补偿。所以说债券的实际利率是由无风险利率加上风险补偿共同决定的，所以说债券的风险评级是影响债收益的一个重要因素。债券的风险评级越高，债券的收益率就会越高，就必须要承担更大的信用违约风险。</p><p>再来分析下无风险利率的影响，前一部分我们提到了一个非常重要的概念叫做无风险利率，此外别忘了债券其实还可以在二级市场（<a href="https://baijiahao.baidu.com/s?id=1761031812657220966&amp;wfr=spider&amp;for=pc">一级市场和二级市场的区别</a>）中进行买卖交易，那么只要存在买卖，价格就会受到供求关系影响。理解了这两点其实就很容易理解无风险利率是如何影响债券价格的了。</p><p>举一个简单的例子：老王今年年初用100元买了一张票面价格为100元的5年期国债，利率为5%。到了第一年年底呢，5年期的国债利率提高到了6%，等同于升息了。有了利息更高的国债老王就打算卖掉手里利率为5%的债券，去买入新发的国债，那么问题就来了新发的国债利率更高，别人凭什么要买你手中利率更低的债券呢？这时候老王只能把手中的债券以更低的价格卖出去了，最终老王只能以98元的价格卖给了老李，这就是所谓的折价。老李以98元的价格买入了价值100元的债券，计算实际收益是自然也要加上这2元，这时候债券的价格不就下降了嘛，所以<strong>一般来说利率提升就会导致债券价格下跌</strong>。如果是相反的情况呢，如果无风险利率下降，这时候新发的债券利率更低，老王就可以以更高的价格卖出手中持有的高息债券，可能最终以102元的价格卖给了老李，这时候债券的价格就上涨了，这就是所谓的债券溢价，老李在计算实际收益时自然也要减掉多花费的这2元，所以<strong>一般来说利率降低也就是降息会导致债券价格上涨</strong>。如果老王持有的是企业债道理也是一样的，如果无风险利率升高同样利息的情况下，谁还会担着更高的风险购买企业债呢？所以要么公司债券的风险补偿要提高，也就是实际利率要有所提高，要么投资者就会卖掉手中的企业债进而去买入国债，这也是会造成债券价格的下跌。</p><p>所以通过上面的例子我们就明白了，为什么债市近期持续下跌主要是由于近期<font color=blue>国债利率持续走高(相当于无风险利率不断上升)</font>，这时候选择折价卖出债券的投资者太多了，那么债券的价格依然也就有所下降了，进而影响了债券基金净值的下降。</p><p>下面我想再顺便科普两个概念，我们知道债券也根据周期的不同分为短债、1年、3年、5年、7年、10年…期的债券，那么其实它们的价格受无风险利率的影响程度也是不同的，也可以说对利率的敏感程度不同。通常周期越长的债券的价格对利率的变化越敏感，这个其实很好理解：剩余的年限越长，长期来看你现在卖掉换成更高利息的债券以后获得的累计收益会更高，所以大家更偏向折价卖掉手中的债券去购入更高利率的债券。有些朋友可能疑惑，即使升息了,我持有的债券不折价卖掉而是继续持有到期，不是能一样获得利息吗，这话其实没有任何问题哈，持有到期你依然能获得原本约定好的利息并收回本金，但是问题是升息了你不卖掉手中的债券，你同样也失去了收回本金，去投资更高利息债券的机会了，你现在便宜点卖出去换来了更高利息的债券，其实也算是互补了。所以实际上折价卖还是不卖，最终对于你的损失/收益都是一样的。</p><p><strong>（二）如何挑选优质债券基金</strong></p><p>接下来就跟大家聊聊我常用的实用技巧。首先我们得清楚，投资债券基金和直接投资债券区别还是挺大的，好处就在于我们不用亲自去选择要投资的债券了，由更专业的基金经理来帮我们做选择，缺点其实也是我们无法亲自挑选债券，在挑选债券基金的时候该以什么样的标准，才能筛选出优秀的债基呢？在挑选债基时通常需要考虑以下几个问题：</p><ol><li>首先要确定债基类型，上一期我们提到过债券基金有三种主要类型：分别是纯债基金、普通型基金、可转债基金。</li><li>确定你所能承受的风险和你的目标回报率，通常来说，你希望得到更高的回报就需要承担更高的风险，就上面三种债基来说，风险/收益：纯债基金 &lt; 普通型基金&lt; 可转债基金。一般来说纯债基金的年化收益在5%~7%之间，普通型债基年化收益分化比较大，业绩好一点的可以达到9%~12%，可转债基金就更依赖于基金经理的操作和股市涨跌了。</li><li>然后要进行初步筛选，筛选的标准我更看重为以下几点：① 成立时间最好大于5年，债基成立的时间越久可参考的数据就会越多，债基更看重的是稳定性，而基金的稳定性通常是从历史数据中评估后得出的结论；② 基金的三年五年评级最低也要大于3星(最好选择5星)，这个评级是对债基历史业绩的评价，我们自然希望挑选历史表现更好的基金；③ 业绩稳定，业绩始终跑赢同类平均这一点很重要，我们投资债基就是为了债基的稳定性，不会出现暴涨暴跌，如果一个债基都无法保证收益稳定，上蹭下跳的那还不如去投资股票基金了，当然稳定的同时我们也同样追求收益，所以业绩至少应该始终能跑赢同类的平均值吧，这个稳定性是相对的只能和同类型的去比较，纯债基金和偏债基金的稳定性自然不能进行比较，对于偏债基金的稳定性要比纯债基金更宽松。(注意：这里指的业绩稳定是短中长期都能保持业绩稳定).</li></ol><p>我们按照上面的标准来初步筛选一下债券基金吧。这里我们以纯债基金为例(普通型债基的挑选方式相似)。下面是我筛选基金的实操展示。</p><p>我在初步筛选债券基金时通常会使用<strong>晨星网</strong>的基金筛选工具，大家可以搜索晨星网进入到<a href="https://www.morningstar.cn/">晨星网主页</a>。进入主页后中间就可以看到基金筛选器这样一个小工具，点进去后就会出现下面这样可以选择筛选条件的页面</p><center><img src="https://img2023.cnblogs.com/blog/2609360/202310/2609360-20231002171600625-54201482.png" style="zoom:50%" /></center><p>我们选择更多筛选条件来进行更详细的筛选，按照上面讲过的筛选标准我们选择纯债基金，三年和五年评级3星以上业绩总回报大于同类平均，点击查询进行初步筛选</p><center><img src="https://img2023.cnblogs.com/blog/2609360/202310/2609360-20231002171844005-1706202037.png" style="zoom:50%" /></center><p>假设查询最终得到了3支纯债基金，如果你觉得条件过于严苛你可以根据自己的想法自由调整。同样的条件在普通债券基金下进行筛选的话，一般可以得到更多支基金。通过初步的筛选，可以帮我们过滤掉不少没有研究价值的基金，剩下的几支长期表现优秀的基金，我们接下来就可以对剩下的几支基金进行详细地对比，优中选优了。</p><p>在最后这一步，我更喜欢使用天天基金网的基金PK小工具来进行。我们既可以在天天基金网页上使用，APP上也能使用。以APP为例向大家展示一下效果，搜索出要PK的几支中的一支基金后，找到下方的PK对比按钮随后我们再选择添加对比基金即可。</p><p><img src="https://img2023.cnblogs.com/blog/2609360/202310/2609360-20231002172318012-885380433.png">“</p><p>可以看到不仅会对每支基金进行打分，同时还有每只基金的业绩走势图，各阶段业绩表现、各阶段盈利概率、风险评价、资产配置比例等很多数据，大家可以通过对比这些数据，进而挑选出更适合投资的1~3支基金。假设以上面搜出的3支纯债基金为例，其中一支基金为C类基金，长期业绩和另外两支有一定的差距，毕竟C类基金本来就不适合长期持有，剩余的另外两支纯债基金，易方达纯债债券A和易方达中债新综合指数(LOF)A，二者的业绩表现相似，且长期业绩都保持平稳增长波动不大，两者中随意挑选一支或同时投资都可以，年化收益都能达到6%左右。</p><p>这一期的第二部分，我介绍了一个我经常使用的筛选债基的方法，也向大家介绍了两个帮助筛选的工具，这样的筛选方法可以辅助我们更容易地挑选出长期表现优秀的债券基金。当然我其实只是为大家提供了一种筛选的思路，大家可以根据不同情况做出调整，改进成更适合自己的方式，我在这一期我主要以纯债基金为例进行说明，其实这样的筛选方式，同样适用于其他类型的债券基金。</p><h4 id="2-2-家庭资产配置话题"><a href="#2-2-家庭资产配置话题" class="headerlink" title="2.2 家庭资产配置话题"></a>2.2 家庭资产配置话题</h4><p>如何合理地配置家庭资产也是很多人关心的一个话题，其实如何科学分配并最大化利用我们的钱，并不是一件简单的事情。如果我们把过多的钱用于投资，一旦出现紧急情况需要用钱，很有可能陷入现金流麻烦，这通常会导致我们在不合适的时机卖出资产来填补现金空缺。相反如果我们预留过多的闲钱在手中，而不用作投资又无法最大化地利用我们的钱，无法为我们带来最大化收益，那么我们到底应该以怎样的比例去分配我们的资产呢。今天我就来为大家介绍一种科学的配置方法 —— <strong><font color=red>标准普尔家庭资产象限</font></strong>，也经常被俗称为资产配置的四笔钱。文章的最后我会针对这个配置方法谈一谈我的个人看法，并给出一个我的改进方案，希望我的文章能对大家有所帮助。</p><p>首先聊聊标普家庭资产象限，无论是家庭还是个人在开始理财投资前，都应该做出充分的准备，需要准备的第一件事就是梳理自身的资产状况，换句话说理财投资前你得先清楚你一共有多少财可理，其中有多少是短期可能会用到的，有多少是可以长时间不用的，你的风险承受能力怎么样，如何保证在未来突然生病了或发生意外时，你能快速拿出钱来处理，标准普尔家庭配置象限图就完美地解决了上面所有的问题，所以它是目前被公认为最合理稳健的家庭资产分配方式。看下面这张图，可以对比一下自己家庭资产配置的方案。</p><center><img src="https://img2023.cnblogs.com/blog/2609360/202310/2609360-20231002203312303-587942123.png" style="zoom:60%" /></center><p>按照标普的建议，我们应该把我们要管理的资产根据用途、持有周期和投资标的风险等级的不同，分成不同比例的四份：① 要花的钱；② 保命的钱；③ 保本升值的钱；④ 生钱的钱。分别建立账户分开进行管理，下面我会对这四笔钱分开进行详细介绍。</p><p><strong>（一）要花的钱</strong></p><p>要花的钱（紧急备用金），相信经历这次疫情后，很多朋友会开始认识到紧急备用金，对于家庭资产配置有多么重要。当我们因为类似疫情这样的突发原因而无法工作时，抑或是在工作不顺心想要换工作时，紧急备用金就开始体现它的价值，这是我们面对突发状况时的重要保障，无论是家庭也好还是个人也好，我们至少应该留出3-6个月的生活费来用作紧急备用金，这部分钱不必追求高收益而是应该保证它的流动性，需要保证在遇到紧急状况时立马就能使用，可以存在余额宝或者微信的零钱通中，但一定要和平时花销的钱分开管理，切记不要存在同一个账户中。至于上图中建议的比例10%我们不必苛求，因为每个人的生活费用是不尽相同的，这就需要每个人或每个家庭根据自身的状况做出适合自身的调整了，建议按照3个月~6个月生活费这一标准来。</p><p><strong>（二）保命的钱</strong></p><p>保命的钱，一般用于购买<strong>重疾险</strong>和<strong>意外险</strong>，请注意这里的保险并不是随便什么保险，而是重疾险意外险和医疗险这类保险，这一类保险是我们每个人每个家庭都一定要配置的，我们看过太多家境殷实但是一场大病倾家荡产的例子，这些保险就是在意外不幸降临时，保护我们的最后一道防线，这部分的钱是万万省不得的，虽然这部分投资有可能永远不会发挥它的作用，最终打了水漂，但是可以说，重疾险和意外险是保护我们健康和资产的最后一道防线。在万一不幸发生意外或者病魔降临时，不至于淘空我们的全部家产甚至赌上家人的未来去应对。当然如果我们一辈子都没能用上这部分保险，那也没什么值得可惜的，身体健健康康的，即使每年花掉一部分钱买份安心也是一件值得做的投资。图中建议的20%在我看来也是不完全契合实际的，大家需要根据自身情况来进行合理配置即可。当然至于其他类型的保险，大家在买之前还是要用心去甄别的，如果你是希望利用保险去赚钱，那么建议还是打消这个念头吧，保险不应该被视作增值类投资产品，而是<strong>保障类的投资品类</strong>。</p><p><strong>（三）保本升值的钱</strong></p><p>保本升值的钱，目的是稳健投资，在完成了上面两部分准备后，剩下的资产就可以用来进行真正意义上的投资，为我们带来实打实的收益了。正如图中的第三象限中写的那样，我们应该拿出一部分来进行稳健的投资，达到保本升值的目的。这部分投资的目标就是能至少<strong>跑赢通货膨胀</strong>，避免让我们辛辛苦苦赚来的钱在通货膨胀中不断贬值，但是图中关于投资标的建议并不适合我们普通人，像债券和信托基金这样的投资标的，一般来说投资门槛都比较高需要资金量也比较大。并不适合普通投资者，我的建议是可以优先考虑投资债券基金，最好选择是纯债基金，至于什么是债券基金和纯债基金，如何挑选债券基金可以在上一节中了解到。基金的门槛更低且有更专业的基金经理帮我们挑选优质的债券，适合我们普通投资者，而纯债基金不投资于任何股票这类高风险产品，属于纯固定收益类产品波动小，本金安全性高适合作为保本升值的投资品类。</p><p><strong>（四）生钱的钱</strong></p><p>生钱的钱，目的是追求高收益。第四象限的资产应该作为生钱的钱，这部分钱应该做好超长期投资的准备，可以考虑配置股票、股票型基金、指数型基金、混合型基金或房地产这类高风险高收益的投资品种上。这类高风险高收益的权益类投资标的我给出的建议如下：</p><ol><li>投资前至少要学习基本的知识，如果你没有经过较系统的学习进而形成自己的投资体系，那么还是轻易不要碰。这一类投资并不像普通人想的那样，不就低买高卖嘛，不是有脑袋就行，其实股票投资也是一件非常专业的事情。虽说入门门槛低，但是想要在股市中不亏钱且能赚到钱，最终拼的还是专业知识和心态。那么如果你也想在你的资产组合中加入一部分高风险高收益投资，那么我希望您就一定要首先认清自己的风险承受能力来确认适合投入的比例。如果我们每天就着这波动曲线睡不着觉，无法安心上班工作那岂不是得不偿失？其次确定了投入资金比例后，我希望您能先学习一些基本的知识。这里给我的公众号FIRE定投打个广告，那里有丰富的基金实盘为你指点迷津，拿出一小部分钱一边学习一边实践，毕竟市场才是最好的老师嘛。</li><li>相比股票和房地产指数或混合型基金更适合，对于非专业非全职的投资者来说，交易股票并不是一件容易的事情，资金门槛高不说，需要花费很多精力盘寻找买卖时机点，对于上班族来说哪有这样精力呢。房地产投资需要的资金量就更大了，且一般房地产投资的周期会更长，但是就目前国内房地产升值空间来看，也知道国内房地产的投资价值并不高，在国家房住不炒的政策下，除了人口流动性非常强的一线城市还能维持小幅上涨外，二线城市都已经出现不同程度的下跌了。在房子升值空间不大的前提下，靠租金收入来创造收益显然在中国也是不太可行的方案，国内房子租售比奇低也是出了名的，至少目前国内的房地产投资价值已经被压缩的相当低了，激进地说是完全没有投资价值了，那么对于普通投资者相对更适合的应该就属股票类基金了，特别是指数基金。尤其是<strong>场外基金</strong>不需要交易只需要申购和赎回，每天只是按照当日收盘价来计算净值，职场人不需要盘找买卖时机，让投资变得相对更省心不必分散主业过多的精力。</li></ol><p>最后我想聊一聊如何根据自身情况调整稳健固收类资产和高风险权益类资产配置比例。下面的表格是我为不同类型投资者提供的配置比例建议：</p><center><img src="https://img2023.cnblogs.com/blog/2609360/202310/2609360-20231002211336174-951124086.png" style="zoom:60%" /></center><p>保险类投资者应该更多选择稳健类资产，所以建议债券型基金的比例在80%-90%之间，股票型或混合型基金比例建议在10%-20%，这样整个组合的稳定性较高达到稳健增值的效果。相反激进型投资者可以更多配置权益类资产，博取更高的收益但是也需要承担更大的短期波动，建议激进型投资者配置70%~90%股票型或混合型基金、10%-30%的债券型基金。而谨慎型、稳健型、进取型投资者的配置比例可以介于两者之间。参考表格上的建议，大家可以根据自己的风险承受能力来选择合适的比例。</p><p>上面对标普家庭资产配置象限图做了非常详细地介绍，我在最开始就提到过这个家庭资产配置方法，又被很多人俗称为“家庭资产配置的四笔钱”，我自己目前就在使用这样的配置方法来管理自己的钱，也同时在替我的父母打理着他们的资产。我认为上面的配置只是为大家提供了一种模板和思路，而每个人都可以在它的基础上做出适合自己的调整或者修改，我建议大家能够理解后并灵活使用。根据自己的财务状况调整出最适合自己的家庭资产配置方式。</p><p>就我而言我在这四笔钱的基础上做了调整，行生出更适合自己4+1笔钱配置策略，其中的+1意味着我每年都会从我的收入或者资产中，预留出5%左右用于对身体和头脑的充电，包括去健身房健身买一些理财类或者其他类型的书籍来阅读、定期去做身体健康检查等这一类花销。投资自己的健康和头脑是最稳赚不赔的投资，最近身体出了一些小毛病让我愈发地认识到了健康的重要性。有一句话我觉得说的非常有道理：健康的身体是1，而工作或投资赚来的钱都是1后面的0，有了这个1后面的0自然是越多越好，但是如果没了这个1，后面的0再多也是徒劳，希望大家都能够身体健健康康的，理解并合理利用上面介绍的家庭资产配置方法，最大化地让资产增值让你的钱也能为你工作。</p><h4 id="2-3-指数基金介绍与分类"><a href="#2-3-指数基金介绍与分类" class="headerlink" title="2.3 指数基金介绍与分类"></a>2.3 指数基金介绍与分类</h4><p>这一节聊一聊我们最主要的投资标的 —— 指数型基金，让我们能从多种角度全方位地了解各类指数基金的特点，进而我到更适合自己定投的那种指数基金。</p><h5 id="2-3-1-什么是指数"><a href="#2-3-1-什么是指数" class="headerlink" title="2.3.1 什么是指数"></a>2.3.1 什么是指数</h5><p>投资指数基金前我们得先弄明自什么是指数吧，其实通俗地讲<strong>指数就是具有某种共同特征的一篮子股票</strong>，通常这一篮子股票组合到一起就能很好地反映一个市场上特定领域或是整个市场的行情走势，例如沪深300就是由A股的300支市值最高、流通性最好的股票组成的一个指数，拥有这样特征的沪深300自然更能很好地反映大盘股（大型企业）的行情走势。</p><p>接下来我们继续深剖什么是指数基金，指数基金顾名思义就是以特定的指数 —— 例如沪深300、中证500等 —— 为投资对象的基金产品。基金经理通过购买该指数的全部或部分成份股，来构建投资组合，以追踪指数表现的基金产品。多数指数基金只是被动地跟踪某个指数，不加入任何人为的干预，所以指数基金又经常会被称为被动型基金。</p><h5 id="2-3-2-指数基金分类"><a href="#2-3-2-指数基金分类" class="headerlink" title="2.3.2 指数基金分类"></a>2.3.2 指数基金分类</h5><p>随着市场上的指数基金越来越多，其实挑选指数基金的难度也越来越大了，而且指数基金的类别也不少，彼此之间差别还不小，所以投资者在挑选指数基金前首先应该搞明白，哪种类型的指数基金才是最适合自己的。这部分我就好好地介绍一下指数基金的几种分类方法。</p><p><strong>（一）根据行业覆盖范围</strong></p><p>第一种分类方法是根据行业覆盖范围，根据行业的覆盖范围的不同指数基金又可以被分为：<strong>宽基指数基金</strong>和<strong>窄基指数基金</strong>(我习惯称其为行业指数基金)。宽基指数的编制规则一般不区分行业，只要符合编制规则的任何股票都可以被包含进去，因此通常覆盖的行业范围更广，可以更好反映大盘、中小盘、创业板等市场的整体行情。例如：沪深300指数的成分股只要市值和流通性达到A股的前300名这一标准就可以被纳入指数，不会考虑成分股属于哪个行业。行业指数的成分股一般只集中在某一个特定的行业，挑选时只会在某个特定的行业中，选择符合编制规则的股票，目的就是更好地反映某个特定行业的行情走势。例如：中证白酒指数就是只选取涉及白酒生产业务，相关的上市公司股票作为成分股，所以它就反映了白酒行业的发展情况。</p><p>其实行业指数其实还可以进一步被分为一级、二级和三级行业指数，主要评判标准就是根据行业细分的程度，例如：食品饮料就是一级行业指数，而白酒行业指数就是在食品饮料行业基础上进一步细分从而得到的二级行业指数。那么总结起来我们能够直观的感受到，行业指数要比宽基指数的风险要更高，高出的部分在于选择的风险，因为我们无法得知自己是否选择的行业是否近期或者未来会发展良好，行业指数的表现就会比较极端。而宽基指数覆盖的范围更广所谓东边不亮西边亮，这就降低了选择行业的风险，但是只要你能选对行业，行业指数可能获得的收益自然也会高于宽基指数。同样的道理越细分的行业，风险自然也越高可能获得的收益自然也越高。例如：沪深300、中证主要消费和中证白酒中都包含贵州茅台等这样白酒企业的股票，那么白酒行业近两年发展的非常好，自然是只包含白酒企业的中证白酒指数涨势最好，其次是消费，最后才会是沪深300。反之白酒行业不景气的话，业绩最差的自然会是中证白酒，其次消费最后才是沪深300。</p><p><strong>（二）根据投资策略</strong></p><p>第二种分类方法是根据投资策略区别，按照投资策略的不同，指数基金又能被分为<strong>完全被动型指数基金</strong>和<strong>增强型指数基金</strong>。</p><p>完全被动型指数基金的基金经理，一般在留出小部分周转现金后，会把剩余的全部资金完全拷贝该指数的成分股及其对应比例进行配置，力求控制跟踪误差在一个小到可以忽略的程度。所以这种类型的指数可以视为完全地拷贝指数，不掺杂任何人为影响，指数涨基金就涨，指数跌基金也会跟着跌。我有时会在指数基金的评论区看到一些亏钱的投资者，去责怪基金经理能力不行，那么这样的人就是没有明白指数基金的特点，就是排除了人为因素，涨跌完全是由投资者选择的指数决定的，基金经理真是人在家中坐锅从天上来。</p><p>增强型指数基金一般在跟踪指数的大前提下，加入少量人为的调控。例如在在可预见的下跌市场中，适当降低仓位来降低损失，或者在指数中只挑选优质的成分股而不是完全复制指数，人为地调整指数各个成分股的配置比例，又或者在市场行情好的时候适当加一点杠杆等。我们不能说增强型指数基金就优于完全被动型，增强型指数基金在厉害的基金经理的管理下，确实会带来超额收益但是同样又为我们带来了另一个难题 —— 如何选择基金经理？能选对好的基金经理自然是好，那么如果选错了基金经理很有可能会带来反向效果，所以选择增强型指数基金时就不只是挑选指数了，同时还要考虑基金经理的投资风格，无形中又增加了一层选择的难度。例如有的基金经理就喜欢加点杠杆，那么这个基金的涨跌自然都会被放大，涨跌幅会比完全被动指数基金要大一些，那么市场好的时候你自然高兴，市场不好的时候比同类型基金亏得多你能不能接受呢，这也是需要考虑的问题。</p><blockquote><p>其实我个人是不太喜欢选择增强型指数基金的，既然都要选择基金经理，我要是具备了选择优秀基金经理的能力，我为什么不去选一个完全主动型基金呢。</p></blockquote><p>主动型基金其实也会有一个对照基准，也是在某个框架下进行选股。但是基金经理的操作灵活度比增强型指数基金的基金经理要高很多，我也可以用一些选择技巧去选择出一支优秀的主动型基金，增强型指数基金就被夹在中间很难受。至于如何挑选主动型基金，我会在后面的小课堂内容中和大家聊聊我的小技巧。</p><p><strong>（三）根据交易方式</strong></p><p>第三种分类方法是根据交易方式的不同，交易方式的不同指的是我们经常听的<strong>场内基金</strong>和<strong>场外基金</strong>的区别(这里的场指的是证券交易所)。如果我们想购买或交易场内基金，需要先在券商那里先开一个证券交易账户，然后在交易市场来进行买卖交易，买卖场内基金和交易股票的方式相似，例如：ETF、LOF基金都是场内基金的一种。而场外基金可以在银行柜台、卷商或互联网代销平台上电购，例如：天天基金、蚂蚁财富、同花顺等。场内基金一般可以在二级市场上直接和其他用户进行交易，而场外基金则不能直接进行交易。而是只能向卷商、互联网平台等进行申购和赎回操作。</p><ul><li><p>场内基金的优势有：<br>&emsp;&emsp; ① 可以进行实时交易，价格实时波动，对于擅长寻找交易时机的投资者友好；<br>&emsp;&emsp; ② 场内买卖费率更低，一般费率只有万三0.03%或者万五0.05%，几乎可以忽略不计。</p></li><li><p>场内基金的缺点有：<br>&emsp;&emsp; ① 实时交易、价格实时波动需要实时盯盘，不适合上班族，对于交易水平要求比较高；<br>&emsp;&emsp; ② 流动性问题，当大家都疯抢某个基金时，场内经常会推高价格，出现溢价，这时候买入自然不合算，同理卖出量太大时，也会出现折价的情况，而场外基金只按照收盘价来计算当日基金净值，不会存在折价溢价。</p></li><li><p>场外基金的优势有：<br>&emsp;&emsp; ① 不需要盯盘，适合上班族和新手投资者，因为场外基金每日就一个价格中间波动再大也只是以最终收盘价格来计算净值，上班族完全不需要着价格波动来看，不会分散太多的精力找买卖时间点，你只需要每日收盘前看一眼，判断今天是申购还是赎回就足够了；<br>&emsp;&emsp; ② 场外基金不存在溢价折价的情况；<br>&emsp;&emsp; ③ 可以避免很多非理性操作，有数据可以证明，大多数的散户投资者的操作都是负作用的，场内实时交易反倒给了大家太多操作的便利，场外有时候没办法操作反倒还为大家避免了不少不理性的操作。</p></li><li><p>场外基金的劣势主要有：<br>&emsp;&emsp; ① 操作空间有限，对于那些资深交易老手来说就没法赚到超额收益了，有时候可能盘中价格推的很高，但是收盘前价格又回落下来，这种情况下，场外投资者只能做一个看客；<br>&emsp;&emsp; ② 申购赎回费用高于场内，不过现在有互联网代销平台后，申购费率都是打一折的，费率差的也不多了。</p></li></ul><p>总之我建议关注我的朋友更多地选择场外基金，原因是更加省心更适合上班族和普通投资者，把投资当作副业去做让赚钱变得简单一些，不要分散太多精力影响了主业就不好了。把天天盘的精力放在读书这样的自我提升上收获会更大，而我自己也是这样做的，我个人也是更加偏好场外基金。</p><p><a href="https://www.zhihu.com/question/454328602">什么是指数基金 ，指数是什么意思？ - 知乎</a><br><a href="https://www.zhihu.com/question/23028423">什么是指数基金？ - 知乎</a><br><a href="https://www.zhihu.com/question/346308078">指数基金 与 指数是什么关系？ - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/200885545">“指数基金”中的“指数”到底是什么？ - 桑塔索菲亚的文章 - 知乎</a><br><a href="https://zhuanlan.zhihu.com/p/79381774">基金小讲|指数型基金的“指数”是什么意思？ - 霍霍小哥的文章 - 知乎</a></p><h4 id="2-4-如何筛选指数基金"><a href="#2-4-如何筛选指数基金" class="headerlink" title="2.4 如何筛选指数基金"></a>2.4 如何筛选指数基金</h4><p>前一个节简单介绍了指数基金的几种不同分类方式，相信大家对于指数基金已经有了初步的认识。然而如何挑选出适合投资的指数基金仍然是一件令人头疼的事，那么本节就来聊一聊如何挑选出优秀的指数基金。挑选的过程可以简单分为以下两个步骤：</p><ol><li>确定想要投资的指数；</li><li>从跟踪该指数的基金中进行筛选；</li></ol><p>下面我们来具体地看看每一步都是如何进行的吧。</p><p>首先需要确定想要投资的指数，<strong>挑选指数基金本质上来讲就是挑选指数</strong>，选择不同的指数会导致收益的天差地别，所以挑选出优秀且适合自己的指数是至关重要的，甚至可以说：选择对了指数，你已经成功了七八成了。下面我就为大家讲一讲该如何挑选指数。</p><p>第一步宽基指数还是行业指数，首先需要做出第个扶择是明确该投资宽基指数还是行业指数？这实际上也是对于自己风险承受能力的一种评估。由于宽基指数的行业覆盖范围更广，所以相比行业指数的风险也就更小，一般来说行业指数的波动率会比宽基指数要大不少，因此如果你的投资风格偏稳健，对于波动很敏感的话建议你选择宽基指数；如果你的风险承受能力很强且追求更高的收益，同时愿意承担更大的风险的话，那么你可以尝试选择行业指数。举个例子：假设我是个稳健型投资者，我害怕短期的巨大波动而且我也对哪个行业未来会成为趋势不太敏感，那么我就应该选择宽基指数，并在众多宽基指数中做进一步得选择。相反假如我是一个偏激进的投资者，短期的涨跌并不会太影响我的心态，我追求更高的收益，也愿意承担更高的风险，那么我就可以尝试投资一些行业指数，我可以在评估后从众多行业指数中选择我看好的行业进行投资。当然我们也可以同时投资于宽基指数和行业指数，下面是我总结的一些优秀的宽基指数可供大家选择,</p><center><img src="https://img2023.cnblogs.com/blog/2609360/202310/2609360-20231003084846756-1004309825.png" style="zoom:40%" /></center><center><img src="https://img2023.cnblogs.com/blog/2609360/202310/2609360-20231003085040508-166695504.png" style="zoom:40%" /></center><center><img src="https://img2023.cnblogs.com/blog/2609360/202310/2609360-20231003085133583-1053607380.png" style="zoom:40%" /></center><p>第二步大盘指数还是中小盘指数。经过第一步的选择后如果你决定选择宽基指数的话，那么你需要确定第二件事选择大盘指数还是中小盘指数？大盘指数一般来说成分股都是些市值比较大的大盘蓝筹股，优点就是稳定安全性高，缺点是成分股的成长上可能就没那么高了，毕竟一般这类公司都已经到了成熟期，已经过了高速发展的时期。相反中小盘指数的成分股市值都没那公大，大多数公司都处于发展期，成长性要更好些，但是缺点是可能业绩并不稳定，且末来的确定性没那么高，算是一把双刃剑吧。所以在选择指数时自然也需要考虑，是只投资于大盘指数或中小盘指数还是二者同时投资。</p><center><img src="https://img2023.cnblogs.com/blog/2609360/202310/2609360-20231003090246602-514009711.png" style="zoom:30%" /></center><p>第三步指数特点与当前估值。通过上面两个步骤我们进一步缩小了选择范围，接下来就需要清楚该范围内每一个指数的特点和指数当前的估值，来最终确定适合投资的指数。指数的特点我们可以通过查看指数的<strong>编制方案</strong>、<strong>成分股行业分布</strong>、<strong>前十大重仓股特征</strong>、<strong>历史业绩走势</strong>等数据进行判断，这些讲起来比较复杂暂时就不具体展开来说了，我们新推出的指数剖析系列视频，每周会对一个指数进行系统的剖析，感兴趣的朋友加个关注。另外估值也是判断指数目前适不适合买入的重要参考指标，即使你判断中证半导体指数是一个非常优秀的指数，然而凭他目前149倍的市盈率来看，已经处于极度高估的情况了，这也就意味着目前并不是投资该指数的好时机。所以我们在挑选指数时也要参考估值这个指标，并且应该优先选择一些低估或估值正常的指数进行投资，因为这一类指数的安全边际会更高一些。</p><p>当我们选好要投资的指数后，接下来我们只需要在跟踪该指数的基金中，根据某些特定的指标筛选出最合适的基金即可。在筛选基金时一般需要考虑如下几个指标：</p><ol><li><strong>场内基金还是场外基金</strong>，场内基金和场外基金的区别与各自的优缺点，在上一节中做了介绍，一句话总结就是如果你有时间精力盘且对自己的买卖技巧有信心，你可以选择场内基金，否则最好选择更省心的场外基金；</li><li><strong>是否选择增强型基金</strong>？熟悉我的朋友应该知道，我个人是强烈不推荐增强型指数基金的，至于原因在上期我也有提到过这里也不做赘述了，所以个人更推荐选择纯被动型指数基金；</li><li><strong>基金成立年限</strong>，在挑选基金时最好挑选成立超过三年的基金，至少我们可以在过去三年甚至更长的数据中，看出这支基金对于指数的跟踪情况是否良好，如果基金成立年限太短，我们无法判断这支基金能否很好地跟踪指数、抗风险能力如何、跟踪误差是否合理等信息；</li><li><strong>基金规模</strong>，不要挑选规模太小的基金，规模太小的基金存在被清盘的风险，且规模小的基金在面临大额赎回时也可能出现暴跌的风险，建议挑选基金规模在2亿以上的基金；</li><li><strong>跟踪误差率</strong>，在我们做被动投资的时候，自然是希望对指数的跟踪误差越小越好，判断一个指数基金的好坏的关键甚至不在于收益率而是跟踪误差率，误差率越小说明基金运作水平高能很好地复制指数，我们应该选择误差小于0.2%的基金，能小于0.1%更好；</li><li><strong>基金的运作费用</strong>，运作费率主要分为三个部分：管理费、托管费和销售服务费，运作费率自然是越低越好了，运作费率越低意味着成本越低。</li></ol><p>最后我们来概括—下整个选过程：</p><p>&emsp;&emsp; <code>Step 1</code> 对自己的风险承受能力进行评估，决定投资偏稳健宽基指数还是偏激进的行业指数。<br>&emsp;&emsp; <code>Step 2</code> 如果选择宽基指数，进一步选择是投资大盘基金还是中小盘基金，抑或是同时投资于二者；如果选择行业基金，进一步判断是投资于更偏防御的消费类指数，还是更偏进攻的科技类指数。<br>&emsp;&emsp; <code>Step 3</code> 时刻关注所选指数的估值情况，等待时机，低估时分批买入，正常估值时继续持有，高估是分批卖出。<br>&emsp;&emsp; <code>Step 4</code> 根据上面提到的一些列指标对跟踪指数的基金进行筛选。</p><p>今天为大家介绍了一种挑选指数基金的通用方法，由于篇幅限制有很多地方没有进行详细的讲解，我希望为大家提供的是一种挑选思路，或者说是一种框架大家在实际挑选的过程中，可以在大框架下更灵活的去应对不同的情景，当然大家也可以根据自己的习惯对这个方法进行改善，形成自己的指数基金挑选方法。另外在今天的文章中提到了很多优秀的指数，既包括国内外的宽基指数，也包括很多优秀的行业指数，我都会在指数剖析系列视频中进行更详细地剖析与解读。</p><h4 id="2-5-定投的概念"><a href="#2-5-定投的概念" class="headerlink" title="2.5 定投的概念"></a>2.5 定投的概念</h4><p>有对指数型基金较为全面的了解，这一节就来讲一讲定投 —— 这个最适合普通投资者的投资策略。让我们—起探索这样的问题，该以什么样的心态去开始定投？定投策略多种多样，哪种更适合自己？</p><p>在开始定投前我们一定要清楚，该以什么样的心态去使用这一投资策略，只有提前做好心态建设，才有能在面临账面浮亏时不被恐惧支配，在漫长熊市中不失去耐心，很多人可能只看到过网上各种鼓吹定投优点的文章，而并不清楚使用定投策略投资的难点是什么，就开始贸然开始定投，那么当出现困难或长时间浮亏时自然是很难坚持下去。为了避免这些情况发生，我希望在开始讲定投策略前先和大家聊一聊，我们该以什么样的心态开始定投这一话题。</p><p>首先第一点要明白定投不是万能的，理性地讲现在网上的很多文章有点过于神话了定投，多数文章只谈论定投的优点却对定投的局限只字不提。我们应该明白一件事，定投只是万千投资策略中的一种而已，定投有它适合的场景也有它的局限所在，它并不是万能的不要强搬硬套，那么定投究竟适合哪些场景呢？我的总结如下：<strong>增量资金才适合做定投存量资产做定投并不合适</strong>。增量资金可以简单地理解为工资，而存量资产可以理解为我们当前持有的存款。而对于存量资产，例如我现在手里有10万的存款想去投资，这个时候就不太适合做定投了。我看到有些文章会推荐把10万的存量资金分成几十份，然后每个月一份地投入进去，这样的做法你仔细想一想就会感觉很别扭，问题就在于我们无法预测市场什么时候会迎来牛市。看历史数据去推测投资周期显然是不靠谱的，定投的最佳周期就是不设周期，牛市来了止盈时才意味着一轮定投结束，另外这样做也无法最大化利用资金，一份一份投入的过程中，剩下的资金完全没有利用上，所以存量资产并不适合做定投。我更推荐类似股债平衡、全天候交易策略等这样的资产配置策略。</p><p>其次第二点是以零存整取的心态定投，这个心态很重要。其实我们简单地类比就会发现，定投在形式上就十分类似于我们熟悉的<strong>零存整取</strong>，零存整取是每月或每周存入一定的金额，等到存够几年或者存够某个数额后一次性取出，而<strong>定投是每月或每周(即定期)买入一定金额的基金</strong>，等到牛市达到某个收益后卖出落袋为安。所以<strong>熊市攒份额、牛市赚收益</strong>这才是定投该有的心态。在熊市中不要过于在意定投期间的浮亏浮赢，因为这些都只是暂时的状态而已，跌的越多我们反而更应该开心，因为这时我们以同等的投入可以买到更多的份额，进一步摊低我们的平均成本。在牛市到来时反而会为我们带来更高的收益。总之在定投的过程中一定不要在太在意浮亏浮盈，不要中途放弃，用零存整取的思维去使用定投这一策略。</p><p>第三点只投长期不用的钱，刚才提到过定投的最佳周期就是不设周期，这是因为我们很难预测牛市到底什么时候会到来，利用历史数据去推测的投资周期也没什么实际意义，所以我们在做定投的时候一定要保持长线思维，做长线投资最好不要拿短期可能要用的钱来定投，保守估计怎么也得是拿未来5年以上大概率不会用到的钱来进行定投。还是那句话我们无法预测市场，试想如果你预估市场在3年后迎来牛市，所以你拿了3年后要使用的钱来定投，而最后没能如你所愿3年后市场仍在下跌，这时如果你急看用钱那不是只能“忍痛割肉”，而其实牛市也就维持三四个月来的快去的也快，万一你前脚刚割肉套现后脚牛市就来了，岂不是白白浪费了三年的精力了。所以为了避免这样的情况发生，我们在定投时最好只拿我长时间不会用到的钱，保持长线思维耐心，等待时机到来，而不是长期不用的钱完全可以使用其他的短线投资策略。</p><p>完成了定投前的心态建设，接下来先一起了解几个常用的基础定投策略吧。一般来说使用定投策略时存在三个变量分别是：<strong>投资间隔</strong>、<strong>投资金额</strong>、<strong>投资标的</strong>。根据这三个变量是否改变衍生出下面几种常见的定投策略：</p><ol><li><strong>定期定额固定标的</strong>，这是最简单最纯粹的一种定投策略，即每月或每周的固定一天，拿出固定的金额买入固定的一支或几支基金。最大的好处就是省心，不需要考虑太多额外的因素，是真正的懒人投资法，而且我们可以在互联网代销平台上设置好定投日期、金额和买入标的后自动执行，到了定投日期就会自动扣款，最适合精力有限的上班族和刚开始接触定投的小白投资者，但是你就不能期望这种定投策略能为你带来什么超额的收益了，属于完全依赖市场行情的一种投资方式，自然只能赚个市场的平均收益了，一轮牛熊过后年化收益率还是能达到10%上下的。</li><li><strong>定期不定额固定标的(智慧定投)</strong>，这种定投策略很受欢迎被多个基金代销平台重点宣传，这种定投方式的核心思想是：在指数越低估的时候定投的金额越多，相反在高估的时候减少定投金额，实现低位加更多的仓位来低成本。现在在各个基金代销平台上，也可以通过一键设置自动执行这种定投策略，系统到了定投日会通过评估后计算出当期投资的金额并自动完成扣款，你只需要保证账户余额充足即可。智慧定投相比定期定额的方式,优点在于可以在低价时买入更多份额把成本进一步拉低，从而在牛市中带来超额涨幅。然而需要注意的是，我们必须要保证扣款日账户的资金充裕，增加后的金额超过了我们的账户余额的话会导致扣款失败，另外如果你每个月只能拿出固定的金额来定投的话，这种弹性变化的方式显然就不适合你了，增加后的金额有可能达到无法承担的地步。</li><li><strong>定期定额不固定标的</strong>，是我目前用的比较多的定投策略，并且我们公众号基金实盘中，指数周定投子账就是使用了这样的定投策略，它的优点就在于可以每周挑选出最低价合适的基金定投，尽量保证每笔定投都投资于当时相对低估的基金，成本都保持最低，可以让你的账户即使在漫长熊市中，也不会出现大幅损能达到稳定心态的作用；缺点就是相对来说更耗费精力，因为相比前两个策略更复杂些，目前没有哪个平台是支持自动化实现这种定投策略的，但是你可以跟着我们的公众号FIRE定投的实盘展示来投，所以只能手动进行定投，而且每周或每月都要对基金池中的基金进行评估，不适合缺乏精力的朋友。</li><li><strong>定期不定额不固定标的</strong>，这是对上第三种定投策略的一种优化，每期投资的基金依旧是不固定的，并且每期投资的金额也不再固定了，而是根据市场的倩值高低进行调整，举个例子：在大盘3000点附近的时候保持正常定投，当市场行情不好掉到2800点的时候增加定投金额，买入更多低价份额，相反行情很好达到3200点以上就减少定投金额。</li><li>其他定投策略，还有几种不固定定投日期的定投策略，由于操作起来复杂度更高，我觉得不太适合普通投资者也不常被大众所使用，我就不做详细的介绍了。</li></ol><p>上面为大家介绍了几种定投策略，有的朋友可能会疑惑自己适合什么样的定投策略。首先大家需要简单地评估一下自己可以把多少精力放在研究基金上，如果你本身比较忙没有太多精力去研究基金，只想通过基金定投赚个市场平均收益的话，那么我建议你选择最简单最省心的方式，定期定额固定标的，你只需要在蚂蚁财富或者天天基金上选择1~3支指数基金，设置好每周或每月的定投日期，每期的定投金额，就可以不必再理会，保证你的账户在扣款日有充足的余额即可。相反如果你有精力且愿意每周或每月拿出一定的时间，来研究基金的各种指标，进而选择出当期最合适的投资的标的的话，我建议你可以使用下面这种我经常使用的定投方案，在我看来挑选指数基金和挑选股票是一样的道理，只需要遵循下面两个步骤：</p><ol><li>分析并挑选出有前景的优质指数构建优质指数池；</li><li>等待合适的估值或价格时买入；</li></ol><p>首先我们看如何构建优质指数池，经过对大量指数的历史业绩进行测算，我发现指数的优劣是影响定投收益高低的一个非常重要的因素，选择一个优秀的指数和选择一个平庸的指数分别进行定投，最终的结果将是云泥之别。通过分析各指数的编制特点和成分股特征，进而从众多指数中挑选出几支或者十几支长期表现优秀的指数构建属于自己的优质指数池，以后定投时只从指数池中挑选适合的指数，尽管前期构建指数池的过程比较复杂，需要耗费不小精力，但是指数池构建完成后定投就变得更加简单且明确了，而挑选优秀指数并构建指数池的过程，我们帮你做了，大家可以查看文章优秀指数池来参考FIRE定投的指数池，公众号也会不定期对指数池进行更新。另外公众号每周更新的优质指数剖析系列，文章会更详细全面地对每一个优秀指数进行分析，让你更全面的了解每一个投资标的，成功地构建了指数池后就可以开始我们的定投了，公众号实盘的定投采用的是周定投的策略，每周四定投500元，通过综合评估指数池中各指数的估值，持仓占比等几个指标，选出1~3支指数相应的基金来定投，并把这500元按照一定比例进行分配。</p><p>本期的话题是定投策略，既介绍了定投开始前该有的心态建设，同时介绍了几种经常被使用的定投策略和它们适用的人群。最后，为大家推荐了一种我常用的策略，希望本节内容让大家对于定投有一个更加全面的了解。</p><h4 id="2-5-A类基金与C类基金的区别"><a href="#2-5-A类基金与C类基金的区别" class="headerlink" title="2.5 A类基金与C类基金的区别"></a>2.5 A类基金与C类基金的区别</h4><p>不少刚接触基金投资的朋友心中都会存在一个疑惑，同一个名字的基金后面经常跟着A或者C，那么A类基金和C类基金它们有哪些区别呢？到底选择哪种来投更适合呢？</p><h5 id="2-5-1-A与C到底有什么区别"><a href="#2-5-1-A与C到底有什么区别" class="headerlink" title="2.5.1 A与C到底有什么区别"></a>2.5.1 A与C到底有什么区别</h5><p>要想弄懂该选哪一个，我们首先需要搞明白它们到底有哪些区别。我们在投资基金的时候需要承担的费用大体上可以分为三种分别是：<strong>申购费</strong>、<strong>基金运作费</strong>和<strong>赎回费</strong>。而A类基和C类基金之的区别就是围绕着这三种费率展开的。</p><p>&emsp;&emsp; ① 先说申购费，一般来说只有A类基金收取申购费，C类基金一般都是免申购费的。A类基金的申购费率一般在0.8%-1.5%之间，如果是在互联网平台，例如天天基金、支付宝等进行申购的话，申购费率可以打一折(即0.08%-0.15%)。</p><p>&emsp;&emsp; ② 运作费率往往又可以分为三个部分：<strong>管理费率</strong>、<strong>托管费率</strong>和<strong>销售服务费率</strong>，相同名字的A类和C类基金，一般来说二者的管理费率和托管费率都是相同的，二者之间唯一的区别在于销售服务费，A类基金免销售服务费，只有C基金收取销售服务费，至于收取多少则完全由基金公司决定(大多数的C类基金的销售服务费处于0.1%-0.8%之间)。另外还需要科普的点是，这里提到的销售服务费都是年费，会被均分到每一个交易日进行扣除，每一个交易日最终更新的净值是已经扣除掉销售服务费了的。所以我们往往也能看出同一名字的A类和C类投资标的相同，但是往往业绩表现会略有差异，A类一般会略高于C类基金。更细心的朋友会发现，一般来说每年相差的，刚好接近于这部分销售服务费。</p><p>&emsp;&emsp; ③ 二者在赎回费上也会存在不小的差异。首先所有场外基金持有时长低于7天，赎回费率都是1.5%。这是为了避免投资者过于频繁交易，大多数C类基金持有满7天或者1个月后赎回费都会清零，对持有时长的限制比较小、赎回门槛相对低一些，所以赎回相对更加灵活。而A类基金一般会分成几个档次，根据投资的持有时长来决定赎回费率，多数基金维持这样的一个规律，持有少于30天的赎回费为0.75%，大于30天但少于1年赎回费率为0.5%，大于1年但少于2年的赎回费率为0.25%，超过2年赎回费清零。当然上面提到的只是一般情况，并不是所有的基金都遵循这样的规律，所以大家在购买基金前一定要先了解清楚基金的三种费率再做决定。另外注意基金的持有天数是按照自然日而不是交易日来计算的，也就是周末和节假日也是计算在内的。</p><h5 id="2-5-2-到底该选A还是选C"><a href="#2-5-2-到底该选A还是选C" class="headerlink" title="2.5.2 到底该选A还是选C"></a>2.5.2 到底该选A还是选C</h5><p>上面了解了A类和C类基金费率上的区别后，我们或多或少能看出A类和C类基金分别是为哪类人群设计的。A类基金赎回门槛设置得比较高，运作费率比C类要低，可以看出A类基金是鼓励投资人长期持有的，他们希望投资人的投资周期在2年以上，持有基金两年以上的话就能相较C类基金省去两年的销售服务费；而C类基金则是为短期投资者而设计的，没有申购费用并且降低了赎回门槛，可以让投资人更灵活地使用资金进行中短线操作，作为代价基金公司额外收取一定的销售服务费。</p><p>上面对A类和C类基金费率之间的区别做了比较详细的介绍，现在我们就来聊一聊投资过程中到底投A类基金更好还是投C类基金更好吧。首先有两种情况肯定是母庸置疑的了，如果你计划短线持有，例如只持有1个月或者半年，那么你可以毫不犹豫地选择C类基金。相反如果你计划次性买入并长期持有超过两年的话，那你也可以毫不犹豫地选择A类基金。唯一个值得纠结的点就是定投，定投某只基金时到底是选择A类基金还是C类基金好呢？数据就不列了，直接说结论吧：理论上来讲，一般定投周期超过26个月，定投A类基金相对更合算且时间越长越合算，低于26个月定投C类基金相对更合算。但是综合来看我会推荐大家优先选择，C类基金来定投主要原因有两个：</p><ol><li>C类基金申赎更灵活，资金利用率高。一般来说定投的周期不是固定的，完全取决于牛市什么时候来，有时候可能刚开始定投几个月就迎来了牛市，有的时候可能定投了3年以上才迎来牛市，我们很难在刚开始定投时就判断出牛市何时会来，也不清楚手中的基金定投多久会止盈卖出，选择申赎更加灵活的C类基金，牛市来临时可以不必过多地受到电赎手续费的限制，想止盈卖出随时都可以。</li><li>定投是分批买入，持有时长有长有短，很多人宣传基金要长期投资，定投应该选择更适合长期持有的A类基金，然而这种思维有一个误区，那么你的资金就是一点—点分批投进去的，最终止盈时持有时长也是有长有短的，所以赎回时A类基金还是要支付部分赎回费用的。选择A类基金定投，不仅性掉了资金的灵活性，最终算下来也不见得比C类低，赎回时心态上投资者更难接受，因为止盈卖出时还得支付赎回费。所以综合来看，定投选择C类基金会更适合一些，可以更加灵活地面对多变的行情。</li></ol><p>我建议可以优先选择C类基金来定投。最后需要提醒大家，上面的所有解释说明都是基于绝大多数基金的，市面上至少有80%以上的基金符合这样的规律，但是也有部分基金的费率设置与一般情况略有差别，例如中欧医疗健康混合A和C，二者的赎回费率设置得完全相同，C类比A多0.8%的年销售服务费，A类比C类多0.08%的申购费。如果是这样的设置，选A就比选C更合适了，中欧医疗显然不是上面提到的大多数情况。所以建议大家在申购基金前，还是要先了解一下A类与C类的这三种费率的差别后再做出最合适的选择。</p><table> <tr> <td style="word-wrap: break-word; word-break: break-all; width: 100%; background-color: HoneyDew;"> <span style="font-size: 16px;"> <strong>视频看到这里，简单梳理一下几个小知识点：</strong> </br><strong>(1) 上证指数是什么？</strong><sup>[1.1、1.2、1.3]</sup></br>上证指数俗称大盘，是中国股市里历史比较悠久的指数，另外深市的大盘叫深证成指。还有些中小盘指数如沪深300、中证500、中证1000等。“上证”就是上海证券交易所，“指数”代表的是某一类证券或者具有某一些共同特征的证券的(加权)平均价格走势情况。对于一个普通的投资者而言，我们对于某一只或者某几支具体股票的价格变动情况是可以了解的，但是面对几千只股票的价格变化，要逐一的去了解非常的不容易。因此编制成一个指数，指示整个市场的涨跌情况。</br>上证指数就是体现上海证券交易所2000支股票的整体涨跌情况！</br><strong>(2) 欠条属于证券吗？</strong><sup>[2.1]</sup></br>广义上来说，欠条属于证券。但狭义上，欠条不属于证券。造成狭义广义不同的原因是：证券要求能在公开市场上转让，一般你手里持有你朋友的欠条在市场上是卖不出去的，当然广义(理论)上是可以交易的。</br><strong>(3) 货币基金和银行存款区别？</strong><sup>[3.1]</sup></br>银行存款（存单）不属于任何理财性质的产品，包括基金、债券等，都不是。银行存款简单讲就是你把钱放在银行那里，银行给你利息，银行用你的钱再借给需要钱的人，需要借钱的人再付给更高的利息给银行，银行则通过你的钱出借赚取利息差。银行存款绝对安全，本金不会亏本，但是**不一定跑得过物价指数**。</br>银行存款并不属于货币基金，两者区别包括：货币基金不保本不保息，但风险极低，银行存款保本保息，资金最安全；货币基金的收益较银行存款高，而资金的灵活性为活期存款高于货币基金高于定期存款。</br><strong>(4) 上证指数和单支股票的区别？</strong><sup>[4.1、4.2]</sup></br>指数是指若干个股票加权产生的一个值，简而言之，一个股票的表现就是一个股票，一群股票的涨跌就是指数，掌握了大部分股票的涨跌就差不多了解了一个指数，掌握了一个版块类股票的涨跌就了解了一个版块指数的涨跌，你越了解企业，越了解更多企业，就越了解指数，就越了解更多指数。</br>一个指数包括的股票越多，越杂就准确度越差，越笼统，一个指数里面的股票越少，分类越准确就准确度越高。因为指数内各个股票的权重不一样，所以指数的涨跌，并不能完全的反应指数内大部分股票的涨跌状态。所以单纯用指数来判断个股行情，是一个效率不太高的事情。</br><strong>(5) 跟踪误差的概念？</strong><sup>[5.1、5.2、5.3]</sup></br>跟踪误差是指基准收益率与投资组合收益率之差的收益率标准差，反映了基金管理的风险。基金的跟踪误差主要是看基金和跟踪标的之间的偏离程度，一般用于ETF基金中，因为ETF基金主要跟踪的是指数，目的在于取得和指数相同的收益。一般跟踪误差一般越小越好，越小代表基金和跟踪标的的走势越接近，这样才能取得与所跟踪指数几乎相同的收益。</br>指数基金在设立之初的概念上就是以跟踪的指数为标，并以该指数的成分股为投资对象，通过购买该指数的全部或部分成份股构建投资组合，以减小跟踪误差为目的，使投资组合的变动趋势与标的指数相一致，以取得与标的指数大致相同的收益率。在选被动型指数基金或者ETF的时候，我们通常会选择跟踪误差较小的基金，那么既然是完全复制跟踪标的成分股就连配置权重也是一样，为什么还会有跟踪误差？其原因大概有：(1)管理费用及其他各项费用、(2)复制误差、(3)现金拖累等，详细请参考链接。</br><strong>(6) 跑赢指数什么意思？</strong><sup>[6.1、6.2]</sup></br>跑赢上证指数的意思是，基金上涨的比例比上证指数上涨的比例高，或基金下跌的比例比上证指数下跌的比例低。也就是说明持有人的股票和基金表现好。</br><strong>(7) 牛市和熊市是什么意思？</strong><sup>[7.1、7.2]</sup></br>牛市（Bull Market）：牛市是指股票市场价格上涨并且投资者信心较高的市场行情。在牛市中，股票价格持续攀升，交易活跃度增加，市场氛围乐观。这种行情往往伴随着经济增长、企业盈利好等积极因素，投资者普遍认为市场前景看好，纷纷购买和持有股票。牛市通常伴随着高涨的股价、较大的成交量以及市场上升趋势的延续。</br>熊市（Bear Market）：熊市是指股票市场价格下跌并且投资者信心较低的市场行情。在熊市中，股票价格普遍下跌，交易活跃度减少，市场氛围悲观。这种行情通常伴随着经济衰退、企业盈利下滑等不利因素，投资者普遍对市场前景持谨慎态度，纷纷卖出股票或观望。</br>牛市和熊市的转换往往与市场的周期性波动相关，其间时间长短不定。一般来说，在牛市中，投资者可以通过买入股票获得较好的收益，而在熊市中，投资者则需要保持谨慎态度，采取适当的风险管理策略。同时，牛市和熊市都是股票市场正常运行的一部分，投资者应该具备较为全面的市场知识，从而更好地适应市场的变动。</br>简单一句话：<font color=red>牛市代表价格上涨、投资者信心高涨的市场，而熊市则代表价格下跌、投资者信心低迷的市场</font>。</br><strong>(8) 基金分额、单位净值、累计净值是什么意思？</strong><sup>[8.1、8.2、8.3]</sup></br>以包子举例，把一屉包子比作你购买的一支基金，则一屉包子的个数 $\Longleftrightarrow$ 基金份额，包子单价 $\Longleftrightarrow$ 基金净值。基金份额是基金的计量单位，基金净值一般指单位净值(每份份额值多少钱)，而累计净值是指基金单位净值与成立以来分红业绩的总和(即基金自成立以来所取得的累计收益总和)。</br>通常来讲：</br>$$单位净值 = \dfrac{总资产}{总份额} \qquad 你持有某支基金总资产 = 持有份额 \times 最新单位净值$$$$累计净值 = 单位净值+成立以来分红业绩$$注意：每只基金的初始净值都默认为1。</br>有些基金单位净值等于累计净值，有些却不一样，这主要是考虑到**基金的分红和拆分**。基金分红就是把部分盈利返还投资者，净值也会做相应的扣除。而基金拆分就是把份额等分，一份变两份或多份，但基金的念资产不会变，所以份额的成倍增加会导致净值相应缩小。</br>所以判断一只基金历史业绩的好坏，不能看单位净值，而要看累计净值。如果要计算自己账户的盈亏，就需要用你持有的份额数量乘以最新单位净值后再减去你的买入金额就好了。</br>$$账户盈亏 = 持有份额 \times 单位净值 - 买入金额$$最后还有一点要注意，有过分红的基金累计收盆率和累计净值会略有不匹配，这主要是因为该基金是按照红利再投资计算的结果，这是一种把分红作为本金再次进行投资的方式，体现的是**复利增值收益**。</br><strong>(9) 基金回撤是什么意思？</strong><sup>[9.1、9.2、9.3]</sup></br>基金回撤是指基金净值在一段时间内从高点回落的幅度。也就是说，当基金净值经历一段上涨后，由于市场的调整或其他原因，基金净值会出现下跌的情况。回撤通常用一个负数表示，表示净值的下降幅度。回撤的程度和时间长短可以反映基金的风险程度和抗风险能力。</br>举个栗子，假设今年2月你在天天基金网买入一只新发基金，最初净值为1.00元，到今年8月，净值涨到1.50元，你获得了50％的回报。于是你推荐小伙伴也来买，他在净值为1.50元的时候听了你的话大量买进，但在接下来的一段时间内基金价值急速回落，下降到1.25元。对你而言，基金此时依旧有25%的回报率，可对你小伙伴来说就很残忍了，反而亏损了16.67%。这16.67%就是**这一段时间的基金最大回撤率**。</br>直观上理解，基金回撤就是价格下跌，但有个限定范围也就是一段时间内，基金净值下跌的幅度，所以划定的时间不同基金回撤的大小也是不同的。</br><strong>(10) 开盘、收盘是什么意思？</strong></br>股市里在一个交易日里，当天股市开始交易叫作开盘，停止交易叫做收盘。国内A股，沪深股市的开盘时间是上午9:30，中午11：30暂停交易，下午13：00继续交易，至15：00收盘。因此，每个交易日的交易时间是4个小时。</br> 股票开盘价是指股票开盘时的价格，也就是9:30的价格，股票收盘价是指收盘时的价格，也就是15:00的价格。</br>股票开盘价和收盘价是由集合竞价产生的，集合竞价时投资者可以自由地进行买卖申报，系统对有效的委托进行撮合成交，成交量最大的价位就是当日开盘价和收盘价。开盘价的高低和股票前一日的收盘价、市场环境等众多因素有关，如果开盘价较前一日收盘价较高，通常意味着市场预期股票将呈现上涨趋势，反之则预期下跌趋势，收盘价则是当日股票交易结束时的最后一笔交易的成交价格，它代表了股票交易当日的收盘价格，也是当日交易活动的总结，收盘价与开盘价一样，也受众多因素干扰，包括市场环境、股票基本面、投资者情绪等等。如果收盘价高于开盘价，则意味着股票当日存在涨幅，反之则是下跌了。</br><strong>(11) 股票交易为什么要有时间限制？</strong><sup>[11.1]</sup></br>第一，对投资者进行保护。第二，抑制投机。第三，国内股市的制度不完善，交易时间短不一定是好事。</br><strong>(12) 投资标的是什么？</strong></br>投资标的就是投资的对象，比如投资标的可以是债券、理财、基金、股票、期货、外汇、贵金属等，再比如说基金的投资标的为货币市场工具、债券、股票等。投资者可以根据自身风险承受能力选择合适的投资标的，风险承受能力低的投资者，可以选择债券、理财等产品，风险承受能力高的投资者，可以选择基金、股票、期货、外汇、贵金属等产品。</br>参考1.1：<a href="https://baijiahao.baidu.com/s?id=1700273378929082643&wfr=spider&for=pc" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 指数基金中的指数是啥意思？ - 百度文章 </a> </br>参考1.2：<a href="https://zhuanlan.zhihu.com/p/79381774" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 基金小讲|指数型基金的“指数”是什么意思？ - 霍霍小哥的文章 - 知乎 </a> </br>参考1.3：<a href="https://www.bilibili.com/video/BV1ef4y1J7eR/" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 什么是上证指数? - Bilibili </a> </br>参考2.1：<a href="https://www.zhihu.com/question/21860482" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> [欠条属于证券吗? - 知乎 </a> </br>参考3.1：<a href="http://zhidao.baidu.com/question/504614061/answer/1266460195" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> "银行存单，存款"属于债券型基金还是货币型基金？ - 百度知道 </a> </br>参考4.1：<a href="https://www.zhihu.com/question/345187097" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 股票涨跌和指数的关系是怎么样的，轻指数重个股对吗？ - 知乎 </a> </br>参考4.1：<a href="https://www.zhihu.com/question/345187097" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 股票涨跌和指数的关系是怎么样的，轻指数重个股对吗？ - 知乎 </a> </br>参考4.2：<a href="http://zhidao.baidu.com/question/375777875716553284/answer/3488451929" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 上证指数和具体某个股有什么关系吗？ - 百度知道 </a> </br>参考5.1：<a href="http://fund.yjcf360.com/fundxuexi/920385.htm" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 跟踪误差是什么意思？为什么会产生跟踪误差？ </a> </br>参考5.2：<a href="https://xueqiu.com/8335104578/116001773" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 指数基金中的跟踪误差率是指什么？为什么会有误差？- 雪球 </a> </br>参考5.3：<a href="https://www.zhihu.com/question/30925168" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 指数基金的跟踪误差率是指的什么？ - 知乎 </a> </br>参考6.1：<a href="http://zhidao.baidu.com/question/209215547705636525/answer/4178935827" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 跑赢上证指数是什么意思 - 百度知道 </a> </br>参考6.2：<a href="https://www.csai.cn/jijin/1299723.html" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 跑赢指数什么意思？指数基金跑不赢指数的原因 - 希财 </a> </br>参考7.1：<a href="https://baijiahao.baidu.com/s?id=1777388301665934992&wfr=spider&for=pc" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 股票市场中的牛市和熊市分别是什么意思？ - 百度文章 </a> </br>参考7.2：<a href="https://zhuanlan.zhihu.com/p/560497211" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 牛市与熊市有什么区别 - 一往无前的文章 - 知乎 </a> </br>参考8.1：<a href="https://www.bilibili.com/video/BV1X34y1h7Jr" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 思哲带你3分钟秒懂基金的份额与净值 - Bilibili </a> </br>参考8.2：<a href="https://www.bilibili.com/video/BV1Yy4y167h5" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 一篇看明白基金净值和基金估值|干货|理财|基金 【5分钟基金课|第三课】 - Bilibili </a> </br>参考8.3：<a href="https://zhuanlan.zhihu.com/p/39504986" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 还分不清什么是基金净值？这篇文章告诉你！ - 金贝塔的文章 - 知乎 </a> </br>参考9.1：<a href="https://zhuanlan.zhihu.com/p/369927701" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 手把手教你计算基金回撤率，学起来!~ - 反语的文章 - 知乎 </a> </br>参考9.2：<a href="https://baijiahao.baidu.com/s?id=1765676309365997827&wfr=spider&for=pc" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 基金回撤是什么意思？ - 百度文章 </a> </br>参考9.3：<a href="https://baijiahao.baidu.com/s?id=1693944441848097519&wfr=spider&for=pc" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 小白理财｜一图了解什么是基金回撤 - 百度文章 </a> </br>参考11.1：<a href="http://www.yingjia360.com/gpsy/2022-06-14/61613.html" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 股票开市和收市时间是什么？股票交易为什么要有时间限制？ </a> </br>参考：<a href="https://www.bilibili.com/video/BV1VK4y1W7TN" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 波动率＆夏普比率＆最大回撤分别代表什么意思？ - Bilibili </a> </br>参考：<a href="http://finance.scnjtv.com/finance/2023/0504/76830.html" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 国债利率和国债收益率一样吗？国债利率是无风险利率吗? </a> </br>参考：<a href="https://baijiahao.baidu.com/s?id=1659068459690450247&wfr=spider&for=pc" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 基金一定要卖掉了才算是真的赚到钱么？ - 百度文章 </a> </br></span> </td> </tr> </table><h4 id="2-6-五种止盈方案"><a href="#2-6-五种止盈方案" class="headerlink" title="2.6 五种止盈方案"></a>2.6 五种止盈方案</h4><p>在股市持续上涨时有止盈需求的朋友会越来越多，毕竟账面上的浮亏浮盈只是数字，落入口袋的才是实打实的真金白银嘛。然而很多投资者又会担心如果现在止盈，未来行情继续上涨会错过未来的行情，就开始陷入了纠结之中，那么到底什么样的止盈方式才是最稳健最合适的呢？如何止盈才能有效规避风险的同时还能把利益最大化呢？今天我就为大家科普5个科学有效的止盈方案。</p><h5 id="2-6-1-估值止盈策略"><a href="#2-6-1-估值止盈策略" class="headerlink" title="2.6.1 估值止盈策略"></a>2.6.1 估值止盈策略</h5><p>估值止盈法是一种最简单的止盈方法，可以最大程度地规避掉风险。在指数的估值达到高估时就果断卖出止盈，如果你买入的是主动基金，你只需要考察该基金对标的指数来进行判断估值即可。先来说说它的优点：在指数低估或者相对低估时持续买入相应的基金，在估值达到适中时继续持有，并在达到高估的时候卖出止盈，也就是说只在比较低的点位时买入，只要点位达到相对的高点，就及时卖出绝对不冒一点风险。这样的投资方式通常安全边界会比较高，是最稳健的方式之一。一般指数达到高就意味着它涨到了历史的相对高点了，随之而来的是更高的风险，在这时候止盈可以非常有效地规避风险。但该方法也有缺陷，因为凡事都不是绝对的，并不是低估的指数就绝对安全，也不是说指数高估了就一定会跌，低或者高估是通过计算指数当前估值所处的历史百分位得到的。我们都知道历史数据只能作为参考，并不能完全代表未来的表现，有些行业例如互联网、半导体、计算机等，几乎一直处于高估值的状态，如果使用估值止盈法的话，很容易就错过了这一类优质的行业，反而去选择那些常年处于低估但是长期上涨空间有限的行业，例如农业、军工、钢铁、煤炭等行业。再举一个例子，在A股整体还处于低估状态时，白酒、消费、医药等行业指数就已经处于高估的状态了，然而半年时间过去了这类行业依旧一路持续上涨，如果你在半年前就止盈了，你就会错过接下来半年多的大涨行情，所以说估值只能作为参考指标，而不能完全依赖估值指标。</p><p>综上所高估止盈法，可以让你完全规避掉高估值带来的风险，适合有“恐高症”的朋友。但是规避掉风险的同时也有可能失去好的机遇，这是估值止盈法的一个致命缺陷。我给出的建议如下，<strong>估值止盈法更适合应用于宽基指数</strong>，宽基指数的行业比较分散，如沪深300、中证500这类宽基指数，都达到了高的状态，那就代表整个A股市场都已经处于一个高估的状态了，这时候确实应该考虑止盈离场了；而对于行业基金，估值止盈法并不是最佳的止盈策略。</p><h5 id="2-6-2-年化收益率止盈策略"><a href="#2-6-2-年化收益率止盈策略" class="headerlink" title="2.6.2 年化收益率止盈策略"></a>2.6.2 年化收益率止盈策略</h5><p>首先设置一个预期的年化收益率，当市场持续上涨达到了你的收益预期，这时候不贪心的朋友可以选择直接止盈离场。年化收益率要设置得合理，不要太不切实际，10%-15%是比较合适的值。举个例子，假如我坚持定投或者一次性买入持有至今，一共经历了4年的时间，我对于投资回报的预期是年化10%上下即可，那么通过计算只要我的最终收益率达到46.41%以上，也就可以选择止盈离场了，既然自标已经达到了，后续行情涨跌也就没那么重要了。这里科普一下收益率的计算方法：</p><script type="math/tex; mode=display">最终收益率 = \left[(1 + 预期年化收益率)^{年份} - 1 \right] \times 100 \%</script><p>年化收益率是10%的话，通过计算最终收益率应该是46.41%。同样首先看看该方法的优点，为自己设定了一个收益率目标，可以有助于抵御诱惑遵守投资纪律，更加关注自身不过分在意市场行情走势的变化，只要能达到我的收益预期我就可以选择离场，克制人性的贪婪；当然该方法也有缺点，这样的止盈方式有些刻板，市场变幻莫测，有时候没有适当的变通的话，很容易错过合适的止盈时机。例如如果你刚开始投资不到一年的时间，市场迎来了牛市，你如果按照年化收益率止盈法，达到10%就止盈的话，你可能在市场还处于适中的位置就止盈卖出了，会完全错过后续巨大的盈利空间，另一种情况如果你是在上一轮牛市的高点进场，成本均价极高，尽管通过持续定投拉低了成本，但是均价仍然不低按照年化收益率止盈的话，需要达到61.1%的收益率才止盈，可能新一轮牛市都结束了你都找不到止盈的时机。</p><h5 id="2-6-3-年化收益率止盈法增强版"><a href="#2-6-3-年化收益率止盈法增强版" class="headerlink" title="2.6.3 年化收益率止盈法增强版"></a>2.6.3 年化收益率止盈法增强版</h5><p>这个止盈方法就是在年化收益率止盈策略基础上加入一些对当前市场整体估值的判断，根据市场行情和自身持仓成本，对预期收益率作出灵活调整，进而作出更合理的止盈决策。同样的例子假如我刚开始投资一年不到的时间，我自前的年化收益率已经达到我预期的10%，但是如果这时上证指数或者沪深300的估值仍处于低估的状态，说明市场整体仍处于一个相对低的点位，那么这时候就不应该作出止盈操作，而是继续持有并坚持定投，等待牛市的到来。另外在上一轮牛市追高入场，在高点被套牢的投资者，那就要根据实际情况适当地调低自己的年化收益率预期，60%以上的收益率预期在这种场景下显得不切实际，如果在上证指数已经处于极度高估，收益率没达到预期例如只有40%，那么也应该作出止盈操作了。</p><p>年化收益率止盈法增强版如果运用得当的话是一个非常实用的方法。通过综合衡量年化收益率和市场整体估值这两个纬度的指标，止盈操作会变得更灵活，是我比较推荐的一种止盈方案。</p><h5 id="2-6-4-分批止盈策略"><a href="#2-6-4-分批止盈策略" class="headerlink" title="2.6.4 分批止盈策略"></a>2.6.4 分批止盈策略</h5><p>分批止盈策略是我十分推荐的止盈策略，使用分批止盈策略可以让我们在有效规避风险的同时收益率实现最大化。顾名思义<strong>在触发止盈条件时不选择全部卖出，而是根据某种规则一点点地分批卖出</strong>。在市场不确定性极高的行情中，分批止盈法是最佳的止盈策略。举一个例子来简单解释一下这一策略。</p><center><img src="https://img2023.cnblogs.com/blog/2609360/202310/2609360-20231005095521140-1268823721.png" style="zoom:50%" /></center><p>如图在收益率达到10%时，我不必全部卖出，而只是卖出30%的份额，再涨10%时赎回60%的份额，再涨10%时赎回全部的份额。通过分批赎回的方式来抵御不确定性带来的风险是一种进可攻退可守的止盈策略。上图的比例只是一个例子，大家可以根据自己的情况进行调整。例如我自前的收益率达到了20%，看不清未来行情，不知道会继续涨还是跌，那么你完全不必纠结，你可以先回一部分份额例如30%，如果继续上涨，剩下的那70%份额依旧会为你带来收益，只不过少赚一部分罢了图个安心。如果市场转为下跌，那么卖掉的30%可以帮你减小收益回撤的幅度，大家记住原理如此,但是收益率达到多少才开始赎回，继续上涨多少触发下一次正盈，每次止盈赎回多少份额，这些大家完全可以根据自身的情况作出灵活调整。</p><p>同样说说该方法的优点，分批止盈法在看不清后市行情的情况下能发挥巨大作用，是最好的止盈方法，是一种进可攻退可守的方案，止盈的部分落袋为安，持有的部分继续上涨自然高兴，少赚一些但图个安心。如果持有的部分出现收益回撤，也没关系毕竟我们已经止盈了一部分，这也让我们减少了损失。但是该方法的缺点是，分批止盈策略不适合在确定性高的行情中使用，如果我们已经可以大概率判断，未来会持续下跌或持续上涨的话，显然分批止盈策略就没有使用的必要了。在确定性高的行情里，直接选择继续持有或者全部卖出就行了，分批止盈策略比较适合在涨跌无法判断的行情中使用，分批止盈策略有点类似于<strong>仓位管理</strong>，说白了就，在行情不确定的情况下，通过适当地减仓来合理控制风险，不直接清仓也不保持满仓，而是把仓位适当调低来抵御未来的不确定性风险。分批止盈策略是我极力推荐的止盈策略之一，应用范围广泛、策略合理，我认为大家都应当掌握。</p><h5 id="2-6-5-回撤止盈法-峰右止盈法"><a href="#2-6-5-回撤止盈法-峰右止盈法" class="headerlink" title="2.6.5 回撤止盈法/峰右止盈法"></a>2.6.5 回撤止盈法/峰右止盈法</h5><p>回撤止盈法也就是在牛市中不做任何止盈策略，在短期出现相对大幅的回撤时，也就是牛市峰顶显露时再止盈赎回的一种策略。所以我又比较形象地把它称为“峰顶右侧正盈策略”。其实我并不是特别喜欢这样的止盈策略，这种止盈策略的缺陷比较大，市场短期出现下跌时，如何才能准确判断是牛市真的结束了还是迎来短暂的调整呢，判断短期内的高点是真的峰顶还是假的峰顶，其实也是一个蛮难的事。我们那前两次的牛市简单举例来看一下，</p><center><img src="https://img2023.cnblogs.com/blog/2609360/202310/2609360-20231005095653912-1238698799.png" style="zoom:40%" /></center><p>上图中的两个标记出来的点位都出现了最高接近10%的回撤，在当时的处境来看，是否就代表峰顶已经出现了呢，如果那时候止盈了，岂不是要错过后面的大行情了，峰顶还是十分难判断的。如果回撤幅度设置的过低，对于峰顶的判断不准确，如果回撤幅度设置到20%，你确实能判断出峰顶了，但是你的收益会损失得太多，可能还不如提前做出分批止盈操作来的轻松安心。所以个人不推荐这样的止盈方案，这要求投资者对于行情能有一个比较敏锐的判断才行。</p><h5 id="2-6-6-我的止盈策略推荐环节"><a href="#2-6-6-我的止盈策略推荐环节" class="headerlink" title="2.6.6 我的止盈策略推荐环节"></a>2.6.6 我的止盈策略推荐环节</h5><p>通过上面的详细介绍我们能发现，几乎每一种止盈方案都有其各自的优缺点和适应场景，那么有没有一种适合普通投资者的通用止盈技巧呢。我们发现通过把其中的三个止盈方案，分别是估值止盈法、年化收益率止盈法和分批止盈法进行结合，可以总结出一个几乎适合任何场景的止盈策略，姑且称它为混合止盈法吧。这个混合止盈法不难理解，下面我通过一个小例子解释一下。</p><ol><li>设置预期年化收益率区间</li></ol><p>普通投资者把年化收益率自标定在10%左右是比较合理的。然而，在使用混合止盈法时，我们建议大家在心里设置一个预期年化收益率区间而不是固定值，例如9%-12%，这个下限是你可以接受的最低年化收益率，区间的上限意味着只要我的年化收益率达到了这个值，不管后续行情再如何发展，果断全部止盈。注意这个下限一定要设定合理不宜过高或过低，如果触发区间下限的话，这时候再根据估值判断是否进行第一次分批止盈，如果经历连续上涨行情后，你的年化收益率达到了区间下限，你可以参考宽基指数的估值，例如上证综指、沪深300、上证50等。如果估值仍处于低估或者适中的位置，那么可以继续持有，市场仍然有充分的上涨空间。相反如果连这些宽基指数都已经达到了高估的状态，那么你可以做出第一次分批止盈操作了，分批止盈的比例要根据估值和自身的稳健程度来决定，估值越高、投资风格越稳健，止盈时卖出的比例可以定的越高。第一次卖出总份额的比例建议控制在<strong>50%以下</strong>，根据随后行情涨跌，持续分批止盈。如果第一次止盈后继续上涨5%或者10%的话则触发第二次止盈，此时稳健的投资者可以将触发值设置为5%，激进型投资者可以设置为10%，止盈比例同样可以根据自己的心情设置，建议应当比第一次止盈卖出份额更多一些，因为点位更高风险更高，卖出的份额自然也应该更多，出现大幅回撤，或者收益率触发区间上限，卖出剩余的全部份额，止盈离场。如果经历了两三次止盈后市场仍在上涨，通过计算年化收益率，已经达到了12%，触发了区间的上限的话那么我劝大家也就别再贪了，卖出剩下的全部份额止盈离场就可以了。一般这种情况发生时，估计市场也已经达到了非常高的点位了，再贪下去恐怕真的就会出现问题了。另一种情况如果经历了两三次止盈操作后，市场突然出现了连续的下跌，卖盘量开始远超买盘量，这时也要果断卖出剩下的全部份额正盈离场。</p><p>经过上面的一系列操作，既可以规避掉持续上涨带来的高估风险，也能通过分批止盈的方式最大化自己的收益率。通过设置预期年化收益率区间达到双保险的自的，在承受风险与获得收益之间达到平衡，把目光放在自身的收益而不是同其他人攀比。这一期的内容就要结束了，有一些朋友只看一遍可能无法完全理解上面推荐的混合止盈策略，但是其实并不难理解，多读几遍自然就理解了其中的奥秘。</p>]]></content>
      
      
      <categories>
          
          <category> 我的生活记录 </category>
          
          <category> 爱好与提升 </category>
          
          <category> 课外学习提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 速成课 </tag>
            
            <tag> 基本概念 </tag>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础乐理</title>
      <link href="/2023/03/19/Basic-music-theory/"/>
      <url>/2023/03/19/Basic-music-theory/</url>
      
        <content type="html"><![CDATA[<h3 id="1-音名与钢琴键盘"><a href="#1-音名与钢琴键盘" class="headerlink" title="1 音名与钢琴键盘"></a>1 音名与钢琴键盘</h3><h4 id="1-1-钢琴键盘的基本布局"><a href="#1-1-钢琴键盘的基本布局" class="headerlink" title="1.1 钢琴键盘的基本布局"></a>1.1 钢琴键盘的基本布局</h4><center><img src="https://pic.imgdb.cn/item/6416f88ca682492fcc011159.jpg" style="zoom:80%" /></center><p>钢琴有88个键，去掉左侧3个键(2白1黑)，去掉最右边1个白键。剩下84个键，分为7组，每组12个键 —— 7个白键和5个黑键。</p><center><img src="https://pic.imgdb.cn/item/6416fa98a682492fcc046303.jpg" style="zoom:50%" /></center><center><img src="https://pic.imgdb.cn/item/6416fc57a682492fcc07006e.jpg" style="zoom:50%" /></center><p>注意看，每组的黑键有规律，都是两个、三个紧挨着。</p><center><img src="https://pic.imgdb.cn/item/6416fab6a682492fcc048f32.jpg" style="zoom:20%" /></center><h4 id="1-2-音名"><a href="#1-2-音名" class="headerlink" title="1.2 音名"></a>1.2 音名</h4><p>音名简单来说就是音高(频率高低)的名称。</p><p><strong>白键音名：</strong>C D E F G A B （不要记什么1 2 3 4 5 6 7）</p><center><img src="https://pic.imgdb.cn/item/6416fd63a682492fcc088d06.jpg" style="zoom:20%" /></center><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">半音</th><th style="text-align:left">全音</th></tr></thead><tbody><tr><td style="text-align:left"><strong>概念</strong></td><td style="text-align:left">两个相邻音之间的关系，就叫半音关系</td><td style="text-align:left">两个相隔音之间的关系，就叫全音关系</td></tr><tr><td style="text-align:left"><strong>例子</strong></td><td style="text-align:left">E/F、B/C之间是半音，它们中间没有黑键</td><td style="text-align:left">如C/D，或者”黑白黑”的这两个黑键的音</td></tr></tbody></table></div><center><img src="https://pic.imgdb.cn/item/641703a5a682492fcc1324ec.jpg" style="zoom:30%" /></center><p><strong>黑键音名：</strong>黑键没有自己的音名，它借相邻的音名来指示。</p><p>&emsp;&emsp; 如<code>C</code>右边紧挨的黑键，叫“升C键”，标记为<code>#C</code>或<code>C#</code>，此外这个键同时是<code>D</code>左边紧挨的，所以又称为“降D键”，标记为<code>bD</code>或<code>Db</code>。也就是说一个黑键有两种叫法。</p><center><img src="https://pic.imgdb.cn/item/6417059fa682492fcc168932.jpg" style="zoom:30%" /></center><blockquote><p>注意1：在钢琴上，音越往右越高，音越往左越低。</p><p>注意2：黑键有两个名字，是否可以随便选择一个使用？<br>答案是不可以。乐谱中符号叫：还原号(Natural，<code>ヰ</code>或<code>♮</code>)，先不用具体管它的定义。它可以将<code>C#</code>“还原”为 <code>C</code>，或将<code>Db</code>还原为<code>D</code>，此时，对于黑键不同的音名，使用还原号得到的结果不同，所以两个音名不能随便用。至于什么时候用什么音名，后面会讲。<br><img src="https://pic.imgdb.cn/item/641706c5a682492fcc1856f4.jpg" style="zoom:30%" /></p></blockquote><p><strong>等音：</strong>简单来说就是音高相同而记法和意义不同的音，通俗地说就是两个音的音高听起来完全相同(在十二平均律中)，而它们的记法和意义不同。</p><p>&emsp;&emsp; 如白键E/F、B/C之间没有黑键，它们的升降如何表示呢。对于<code>E</code>来说，往前升半音就是到了<code>F</code>，因此<code>F</code>的等音是<code>#E</code>，同理对于<code>F</code>来说，往后降半音就是到了<code>E</code>，因此<code>E</code>的等音是<code>bF</code>。对于B/C也是同样分析。</p><center><img src="https://pic.imgdb.cn/item/64170a4fa682492fcc1f24be.jpg" style="zoom:30%" /></center><div class="table-container"><table><thead><tr><th></th><th>重升</th><th>重降</th></tr></thead><tbody><tr><td><strong>意义</strong></td><td>连续升两次半音</td><td>连续降两次半音</td></tr><tr><td><strong>符号</strong></td><td><img src="https://pic.imgdb.cn/item/64170ba4a682492fcc219df5.jpg" style="zoom:60%" /></td><td><img src="https://pic.imgdb.cn/item/64170bbba682492fcc21c56a.jpg" style="zoom:60%" /></td></tr><tr><td><strong>例子</strong></td><td>重升<code>C</code>就是到了<code>D</code>键</td><td>重降<code>D</code>就是到了<code>C</code>键    </td></tr></tbody></table></div><table><td style="word-wrap:break-word;word-break:break-all;" width="100px"; bgcolor=HoneyDew><font size="3"><strong>🐹 补：</strong> 区分同一音名的不同键- 大字组：字母大写；最左边的有下标区分。- 小字组：字母小写；右边的有上标区分。- 钢琴标准键盘布局如下：  - 大字二组、【大字一组、大字组 | 小字组、小字一组、小字二组、小字三组、小字四组】，中央 C 是 c1  - 在编曲软件里，更简化了，直接把上式的 【…】分别记为 C0【C1、C2、C3、…、C7】，其中中央 C 是 C3<center><img src="https://pic.imgdb.cn/item/64171522a682492fcc357c3b.jpg" style="zoom:60%" /></center></font></td></table><h4 id="1-3-音符时值"><a href="#1-3-音符时值" class="headerlink" title="1.3 音符时值"></a>1.3 音符时值</h4><p>音的时值就是音的长短。只要是音肯定有时长，每个音可能唱得长或短。(PS：我们还没学到简谱的1 2 3 4 5 6 7，所以暂时用$X$来替代)。</p><ul><li>最常见的音符时值：<ul><li>1 全音符：$X—-$</li><li>1/2 二分音符：$X-$，全音符是二分音符时长的2倍；</li><li>1/4 四分音符：$X$，二分音符是四分音符时长的2倍；</li><li>1/8 八分音符：$\underline{X}$，四分音符是八分音符时长的2倍；</li><li>1/16 十六分音符：$\underline{\underline X}$，八分音符是十六分分音符时长的2倍；</li><li>$\cdots$</li></ul></li></ul><p><strong>休止符：</strong>不发音、”休息”、”换气”，一般用$0$来表示。</p><ul><li>常见休止符的音符时值：<ul><li>全休止符：$0 0 0 0$</li><li>二分休止符：$0 0$</li><li>四分休止符：$0$</li><li>八分休止符：$\underline{0}$</li><li>十六分休止符：$\underline{\underline 0}$</li><li>$\cdots$</li></ul></li></ul><h4 id="1-4-拍号"><a href="#1-4-拍号" class="headerlink" title="1.4 拍号"></a>1.4 拍号</h4><p>拍号，即音乐的节奏律动，以分数的形式来表达拍号。</p><ul><li><p>4/4：念 “4 4 拍”，即 “以 4 分音符为一拍，每小节有4拍”</p><ul><li>分母 = 4：以 4 分音符为一拍<ul><li>诶，那此时，二分音符就是2拍，全音符就是4拍，八分音符是半拍</li></ul></li><li>分子 = 4：每小节有 4 拍<ul><li>小节线：<code>|</code>，在一张谱中有：<code>小节 | 小节 | 小节 | 小节</code>，歌曲就是一个个小节构成的，只要拍号不变，歌曲里所有小节的时值都是相等的<br>每个小节中的拍数固定(和是4拍即可)，比如以下各个小节都是4拍：<br><img src="https://pic.imgdb.cn/item/64171efda682492fcc48d89b.jpg" style="zoom:60%" /></li><li>再来个错误示范：<br><img src="https://pic.imgdb.cn/item/64171f3da682492fcc497bb7.jpg" style="zoom:30%" /></li></ul></li></ul></li><li><p>常见的拍号还有：3/4、2/4、3/8、6/8等等</p></li></ul><h4 id="1-5-拍号的强弱"><a href="#1-5-拍号的强弱" class="headerlink" title="1.5 拍号的强弱"></a>1.5 拍号的强弱</h4><p>拍子强弱规律（不是死板的）：</p><ul><li>2拍子：<font color=red>强</font>弱 <font color=red>强</font>弱 <font color=red>强</font>弱 <font color=red>强</font>弱</li><li>3拍子：<font color=red>强</font>弱弱 <font color=red>强</font>弱弱 <font color=red>强</font>弱弱</li><li>4拍子：<font color=red>强</font>弱<font color=blue>次强</font>弱 <font color=red>强</font>弱<font color=blue>次强</font>弱</li><li>6拍子：<font color=red>强</font>弱弱<font color=blue>次强</font>弱弱 <font color=red>强</font>弱弱<font color=blue>次强</font>弱弱</li></ul><h4 id="1-6-歌曲速度-Beat-Per-Minute-BPM"><a href="#1-6-歌曲速度-Beat-Per-Minute-BPM" class="headerlink" title="1.6 歌曲速度(Beat Per Minute, BPM)"></a>1.6 歌曲速度(Beat Per Minute, BPM)</h4><p>仅通过之前学的音符时值和节拍，并不能得出具体的时间值，我们必须知道歌曲的速度。</p><p>简单来说，歌曲速度BPM=每分钟节拍数。BPM与拍子的换算关系：</p><script type="math/tex; mode=display">每一拍的时间(s) = \frac{60}{\mathrm{BPM}}</script><p>例子：4/4拍60BPM：得到$\dfrac{60}{\mathrm{BPM}} = 1s = 1拍 = 4分音符$</p><p>例子：6/8拍120BPM：得到$\dfrac{60}{\mathrm{BPM}} = 0.5s = 1拍 = 8分音符$</p><p>通过节拍和速度，就可以算出音符的时间。</p><h4 id="1-7-附点音符"><a href="#1-7-附点音符" class="headerlink" title="1.7 附点音符"></a>1.7 附点音符</h4><p>附点音符的含义是在原本音符的基础上延长一半，因此附点音符不是独立的，比如附点X分音符。可以表示为：</p><script type="math/tex; mode=display">附点X分音符 = X分音符 + X分音符的一半</script><p>例子：附点4分音符 = 4分音符 + 4分音符的一半(8分音符)</p><p>写法： 在音符后面加一个点：$X- \cdot \qquad X \cdot \qquad \underline{X}\cdot \qquad \cdots$</p><h4 id="1-8-三连音"><a href="#1-8-三连音" class="headerlink" title="1.8 三连音"></a>1.8 三连音</h4><p>类似附点音符，不是单独存在的，也需要有一个前缀，其含义是把一个整体切分成三等分。</p><p>例子：4分音符的三连音：把2分音符作为整体分成3份，3个音时值加起来等于一个4分音符时值。</p><center><img src="https://pic.imgdb.cn/item/64172746a682492fcc59103e.jpg" style="zoom:20%" /></center><p>例子：8分音符的三连音：把4分音符作为整体分成3份，3个音时值加起来等于一个8分音符时值。</p><center><img src="https://pic.imgdb.cn/item/641727b3a682492fcc59dd0b.jpg" style="zoom:20%" /></center><ul><li>区分(下面例子在 4/4 拍下)：<ul><li>8分音符三连音：打3次，实际上只有1拍的时长</li><li>三个8分音符：打3次，1.5拍的时长</li></ul></li></ul><ul><li>音与节奏的应用：<ul><li>4/4 拍，试唱下面的音和节奏。</li></ul></li></ul><h4 id="1-9-唱名和简谱数字"><a href="#1-9-唱名和简谱数字" class="headerlink" title="1.9 唱名和简谱数字"></a>1.9 唱名和简谱数字</h4><p>简谱数字：1 2 3 4 5 6 7；</p><p>唱名：do re mi fa sol la si</p><p>音名(C D E F G A B)和简谱数字(1 2 3 4 5 6 7)不一定对等，而简谱数字(1 2 3 4 5 6 7)一定对应唱名(do re mi fa sol la si)</p><center><img src="https://pic.imgdb.cn/item/64181108a682492fccbc637e.jpg" style="zoom:20%" /></center><blockquote><p>注：八度的概念<br>八度：可以先理解为钢琴键盘上的一组，音高从左边一组升到右边临近的一组。后面会涉及音程，即两个音之间的距离。</p></blockquote><h4 id="1-10-自然调式"><a href="#1-10-自然调式" class="headerlink" title="1.10 自然调式"></a>1.10 自然调式</h4><h5 id="1-10-1-引言"><a href="#1-10-1-引言" class="headerlink" title="1.10.1 引言"></a>1.10.1 引言</h5><p>从现在开始可以写简谱了：</p><center><img src="https://pic.imgdb.cn/item/641812e4a682492fccc10ab1.jpg" style="zoom:30%" /></center><p>我们知道1 3对应唱名的do mi，但不知道对应到钢琴键盘上哪个白键(之前说过了音名和简谱数字不对等)，那简谱就需要补充一个信息，即1是几，比如<code>1=C</code>。</p><center><img src="https://pic.imgdb.cn/item/6418135aa682492fccc23729.jpg" style="zoom:40%" /></center><h5 id="1-10-2-调式"><a href="#1-10-2-调式" class="headerlink" title="1.10.2 调式"></a>1.10.2 调式</h5><p>钢琴一组有12个键，对应12个调式。</p><p><code>1=C</code>传递出的另一个信息是调式；调式有很多，这里只涉及自然调式；自然调式有大小分；本部分只讲最常见的自然大调和自然小调。</p><h5 id="1-10-3-自然大调"><a href="#1-10-3-自然大调" class="headerlink" title="1.10.3 自然大调"></a>1.10.3 自然大调</h5><ul><li><strong>自然大调(白键)：</strong><ul><li><code>1=C</code>传递的信息：“C自然大调”，即：<code>1=C</code> <code>2=D</code> <code>3=E</code> <code>4=F</code> <code>5=G</code> <code>6=A</code> <code>7=B</code>；</li><li>“C自然大调”音阶排列规律：全 全 半 全 全 全 半</li><li>C大调：C D E F G A B C</li><li>G大调：G A B C D E #F G</li><li>D大调：D E #F G A B #C D</li></ul></li></ul><center><img src="https://pic.imgdb.cn/item/641815f6a682492fccc82064.jpg" style="zoom:30%" /></center><center><img src="https://pic.imgdb.cn/item/641817d5a682492fcccc4c1c.jpg" style="zoom:30%" /></center><blockquote><p> 注意一个小问题，G大调中这个黑键为啥叫<code>#F</code>不叫<code>bG</code>：因为调式内的7个音名都要出现，并且要按顺序出现。如果黑键是<code>bG</code>，那么整个调式就没有<code>F</code>这个音名了。</p></blockquote><ul><li><strong>自然大调(黑键)：</strong><ul><li>一个问题：黑键没有自己的音名，那么从黑键出发的调式应该用哪个音名？原则来讲都可以，一般用降调来表示，此时全局更简洁。</li><li>下面的例子同样遵守：全 全 半 全 全 全 半 的音阶规律。</li></ul></li></ul><center><img src="https://pic.imgdb.cn/item/64181908a682492fccced439.jpg" style="zoom:20%" /></center><center><img src="https://pic.imgdb.cn/item/6418195aa682492fcccf8213.jpg" style="zoom:20%" /></center><h5 id="1-10-4-自然小调"><a href="#1-10-4-自然小调" class="headerlink" title="1.10.4 自然小调"></a>1.10.4 自然小调</h5><p>小调的音阶唱名是：<code>la</code> <code>si</code> <code>do</code> <code>re</code> <code>mi</code> <code>fa</code> <code>sol</code>，对应简谱是：<code>6</code> <code>7</code> <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code>。</p><p>A小调的音名：A B C D E F G，刚好落在白键上，借助它可以推理一下音阶排列规律；</p><p>音阶排列规律：全 半 全 全 半 全 全；</p><p>D小调：D E F G A bB C</p><blockquote><p>也可以利用“关系大小调” (平行大小调)来帮助记忆：C大调和A小调就是关系大小调。（这里就不详细展开了，直接记住自然小调音阶排列规律吧）。</p></blockquote><h5 id="1-10-5-大小调区别"><a href="#1-10-5-大小调区别" class="headerlink" title="1.10.5 大小调区别"></a>1.10.5 大小调区别</h5><p>一般区别（但不绝对，小调也可以写激昂的曲子，甚至洗脑神曲，比如《忐忑》）：</p><ul><li>小调：暗淡/忧伤</li><li>大调：欢快/明朗</li></ul><h4 id="1-11-音程"><a href="#1-11-音程" class="headerlink" title="1.11 音程"></a>1.11 音程</h4><h5 id="1-11-1-音程基本概念"><a href="#1-11-1-音程基本概念" class="headerlink" title="1.11.1 音程基本概念"></a>1.11.1 音程基本概念</h5><p>两个音之间的距离，或者叫 “度”，有几个白键就是多少度(包括自身)。</p><p>举例：</p><ul><li>C -&gt; A：是6度（包括他们自身的白键数）；</li><li>E -&gt; B：5度</li><li>C# -&gt; E：3度（对边缘的黑键，需要还原成白键再来数总的白键数，本例中<code>#C</code>还原成<code>C</code>，C-&gt;E是3度）</li><li>bD -&gt; E：2度（虽然<code>#C</code>就是<code>bD</code>，但 “还原” 这个行为就是去掉升降号，本例中<code>bD</code>还原成<code>D</code>，D-&gt;E是3度）</li></ul><h5 id="1-11-2-音程的属性"><a href="#1-11-2-音程的属性" class="headerlink" title="1.11.2 音程的属性"></a>1.11.2 音程的属性</h5><p>C-&gt;E 和 #C-&gt;E都是 3 度，所以单说音程无法描述两个音的距离。所以音程，分为 纯/大/小/减/倍减/增/倍增。</p><p>在几度前要加上一个属性，1、4、5、8度之前加一个“纯”，2、3、6、7度之前加一个“大”。即<code>1、2、3、4、5、6、7、8度</code>对应<code>纯 大 大 纯 大 大 纯</code></p><p>例子(此例仅使用于以C为中心到其余八度)：C-&gt;C：纯一度；C-&gt;D：大二度；C-&gt;E：大三度；C-&gt;F：纯四度；C-&gt;G：纯五度；C-&gt;A：大六度；C-&gt;B：大七度；C-&gt;高音C：纯八度。</p><blockquote><p>注意：纯一度和纯八度比较特殊。纯一度理论来讲不存在，因为就是它本身，C-&gt;C没有音程的存在。纯八度和纯一度差不多，都是C-&gt;C，只是这个高了八度。</p><p>出去上面特殊的纯一度和纯八度，剩下的只要记住从C到八度内的任何一个键，4、5度前为“纯”，2、3、6、7度前为“大”。</p></blockquote><p>把黑白键看作是一个一个的格子(实际上“格子”就代表“半音”)，那么C-&gt;F为纯四度要走几个格子呢？如下图所示，要走5个格子(注意<font color = blue>数格子和数白键不同，数格子第一个键不用数</font>)。</p><center><img src="https://pic.imgdb.cn/item/641845c4a682492fcc3ecaee.jpg" style="zoom:20%" /></center><p>再比如C-&gt;D为大二度，需要走2个格子。</p><center><img src="https://pic.imgdb.cn/item/6418494ba682492fcc487036.jpg" style="zoom:20%" /></center><p>总是，可以简单总结为下图：</p><center><img src="https://pic.imgdb.cn/item/641849b8a682492fcc494c2f.jpg" style="zoom:50%" /></center><p>得到上面的结论后，我们再来考察几个例子。</p><p>例子：C-&gt;#F：首先#F还原到F，从C到F有4个白键，所以C-&gt;#F为4度，但是它不是纯四度，因为由上面的总结图可知纯四度走的是5个格子，而C-&gt;#F要走6个格子，因此<code>C-&gt;#F</code>为<code>增4度</code>。</p><p>下面是纯/大X度的几个拓展对应的公式：</p><script type="math/tex; mode=display">纯X度格子数+1 \Longrightarrow 增X度 \qquad 大X度格子数+1 \Longrightarrow 增X度</script><script type="math/tex; mode=display">纯X度格子数+2 \Longrightarrow 倍增X度 \qquad 大X度格子数+2 \Longrightarrow 倍增X度</script><script type="math/tex; mode=display">纯X度格子数-1 \Longrightarrow 减X度 \qquad 大X度格子数-1 \Longrightarrow 小X度</script><script type="math/tex; mode=display">纯X度格子数-2 \Longrightarrow 倍减X度 \qquad 小X度格子数-1 \Longrightarrow 减X度</script><script type="math/tex; mode=display">\qquad \qquad \qquad \qquad \qquad \qquad \qquad 小X度格子数-2 \Longrightarrow 倍减X度</script><table><td bgcolor=AntiqueWhite><font size="3">🎵 也就是可分为2个步骤：<br>STEP ONE：先通过数白键个数确定是几度；<br>STEP TWO：再数格子数，然后根据上面的公式判断是增/倍增/减/倍减几度。</font></td></table><p>例子：C-&gt;bF为减四度；C-&gt;#E为增三度；F-&gt;bB为纯四度；#C-&gt;bB为减六度；</p><p>最后一个特殊例子：C-&gt;#B为减二度。这两个键虽然是一个键，但是它们之间有音程。</p><blockquote><p>除了数格子的方式，有时间也可以去了解“音数”的概念。</p></blockquote><h4 id="1-12-音的乐名"><a href="#1-12-音的乐名" class="headerlink" title="1.12 音的乐名"></a>1.12 音的乐名</h4><div class="table-container"><table><thead><tr><th style="text-align:center">乐名</th><th style="text-align:center">主音</th><th style="text-align:center">上主音</th><th style="text-align:center">中音</th><th style="text-align:center">下属音</th><th style="text-align:center">属音</th><th style="text-align:center">下中音</th><th style="text-align:center">导音</th></tr></thead><tbody><tr><td style="text-align:center"><strong>音名</strong></td><td style="text-align:center">C</td><td style="text-align:center">D</td><td style="text-align:center">E</td><td style="text-align:center">F</td><td style="text-align:center">G</td><td style="text-align:center">A</td><td style="text-align:center">B</td></tr><tr><td style="text-align:center"><strong>唱名</strong></td><td style="text-align:center">do</td><td style="text-align:center">re</td><td style="text-align:center">mi</td><td style="text-align:center">fa</td><td style="text-align:center">sol</td><td style="text-align:center">la</td><td style="text-align:center">xi</td></tr><tr><td style="text-align:center"><strong>简谱</strong></td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td></tr></tbody></table></div><p>其中：主音、下属音、属音构成的和弦分别是主音和弦、下属音和弦、属音和弦。</p><h4 id="1-13-和弦"><a href="#1-13-和弦" class="headerlink" title="1.13 和弦"></a>1.13 和弦</h4><p>和弦：三个及三个以上不同音构成的。</p><h5 id="1-13-1-三和弦"><a href="#1-13-1-三和弦" class="headerlink" title="1.13.1 三和弦"></a>1.13.1 三和弦</h5><p>三和弦：三个音按三度关系叠加的和弦，是最基本的和弦。</p><ul><li>三个音：<ul><li>根音：很重要，它决定了和弦的本质，根音是什么那就是什么和弦，在原位和弦中，根音是最低音；</li><li>三音：根音上方三度音；</li><li>五音：根音上方五度音。</li></ul></li></ul><p>三和弦分类：</p><ul><li>【大三和弦】$\Longleftrightarrow$大三度+小三度：根音 –大三度-&gt; 三音 –小三度-&gt; 五音，例如：</li></ul><center><img src="https://pic.imgdb.cn/item/64185567a682492fcc62dcf0.jpg" style="zoom:40%" /></center><ul><li>【小三和弦】$\Longleftrightarrow$小三度+大三度：根音 –小三度-&gt; 三音 –大三度-&gt; 五音，例如：</li></ul><center><img src="https://pic.imgdb.cn/item/641855afa682492fcc6360a4.jpg" style="zoom:40%" /></center><ul><li>【减三和弦】$\Longleftrightarrow$：根音 –小三度-&gt; 三音 –小三度-&gt; 五音</li></ul><center><img src="https://pic.imgdb.cn/item/64185620a682492fcc641822.jpg" style="zoom:40%" /></center><ul><li>【增三和弦】$\Longleftrightarrow$：根音 –大三度-&gt; 三音 –大三度-&gt; 五音</li></ul><center><img src="https://pic.imgdb.cn/item/6418564ca682492fcc6466be.jpg" style="zoom:40%" /></center><p>在C大调中有7个音名(C D E F G A B)，能分别组成7个和弦，且是本调和弦(本调和离调在D和弦中举例)：</p><ul><li>C E G，1 级，（大三和弦），主和弦</li><li>D F A，2 级，（小三和弦）<ul><li>D大三和弦：D #F A</li><li>D小三和弦：D F A（只有它在 4 个和弦中没有离调音，所以选它）</li><li>D减三和弦：D F bA</li><li>D增三和弦：D #F #A</li></ul></li><li>E G B，3 级，（小三和弦）</li><li>F A C，4 级，（大三和弦），下属和弦</li><li>G B D，5 级，（大三和弦），属和弦</li><li>A C E，6 级，（小三和弦）</li><li>B D F，7 级，（减三和弦）</li></ul><h5 id="1-13-2-七和弦"><a href="#1-13-2-七和弦" class="headerlink" title="1.13.2 七和弦"></a>1.13.2 七和弦</h5><p>七和弦：由4个音组成(注意不是7个音)，按三度关系叠加的和弦。</p><ul><li>四个音：<ul><li>根音：最低音（原位和弦）</li><li>三音：根音上方三度音</li><li>五音：根音上方五度音</li><li>七音</li></ul></li></ul><p>七和弦分类：</p><ul><li>【大七和弦】$\Longleftrightarrow$ 大三和弦 + 大三度</li></ul><center><img src="https://pic.imgdb.cn/item/6418580ba682492fcc67a223.jpg" style="zoom:40%" /></center><ul><li>【大小七和弦】$\Longleftrightarrow$ 大三和弦 + 小三度<ul><li>如果大小七和弦里的根音是这个调式的属音，这个大小七和弦可以叫做【属七和弦】。<ul><li>比如 C7 和弦在 F 调中是属七和弦；</li><li>比如 G7 和弦在 C 调中是属七和弦。</li></ul></li><li>每个调只有一个 “属音”，所以只有一个 “属七和弦”，其他的都叫“大小七和弦”</li><li>一个调式里，除了“属七和弦”，其他“大小七和弦”都有离调音(7 音)</li></ul></li></ul><center><img src="https://pic.imgdb.cn/item/6418584da682492fcc681858.jpg" style="zoom:40%" /></center><center><img src="https://pic.imgdb.cn/item/6418599ca682492fcc6b34b1.jpg" style="zoom:35%" /></center><center><img src="https://pic.imgdb.cn/item/64185a82a682492fcc6d906a.jpg" style="zoom:36%" /></center><ul><li>【小七和弦】$\Longleftrightarrow$ 小三和弦 + 小三度</li></ul><center><img src="https://pic.imgdb.cn/item/64185b0fa682492fcc6e9543.jpg" style="zoom:25%" /></center><ul><li>【小大七和弦】$\Longleftrightarrow$ 小三和弦 + 大三度</li></ul><center><img src="https://pic.imgdb.cn/item/64185bf2a682492fcc7031dc.jpg" style="zoom:25%" /></center><ul><li>【减七和弦】$\Longleftrightarrow$ 减三和弦 + 小三度</li></ul><center><img src="https://pic.imgdb.cn/item/64185c4ca682492fcc70dea2.jpg" style="zoom:25%" /></center><p>【半减七和弦】$\Longleftrightarrow$ 减三和弦 + 大三度</p><center><img src="https://pic.imgdb.cn/item/64185cb6a682492fcc71932e.jpg" style="zoom:25%" /></center><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><p>参考资料1：<a href="https://www.jianshu.com/p/c82de692f6bb">钢琴键盘及乐理入门</a><br>参考资料2：<a href="https://zhangt.top/MUSIC/Music-Theory/#%E5%9F%BA%E7%A1%80%E4%B9%90%E7%90%86">乐理/吉他-学习笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 我的生活记录 </category>
          
          <category> 爱好与提升 </category>
          
          <category> 课外学习提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐理 </tag>
            
            <tag> 速成课 </tag>
            
            <tag> 基本概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的密码</title>
      <link href="/2022/12/13/My-password/"/>
      <url>/2022/12/13/My-password/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a21c8c4695dbb02c2dc884677242f1090c7957de4bff662e37bef50a610b1f0d">26d0955f3518d1f7254047f47551dc2e5bae0867ee61417fef479920426058118d02adb71ebcf04042f9f040d3bd3498b54a64daf2c782fa4262fbfce0faac33c75724999d3db6c26c08778d9f5d97ead3207b9497285850cece7e68a7ed3d8f269ae3d6470b781c682ad9d2e14d52539cd280f235761160ac2bd175728ae767016d97e6d793e3c024919aae1bf72dda09ba86df540e37d9e6c3010f9fbbe7a06b4e0fbf1663d242c876abd9cf924fcaee43d30c7fde3c980c5249425c8aa66ba2d23ea08243c68d164579c3b28940b73f723e52b32281a20336c7fda81ab41e0c396cbd25ceb224ae93afa75687d0f01b239fc8a66585fdacf04f036f29570eb76fc2314fa6f638edc393bfa33ee50828a37f0b1c62b61d3d4de4576e823ae8897f3b0a693cf256b4d12ed33f668e972f7b738322c669e3f1e5f4c6dc61a9b0ed2f1afbd4a61884582132026fdec4a4db8498b134bf8590f4b14850b3d25bdd7b05bbe9a8a1bbd26662b7003216fade7576a96976f072a26027739852d7c38b82f9472c9370a91260454e5e7754dc65c5bb9187201917ed7f5951421ba1429a7dfea07771873a08d111380e43648a65c5c51af768dbfc7516af71cb99f6fa219a49ab758d187391eafc21d8960a61e5366e50ee5adef92ca42ac7eb9ba0d3057e4dbcdf9e076fec1e0f6fcf68f7bf552e48e3f53075be4011847a516245839737400bc3e3ed985be1cbfac135bad74469c416ee481cf5a92ce5c70598cb3ebb1e921bb47939f0f8f1eeb8cfd556511447fbd643f7d3b520ffe7e101ac5fda02f07afa96f44d386ff50f49d5d5c9246a1f651d636e431e5471bf0177a38aa349282c4d71d8f0287e231763666a31b47b2e779bde31bd8951e7242ea827dd71fd79ce54fbfe70a82e4bcf90557cea1755701ff3e5b4e0acd1028c275d840fdf0d5d6c898437951cb6e34d684edb62ac2f2b3fe378f730c608ca3cb0b2117410c39839321a12ed258f8d69ddce5336274ae95334d8b7a0201e96b005369615aed9867c5982a3662e48ce5ab39aac4b4e06b1f999bd98ef77de4379111a6babf4c81c9da6f79de58ae1204558b38dbace71d2a0f2ffa7126b5899fce0b6770596cdcea9e9331c3eeb3a50abede29992d467ef72a1ff12a17350d7f45806aff7fa2f0d95ae2b090a0883aeac7d9f9fdb94950e9caae5f6649a148c30e9148d042266159fa0c50f48f06b5df98c385ff5ff728af102fe2eb31d57d05e0c49628f3515589268e9c55fd23b65dda4532f711dfc5a674564dc2bcc80733014ba5b500db55d51cb47fd35cc7dd34dc14809c342177f101207ceb31a218bca9313142f513d505abc0088027e9eca7c841d7d1b88a511393684e85769caf2ab615aef6781536646bd1bf8077bf84ede302865e9576e8e5bc4bb129937e17fc506b490eccdf08647b82662a48ceec4759b2eddde9d5b3f303b2c4b0f57c3028a32dafe6eae91c1be215cbf0501f950bcc47e731d3c963a14f4480f7f0f7a557f5d7b95041426047916043d3501f660d62747490ec7394f0f6b003813473e950dda67533ad11021d4fad513c63437034a5d646ab234cc17e7c5706bca006e5ab502e4b32ae835645b8766787f26bdb06f480a3637e58f6899613cba83b682f42f7eedb1972510f1c3d6b4b325d98b7c4adfcc0cb2cfbbf24377f268c835d4a4174102c4108115f91eade7c5357cf53cfd177db482f1727bd1504129d99dfb1ae8b8639886894d5259bbc997c1c8aa108d5887e97edb79c6900da5d57fd833cdb0b4edd9f5718dff6734d5006f579409db2f2912676e59f0e01cf4fe1c156c59d79ecf2d10685c3ca5105911cde6f684faed4882953dcff8d1b491d47ac6578e0e24d6f3c313391932520396e86e8cea8c310364cfb8390576a0d226b6b4b741cbd6ba40d8d4e5c251389837c5f044a477085f9170bcbbd0f7bd809cf38627d611f58779b12102c3352594cbd3bded5a0aee4893fae0e401ae93d56125a6a6f8af154320c98533437f11f2687c857b45b94e4876a7082b32b4c8c6b085b1b62d75901e3273cb22901a7f7b67944e08be39ac7d3e66eb54f0f5fed132d1b4d16bb9f0330bae7bc69a14200b8272d99fa79606d6355467781846df68541e73eda5b62d1fc8436eb4f181d5f0cbf404d89a9d13deff2e64920bb2dc332884a0fd70854830095f4da5ea3679d826dd014be689d180ebe40ed658db69e5fc07ec3775fb6d3cda455a94fa9303347537c5ee50e71f81adf710e9e7c15d8eb5d40c5e0e99a430c7a68e40277b2b6f4d7eedc00afef058003666e03d6ce9e817ba93ecb66f07498c146ac7ac8b350f245369434dfe78749530beaf199ac0c7451f4657fef16d0af4910238893f83867d87d3b48a778516a4f43800529b9b7385fd2ccde0fb4ee3b7161c01b66f3ad3fffb6938eff336b5ca8a628bb75773f7852be940c478a0c31933089d4ff7383b6165392393016a2adef8c52dd689c9e42eb98f540ff06d478a42381e169079e4b27af760b04ce56488ae92bbe4891032952e1554a27d5f454bff12588d41986a0494de9a46cff11ec7a9ec1df09734acfa2d7cad66208904c36a194d58a1b83ce978e15ab158bec95c4dd7e12709deda0a137dee7ab6395a488042893b90dbf532b17f02481b2986280fa591a8158131cd6b944cca731d312469c23d2e5206c5728fe95c887528f08aa31a0a5afbebf45e3f094f32578884e1e3d3a871eeaf9ff3a9989b7f7a04818d9de3e86836b3b9274fe15f12b42ac91758610e6415d1e8298e0eb46df723ef1880f4a30e95fd5261e79da191871db57178824974175fafc341be3017c014ebc3aa3e3238f7fe225ea3dc7098ca7459f6e1fbd6e9470723d3d23541aa19f2b50091816fa2832b91a755a507e01249edb9aaeb969e45ab6fe3ae7522f5a713b12d817b1b77145401b70c4fd199f18e5f45608294764fd1484997c47a7919d6d27fa95e2f45064e43145592ce6f5ffd8d4cbc1c085fbafa4ed2a6a7be137f5fba7146e0b27aed7d6edeb307d210cd1ccef401bb2cd275c13eaf4ecffe06acdcad5a91af7c8a2b88e3609dfdc2d58470e13cb7933bf57209cfc89b70e9de26259806f6f531a89ea5de6ae56f5e7d421d6302a49171bf443834effedfb6fbfe1ab41b06253bbf1107c88cbc77ea427721e5bb4b5ae56cc4a1facb252e1414e86cd873b102dcd9381595eec60d184f03bd425037965bd6c6c6c3ae2e78e0c60bed31c5b15364de349a24ae54f40695e9fae83680a5a6f62003a5de8e2bfad1d69ec0cb4c3086145b34d4bb04e713d5aaf7175a4924707d7eea750ddbc7cbc798a618ff71396e3f0d412d5eff86259fd7e214ac565258f242c67a960db6541c23b74050cedd6640f00ffcdeefd7cfc3439ae1b2bb0e7093aec7f9d930ab1ac6d2208bf5e9e3c6341bc7977eb52a07f0134b0b25b60cb0336d1673e2099f999d411405c69c99409d496d7df1f5e6771713d5d9f13f107aa92107c90698227967ad65c0306aa4c092d44cf88d4f94846c4c95379cfe1e0cd68e9e7d2f9877dae15f31c7353bd6d1112f9e330511718599a05373e66697ed836496916718b3bcb514a8d627ff6fa50136f9e224194f5c10e4279f3419da24caa2ae8afeff100c00bdd37fba35fd0c63afcecddfda662bd781c19005de62dba82d217a15c8135388a9618699d3ab15c322403ebcf2a876989696f26644a0bfb899dd2810febfe41c1e054db3a239cc0e6449087c940ae3aef1925d0cb46453025ded3097e8dd603fd364fe02638861709e5b1b27c4c923ef2afbc2a85da7d752f1b7171fd7fa1bc60fad5db35155cd7d362d3c08bf36d213b7dda79de57c7f56a1c0a613685acd79dd267f834d72319fc4b130e75acf8482d10c657d150fe6326c8225d79f49f65ef6abe808e561c3003b742aee9b764bd4360677d4f20c10f1320aab8109e69237c43cb125a8fe077907903245d2d20f171c4db6a5528ae2bb91c7f6642842fa97663819610958140db1de61f19047cb30e1894234dcc32ef3d40367a6723c3a08ab658650ddf3ab0005faec528f872b5ab8b42e7e03d408039b32e164cee7313421d1dd9a41ea1bf5c5b812c268282788fa58a59a86faf760e67719092d3bb609f2b7ed6a8089bf2f986867d871584c7272fd2f0a2f2c604cd6db535b93c1f4ac7806ca530a238021cd8c766dc72e5e77a04ca04fe0e1bcfd497116540375afe6483807c7042bfc7310029835673747a0ce815ef01878a94675530f22471d3c2eea9d0774e1261ed2e4007092153fea3527c70ab4354a94b81b06f4ab7bfdf4e6d0457889ca8527bfedbdeeb4759706cbcc65270dc2de6ac0cd29511b5ca0af12aa1c6df9b123c2cdfd50038cf29c740a78210b7e8f44d5c63f736ab5def4c58be8b9946dd134d15c822eea1851c6c745b11202de33be86d7d4460629acfbfdc3b4a0b9ecc87814109efafb7d47fed3e6107bb7484ac5ccb9e024f3bdcb5607c4a874b1e304ee9bf0f16817dbaba6438d66ad65d47a22c4ce278de1454d1d52c9de6a1eb01cffc87a6692efc5f0dd10e71a1666319a720b864a485cce77d40a2f3c04abdb0c787cb648f445014366d0e1a7702ccea5ee73900e8050a46f79c8e4cee9457962e7ec9e7b6f92c9d2775b2d2f24d581c9404b28b7092592d0abea8dc2e977042acef673268ca6ae9989680b70d19a390903999272ce73dc5bce43978e38784bb6aa6457ff48370d7d854cfc7354ba07324a9adeb8a61f83a45c2dcaf559db447b40f079554fd676d06b7f819f32af1b31cef7b90b3c31a2b1c1f1829f1986545830236e2207fb0f906f8d18681849db20391de8023e4662b6344dd0adb83c383285485c78606a1128fd5834aa922603e960d610c1c96304d9e0e88a4d2d4540d4c3ef0d74387089cbcd14e75bd12df99eaedddf28a5e6f0d397412793bdae6900e886846d0ff0045209b3d4cc41c5342d1823788d8190143d2a84165a0cc4a87c639a1df9f16c36ed67f952937e035951a4c8eaf7359d169146de1fa5b8ec2cafa85d4459bd49102425c2a5f28fc3df9b32cfca6799a762437c272fed2ebbde448f0388f88f027a0054c8f9baaaf7cf47c5e1b3abda9575e69fcfda4689873881ab5665c3d5c39d782b3e0ce30e84a660ea4a32f29baf4393413f5f7908270ac69419da09ef79c1502ac7ccea7872fd2e18e5b03700995893dbe63bc442ffe742fbf0597f4bc3acd062bb2a8b9ffa687b1d395afe4e637d7ece41073a899f3d21c7750f267ef921e0c1703029e56ce96c06a929e40dea10694fdeab39bba17487bfb050dff6ac95ee412521fe5678340497fe3b9a596f33238e20d6481596687219e04b4de4a463d6acb1c419732be91309462cb0248982875cc3f85c0c253aa93bdca9ac72ef2e0fd3c9476872ed2872e10ea4ac0b558442cd27bd50efc0b9f7081528164f9d09cb383afbf4ed06fe51402051c32a1ac22772b47f4500720d8d15faeb72452b8e200edeb098004addc48a72c5cb4eaa74f00579418e37a78bc149cd57c98752cd2537af24012b07733805c998fe5a51346f143eba64e82e7877b2cac0af1a2ccd26013dc95636a03e5236c157b768dc56db79fc27a9805ac9c088fa1147d051c4d4ae284d536baf4f049c11a4446db85ea34454a30eaa0b71f4bac3f58722e0d292fbe31b344dc3ec82d495d7fd85dbfdc87afa41fae1ab6236d44f38e2de0baafc94e2e09a34d8efaf1f7e4e1f5ae1d15f9e8685c8a964a958c52b3c291e4a03d96a3639773b2b01ff00ad4609e13db01ca6ff026e3ad822f038f1103b924df4d066a751be106648ccbdb32a549ad4cdb985f4e2ec624f52d85f0d8e7facf36177684704670a3725f9fdd796d68d609e2ce119355ecef030b25daf5c877918c6805c336602208b62fb20c50ca590729f5aeee59c830aa69050913aecfab2f4ee3ba4845e82b9c50ee313f0cc6f7d07080128291bbacdf82946217e6afb57849d62b53234bb62cf3150a1b1d4fdabba8337daffee3eb5a1ca773a005dc34d597dfc400e052df3eed6113ede3fe5c939e2dfe10da0c08db56961bdab476e73901bbdef38c97f9c7ef0acdb65ed37e6f761db4c8e17f43915149a5d8fd6335e796daa2b57a9f24bba006be70ba81b0483e170d7c1b24b5b31b2af24b999bdf357cc54026f91f4211cd119bac2bd75e2d2f368d771346d1aa532c80f1267dcce5499957dc8d198cd667349407446c9a98625e50424cac6ff759c35bf586d70a05646f0a85de8f88d865f599a394527fa248179bef9bf5d954836a7d6a417db2cc7098165e53452a92ebce2b74f44dd4f26fed55c581a6d32799b33274d44e15e67bc3bc33b2a2dc85ab65b4aab88c33549fe9629dcd1498e22ed73bf9cdc68bffdb655a7d5ba3b811b7d1b5c72c0b7f373cd79b0676408bb8fa6be09ba73bf72f0b172c968646505ef2c354d4ce961f2b25792f3585db8deb77a9be0d5857cf1ef8682560c99281138163c41ec9c1e0b350674e6d6796ae80ede44f5ed914fe119e368f07a4074784d531c678c185227de5c95341eee73a0d2507b8aba5e6fde7d1dc7d650a3ab6c02c4a794f5f4bc749f311b757698f1b9e3d16337a5e4849791e44bcfe17b8e3e4bc7ef351bc5c4a4bb8c415badde91271bf899a4309d1d77a021db2fc1794eca8f77fb552b5f1767b6a8b63cc1df8df8a6174272e1db71084b3891a348a60c50ea611851bd398b4f8b994325835c7f9aea82e5cd252c5e7a07e8032608b7e1e2d58b1453ce48a43b783c97339997dd01642cfc05265af171091cd24163f0bb4b0a37d93e1f05feb50e70f8888d18dfb306df6794bdaed801f7992949bca4d58f66fca6f53d25e92ce9e05f58cc75efb4546411a8a0362a736c6926facd5844df69eded3f3feef721f1aba2495abae7e3ccc19360816bd2458c349a58219634d29d7b6a2a7c5376edaec2533e51e87ce9aada3404b25d8064974257e5a218a0548de7a2756ff3caefda13bef5777c90c33913fb4d0f5a017fdec83c22b4d2694b2cc883df19f68c92e2a31de5e164367ac4b23875de3d58bc8445a649ef1b92f2a4fa3ffa6973afad9ae943eb0e7e388bb78018f4091fe6734194537afe5cbc9b38443a2060cfcd143690823450ffc785e12ca69a4e5912121049053541e6e3306b19bf3cf486f36ad68bdc3a1475e34c2577aaa67f220b50ae875069c435c4b452907a8bdba3c62fdc2b069d1df5370ef1df1774be9c5acbdaaaa1b55b593143ede048a657ea168f125f50228b711b1262c97fcc61557d9498392064002acb4900332785af9214171f4cb4366d10ec30f60bd79d1742f9efd91f205fa50851c97fce980eb6427dc710863dc790c9cc7b94f6ee0628261e242c32b5afa7feb061c43b7f85f171fcab13e84462c84f7bd083de660b67f92a202f0f6051920da5771ff8ba5be145108f34da42787f1d2aecc44d32d6014210d6d3346b93bb547d811cdfa35eff4de68e3f0a745fc1221af01726801f2ee325709a5ba0560055c33b7388cfb34f62b95186e5009867252bba10bc654b61a4623a9697ec81881de8f021091b94d7a51111082074ae7edfb3abc5cfabf135dd0d3db839ee34d4ebeb62c77eaa2a16b8ae11ac5969109024aa0e3657dd93d0c4d2dcaa4fe3c14a6d034a63f50a802cce645cdab342f1540c8a837382d60f078ea7736b8728e7ab23f4ca97bcc6a3abdf6f8fd763da79ac77b6b8dec3cc18539c54dd054df68b82a1faf0544da33cda13a58b89ca725478c22b300b045b131606646cd5c278291ac4a932b163013147732f95f44f80545de75eba80ef93abaa6ea66d8c4b9825eaeb0396abeb85f3f1226b9d3d8e9ccab798150d704249295a011ab960fe4fb0fc62681b9ea934eb9ae6057407476f431b9c9d58f028801f98dac86d519b998d33fc2a9d94459c640db76e5b2a5ff75ecd52597254265c10349861a8f435615d7cccaab18f9d014f5937fe90bd5ca7a4686fade90a8dd7a0877a49eeb13fde7b002b884208041791de9d2b89d0d83ba5ad0e68ef280e619a47a63ec4188288e417102fd8f45bc5f9d9fcc4497b89b3afc7a271773e175cc9f45a473ef8ac98d1c208e791276715f819f9063f8c4bc93152f45f5179a5d36c27659d20b7d1d52b9a45ced086f4b1910b212c79f3257075217e8ae8c90e99184ca8571a5f9fc626555b2f9c1f5857687b7cccd279ef3197e481be49f0b22c8cb2e351c6338bb31a255cbe1308b215fdd59ba203bf2c46b07cc5e2d168dbdd5cc4bb61b3c0701f969ffa1ccd1b61ac825670bfa8edc0b50747e123579bdef9782e09dacf680ae65c480cb5d7d3af9de7120ca402abcd61e8b8320365f819b7b04a5f9b2f5bc8be4e76cc8b0c92fc09897581ec49ff32bc91766ab4c186115facc52506ec5369e33da89de6e78ba344cacbcf6af916ebaabe68fe931889efb6858bcc1bdc867b8b76779336311394b76a8a56a9638ea13dffc372f5b0dda3829d816509469d6c80e216552dbaf3d880680124036df28b4399369e2f5b0a292a664e32b53a5666c25b675009c23341b7c59894aefe782496dbbb40820249dc9d175d7a1e1b476e89fff3c5a37ed9d2546edecaa45e692417e22f820ba708ca09a26c60e88e1d1ffae657c688451a00747e86e47a57537cf8edc43eab72ffa43b8f2466bf8d31750a6184f381364f53eeca241261b1feef4c4ca8d0d26ee285f59a48331964e616b684ce61201546647692b99fdc49cf25614e7b7178635510d10214b2053740b2edfefcff033910875f5a95fc4bac674e3b7142c6f8d2e088590eeba6ba781c89e189df8c1acfbae0eb92c10d5d6f0e7762bd47e247ac96002de0b74e5510b0255bff54607f94ac0c42fbfc30076b116efa46483da9937df8bf3a483eeb85602ee7157901a466e60c96a151b4202de8139a5a9b6e2828988c739e50252c668e600fbd29cbefcb50c9c69baf13eec7ad4f4b3bc4b7721755ce12d1358df5adfc09b6cda246f1cc3903693d72425dcdd7c6b3a7489320a36ceca598cd659720014a3460c86387f39814424c4dacd6667b372a00179cae63cf0dc380a1f6071ba839f20ceaff01ce76831a1037a7bec30022e13b858ef1f2bf14e4d6d16794f1051018e68ee92202879ca11ad2474ae38c9ed6738eb3e3df492d03d086ba0bbe43cc41b5a9b481c6b6944ff3bb1591f8ed57d28de8c770564e7ab18af1ced684b5114a2d965d5a88e1b57f290ee57ef4e8a23bb14a263cb1ed75d973240b5b4fdfda34676341ce252a573edad597f2792292a6180355453a931e1c6f2d3cdf9a4105e25e56e69dec6108e28de0e83c66cc9e91a6355d6970b0869b2cd1d99815882e3b461b981dd15fdaf06144a75a397c2c60462e31810040ab1a7174097b434ce6bfb5bf5bd0335ea0fd31e6efdb4c2e0be95f1db5e892dd7ffa908f1d7000561b8f86874465d5b0a24c64fe7a2d4f741771852838b2191faf39f125bc4bda922ca158c857c693dadfd18cada3c34bc12bbe9b81dd79da8b0caf649f7421de822a887e47af34ab2aef447dfcb07dcca0fec85fd9cba47c68977dfad0143b5168ef3e092e37b8081b0a9e7ba836a8ce58d489e250a752b21c7ad6ef7cc1c4240ca896ee2a978d3ade73ca70c394893e8215fc923a179f471de5be12e535b867d0b41f22bd67d8c7f06bcf4a998b4e26b73e10f0b93fd4224211f53761f2d4d693e72c341b121928b704fd7084bef1825403888f93e0188a37fb612c5cfaf894b74ef6c1399672ee35f0c95c7ab8153e35b67eca5d29ff135bf05cf3b79ddd55fce36c751ad49f3a7f7605d3908b3c754ea800f803feb65dc34045db5102b29766ef85fd072a3032f27471af7c4858d8aab21967534ae4d4910bde44d26bd87eb0a7a23b268c50bf6a4012b22aa3575ae1a63727546a0c4a2fcff486af91dfe130c195f6fd659d51f8815b433cf3e89111e551bad34aa31ff3bb81c517b113f536ee824d7a51d9cd0b4ceee953a4aca0719277cb80ff0dbbc6906a11e9f892148f6624f78e0855f2f101e7f37b0d8ac6a32d2f66c85a810a604cd0967f96a83ef82f346aa4ce01b2d85c6593592dbdf455dc69d2d6a23a648bc49c69e980fd83e13363ba68487550fe72fe4c025e1b4a33a9da31a910fdec8d64d7726cdf33e2d4264555c016483e2556869522f9b58060753384b6189f347a89e32302b03800335daad57c90131888137f0e98bb0ad455a7a0fa1ed4351ba73e2c0c175de99a87be2d3ad16672d0e592bbac7e74b46f14f32d6c83a5be8a415b95b532c354291dbfc5cb1b287d9a901ef75d585e75309d5f9b2fd05d19879a2898f2a53a353fc57bcd8ab59c19597f5b9de7124ea77401658c14aba0572721f3920e1b28521aacaf6067abade5362d789a3ec74db82403d3e8550ad300471dd9120c5c81ee47cec45f630a060a54c4941461aaae7d82f49009573af91141f54b94b50987522e91eedc619e645584c0960eb40a2fc6282af100cf6b03c6bd62be0b0090d038f7b7563f77a652bb9fc54f19d76cf9a0acf396c3c09182aecc2a710f018b9e734598053a816040d486e4a7b900ead365f547a6e30681968adc70371e33ca8218b03842c3d6fb303f434e0b6b17fdea7afa667d8b3580ccf491e69678b9af6e4773ffa91b47f1a80d7da5c371f01fd54d3576f8d1928cf1310d1223969a3297861de8835ae920c9791d2df9a26db2dcc750334aaf7b86e611f54fcfb6e6afc1fa36d1c60733fc1297e2158bf19100dcf55f7f2574d2448695174b08235dafa4cf404cacca2d2404b329f14f5ccb3b0622ce10d25fdd73bfd00c02d396955f5448fb1ed0c8d27f0c8243e003d65984c5ada79b5a2a722531fe798cdc10738bd97960a62313d5dc23e61eac7b51dd4e9f4faa808002a20b30cd6b1d6cd77d48a5c193713ca84970edf4f8e6da84c7436b39cdf5042bb32c1c3b91898db0efaf88304ad02f5fa7b307abbe0f80aa34ba2b3b5e63d2181874149151113c5dccc53fc4f4561aa8dce7a4d3bdeb29ed0fdaf0f571620535190f9334a74eb29e55bbac12a972cd95b9e1975fb05e9f536e3d6753c1b910ed0c0a9c528f0b111c29820d860483309a68ddffe93945f6ffcb9d41fa6a4f58d596ddca5e12372a131d5e69451dd294b945626e25934682b2fdf24652cfc7659803d08fabcf85fa349e461cf8ef0da8f3ebeacc172499f1622194c3c80369e81f42377c0594bfbcf037c7f6f2490cbdfe04cb158fcc10883ff03c36a828b9ff430b9e09781d115419aaa2d74f22d745cea2bbfc2e311b55f1c083e7bd16afabbd6db166a9d42f6ff3a1d696499a61f6913aaf04f44e2102ac6d9f0dfd587fd9aaf25f8d82dd6fdf018aa3107289ce70f625c508cf3018e18ba231ebc9a3ecf64cfb4f3742eaebf2ca988c9a98f1d30a8dbd72b1ccb4ec7f77f7dd76c542fdab4e722b24b072934763b72d0a9d66adfeed806844666980f341791493485c40690f0aaea4c32998783793b458d980ae9113a0d58047130a78c137e9a171c9a49292f6193182dee4ed038b13a86ef6cf6f3381a4851448fe02fab0ca715742de6d8742b7eaca74c532ed8c779c6de27ca14d2fef1c12e2f5c3f6fc496682891b634ddda6f46bc70550a4f2c7d024fd0be3d8e16ec9b636463a6cd39e564a8116095491641a2e60ed13f4184ecf6b02f6aa0afe724f596ef6306d14e82481a28b24266423e285a4832fa1b3553c2b97f2fcad3f4baa9914d2f4189f54a912f0ab6d35b59fe41f6b5932796b182717c6cb1ed63c1f483848e925fc8609b1d945b96d1008c2cab98820145823f31e595e7dffed31623adb0db0e54a134b03b42c9e514c480b52135c92e86c432f2a318d3ff771dcc96dccb4919c1e30c6e2842574f342efbbd4d21dbd2bd58f546c6761475365ee6b2b31c15b0f8985d519ca28ba02adc62e478c20eb3506ed51479ac0124abd01463daececeae799c0dd519cd83caaf28a253e9b7a306fa7b340c06d7bf39bd72b0a5501073365b379f24deb8c5ea95808c8856886b8f7307e208e01ac7b41918f7639458ec8de74722b552034254f297cfde4f55e996d7ec6b8ad2fc880ec12c3feb394333e51c02aab0dc27448ccc2e08ad5c8505c1d3463517f705ebc0b41226b4a0fa564aa1628dbc41c963726b95a743922c18bba925aa694eb9db433e2574281ab59924625aa3221e154057182b4cd987dcb74c1a34e3a59a67a1a08ca6dd4105b05defc5d13488e059603d61a038184ee9a0bba806bfc493cd717e59456c4ca46884d1e1bf6524ff17e557bddfad1f9b37ae1d2579933aba712b9237edae91d2e9233cd5f099513caf899f8aa7ca47f96289b437e0a219158db93435ed7215468202be6fd2e2269a6b2ed5570eefb9107516ad935d1c7ba95ae8c7168b38ba2855b9a4b5b3d9043a0c0b23c31827bebb7c0d19de8edc3a4a0670c4410c11d678995717390cd45ad002c1e9e7a0f747880fcea919d0a669e5eff8431b4e2c65db9deab791574ddfe89a7c93714b3217a6cc92c170fceeb596a41d69f6d20cdf89887493b5ee4f6a1bca7d6132276b029ef745ccea3fe1c959ef83ee0925aecdad2ad46942ddbc6b92d1ac48f0de20e41f8f5bcfb3cd8ab933ccd7308bb429e27be954f9f1b7e8dbca4e35906a61261dea606fb513604e54ecbd0b3a60d0330c6dbec4b2c5f75e678c4dfe11e39ba311c36013be0726a823f228bab93c1db384644c2175978bb49aae22fcff596cb85e4d0da51bc66a3b7836187fb5a1d36c9521aad9c81f4805ea5dda7aae6b1126a93e68880cefbb9cf7af1c7edab35d2823cde0e29c500afdf0d2319090e699126deb4d498fbe7612db6052c47fa3b5296258c1631a38596cc362d4a755cf3e285ee52caafd456d3f660c1379aa0419e5bbf78ba881215c3ee5a450291f583788d0c61c06adc594324b4e2aaeb6dff5bf38514b2395f7c1fcfc046e7f9f8d638364931e868cb585d083a0c4c8154e96d23d592a7908595d5af87659fd3fd10ae765617a776815f914c6172b04a25a078ecdc4192959a60964f26887094ae8decc588a30779dbc6300dda3dcc0dd2411a195cdea900dc15dd910cf5ccd606774eb0266696943098b29fee2d13f8dea6c9d9938d01e4fa1804f5f465058e494490b0747378cd140ed880ca0ee5ea888d7d86b00daadbfd1dad6c5838dc94d9eaccd6b46577625c38c92156c7d094f888e447db324f0de3ac2504238a75feb24d2fdc54f736834fe78b946896dfc04821f4b49078e71c8a0b4b7250641425937a09f6dbea1298006774418e715568fa590bc3a6d296fbebc61b62046750bccad510e6b2e95ea4246ec16849f5edd0277f0154f5428d0cd21b73f1389dfa11a44ad92db8dbd29d652aa6068b5077eb186ef7438a0a0eb1724434c024cf711957c307ac9f0dba67d636772699db6ec95439c1a41caa0806cd4b7466096bf5d64095379381bf433ce4516c4e6a9264c59f17e56cb3313d4cce31dd85deb937fcac583f7d424b900726a45ad9911f043c4942a956e02b94333ed30ffd6bd8dc20d4b2f64e0eda8490b19f9cc0ddbdb4350b536eceb1775950125eff7f5726146963d6eb1c4a23a70dadd7cfe43be068b80a3ca0ed1e86e732f2e3ee8695c553601ea7aa1b1c41e1dd96423265acad81c474dd3ebe102132a126bc66241fbd8d4cbf6a76094577186abbf4f139a38f8962a7821071fd22c6cacefc30dd67b2472847387b4f2ab99c91c6e065fc6d24fc9f499169f00d8717c0a0753ddbd49ebd5f0784be59730ed971e380e55057587fe99051a8730e0d801ad8a166c3bef25210ce20b4501ed1895e35ff59d04c20c25db5862016291f3a216c07c2834c0021c9ef8095cb80d9dd433cc2dfa0a3cbfd59ce9781041fbf2ce7e0b3b04ad4b6b72d67c558e281b52074460ca9e150dff55f5c3e5a490ba0450ce8c915cd98abac2ac2c5e62486331586ca774f88241448f0467c959a498d5132c823ef5a76566f5f155ecda4c6b6ccd9df89d7895ce6c1d8d4f789cb2d34e6273bef28bc0be77fd9b26952f985728af95c47fa6e1a5d0fe3c54105b9ffbb8bcd2dc1478ed9cef25cd36768bd6f173c237b15acbeb21ba2f5a2f14e3af4635dca1686b5b3c653d59e77756cc9a1dee85f229213c1142312783dd586f294f74abd4e04fec4284b617bbe4583c5e9072fcb25f3dd4f7c25503c9db434edb64fe5500745a258dbc5a2b58a03539879051b8402459d52dcd29f0d7e38ab8f5ecdf0ed1aaf53d9055a7b091d68d1c46c41f33d03346aeba3563e3a2bcb413c1684925452f89322227bd66a59c7420162aea8857a16575149c8932419cfce06159696dd0bfacb50364cae5a373d6dcc1cbe2a7d0bb4beb9665c33324efd94cf85339ba15bc032613bbd8b770bf411a111255b3278e4b363af4427149909671b981cf7371fd1da114bacf573046f6729242fe837e3cc386c8ba197dd63376fc05a6d5ff5aeae228f4c3c823ca04f1a80116f377c15c100e489e0ad19a2e35e2865ca784c5ea6170e6b7c048af56adc77b33a9da6171fb6ff9c0454e905fb407efdab5c531535d0f85ba5445df9a7c0c072d90cec21faffbeb0dda3a0934953256a1464f22b244380d861feb2bdd14ad23a54145a24dfb6fae3bc41d985b9d72a4aa4bf056e2b233a644d5b79311f265821fecf22139f26bc90d33bcb9ca1e61722fb03b9a19aed38872c425d9bbf14c5fb4933eebd68bb98f23bacc40a2dc7a50da8013ce6d31d31dcded07a558c592aaf63b209d49f71db4fec63b38ff36b4b3b88887c900db304f23631c9779a1232ca6f1572cbfbbd1f953697425669bb4b783137a6cfbb63ffec9905eebde73c50e173205946b80c3864eeec6ba45b91010cbc61156fa09b9b14c480d66f916d99219ec7690709f3c4931e30cb03f1c5798fb7ae17c2454d1942a39a209f5bfb710e6f26631aa94f3196d5b1261220c82fcc8d647d30a28f72653d26890140d904e0f6ebb579795771574a87fc3bea21f10cfce3f2a21bb4e2d3a9939a2c4430c28e6f2d2e25ff07a80a64ebd578e0dd6ab26499737e022bd11ccd71f58da27b981ea0eea5f0dbc0e538bfa96c13b711a5dd5670f9e328e410d4ab1a97ba73f25489a3ffeceba505f40c475ceb598613d548f1b253c01ac26d01e5167f40db3ba829597f0fe72539eb0687e396659f56d1da2d7127900a29080e8e790ba0ad1a2a1f46a7b3ce540b8d515f9d180a745857e55b7d7e5cef5c516815ef85deb41ac9d496da9918b7b5ac36b8d885e1b157bc7c7cb89021916e03fb514edf24c1c657cfce5fc8bec4b1a880170d35bee215fbe2bdd27ad088700c1eb511418a87be44f277f44200ce5bb5ee33a3ee9f81ff4f6589a076d8fae35801f1ab4494dd71a7d4a3ec998ed95632da18ea503e243892f9fdaa55ed5168b1376eb8f724abc10915c2a3a0f55ba295d22ec4875e3949dddc1621af1afad62f4a05016375724538d5edefa869188ddd8717c4d22fa8bee826be711526f32da8d44213227455c2eb2861e58523427dc673fa41661ad54ff59db0328d6a4828b1114e52a7b15325596dd6f9d7e9e24b598fcaec6611ee152d3aefe78591afffeb3919c4dc0d912721597cdf68f35c50d02c3f491e5b8ad2d47ba9cdabf0792a3fa95484778b8e34a51cda19c7a34dfe2ff43d0dbd85819a5aabae263d22db9ecf2ad24c51fccd34083df702f33e30f6b6b5c07c93ae96695fdbe0023b19c9e7ca7546d9f6c92866e6d6ab2083447c83d48cb5f4be668872a5668acc674f38aba57d2c2f73c1251e26bd1658367da620165028a69fecf184345e55e156be5ebb08aa18fd94ca904deb5e53b5b5449b28655b83af9e5fbcd0ff4a8da450a3d0da6117deb93b25cae5199ba916f89cccba5bad365e4c84985ddeca4b1b3378647ef3cd40daa43761c9cb1b1e76185a9c2f469e068ecb57f7915a502caa53a7361863711ba0e260d69ed5af2b5253830ad4b1b51149c52ff036c99cc06161b9391acf357a67b1c5099462e2593afcdd13ef12591f4fd8d0a93bce619e578b160cd8c777205dc37f6a0b1c4f2acb3e224e6193481bf289491bb92cbc8cb1fdea992d2d14843b5f7fc358c480d588ed708fb446447452043233a0238d55741c3e6497e98ebcdaaed2555bb362efc9d21c7357f9916521bf2066362cb6c945ca4b936737cedd73e827c79955c2373d13c0036fae87f1dcdc217f52828789fd605edf06821b824df66a1d579ab4d96b55260d16bb6d8aeb9f9b409a1b7c057a4ecf2ad3b2630bb24d8faf9036b186c8597500393b2fd7e401cf26f6070726f287111416bead5fedeb032b46ea05ecb35c30bf8157ce61ae5a3b6ea29d704380a6d61b456118914ec33751229e03c3110e44f12b083deb0f504ad34f45e2b7e47e57bfdcd9ab2831fb89d266a52dcdf4bf211c5c62a29224a1002cafe989f373a3534506e248fbaa41fc559c717186ccb9684b5f5791a0656981cd8cf5233f2d77ec0843bd15c334c42b5b5759342976a98e038512555939f23452d2140cce428f3e71dd4c3a4ba8e7a1603238862f3de2007cb8a1fc4f4227da880db58c445cf844c45f05b4bdbb3e53373ba60f27ce4327f90a261d70ba0fd167e396c76fe8b29a3cc25c9ee1dc15e2fffa1bfaa173ec92d9bff368bcc4379d8fefdb54cf8744bc5191e35875775d4ead1e4775befad09129ff83c485da1c899730bc4d0d4258e337a126927eb7602da8d097d3755b647ee938919123e8d9a0a4fbe8219514706edb177480531e605ffda0d8e0c49258f9299430bc3384202bfb55560d36b016ca6c7be45d108854eeeb4b01b832dee63fc892af7f63096ab75cabe8c1f65d406dcf9ea86817edb0b2d1a509d7d7ecad54f93d62096e8bee03f4e87bdae191fb7f012edf2022884a0b3205985bcf2546cf4eacd8058e1fd0c9e4173703740fba707693a5914cf9aa21fe5b58f0a3fba314bc14f22ee1549e32e810936a012f27ad707d4e02725c980ae9b56b28864de0bff5daea4d0f50fcdbd8f96602e5343e41931a858c2e3a895cceb0464a633466dd803c88053667ed32439c0ced993cb7d9c771e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 我的生活记录 </category>
          
          <category> 密码与保密文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重要 </tag>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的阅读记录</title>
      <link href="/2022/06/28/My-book/"/>
      <url>/2022/06/28/My-book/</url>
      
        <content type="html"><![CDATA[<style type="text/css">.tg {  border-collapse: collapse;  border-spacing: 0;  width: 100%; /* 表格宽度为100% */  table-layout: auto; /* 允许表格根据内容自动调整列宽 */}.tg td {  border-color: black;  border-style: solid;  border-width: 1px;  font-family: Arial, sans-serif;  font-size: 14px;  overflow: hidden;  padding: 10px 5px;  word-break: break-all; /* 允许单词内换行 */  white-space: normal; /* 允许文本换行 */}.tg th {  border-color: black;  border-style: solid;  border-width: 1px;  font-family: Arial, sans-serif;  font-size: 14px;  font-weight: normal;  overflow: hidden;  padding: 10px 5px;  word-break: break-all; /* 允许单词内换行 */  white-space: normal; /* 允许文本换行 */}.tg .tg-0pky {  border-color: inherit;  text-align: left;  vertical-align: top;}.tg .tg-fymr {  border-color: inherit;  font-weight: bold;  text-align: left;  vertical-align: top;}.tg .tg-0lax {  text-align: left;  vertical-align: top;}</style><table class="tg">  <colgroup>    <col style="width: 70.2px">    <col style="width: 232.2px">    <col style="width: 208.2px">    <col style="width: 519.2px">  </colgroup>  <thead>    <tr>      <th class="tg-0pky">类型</th>      <th class="tg-0pky">名称</th>      <th class="tg-0pky">时间</th>      <th class="tg-0pky">备注</th>    </tr>  </thead>  <tbody>  <tr>    <td class="tg-fymr" rowspan="5">书籍</td>    <td class="tg-0pky">《南京大屠杀》</td>    <td class="tg-0pky">2023/01/09</td>    <td class="tg-0pky"> <a href="https://book.douban.com/subject/26545308/">《南京大屠杀》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1ET411E7Ln">《张纯如_南京大屠杀》- bilibili</a> </td>  </tr>  <tr>    <td class="tg-0lax">《尼罗河上的惨案》</td>    <td class="tg-0lax">2023/06/05</td>    <td class="tg-0lax"><a href="https://book.douban.com/subject/25697546/">《尼罗河上的惨案》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1FW411P7ae">《尼罗河上的惨案 木鱼水心》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《呐喊》</td>    <td class="tg-0lax">2023/06/10 - 2023</td>    <td class="tg-0lax"><a href="https://book.douban.com/subject/1449351/">《呐喊》- 豆瓣</a>、<a href="https://space.bilibili.com/79577853/channel/collectiondetail?sid=572">《谈鲁迅系列 智能路障》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax"></td>    <td class="tg-0lax"></td>    <td class="tg-0lax"></td>  </tr>  <tr>    <td class="tg-0pky"></td>    <td class="tg-0pky"></td>    <td class="tg-0pky"></td>  </tr></tbody></table><table> <tr> <td style="word-wrap: break-word; word-break: break-all; width: 100%; background-color: HoneyDew;"> <span style="font-size: 16px;"> <strong>🎉2025阅读计划</strong></br>知识学习：《网络是怎样连接的》、《Linux命令行与Shell脚本编程大全》</br>文学：《我与地坛》、《毛选第一卷》</span> </td> </tr> </table>]]></content>
      
      
      <categories>
          
          <category> 我的生活记录 </category>
          
          <category> 书音影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的观影记录</title>
      <link href="/2022/06/27/My-movie/"/>
      <url>/2022/06/27/My-movie/</url>
      
        <content type="html"><![CDATA[<h1 id="1-观影记录"><a href="#1-观影记录" class="headerlink" title="1 观影记录"></a>1 观影记录</h1><style type="text/css">.tg {  border-collapse: collapse;  border-spacing: 0;  width: 100%; /* 表格宽度为100% */  table-layout: auto; /* 允许表格根据内容自动调整列宽 */}.tg td {  border-color: black;  border-style: solid;  border-width: 1px;  font-family: Arial, sans-serif;  font-size: 14px;  overflow: hidden;  padding: 10px 5px;  word-break: break-all; /* 允许单词内换行 */  white-space: normal; /* 允许文本换行 */}.tg th {  border-color: black;  border-style: solid;  border-width: 1px;  font-family: Arial, sans-serif;  font-size: 14px;  font-weight: normal;  overflow: hidden;  padding: 10px 5px;  word-break: break-all; /* 允许单词内换行 */  white-space: normal; /* 允许文本换行 */}.tg .tg-0pky {  border-color: inherit;  text-align: left;  vertical-align: top;}.tg .tg-fymr {  border-color: inherit;  font-weight: bold;  text-align: left;  vertical-align: top;}.tg .tg-0lax {  text-align: left;  vertical-align: top;}</style><table class="tg">  <colgroup>    <col style="width: 60px">    <col style="width: 270px">    <col style="width: 270px">    <col style="width: 520px">  </colgroup>  <thead>    <tr>      <th class="tg-0pky">类型</th>      <th class="tg-0pky">名称</th>      <th class="tg-0pky">时间</th>      <th class="tg-0pky">备注</th>    </tr>  </thead>  <tbody>  <tr>    <td class="tg-fymr" rowspan="22">影视</td>    <td class="tg-0pky">《子弹列车》</td>    <td class="tg-0pky">2023/01/06</td>    <td class="tg-0pky"><a href="https://movie.douban.com/subject/35118954/">《子弹列车》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1BB4y1775g">《子弹列车》- bilibili</a> </td>  </tr>  <tr>    <td class="tg-0lax">《毛骗(1-3季)》</td>    <td class="tg-0lax">2023/02/06(模糊)</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/4888230/">《毛骗 第一季》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1ot411J7sQ">《毛骗 工藤新医》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《七号房的礼物》</td>    <td class="tg-0lax">2023/02/06(模糊)</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/10777687/">《七号房的礼物》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1pe41147Hh">《七号房的礼物 何止电影》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《小鞋子》</td>    <td class="tg-0lax">2023/07/23</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/1303021/">《小鞋子》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1BW411T7gP">《小鞋子 木鱼水心》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《1408幻影凶间》</td>    <td class="tg-0lax">2023/08/13</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/1793903/">《幻影凶间》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1ca411W7Yo">《幻影凶间 史蒂芬周大反派》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《偷听女人心》</td>    <td class="tg-0lax">2023/08/15</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/1295078/">《偷听女人心》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1ea4y1v73W/">《偷听女人心 科幻梦工厂》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《泰迪熊1》</td>    <td class="tg-0lax">2023/09/17</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/4807924/">《泰迪熊1》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1Ep4y137jd">《泰迪熊1 散装官人》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《泰迪熊2》</td>    <td class="tg-0lax">2023/09/17</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/19957083/">《泰迪熊2》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1wz4y1W762">《泰迪熊2 散装官人》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《无罪之最》</td>    <td class="tg-0lax">2023/09/30</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/34926405/">《无罪之最》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1qp4y1478h/">《无罪之最 木鱼水心》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《无名女尸》</td>    <td class="tg-0lax">2023/10/22</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/26339213/">《无名女尸》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1XW4y1H7T6/">《无名女尸 史蒂芬周大反派》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《穆赫兰道》</td>    <td class="tg-0lax">2023/10/25</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/1292217/">《穆赫兰道》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1PL4y167R9/">《穆赫兰道 小片片说大片》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《七宗罪》</td>    <td class="tg-0lax">2023/10/27</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/1292223/">《七宗罪》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1nz4y1t7F9/">《七宗罪 太和的房间》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《白日梦想家》</td>    <td class="tg-0lax">2023/11/3</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/2133323/">《白日梦想家》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1QP41197RC/">《白日梦想家 阿斗归来了》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《源代码》</td>    <td class="tg-0lax">2023/11/25</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/3075287/">《源代码》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1tE411s7XF">《源代码 电影最TOP》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《明日边缘》</td>    <td class="tg-0lax">2021/*/*</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/4746257/">《明日边缘》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1uu411N7rX/">《明日边缘 迷影至下Filmlast》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《通缉令》</td>    <td class="tg-0lax">2021/*/*</td>    <td class="tg-0lax"><a href="https://movie.douban.com/subject/1945336/">《通缉令》- 豆瓣</a>、<a href="https://www.bilibili.com/video/BV1YF411Z7Ax/">《通缉令 影迷驿站》- bilibili</a></td>  </tr>  <tr>    <td class="tg-0lax">《唐朝诡事录（1-2季）》</td>    <td class="tg-0lax">2024/*/* - 未完结</td>    <td class="tg-0lax"></td>  </tr>  <tr>    <td class="tg-0lax">《黑袍纠察队 第四季》</td>    <td class="tg-0lax">2024/*/* - 未完结</td>    <td class="tg-0lax"></td>  </tr>  <tr>    <td class="tg-0lax">《目中无人》</td>    <td class="tg-0lax">2024/03/30</td>    <td class="tg-0lax"></td>  </tr>  <tr>    <td class="tg-0lax">《少年歌行 电视剧版》</td>    <td class="tg-0lax">2025/03/17 - 2025/3/22</td>    <td class="tg-0lax"></td>  </tr>  <tr>    <td class="tg-0lax"></td>    <td class="tg-0lax"></td>    <td class="tg-0lax"></td>  </tr> <tr>    <td class="tg-0lax"></td>    <td class="tg-0lax"></td>    <td class="tg-0lax"></td>  </tr> <tr>    <td class="tg-fymr" rowspan="25">动漫</td>    <td class="tg-0pky">《斗破苍穹》</td>    <td class="tg-0pky">2023/*/* - 正在更新中</td>    <td class="tg-0pky"> <a href="https://v.qq.com/x/cover/mzc0020027yzd9e/q0043cz9x20.html">《斗破苍穹》- 腾讯视频官方</a>、<a href="https://www.gying.net/ac/GEvK">《斗破苍穹》- 免费网站</a></td>  </tr>  <tr>    <td class="tg-0lax">《完美世界》</td>    <td class="tg-0lax">2023/*/* - 正在更新中</td>    <td class="tg-0lax"><a href="https://v.qq.com/x/cover/mcv8hkc8zk8lnov/x0036x5qqsr.html">《完美世界》- 腾讯视频官方</a>、<a href="https://www.gying.net/ac/P8Pr">《完美世界》- 免费网站</a></td>  </tr>  <tr>    <td class="tg-0lax">《画江湖之不良人》</td>    <td class="tg-0lax">2023/*/* - 未完结</td>    <td class="tg-0lax"><a href="https://v.qq.com/x/cover/o85sk7hqhbw3g9n/y0014r283na.html">《画江湖之不良人》- 腾讯视频官方</a>、<a href="https://www.gying.net/ac/lwbJ">《画江湖之不良人》- 免费网站</a></td>  </tr>  <tr>    <td class="tg-0lax">《秦时明月》</td>    <td class="tg-0lax">2024/*/* - 未完结，已死</td>    <td class="tg-0lax"><a href="https://v.qq.com/x/cover/mzc002001kt6n30/h0033i56bl1.html">《秦时明月》- 腾讯视频官方</a>、<a href="https://www.gying.net/ac/kV66">《秦时明月》- 免费网站</a></td>  </tr>  <tr>    <td class="tg-0pky">《天行九歌》</td>    <td class="tg-0pky">2024/*/* - 未完结，已死</td>    <td class="tg-0pky"><a href="https://v.qq.com/x/cover/rm3tmmat4li8uul/w0019k37ecc.html">《天行九歌》- 腾讯视频官方</a>、<a href="https://www.gying.net/ac/Xy2d">《天行九歌》- 免费网站</a></td>  </tr>  <tr>    <td class="tg-0pky">《少年歌行》</td>    <td class="tg-0pky">2024/*/* - 正在更新中</td>    <td class="tg-0pky"><a href="https://www.bilibili.com/bangumi/play/ep259013?spm_id_from=333.337.0.0&from_spmid=666.25.episode.0">《少年歌行》- Bilibili官方</a>、<a href="https://www.gying.net/ac/YXJ8">《少年歌行》- 免费网站</a></td>  </tr>  <tr>    <td class="tg-0pky">《火影忍者》</td>    <td class="tg-0pky">2024/*/* - 已完结</td>    <td class="tg-0pky"><a href="https://v.qq.com/x/cover/mzc00200nc1cbum/n4100jkneti.html">《火影忍者》- 腾讯视频官方</a>、<a href="https://www.gying.net/ac/JJzb">《火影忍者》- 免费网站</a></td>  </tr>  <tr>    <td class="tg-0pky">《火影忍者剧场版：终章》</td>    <td class="tg-0pky">2024/*/* - 已完结</td>    <td class="tg-0pky"><a href="https://www.gying.net/mv/1xM9">《火影忍者剧场版：终章》- 免费网站</a></td>  </tr>  <tr>    <td class="tg-0pky">《火影忍者剧场版：忍者之路》</td>    <td class="tg-0pky">2024/*/* - 已完结</td>    <td class="tg-0pky"><a href="https://www.gying.net/mv/eLm2">《火影忍者剧场版：终章》- 免费网站</a></td>  </tr>  <tr>    <td class="tg-0pky">《神印王座》</td>    <td class="tg-0pky">2024/*/* - 正在更新中</td>    <td class="tg-0pky"><a href="https://v.qq.com/x/cover/mzc002007j7p5hn/k0042sids9q.html">《神印王座》- 腾讯视频官方</a>、<a href="https://www.gying.net/ac/EJOD">《神印王座》- 免费网站</a></td>  </tr>  <tr>    <td class="tg-0pky">《赘婿》</td>    <td class="tg-0pky">2025/1/5 - 2025/1/7， 未完结</td>    <td class="tg-0pky"><a href="https://www.bilibili.com/bangumi/play/ss39708?spm_id_from=333.337.0.0">《赘婿》- Bilibili官方</a>、<a href="https://www.gying.net/ac/EJYw">《赘婿》- 免费网站</a></td>  </tr>  <tr>    <td class="tg-0pky">《白蛇：缘起》</td>    <td class="tg-0pky">2025/1/20 - 已完结</td>    <td class="tg-0pky"><a href="https://www.tdgo.shop/vodplay/19598-1-1.html">《白蛇：缘起》- 免费网站</a></td>  </tr>  <tr>    <td class="tg-0pky">《刺客五六七》</td>    <td class="tg-0pky">2025/2/1 - 2025/2/5， 未完结</td>    <td class="tg-0pky"><a href="https://www.bilibili.com/bangumi/play/ss6360?spm_id_from=333.337.0.0">《刺客伍六七》- Bilibili官方</a></td>  </tr>  <tr>    <td class="tg-0pky">《秦汉英雄传》</td>    <td class="tg-0pky">2025/2/11 - 2025/2/15，完结</td>    <td class="tg-0pky"><a href="https://www.bilibili.com/video/BV1yx411K7nY/?spm_id_from=333.337.search-card.all.click&vd_source=78e1f2016c0ed006b58600755ec51c9b">《秦汉英雄传》- Bilibili官方</a></td>  </tr>  <tr>    <td class="tg-0pky">《三国演义》</td>    <td class="tg-0pky">2025/2/16 - 2025/3/16，完结</td>    <td class="tg-0pky"><a href="https://www.bilibili.com/video/BV1nx411N7uq">《三国演义》- Bilibili官方</a></td>  </tr></tbody></table><table> <tr> <td style="word-wrap: break-word; word-break: break-all; width: 100%; background-color: HoneyDew;"> <span style="font-size: 16px;"> <strong>🚀2025观影计划</strong></br>电影：</br>喜剧：《加油吧威基基》</br>国产动漫：《斗破苍穹》、《完美世界》、《少年歌行》、《秦汉英雄传》、《三国演义》</br>日本动漫：</br></span> </td> </tr> </table><p>链接1：<a href="https://www.douban.com/doulist/44150794" target="_blank"  style="color: #007bff; text-decoration: none; font-weight: bold; transition: color 0.3s ease;"> 国漫崛起（7分至7分以上）- 豆瓣 </a> </p><h1 id="2-观影影评"><a href="#2-观影影评" class="headerlink" title="2 观影影评"></a>2 观影影评</h1><h2 id="2-1-鬼子来了【22-02-11】"><a href="#2-1-鬼子来了【22-02-11】" class="headerlink" title="2.1 鬼子来了【22-02-11】"></a>2.1 鬼子来了【22-02-11】</h2><div class="table-container"><table><thead><tr><th>豆瓣</th><th>B站</th></tr></thead><tbody><tr><td><div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/1291858">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2553104888.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2553104888.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>鬼子来了(2000)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>姜文</span></div>            <div class="douban-card-item"><span>主演: </span><span>姜文/香川照之</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>2000-05-12(戛纳电影节)</span></div>            <div class="douban-card-item"><span>评分: </span><span>9.3</span></div>        </div>    </a></div></td><td><div class="bvideo"><a href="//www.bilibili.com/video/BV1Wx41157LP" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/69b07d9131be3f5dcd1fc1ea0bf33e44ce3e4613.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:20:54</span>            </div>            <div class="bvideo-info">                <p class="title">细读经典 20: 真正的抗日神片《鬼子来了》</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>134.8万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>7942</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">电影最TOP</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div></td></tr></tbody></table></div><p><strong>转载影评：</strong></p><p>终于看了姜文被禁止公映的《鬼子来了》，很多人都将这部片子的禁止公映解说为该片中绝口不提共产党抗日，自始至终未出现一个党员形象，因此而引起不满。但看了这部片子才知道决不是因为这个原因。</p><p>《鬼子来了》讲的是川北抗战的故事，在那个叫挂甲台的小村落里老百姓无知的固守着自己的善良，却悲惨的被鬼子集体屠杀。而且这场大屠杀发生在日本天皇发表投降诏书之后！中国的农民是淳朴而且安于现状的，他们被诸多的势力欺压了两千年，形成的秉性却温顺贤良。可以想见，当小鬼子们没有进行烧杀戮掠的时候，老百姓虽然会心有不甘，但真的是尚不至于奋起以命相搏（并不是说老百姓就不爱国，而是在那样一个自给自足、封闭且未开化的时期里，“爱国”还是一个虚幻的理念）。片中有大量的这样的痕迹，在那个被日军牢牢把持的小地方，因为没有国军和共军的争夺而显得相对安宁，小日本对当地人进行着和平的奴役。习惯了被压迫的老百姓已经对于尊严的事情麻木了，为了生计这样的眼前利益而过分乐观的活着。小镇上唱曲的在集市上宣扬着皇道乐土，教育众人中日“八百年前是一家”，村落里老百姓见了鬼子一口一个“森塞”的叫着。固执的不肯杀人的村民们为了结果被俘的鬼子，费尽周折请刀斧手，最终得到的结论是这鬼子命不该绝。并最终同意了鬼子用人换粮的建议。</p><p>烧杀掳掠外加奸淫妇女，这是鬼子留在中国人心目中固有的形象。但在这部片中的开始，虽然老百姓见了鬼子依然是战战兢兢有着被杀的危险，但小鬼子们仅是打骂并未随意杀人。不过，小鬼子们的武士道精神和对中国人的残忍施暴的一面却被生动形象的刻画出来。两个场景就可以进行完全的阐释： </p><ul><li>一、炮楼里的两个鬼子溜出来想吃鸡，老兵教新兵如何粗暴的对待中国人，如何利用自己手中的刺刀，并说“对付支那猪就只有用这种办法”； </li><li>二、被囚半年兽性冷却后的小三郎在所谓的鬼子＋百姓的联欢中得意忘形，对中国人大声说着“大哥大嫂过年好，你是我的爷，我是你的儿”，但明显喝高了的他在队长一番激励下，兽性大发对养活了他半年的村民们举起了屠刀。</li></ul><p>凡中国人与外族的殊死争斗，敌阵中必有我国人！这简直是个千古不变的道理！汉武帝征讨匈奴，有前宫人在匈奴王帐中出谋划策；抗日战争中更是伪军比日寇数量都多！这部片子中着重刻画了翻译这个角色，这个懂日本话的东北人几乎没有一句是在“直译”，国人对国人的欺瞒才是最可悲的事情。而且这个翻译在被村民释放后居然给鬼子队长出主意让鬼子爽约，结果招来一句奚落：“我们日本人不像你们中国人那样不讲信用。”这句话对我来说真的是太刺耳了。</p><p>悲剧就是把美好的东西打碎给人看。这部片子的结局是挂甲台整个村落在大火中消失在鬼子的屠刀下，而国军的抗战将领又让斧劈日本战俘的三儿受戮于已经被俘的小鬼子。这就是中国人的悲哀。为什么这样一个国土辽阔人口众多的民族被一个岛国践踏了整整八年，这部片子给了我们一定的启示。很多时候，不是别人的凶残和强大，而是我们自己的愚昧和自残。</p><p>从联合早报网上看到消息，东京举行了一个反华游行，理由是中国还没有对去年4月份爆发的反日游行向日本人道歉。不明白为什么这个世界上还有如此不讲道理的人种，但是毕竟有这样的邻居，有惨痛的教训，我们只能用《霍元甲》中的那句震撼的台词一样——“自强不息”！ </p><blockquote><p>作者：豆瓣用户——俩飞</p><p>原文链接：<a href="https://movie.douban.com/review/1045537/">https://movie.douban.com/review/1045537/</a></p><p>侵删</p></blockquote><h2 id="2-2-爆裂鼓手【22-02-15】"><a href="#2-2-爆裂鼓手【22-02-15】" class="headerlink" title="2.2 爆裂鼓手【22-02-15】"></a>2.2 爆裂鼓手【22-02-15】</h2><p><strong>转载影评：</strong></p><p>作为今年圣丹斯的获奖影片和奥斯卡热门，影片的上佳口碑主要来自于紧凑的剪辑、优质的表演和对于师徒关系非常规的刻画。诚然，影片的剪辑凌厉而准确，除结尾处有少许松懈，整部电影更像是一部动作悬疑片，节奏一再加快，冲突一再升级，影片结束，107分钟不知不觉中过去。影片对于音乐的处理也相当不马虎，体现了对于细节的重视和专业精神。</p><p>然而，如果将电影解读为描绘师徒关系，以及少年经历魔鬼训练，超越极限，从而实现自我的励志电影，大概是个误会。片中鼓手和指挥从始至终是纯粹的互相利用关系。鼓手其实从未得到特殊待遇——他始终是乐队中和其他乐手一样微不足道的一员，随时被指挥予取予求，玩弄于鼓掌之间。在鼓手坦陈指挥对于乐队的虐待，间接导致指挥离职之后，酒吧相遇，看似一番肺腑之言，实际上指挥已暗暗设计陷害，如若没有鼓手最后的破釜沉舟，一个乐手的生涯就要万劫不复（影片一再强调在卡内基演出对于音乐生涯的决定性作用）。即使仇人之间，若有一丁点原则和不忍，做事尚不会如此残忍，何况师徒。</p><p>鼓手本身也并非传统的善良天才少年。一定的才华和逼迫自己到极限的决心也许天才少年皆有，但是本片主角个性中的偏执和阴暗才是他一直被指挥吸引，也是指挥最后透露出欣赏的主因——鼓手一定程度是年轻版本的指挥，同样为达目的不择手段。影片中有诸多巧合，其中鼓手丢失首席鼓手让他代为保管的乐谱一节，其实颇值得思量。鼓手是否真的如观众期待那样无辜？未必。台词给出许多暗示：首席为自己辩解时说自己因身体有恙不能记谱，指挥早就知晓（那么其他乐手自然也知道）。鼓手在事发之后毫无愧疚，也从未想过补偿。键盘手似开玩笑让鼓手不要动自己的谱子，未必不是防人之心，等等。鼓手在争夺首席位置、与女友分手和佯作无辜答应指挥帮助演出时也同样毫无愧怍。因为同样认同追求卓越就要牺牲自我、他人，以至阻碍道路的一切，鼓手才会被指挥一番话吸引从而上钩，因为指挥的人生哲学实际道出了鼓手的心声。整部影片细述了鼓手从安德鲁到弗莱彻的渐变，最后一幕父亲在后台观看鼓手的独奏，眼神中惊恐多于欣慰，因为眼前的少年早已不是曾经一起吃爆米花开玩笑的儿子，技术上的提升和人性的嬗变相比已经显得次要。</p><p>本片导演说结尾实际是悲剧，主要媒体的影评也多少在这一点达到共识，大概正是为此。片中固然有励志的成分，但是成功的代价是少年纯真的丧失，如果本来尚有纯真的话。结尾高潮处影院中的观众畅然拊掌，其实是庆祝这种扭曲哲学的胜利——鼓手大概经此洗礼，从此更加坚定目标，不顾旁人，不择手段，从而一帆风顺。更可怕的是，等他自己成为别人的老师，恐怕也要把这样的哲学传递下去了。相对于严师是否定出高徒、学艺之路如何逼迫自我突破极限这类常规主题，影片提出的问题更集中于追求极致（无论目标是艺术的完美还是名利的丰收，也无论是否关于音乐）和葆有灵魂的平衡取舍。</p><blockquote><p>作者：豆瓣用户——Z</p><p>原文链接：<a href="https://movie.douban.com/review/7265093/">https://movie.douban.com/review/7265093/</a></p><p>侵删</p></blockquote><h2 id="2-3-寻梦环游记【22-02-17】"><a href="#2-3-寻梦环游记【22-02-17】" class="headerlink" title="2.3 寻梦环游记【22-02-17】"></a>2.3 寻梦环游记【22-02-17】</h2><div class="table-container"><table><thead><tr><th>豆瓣</th><th>B站</th></tr></thead><tbody><tr><td><div class="douban-card-block">    <a class="douban-card" href="https://movie.douban.com/subject/20495023">        <div bg-lazy class="douban-card-bgimg" style="background-image: url('https://images.weserv.nl/?url=https://img2.doubanio.com/view/photo/s_ratio_poster/public/p2505426431.jpg');"></div>        <div class="douban-card-left">            <div bg-lazy class="douban-card-img" style="background-image: url('https://images.weserv.nl/?url=https://img2.doubanio.com/view/photo/s_ratio_poster/public/p2505426431.jpg');"></div>            <div class="douban-card-status">灯影绰约</div>        </div>        <div class="douban-card-right">            <div class="douban-card-item"><span>电影名: </span><strong>寻梦环游记Coco(2017)</strong></div>            <div class="douban-card-item"><span>导演: </span><span>李·昂克里奇/阿德里安·莫利纳</span></div>            <div class="douban-card-item"><span>主演: </span><span>安东尼·冈萨雷斯/盖尔·加西亚·贝纳尔</span></div>            <div class="douban-card-item"><span>上映时间: </span><span>2017-11-24(中国大陆)</span></div>            <div class="douban-card-item"><span>评分: </span><span>9.1</span></div>        </div>    </a></div></td><td><div class="bvideo"><a href="//www.bilibili.com/video/BV1pW411e7oF" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i2.hdslb.com/bfs/archive/a4840b6079f876e0e31075471d2f9c7e3fca0148.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">00:15:49</span>            </div>            <div class="bvideo-info">                <p class="title">【木鱼微剧场】《寻梦环游记》</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>116.3万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>4647</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">木鱼水心</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div></td></tr></tbody></table></div><p><strong>转载影评：</strong></p><p>5星推荐，片子真的好看，适合全年龄层。孩子们可以看到梦想，看到童趣，看到动画乐园一般的亡灵世界。大人可以看到亲情，看到爱情，看到梦想与责任，看到人性善恶。老年人会更感动吧，家人就是要生活在一起，要互相体谅，互相扶持。</p><p>最令我感动的一幕是，小孩回到家，他的太奶奶要去世了，忘记了亲人。小孩弹吉他唱起了“请记住我”，歌声响起，我的眼泪跟着落下。老奶奶眼睛亮起，跟着唱出来，亲人还在我们心里。</p><p>电影构建的死后世界很华丽，美轮美奂，就象一个巨大的游乐场。亡灵们很萌，白骨间的随意组合带来各种意料之外的笑点，不恐怖反倒很有趣。这个世界建立在另一个活人世界的记忆上，凡是在世的人记得的有照片的人，就可以在亡灵世界存在，反之就彻底消亡。所以一个家族代代传承的记念和供奉，会让家族中死去的人在另一个世界快乐的永生。</p><p>鲁迅说，亲人或余悲，他人亦已歌。确实，当人们不再记得一个人，他就真的消失了。如果世界的规律真是如此，我们活着的时候就应该更善意，更有责任感，更关爱家庭，关爱亲人，大家更团结，影响更多的人，这样当我们死去时，才会被人纪念，才会一直活在亲人和世人的心里。</p><p>看了电影，很希望亡灵世界就是这样的，我们的亲人也快乐的在。</p><p>另：这个逻辑基础下，还是当名人划算，你看电影里那个歌手，明明是个坏人，死后几十年了，还有无数的歌迷送无数的礼物，可以在亡灵世界风生水起。按这个设想一下，大魔头类的，会不会也因为被无数人记住而永生呢。</p><blockquote><p>作者：豆瓣用户——雪</p><p>原文链接：<a href="https://movie.douban.com/review/8999006/">https://movie.douban.com/review/8999006/</a></p><p>侵删</p></blockquote><h2 id="2-4-催眠大师【22-02-23】"><a href="#2-4-催眠大师【22-02-23】" class="headerlink" title="2.4 催眠大师【22-02-23】"></a>2.4 催眠大师【22-02-23】</h2><p><strong>转载影评：</strong></p><p>今天电影催眠大师上映了，凑了个热闹，第一时间看到这部电影的公映，以国产电影的水准，应该算得上一部‘好电影’了，悬疑+惊悚，不仔细推敲的话，应该是勉强达到了观众的期待值。同时，电影里运用了大量的催眠理论和催眠技术，并且做了艺术的夸张，相信一定让很多观众迷惑，怀疑，不解，让人感觉玄之又玄，虚之又虚。本文，笔者就根据所学的有限的催眠知识，免费给这部电影做一次答疑解惑，也尽自己的一份力解除电影对于催眠术的误导。解释过程尽量做到不剧透吧，免得被喷！</p><p>首先科普一下催眠的几个深度，最广泛接受的划分方法是将催眠程度分为六个等级：</p><p>第一级催眠深度：小肌群受到暗示被操控，如暗示被催眠对象眼皮睁不开或嘴唇张不开，被催眠者受到暗示无法睁开，被催眠者不感觉被催眠，觉得完全清醒，这阶段已经可以做到减肥、戒烟等心理治疗了。</p><p>第二级催眠深度：大的肌群受到暗示，如手臂无法抬起或无法落下。此时被催眠者更加放松，也更加专注与催眠师的指令。</p><p>第三级催眠深度：可以完全控制所有的肌肉系统，产生数字阻滞。如无法从椅子上站起来，无法走路，无法说出某个数字，但并不是忘了那个数字，临床催眠师的大部分工作，一般在这前三个等级之内。</p><p>第四级催眠深度：开始有失忆现象，被催眠者可以遗忘掉自己的名字，地址，某个数字，并可以产生痛觉阻断，可以做一些手术，拔牙、开刀等。</p><p>第五级催眠深度：开始产生梦游状态，产生正性幻觉，可以看到不存在的东西（是真的看到，而不是想象出来的）。 </p><p>第六级催眠深度：更新的梦游状态，可以产生负性幻觉，看不见，听不见，确实存在的事物或声音，如暗示被催眠者看不见别人的身体，只能看到头部，那么他就只能看到一个的头。</p><p>在影片《催眠大师》中到底达到那个深度，也有人在争议，有人说三级，有人说四级；我认为，至少达到了第五级催眠深度，甚至是第六级，因为被催眠者已经完全不认识自己很熟悉的人（具体情节电影中会交待，此处不详细说的话要剧透），用自己的幻觉代替了现实，这已经完全超出了想像的范畴了。但大多情节中出现的现象达到前三个等级就可以完成，如回忆起以前自己想不起来的事情，跟想象中的人进行对话交流（这在催眠治疗中十分常用，实质是跟自己的潜意识在交流）等，另外，演员在在催眠状态下的表现也符合催眠的状态，如，莫文蔚在催眠状态下产生的眼皮跳动，快速动眼活动，肢体放松，泪水增加，眼白部分变红等等，说明剧组确实注意到了催眠状态下的细节，大家在观看的时候可以留意一下。</p><p>最意思是影片中使用的各种催眠技术，种类繁多，甚至可以作为了解催眠技术的一个入门教学了。</p><p>先说直接催眠法的技术，首先是眼睛凝视法，影片中使用的道具是怀表，用它的好处是让被催眠者不仅可以凝视重复的摆动，还可以听到单调重复的滴答声， 从而快速导入催眠。影片中的用的凝视法并不限于盯着看怀表，还包括催眠师的眼睛，烟头，笔尘（沈医生在试图催眠徐瑞宁时所用到的）等等，让观众感觉处处有催眠，防不胜防。  </p><p>其次是联想法导入催眠的运用，通过让被催眠对象在头脑中产生想象的画面，进而引导他进入更深的催眠状态，这个想像的画面，既可以是对象凭空创造的一个形象或场景，也可以是过去记忆中的的一个场景，这种方法在影片中使用的次数也非常多，如果有兴趣，大家在观影过程中也可以注意一下。</p><p>再次是反复加深技术，这种技术的做法就是不断引发被催眠对象唤醒，再不断地导入催眠，从而让对象进入更深的催眠状态，影片中徐峥和莫文蔚不断的互相催眠，又不断的唤醒，再不断的进入催眠……实质上确实使用了这种反复加深技术，不知道是剧情的需要，还是编剧越催眠技术的特意安排。这也是我很喜欢用的一个技术，效果很好，在催眠中，把对象唤醒调整下身体的姿势，反馈一下感受，接着再导入催眠，可以避免被催眠对象长时间保持一个姿势造成的肌肉疲劳。</p><p>然后再说一下间接催眠，这是影片中让观众感觉比较玄乎的地方，在影片中叫做清醒催眠，也有人叫做隐性催眠；就是让人在清醒状态下，通过交流谈话或者环境暗示，让对象在不知不觉中进入催眠状态。整个影片框架也是在这种理论的基础上搭建的，为了让观众了解这种催眠技术，影片还特意让主人公对这种理论做了一个讲解，给剧情的勾画做了一个铺垫。如，影片中多次用到了环境的暗示，通过水，声音、光线等，或某一个词语（如影片中用到的“船长”），让对象不知不觉中产生联想和回忆，从而再进一步导入催眠。</p><p>另外，影片中有这样的一个比较的高级催眠技术是：混乱技术。该技术的原理是，通过一些异乎寻常的语言，动作，表情等，让被催眠对象短时间内接受大量的信息，造成信息过载，引发神经失衡，触发战斗或逃跑反应（Fight-or-flight response），绕过对象的意识评判区，从而导入催眠。仔细分析一下，影片中一直在使用这种技术，如，影片中心理咨询室故意布置得非常怪异，无形中给予被催眠对象一些混乱；催眠师故意把怀表掉在地上，也是一种混乱；来访者任小妍怪异的心理行为本身就是一种混乱，突然去拨弄钟表指针，突然把水泼出来等都是一种混乱技术的应用，以及从其他咨询师传来的大量信息，也加强了这种混乱，所以，对象没有理由不进入催眠状态了。</p><p>当然，能把这种隐性催眠技术运用的如此娴熟，绝非等闲之辈所能及，我想，即使催眠大师艾瑞克森还在世的话，也未必能做到。</p><p>现在问题来了，现实中，到底有没有可能做到影片中那样的催眠？我的答案是，有可能。但前期必须做大量的铺垫工作，我不可能在一次咨询过程中做到这样的效果。说到这里，不得不提及另外一种心理技术技术，这就是“心锚”的建立。所谓“心锚”，就是人的内心某一心理状态或行与另外某一动作或表情之间的锚定，它的基础是条件反射。比如开车时看到红灯就不自觉的踩刹车，这就是一种“心锚”。影片中，被催眠对象，一看到有节律的“一，二，三”运动形式就会被催眠，如听到数数123，看烟头有节律的3次一熄一灭，三次晃动水杯，拨动三下钟表针等都能迅速地导入催眠状态，要实现这种简单的瞬间催眠，一般就需要“心锚”的建立，而建立这样的“心锚” 一般还得在催眠状态下，所以这样的“心锚”又称为“催眠后暗示”。</p><p>看完影片后，观众还可能有一个担忧，担心自己会不会像影片中那样，某一天被不知不觉的被催眠、被控制，从而说出自己不愿说出的事情，作出自己不愿做的事。其实，大可不必担心，首先，能做到这样快速隐性催眠的催眠师少之又少，凤毛麟角，即使有，也早忙着去某个商业机构都赚大钱去了，恐怕也没有时间闲的蛋疼催眠你玩吧；其次，人在催眠状态下，潜意识的自我保护能力是非常强的，一旦有人要求你做违背个人意愿的事情，很快就能从催眠状态下次苏醒过来。</p><p>调查显示，很多普通大众对催眠有很深的误解，认为催眠可以控制人或者让人失去意识进入昏睡状态。因为催眠术早期多用于巫术和宗教等，让它蒙上了一层迷信和神秘的色彩，影片的播出，也可能让许多人加深了这种误解，所以普及和了解一下催眠知识，还是非常有必要的。其实，任何一种催眠状态在平常生活中都出现过，如在睡觉即将清醒或快睡着的时候，突然身体无法动弹，出现‘鬼压床’的现象，就是一种催眠状态；人在某个极度的悲伤或恐惧情绪状态下，眼前突然浮现某个人，就是一种正性幻觉；又如某小美女穿着超短裙去玩，回到家发现青一块，紫一块，什么时候碰的都不知道，这就是一种催眠麻醉状态；有时候时候拿着钥匙找钥匙，拿着电话找手机，或某个东西明明就在桌子上就是找不到，看不见，这就是催眠状态下的一种负性幻觉；所以说催眠一点儿也不神奇。  　　最后再回答一个问题，催眠术可不可能被用于犯罪？答案是可能的！任何一种技术都是一把双刃剑，历史上也确实出现过催眠犯罪的案例，如着名的“海德堡事件”，所以不要轻易找不熟悉的催眠师进行催眠，进行催眠之前最好对催眠师进行一个调查了解，既有利于对催眠师产生信任更好地进入催眠状态，也是一种自我保护。</p><p>写这篇文章的过程中，我被催眠了，不知不觉中时间都这么晚了，哈哈哈！有些东西可能说的还不是太清楚，大家有什么问题可以在下面留言，也可以加我QQ：315678525。（吕艳朋，2014年4月29日，于济南宝华苑。） </p><blockquote><p>作者：豆瓣用户——吕艳朋</p><p>原文链接：<a href="https://movie.douban.com/review/6653031/">https://movie.douban.com/review/6653031/</a></p><p>侵删</p></blockquote><h2 id="2-5-记忆大师【22-02-24】"><a href="#2-5-记忆大师【22-02-24】" class="headerlink" title="2.5 记忆大师【22-02-24】"></a>2.5 记忆大师【22-02-24】</h2><p><strong>转载影评：</strong></p><p>故事一开始的设定就是和现实不太关联的另外一个国度，我感觉抽取记忆出来的技术就像未来一段时间或许可以发生的，但是后面很多场景又让自己感觉这个又是很接地气的画面，可能是交错未来与现在的交错吧，一些场景选的还是很不错的。</p><p>在电影里，可以感觉一个人的记忆对一个人性格影响太大了，在江丰记忆弄错之后，一些举动就变得怪异许多，一个植入的记忆对于一个人的行为的影响是否过大？这个需要推敲一下。朋友们有的说这部电影是比较烧脑的，一路猜测，最后回归到自己第一感觉，沈警官。</p><p>故事从零碎的记忆开始，穿插了两段故事，在现实中江丰与妻子有矛盾起冲突，慢慢铺展开来，这一部电影感觉又带有对家暴现象的评价，沈警官对于保护那些避免到家暴女性的态度太过于偏执，最开始怀疑他的原因，来自于去警察局找他的男子他一直不愿意去面对，另外就是去找那个女孩调查时，女孩对他的态度和对他徒弟的态度有点差异。</p><p>高潮大概是从被设计之后的江丰怀疑陈姗姗开始，故事开始紧张起来，这里相对来讲精彩了，将所有人的目光吸引到这个凶手可能是女性，又有一点疑问，就是录像中从背影看挺像一个女子，但是从电话到最后，都未再提及这个。</p><p>最后是一个美好结局，算是一部烧脑的但又不能细究的悬疑电影吧，还是推荐看看的。对于记忆是否影响人的行为，通过记忆找出凶手，还是保持一个探究之心。 </p><blockquote><p>作者：豆瓣用户——不懂相负</p><p>原文链接：<a href="https://movie.douban.com/review/8536325/">https://movie.douban.com/review/8536325/</a></p><p>侵删</p></blockquote><p> <strong>从狼人杀角度分析记忆大师</strong></p><p>先盘狼坑：沈sir金刚狼，拿了警徽，最后时刻发言爆炸；沈sir他爸深水狼；李航发言爆炸的冲锋狼，被沈sir卖了做自己身份。 陈姗姗平民钻了狼坑，又被狼队作为完美抗推位，最后没被推出去晚上被狼人给刀了；李惠兰，首夜吃刀的平民；张代晨划水民但最后跳出来帮女巫挡刀。 江丰女巫，吃夜里信息但是逻辑不行没盘出狼坑，差点把毒撒到被狼人污了一手的陈姗姗身上，还好最后时刻抓住沈sir的发言漏洞又站对了边；徒弟原本是铁站边陈sir的猎人，最后因为沈sir他爸的发言漏洞看出了沈sir是只狼一枪把沈sir给崩了；沈sir他妈，离线预言家。。。</p><blockquote><p>作者：豆瓣用户——Turkey is done</p><p>原文链接：<a href="https://movie.douban.com/review/8510215/">https://movie.douban.com/review/8510215/</a></p><p>侵删</p></blockquote><h2 id="2-6-我是山姆【22-02-27】"><a href="#2-6-我是山姆【22-02-27】" class="headerlink" title="2.6 我是山姆【22-02-27】"></a>2.6 我是山姆【22-02-27】</h2><p>大概是深夜了，我从手中挑了挑盘，打算安静的找个剧情片看，我挑了一会。衡量再三，选了一部讲述弱智，不健全、低能父亲的这部《我是山姆》放进了DVD机当中。</p><p>山姆是一个快乐的人。生活在美国，工作在星巴克，他是一个小时工，拿时薪。那天突然来了一个电话，告诉他马上就快有了，速来医院认领。于是他快乐的飞奔而去。</p><p>是一个女孩，他如获至宝，他想这比什么都珍贵，那应该是天上掉下来的钻石，于是他给孩子取名“露西”（《天空中拥有钻石的露西》：披头四的一首曲子）。办完手续，他携子带母出了医院的大门，孩子他妈对山姆说，快看，外星人。山姆一愣，那孩子他妈仓皇的飞奔而去。</p><p> 山姆独自拉扯女孩的日子就这么开始了，这日子很惨，惨过1939年的《飘》，但一步步的，他也明白了很多东西：例如婴儿两个小时要喝一次奶；每周例行的电影会，谈心会将要改成不定期的了；苏斯博士的《绿蛋和火腿》是不能给孩子读一辈子的。同时他也获得了很多疑惑，例如为什么有的男人是光头，天空的尽头在哪，夏时令中少的那一个小时去了哪里，露西长的到底是像他还是像孩子他妈？</p><p>有一天露西问山姆，我妈还回来吗？山姆冥思后带着苦相答，保罗麦卡特尼（披头四成员）从小就没妈，约翰列侬（同样是披头四成员）也是，所以你注定是一个不平凡的小孩。露西又问，爸，那你是不平凡的吗？是从小就这样？山姆很茫然，可能明白了露西的一语双关。他带着愧意对露西说，对不起。而露西说，这没什么，我们都是幸运的。</p><p>当露西7岁的时候，她已经比山姆显得成熟和聪明了，她会读different，而山姆不能。露西要上小学，同时也快过生日了，山姆想，要给她举办一个聚会，在这个聚会他想给露西一个礼物：一张披头四的唱片。</p><p>但惊喜终究是没有到来，那场聚会搞砸了，露西看到慌里慌张的山姆瘫在地上，伤心的飞奔而去。</p><p>这个家庭面临困境，露西要被别人托管，美国政府的维权组织切入了进来，法庭也来了，他们要剥夺山姆的抚养权，山姆没见过这阵势，又一次陷入了慌张。</p><p>还好，他有一群智囊班子，由一群和他一样有一些缺陷的人员组成的智囊班子。他们合伙给山姆推荐了一个本市最牛逼的律师，是600多页的大黄页中筛选的结果，他们甚至细心的告诉了山姆那律师的地址，这让山姆为之一振，兴奋的飞奔而去。</p><p>看到这里我想，如果这个故事没有这一刻的神奇，那这就不是戏剧，而是人生了。</p><p>这个牛逼律师是一名女性，招牌服饰是高档职业装，高档眼镜压在高鼻梁上面，是极品女强人，当然她个子也不矮。</p><p>电影在这一阶段显示出了诡异的蓝，连那个律师的杯子都是蓝蓝的，让人冷峻不已。这个女律师显得很忙，时间就是金钱，一天办八个案子（都收费），甚至忙的亲儿子的电话都必须排在第二线，山姆看到这个情景，不仅一阵慌张，他想，钱怎么办？我不能再当小时工了，我要学个技术，我要学会调卡布奇诺。</p><p>在这期间，山姆又飞奔了很多次（在去律师楼和去看露西的路上），有一次看他去看露西的时候，他没有飞好，滑倒了，那手中的蛋糕塌陷了一地，但露西躺在山姆身边，丝毫不会在意，笑得很甜。</p><p>一次次山姆的到来，让女律师被同事的白眼和自己的势利心打动了，他对山姆说，好吧 我义务（pro bono）一次，当你律师。山姆很茫然的样子。女律师又换了一个简单词汇，免费（free）。山姆大喜。 接下来就是很诡异地开了很多次庭，电影的底色还是蓝蓝的，也十分冷峻。镜头中大量使用了近角的特写，照在山姆那茫然的额头上，但是山姆挺住了，没有看到汗水顺着他的额头滴落下来，这应该是一种抗争，但天真的山姆应该不能体会到生活何常不是一种抗争呢？</p><p>又一次开庭结束，山姆慷慨邀请女律师吃了一顿便饭，他说这顿饭，我来，我义务（pro bono）一次，看山姆学的多快。</p><p>人心是肉长的，女律师在一次次与山姆的交流中也学会了很多，例如耐性和聆听。 她发现在这次义务当中，她得到的比山姆还多，他送给了山姆一套西服和一条领带，山姆很开心，要知道当山姆在法庭上看到他的智囊团中的傻小伙A带着一条红领巾一样的蹩脚领带是多么神往。女律师发现当她和山姆在一起的时候，他确实放下了什么叫成功和高档，甚至有一次她哭着告诉山姆，他丈夫泡上了一个比她还要高档完美的女人，她很痛苦。她当着山姆的面，真的是什么都敢说了。</p><p>就这么着，日子过去了，露西暂时被一家人收养。在这期间，女律师还是在和不公正的法律抗争，同时也办了离婚；而山姆同时也是在和生活抗争。但好的方向是，山姆升了职，去调卡布奇诺了。</p><p>山姆还找了两份兼职，一份是溜狗，这是为了能够离露西近一些。另一份是去必胜客薄饼店当店员，为了多练习一下算数的实际应用，因为最终在法庭上，法官会考山姆，他要证明山姆脑子够用，是一个能精打细算过日子的人。</p><p>山姆开始背很多数据，然后一一串联起来，他知道露西暂时住在九号屋，而约翰.列侬是10月9日生的，约翰.列侬的儿子也是10月9号生的，约翰.列侬他妈住在利物浦纽卡斯尔大街9号。他知道这一切不是巧合，他和露西的相遇也不是巧合，天上掉下的钻石就是他的。    </p><p>电影就在此刻伴随着山姆的坚持也慢慢的融化了，那冷峻的蓝色调变成了橙色的暖色调，阳光大量的照射在了草地上，木吉他轻松的和弦带出了一场愉快的足球比赛，而最终的胜利者是山姆，露西回到了他的身边。</p><p>最后要说的是，1电影原声很好听，很多大牌乐队或歌手翻唱了披头四的经典歌曲作为这个电影的配乐。我个人最喜欢“across the universe”这首。  2 星巴克和必胜客给我的印象彻底改变，我终于知道，其实那只是美国的牛肉面馆子 </p><blockquote><p>作者：豆瓣用户——饭忒稀</p><p>原文链接：<a href="https://movie.douban.com/review/1631458/">https://movie.douban.com/review/1631458/</a></p><p>侵删</p></blockquote><h2 id="2-7-禁闭岛【22-03-09】"><a href="#2-7-禁闭岛【22-03-09】" class="headerlink" title="2.7 禁闭岛【22-03-09】"></a>2.7 禁闭岛【22-03-09】</h2><p>一个相同的事情，两个完全不同的故事。</p><p>故事一： Marshal Teddy Daniels 的妻子和孩子因为一场由Andrew Laeddis引起的火灾而致死，他深爱着自己的妻子，深爱着自己的孩子。通过对Andrew Laeddis的调查，他了解到一个叫Ashecliff的精神病院，在shutter island上。随着调查的深入Teddy开始怀疑在这个岛上有不可告人的秘密。  </p><p>Teddy 的直觉是对的，shutter island 是一个秘密的思维控制的实验室，他们利用有严重精神问题的病人，企图试验对他们的大脑进行手术，让他们没有感觉，没有记忆，在军事上利用他们。  </p><p>实验室需要一个新的病人，他们通过调查发现Teddy Daniels心中有trauma. 这正是Teddy的精神弱点。 他们制造了一个假的病人Rachel的失踪，以调查的名义让Teddy来这个精神病院。 他身边还跟着假装Teddy调查助手的心理学家，Dr. Sheehan，目的是观察他的行为，倾听他的描述，了解他，然后和岛上的主精神分析师Dr. John Cawley从心里上摧毁他。  </p><p>上了岛以后，岛上的人让Teddy吃谎称阿斯匹林的药丸，吃他们的烟，从生理上加剧Teddy的幻觉问题。  </p><p>Dr Cawley 说Rachel是个精神病人，他淹死了自己的三个孩子，却始终觉得他们还活着。通过仔细的调查，Teddy的失踪根本是不可能的，他开始认识到Rachel的失踪也许是什么阴谋。当他审问一个较“清醒”的病人时，这个女病人故意让Dr. Sheehan，那个假装Teddy助手的帮凶心理学家，去倒水。然后趁这个机会马上写给他“快跑”。 …慢慢的他开始怀疑起自己的助手。  </p><p>在牢房里，他偶遇到了自己曾经认识的人George Noyce，他告诉Teddy在灯塔里正进行可怕的脑部实验，告诉他要摆脱自己的幻觉，摆脱trauma, 不能相信自己的助手，不然就永远走不出这个岛～  </p><p>从牢房里出来后，Teddy第一时间想去那个Geoge提到的灯塔，Dr. Sheehan以助手的理由跟随。去灯塔的路很有危险，Dr. Sheehan借口离开Teddy跑回去告诉全部人Teddy要发现他们的阴谋了。Teddy 没有去成灯塔，却在一个隐蔽的山洞里遇到了真正的Rachel, 她以前是这里的医生，那些心理学家也曾经想把她变成精神病人，然后进行手术。Rachel告诉了Teddy所有的真相，Teddy意识到他们的阴谋就让自己成为第67号精神病人，可是他仍然相信自己的助手。  </p><p>回到精神病院，Teddy的助手消失了，Teddy怀疑岛上的人把他带到灯塔里做脑部手术。Teddy要去救助手。当Teddy到灯塔的时候，Dr Cawley 早以在那里等候他。 故事到达了高潮。  </p><p>Dr. Sheehan现身和 Dr. Cawley用各种伪造文件，理性分析说服Teddy他自己本来就是精神病人，已经在这里两年了，在这里不断重复自己来这里是调查Rachel的幻觉。 诱导Teddy相信自己杀害了妻子。因为药物的作用，Rachel的故事结合Dr. Cawley的捏造，Teddy产生了幻觉，自己的妻子杀害了三个孩子，然后自己杀了心爱的妻子。  Teddy为了避免立刻的被lobotomize，暂时承认自己是凶手，是精神病人。 可是最后他无法让自己像一个怪物一样活着，还是决定了一死… 电影以象征脑手术的灯塔作为结束…   </p><p>故事二： Teddy其实是第66号病人， 他曾经是一个Marshal, 是的他很爱自己的妻子。 可是周六的一天当他发现得了忧郁症的妻子淹死了自己的孩子时，他心里产生了极大的痛苦，一枪把他的妻子杀死了。  </p><p>可是正如一个像弗洛伊德的心理学家Dr. Naehring所说的，Teddy心里有很强的defense mechanism (弗洛伊德术语语境下). 于是Marshal 疯了，被送到了shutter island.  </p><p>Marshal 是如此爱自己的妻子，他天天带着那个她送的tie，他经常梦见自己的妻子，和她拥抱在一起。他内心无法接受自己就是杀害心爱妻子的人，于是他幻想出Andrew Laeddis这么个凶手，要追寻他报仇，把自己从一个杀人犯变成了一个追查凶手的英雄。</p><p> [对应于 弗洛伊德语境下的 reaction formation]  </p><p>Teddy 还将妻子杀害三个孩子的记忆transform到一个幻想出来的病人Rachel身上，其实不是Rachel不想承认自己杀孩子的事实而是Teddy本身就不想承认是妻子淹死了自己的孩子。 </p><p>[对应于 弗洛伊德语境下的 projection]  </p><p>Teddy还经常梦到原来的纳粹集中营，梦见了杀人，梦见了痛苦，梦见了死亡～ </p><p>Teddy 通过对 Rachel和Laeddis的追寻和调查去缓和对妻子的爱，不可杀人的道德，和自己杀妻之间的强烈的矛盾。爱，否定，追忆，痛苦在一个失去理智的心中不断的纠缠和升级。构成电影最感人，怜悯而细腻的一面。  </p><p>在这期间Teddy还产生了各种幻觉让自己的追寻和调查合理化。  </p><p>Dr. Sheehan两年来一直Teddy的心理医师，希望通过role play慢慢的帮助Teddy 从幻觉中走出来。  </p><p>当Teddy 的追寻和调查伤害到岛上的人安全时，在灯塔上，Dr. Sheehan和 Dr Cawley试图把他曾杀妻的真相告诉他。 Teddy被说服了，回忆起了那痛苦的杀妻的一幕。  不久后, Teddy又重新回到自己的幻觉当中，岛上的精神分析师怕他的defense mechanism再对别人造成伤害，于是带他去lobotomize…    </p><p>故事一是一个充满了阴谋的惊悚片，Teddy以一个刚强执着的探员的形象，一步步探险。故事的高潮发生在对深刻问题的追问：当所有的理性的分析和证据都导向自己是疯子时，你是相信自己的记忆还是相信“现实”的证据？记忆是什么？判断证据是否应该依靠自己的记忆？  </p><p>故事二是一个充满悲悯和柔情的故事。对妻子深深的爱，残酷的杀妻事实，令Teddy在幻觉和现实中苦苦的挣扎。 故事二的美在于用精心设计的梦境去深刻分析和表达Teddy的内心，去诠释弗洛伊德关于defense mechanism，dream，hallucination,trauma的理论。    </p><p>而shutter island电影最美的地方在于一个电影，根据不同的“相信”，可以是两个完全不同的冲突的故事。 电影对两个故事平衡的表述，用如此多的事实去支持每个故事使得没有哪个故事才是真正的“真相”。  或者两个故事原本都是“真相”，通过观众的主观介入，才使两个真相绝对成一个故事。  而这一切，双向的，绝对的相对只能发生在一个孤立的岛上，任何局外人都能使“真相”暴露。 以shutter island作为电影的题目，可以说再贴切不过。  </p><p>我一直觉得如何讲故事才是电影的灵魂，而shutter island这种双向引导故事的叙事方法就好象电影史的一个奇迹，通过创造“两个故事”间的冲突和矛盾重新开拓出新的电影的美  </p><p>远远不仅如此，电影中竟然多次出现Mahler的”Quartet for Strings and Piano in A minor”来描述弗洛伊德式的“回忆”或“幻觉”，Mahler和弗洛伊德同是20世纪初奥地利人，音乐不仅仅在内容上和叙事内容吻合(Mahler的七个姐妹死于童年，且从未从自己失去四岁爱女儿Maria的痛苦中恢复过来)，而且时间和地点相吻合， 电影的原创不仅对故事的表述，心理学有认识，而且对古典音乐也有很深入的理解，真是让人赞叹。  </p><p>还有电影中的几幕都非常经典： </p><p>Teddy梦见自己的妻子在家中，忘出窗外，“妻子死于火灾”（故事一的视角），他紧紧抱着妻子，天上掉着灰，而妻子像一张纸一样，慢慢的烧为灰烬。不舍，爱恋，温情，烧死的信息暗示以一种唯美的方式表达。  </p><p>Teddy 幻想到在Dr. Naehring的office, Rachel满身是血，杀害三个孩子前的一幕。 </p><p>Teddy周围弥漫的烟雾突然凝固，不仅创造了一种静止的对比，而且还有空间上深度的对比。  …  </p><p>还有Leonardo DiCaprio 出色的表演… </p><p>还有Dr. Naehring 的办公室那充满十九世纪维也纳风格的室内装饰…  </p><p>这个电影越是回味，越有味道。    </p><p> 最后我想追问的是，是的正如shakespeare所说 All the world ‘s a stage, and all the men and women merely players. They have their exits and their entrances; And one man in his time plays many parts 即使一个人在生命中的一个时期只有一个角色，那他是否仅仅在上演一个故事呢？  一个相同的事情，两个完全不同的故事。 </p><blockquote><p>作者：豆瓣用户——resurrection</p><p>原文链接：<a href="https://movie.douban.com/review/3043968/">https://movie.douban.com/review/3043968/</a></p><p>侵删</p></blockquote><h2 id="2-8-蜘蛛侠：英雄无归【22-04-01】"><a href="#2-8-蜘蛛侠：英雄无归【22-04-01】" class="headerlink" title="2.8 蜘蛛侠：英雄无归【22-04-01】"></a>2.8 蜘蛛侠：英雄无归【22-04-01】</h2><p>这篇影评我就自己随便简单写一两句吧，一方面是因为漫威电影这个剧情价值不是很大，更多的是看一下特效，二一方面是因为这一步感觉也太差了，没有什么好的看点，除了一些情怀（三代蜘蛛侠同现、前几代的怪物）以及奇异博士和一些特效。</p><p>然后想吐槽一下剧情，这剧情设计的太无聊无趣而且强行降智，蜘蛛侠还想要拯救这些人，想要逆天改命，无语了，本来就是每个人的命运，他这一改感觉造成了很多物理以及哲学上的矛盾。</p><p>大概就写着点吧，反正满是槽点。</p><h2 id="2-9-叫我第一名【22-04-06】"><a href="#2-9-叫我第一名【22-04-06】" class="headerlink" title="2.9 叫我第一名【22-04-06】"></a>2.9 叫我第一名【22-04-06】</h2><p>这部影片改编自真实事件，男主布莱德是一名妥瑞氏症患者，这是一种非常严重的痉挛疾病，患者会不由自主且无法控制抽搐、做鬼脸、发出怪叫。 通过电影，我的感受是男主一路成长来肯定是不容易，毕竟发出怪叫总会引起别人的注意，而且日常生活肯定十分不方便，不论是上课还是听音乐、甚至是交谈都有极大的不变；此外更重要的会引起别人的嘲讽、歧视等，心里需要承受极大的压力（要我估计早放弃了。。。），但是男主不仅没有放弃，反而却要克服这该死的疾病，确实佩服（我做不到）。此外幸亏男主一路上还遇到许多好人，给了他很多帮助和勇气，这其中最重要的是他的妈妈——一直没有放弃他，另外就是他的小学校长——给了他自信，并成为了他的人生目标，这也是他为什么将来要做一名教师的原因。</p><p>总之吧，给我的感受就是——努力、奋进可以完成很多看似完不成的事情，可能做不到天赋异禀那样的高度，但是至少能完成最基本，甚至如果你做到足够努力，也可以比大部分人做的足够好。</p>]]></content>
      
      
      <categories>
          
          <category> 我的生活记录 </category>
          
          <category> 书音影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
            <tag> 电视剧 </tag>
            
            <tag> 动漫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的音乐</title>
      <link href="/2022/06/26/My-music/"/>
      <url>/2022/06/26/My-music/</url>
      
        <content type="html"><![CDATA[<h3 id="1-中文歌曲"><a href="#1-中文歌曲" class="headerlink" title="1 中文歌曲"></a>1 中文歌曲</h3><h4 id="1-1-按人名划分"><a href="#1-1-按人名划分" class="headerlink" title="1.1 按人名划分"></a>1.1 按人名划分</h4><ul><li>邓丽君<ul><li>《甜蜜蜜》、《月亮代表我的心》、《我只在乎你》、《漫步人生路》、《往事只能回味》</li></ul></li><li>许冠杰<ul><li>《半斤八两》、《天才白痴梦》</li></ul></li><li>陈百强<ul><li>《偏偏喜欢你》、《今宵多珍重》</li></ul></li><li>林子祥<ul><li>《男儿当自强》、《敢爱敢做》、《敢爱敢做》、《谁明浪子心》</li></ul></li><li>罗大佑<ul><li>《光阴的故事》、《明天会更好》、《你的样子》</li></ul></li><li>李宗盛<ul><li>《当爱已成往事》、《鬼迷心窍》</li></ul></li><li>周华健<ul><li>《刀剑如梦》、《神话情话》、《有没有一首歌会让你想起我》、《难念的经》、《花心》、《朋友》、《让我欢喜让我忧》、《风雨无阻》</li></ul></li><li>蔡琴<ul><li>《你的眼神》</li></ul></li><li>齐秦<ul><li>《大约在冬季》、《不让我的眼泪陪我过夜》</li></ul></li><li>潘美辰<ul><li>《我想有个家》</li></ul></li><li>苏芮<ul><li>《酒干倘卖无》</li></ul></li><li>谭咏麟<ul><li>《讲不出再见》、《一生中最爱》、《水中花》、《爱在深秋》、《难舍难分》</li></ul></li><li>徐小凤<ul><li>《风的季节》</li></ul></li><li>张国荣<ul><li>《风继续吹》、《追》、《沉默是金》</li></ul></li><li>梅艳芳<ul><li>《梦幻的拥抱》、《似是故人来》、《女人花》、《亲密爱人》、《一生爱你千百回》、《夕阳之歌》</li></ul></li><li>陈慧娴<ul><li>《夜机》、《千千阙歌》</li></ul></li><li>周慧敏<ul><li>《最爱》、《痴心换情深》</li></ul></li><li>李克勤<ul><li>《红日》、《月半小乐曲》、《护花使者》</li></ul></li><li>beyond<ul><li>《光辉岁月》、《海阔天空》、《不再犹豫》、《灰色轨迹》、《喜欢你》、《真的爱你》、《情人》、《Amani》</li></ul></li><li>刘德华<ul><li>《冷雨》、《爱你一万年》、《十七岁》、《暗里着迷》、《鸽子情缘》、《一起走过的日子》</li></ul></li><li>张学友<ul><li>《吻别》、《李香兰》、《月半弯》、《忘记你我做不到》、《慢慢》、《只想一生跟你走》</li></ul></li><li>黎明<ul><li>《今夜你会不会来》、《全日爱》</li></ul></li><li>郭富城<ul><li>《对你爱不完》、《狂野之城》</li></ul></li><li>小虎队：吴奇隆、陈志朋、苏有朋<ul><li>《爱》、《红蜻蜓》、《蝴蝶飞呀》、《祝你一路顺风》、《青苹果乐园》</li></ul></li><li>王菲<ul><li>《容易受伤的女人》、《我愿意》、《红豆》、《匆匆那年》、《旋木》、《笑忘书》、《暧昧》、《闷》、《如愿》、《天上人间》</li></ul></li><li>张雨生<ul><li>《口是心非》、《大海》、《我的未来不是梦》、《一天到晚游泳的鱼》、《最爱的人伤我最深》</li></ul></li><li>张惠妹<ul><li>《血腥爱情故事》、《趁早》、《血腥爱情故事》、《我最亲爱的》</li></ul></li><li>张信哲<ul><li>《爱如潮水》、《爱就一个字》、《白月光》、《信仰》、《雨后》、《过火》、《太想爱你》</li></ul></li><li>张宇<ul><li>《用心良苦》、《曲终人散》、《给你们》、《月亮惹的祸》、《趁早》、《雨一直下》、《单恋一枝花》</li></ul></li><li>彭羚<ul><li>《囚鸟》</li></ul></li><li>伍佰<ul><li>《再度重相逢》、《挪威的森林》、《与你到永久》、《突然的自我》、《被动》、《白鸽》、《晚风》、《牵挂》、《夏夜晚风》、《孤星泪》、《痛哭的人》</li></ul></li><li>周深<ul><li>《化身孤岛的鲸》、《大鱼》、《玫瑰与小鹿》、《生活总该迎着光亮》、《可它爱着这个世界》、《来不及勇敢》</li></ul></li><li>牛奶咖啡<ul><li>《明天，你好》、《越长大越孤单》</li></ul></li><li>薛之谦<ul><li>《演员》、《丑八怪》、《认真的雪》</li></ul></li><li>杨宗纬 <ul><li>《一次就好》、《红尘来去一场空》、《洋葱》、《其实都沒有》</li></ul></li><li>容祖儿<ul><li>《小小》、《挥着翅膀的女孩》</li></ul></li><li>汪苏泷<ul><li>《有点甜》、《小星星》、《万有引力》、《专属味道》、《不分手的恋爱》、《巴赫旧约》</li></ul></li><li>岑宁儿 <ul><li>《追光者》</li></ul></li><li>陈奕迅<ul><li>《十年》、《孤勇者》、《好久不见》、《浮夸》、《富士山下》、《因为爱情》、《单车》、《最佳损友》、《k歌之王》</li></ul></li><li>刘若英 <ul><li>《后来》</li></ul></li><li>许巍 <ul><li>《蓝莲花》、《曾经的你》、《像风一样自由》</li></ul></li><li>陈慧娴<ul><li>《千千阕歌》</li></ul></li><li>张学友 <ul><li>《吻别》</li></ul></li><li>鹿晗<ul><li>《我们的明天》、《勋章》</li></ul></li><li>叶丽仪 <ul><li>《上海滩》</li></ul></li><li>满文军‌ <ul><li>《懂你》</li></ul></li><li>杨培安<ul><li>《我相信》、《爱上你是一个错》</li></ul></li><li>刀郎、云朵<ul><li>《西海情歌》、《爱是你我》、《画船记》、《手心里的温柔》、《情人》、《2002年第一场雪》、《喀什噶尔胡杨》、《冲动的惩罚》、《我的楼兰》、《映山红》</li></ul></li><li>韩宝仪 <ul><li>《粉红色的回忆》、《舞女泪》</li></ul></li><li>叶启田 <ul><li>《爱拼才会赢》</li></ul></li><li>华晨宇<ul><li>《烟火里的尘埃》、《南屏晚钟》、《国王与乞丐》</li></ul></li><li>张杰 <ul><li>《我们都一样》、《他不懂》、《逆战》、《逆态度》、《看月亮爬上来》、《天下》、《最美的太阳》、《明天过后》、《这就是爱》、《直到世界尽头》、《着魔》</li></ul></li><li>周杰伦<ul><li>《夜曲》、《青花瓷》、《稻香》、《七里香》、《花海》、《夜的第七章》、《说好不哭》、《给我一首歌的时间》、《菊花台》、《千里之外》、《珊瑚海》</li></ul></li><li>陆虎 <ul><li>《雪落下的声音》</li></ul></li><li>买辣椒也用券 <ul><li>《起风了》</li></ul></li><li>谢安琪 <ul><li>《钟无艳》</li></ul></li><li>范玮琪 <ul><li>《最初的梦想》、《一个像夏天一个像秋天》、《是非题》</li></ul></li><li>庄心妍 <ul><li>《走着走着就散了》、《以后的以后》、《再见只是陌生人》、《为情所伤》</li></ul></li><li>李玉刚<ul><li>《刚好遇见你》、《万疆》</li></ul></li><li>南征北战NZBZ <ul><li>《我的天空》</li></ul></li><li>朴树<ul><li>《生如夏花》、《平凡之路》</li></ul></li><li>张芸京 <ul><li>《偏爱》</li></ul></li><li>青鸟飞鱼 <ul><li>《此生不换》</li></ul></li><li>赵雷 <ul><li>《成都》、《阿刁》、《鼓楼》、《小行迹》、《我记得》</li></ul></li><li>孙燕姿 <ul><li>《遇见》、《逆光》、《我怀念的》、《开始懂了》、《绿光》</li></ul></li><li>李荣浩 <ul><li>《作曲家》、《老街》、《年少有为》、《爸爸妈妈》</li></ul></li><li>张碧晨<ul><li>《年轮》、《渡红尘》、《如果一切都没有发生过》、《凉凉》、《开往早晨的午夜》</li></ul></li><li>马頔 <ul><li>《南山南》</li></ul></li><li>逃跑计划 <ul><li>《夜空中最亮的星》、《一万次悲伤》</li></ul></li><li>李宗盛<ul><li>《漂洋过海来看你》</li></ul></li><li>邓紫棋<ul><li>《倒数》、《光年之外》、《来自天堂的魔鬼》、《你不是真正的快乐》、《死了都要爱》、《泡沫》、《多远都要在一起》</li></ul></li><li>周兴哲 <ul><li>《你，好不好？》</li></ul></li><li>袁娅维<ul><li>《说散就散》</li></ul></li><li>林宥嘉 <ul><li>《成全》、《说谎》</li></ul></li><li>王铮亮 <ul><li>《时间都去哪了》</li></ul></li><li>赵英俊 <ul><li>《都选C》、《送你一朵小红花》</li></ul></li><li>许嵩<ul><li>《断桥残雪》、《有何不可》、《如果当时》、《千百度》、《弹指一挥间》、《灰色头像》、《你若成风》、《清明雨上》、《城府》、《燕归巢》</li></ul></li><li>周传雄<ul><li>《黄昏》、《寂寞沙洲冷》、《花香》、《我的心太乱》 、《关不上的窗》、《青花》、《出卖》、《冬天的秘密》</li></ul></li><li>任素汐 <ul><li>《胡广生》、《我要你》‌ 、《大梦》‌ 、《亲爱的小孩》‌ 、《枕着光的她》、《王昭君》</li></ul></li><li>胡彦斌 <ul><li>《江湖再见》、《红颜》、《月光》、《你要的全拿走》</li></ul></li><li>筷子兄弟<ul><li>《老男孩》、《小苹果》</li></ul></li><li>李宇春 <ul><li>《木兰》、《和你一样》、《蜀绣》、《千年游》、《下个路口见》</li></ul></li><li>阿兰 <ul><li>《千古》</li></ul></li><li>周笔畅 <ul><li>《最美的期待》、《笔记》、《若不是那次夜空》、《怎样》</li></ul></li><li>金玟岐 <ul><li>《岁月神偷》</li></ul></li><li>郁可唯 <ul><li>《路过人间》、《离人》、《时间煮雨》、《知否知否》、《情人咒》</li></ul></li><li>光良 <ul><li>《童话》、《第一次》</li></ul></li><li>老狼<ul><li>《同桌的你》、《想把我唱给你听》</li></ul></li><li>郑少秋 <ul><li>《笑看风云》</li></ul></li><li>Christine Welch <ul><li>《一百万个可能》</li></ul></li><li>苏打绿 <ul><li>《小情歌》</li></ul></li><li>林俊杰<ul><li>《曹操》、《修炼爱情》、《背对背拥抱》、《江南》、《飞云之下》、《小酒窝》、《醉赤壁》、《可惜没如果》、《将故事写成我们》、《一千年以后》</li></ul></li><li>毛不易<ul><li>《像我这样的人》、《牧马城市》、《消愁》、《入海》、《一荤一素》</li></ul></li><li>至上励合 <ul><li>《棉花糖》</li></ul></li><li>汪峰 <ul><li>《怒放的生命》、《花火》、《北京北京》</li></ul></li><li>霍尊<ul><li>《恰好》、《卷珠帘》</li></ul></li><li>郑智化 <ul><li>《水手》、《星星点灯》</li></ul></li><li>田燚 <ul><li>《车上的人》</li></ul></li><li>赵传 <ul><li>《爱要怎么说出口》、《我终于失去了你》、《我很丑可是我很温柔》、《勇敢一点》</li></ul></li><li>李翊君 <ul><li>《雨蝶》    </li></ul></li><li>任贤齐 <ul><li>《伤心太平洋》、《心太软》、《沧海一声笑》、《很受伤》、《花好月圆夜》 </li></ul></li><li>曲婉婷<ul><li>《在我的歌声里》</li></ul></li><li>林志炫 <ul><li>《单身情歌》</li></ul></li><li>王力宏 <ul><li>《花田错》、《需要人陪》、《大城小爱》、《缘分一道桥》、《唯一》</li></ul></li><li>水木年华 <ul><li>《在他乡》、《一生有你》</li></ul></li><li>郭峰 <ul><li>《甘心情愿》</li></ul></li><li>温奕心<ul><li>《一路生花》</li></ul></li><li>许茹芸<ul><li>《如果云知道》、《独角戏》</li></ul></li><li>胡夏 <ul><li>《那些年》</li></ul></li><li>杨千嬅 <ul><li>《处处吻》</li></ul></li><li>梁咏琪 <ul><li>《胆小鬼》</li></ul></li><li>莫文蔚 <ul><li>《慢慢喜欢你》、《这世界那么多人》、《盛夏的果实》、《如果没有你》、《广岛之恋》</li></ul></li><li>于文文 <ul><li>《体面》</li></ul></li><li>田馥甄 <ul><li>《小幸运》、《魔鬼中的天使》、《只对你有感觉》</li></ul></li><li>安琥 <ul><li>《天使的翅膀》</li></ul></li><li>陈淑桦 <ul><li>《笑红尘》、《梦醒时分》、《问》</li></ul></li><li>唐磊 <ul><li>《丁香花》</li></ul></li><li>张韶涵 <ul><li>《隐形的翅膀》、《欧若拉》、《猜不透》、《亲爱的那不是爱情》、《夜航星》、《篇章》</li></ul></li><li>S.H.E <ul><li>《Super Star》、《谢谢你的温柔》</li></ul></li><li>梁静茹 <ul><li>《可惜不是你》、《勇气》、《会呼吸的痛》、《暖暖》</li></ul></li><li>苏芮 <ul><li>《再回首》</li></ul></li><li>马天宇<ul><li>《该死的温柔》</li></ul></li><li>黄品源<ul><li>《小薇》、《你怎么舍得我难过》、《海浪》</li></ul></li><li>傅如乔<ul><li>《微微》</li></ul></li><li>张靓颖/王铮亮 <ul><li>《只是没有如果》、《终于等到你》、《画心》、《如果爱下去》、《如果这就是爱情》</li></ul></li><li>李丽芬 <ul><li>《爱江山更爱美人》</li></ul></li><li>吴克群 <ul><li>《为你写诗》</li></ul></li><li>罗志祥 <ul><li>《爱转角》</li></ul></li><li>李圣杰 <ul><li>《最近》、《痴心绝对》、《手放开》</li></ul></li><li>陈小春 <ul><li>《独家记忆》</li></ul></li><li>张栋梁 <ul><li>《当你孤单你会想起谁》</li></ul></li><li>陈瑞 <ul><li>《白狐》</li></ul></li><li>庾澄庆 <ul><li>《春泥》、《情非得已》</li></ul></li><li>李琛 <ul><li>《窗外》</li></ul></li><li>沙宝亮<ul><li>《暗香》、《沧浪行》 </li></ul></li><li>金志文<ul><li>《远走高飞》</li></ul></li><li>本兮 <ul><li>《情花》</li></ul></li><li>黄义达 <ul><li>《那女孩对我说》</li></ul></li><li>蔡依林 <ul><li>《日不落》、《玫瑰少年》</li></ul></li><li>陶钰玉 <ul><li>《不是因为寂寞才想你》</li></ul></li><li>林忆莲 <ul><li>《至少还有你》、《为你我受冷风吹》</li></ul></li><li>腾格尔 <ul><li>《天堂》</li></ul></li><li>刘惜君<ul><li>《后来我们会怎样》、《我很快乐》</li></ul></li><li>周冰倩<ul><li>《真的好想你》</li></ul></li><li>江珊 <ul><li>《梦里水乡》</li></ul></li><li>杨坤 <ul><li>《空城》、《答案 》、《重生之我在异乡为异客 》</li></ul></li><li>孟庭苇 <ul><li>《羞答答的玫瑰静悄悄地开》</li></ul></li><li>动力火车 <ul><li>《当》</li></ul></li><li>央金兰泽 <ul><li>《遇上你是我的缘》</li></ul></li><li>隔壁老樊 <ul><li>《我曾》</li></ul></li><li>枯木逢春 <ul><li>《这一生关于你的风景》</li></ul></li><li>吴宗宪 <ul><li>《是不是这样的夜晚你才会这样的想起我》</li></ul></li><li>李行亮 <ul><li>《愿得一人心》</li></ul></li><li>马嘉祺/严浩翔 <ul><li>《飘向北方》</li></ul></li><li>烟把儿乐队 <ul><li>《纸短情长》</li></ul></li><li>黄鸿升 <ul><li>《地球上最浪漫的一首歌》</li></ul></li><li>樊凡 <ul><li>《守着你到永久》</li></ul></li><li>八三夭 <ul><li>《想见你想见你想见你》</li></ul></li><li>卓义峰 <ul><li>《再见烟火》</li></ul></li><li>林凡 <ul><li>《缺口》</li></ul></li><li>曾沛慈 <ul><li>《不过失去了一点点》</li></ul></li><li>陈柯宇 <ul><li>《直到遇见了你我只喜欢你》</li></ul></li><li>费玉清<ul><li>《一剪梅》</li></ul></li><li>陈冠蒲 <ul><li>《太多》</li></ul></li><li>张小九 <ul><li>《余香》</li></ul></li><li>张震岳 <ul><li>《再见》</li></ul></li><li>温岚 <ul><li>《夏天的风》</li></ul></li><li>李雅微 <ul><li>《我们的纪念》</li></ul></li><li>尹昔眠 <ul><li>《落在生命里的光》</li></ul></li><li>王冰洋 <ul><li>《飞舞》</li></ul></li><li>郑中基 <ul><li>《无赖》</li></ul></li><li>阿杜<ul><li>《撕夜》</li></ul></li><li>袁成杰 <ul><li>《外滩十八号》</li></ul></li><li>海鸣威 <ul><li>《老人与海》</li></ul></li><li>李慧珍 <ul><li>《爱死了昨天》</li></ul></li><li>许慧欣 <ul><li>《七月七日晴》</li></ul></li><li>Tank <ul><li>《千年泪》、《三国恋》</li></ul></li><li>徐怀钰<ul><li>《纷飞》</li></ul></li><li>郑秀文 <ul><li>《值得》</li></ul></li><li>郑伊健 <ul><li>《友情岁月》</li></ul></li><li>孙耀威 <ul><li>《爱的故事上集》</li></ul></li><li>郑源 <ul><li>《一万个理由》、《不要在我寂寞的时候说爱我》、《为爱停留》</li></ul></li><li>顾峰/斯琴高丽 <ul><li>《犯错》</li></ul></li><li>孙露 <ul><li>《心醉》</li></ul></li><li>张振宇 <ul><li>《不要再来伤害我》</li></ul></li><li>胡杨林 <ul><li>《香水有毒》</li></ul></li><li>六哲 <ul><li>《错错错》</li></ul></li><li>刘嘉亮<ul><li>《你到底爱谁》</li></ul></li><li>关心妍 <ul><li>《放生》</li></ul></li><li>徐怀钰 <ul><li>《分飞》</li></ul></li><li>阿桑 <ul><li>《一直很安静》</li></ul></li><li>郭静 <ul><li>《下一个天亮》、《心墙》</li></ul></li><li>范晓萱 <ul><li>《雪人》</li></ul></li><li>王娅 <ul><li>《爱情错觉》</li></ul></li><li>戴爱玲 <ul><li>《千年之恋》</li></ul></li><li>罗文/甄妮 <ul><li>《铁血丹心》</li></ul></li><li>陈慧琳 <ul><li>《记事本》</li></ul></li><li>萧亚轩 <ul><li>《类似爱情》、《最熟悉的陌生人》</li></ul></li><li>BY2 <ul><li>《爱丫爱丫》</li></ul></li><li>潘玮柏 <ul><li>《不得不爱》、《我想更懂你》</li></ul></li><li>孙楠/韩红 <ul><li>《美丽的神话》、《天亮了》、《那片海》</li></ul></li><li>王杰 <ul><li>《伤心1999》、《不浪漫罪名》</li></ul></li><li>F.I.R.飞儿乐团<ul><li>《月牙湾》</li></ul></li><li>宇桐非 <ul><li>《感动天感动地》</li></ul></li><li>王心凌 <ul><li>《当你》</li></ul></li><li>可米小子 <ul><li>《青春纪念册》</li></ul></li><li>林依晨 <ul><li>《孤单北半球》</li></ul></li><li>张敬轩 <ul><li>《断点》</li></ul></li><li>Twins <ul><li>《下一站天后》</li></ul></li><li>信乐团 <ul><li>《离歌》</li></ul></li><li>瞿颖 <ul><li>《加速度》</li></ul></li><li>五月天 <ul><li>《温柔》</li></ul></li><li>阿牛 <ul><li>《桃花朵朵开》</li></ul></li><li>曹格/卓文萱 <ul><li>《梁山伯与朱丽叶》</li></ul></li><li>羽泉/黄征 <ul><li>《奔跑》</li></ul></li><li>郑秀妍 <ul><li>《FLY》</li></ul></li><li>那英 <ul><li>《一笑而过》</li></ul></li><li>F4-流星花园 <ul><li>《第一时间》、《流星雨》</li></ul></li><li>欢子 <ul><li>《心痛2009》</li></ul></li><li>黄小琥 <ul><li>《没那么简单》</li></ul></li><li>小沈阳/高进 <ul><li>《我的好兄弟》</li></ul></li><li>慕容晓晓 <ul><li>《爱情买卖》</li></ul></li><li>丁当<ul><li>《我爱他》</li></ul></li><li>蔡健雅 <ul><li>《红色高跟鞋》</li></ul></li><li>毛阿敏 <ul><li>《相思》</li></ul></li><li>徐海俏<ul><li>《空》</li></ul></li><li>魏新雨 <ul><li>《恋人心》</li></ul></li><li>阿梨粤 <ul><li>《晚风心里吹》</li></ul></li><li>刘艺雯<ul><li>《听闻远方有你》</li></ul></li><li>陈升 <ul><li>《把悲伤留给自己》</li></ul></li><li>胡歌 <ul><li>《逍遥叹》</li></ul></li><li>丢火车乐队 <ul><li>《火车日记》</li></ul></li><li>痛仰乐队 <ul><li>《无法离地的飞行》</li></ul></li><li>黄丽玲 <ul><li>《晚风遇见你》</li></ul></li><li>刘佳<ul><li>《爱的就是你》</li></ul></li><li>叶蒨文<ul><li>《潇洒走一回》</li></ul></li><li>黄靖弦<ul><li>《亲爱的爱人》</li></ul></li><li>凤飞飞 <ul><li>《追梦人》</li></ul></li><li>梦然 <ul><li>《没有你陪伴真的好孤单》</li></ul></li><li>陈楚生/何洁 <ul><li>《经过》</li></ul></li><li>古巨基 <ul><li>《爱得太迟》、《必杀技》、《情歌王》</li></ul></li><li>马博 <ul><li>《菊花爆满山》</li></ul></li><li>王筝 <ul><li>《对你说》</li></ul></li><li>夏天Alex <ul><li>《将心比心》</li></ul></li><li>一支榴莲 <ul><li>《海底》</li></ul></li><li>张柏芝<ul><li>《星与星愿》</li></ul></li><li>凤凰传奇<ul><li>《以爱为囚》 </li></ul></li><li>陈坤<ul><li>《月半弯》</li></ul></li><li>麻园诗人<ul><li>《黑白色》《彩虹的微笑》《泸沽湖2021》</li></ul></li></ul><h4 id="1-2-戏曲改编歌曲"><a href="#1-2-戏曲改编歌曲" class="headerlink" title="1.2 戏曲改编歌曲"></a>1.2 戏曲改编歌曲</h4><p>《探清水河 》《黄梅戏》</p><h4 id="1-3-近期网红歌曲"><a href="#1-3-近期网红歌曲" class="headerlink" title="1.3 近期网红歌曲"></a>1.3 近期网红歌曲</h4><p>《桥边姑娘》《最美的瞬间》《风筝误》《守护着我的光》《须尽欢》《不甘》《离别开出花》《繁花落岸》《千岁暖》《遥远的你》《星空剪影》《不畏侠》《酒家》《难却》《盗墓笔记十年人间》《虞兮叹》《赤伶》《关山酒》《平凡日子里的挣扎》《死心塌地去爱你》《不在》《我爱你不问归期》《若把你》《是否》</p><h4 id="1-4-动漫、游戏歌曲"><a href="#1-4-动漫、游戏歌曲" class="headerlink" title="1.4 动漫、游戏歌曲"></a>1.4 动漫、游戏歌曲</h4><p>《从别后》《宿》《化鹤归》《知我》</p><h4 id="1-5-古风音乐"><a href="#1-5-古风音乐" class="headerlink" title="1.5 古风音乐"></a>1.5 古风音乐</h4><p>《再逢明月照九州》《如花》《江南调》《古旧人间》《除夜思》《弱水三千》</p><h4 id="1-6-暂时不好分类"><a href="#1-6-暂时不好分类" class="headerlink" title="1.6 暂时不好分类"></a>1.6 暂时不好分类</h4><p>《求佛》《老鼠爱大米》《北京东路的日子》《悟空》《去年夏天》《飘向远方》《醉千年》《等一分钟》《回忆总想哭》《怀念青春》《野子》《荣耀》《无期》《樱花草》《翱翔》《最后一次的温柔》《特别的爱给特别的你》《秋天不回来》《千千万万》《无名之辈》《有多少爱可以重来》《水星记》《纪念》《向全世界宣布爱你》《我的少女时代》《爱你AINI》《明天会更好》《有一种爱叫做放手》《浪子回头》《再也没有》《这条街》《爱的哲学》《你是人间四月天》《掌心》《感谢你曾经来过》《不要怕》《你还记得吗》</p><h3 id="2-英文歌曲"><a href="#2-英文歌曲" class="headerlink" title="2 英文歌曲"></a>2 英文歌曲</h3><p>《Yesterday Once More》《Let Her Go》《See You Again》《We Don’t Talk Any More》《Rain On Me》《Take Me Hand》《That Girl》《Stronger》《Dream It Possible》《Fight Song》《Try》《Lonely》《Stop!Stop!Stop》《Axel f》《Faded》《Lean on》《Closer》《Rockabye》《This is what you came for》《sparks》《Unbelievable》《Stay Here Forever》《You belong with me》《Closer》《Apologize》《Glad you came》《Until you》《What are word》《The Saltwater Room》《Traveling Light》《Need you now》《Love Story》《Just Like Fire》《Dancing With A Stranger》《I Want To Believe》《The heart of the ocean》《Wolves》《Mandy》《Monody》《My Love》《Love Me Like You Do》《Unstoppable》《Umbrella》《if you》《A sad me in your eyes》《Letting Go》《Last Christmas》 </p><h3 id="3-日韩歌曲"><a href="#3-日韩歌曲" class="headerlink" title="3 日韩歌曲"></a>3 日韩歌曲</h3><p>《曾经我也想过一了百了》《Planet》《有彩虹》《清新的小女孩》《Trap》</p><ul><li>kokia吉田亚纪子 <ul><li>《泪的告白(谢谢)》</li></ul></li></ul><h3 id="4-纯音乐"><a href="#4-纯音乐" class="headerlink" title="4 纯音乐"></a>4 纯音乐</h3><p>《天空之城》《和兰花在一起》《城南花已开》《Senbonzakura》《穿越时空的思念》《Dawn of a new century》《Heartstrings》《nocturne》《Sometimes When it rain》《Sakura Tears》《Victory》《Champagne Ocean》《月亮门》《克罗地亚狂想曲》《鸿雁》《sunny mornings》《windy hill》《浮光》</p><p><a href="https://zhuanlan.zhihu.com/p/27815639">100首非常好听的中文歌曲。 - 音乐君的文章 - 知乎</a><br><a href="https://www.zhihu.com/question/289460419">你知道哪些少有人知道但是超好听的歌？ - 知乎</a><br><a href="https://www.zhihu.com/question/54562573">有哪些不太火，但好听到你想强烈推荐的歌曲？ - 知乎</a><br><a href="https://www.zhihu.com/question/51189008">有哪些好听到让人浑身颤抖、无法自拔、久久不忘的音乐？ - 知乎</a><br><a href="ttps://www.zhihu.com/question/20586817">你偶然间听到特别好听的歌曲有哪些？ - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 我的生活记录 </category>
          
          <category> 书音影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 歌曲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>休闲事情</title>
      <link href="/2022/06/11/Relax-activity/"/>
      <url>/2022/06/11/Relax-activity/</url>
      
        <content type="html"><![CDATA[<h2 id="1-学习提升"><a href="#1-学习提升" class="headerlink" title="1 学习提升"></a>1 学习提升</h2><h3 id="1-1-读书"><a href="#1-1-读书" class="headerlink" title="1.1 读书"></a>1.1 读书</h3><p>总说“要么读书，要么旅行，身体和心灵总有一个在路上”。作为自我认识深刻的人呀 ，闲来无事就会去看书。是打发，也是在别人的文字里找到有共鸣的我。</p><h3 id="1-2-图书馆"><a href="#1-2-图书馆" class="headerlink" title="1.2 图书馆"></a>1.2 图书馆</h3><p>一定要远离宿舍，图书馆能做的事情不要太多啊！看书上网画画写字，我还会逛书架，就像逛超市一样，发现一些奇葩的书，一些别人记在边角的小情绪，或者从一个奇怪的方向看书等等，意外得像一个礼物不是么?</p><h3 id="1-3-练字"><a href="#1-3-练字" class="headerlink" title="1.3 练字"></a>1.3 练字</h3><p>练字的好处太多了就不列举了，一个人就应该多做做有（zhuang）益(zhuang)身(bi)心(ge)的事呀</p><h3 id="1-4-口才"><a href="#1-4-口才" class="headerlink" title="1.4 口才"></a>1.4 口才</h3><p>每天花1个小时读新闻，在读的过程中不仅能够帮助我们练习口才，还能够梳理逻辑。因为新闻和文章不一样，有着严谨的逻辑。每次读完以后，尝试着用自己的话表达出来，坚持下去，你的表达能力会越来越好。</p><h3 id="1-5-了解行业资讯"><a href="#1-5-了解行业资讯" class="headerlink" title="1.5 了解行业资讯"></a>1.5 了解行业资讯</h3><p>曾听过一句话：“在了解事实的过程中，我们会筛选出许多资讯，这些资讯会引导我们做出决定”。每天花十分钟了解资讯，观察行业的最新情况，以便进行深度评价。判断所处行业是朝阳还是夕阳产业，或转行或深耕，规划职业生涯，定位日后的发展方向。</p><h3 id="1-6-参加活动，见识牛人"><a href="#1-6-参加活动，见识牛人" class="headerlink" title="1.6 参加活动，见识牛人"></a>1.6 参加活动，见识牛人</h3><p>在一个熟悉的圈子待久了，我们常常受限于自己的视野。<br>想要扩展自己的眼界，先要认识到自己圈子的不足。<br>多去参加活动，接触更多的牛人，把他们的经验运用在工作、生活上，能够规避很多坑。<br>另外，接触新鲜的人和物，就能看到自己跟别人的差距，从而促使你自我成长。</p><h3 id="1-7-学会理财"><a href="#1-7-学会理财" class="headerlink" title="1.7 学会理财"></a>1.7 学会理财</h3><p>理财的目的就是钱生钱，也就说所说的资产增值。要合理安排自己现有的资产并进行分配。然后财富才能进入一个不断积累的过程，财富积累后自然就可以做一些自己想做的事情，财富增值并不是最终的理财目标，而是我们达到人生目标的必经之路。 　</p><h3 id="1-8-学习PS、PR"><a href="#1-8-学习PS、PR" class="headerlink" title="1.8 学习PS、PR"></a>1.8 学习PS、PR</h3><p>随着自媒体的发展，越来越多人开始做博主，视频博主最紧要的事情九四剪辑视频，你学会可以学习商单，一单十几或七八百，不过对技术要求很多，随着佣金越高做出的视频效果自然非同寻常了。当然当有一天，你的其他知识学习很好时，你可以随时离开不喜欢的公司，随时成为一位自由工作者。</p><h2 id="2-梳理总结与反思"><a href="#2-梳理总结与反思" class="headerlink" title="2 梳理总结与反思"></a>2 梳理总结与反思</h2><h3 id="2-1-梳理总结"><a href="#2-1-梳理总结" class="headerlink" title="2.1 梳理总结"></a>2.1 梳理总结</h3><p>整理自己电脑、网盘已经各种在线网站(博客)中的文件夹/文档，定时整理邮箱邮件，不然囤积太多。</p><h3 id="2-2-规划时间"><a href="#2-2-规划时间" class="headerlink" title="2.2 规划时间"></a>2.2 规划时间</h3><p>管理自己的时间，花时间去复盘，做做计划，让自己更加清楚，做做总结呗，看看实际和梦想的差距，再进行调整，还可以写点字。此外，还要好好想想最近有什么事情需要做，及时去做，不拖延。</p><h3 id="2-3-调整心态，摒弃杂念"><a href="#2-3-调整心态，摒弃杂念" class="headerlink" title="2.3 调整心态，摒弃杂念"></a>2.3 调整心态，摒弃杂念</h3><p>人生在世，难免面对许多纷纷扰扰。心态烦躁，眼前的小事也就成了大事；心静下来，许多大事也就化成了小事。<br>面对问题时，保持从容镇定，心静则清，心清则明，这是最好的生活态度，也是人生至高的境界。<br>人生短暂，也许有些事我们无法改变，但如何提升自己却可以由我们自己决定。<br>请相信，那些你流过的汗、读过的书、走过的路、行过的善，最终都会回馈到你自己的身上。</p><h3 id="2-4-反省自己"><a href="#2-4-反省自己" class="headerlink" title="2.4 反省自己"></a>2.4 反省自己</h3><p>学习学习心理学，定时反省自己，找找自己的优缺点，针对缺点重点改进。</p><h3 id="2-5-输出内容"><a href="#2-5-输出内容" class="headerlink" title="2.5 输出内容"></a>2.5 输出内容</h3><p>我自己会定期在知乎上面写一些回答，把自己学到的知识，用相对通俗易懂的话去表达出来。即费曼学习法:当你将一些专业知识讲给别人听，别人能听得懂，就说明你已经对知识的理解非常扎实了。<br>写篇博客文章。一点点的闲暇时间是更新博客文章的绝佳时机，也不完也可以分几次，累积。</p><h2 id="3-生活娱乐"><a href="#3-生活娱乐" class="headerlink" title="3 生活娱乐"></a>3 生活娱乐</h2><h3 id="3-1-电影刷剧"><a href="#3-1-电影刷剧" class="headerlink" title="3.1 电影刷剧"></a>3.1 电影刷剧</h3><h3 id="3-2-收纳清理"><a href="#3-2-收纳清理" class="headerlink" title="3.2 收纳清理"></a>3.2 收纳清理</h3><p>要时常清理一下自己的生活环境，定时收纳平时乱放的一些东西，此外还要时常打扫卫生、清理自己的办公桌，一个干净卫生的环境、一张整洁的桌子使你更有效率，你只需要把办公桌上或周围地上积累的各式各样垃圾都简单清理一下就完事，同样的简单、不花多少时间。</p><h3 id="3-3-打电话。"><a href="#3-3-打电话。" class="headerlink" title="3.3 打电话。"></a>3.3 打电话。</h3><p>列一份你需要打电话清单，记下号码并且随身带上。不管在桌前还是在路上，你都可以在很短时间内解决一些通话。</p><h2 id="4-休闲探索"><a href="#4-休闲探索" class="headerlink" title="4 休闲探索"></a>4 休闲探索</h2><h3 id="4-1-城市徒步"><a href="#4-1-城市徒步" class="headerlink" title="4.1 城市徒步"></a>4.1 城市徒步</h3><p>不管是不是从小长到大的城市，这个城市一定有你还没到过的角落，拿着地图就像在游戏中开拓新领域一样的去探索吧，想象每走过一个地方那个地方的黑色就没有了，感觉很有趣啊!尤其是在上海这种地方，一不小心就会发现什么故居或者优秀历史建筑，比如我到过的老舍故居张爱玲楼下的咖啡厅丰子恺故居林微因住过的小楼等等，会有很多意外收获哦~</p><h3 id="4-2-夜游"><a href="#4-2-夜游" class="headerlink" title="4.2 夜游"></a>4.2 夜游</h3><p>城市的夜晚和白天完全是两个样子你造嘛!!很多有格调的店子可能只有五六点以后才开，很多露天的小演奏，不一样的夜景，还有各种跑车。。。一个人觉得不安全的话可以豆瓣同城啊，有很多夜游团伙(团伙? )，一起看凌晨的城市，安静或者喧嚣的，多么有趣!</p><h3 id="4-3-看海"><a href="#4-3-看海" class="headerlink" title="4.3 看海"></a>4.3 看海</h3><p>我承认大家一起在海边玩真的很高兴，可偶然自己一个人去的时候，是完全不一样的feel~还能独自感受大海浩浩荡荡，涛声阵阵</p><h2 id="5-运动健身"><a href="#5-运动健身" class="headerlink" title="5 运动健身"></a>5 运动健身</h2><p>跑步、游泳、健身，运动的时候一个人也很开心而且更自在啊!!!不用担心有人看到自己面红耳赤的样子，也不用担心形象不佳，爱怎么动怎么动！</p>]]></content>
      
      
      <categories>
          
          <category> 我的生活记录 </category>
          
          <category> 休闲娱乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 休闲娱乐 </tag>
            
            <tag> 放松 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性格与为人处世</title>
      <link href="/2022/05/06/Character-and-My-action/"/>
      <url>/2022/05/06/Character-and-My-action/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="03f9d4adcb5005e1cd5700a1424ff60ca3a980218e100e05b0e0666c69146522">26d0955f3518d1f7254047f47551dc2e5bae0867ee61417fef479920426058113b488fa7c161ac6ab2ea764247cabbfd91e00796619b3600a901f7488fc42c23a9aedb0c0b23932eb1aca1400f8f99098a31c84bcb38160e988954544d9f0a134773f5b1219cb0d32b8647377e7cb1e592da4a46d807e9a94c8b60faa15345b1995890b3ef2f28b99cbeb980d335a5c732fa2c7f692c708620e18062b99d1b72a508b6e6ac326b4b58d52c4d0582d0ff4cf001cb8ce1bfce8c5dea5b45ff9db669a90203ac680db01b1f5cc4869605512b64c20bab8cff120ddcdca514e530363d6925397478abd158e193b429f4806c833aef9cacd05cfb70f99eec92bb285cd0657e7ee5de35aa7bf882f8f9d667b640d71fefde8b2e2e849dca3230db82558dc00e7bc5974ea87809fcb980bbe6969413a7536efd4b955a9682b36de8bbef037a8cf465b4674081fe3f62852d7346169bea521d293635d626034bb8aa4afebb4b60d8ae8237cf1e1e18f4b4b7fd29ae3a37192f77047ae5589754106f926b2ef0e448d869cbc761660840d5d5062605d7feb9084ec943fc6c02f51240c1bdd3e3db0ca35c70363dfe8037d97e325dfd0296253a0e190f062883749526440367235d253c830bed16a7e3cc3d07cc75d480ff4b55774b43fc821a4e5b0913814705f5b0888b541ccd2cfec557976ecf45e98250b37094694258ce5874c9a681b2930be951a08e66aba206e613b6a769b91e8ad896cd3c12ac1ad912eec1d8d75ebc69a413481d12ffd0f444e698ed9da238bade58a44ea2aadf149ed7989b103121574bb57eb1ba93905f3c1021bccb72f818de6225962b56b7681b10a573aaa87500877925f2aa1c0c7b24c09b14a8b55dcf1f99bf1867c98341d146ff27426fe8b3be2e2c3c6efe555a9b6389eefb90f482d881ff0e47a4515fe4eac053dd1b4aafef05a4ee12f0a3d651d840e79d2673a6ad7d7523491a7b4403d261601bac167af853a66785fdfa0b93d5a43712b7c76dd7e157c78001465d764c14267bbbcaa902df30c34b70b831400e9fcc1a56ab934c6e1b357ce04cc0671d7dc9ec7f7146457255be19fd190972a8debb9a922efab3429106cdcb4a5dff806d7e479490e7025c8014713e7338561ec730c88820ca97483cbd4721dca7dcedcef5c60d103b2f462f5c134fb699b9c52b60543d3578323ee4fdefd13d95517ae17aae7ec4e88492871424010af4ea00050ad8bdd1bfa1ae7fbcd100cdf4ef6fa0c2a248461fa4308ef37b628a49e7e343eb3a7c04c2fa4a819996dee68e5984cf6da9553eeef785fa31b4cdac6beecaa7aa52982adc8594fe0cb93e4c6c665cda7ad64a8ce27583e8bc2159a8ca3da5c137dbd94f8eecab531df54c55129aeae22f732d41aee8ed4d90d7574b4c4fada2229d952603c409a39b204814183bbadae3ec3e89aed8a5bbea1bc4cbf9db6f58f70d33c5f205ac7ac0c2e14b26a4185f466730d42f1c38be4a6fd261260c968b70b559c2e28fc2a58a6eca967ef4d2b99c48fe5505bf6b7d52c91b602a30860afd174e471ccfcdc79672f57f31aab88fb8ae50cfada5cc8a02e1706f0852b4f104891fa0d5ba13ff5f741824dfd470e1dee72f582f63737b0af104c7a7551cea0281534305412fbcfd84968cc481bfeb78562d6ee951700e2e53fb52e38b773fe7885654b3ebb365f2056a85a46c6baa30799f0b1c530022773d767fbb16948ad77f97125d71e4737125b02e1dc82d70d3693744b92d40bda8e7389b4382c1c51b20c98d82365246e9b99a539dbf595c4009c2e718da5c456e03de9eac75277190136b7fa455464f5d8f4cc50daaa671e3936133bed436df84f595a293122b2037222adf82741b6db6cdbd70ed5462745b55568d7415d0729f62859b58041ac6547c12ac0fd4bf80b433b53f924ffad684642b68fb74a3d5302ac942ae8c6264d7e5c170fe70b48e5947fc04888bf5d80a2d8c88cffbff7fe474cc835d7645390dd4fabbdaac5670424e7d4ec07c8444f36b4cc46e08f6338cd78992ed41eb62e03a5d2d36abe7c00da8a8378734fa69adf364f8c509d3a15030298376726057f4e15698001fdbbdef1a9e1361f7dca4408047b2fc25d9c9c7aeeac5c93346e7dc7cafa4f85bbfe901e052390ce1f16ccdbdfd1322bf84e4ce720913c7908d9628314e9501eef50578b0916dce188d6a1aea1a1128a3f6f733f67082fa2b0e20fb54d6abec348723c4e77392ba9433c81ffa54e7cc26fe6042375420b0b0ccf395dc6f453c7258d8dbd0622cae324b8a21bdb500c351e62f4300474abfafd3a0710509a9dc375b9af060df2ed8e1d0551f481942f513bc66c1e622a5e88351cc54cbac01bc0f4a5c5839cad31f079e11a5925c69163a9da44621b585232768bd0ee354f1f7ab81a0ae5202eb71fb35e93d22edd80cbea66edf0d7c6e01a17bf3f9ccad83e05d8822f39baffce6f133c6bedc84afc11b107872b1a2ccefc7f312bd5232924c138b955b0db8b73b78a0c4a3d905d5a264f686896050b4401f70721dd26163d75a1df3aef7aa3a61f5f572f875b8ac24c41b3f958280eedd414f42928a3a2914e822650eb27c7a271e857fadc6f9a3755ed98dfca7352ccef8fe4d2c171e00cfd258aa8601c0db73771fa5a111ef7220000e0268cc4ddb007fee464731736b58c8c151c5d2eebb281942780ca535a99b5c0e9bfb3585260e2c560927b414938876190fc83ffc8ea487a9c0b48812e9a037dadaee93abf1fcf05d5956bdc6a33e825f2bc822bcd1c4c1a154713cfddd6c2c425a46a9308d25cffe0959216a98908f46b98016b40141a9bc311aaf91526fb56a8487455ea59450f1373bc5e4f0c4fed5020993ff2c210f26e3ca21bfbfa93f0f7290fe695b8a3778593077a8554e87d97b8bdf54ea9c5f192a818dc9849793ad15e6a061edefdb673713c3b8e0d1be01cb0bccdefa645d01d7adbeabcddbd15f1160f807541dcfa070ff9dbafcd4e1e8bccbdb27d63c5bd16a25d0f5beda6120cbf1071f53db9b78b94fa1a0c80a4e7cadd6e9dd5d84407738abeb93ac0a6ee0c21cb421af12c07ae87926b09cf3d26b0df638138887a2b1b13fbe0051eb0bb15e58ffd4bdb05b3575b3f7acbe2985c8bd446071c126bb33e7ce069337348148851012aee8b739d097a72a716debd99900f8d46d66a2a868c1c626cdc38a3a4afef0b82bbf397f5ed4be320e15f84fe9b2d3200b86cf39988b4f3b104bfcf581e700c65116e5d4a1dfad435061924dd1f057578ed98ad59ea5e9a181c6ff44afecb4842e475575258b5e1fea2803f22dd217232048c1e04e505cbaf834db0d93564b211eca1bd2c7b9de5f79f95e6145f81767027778b81a96d310a4c5214aa37e1a060711cec640ce2731d325a0d19e10c7439a268ac9d700177aa63a46b9f1585d34169719fc8569442dd5337116882983ee91f7922f4cee657c3a49182d93b1ba3a0d3bd5470c5f63d35660a74a7150ca20b8de6c00d0799611ef3a0df557dd96637d4c9ff19cb172daf399174f1ffb2ad412101b68e0d4f216f41c5c706b19f3c4ff5af0d20317fa6573f56c7de22f2bd86ddf056854949fcf86493f50f43a1fd98d4ae1fe1d339eb1441faae5c757d5b2b03330611a4768a11fc82fb10f908aae8144fa59a7a9aff870e832b6be28dc1fdeabccfd4b6e2f5b69f1556971e5bc80479a86876b999d07905b34de0fac2c08e11c0d48e699ac19e003d456c2a6b41b4d5029c7cb7346eeba59e8eee57841e4850c20347cb488fa4aad3f528dad30d3a70f7755e3101873df4da440c49f026975e8f735d56117501918cc9bdc1de6283a82f6b8a1e97406c892ef18a80700abad4d98df1bece528dd5ed45c863008bc4e826fe875b85872ae134abe7cbbc9c69a0b4fdd1c25762e705d2a53479c17f98f9debd99cdf911bca40290b9bb13975113a5779991bb53fa7a6f42c447ee49567c496f91e651b75bde6a1687c290a6b17942ace0ff4c203da69e8a97a1460330fd4ae6f77b5bcf9f99a307f6f2d7f4d22d568150358ff66288f715893046b6fbf53b4e3ae8921998185386c5fbe924ca342e2b4f8a9049fd6028cb3e16ae25253804e6e8c6cc08db6ad6a72f8a12777265b5e4c28ea88764f0487fd2d65e7e68120ca298a2cbb6da1cfbb062df3145a8c53c31003b90499b720ada473f737f7e708cf1ddb9d03f5883aca2a257213bc3f8bf255140be12e7c02a5e992bccda01c62619742a8b7164bf95adad5265a048ab70a117576eaeda6dfce58866bb4834e116f4eda5d8ade1d64d03b24040b01fef0b1eef6f8831b5aa6956d2705e4aea601c92595c5ff988951a88773b579197a2907f90b3647e24a57476f937010e1264b870f2b2af247ef730aa5c8989625bd170cf8f48422f3c2d47de3872fcbdce1a9523df2eea555799a30ee5e01d3a1df5cae5e5870663502d83612621fcc291bb41b5ffbe6656f8c97993ec6e11818d61710698d11d481ca46a81ebf161c7b5feb4e79833b536be8f3272dd31515a96570aa0c5699f2234335aca583fa259f45e650c8246004ee1130d97745dc2704f8942912ddf3d8f37c6d1dee560e1a8a952fb6a01b53695b78b369b589f68011e0e2e3289868ffeb221d761b6693f594104e80db0af77997904d23838b40eeb243ee42c83317902b28a34d421f189b2bbdafafaafe90ff704856c3921dfb4f955c790f2a20d613596fa53f4eb717b68bc0c06f12b96ffc89787ab15f8e680b2af1074cbd0d4cfa721ee30dd4663626de3ab46329638ca27f8f1f61acd30558e041c4fed5c9603317b46eec002c063afbfa219aaa991127333a5b07e38917744ff26ed3bbb72ac672684971289d090e5d33ffffcda5d4f9bd191282e251bbc29a0bce03dd41fd5979e320e74383b583eb761424b40fca51329443c4bd843d387c839b7a4f42e6ef1b7f0dbc84901ac48c4be0b27db7e1fb19cb054e2c69e34a10860c6733c53deb5523d9c0f62b68d567aed1607a84232f621843649938ccd5f9ed10e4d2408a255957edd6f8d08632fc8bc790120f700a1867efc3489f36ece655d36a951eb5c20f1119659479e89523a5474837a68e1393e4c7a8eaa6abd8d35be41e7fe3260b2ff2d0be70b2d9b0bd206c774a0efd013cd62ced8d4180b7113d456fb112bbd5da932e7a182faad4e2bafa4eba1131f7f8da1900712411b7c981120ffb2b0a7b45fb3f2bb8d2ec45a1109a2f6e4448e75613516fd5cb20ae1fc8286fb662a6eb066994f4c89b257ed7ca333a056c9edb1f864839faa3d8712197170aba5789d12636d2b6a978ff74bd0954061dee0fe3c33fe645295292d8f7a23142c4aa0e0e8e9696ceec395915cf7636ab57c31a22d10af54606ac432203a0e9f671fbdc4754ddced14eb45af8243a7ffc7720bc527806acceb958fff9997dda88811cbfa901e9ac814f13201502007955df5469009de68f6c8bcedf1d6a91f0cedaaf45e33731bd62974d5fd113ecaf25ae1593c5a7ace5f2b9f741b61d69e2eec39b18dcd6859d875b654803fb7cccccc4686047c1bc84e800a8c681ce219fcde4a62b7df0113ac57635681c7fefffc5599b66781ea04701a11ad9e5e1facfdea2b3b7258744c886dbd96b504b3997167677f87c19fad7e09de94cd7d7f7318e8e9978f57c1832024b7bc8a07ad6f592d7ebdc6bd76cb741258a1bce549d38944d230502389c0e02e2a028af69fb6b9f189b17472b691f6efd991695486286ab55ca2c69f120727b236c0e463c411fc49123d30d051f26fb67cee2c6726cecdcf63657bdd6ba77c3986cc11ea7fbacea82a53c9b2f9bd9437fda50e380a8da69d974b22a2a3f5ab0b732e25f442842fb06bbb00de75b2d3ef96d8d3753e7af732d5875f9024d9e1c5d5f2d2f3824ce00a5d1bfbe2637b4c7c6ebf360eef5a16d5a061bc84e620204cfd643d0ba5144af9e88ed0554f0d11b60a1244b9771ca64ebac45c01ce0bd2c45bd60bf2535e79a9bc213aaab42f2006314936ebebdf3f397235a53c41542e9fd25a631b06fc8ebe2860cd6fbc403802403c5d63ff8b216a0ee77b4d7926b2f58525db5f4915a872c29cd0439b1eeb23b0331681d6d1230675aa3fa3b60a82bcf9bdede3971c5215031aebcfff51a00199123d3351af56d5c8090aebfdd136e3e6c05d00fd18a13bc7ff6575dfdb313477b960275677f53ddb137941c75ffb11dac6a74744b3530904b5e7fe56869475b8dc6a2c78e816239062c448d53fb5c08041b68c809a80ca4b36ae8b0dde6a47e36e9668390bc01e0f5dfff42da0584ee992277ec3dbc9d4e98157a03c11caa948298c2f97521963c6a870f9b284e18fe4ab380fa5c5bb957f454dc2fefe3d6521e13b6c8e4aaea0f1279b6a6df53209d9d45249e12fb922114e19f3c9a50354813ee64930a289634ff80bd0ff3f37e7fb54a5c40452299b85ff0e08305d62b152b36476ee81cdd50717147eac98eac19bafcea2b4811ecab2b5ad53729df495158fbba22c12496eccfcfcbaff2546fc619aa9cc3a0be0994335b45a18b10ab729fb3e4e6c6344d62b439aebf9c524db82ee120f083bb3569b8ee291e5c90c40463474346e2d0a0f91dad812ba25a1956f824b1bacba9b6e6b5dc89bee9c3423c1ccf281e3968b4d3a16213cd69f67af5c45b044c934b8a4d61db34ab5be7de3eecb717dabe4bd2fbb01bc6c90bd33d201b0064f1f25a3c69b5e67b717d81df0bbf62c33ded56368a2d5550963bd4e2559b03529afbcff7cc57d1c3037f43a9e8360e6ddfabf47892404df320d7ff238975035a393d43aff19e272b470883d9f0744a39626373f7298fb8be2de0142b55cfba60487323381ac52d923b1a9f5ee92d5d99da99c92081fa57b31626ddb63807fdb1b1e334141489006aeaa1b3454711a0d61b212a908e5507714144b8fb0d73bc05265f09ac239ae12389e9aea8ac2dca66652e577ffcf485ccbadb447616476058f2c154768c606d55bc37510e0e9c9888a17bb17003a11ea347ff3b625abc5c87b6752cd0236e979429dcf89edeca126c1a9b2f20b0c5a1a336b701557ee3245e077da4966f73f2420fd03dc74a2eb46bb495e248c80d31e9ed950bca3ce83efad5b15d3916161ef832934796036caf452b8384be421fe5b8d957ab26390b2d808a362d00de214ad3c802212cc0d5ead1641d5de0a948d592f789da370ae1490549af9753a2a6fa0f09998f5784d8a8068b36fb002e756a37eba197a9aaad376aa27e67bb5a03924974ed828d5bcb8af5638fbbca6573c01024cb1e5c38e77dd2594054c3956ee216fdc2d3f34280a6ed47dde3f88edb6ec1d46ea2cc92c36a8b8cd0d7425172228310c3832687dd4964784254c39cddddd350e0fec752f58856c1daf4b568b99849db555322de4857ab804331982fb897972fca712b62b944a7fbe5907e1995fbd56bd0fa800028415552216cbc2c5d74411a6b07982c49a2c49b2fdce4abde8aaa91736024dc1090819a1cbd15b2334a702bd91071855bc499f34555cb772fe0dc97fd61e8acaaa7c83bd49957e78b3fa11adf2f4736d06c2f35f5b22fc2c18a8a15fa26010ac42ea9392cbeda052304635a5cbe0b54b1c6c9a8ee77d302dcba363780680fa49b6e35e0a35553f3f143e3b95a76a6172b395343dac825b495cd03eb611131a0c13e42328685882ebbc1310dc48f0a417085a3fbd3a4247106bc3e754de0edefd7a303ceb9b7080ffab5c5daa99f096ba655f0b3c3f0b0584e8527c4014c0b58cc15602e789c7a858172f763fed213974f63a21d97d171cf24d239b1f8b12df63a95c8f6e09370272e13b0bbf3f1180f45c908c708816fe0faabf3b7b4a8f6dad5e9bf3b5e2b5f45c4d84e77a64c3a030e55a5b43923c9936ae6e3448bb18630c28e0f11536722beff0de81e20012447b7ec8729a8425d6a5e3a9e1425e7585ab93b5df5835421d162eccbb61f7ad86d7a32220a425314c1d083264b4c52a70f5688715e38047de62cb7b40088b9583c6f7564a2f3c35e22ebb431c38d70bd7291835d383e82241affcf44050b95692c06d9b4481e747c68c167e6485b654e3a4914a99754e306d421b6a677207ce3ccd28497c9db8d25fa5bad843dec5dba36df42aee835fc6b0cb3c735257e65ef13c43ef1612f66b532027e4c7980c9c9d44b57ff743402476203a73201d24a52693c93099a9a2361f0ff1bf32c2267e1dda7925b568ce1cca6d70a655825d654b9242e8e226f10fb5fda42aecfeb9010b1f362b17e2e41c11b87c41036844d9bb15dd6233ad63c581b4957a34fc8d73854b70009935506c659333b09842c74240c8ad88e14f8cd6f0ee58606fab71f85c1d447af5591bb0ef444a54d25061deab41232486078799cca3176c87a401025d1502d259e3e1dffd1f1dff0976fb262fc94e70b7590e81009a4b5859aa7c18aef109d99b6990b710bc5be61ffb460ec59c4f1f14d52c3a309c88a4b73d7709416b508b6c794884375237631d6d08b449982e78d9e2a6e6dd2c9ac4e75445e85eda806c563f4fe34cc1f22ddeaab2170d288ed033fc087edc6111cbeeac24cbe7971d2e9fa479a5b535025e21697299d92110c878e4c655d652628438422be84ccc5b901f6ce5f44383b0195921655e8c99806281c9f248f72cefd1e245cd7e755cc73847913e27d5ff54829130bcf836579ae8c3ebc2692f3bace89e49352ae6557b1c92a9bf2a39bfcb3d4440fef5b8df882de3a2c1582ba6b796a3a1564f644dfb5520f2bd3c897b2f586f2e4b204194a25b23f6ab89a9a44cac0536c92fb8746617b926234948f4a935f6fe308ad5a9a75d9fafa9f0136d4121658560fa5e8ae0bf55787f38cc7b85697c6ee12c83039c54b9af283d3ed26e2bf1a1e4867e3939fa78adf6cbd33b247cd291237ad39e608e50d4b24ffe0387a66eb421f2963d11aeb166127b55f397f9c071641c6d227eeb7357e9391da35213b6cd192cdf1e28c44cb471d4e91b746eeaeb257402bc586c615a6bbccc0303daf2ae0a6820815976ced6dc59247981c96a282b61672c72c0e396040f00efa43c5bf9568eae78d9aa45b23cf1274b2c325db1085f3e8e3eb559212b5a9dddd0e2dbd86fc34562dfee7094051aaec255a36cd94897291fab11ad0cb9e136cde5dd9a9aae634b979a553bff779e9ad4cc137a262acf7d28a9f539fd3cfa820694352421386b79fde85a53b12367e91ef0e5e815c3fec6794b76d1027126cbeabbee58b74511f008986c4a450881a323df7c496c71271f65c041bbc7e5d09862561e90ca1cf5e60f92c704c3b3ff43a1539eaae8d6ab4cea59ed5fc36006910f83a21b8bd84f33a8002e5d706768372d34ae30588fc5a2cbe34128b86aafbc1c84a0dec624bededa043f837292eb48b76e4834d92f95453329eb3fc752d77ff26dc55fd29acf1a8c45eb24e6c2a555933e0a6e8006465289d0016154bfa799368274a6b4c771d3c59467774b670908af3c57e99885841be17b8f6d89e6d49f450e5fbf2e160d822bbcdb466c02c4f946292b6d71a90d7bc3cf5ac317d229723e1c1069b372067c2d73989b040dab38941d3d5701c4f5c2cc04ef97bc949abe7a723b99f6fb16838973f8f84f822cbf556a44d29cccc13031bd51bcb6281d497ed06af406170b477c1f3dc31df07c53a17647151ebe9cf00ef146f63da2433c0e3f82168d8a6d8ff70aeefe886ce5ca68b43dae480b4aef4792f391af32c013ded92af689d82394b0ff13689663a180dc4947291301ccb5ece3484faff04e8075b86e3a2ada6e506a2ad986130b4ce458ea1b8d0f5260f18579ed62db5399869b196d78ec00934f0563ff064dc7890e390db2dd7ba44aeced3ea584c6c2e47d3438aa8316742c25cca5447041075a075ce25a0694600968bd729d40ad95d4a90ddc01d52eba4b591345559c4f867342334cd1df8335e776d5c03c9d5a856ca95b4d31b70bafc4513679cbeeee059ab833ba256de4e6311cdf435e9f85f54fe7c8ac36df402e9197d97260a6f568b79eb05a55b6c6567226960ea1ae14dcf2b43918b5355009b40cc12b31ede68efa15d504d93cb015f98c08b3ceb9d93a9d3b1fb5e1b4915f56e86547c86a1e48a792214b79dcce38aca118667fa3beccbef5ce65106e309f3e9f25504a1e1d088274cc4ddb5e10188d10eb1e3e6811c420dc14a662dce1605be5e73258dfdd0d5e4a9e47a217ac9c79228e0f3299a640232bc0e5d45f85ebef20e3ddaa1aba6c2500774d5bf267578c4f5ae517a8698d58782805a72320f5bf04b76bb56d13f660525231f962b8f4f42374ec208ad76f42a03c706a2be748c7761eefa220771780d967c666e5085f5c24db05ae442daf00dc0e4feb4d05c3b8650e327c736d23287992a44fe9019cb337ad1de3d161cf029657af937bf4dfca24d9e33b96361d898b0a4cb20b47addac4f1f0ef87dd0ebf2324a3cfe47bafbf6f7b5b87244022842bf28a6db5801676a0bb22e667d6b5a4424951d47b1c57f70a597c2403b95f36f534be19e49bb52c2e1e4f06fc46348a2ebd650d6091d88166336eca771ce03c1a7e1817bd9bb9eaf68ed9e5075882a894a8a89c00e52119d88160f3979cd12e4dc86cd317308c91dbde392d1f498e6a039ac26ea37097cbe65bf4efacacf882298c0594e1611e7a5cf71fcb453971023ea695e2738b44ed68dbfd6d0a8bba06fbf9431a354e864c0983f7a895a6255fbe77e87dda228fdd255bb26441d3bc8ab0b5ae1a6dba684393d80a5c41f1d4cb13bedc9660c06103bc2b45b009bc17a7eab3dd006a7780faaeede8302188fda27cba5cc0bdb6c726c62d778958072604b7af6ee9805</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 我的生活记录 </category>
          
          <category> 密码与保密文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性格 </tag>
            
            <tag> 做事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习</title>
      <link href="/2022/01/18/Learn-Git/"/>
      <url>/2022/01/18/Learn-Git/</url>
      
        <content type="html"><![CDATA[<div class="bvideo"><a href="//www.bilibili.com/video/BV1vy4y1s7k6" target="_blank">        <div class="bvideo-box">            <div class="bvideo-cover">                <div class="cover-default"></div>                <div class="bvideo-cover-layer" style="background-image:url(https://images.weserv.nl/?url=http://i0.hdslb.com/bfs/archive/7d77c3fa1e99a6615aab26615f20b8cf15c78d7a.jpg)">                    <i class="icon-video"></i>                </div>                <span class="duration">04:52:41</span>            </div>            <div class="bvideo-info">                <p class="title">尚硅谷Git入门到精通全套教程（涵盖GitHub\Gitee码云\GitLab）</p>                <p class="card-status">                    <span class="play-num">                        <i class="fa fa-youtube-play"></i>                        <span>126.9万</span></span>                    <span>                        <i class="fa fa-list-alt"></i>                        <span>2.0万</span></span></p>                <div class="partition">                    <label class="card-label">视频</label>                    <label class="up-label"></label>                    <label class="up-name">尚硅谷</label>                </div>                <div class="actions hide"></div>            </div>        </div>    </a></div><blockquote><p>PS：上面的尚硅谷的Git教程是我认为在B站讲的最好的，但是本文并不是来自上面的视频链接，而是来自廖雪峰的Git教程，具体的链接在文章末。</p></blockquote><h3 id="sect-1-Git安装"><a href="#sect-1-Git安装" class="headerlink" title="&sect; 1 Git安装"></a>&sect; 1 Git安装</h3><h4 id="1-1-在Windows上安装Git"><a href="#1-1-在Windows上安装Git" class="headerlink" title="1.1 在Windows上安装Git"></a>1.1 在Windows上安装Git</h4><p>在Windows上使用Git，可以从<a href="https://git-scm.com/downloads">Git官网</a>直接下载安装程序，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！可以利用<code>git --version</code>查看安装的Git版本。</p><h4 id="1-2-设置名字-邮箱"><a href="#1-2-设置名字-邮箱" class="headerlink" title="1.2 设置名字+邮箱"></a>1.2 设置名字+邮箱</h4><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>注意：<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h3 id="sect-2-创建版本库"><a href="#sect-2-创建版本库" class="headerlink" title="&sect; 2 创建版本库"></a>&sect; 2 创建版本库</h3><h4 id="2-1-定义与创建"><a href="#2-1-定义与创建" class="headerlink" title="2.1 定义与创建"></a>2.1 定义与创建</h4><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p><img src="https://pic.imgdb.cn/item/66af1f60d9c307b7e936dfc1.png" style="zoom:30%"></p><p>所以，创建一个版本库非常简单。</p><ul><li><strong>第一步</strong>，选择一个合适的地方，创建一个空目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> learngit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> learngit</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示当前目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure><p>使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 </p><ul><li><strong>第二步</strong>，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库(empty Git repository)，细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><h4 id="2-2-把文件添加到版本库"><a href="#2-2-把文件添加到版本库" class="headerlink" title="2.2 把文件添加到版本库"></a>2.2 把文件添加到版本库</h4><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪<strong>文本文件</strong>的改动，比如txt文件、网页、所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><blockquote><p>PS：这里在本地库暂时测试了一下，word文档等应该是可以用Git进行<strong>版本管理</strong>的，只是Git无法直观地展示修改的内容。</p></blockquote><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><blockquote><font color =red>使用Windows的童鞋要特别注意：</font><p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="https://code.visualstudio.com/">Visual Studio Code</a>代替记事本，不但功能强大，而且免费！</p></blockquote><p>言归正传，现在我们编写一个<code>readme.txt</code>文件，内容如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p><ul><li><strong>第一步</strong>，用命令<code>git add</code>告诉Git，把文件添加到仓库：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add readme.txt</span></span><br></pre></td></tr></table></figure><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><ul><li><strong>第二步</strong>，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;wrote a readme file&quot;</span></span></span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add file1.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add file2.txt file3.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;add 3 files.&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-3-疑难解答"><a href="#2-3-疑难解答" class="headerlink" title="2.3 疑难解答"></a>2.3 疑难解答</h4><p><strong>Q</strong>：输入<code>git add readme.txt</code>，得到错误：<code>fatal: not a git repository (or any of the parent directories)</code>。<br><strong>A</strong>：Git命令必须在Git仓库目录内执行（<code>git init</code>除外），在仓库目录外执行是没有意义的。</p><p><strong>Q</strong>：输入<code>git add readme.txt</code>，得到错误<code>fatal: pathspec &#39;readme.txt&#39; did not match any files</code>。<br><strong>A</strong>：添加某个文件时，该文件必须在当前目录下存在，用<code>ls</code>或者<code>dir</code>命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。</p><h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p>现在总结一下今天学的两点内容：</p><ul><li>初始化一个Git仓库，使用<code>git init</code>命令。</li><li>添加文件到Git仓库，分两步：<ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol></li></ul><h3 id="sect-3、版本控制"><a href="#sect-3、版本控制" class="headerlink" title="&sect; 3、版本控制"></a>&sect; 3、版本控制</h3><h4 id="3-1-修改文件并提交"><a href="#3-1-修改文件并提交" class="headerlink" title="3.1 修改文件并提交"></a>3.1 修改文件并提交</h4><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>现在，运行<code>git status</code>命令看看结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令查看，此命令是：<strong><font color=blue>比较文件在暂存区和工作区的差异</font></strong> ，即显示已写入暂存区和已经被修改但尚未写入暂存区文件的区别。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff readme.txt</span> </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add readme.txt</span></span><br></pre></td></tr></table></figure><p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p><code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;add distributed&quot;</span></span></span><br><span class="line">[master e475afc] add distributed</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p><p><strong>小结</strong></p><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li></ul><h4 id="3-2-版本回退"><a href="#3-2-版本回退" class="headerlink" title="3.2 版本回退"></a>3.2 版本回退</h4><h5 id="3-2-1-查看历史版本记录"><a href="#3-2-1-查看历史版本记录" class="headerlink" title="3.2.1 查看历史版本记录"></a>3.2.1 查看历史版本记录</h5><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>然后尝试提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add readme.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;append GPL&quot;</span></span></span><br><span class="line">[master 1094adb] append GPL</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><p>现在，我们回顾一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p><p>版本1：wrote a readme file</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本2：add distributed</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本3：append GPL</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。 </p><h5 id="3-2-进行版本回退"><a href="#3-2-进行版本回退" class="headerlink" title="3.2 进行版本回退"></a>3.2 进行版本回退</h5><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD^</span></span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> readme.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>果然被还原了。</p><p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，让我们用<code>git log</code>再看看现在版本库的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard 1094a</span></span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>再小心翼翼地看看<code>readme.txt</code>的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> readme.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>果然，我胡汉三又回来了。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──&gt; ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>改为指向<code>add distributed</code>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──&gt; ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reflog</span></span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p><p><strong>小结</strong></p><p>现在总结一下：</p><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><h4 id="3-3-工作区和暂存区"><a href="#3-3-工作区和暂存区" class="headerlink" title="3.3 工作区和暂存区"></a>3.3 工作区和暂存区</h4><h5 id="3-3-1-工作区"><a href="#3-3-1-工作区" class="headerlink" title="3.3.1 工作区"></a>3.3.1 工作区</h5><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区。</p><h5 id="3-3-2-版本库（Repository）"><a href="#3-3-2-版本库（Repository）" class="headerlink" title="3.3.2 版本库（Repository）"></a>3.3.2 版本库（Repository）</h5><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage(或者叫index)的暂存区</strong>，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="https://pic.imgdb.cn/item/61e67be02ab3f51d91087ff2.jpg" alt="Git指针关系"></p><p>分支和<code>HEAD</code>的概念我们以后再讲。</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><ol><li>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</li><li>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li></ol><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></table></figure><p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p><p>先用<code>git status</code>查看一下状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p><p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   LICENSE</span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>现在，暂存区的状态就变成这样了：</p><p><img src="https://pic.imgdb.cn/item/61e67c9b2ab3f51d91095d39.jpg" alt="当前暂存区"></p><p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;understand how stage works&quot;</span></span></span><br><span class="line">[master e43a48b] understand how stage works</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></table></figure><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>现在版本库变成了这样，暂存区就没有任何内容了：</p><p><img src="https://pic.imgdb.cn/item/61e67d0c2ab3f51d9109f1d7.jpg" alt="当前库内情况"></p><p><strong>小结</strong>：暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</p><h4 id="3-4-管理修改"><a href="#3-4-管理修改" class="headerlink" title="3.4 管理修改"></a>3.4 管理修改</h4><p>现在，假定你已经完全掌握了暂存区的概念。下面要讨论的是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p><p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p><p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，修改readme.txt，比如加一行内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> readme.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes.</span><br></pre></td></tr></table></figure><p>然后，添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add readme.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On branch master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Changes to be committed:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment">#       modified:   readme.txt</span></span></span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure><p>然后，再修改readme.txt：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> readme.txt</span> </span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;git tracks changes&quot;</span></span></span><br><span class="line">[master 519219b] git tracks changes</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>提交后，再看看状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>咦，怎么第二次的修改没有被提交？别激动，我们回顾一下操作过程：</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff HEAD -- readme.txt</span> </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 76d770f..a9c5755 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,4 +1,4 @@</span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>可见，第二次修改确实没有被提交。</p><p>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p><p>好，现在，把第二次修改提交了，然后开始小结。</p><p><strong>小结</strong>：现在，理解了Git是如何跟踪修改的，每次修改，若不用<code>git add</code>到暂存区，那就不会加到<code>commit</code>中。</p><h4 id="3-5-撤销修改"><a href="#3-5-撤销修改" class="headerlink" title="3.5 撤销修改"></a>3.5 撤销修改</h4><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> readme.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure><p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- readme.txt</span></span><br></pre></td></tr></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><ul><li>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ul><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>现在，看看<code>readme.txt</code>的文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> readme.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>文件内容果然复原了。</p><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> readme.txt</span></span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add readme.txt</span></span><br></pre></td></tr></table></figure><p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD readme.txt</span></span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">Mreadme.txt</span><br></pre></td></tr></table></figure><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>还记得如何丢弃工作区的修改吗？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- readme.txt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>整个世界终于清静了！</p><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把<code>stupid boss</code>提交推送到远程版本库，你就真的惨了……</p><p><strong>小结</strong></p><ul><li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</li><li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li><li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</li></ul><h4 id="3-6-删除文件"><a href="#3-6-删除文件" class="headerlink" title="3.6 删除文件"></a>3.6 删除文件</h4><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add test.txt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;add test.txt&quot;</span></span></span><br><span class="line">[master b84166e] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br></pre></td></tr></table></figure><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> test.txt</span></span><br></pre></td></tr></table></figure><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> test.txt</span></span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;remove test.txt&quot;</span></span></span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure><p>现在，文件就从版本库中被删除了。</p><p>小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。 </p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- test.txt</span></span><br></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p> 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ </p><p><strong>小结</strong></p><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><h3 id="四、远程仓库"><a href="#四、远程仓库" class="headerlink" title="四、远程仓库"></a>四、远程仓库</h3><h4 id="1-什么是远程库"><a href="#1-什么是远程库" class="headerlink" title="1. 什么是远程库"></a>1. 什么是远程库</h4><p>到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。</p><p>可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。</p><p>没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：<font color=red><strong>远程仓库</strong></font>。</p><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p><p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p><p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p><p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p><p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p><p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过<font color=red><strong>SSH加密的</strong></font>，所以需要一点设置：</p><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面。</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容。</p><p>点“Add Key”，你就应该看到已经添加的Key。</p><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p><p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p><p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p><p><strong>小结</strong></p><p>“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机</p><h4 id="2-添加远程库"><a href="#2-添加远程库" class="headerlink" title="2. 添加远程库"></a>2. 添加远程库</h4><h5 id="2-1创建并关联远程库"><a href="#2-1创建并关联远程库" class="headerlink" title="2.1创建并关联远程库"></a>2.1创建并关联远程库</h5><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库。</p><p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。</p><p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure><p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.</span><br><span class="line">Total 20 (delta 5), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样 。</p><p>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h5 id="2-2-SSH警告"><a href="#2-2-SSH警告" class="headerlink" title="2.2 SSH警告"></a>2.2 SSH警告</h5><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &#x27;github.com&#x27; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p><h5 id="2-3删除远程库"><a href="#2-3删除远程库" class="headerlink" title="2.3删除远程库"></a>2.3删除远程库</h5><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learn-git.git (push)</span><br></pre></td></tr></table></figure><p>然后，根据名字删除，比如删除<code>origin</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm origin</span><br></pre></td></tr></table></figure><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><p><strong>小结</strong></p><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p><h4 id="3-远程库克隆"><a href="#3-远程库克隆" class="headerlink" title="3. 远程库克隆"></a>3. 远程库克隆</h4><p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p><p>现在，假设<font color=red><strong>我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆</strong>。</font></p><p>首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code> 。</p><p>我们勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件。</p><p>现在，远程库已经准备好了，下一步是用命令<code>git clone</code>克隆一个本地库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/gitskills.git</span><br><span class="line">Cloning into &#x27;gitskills&#x27;...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3</span><br><span class="line">Receiving objects: 100% (3/3), done.</span><br></pre></td></tr></table></figure><p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有<code>README.md</code>文件了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd gitskills</span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p><p>你也许还注意到，GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p><p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p><p><strong>小结</strong></p><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p><p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p><h3 id="五、分支管理"><a href="#五、分支管理" class="headerlink" title="五、分支管理"></a>五、分支管理</h3><h4 id="1-分支管理的概念"><a href="#1-分支管理的概念" class="headerlink" title="1. 分支管理的概念"></a>1. 分支管理的概念</h4><p>分支就是科幻电影里的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p><p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p><p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p><h4 id="2-创建与合并分支"><a href="#2-创建与合并分支" class="headerlink" title="2. 创建与合并分支"></a>2. 创建与合并分支</h4><h5 id="2-1-分支概念与实践"><a href="#2-1-分支概念与实践" class="headerlink" title="2.1 分支概念与实践"></a>2.1 分支概念与实践</h5><p>在<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p><p><img src="https://pic.imgdb.cn/item/61e696dd2ab3f51d91240513.jpg" alt=""></p><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><p><img src="https://pic.imgdb.cn/item/61e696fd2ab3f51d91242093.jpg" alt=""></p><p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p><img src="https://pic.imgdb.cn/item/61e697152ab3f51d912435f0.jpg" alt=""></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并： </p><p><img src="https://pic.imgdb.cn/item/61e697332ab3f51d91245144.jpg" alt=""></p><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><p><img src="https://pic.imgdb.cn/item/61e697492ab3f51d912464db.jpg" alt=""></p><p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p><p>下面开始实战。</p><p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p>然后，用<code>git branch</code>命令查看当前分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick.</span><br></pre></td></tr></table></figure><p>然后提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;branch test&quot;</span><br><span class="line">[dev b17d20e] branch test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure><p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p><p><img src="https://pic.imgdb.cn/item/61e697672ab3f51d91248608.jpg" alt=""></p><p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure><p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p><h5 id="2-2-switch"><a href="#2-2-switch" class="headerlink" title="2.2 switch"></a>2.2 switch</h5><p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p><p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p><p>创建并切换到新的<code>dev</code>分支，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure><p>直接切换到已有的<code>master</code>分支，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch master</span><br></pre></td></tr></table></figure><p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p><p><strong>小结</strong></p><p>Git鼓励大量使用分支：</p><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h4 id="3-解决冲突"><a href="#3-解决冲突" class="headerlink" title="3. 解决冲突"></a>3. 解决冲突</h4><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p><p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c feature1</span><br><span class="line">Switched to a new branch &#x27;feature1&#x27;</span><br></pre></td></tr></table></figure><p>修改<code>readme.txt</code>最后一行，改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick AND simple.</span><br></pre></td></tr></table></figure><p>在<code>feature1</code>分支上提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;AND simple&quot;</span><br><span class="line">[feature1 14096d0] AND simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>切换到<code>master</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br></pre></td></tr></table></figure><p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p><p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick &amp; simple.</span><br></pre></td></tr></table></figure><p>提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;&amp; simple&quot;</span><br><span class="line">[master 5dc6824] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><p><img src="https://pic.imgdb.cn/item/61e69e7a2ab3f51d912a6360.jpg" alt=""></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 2 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>我们可以直接查看readme.txt的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a new branch is quick and simple.</span><br></pre></td></tr></table></figure><p>再提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;conflict fixed&quot;</span><br><span class="line">[master cf810e4] conflict fixed</span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p><img src="https://pic.imgdb.cn/item/61e69ea22ab3f51d912a838f.jpg" alt=""></p><p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   cf810e4 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\  </span><br><span class="line">| * 14096d0 (feature1) AND simple</span><br><span class="line">* | 5dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e add test.txt</span><br><span class="line">* 519219b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* 1094adb append GPL</span><br><span class="line">* e475afc add distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>最后，删除<code>feature1</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 14096d0).</span><br></pre></td></tr></table></figure><p>工作完成。</p><p><strong>小结</strong></p><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><h4 id="4-分支管理策略"><a href="#4-分支管理策略" class="headerlink" title="4. 分支管理策略"></a>4. 分支管理策略</h4><h5 id="4-1-分支管理"><a href="#4-1-分支管理" class="headerlink" title="4.1 分支管理"></a>4.1 分支管理</h5><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p><p>首先，仍然创建并切换<code>dev</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p>修改readme.txt文件，并提交一个新的commit：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;add merge&quot;</span><br><span class="line">[dev f52c633] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>现在，我们切换回<code>master</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://pic.imgdb.cn/item/61e69fbd2ab3f51d912b56e2.jpg" alt=""></p><h5 id="4-2-分支策略"><a href="#4-2-分支策略" class="headerlink" title="4.2 分支策略"></a>4.2 分支策略</h5><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://pic.imgdb.cn/item/61e69fd92ab3f51d912b6b96.jpg" alt=""></p><p><strong>小结</strong></p><p>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h4 id="5-Bug分支"><a href="#5-Bug分支" class="headerlink" title="5. Bug分支"></a>5. Bug分支</h4><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch &#x27;issue-101&#x27;</span><br></pre></td></tr></table></figure><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;fix bug 101&quot;</span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git switch dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p><p>那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？</p><p>有木有更简单的方法？</p><p>有！</p><p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p><p>有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p><p><strong>小结</strong></p><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p><h4 id="6-Feature分支"><a href="#6-Feature分支" class="headerlink" title="6. Feature分支"></a>6. Feature分支</h4><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c feature-vulcan</span><br><span class="line">Switched to a new branch &#x27;feature-vulcan&#x27;</span><br></pre></td></tr></table></figure><p>5分钟后，开发完毕：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">new file:   vulcan.py</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure><p>切回<code>dev</code>，准备合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch dev</span><br></pre></td></tr></table></figure><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p>但是！</p><p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p><p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch &#x27;feature-vulcan&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D feature-vulcan&#x27;.</span><br></pre></td></tr></table></figure><p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p><p>现在我们强行删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 287773e).</span><br></pre></td></tr></table></figure><p>终于删除成功！</p><p><strong>小结</strong></p><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h3 id="六、多人协作"><a href="#六、多人协作" class="headerlink" title="六、多人协作"></a>六、多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>要查看远程库的信息，用<code>git remote</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h4 id="1-推送分支"><a href="#1-推送分支" class="headerlink" title="1. 推送分支"></a>1. 推送分支</h4><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h4 id="2-抓取分支"><a href="#2-抓取分支" class="headerlink" title="2. 抓取分支"></a>2. 抓取分支</h4><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into &#x27;learngit&#x27;...</span><br><span class="line">remote: Counting objects: 40, done.</span><br><span class="line">remote: Compressing objects: 100% (21/21), done.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40/40), done.</span><br><span class="line">Resolving deltas: 100% (14/14), done.</span><br></pre></td></tr></table></figure><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add env&quot;</span><br><span class="line">[dev 7a5e5dd] add env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add new env&quot;</span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure><p>再pull：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add/add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344">解决冲突</a>完全一样。解决后，提交，再push：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;fix env conflict&quot;</span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4/4), done.</span><br><span class="line">Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><p><strong>小结</strong></p><ul><li>查看远程库信息，使用<code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li><li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li></ul><h3 id="七、Rebase"><a href="#七、Rebase" class="headerlink" title="七、Rebase"></a>七、Rebase</h3><p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p><p>每次合并再push后，分支变成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure><p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p><p>其实是可以做到的！</p><p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p><p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p><p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 582d922 (HEAD -&gt; master) add author</span><br><span class="line">* 8875536 add comment</span><br><span class="line">* d1be385 (origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的HEAD和远程origin的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p><p>现在我们尝试推送本地分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure><p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (1/1), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From github.com:michaelliao/learngit</span><br><span class="line">   d1be385..f005ed4  master     -&gt; origin/master</span><br><span class="line"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> hello.py | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>再用<code>git status</code>看看状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 3 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p><p>用<code>git log</code>看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch &#x27;master&#x27; of github.com:michaelliao/learngit</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) set exit=1</span><br><span class="line">* | 582d922 add author</span><br><span class="line">* | 8875536 add comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？</p><p>有！</p><p>什么问题？</p><p>不好看！</p><p>有没有解决方法？</p><p>有！</p><p>这个时候，rebase就派上了用场。我们输入命令<code>git rebase</code>试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add comment</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: add author</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure><p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin/master) set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p><p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p><p>最后，通过push操作把本地分支推送到远程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Mac:~/learngit michael$ git push origin master</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 1 local object.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line">   f005ed4..7e61ed4  master -&gt; master</span><br></pre></td></tr></table></figure><p>再用<code>git log</code>看看效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 set exit=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>远程分支的提交历史也是一条直线。</p><p><strong>小结</strong></p><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul><h3 id="八、标签管理"><a href="#八、标签管理" class="headerlink" title="八、标签管理"></a>八、标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git有commit，为什么还要引入tag？</p><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><p>“好的，按照tag v1.2查找commit就行！”</p><p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h4 id="1-创建标签"><a href="#1-创建标签" class="headerlink" title="1. 创建标签"></a>1. 创建标签</h4><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure><p>再用命令<code>git tag</code>查看标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 </p><p><strong>小结</strong></p><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><h4 id="2-操作标签"><a href="#2-操作标签" class="headerlink" title="2. 操作标签"></a>2. 操作标签</h4><p>如果标签打错了，也可以删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag &#x27;v0.1&#x27; (was f15b0dd)</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &#x27;v0.9&#x27; (was f52c633)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><p><strong>小结</strong></p><ul><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li></ul><h3 id="九、Github"><a href="#九、Github" class="headerlink" title="九、Github"></a>九、Github</h3><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。</p><p>但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap">https://github.com/twbs/bootstrap</a>，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/bootstrap.git</span><br></pre></td></tr></table></figure><p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p><p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─ GitHub ────────────────────────────────────┐</span><br><span class="line">│                                             │</span><br><span class="line">│ ┌─────────────────┐     ┌─────────────────┐ │</span><br><span class="line">│ │ twbs/bootstrap  │────&gt;│  my/bootstrap   │ │</span><br><span class="line">│ └─────────────────┘     └─────────────────┘ │</span><br><span class="line">│                                  ▲          │</span><br><span class="line">└──────────────────────────────────┼──────────┘</span><br><span class="line">                                   ▼</span><br><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ local/bootstrap │</span><br><span class="line">                          └─────────────────┘</span><br></pre></td></tr></table></figure><p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p><p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p><p>如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：<a href="https://github.com/michaelliao/learngit">https://github.com/michaelliao/learngit</a>，创建一个<code>your-github-id.txt</code>的文本文件，写点自己学习Git的心得，然后推送一个pull request给我，我会视心情而定是否接受。</p><p><strong>小结</strong></p><ul><li>在GitHub上，可以任意Fork开源仓库；</li><li>自己拥有Fork后的仓库的读写权限；</li><li>可以推送pull request给官方仓库来贡献代码。</li></ul><h3 id="十、使用Gitee"><a href="#十、使用Gitee" class="headerlink" title="十、使用Gitee"></a>十、使用Gitee</h3><p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。</p><p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——<a href="https://gitee.com?utm_source=blog_lxf">Gitee</a>（<a href="https://gitee.com?utm_source=blog_lxf">gitee.com</a>）。</p><p>和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p><p> Gitee的免费版本也提供私有库功能，只是有5人的成员上限。 </p><p>使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的<code>.ssh/id_rsa.pub</code>文件的内容粘贴进去，点击“确定”即可完成并看到刚才添加的Key。</p><p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？</p><p>首先，我们在Gitee上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”。</p><p>项目名称最好与本地库保持一致：</p><p>然后，我们在本地库上使用命令<code>git remote add</code>把它和Gitee的远程库关联：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>之后，就可以正常地用<code>git push</code>和<code>git pull</code>推送了！</p><p>如果在使用命令<code>git remote add</code>时报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure><p>这说明本地库已经关联了一个名叫<code>origin</code>的远程库，此时，可以先用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origingit@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origingit@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>可以看到，本地库已经关联了<code>origin</code>的远程库，并且，该远程库指向GitHub。</p><p>我们可以删除已有的GitHub远程库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>再关联Gitee的远程库（注意路径中需要填写正确的用户名）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>此时，我们再查看远程库信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origingit@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">origingit@gitee.com:liaoxuefeng/learngit.git (push)</span><br></pre></td></tr></table></figure><p>现在可以看到，origin已经被关联到Gitee的远程库了。通过<code>git push</code>命令就可以把本地库推送到Gitee上。</p><p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联Gitee呢？</p><p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p><p>使用多个远程库时，我们要注意，git给远程库起的默认名称是<code>origin</code>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p><p>仍然以<code>learngit</code>本地库为例，我们先删除已关联的名为<code>origin</code>的远程库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>然后，先关联GitHub的远程库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure><p>注意，远程库的名称叫<code>github</code>，不叫<code>origin</code>了。</p><p>接着，再关联Gitee的远程库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>同样注意，远程库的名称叫<code>gitee</code>，不叫<code>origin</code>。</p><p>现在，我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">giteegit@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">giteegit@gitee.com:liaoxuefeng/learngit.git (push)</span><br><span class="line">githubgit@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">githubgit@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>如果要推送到GitHub，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure><p>如果要推送到Gitee，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push gitee master</span><br></pre></td></tr></table></figure><p>这样一来，我们的本地库就可以同时与多个远程库互相同步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────┐ ┌─────────┐</span><br><span class="line">│ GitHub  │ │  Gitee  │</span><br><span class="line">└─────────┘ └─────────┘</span><br><span class="line">     ▲           ▲</span><br><span class="line">     └─────┬─────┘</span><br><span class="line">           │</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ Local Repo  │</span><br><span class="line">    └─────────────┘</span><br></pre></td></tr></table></figure><p>Gitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：<a href="https://gitee.com/liaoxuefeng/learngit?utm_source=blog_lxf">https://gitee.com/liaoxuefeng/learngit</a>，创建一个<code>your-gitee-id.txt</code>的文本文件， 写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在Gitee和GitHub做双向同步。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>本博客主要内容转自廖雪峰大神的Git学习版块，原文链接：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰Git学习</a><br>如果涉嫌侵权，著作权人可以联系我，我会立即删除。 </p>]]></content>
      
      
      <categories>
          
          <category> 计算机与编程学习 </category>
          
          <category> 相关技术 </category>
          
          <category> Git学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建历程</title>
      <link href="/2022/01/18/My-first-hexo-bolg-building/"/>
      <url>/2022/01/18/My-first-hexo-bolg-building/</url>
      
        <content type="html"><![CDATA[<h3 id="〇-简要介绍"><a href="#〇-简要介绍" class="headerlink" title="〇. 简要介绍"></a>〇. 简要介绍</h3><p>本博客的搭建不需要什么技术，而且自己截止到当前时间对Git和Github的使用也刚学，所以只是参考网上博客和B站的教学视频来做的。</p><h3 id="一-部署Github-Pages"><a href="#一-部署Github-Pages" class="headerlink" title="一. 部署Github Pages"></a>一. 部署Github Pages</h3><p>在自己的Github上创建一个新的<strong>Repositories</strong>，注意命名规则是——Github账号名.github.io。</p><h3 id="二-安装Hexo"><a href="#二-安装Hexo" class="headerlink" title="二. 安装Hexo"></a>二. 安装Hexo</h3><h4 id="1-插入注解"><a href="#1-插入注解" class="headerlink" title="1. 插入注解"></a>1. 插入注解</h4><h5 id="1-常见的博客搭建方法"><a href="#1-常见的博客搭建方法" class="headerlink" title="(1) 常见的博客搭建方法"></a>(1) 常见的博客搭建方法</h5><p>据我目前所知，搭建博客总体上分有两种方法：</p><ul><li>第三方平台：在现有的博客网站、论坛或社区上注册个人主页。如知乎，掘金，简书，segmentFault，csdn，博客园等。特点：无技术门槛，可专注于内容。</li><li>静态网站生成技术：在终端执行命令快速生成静态网站，如 Jekyll、Hugo、Hexo等。然后通过 Github Pages、Coding 等展示。特点：通过插件可增加评论、搜索、分析等功能。有多种主题可选。在本地以特定格式书写文章，放置在指定的文件夹。每次发布或修改文章都需要重新生成和部署网站。</li><li>其他：<a href="https://juejin.cn/post/6951679886557708302">参考链接-如何搭建个人博客 ：几种方案比较 + 个人实现</a> </li></ul><h5 id="2-静态网站生成技术比较"><a href="#2-静态网站生成技术比较" class="headerlink" title="(2) 静态网站生成技术比较"></a>(2) 静态网站生成技术比较</h5><p>在该方法当中，也与许多可供选择的方案，像 Jekyll、Hugo、Hexo、Typecho、Wordpress等等，那么它们各有什么优缺点呢，这里我就不说了(不是我的重点)，请参考链接：<a href="https://blog.laoda.de/archives/blog-choosing">Hexo还是Hugo？Typecho还是Wordpress？读完这篇或许你就有答案了！</a></p><h4 id="2-安装相应软件"><a href="#2-安装相应软件" class="headerlink" title="2. 安装相应软件"></a>2. 安装相应软件</h4><h5 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="(1) 安装Node.js"></a>(1) 安装Node.js</h5><p><a href="https://nodejs.org/zh-cn/">Node.js的官方网站</a>，下载好了之后直接安装，安装过程中会出现</p><p><img src="https://pic.imgdb.cn/item/61e64e022ab3f51d91dc2599.png" alt="&lt;font color=red&gt;图1&lt;/font&gt;  Node安装"></p><p>要点第四个，添加到Path(环境变量)。</p><h5 id="2-Git安装"><a href="#2-Git安装" class="headerlink" title="(2) Git安装"></a>(2) Git安装</h5><p>Git的安装则是傻瓜式安装即可，虽然步骤多，但是按照默认的来就行；</p><p>好的，现在已经全部准备完毕，下面简单测试一下看看是否安装成功。</p><h5 id="3-测试"><a href="#3-测试" class="headerlink" title="(3) 测试"></a>(3) 测试</h5><p> 为了验证我们的Node.js和Git是否安装完毕，可以在CMD（win+R，输入“cmd”即可打开）中输入两条命令查看： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">git version</span><br></pre></td></tr></table></figure><p>若两条命令没有报错，而且显示了版本号，则安装成功！</p><h4 id="3-Hexo本地化"><a href="#3-Hexo本地化" class="headerlink" title="3. Hexo本地化"></a>3. Hexo本地化</h4><h5 id="1-创建新文件夹"><a href="#1-创建新文件夹" class="headerlink" title="(1) 创建新文件夹"></a>(1) 创建新文件夹</h5><p>这个新文件夹在之后会保存Hexo的文件以及你的博客相关内容，十分重要，我是建立在E盘下新文件夹I.myBlog。</p><h5 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="(2) 安装Hexo"></a>(2) 安装Hexo</h5><p>打开Windows中使用cmd命令打开命令行，然后更改命令行目录到上一步创建的新文件夹中，然后执行下面的命令安装Hexo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>注意安装过程中网络不要断开，安装完成后文件夹还是一个空的状态，下一步要初始化。</p><h5 id="3-初始化Hexo"><a href="#3-初始化Hexo" class="headerlink" title="(3) 初始化Hexo"></a>(3) 初始化Hexo</h5><p> 执行以下代码完成初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>这时候文件夹就出现了新文件，不再是空的，文件主要有以下几种：</p><ul><li>.deploty_git：上传到Github的最终文件，如果不使用Git，则不会生成</li><li>.github：一个神秘文件夹</li><li>node_modules：一个神秘文件夹</li><li>public：上传到Github的最终文件，不安装Git时可以使用这种方法直接部署</li><li>scaffolds：存放创建新文章时的模板文件</li><li>theme：主题存放文件夹</li><li>post：博客文章存放的地方</li></ul><h3 id="三-基础配置与指令"><a href="#三-基础配置与指令" class="headerlink" title="三. 基础配置与指令"></a>三. 基础配置与指令</h3><h4 id="1-主题配置-美化"><a href="#1-主题配置-美化" class="headerlink" title="1. 主题配置(美化)"></a>1. 主题配置(美化)</h4><p>进入博客文件夹根目录，打开<strong>_config.yml</strong>文件，然后自行进行修改。</p><p><img src="https://pic.imgdb.cn/item/61e64e022ab3f51d91dc258c.png" alt="&lt;font color=red&gt; 图2&lt;/font&gt;  _config文件截图示意"></p><p>这里是一些基本的，比如说你的网站名（第六行）、描述（第八行）、作者（第十行）、语言（第十一行）等都可以进行自主修改。</p><p><img src="https://pic.imgdb.cn/item/61e64e022ab3f51d91dc25a2.png" alt="&lt;font color=red&gt; 图3&lt;/font&gt;  url修改"></p><p>如图3所示，这里url的修改十分重要，一定要记得修改。要改成你将来要部署的网站！！！比如你要用GitHub Pages部署，就必须是那一节你部署过的网站链接！！！ </p><p><img src="https://pic.imgdb.cn/item/61e64e022ab3f51d91dc2594.png" alt="&lt;font color=red&gt; 图4&lt;/font&gt;  git链接修改"></p><p><strong><font color=red>注意，下面这几处修改十分重要！！！</font></strong></p><ul><li>第100行的主题名改为之前让你复制的那个文件夹名(记得空格，在你没有下载新主题之前不用管，默认即可)；</li><li>第105行“type”后面填写“git”；</li><li>第106行加上“repo”，然后加上链接——不是GitHub Pages的链接，是GitHub Pages的库的链接！！</li></ul><blockquote><p>注意：这里由于Github在2021年进行了一次更新，应该是不能再使用https协议了，转而应该示意SSH，但是我这里使用了https好像也没什么问题，其实我自己现在对Git、GitHub的使用也还是模模糊糊，对一些操作、概念(如：密钥、公钥、令牌等)不明白，所以也就是稀里糊涂，后面我还要仔细学习学习Git的知识，如果你的使用https不行，建议参考链接进行设置——<a href="https://vabzjaby.github.io/2021/10/05/pwh/#%E7%AC%AC%E5%9B%9B%E6%AD%A5-%E7%BC%96%E8%BE%91">如何在手机端搭建并部署Hexo - 听话的便当 - 个人博客</a></p></blockquote><ul><li>第107行加上“branch”，名字起main。注意，这里与Github在2021年进行了一次更新有关，之前应该是填写master，现在填写main即可；</li></ul><p>完成这些后，可以再次用<code>hexo s</code>这个指令查看预览，发现已经更新主题了。</p><h4 id="2-Hexo的常用命令"><a href="#2-Hexo的常用命令" class="headerlink" title="2. Hexo的常用命令"></a>2. Hexo的常用命令</h4><ul><li><code>hexo s</code>：在本地演示网站</li><li><code>hexo g</code>：在本地渲染静态页面(就是将md转换为html)</li><li><code>hexo d</code>：把静态页面一键上传到Github Pages</li><li><code>hexo new</code>：<ul><li><code>标题</code>(直接加标题则是在source/_posts文件夹生成—个”标题.md”文件作为文章，建议生成新文章和页面时最好用阿拉伯数字或者英文，这样链接不会很长)</li><li><code>page+标题</code>(标题前加page则是生成一个新页面，hexo刚开始只有默认的首页和归档页，创建其他页面，例如标签、关于等页面都需要此指令生成)</li><li><code>post+标题</code>(在\_config.yml中将post_asset_folder设为true之后hexo new post “first-page”之后新建了一篇文章，就会同时在hexo/source/_post文件夹下生成一个.md文件和一个同名文件夹，文件夹存放文章中的图片)</li></ul></li><li><code>hexo clean</code>：清理已有的静态页面(不是删干净重来)</li></ul><h4 id="3-示例配置过程"><a href="#3-示例配置过程" class="headerlink" title="3. 示例配置过程"></a>3. 示例配置过程</h4><p>在执行<code>hexo init</code>之后，可以再执行<code>hexg g</code> 在本地渲染页面，完成后文件夹中会出现<strong>public</strong>文件夹。然后再执行<code>hexo new ts</code> 这时在source文件夹下会生成_post文件夹，里面有hello-world.md(默认自带)和ts.md(代码新生成的)，然后我们可以在ts.md中写一些东西，就是日后的博客文章。还可以使用命令<code>hexo new page about</code> 生成一个新的about文件夹，里面有index.md，可以写一些介绍自己的内容。</p><p>弄好上面的之后，我们可以执行命令<code>hexo s</code> 在本地演示网站，此时cmd窗口会生成一个<a href="http://localhost:4000">http://localhost:4000</a> 的链接，我们在浏览器打开就可以看到渲染的博客页面了。</p><h4 id="4-主题的美化"><a href="#4-主题的美化" class="headerlink" title="4. 主题的美化"></a>4. 主题的美化</h4><p>主要是利用<strong>根目录下的_config.yml文件</strong>和<strong>themes文件夹下某一主题文件夹下的_config.yml</strong>进行修改美化页面，可以自己进行探索。</p><h5 id="1-关于主题的设置"><a href="#1-关于主题的设置" class="headerlink" title="(1) 关于主题的设置"></a>(1) 关于主题的设置</h5><ul><li>存放位置：/themes/主题名/\_config.yml(注意：有别于根目录下的_config.yml文件)<ul><li>这里需要说明的是：Hexo在渲染静态页面时，themes文件夹的\_config.yml文件优先度比根目录的_config.yml高</li></ul></li><li>修改方式：大部分为布尔值(只需要修改true或者false即可)，支持中文的主题大部分会有注释<ul><li>这里推荐Hexo的Next与Ayer主题，两者有很清晰明了的中文，页面也很清爽(我的主题是Ayer)</li></ul></li><li>添加自定义js的方式：在/themes/主题名/layout/layout.ejs中添加<ul><li>该方法是我在用Next主题时发现的，当时成功了，是后来Ayer主题失败了，还是要按照不同的主题来</li></ul></li></ul><p>完成配置后，可以使用<code>hexok s</code> 在本地演示网站看一下配置情况。</p><h5 id="2-Markdown语法学习"><a href="#2-Markdown语法学习" class="headerlink" title="(2) Markdown语法学习"></a>(2) Markdown语法学习</h5><p>自己学习，这里不讲。</p><h3 id="四-部署与上传"><a href="#四-部署与上传" class="headerlink" title="四. 部署与上传"></a>四. 部署与上传</h3><p>在进行完这一步之后，就可以真正意义上有一个可以在浏览器打开的自己的博客网站！！！</p><p>正常情况下，在cmd输入指令<code>npm install hexo-deployer-git --save</code> 之后指令<code>hexo g -d</code> 理论上就可以成功将博客文件上传到Github上了，然后在GitHub网页的settings页面下找到pages，就可以找到对应的网址，打开即可看到自己的博客。<br>但是，由于Github服务器在国外，所以经常出现网络问题，需要搭梯子，下面是失败情况下的一些处理方法。</p><ul><li>失败则输入指令<code>git config --global credential.helper wincred</code></li><li>再次失败，错误原因是spawn的话就是网络有些问题，重启cmd试试</li><li>还是失败的话可能是电脑上装了两个hexo</li><li>最终还是失败的话可以使用指令<code>hexo g</code>，然后直接在网页端的GitHub上传public文件夹。</li></ul><h3 id="五-相关链接"><a href="#五-相关链接" class="headerlink" title="五. 相关链接"></a>五. 相关链接</h3><h4 id="1-帮助文档链接"><a href="#1-帮助文档链接" class="headerlink" title="1. 帮助文档链接"></a>1. 帮助文档链接</h4><p>在自己搭建第一个博客中出现了很多问题，有许多博客、视频帮助了我，贴在下面可以可看一下。</p><p>听话的便当的B站视频：<a href="https://space.bilibili.com/435364951/channel/seriesdetail?sid=812995">听话的_便当的个人空间_哔哩哔哩_bilibili</a> </p><p>听话的便当的博客：<a href="https://byn6.github.io/2021/08/29/gp-h/">https://byn6.github.io/2021/08/29/gp-h/</a></p><p>Ayer中文官方文档： <a href="https://shen-yu.gitee.io/2019/ayer">https://shen-yu.gitee.io/2019/ayer</a></p><p>Hexo官方文档：<a href="https://hexo.io/zh-cn/docs/asset-folders.html">https://hexo.io/zh-cn/docs/asset-folders.html</a></p><p>Hexo常用命令详解及使用方法：<a href="https://www.mabiji.com/hexo/hexocommands.html">https://www.mabiji.com/hexo/hexocommands.html</a></p><p>Hexo为文章设置目录与标签的方法：<a href="https://blog.csdn.net/weixin_44543463/article/details/119738094">https://blog.csdn.net/weixin_44543463/article/details/119738094</a></p><p>[hexo]如何更换主题、删除文章：<a href="https://www.cnblogs.com/mrwuzs/p/7942689.html">https://www.cnblogs.com/mrwuzs/p/7942689.html</a></p><p>hexo搭建博客后图片无法显示的完美解决：<a href="https://blog.csdn.net/weixin_43702620/article/details/118655308">https://blog.csdn.net/weixin_43702620/article/details/118655308</a></p><p>不会git就学不会github吗？：<a href="https://www.zhihu.com/question/29566172">https://www.zhihu.com/question/29566172</a></p><p>git是干什么的？ sourcetree是干什么的？：<a href="https://www.zhihu.com/question/48322958">https://www.zhihu.com/question/48322958</a></p><p>SourceTree的基本使用教程：<a href="https://blog.csdn.net/qq_34129814/article/details/82847753">https://blog.csdn.net/qq_34129814/article/details/82847753</a></p><p>Hexo server报错TypeError: Cannot read property ‘utcOffset’ of null解决方法：<a href="http://t.zoukankan.com/mmzuo-798-p-10510225.html">http://t.zoukankan.com/mmzuo-798-p-10510225.html</a></p><p>免费图床，看这一篇就够了！：<a href="https://www.duangvps.com/archives/1737">https://www.duangvps.com/archives/1737</a></p><h4 id="2-数学公式解决方法"><a href="#2-数学公式解决方法" class="headerlink" title="2. 数学公式解决方法"></a>2. 数学公式解决方法</h4><p>如何在Hexo中插入数学公式 <a href="https://qingstudios.com/2020/03/01/Hexo%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">https://qingstudios.com/2020/03/01/Hexo%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</a></p><p>MathJax在Hexo博客中插入数学公式：<a href="https://blog.csdn.net/weixin_39789979/article/details/110806006">https://blog.csdn.net/weixin_39789979/article/details/110806006</a></p><p>markdown斜体和数学公式的矛盾：<a href="https://blog.moper.net/2640.html">https://blog.moper.net/2640.html</a></p><p>hexo博客MathJax公式渲染问题：<a href="https://www.cnblogs.com/Ai-heng/p/7282110.htm">https://www.cnblogs.com/Ai-heng/p/7282110.htm</a></p><p>hexo 如何解决markdown下划线要加反斜杠，以及如何使用其他markdown的渲染引擎？：<a href="https://segmentfault.com/q/1010000003987383">https://segmentfault.com/q/1010000003987383</a></p><h4 id="3-优秀博客示例"><a href="#3-优秀博客示例" class="headerlink" title="3. 优秀博客示例"></a>3. 优秀博客示例</h4><p>二十五画生 <a href="https://blog.laoda.de">https://blog.laoda.de</a></p>]]></content>
      
      
      <categories>
          
          <category> 我的生活记录 </category>
          
          <category> 爱好与提升 </category>
          
          <category> HEXO博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h5 id="关于博主"><a href="#关于博主" class="headerlink" title="关于博主"></a>关于博主</h5><p>本科学生，致力于学习、生活休闲</p><h5 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h5><p>邮箱：junhengwangrizhao@gmail.com</p><p>地址：山东省日照市莒县</p><h5 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h5><p>我用它做些什么<br>记录学习和生活中的遇到的问题，怕以后忘掉了，不舍得自己掏钱买主机和域名，就在用了Hexo，所以不用问我技术方面的事情，我不懂;<br>或者，只是一个摆设。</p>]]></content>
      
    </entry>
    
    
  
</search>
