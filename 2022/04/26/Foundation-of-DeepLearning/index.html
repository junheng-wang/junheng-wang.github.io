<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="���͡�ѧϰ�����˼�������С�����" />
       
      <meta name="description" content="���˺�����" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>深度学习_吴恩达_Part_1 |  Wang Junheng</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Foundation-of-DeepLearning"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  深度学习_吴恩达_Part_1
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/04/26/Foundation-of-DeepLearning/" class="article-date">
  <time datetime="2022-04-26T04:11:17.000Z" itemprop="datePublished">2022-04-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E6%8F%90%E5%8D%87/">学习提升</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E6%8F%90%E5%8D%87/%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">编程与深度学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E6%8F%90%E5%8D%87/%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/">深度学习基础</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">18k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">72 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="1-0-深度学习发展历史"><a href="#1-0-深度学习发展历史" class="headerlink" title="1.0 深度学习发展历史"></a>1.0 深度学习发展历史</h4><p><img src="https://pic.imgdb.cn/item/6267f189239250f7c59f6a42.png"></p>
<p>本小节参考链接：<br>参考链接1.1：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29096536">深度学习(deep learning)发展史 - 极海·GeoHey的文章 - 知乎</a><br>参考链接1.2：深度学习发展历程(MindSpore)-哔哩哔哩, <a target="_blank" rel="noopener" href="https://b23.tv/t4osJ6I">https://b23.tv/t4osJ6I</a></p>
<h4 id="1-1-欢迎"><a href="#1-1-欢迎" class="headerlink" title="1.1 欢迎"></a>1.1 欢迎</h4><p>从本节课我们将学到：</p>
<ul>
<li>学习神经网络的基础——神经网络与深度学习；</li>
<li>深度学习方面的实践；</li>
<li>如何结构化机器学习工程；</li>
<li>卷积神经网络(经常用于图像)；</li>
<li>序列模型以及如何应用到自然语言处理(NLP)，常见的序列模型有：循环神经网络(RNN)，长短期记忆网络(LSTM)模型。 </li>
</ul>
<h4 id="1-2-什么是神经网络"><a href="#1-2-什么是神经网络" class="headerlink" title="1.2 什么是神经网络"></a>1.2 什么是神经网络</h4><p>深度学习指的是“训练神经网络”</p>
<p>下面以房屋价格预测为例。首先，将已知的六间房子的价格和面积的关系绘制在二维平面上，如下图所示： </p>
<p><img src="https://pic.imgdb.cn/item/6267f293239250f7c5a1d58d.png" style="zoom:40%"></p>
<p>一般地，会用一条直线来拟合图中这些离散点，即建立房价与面积的线性模型。但是从实际考虑，价格永远不会是负数。所以对该直线做一点点修正，让它变成折线的形状，当面积小于某个值时，价格始终为零。如下图蓝色折线所示，就是建立的房价预测模型。 </p>
<p><img src="https://pic.imgdb.cn/item/6267f3cf239250f7c5a4cb1c.png" style="zoom:40%"></p>
<p>其实这个简单的模型（蓝色折线）就可以看成是一个神经网络，而且几乎是一个最简单的神经网络。我们把该房价预测用一个最简单的神经网络模型来表示，如下图所示： </p>
<p><img src="https://pic.imgdb.cn/item/6267f419239250f7c5a57391.png" style="zoom:40%"></p>
<p>上图中的小圆圈就可以视为一个独立的神经元，这个简单网络实现了左边函数的功能值得一提的是，上图神经元的预测函数（蓝色折线）在神经网络应用中比较常见。把这个函数称为<strong>线性整流函数(Rectified Linear Unit, ReLU)</strong>，形如下图所示： </p>
<p><img src="https://pic.imgdb.cn/item/6267f506239250f7c5a7c622.png" style="zoom:70%"></p>
<p>上面是一个最为简单的神经网络，更深的神经网络可以视为：将这些单个的神经元看作乐高积木，通过搭建积木来构建更大更深的网络。把上面举的房价预测的例子变得复杂一些，而不是仅仅使用房屋面积一个判断因素。 </p>
<p><img src="https://pic.imgdb.cn/item/6267f560239250f7c5a8b1e3.png" style="zoom:50%"></p>
<p>在给定这四个输入后，神经网络所做的就是输出房屋的预测价格y。上图中三个神经元所在的位置称之为<strong>中间层或者隐藏层</strong>(x所在的称之为输入层，y所在的称之为输出层)，每个神经元与所有的输入x都有关联(直线相连)。 </p>
<h4 id="1-3-使用神经网络进行监督学习"><a href="#1-3-使用神经网络进行监督学习" class="headerlink" title="1.3 使用神经网络进行监督学习"></a>1.3 使用神经网络进行监督学习</h4><p>由神经网络模型创造的价值基本上都是基于<strong>监督式学习(Supervised Learning)</strong>的。监督式学习与非监督式学习本质区别就是<strong>是否已知训练样本的输出y</strong>。在实际应用中，机器学习解决的大部分问题都属于监督式学习，神经网络模型也大都属于监督式学习。下面我们来看几个监督式学习在神经网络中应用的例子。</p>
<ul>
<li>房屋价格预测。根据训练样本的输入x和输出y，训练神经网络模型，预测房价。</li>
<li>线上广告。输入x是广告和用户个人信息，输出y是用户是否对广告进行点击。神经网络模型经过训练，能够根据广告类型和用户信息对用户的点击行为进行预测，从而向用户提供用户自己可能感兴趣的广告。</li>
<li>电脑视觉(computer vision)。电脑视觉是近些年来越来越火的课题，而电脑视觉发展迅速的原因很大程度上是得益于深度学习。其中，输入x是图片像素值，输出是图片所属的不同类别。</li>
<li>语音识别(speech recognition)。深度学习可以将一段语音信号辨识为相应的文字信息。</li>
<li>智能翻译。例如通过神经网络输入英文，然后直接输出中文。</li>
<li>自动驾驶。通过输入一张图片或者汽车雷达信息，神经网络通过训练来告诉你相应的路况信息并作出相应的决策。 </li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6267f5d9239250f7c5a9dfcd.png" style="zoom:50%"></p>
<p>根据不同的问题和应用场合，应该使用不同类型的神经网络模型。CNN和RNN是比较常用的神经网络模型。下图给出了Standard NN，Convolutional NN和Recurrent NN的神经网络结构图。 </p>
<p><img src="https://pic.imgdb.cn/item/6267f6c4239250f7c5ac1c6c.png"></p>
<p>数据类型一般分为两种：<strong>结构化数据(Structured Data)</strong>和<strong>非结构化数据(Unstructured Data)</strong> </p>
<p><img src="https://pic.imgdb.cn/item/6267f734239250f7c5ad2a26.png" style="zoom:40%"></p>
<h4 id="1-4-为什么深度学习流行起来了"><a href="#1-4-为什么深度学习流行起来了" class="headerlink" title="1.4 为什么深度学习流行起来了"></a>1.4 为什么深度学习流行起来了</h4><p>略</p>
<h3 id="第二章-神经网络基础之逻辑回归"><a href="#第二章-神经网络基础之逻辑回归" class="headerlink" title="第二章 神经网络基础之逻辑回归"></a>第二章 神经网络基础之逻辑回归</h3><p>下面开始介绍神经网络的基础：逻辑回归（Logistic Regression）。通过对逻辑回归模型结构的分析，为后面学习神经网络模型打下基础。 </p>
<h4 id="2-1-二分类-Binary-Classification"><a href="#2-1-二分类-Binary-Classification" class="headerlink" title="2.1 二分类(Binary Classification)"></a>2.1 二分类(Binary Classification)</h4><p>逻辑回归模型一般用来解决二分类(Binary Classification)问题。二分类就是输出只有{0,1\}两个离散值(也有{-1,1}的情况)。以一个图像识别问题为例，判断图片中是否有猫存在，0代表not cat，1代表cat。 </p>
<p><img src="https://pic.imgdb.cn/item/6267f7e7239250f7c5aece58.png" style="zoom:50%"></p>
<p>如上图所示，这是一个典型的二分类问题。一般来说，彩色图片包含RGB三个通道。例如该cat图片的尺寸为<script type="math/tex">(64, 64, 3)</script>。在神经网络模型中，我们首先要将图片输入<script type="math/tex">x</script>(维度是<script type="math/tex">(64, 64, 3)</script>)转化为一维的特征向量(feature vector)。方法是每个通道一行一行取，再连接起来。由于<script type="math/tex">64\times 64\times 3=12288</script>，则转化后的输入特征向量维度为<script type="math/tex">(12288, 1)</script>。此特征向量<script type="math/tex">x</script>是列向量，维度一般记为<script type="math/tex">n_x</script>。</p>
<p>如果训练样本共有<script type="math/tex">m</script>张图片，那么整个训练样本<script type="math/tex">X</script>组成了矩阵，维度是<script type="math/tex">(n_x,m)</script>。注意，这里矩阵<script type="math/tex">X</script>的行<script type="math/tex">n_x</script>代表了每个样本<script type="math/tex">x^{(i)}</script>特征个数，列<script type="math/tex">m</script>代表了样本个数。这里，Andrew解释了<script type="math/tex">X</script>的维度之所以是<script type="math/tex">(n_x, m)</script>而不是<script type="math/tex">(m, n_x)</script>的原因是为了之后矩阵运算的方便。算是Andrew给我们的一个小小的经验吧。而所有训练样本的输出<script type="math/tex">Y</script>也组成了一维的行向量，写成矩阵的形式后，它的维度就是<script type="math/tex">(1, m)</script>。</p>
<blockquote>
<p>后面课程会用到的一些符号<br>用一对<script type="math/tex">(x, y)</script>来表示一个单独的样本，其中<script type="math/tex">x</script>是<script type="math/tex">n_x</script>维特征向量(可记为<script type="math/tex">x \in \mathbb{R}^{n_x}</script>)，<script type="math/tex">y \in \{0, 1\}</script>，训练集由<script type="math/tex">m</script>个训练样本组成，<script type="math/tex">(x^{(i)}, y^{(i)})</script>表示样本<script type="math/tex">n</script>的输入输出。为了便于表示和区分，有时训练集表示为<script type="math/tex">m = m_{\text{train}}</script>，测试集表示为<script type="math/tex">m = m_{\text{test}}</script>，可进一步将训练集表示为更紧凑的形式，用矩阵<script type="math/tex">X</script>表示：<script type="math/tex">X=\left(\begin{array}{cccc}\vdots & \vdots & & \vdots \\x^{(1)} & x^{(2)} & \cdots & x^{(m)} \\\vdots & \vdots & & \vdots \\\end{array}\right)</script>，<script type="math/tex">X</script>的大小为<script type="math/tex">(n_x, m)</script>，<script type="math/tex">X \in \mathbb{R}^{n_x \times m}</script>，输出用<script type="math/tex">Y</script>表示：<script type="math/tex">Y = [y^{(1)}, y^{(1)}, \cdots, y^{(m)}]</script>，<script type="math/tex">Y</script>的大小为<script type="math/tex">(1, m)</script>，<script type="math/tex">Y \in \mathbb{R}^{1\times m}</script></p>
</blockquote>
<h4 id="2-2-logistic回归"><a href="#2-2-logistic回归" class="headerlink" title="2.2 logistic回归"></a>2.2 logistic回归</h4><p>这是一个学习算法，用于监督学习中输出<script type="math/tex">y​</script>是<script type="math/tex">0​</script>或<script type="math/tex">1​</script>的二元分类问题。</p>
<p>逻辑回归中，预测值<script type="math/tex">\hat{h} = \text{P}(y=1|x)</script>表示为输入<script type="math/tex">x</script>输出为<script type="math/tex">y = 1</script>的概率，取值范围在<script type="math/tex">[0,1]</script>之间，这是其与二分类模型不同的地方。使用线性模型，引入参数<script type="math/tex">w</script>和<script type="math/tex">b</script>。权重<script type="math/tex">w</script>的维度是<script type="math/tex">(n_x, 1)</script>，<script type="math/tex">b</script>是一个常数项，即<script type="math/tex">w \in \mathbb{R}^{n_x \times 1}, b \in \mathbb{R}</script>。这样，逻辑回归的线性预测输出可以写成：</p>
<script type="math/tex; mode=display">
\hat{y} = w^{\text{T}}x+b</script><p>值得注意的是，很多其它机器学习资料中，可能把常数<script type="math/tex">b</script>当做<script type="math/tex">w_0</script>处理，并引入<script type="math/tex">x_0=1</script>。这样从维度上来看，<script type="math/tex">x</script>和<script type="math/tex">w</script>都会增加一维。但在本课程中，为了简化计算和便于理解，Andrew建议还是使用上式这种形式将<script type="math/tex">w</script>和<script type="math/tex">b</script>分开比较好。</p>
<p>上式的线性输出区间为整个实数范围，而<strong>逻辑回归要求输出范围在</strong><script type="math/tex">[0,1]</script><strong>之间</strong>，所以还需要对上式的线性函数输出进行处理。方法是引入sigmoid函数，让输出限定在<script type="math/tex">[0,1]</script>之间。这样，逻辑回归的预测输出就可以完整写成：</p>
<script type="math/tex; mode=display">
\hat{y} = \text{sigmoid}(w^{\text T}x+b) = \sigma(w^{\text T}x+b)</script><p>sigmoid函数是一种非线性的S型函数，输出被限定在<script type="math/tex">[0,1]</script>之间，通常被用在神经网络中当作<strong>激活函数(Activation function)</strong>使用。Sigmoid函数的表达式：</p>
<script type="math/tex; mode=display">
\text{sigmoid}(z) = \frac{1}{1+e^{-z}}</script><p> 通过Sigmoid函数，就能够将逻辑回归的输出限定在<script type="math/tex">[0,1]</script>之间了。</p>
<h4 id="2-3-logistic回归损失函数"><a href="#2-3-logistic回归损失函数" class="headerlink" title="2.3 logistic回归损失函数"></a>2.3 logistic回归损失函数</h4><p>逻辑回归中，<script type="math/tex">w</script>和<script type="math/tex">b</script>都是未知参数，需要反复训练优化得到。因此，我们需要定义一个成本函数(cost function)，包含了参数<script type="math/tex">w</script>和<script type="math/tex">b</script>。通过优化cost function，当cost function取值最小时，得到对应的<script type="math/tex">w</script>和<script type="math/tex">b</script>。</p>
<p>如何定义所有<script type="math/tex">m</script>个样本的cost function呢？先从单个样本出发，我们希望该样本的预测值<script type="math/tex">\hat y</script>与真实值越相似越好。我们把单个样本的cost function用<strong>Loss function</strong>来表示，根据以往经验，如果使用平方错误(squared error)来衡量，如下所示：</p>
<script type="math/tex; mode=display">
L(\hat y, y) = \frac{1}{2}(\hat y-y)^2</script><p>但是，对于逻辑回归，我们一般不使用平方错误来作为Loss function。原因是这种Loss function一般是<strong>非凸(non-convex)</strong>的。non-convex函数在使用梯度下降算法时，容易得到局部最小值(local minumum)，即<strong>局部最优化</strong>。而我们最优化的目标是计算得到全局最优化(Global optimization)。因此，我们一般选择的Loss function应该是convex的。因此，我们可以构建另外一种Loss function，且是convex的，如下所示：</p>
<script type="math/tex; mode=display">
L(\hat y, y) = -(y\log \hat y + (1-y)\log(1-\hat y))</script><p>我们来分析一下这个Loss function，它是衡量错误大小的，Loss function越小越好。</p>
<p>当<script type="math/tex">y = 1</script>时，我们带入上式容易得知<script type="math/tex">\hat y\rightarrow1</script>时<script type="math/tex">L(\hat y, y)\rightarrow0</script>，预测效果越好；同理，当<script type="math/tex">y=0</script>时，<script type="math/tex">\hat y \rightarrow 0</script>则<script type="math/tex">L(\hat y,y)\rightarrow0</script>，预测效果越好。后续将会提到这个损失函数是如何推导出来的。</p>
<p>上面介绍的Loss function是针对单个样本的。那对于<script type="math/tex">m</script>个样本，我们定义Cost function，Cost function是<script type="math/tex">m</script>个样本的Loss function的平均值，反映了<script type="math/tex">m</script>个样本的预测输出<script type="math/tex">\hat y</script>与真实样本输出<script type="math/tex">y</script>的平均接近程度。Cost function可表示为：</p>
<script type="math/tex; mode=display">
J(w,b) = \frac1m \sum_{i=0}^{m}L(\hat y^{(i)}, y^{(i)})</script><p>Cost function已经推导出来了，Cost function是关于待求系数w和b的函数。我们的目标就是迭代计算出最佳的w和b值，<strong>最小化Cost function</strong>，让Cost function尽可能地接近于零。</p>
<p>其实逻辑回归问题可以看成是一个简单的神经网络，只包含<strong>一个神经元</strong>。这也是我们这里先介绍逻辑回归的原因。</p>
<h4 id="2-4-梯度下降法"><a href="#2-4-梯度下降法" class="headerlink" title="2.4 梯度下降法"></a>2.4 梯度下降法</h4><p>使用<strong>梯度下降(Gradient Descent)</strong>算法来计算出合适的<script type="math/tex">w</script>和<script type="math/tex">b</script>值，从而最小化<script type="math/tex">m</script>个训练样本的Cost function，即<script type="math/tex">J(w,b)</script>。</p>
<p>由于<script type="math/tex">J(w,b)</script>是convex  function，梯度下降算法是先随机选择一组参数<script type="math/tex">w</script>和<script type="math/tex">b</script>值，然后每次迭代的过程中分别沿着<script type="math/tex">w</script>和<script type="math/tex">b</script>的梯度(偏导数)的反方向前进一小步，不断修正<script type="math/tex">w</script>和<script type="math/tex">b</script>。每次迭代更新后，都能让<script type="math/tex">J(w,b)</script>更接近全局最小值。梯度下降的过程如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/648a82371ddac507ccb0ec36.jpg" style="zoom:50%"></p>
<p>梯度下降算法每次迭代更新，<script type="math/tex">w</script>和<script type="math/tex">b</script>的修正表达式为：</p>
<script type="math/tex; mode=display">
w:=w-\alpha \frac{\partial J(w, b)}{\partial w}</script><script type="math/tex; mode=display">
b:=b-\alpha \frac{\partial J(w, b)}{\partial b}</script><p>上式中，<script type="math/tex">\alpha</script>是学习因子(learning rate)，表示梯度下降的不仅长度。梯度下降算法能够保证每次迭代w和b都能向着J(w,b)全局最小化的方向进行。其<a target="_blank" rel="noopener" href="http://blog.csdn.net/red_stone1/article/details/72229903">数学原理</a>主要是运用泰勒一阶展开来证明的。</p>
<h4 id="2-5-2-6-导数复习"><a href="#2-5-2-6-导数复习" class="headerlink" title="2.5-2.6 导数复习"></a>2.5-2.6 导数复习</h4><p>这一部分的内容相对简单，Andrew主要是给对微积分、求导数不太清楚的同学介绍的。梯度或者导数一定程度上可以看成是斜率。关于求导数的方法这里就不再赘述了。</p>
<h4 id="2-7-计算图"><a href="#2-7-计算图" class="headerlink" title="2.7 计算图"></a>2.7 计算图</h4><p>整个神经网络的训练过程实际上包含了两个过程：<strong>正向传播(Forward Propagation)</strong>和<strong>反向传播(Back Propagation)</strong>。正向传播是从输入到输出，由神经网络计算得到预测输出的过程；反向传播是从输出到输入，对参数w和b计算梯度的过程。下面，我们用<strong>计算图(Computation graph)</strong>的形式来理解这两个过程。</p>
<p>举个简单的例子，假如Cost function为<script type="math/tex">J(a,b,c)=3(a+bc)</script>，包含<script type="math/tex">a</script>，<script type="math/tex">b</script>，<script type="math/tex">c</script>三个变量。我们用<script type="math/tex">u</script>表示<script type="math/tex">bc</script>，<script type="math/tex">v</script>表示<script type="math/tex">a+u</script>，则<script type="math/tex">J=3v</script>。它的计算图可以写成如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648a82ed1ddac507ccb243d5.jpg" style="zoom:50%"></p>
<p>令<script type="math/tex">a=5,b=3,c=2</script>，则<script type="math/tex">u=bc=6,v=a+u=11,J=3v=33</script>。计算图中，这种从左到右，从输入到输出的过程就对应着神经网络或者逻辑回归中输入与权重经过运算计算得到Cost function的正向过程。</p>
<h4 id="2-8-使用计算图求导"><a href="#2-8-使用计算图求导" class="headerlink" title="2.8 使用计算图求导"></a>2.8 使用计算图求导</h4><p>下面我们来介绍反向传播(Back Propagation)，即计算输出对输入的偏导数。</p>
<p><img src="https://pic.imgdb.cn/item/648a83431ddac507ccb2e777.jpg" style="zoom:50%"></p>
<h4 id="2-9-logistic回归中的梯度下降法"><a href="#2-9-logistic回归中的梯度下降法" class="headerlink" title="2.9 logistic回归中的梯度下降法"></a>2.9 logistic回归中的梯度下降法</h4><p>对逻辑回归进行梯度计算。对单个样本而言，逻辑回归Loss function表达式如下：</p>
<script type="math/tex; mode=display">
\begin{gathered}
&z = w^\text Tx+b \\
&\hat y = a = \sigma(z) \\
&L(\hat y,y) = L(a, y) = -(y\log a+(1-y)\log(1-a))
\end{gathered}</script><p>该逻辑回归的正向传播过程非常简单。据上述公式，例如输入样本<script type="math/tex">x</script>有两个特征<script type="math/tex">(x_1,x_2)</script>，相应的权重也有两个<script type="math/tex">(w_1,w_2)</script>，则<script type="math/tex">z = w_1x_1+w_2x_2+b</script>。</p>
<p>然后，计算该逻辑回归的反向传播过程，即由Loss function计算参数<script type="math/tex">w</script>和<script type="math/tex">b</script>的偏导数：</p>
<script type="math/tex; mode=display">
\begin{gathered}
&\mathrm d a=\frac{\partial L}{\partial a}=-\frac{y}{a}+\frac{1-y}{1-a}\\
&\mathrm d z=\frac{\partial L}{\partial z}=\frac{\partial L}{\partial a} \cdot \frac{\partial a}{\partial z}=\left(-\frac{y}{a}+\frac{1-y}{1-a}\right) \cdot a(1-a)=a-y
\end{gathered}</script><p>知道了<script type="math/tex">\mathrm dz</script>之后，就可以直接对<script type="math/tex">w_1，w_2</script>和<script type="math/tex">b</script>进行求导了：</p>
<script type="math/tex; mode=display">
\begin{gathered}
&\mathrm d w_1=\frac{\partial L}{\partial w_1}=\frac{\partial L}{\partial z} \cdot \frac{\partial z}{\partial w_1}=x_1 \cdot \mathrm  d z=x_1(a-y)\\
&\mathrm d w_2=\frac{\partial L}{\partial w_2}=\frac{\partial L}{\partial z} \cdot \frac{\partial z}{\partial w_2}=x_2 \cdot \mathrm  d z=x_2(a-y)\\
&\mathrm d b=\frac{\partial L}{\partial b}=\frac{\partial L}{\partial z} \cdot \frac{\partial z}{\partial b}=1 \cdot \mathrm  d z=a-y
\end{gathered}</script><p>则梯度下降算法可表示为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
w{1}:=w{1}-\alpha ~\mathrm d w{1} \\
w{2}:=w{2}-\alpha ~\mathrm d w{2} \\
b:=b-\alpha ~\mathrm d b
\end{gathered}</script><p><img src="https://pic.imgdb.cn/item/648a84f21ddac507ccb64b43.jpg" style="zoom:50%"></p>
<h4 id="2-10-m-个样本的梯度下降"><a href="#2-10-m-个样本的梯度下降" class="headerlink" title="2.10 m 个样本的梯度下降"></a>2.10 m 个样本的梯度下降</h4><p>上一部分讲的是对单个样本求偏导和梯度下降。如果有m个样本，其Cost function表达式如下：</p>
<script type="math/tex; mode=display">
\begin{gathered}
z^{(i)}=w^{T} x^{(i)}+b \\
\hat{y}^{(i)}=a^{(i)}=\sigma\left(z^{(i)}\right) \\
J(w, b)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)=-\frac{1}{m} \sum_{i=1}^{m}\left[y^{(i)} \log \hat{y}^{(i)}+\left(1-y^{(i)}\right) \log \left(1-\hat{y}^{(i)}\right)\right]
\end{gathered}</script><p>Cost function关于<script type="math/tex">w</script>和<script type="math/tex">b</script>的偏导数可以写成和平均的形式：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathrm d w_{1}=\frac{1}{m} \sum_{i=1}^{m} x_{1}^{(i)}\left(a^{(i)}-y^{(i)}\right) \\
\mathrm d w_{2}=\frac{1}{m} \sum_{i=1}^{m} x_{2}^{(i)}\left(a^{(i)}-y^{(i)}\right) \\
\mathrm d b=\frac{1}{m} \sum_{i=1}^{m} \left(a^{(i)}-y^{(i)}\right)
\end{gathered}</script><p>这样，每次迭代中<script type="math/tex">w</script>和<script type="math/tex">b</script>的梯度有$m$个训练样本计算平均值得到。其算法伪代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">J=<span class="number">0</span>; dw1=<span class="number">0</span>; dw2=<span class="number">0</span>; db=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to m</span><br><span class="line">    z(i) = wx(i)+b;</span><br><span class="line">    a(i) = sigmoid(z(i));</span><br><span class="line">    J += -[y(i)log(a(i))+(<span class="number">1</span>-y(i)）log(<span class="number">1</span>-a(i));</span><br><span class="line">    dz(i) = a(i)-y(i);</span><br><span class="line">    dw1 += x1(i)dz(i);</span><br><span class="line">    dw2 += x2(i)dz(i);</span><br><span class="line">    db += dz(i);</span><br><span class="line">J /= m;</span><br><span class="line">dw1 /= m;</span><br><span class="line">dw2 /= m;</span><br><span class="line">db /= m;</span><br></pre></td></tr></table></figure>
<p>经过每次迭代后，根据梯度下降算法，<script type="math/tex">w</script>和<script type="math/tex">b</script>都进行更新：</p>
<script type="math/tex; mode=display">
\begin{gathered}
w_{1}:=w_{1}-\alpha ~ \mathrm d w_{1} \\
w_{2}:=w_{2}-\alpha ~ \mathrm d w_{2} \\
b:=b-\alpha ~ \mathrm d b
\end{gathered}</script><p>这样经过<script type="math/tex">n</script>次迭代后，整个梯度下降算法就完成了。</p>
<p>值得一提的是，在上述的梯度下降算法中，是利用for循环对每个样本进行dw1，dw2和db的累加计算最后再求平均数的。在深度学习中，样本数量$m$通常很大，使用for循环会让神经网络程序运行得很慢。所以，我们应该尽量避免使用for循环操作，而使用<strong>矩阵运算</strong>，能够大大提高程序运行速度。关于<strong>向量化(vectorization)</strong>的内容我们放在下次笔记中再说。</p>
<h4 id="2-11-2-12-向量化"><a href="#2-11-2-12-向量化" class="headerlink" title="2.11-2.12 向量化"></a>2.11-2.12 向量化</h4><p>深度学习算法中，数据量很大，在程序中应该尽量减少使用loop循环语句，而可以使用向量运算来提高程序运行速度。</p>
<p>向量化(Vectorization)就是利用矩阵运算的思想，大大提高运算速度。</p>
<p>上一部分我们讲了应该尽量避免使用for循环而使用向量化矩阵运算。在python的numpy库中，我们通常使用<strong>np.dot()</strong>函数来进行矩阵运算。</p>
<p>我们将向量化的思想使用在逻辑回归算法上，尽可能减少for循环，而只使用矩阵运算。值得注意的是，算法最顶层的迭代训练的for循环是不能替换的。而每次迭代过程对J，dw，b的计算是可以直接使用矩阵运算。</p>
<h4 id="2-13-向量化logistic回归"><a href="#2-13-向量化logistic回归" class="headerlink" title="2.13 向量化logistic回归"></a>2.13 向量化logistic回归</h4><p>在前面的笔记中我们提到过，整个训练样本构成的输入矩阵<script type="math/tex">X</script>的维度是<script type="math/tex">(,m)</script>，权重矩阵<script type="math/tex">w</script>的维度是<script type="math/tex">(,1)</script>，<script type="math/tex">b</script>是一个常数值，而整个训练样本构成的输出矩阵<script type="math/tex">Y</script>的维度为<script type="math/tex">(1,m)</script>。利用向量化的思想，所有<script type="math/tex">m</script>个样本的线性输出<script type="math/tex">Z</script>可以用矩阵表示：</p>
<script type="math/tex; mode=display">
Z = w^{\text T}X+b</script><p>在python的numpy库中可以表示为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.dot(w.T,X) + b      <span class="comment"># w.T表示w的转置</span></span><br><span class="line">A = sigmoid(Z)</span><br></pre></td></tr></table></figure>
<p>这样，我们就能够使用向量化矩阵运算代替for循环，对所有<script type="math/tex">m</script>个样本同时运算，大大提高了运算速度。 </p>
<h4 id="2-14-向量化logistic回归的梯度输出"><a href="#2-14-向量化logistic回归的梯度输出" class="headerlink" title="2.14 向量化logistic回归的梯度输出"></a>2.14 向量化logistic回归的梯度输出</h4><p>逻辑回归中的梯度下降算法如何转化为向量化的矩阵形式。对于所有<script type="math/tex">m</script>个样本，<script type="math/tex">\mathrm dZ</script>的维度是<script type="math/tex">(1, m)</script>，可表示为：</p>
<script type="math/tex; mode=display">
\mathrm dZ = A-Y</script><script type="math/tex; mode=display">\mathrm d b$$可以表示为：</script><p>\mathrm d b = \frac{1}{m} \sum_{i=1}^{m}dz^{(i)}</p>
<script type="math/tex; mode=display">
对应的程序可以写成：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dw = <span class="number">1</span>/m*np.dot(X,dZ.T)</span><br></pre></td></tr></table></figure>
这样，我们把整个逻辑回归中的for循环尽可能用矩阵运算代替，对于单次迭代，梯度下降算法流程如下所示：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Z = np.dot(w.T,X) + b</span><br><span class="line">A = sigmoid(Z)</span><br><span class="line">dZ = A-Y</span><br><span class="line">dw = <span class="number">1</span>/m*np.dot(X,dZ.T)</span><br><span class="line">db = <span class="number">1</span>/m*np.<span class="built_in">sum</span>(dZ)</span><br><span class="line">w = w - alpha*dw</span><br><span class="line">b = b - alpha*db</span><br></pre></td></tr></table></figure>
其中，**alpha是学习因子**，决定$$w$$和$$b$$的更新速度。上述代码只是对单次训练更新而言的，外层还需要一个for循环，表示迭代次数。

### 第三章 浅层神经网络

#### 3.1 神经网络概览

首先，我们从整体结构上来大致看一下神经网络模型。

前面的课程中，我们已经使用**计算图**的方式介绍了逻辑回归**梯度下降算法**的**正向传播**和**反向传播**两个过程。如下图所示。神经网络的结构与逻辑回归类似，只是神经网络的层数比逻辑回归多一层，多出来的中间那层称为**隐藏层或中间层**。这样从计算上来说，神经网络的正向传播和反向传播过程只是比逻辑回归多了一次重复的计算。

正向传播过程分成两层，**第一层是输入层到隐藏层**，用上标[1]来表示：</script><p>\begin{gathered}<br>z^{[1]}=W^{[1]} x+b^{[1]} \\<br>a^{[1]} = \sigma (z^{[1]})<br>\end{gathered}</p>
<script type="math/tex; mode=display">
第二层是**隐藏层到输出层**，用上标[2]来表示：</script><p>\begin{gathered}<br>z^{[2]}=W^{[2]} x+b^{[2]} \\<br>a^{[2]} = \sigma (z^{[2]})<br>\end{gathered}</p>
<script type="math/tex; mode=display">
在写法上值得注意的是，方括号上标[i]表示当前所处的层数；圆括号上标(i)表示第i个样本。

同样，**反向传播过程也分成两层**。第一层是输出层到隐藏层，第二层是隐藏层到输入层。其细节部分我们之后再来讨论。

<img src="https://pic.imgdb.cn/item/648ac1111ddac507cc54a4ee.png" style="zoom:50%" />

#### 3.2 神经网络的表示

下面我们以图示的方式来介绍单隐藏层的神经网络结构。如下图所示，单隐藏层神经网络就是典型的浅层(shallow)神经网络。

<img src="https://pic.imgdb.cn/item/648ac1ad1ddac507cc56265f.png" style="zoom:60%" />

结构上，从左到右，可以分成三层：**输入层(Input layer)**，**隐藏层(Hidden layer)**和**输出层(Output  layer)**。输入层和输出层，顾名思义，对应着训练样本的输入和输出，很好理解。隐藏层是抽象的非线性的中间层，这也是其被命名为隐藏层的原因。

在写法上，我们通常把输入矩阵$$X$$记为$$a^{[0]}$$，把隐藏层输出记为$$a^{[1]}$$，上标从$$0$$开始。用下标表示第几个神经元，注意下标从$$1$$开始。例如$$a^{[1]}_1$$表示隐藏层第$$1$$个神经元，$$a^{[1]}_2$$表示隐藏层第$$2$$个神经元等等。这样隐藏层有$$4$$个神经元就可以将其输出$$a^{[1]}$$写成矩阵的形式：</script><p>a^{[1]}=\left[\begin{array}{c}a_{1}^{[1]} \\a_{2}^{[1]} \\a_{3}^{[1]} \\a_{4}^{[1]}\end{array}\right]</p>
<script type="math/tex; mode=display">


相应的输出层记为$$a^{[2]}$$，即$$\hat y$$。这种单隐藏层神经网络也称为两层神经网络(2 layer NN)。

> 之所以叫两层神经网络是因为，通常我们只会计算隐藏层输出和输出层的输出，输入层是不用计算的。这也是我们把输入层层数上标记为$$0$$的原因($$a^{[0]}$$)。
> 关于隐藏层对应的权重$$W^{[1]}$$和常数项$$b^{[1]}$$，$$W^{[1]}$$的维度是$$(4,3)$$。这里的$$4$$对应着隐藏层神经元个数，$$3$$对应着输入层$$x$$特征向量包含元素个数。常数项$$b^{[1]}$$的维度是$$(4,1)$$，这里的$$4$$同样对应着隐藏层神经元个数。关于输出层对应的权重$$W^{[2]}$$和常数项$$b^{[2]}$$，$$W^{[2]}$$的维度是$$(1,4)$$，这里的$$1$$对应着输出层神经元个数，$$4$$对应着隐藏层神经元个数。常数项$$b^{[2]}$$的维度是$$(1,1)$$，因为输出只有一个神经元。

总结一下，第$$i$$层的权重$$W^{[i]}$$维度的行等于$$i$$层神经元的个数，列等于$$i-1$$层神经元的个数；第$$i$$层常数项$$b^{[i]}$$维度的行等于$$i$$层神经元的个数，列始终为$$1$$。

#### 3.3 计算神经网络的输出

本节详细推导神经网络的计算过程。前面讲过两层神经网络可以看成是逻辑回归再重复计算一次。如下图所示，逻辑回归的正向计算可以分解成计算$$z$$和$$a$$的两部分：</script><p>\begin{gathered}<br>z = w^{\text T}x+b \\<br>a = \sigma(z)<br>\end{gathered}</p>
<script type="math/tex; mode=display">
<img src="https://pic.imgdb.cn/item/648ac29f1ddac507cc58f815.png" style="zoom:50%" />

对于两层神经网络，从输入层到隐藏层对应一次逻辑回归运算；从隐藏层到输出层对应一次逻辑回归运算。每层计算时，要注意对应的上标和下标，一般我们记上标方括号表示layer，下标表示第几个神经元。例如$$a^{[l]}_i$$表示第$$l$$层的第$$i$$个神经元。**注意，**$$i$$**从**$$1$$**开始，**$$l$$**从**$$0$$**开始**。

将从输入层到输出层的计算公式列出来：</script><p>\begin{aligned}&amp;z_{1}^{[1]}=w_{1}^{[1] T} x+b_{1}^{[1]}, a_{1}^{[1]}=\sigma\left(z_{1}^{[1]}\right) \\&amp;z_{2}^{[1]}=w_{2}^{[1] T} x+b_{2}^{[1]}, a_{2}^{[1]}=\sigma\left(z_{2}^{[1]}\right) \\&amp;z_{3}^{[1]}=w_{3}^{[1] T} x+b_{3}^{[1]}, a_{3}^{[1]}=\sigma\left(z_{3}^{[1]}\right) \\&amp;z_{4}^{[1]}=w_{4}^{[1] T} x+b_{4}^{[1]}, a_{4}^{[1]}=\sigma\left(z_{4}^{[1]}\right)\end{aligned}</p>
<script type="math/tex; mode=display">
然后，从隐藏层到输出层的计算公式为：</script><p>z^{[2]}_1 = w^{[1] \text T}_1a^{[1]}+b^{[2]}_1,a^{[2]}_1 = \sigma(z^{[2]}_1)</p>
<script type="math/tex; mode=display">
其中</script><p>a^{[1]}=\left[\begin{array}{c}a_{1}^{[1]} \\a_{2}^{[1]} \\a_{3}^{[1]} \\a_{4}^{[1]}\end{array}\right]</p>
<script type="math/tex; mode=display">
上述每个节点的计算都对应着一次逻辑运算的过程，分别由计算$$z$$和$$a$$两部分组成。

为了提高程序运算速度，我们引入向量化和矩阵运算的思想，将上述表达式转换成矩阵运算的形式：

<img src="https://pic.imgdb.cn/item/648ac37a1ddac507cc5b55f3.png" style="zoom:50%" />

之前也介绍过，这里顺便提一下，$$W^{[1]}$$的维度是$$(4,3)$$，$$b^{[1]}$$的维度是$$(4,1)$$，$$W^{[2]}$$的维度是$$(1,4)$$，$$b^{[2]}$$的维度是$$(1,1)$$。这点需要特别注意。

#### 3.4 多个样本的向量化

上一部分我们只是介绍了单个样本的神经网络正向传播矩阵运算过程。而对于$$m$$个训练样本，我们也可以使用矩阵相乘的形式来提高计算效率。而且它的形式与上一部分单个样本的矩阵运算十分相似，比较简单。

之前我们也介绍过，在书写标记上用上标$$(i)$$表示第$$i$$个样本，例如$$x^{(i)}$$，$$z^{(i)}$$，$$a^{[2](i)}$$。对于每个样本$$i$$，可以使用for循环来求解其正向输出：</script><p>\begin{aligned}for \  i = 1 \ to \ m \\&amp;z^{<a href="i">1</a>}=W^{[1]} x^{(i)}+b^{[1]} \\&amp;a^{<a href="i">1</a>}=\sigma\left(z^{<a href="i">1</a>}\right) \\&amp;z^{<a href="i">2</a>}=W^{[2]} a^{<a href="i">1</a>}+b^{[2]} \\&amp;a^{<a href="i">2</a>}=\sigma\left(z^{<a href="i">2</a>}\right)\end{aligned}</p>
<script type="math/tex; mode=display">
不使用for循环，利用矩阵运算的思想，输入矩阵$$X$$的维度为$$(n_x,m)$$。这样，我们可以把上面的for循环写成矩阵运算的形式：</script><p>\begin{gathered}Z^{[1]}=W^{[1]} X+b^{[1]} \\A^{[1]}=\sigma\left(Z^{[1]}\right) \\Z^{[2]}=W^{[2]} A^{[1]}+b^{[2]} \\A^{[2]}=\sigma\left(Z^{[2]}\right)\end{gathered}</p>
<script type="math/tex; mode=display">
其中，$$Z^{[1]}$$的维度是$$(4,m)$$，$$4$$是隐藏层神经元的个数；$$A^{[1]}$$的维度与$$Z^{[1]}$$相同；$$Z^{[2]}$$和$$A^{[2]}$$的维度均为$$(1,m)$$。对上面这四个矩阵来说，均可以这样来理解：**行表示神经元个数，列表示样本数目**$$m$$。

#### 3.5向量化实现的解释

这部分Andrew用图示的方式解释了$$m$$个样本的神经网络矩阵运算过程。其实内容比较简单，只要记住上述四个矩阵的行表示神经元个数，列表示样本数目$$m$$就行了。

值得注意的是输入矩阵$$X$$也可以写成$$A^{[0]}$$。

#### 3.6 激活函数

神经网络隐藏层和输出层都需要**激活函数(activation function)**，在之前的课程中我们都默认使用Sigmoid函数$$σ(x)$$作为激活函数。其实，还有其它激活函数可供使用，不同的激活函数有各自的优点。下面我们就来介绍几个不同的激活函数$$g(x)$$。

**(1) sigmoid函数**

<img src="https://pic.imgdb.cn/item/648ac3fb1ddac507cc5c8851.png" style="zoom:70%" />

**(2) tanh函数**

<img src="https://pic.imgdb.cn/item/648ac49f1ddac507cc5df268.png" style="zoom:70%" />

**(3) ReLU函数**

<img src="https://pic.imgdb.cn/item/648ac4d01ddac507cc5e604c.png" style="zoom:70%" />

**(4) Leaky ReLU函数**

<img src="https://pic.imgdb.cn/item/648ac4ed1ddac507cc5ea77a.png" style="zoom:70%" />

如上图所示，不同激活函数形状不同，$$a$$的取值范围也有差异。

如何选择合适的激活函数呢？首先我们来比较sigmoid函数和tanh函数。对于隐藏层的激活函数，一般来说，tanh函数要比sigmoid函数表现更好一些。因为tanh函数的取值范围在[-1,+1]之间，隐藏层的输出被限定在[-1,+1]之间，可以看成是在0值附近分布，均值为0。这样从隐藏层到输出层，数据起到了归一化（均值为0）的效果。因此，隐藏层的激活函数，tanh比sigmoid更好一些。而对于输出层的激活函数，因为二分类问题的输出取值为{0,+1}，所以一般会选择sigmoid作为激活函数。

观察sigmoid函数和tanh函数，我们发现有这样一个问题，就是当$$|z|$$很大的时候，激活函数的斜率（梯度）很小。因此，在这个区域内，梯度下降算法会运行得比较慢。在实际应用中，应尽量避免使z落在这个区域，使$$|z|$$尽可能限定在零值附近，从而提高梯度下降算法运算速度。

为弥补sigmoid函数和tanh函数的这个缺陷，就出现了ReLU激活函数。ReLU激活函数在$$z$$大于零时梯度始终为1；在$$z$$小于零时梯度始终为0；$$z$$**等于零时的梯度可以当成1也可以当成0**，实际应用中并不影响。对于隐藏层，选择ReLU作为激活函数能够保证z大于零时梯度始终为1，从而提高神经网络梯度下降算法运算速度。但当z小于零时，存在梯度为0的缺点，实际应用中，这个缺点影响不是很大。为了弥补这个缺点，出现了Leaky ReLU激活函数，能够保证z小于零是梯度不为0。

最后总结一下，如果是分类问题，输出层的激活函数一般会选择sigmoid函数。但是隐藏层的激活函数通常不会选择sigmoid函数，tanh函数的表现会比sigmoid函数好一些。实际应用中，通常会会选择使用ReLU或者Leaky ReLU函数，保证梯度下降速度不会太小。其实具体选择哪个函数作为激活函数没有一个固定的准确的答案，应该要根据具体实际问题进行验证(validation)。

#### 3.7 为什么需要非线性激活函数

我们知道上一部分讲的四种激活函数都是**非线性(non-linear)**的。那是否可以使用线性激活函数呢？答案是不行！下面我们就来进行简要的解释和说明。

假设所有的激活函数都是线性的，为了简化计算，我们直接令激活函数$$g(z)=z$$，即$$a=z$$。那么，浅层神经网络的各层输出为：</script><p>\begin{gathered}z^{[1]}=W^{[1]} x+b^{[1]} \\a^{[1]}=z^{[1]} \\z^{[2]}=W^{[2]} a^{[1]}+b^{[2]} \\a^{[2]}=z^{[2]}\end{gathered}</p>
<script type="math/tex; mode=display">
我们对上式中$$a^{[2]}$$进行化简计算：</script><p>\begin{align}a^{[2]}&amp; =z^{[2]} \\&amp; =W^{[2]} a^{[1]}+b^{[2]} \\&amp; =W^{[2]}\left(W^{[1]} x+b^{[1]}\right)+b^{[2]} \\&amp;=\left(W^{[2]} W^{[1]}\right) x+\left(W^{[2]} b^{[1]}+b^{[2]}\right) \\&amp; =W^{\prime} x+b^{\prime}\end{align}</p>
<script type="math/tex; mode=display">
经过推导我们发现$$a^{[2]}$$仍是输入变量$$x$$的**线性组合**。这表明，使用神经网络与直接使用线性模型的效果并没有什么两样。即便是包含多层隐藏层的神经网络，**如果使用线性函数作为激活函数，最终的输出仍然是输入**$$x$$**的线性模型**。这样的话神经网络就没有任何作用了。因此，**隐藏层的激活函数必须要是非线性的**。

另外，如果所有的隐藏层全部使用线性激活函数，只有输出层使用非线性激活函数，那么整个神经网络的结构就类似于一个简单的逻辑回归模型，而失去了神经网络模型本身的优势和价值。

值得一提的是，如果是预测问题而不是分类问题，输出$$y$$是连续的情况下，输出层的激活函数可以使用线性函数。如果输出$$y$$恒为正值，则也可以使用ReLU激活函数，具体情况，具体分析。

#### 3.8 激活函数的导数

在梯度下降反向计算过程中少不了计算激活函数的导数即梯度。

(1) sigmoid函数的导数</script><p>\begin{gathered}g(z)=\frac{1}{1+e^{(-z)}} \\g^{\prime}(z)=\frac{\mathrm d}{\mathrm d z} g(z)=g(z)(1-g(z))=a(1-a)\end{gathered}</p>
<script type="math/tex; mode=display">
(2) tanh函数的导数</script><p>\begin{gathered}g(z)=\frac{e^{(z)}-e^{(-z)}}{e^{(z)}+e^{(-z)}} \\g^{\prime}(z)=\frac{\mathrm d}{\mathrm d z} g(z)=1-(g(z))^{2}=1-a^{2}\end{gathered}</p>
<script type="math/tex; mode=display">
(3) ReLU函数的导数</script><p>\begin{gathered}g(z)=\max (0, z) \\g^{\prime}(z)= \begin{cases}0, &amp; z<0 \\1, & z> 0 \\0\ \text{or}\ 1,&amp; z = 0\end{cases}\end{gathered}</0></p>
<script type="math/tex; mode=display">
(4) Leaky ReLU函数的导数</script><p>\begin{gathered}g(z)=\max (0.01z, z) \\g^{\prime}(z)= \begin{cases}0.01, &amp; z&lt;0 \\1, &amp; z \geq 0\end{cases}\end{gathered}</p>
<script type="math/tex; mode=display">

#### 3.9 神经网络的梯度下降法

你的单隐层神经网络会有$$W^{[1]}$$，$$b^{[1]}$$，$$W^{[2]}$$，$$b^{[2]}$$这些参数，还有$$n_x$$个表示输入特征的个数，$$n^{[1]}$$表示隐藏单元个数, $$n^{[2]}$$表示输出单元个数。只介绍这种情况，那么参数:

矩阵$$W^{[1]}$$的维度就是$$(n^{[1]}, n^{[0]})$$，$$b^{[1]}$$就是$$n^{[1]}$$维向量，可以写成$$(n^{[1]},1)$$，就是一个的列向量。矩阵$$W^{[2]}$$的维度就是$$(n^{[2]},n^{[1]} )$$, $$b^{[2]}$$的维度就是$$(n^{[2]},1 )$$。

你还有一个神经网络的成本函数，假设你在做二分类任务，那么你的成本函数等于</script><p>J(W^{[1]}, b^{[1]}, W^{[2]}, b^{[2]}) = \frac{1}{m}\sum_{i=1}^{m}{L(\hat y,y)}</p>
<script type="math/tex; mode=display">
训练参数需要做梯度下降，在训练神经网络的时候，随机初始化参数很重要，而**不是初始化成全零**。当你参数初始化成某些值后，每次梯度下降都会循环计算以下预测值$$\hat y, (i= 1,2,.... m)</script><script type="math/tex; mode=display">
\begin{aligned}&\mathrm d W^{[1]}=\frac{\mathrm d J}{\mathrm d W^{[1]}}, \mathrm d b^{[1]}=\frac{\mathrm d J}{\mathrm d b^{[1]}} \\&\mathrm d W^{[2]}=\frac{\mathrm d J}{\mathrm d W^{[2]}}, \mathrm d b^{[2]}=\frac{\mathrm d J}{\mathrm d b^{[2]}}\end{aligned}</script><p>其中，</p>
<script type="math/tex; mode=display">
\begin{aligned}&W^{[1]} \Rightarrow W^{[1]}-\alpha \mathrm d W^{[1]}, b^{[1]} \Rightarrow b^{[1]}-\alpha \mathrm d b^{[1]} \\&W^{[2]} \Rightarrow W^{[2]}-\alpha\mathrm  d W^{[2]}, b^{[2]} \Rightarrow b^{[2]}-\alpha \mathrm d b^{[2]}\end{aligned}</script><p>使用计算图的方式来推导神经网络反向传播过程。记得之前介绍逻辑回归时，我们就引入了计算图来推导正向传播和反向传播，其过程如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648ac6371ddac507cc6308ed.png"></p>
<p>由于多了一个隐藏层，神经网络的计算图要比逻辑回归的复杂一些，如下图所示。对于单个训练样本，正向过程很容易，反向过程可以根据梯度计算方法逐一推导。</p>
<script type="math/tex; mode=display">
\begin{gathered}\mathrm d z^{[2]}=a^{[2]}-y \\
\mathrm d W^{[2]}=\mathrm d z^{[2]} \cdot \frac{\partial z^{[2]}}{\partial W^{[2]}}=\mathrm d z^{[2]} a^{[1] T} \\
\mathrm d b^{[2]}=\mathrm d z^{[2]} \cdot \frac{\partial z^{[2]}}{\partial b^{[2]}}=\mathrm d z^{[2]} \cdot 1=\mathrm d z^{[2]} \\
\mathrm d z^{[1]}=\mathrm d z^{[2]} \cdot \frac{\partial z^{[2]}}{\partial a^{[1]}} \cdot \frac{\partial a^{[1]}}{\partial z^{[1]}}=W^{[2] T}\mathrm  d z^{[2]} * g^{[1]^{\prime}}\left(z^{[1]}\right) \\
\mathrm d b^{[1]}=\mathrm d z^{[1]} \cdot \frac{\partial z^{[1]}}{\partial b^{[1]}}=\mathrm d z^{[1]} \cdot 1=\mathrm d z^{[1]} \\
\mathrm d z^{[1]}=\mathrm d z^{[1]} \cdot \frac{\partial z^{[1]}}{\partial W^{[1]}}=\mathrm d z^{[1]} x^{T}\end{gathered}</script><script type="math/tex; mode=display">
\begin{aligned}&\mathrm d z^{[2]}=A^{[2]}-Y, Y=\left[\begin{array}{lll}y^{[1]} & y^{[2]} & \ldots & \left.y^{[m]}\right]\end{array}\right. \\
&\mathrm d W^{[2]}=\frac{1}{m} \mathrm d z^{[2]} A^{[1] T} \\&\mathrm d b^{[2]}=\frac{1}{m} \text { np.sum }\left(\mathrm d z^{[2]}, \text { axis }=1, \text { keepdims }=\text { True }\right) \\
&\mathrm d z^{[1]}=\underbrace{W^{[2] T} \mathrm d z^{[2]}}_{\left(n^{[1]}, m\right)} \quad \text { activation function of hidden layer } \quad * \underbrace{\left(z^{[1]}\right)}_{\left(n^{[1]}, m\right)} \\
&\mathrm d W^{[1]}=\frac{1}{m} \mathrm d z^{[1]} x^{T} \\
&\underbrace{\mathrm d b^{[1]}}=\frac{1}{m} \text { np.sum }\left(\mathrm d z^{[1]}, \text { axis }=1, \text { keepdims }=\text { True }\right)\end{aligned}</script><p><img src="https://pic.imgdb.cn/item/648ac7ce1ddac507cc677d5e.png"></p>
<p>上述是反向传播的步骤，注：这些都是针对所有样本进行过向量化，<script type="math/tex">Y</script>是<script type="math/tex">1 ∗ m</script>的矩阵；这里np.sum是python的numpy命令，<strong>axis=1表示水平相加求和</strong>，<strong>keepdims防止python输出那些古怪的秩数</strong><script type="math/tex">(n , )</script>，加上这个确保矩阵<script type="math/tex">db^{[2]}</script>这个向量输出维度为<script type="math/tex">( n , 1 )</script>这样标准的形式。</p>
<p>总结一下，浅层神经网络(包含一个隐藏层)，<script type="math/tex">m</script>个训练样本的正向传播过程和反向传播过程分别包含了6个表达式，其向量化矩阵形式如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648ac8041ddac507cc681841.png"></p>
<h4 id="3-10-选修-直观理解反向传播"><a href="#3-10-选修-直观理解反向传播" class="headerlink" title="3.10 (选修)直观理解反向传播"></a>3.10 (选修)直观理解反向传播</h4><p>本节记录一下我的两个疑问：</p>
<p>(1) 矩阵微积分问题</p>
<p>(2) <script type="math/tex">\mathrm dZ</script>的式子中没有<script type="math/tex">1/m</script>项</p>
<p>本小节笔记参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36815313/article/details/105341107">3.10 直观理解反向传播-深度学习-Stanford吴恩达教授_赵继超的笔记-CSDN博客</a></p>
<h4 id="3-11-随机初始化"><a href="#3-11-随机初始化" class="headerlink" title="3.11 随机初始化"></a>3.11 随机初始化</h4><p>神经网络模型中的参数权重W是不能全部初始化为零的，接下来我们分析一下原因。</p>
<p>举个简单的例子，一个浅层神经网络包含两个输入，隐藏层包含两个神经元。如果权重<script type="math/tex">W[1]</script>和<script type="math/tex">W^{[2]}</script>都初始化为零，即：</p>
<script type="math/tex; mode=display">
\begin{gathered}W^{[1]}=\left[\begin{array}{ll}0 & 0 \\0 & 0\end{array}\right] \\W^{[2]}=\left[\begin{array}{ll}0 & 0\end{array}\right]\end{gathered}</script><p><img src="https://pic.imgdb.cn/item/648ac8e91ddac507cc6ae7b1.png" style="zoom:60%"></p>
<p>这样使得隐藏层第一个神经元的输出等于第二个神经元的输出，即<script type="math/tex">a^{[1]}_1=a^{[1]}_2</script>。经过推导得到<script type="math/tex">dz^{[1]}_1 = dz^{[1]}_2</script>，以及<script type="math/tex">dW^{[1]}_1 = dW^{[1]}_2</script>。因此，这样的结果是隐藏层两个神经元对应的权重行向量<script type="math/tex">W^{[1]}_1</script>和<script type="math/tex">W^{[1]}_2</script>，每次迭代更新都会得到完全相同的结果，<script type="math/tex">W^{[1]}_1</script>始终等于<script type="math/tex">W^{[1]}_2</script>，完全对称。这样隐藏层设置多个神经元就没有任何意义了。值得一提的是，<strong>参数</strong><script type="math/tex">b</script><strong>可以全部初始化为零</strong>，并不会影响神经网络训练效果；<strong>此外权重</strong><script type="math/tex">W</script><strong>不能全初始化为零，也不能全部初始化为一样的值。</strong></p>
<p>我们把这种权重W全部初始化为零带来的问题称为symmetry breaking problem。解决方法也很简单，就是将W进行随机初始化(b可初始化为零)。python里可以使用如下语句进行W和b的初始化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">W_1 = np.random.randn((<span class="number">2</span>,<span class="number">2</span>))*<span class="number">0.01</span></span><br><span class="line">b_1 = np.zero((<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">W_2 = np.random.randn((<span class="number">1</span>,<span class="number">2</span>))*<span class="number">0.01</span></span><br><span class="line">b_2 = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里我们将<script type="math/tex">W^{[1]}_1</script>和<script type="math/tex">W^{[1]}_2</script>乘以<script type="math/tex">0.01</script>的目的是尽量使得权重<script type="math/tex">W</script>初始化比较小的值。之所以让<script type="math/tex">W</script>比较小，是因为如果使用sigmoid函数或者tanh函数作为激活函数的话，<script type="math/tex">W</script>比较小，得到的<script type="math/tex">|z|</script>也比较小(靠近零点)，而<strong>零点区域的梯度比较大</strong>，这样能大大提高梯度下降算法的更新速度，尽快找到全局最优解。如果<script type="math/tex">W</script>较大，得到的<script type="math/tex">|z|</script>也比较大，附近曲线平缓，梯度较小，训练过程会慢很多。</p>
<p>当然，如果激活函数是ReLU或者Leaky ReLU函数，则不需要考虑这个问题。但是，如果输出层是sigmoid函数，则对应的权重最好初始化到比较小的值。</p>
<h3 id="第四章-深层神经网络"><a href="#第四章-深层神经网络" class="headerlink" title="第四章 深层神经网络"></a>第四章 深层神经网络</h3><p>上节主要介绍了浅层神经网络。首先介绍神经网络的基本结构，包括输入层，隐藏层和输出层。然后以简单的2 layer NN为例，详细推导了其正向传播过程和反向传播过程，使用梯度下降的方法优化神经网络参数。我们还介绍了不同的激活函数，比较各自优缺点，讨论了激活函数必须是非线性的原因。最后介绍了神经网络参数随机初始化的必要性，特别是权重<script type="math/tex">W</script>，不同神经元的<script type="math/tex">W</script>不能初始化为同一零值。本节课是对上节课的延伸和扩展，讨论更深层的神经网络。</p>
<h4 id="4-1-深层神经网络概述"><a href="#4-1-深层神经网络概述" class="headerlink" title="4.1 深层神经网络概述"></a>4.1 深层神经网络概述</h4><p>深层神经网络其实就是包含更多的隐藏层神经网络。如下图所示，分别列举了逻辑回归、1个隐藏层的神经网络、2个隐藏层的神经网络和5个隐藏层的神经网络它们的模型结构。</p>
<p><img src="https://pic.imgdb.cn/item/648ac9781ddac507cc6cd8f2.png"></p>
<p>命名规则上，一般只参考隐藏层个数和输出层。例如，上图中的逻辑回归又叫1 layer NN，1个隐藏层的神经网络叫做2 layer NN，2个隐藏层的神经网络叫做3 layer NN，以此类推。如果是L-layer NN，则包含了L-1个隐藏层，最后的L层是输出层。</p>
<p>下面以一个4层神经网络为例来介绍关于神经网络的一些标记写法。如图30所示。</p>
<ul>
<li>总层数：用<script type="math/tex">L</script>表示，<script type="math/tex">L=4</script>。输入层是第<script type="math/tex">0</script>层，输出层是第<script type="math/tex">L</script>层。</li>
<li><script type="math/tex">n^{[l]}</script>表示第<script type="math/tex">l</script>层包含的单元个数，<script type="math/tex">l=0,1,⋯,L</script>。这个模型中，<script type="math/tex">n^{[0]}=n_x=3</script>，表示三个输入特征<script type="math/tex">x_1,x_2,x_3</script>。<script type="math/tex">n^{[1]}=5，n^{[2]}=5，n^{[3]}=3，n^{[4]}=n^{[L]}=1</script>。</li>
<li>第<script type="math/tex">l</script>层的激活函数输出用<script type="math/tex">a^{[l]}</script>表示，<script type="math/tex">a^{[l]}=g^{[l]}(z^{[l]})</script>。</li>
<li><script type="math/tex">W^{[l]}</script>表示第<script type="math/tex">l</script>层的权重，用于计算z[l]。<br>另外，我们把输入<script type="math/tex">x</script>记为<script type="math/tex">a^{[0]}</script>，把输出层<script type="math/tex">\hat y</script>记为<script type="math/tex">a^{[L]}</script>。</li>
</ul>
<p>注意，<script type="math/tex">a^{[l]}</script>和<script type="math/tex">W^{[l]}</script>中的上标<script type="math/tex">l</script>都是从<script type="math/tex">1</script>开始的，<script type="math/tex">l=1,⋯,L</script>。</p>
<p><img src="https://pic.imgdb.cn/item/648ac9ba1ddac507cc6ddfdd.png" style="zoom:40%"></p>
<h4 id="4-2-深层神经网络中的前向传播"><a href="#4-2-深层神经网络中的前向传播" class="headerlink" title="4.2 深层神经网络中的前向传播"></a>4.2 深层神经网络中的前向传播</h4><p>对于第<script type="math/tex">l</script>层，其正向传播过程的<script type="math/tex">Z^{[l]}</script>和<script type="math/tex">A^{[l]}</script>可以表示为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
Z^{[l]}=W^{[l]} A^{[l-1]}+b^{[l]} \\
A^{[l]}=g^{[l]}\left(Z^{[l]}\right)
\end{gathered}</script><p>其中，<script type="math/tex">l = 1,...L</script>。</p>
<h4 id="4-3-核对矩阵的维数"><a href="#4-3-核对矩阵的维数" class="headerlink" title="4.3 核对矩阵的维数"></a>4.3 核对矩阵的维数</h4><p>对于单个训练样本，输入<script type="math/tex">x</script>的维度是<script type="math/tex">(n^{[0]},1)</script>神经网络的参数<script type="math/tex">W^{[l]}</script>和<script type="math/tex">b^{[l]}</script>的维度分别是：</p>
<script type="math/tex; mode=display">
\begin{gathered}W^{[l]}:\left(n^{[l]}, n^{[l-1]}\right) \\b^{[l]}:\left(n^{[l]}, 1\right)\end{gathered}</script><p>其中，<script type="math/tex">l=1,⋯,L</script>，<script type="math/tex">n^{[l]}</script>和<script type="math/tex">n^{[l−1]}</script>分别表示第<script type="math/tex">l</script>层和<script type="math/tex">l−1</script>层的所含单元个数。<script type="math/tex">n^{[0]}=n_x</script>，表示输入层特征数目。</p>
<p>顺便提一下，反向传播过程中的<script type="math/tex">dW^{[l]}</script>、<script type="math/tex">db^{[l]}</script>的维度和<script type="math/tex">W</script>、<script type="math/tex">b</script>的<strong>维度相同</strong>。</p>
<p>正向传播过程中的<script type="math/tex">z^{[l]}</script>和<script type="math/tex">a^{[l]}</script>的维度分别是：</p>
<script type="math/tex; mode=display">
\begin{aligned}&z^{[l]}:\left(n^{[l]}, 1\right) \\&a^{[l]}:\left(n^{[l]}, 1\right)\end{aligned}</script><script type="math/tex; mode=display">z^{[l]}$$和$$a^{[l]}$$的维度是一样的，且$$dz^{[l]}$$和$$da^{[l]}$$的维度均与$$z^{[l]}$$和$$a^{[l]}$$的维度一致。

对于$$m$$个训练样本，输入矩阵$$X$$的维度是$$(n^{[0]},m)$$。需要注意的是$$W^{[l]}$$和$$b^{[l]}$$的维度与只有单个样本是一致的：</script><p>\begin{gathered}W^{[l]}:\left(n^{[l]}, n^{[l-1]}\right) \\b^{[l]}:\left(n^{[l]}, 1\right)\end{gathered}</p>
<script type="math/tex; mode=display">
只不过在运算$$Z^{[l]}=W^{[l]}A^{[l−1]}+b^{[l]}$$中，$$b^{[l]}$$会被当成$$(n^{[l]},m)$$矩阵进行运算，这是因为python的广播性质，且$$b^{[l]}$$每一列向量都是一样的。$$dW^{[l]}$$和$$db^{[l]}$$的维度分别与$$W$$和$$b$$的相同。但是，$$Z^{[l]}$$和$$A^{[l]}$$的维度发生了变化：</script><p>\begin{gathered}<br>Z^{[l]}:\left(n^{[l]}, m\right)\\<br>A^{[l]}:\left(n^{[l]}, m\right)<br>\end{gathered}</p>
<script type="math/tex; mode=display">
$$dZ^{[l]}$$和$$dA^{[l]}$$的维度分别与$$Z^{[l]}$$和$$A^{[l]}$$的相同。

#### 4.4 为什么使用深层表示

神经网络能处理很多问题，而且效果显著。其强大能力主要源自神经网络足够**“深”**，也就是说网络层数越多，神经网络就更加复杂和深入，学习也更加准确。接下来，我们从几个例子入手，看一下为什么深度网络能够如此强大。

先来看人脸识别的例子，如下图所示。经过训练，神经网络第一层所做的事就是从原始图片中提取出人脸的轮廓与边缘，即边缘检测。这样每个神经元得到的是一些边缘信息。神经网络第二层所做的事情就是将前一层的边缘进行组合，组合成人脸一些局部特征，比如眼睛、鼻子、嘴巴等。再往后面，就将这些局部特征组合起来，融合成人脸的模样。可以看出，**随着层数由浅到深，神经网络提取的特征也是从边缘到局部特征到整体，由简单到复杂。可见，如果隐藏层足够多，那么能够提取的特征就越丰富、越复杂，模型的准确率就会越高。**

语音识别模型也是这个道理。浅层的神经元能够检测一些简单的音调，然后较深的神经元能够检测出基本的音素，更深的神经元就能够检测出单词信息。如果网络够深，还能对短语、句子进行检测。**记住一点，神经网络从左到右，神经元提取的特征从简单到复杂。特征复杂度与神经网络层数成正相关。特征越来越复杂，功能也越来越强大**。

<img src="https://pic.imgdb.cn/item/648acaa01ddac507cc70ee96.png">

除了从提取特征复杂度的角度来说明深层网络的优势之外，深层网络还有另外一个优点，就是能够减少神经元个数，从而减少计算量。例如下面这个例子，使用电路理论，计算逻辑输出：</script><p>y=x_{1} \oplus x_{2} \oplus x_{3} \oplus \cdots \oplus x_{n}</p>
<script type="math/tex; mode=display">
其中，⊕表示异或操作。对于这个逻辑运算，如果使用深度网络，深度网络的结构是每层将前一层的两两单元进行异或，最后到一个输出，如下图左边所示。这样，整个深度网络的层数是$$log_2(n)$$，不包含输入层。总共使用的神经元个数为：</script><p>1+2+\cdots+2^{\log _{2}(n)-1}=1 \cdot \frac{1-2^{\log _{2}(n)}}{1-2}=2^{\log _{2}(n)}-1=n-1</p>
<script type="math/tex; mode=display">
可见，输入个数是$$n$$，这种深层网络所需的神经元个数仅仅是$$n-1$$个。

如果不用深层网络，仅仅使用单个隐藏层，那么需要的神经元个数将是指数级别那么大。Andrew指出，由于包含了所有的逻辑位（0和1），则需要$$2^{n−1}$$个神经元。**这里笔者推导的是**$$2^n$$**个神经元，为啥是**$$2^{n−1}$$**请哪位高手解释下。**

比较下来，处理同一逻辑问题，深层网络所需的神经元个数比浅层网络要少很多。这也是深层神经网络的优点之一。

尽管深度学习有着非常显著的优势，Andrew还是建议对实际问题进行建模时，尽量先选择层数少的神经网络模型，这也符合奥卡姆剃刀定律(Occam's Razor)。对于比较复杂的问题，再使用较深的神经网络模型。

#### 4.5 搭建深层神经网络模块

下面用流程块图来解释神经网络正向传播和反向传播过程。如下图所示，对于第$$l$$层来说，正向传播过程中：

|              | **正向传播**        | **反向传播**                     |
| :----------- | :------------------ | :------------------------------- |
| **输入**     | $$a^{[l-1]}$$       | $$da^{[l]}$$                     |
| **输出**     | $$a^{[l]}$$         | $$da^{[l-1]},dW^{[l]},db^{[l]}$$ |
| **参数**     | $$W^{[l]},b^{[l]}$$ | $$W^{[l]},b^{[l]}$$              |
| **缓存变量** | $$z^{[l]}$$         |                                  |

<img src="https://pic.imgdb.cn/item/648acb1f1ddac507cc728405.png" style="zoom:50%" />

刚才这是第$$l$$层的流程块图，对于神经网络所有层，整体的流程块图正向传播过程和反向传播过程如下所示：

<img src="https://pic.imgdb.cn/item/648acb641ddac507cc737af1.png">

#### 4.6 前向和反向传播

接着上一部分流程块图的内容，推导神经网络正向传播过程和反向传播过程的具体表达式。首先是正向传播过程，令层数为第$$l$$层，输入是$$a^{[l−1]}$$，输出是$$a^{[l]}$$，缓存变量是$$z^{[l]}$$。其表达式如下：</script><p>\begin{gathered}<br>z^{[l]}=W^{[l]} a^{[l-1]}+b^{[l]} \\<br>a^{[l]}=g^{[l]}\left(z^{[l]}\right)<br>\end{gathered}</p>
<script type="math/tex; mode=display">
$$m$$个训练样本，向量化形式为：</script><p>\begin{gathered}<br>Z^{[l]}=W^{[l]} A^{[l-1]}+b^{[l]} \\<br>A^{[l]}=g^{[l]}\left(Z^{[l]}\right)<br>\end{gathered}</p>
<script type="math/tex; mode=display">
然后是反向传播过程，输入是$$da^{[l]}$$，输出是$$da^{[l−1]},dw^{[l]},db^{[l]}$$。其表达式如下：</script><p>\begin{gathered}<br>\mathrm d z^{[l]}=\mathrm d a^{[l]} * g^{[l]^{\prime}}\left(z^{[l]}\right) \\<br>\mathrm d W^{[l]}=\mathrm d z^{[l]} \cdot a^{[l-1]} \\<br>\mathrm d b^{[l]}=\mathrm d z^{[l]} \\<br>\mathrm d a^{[l-1]}=W^{[l] T} \cdot \mathrm d z^{[l]}<br>\end{gathered}</p>
<script type="math/tex; mode=display">


由上述第四个表达式可得$$da^{[l]}=W^{[l+1]T}⋅dz^{[l+1]}$$，将$$da^{[l]}$$代入第一个表达式中可以得到：

$$d z^{[l]}=W^{[l+1] T} \cdot d z^{[l+1]} * g^{[l]^{\prime}}\left(z^{[l]}\right)</script><p>该式非常重要，反映了<script type="math/tex">dz^{[l+1]}</script>与<script type="math/tex">dz^{[l]}</script>的递推关系。</p>
<script type="math/tex; mode=display">m$$个训练样本，向量化形式为：

$$\begin{gathered}d Z^{[l]}=d A^{[l]} * g^{[l]^{\prime}}\left(Z^{[l]}\right) \\d W^{[l]}=\frac{1}{m} d Z^{[l]} \cdot A^{[l-1] T} \\d b^{[l]}=\frac{1}{m} n p \cdot sum\left(d Z^{[l]}, \text { axis }=1, \text { keepdim }=\text { True }\right) \\d A^{[l-1]}=W^{[l] T} \cdot d Z^{[l]} \\d Z^{[l]}=W^{[l+1] T} \cdot d Z^{[l+1]} * g^{[l]^{\prime}}\left(Z^{[l]}\right)\end{gathered}</script><h4 id="4-7-参数-VS超参数"><a href="#4-7-参数-VS超参数" class="headerlink" title="4.7 参数 VS超参数"></a>4.7 参数 VS超参数</h4><p>该部分介绍神经网络中的参数（parameters）和超参数（hyperparameters）的概念。</p>
<p>神经网络中的参数就是我们熟悉的<script type="math/tex">W^{[l]}</script>和<script type="math/tex">b^{[l]}</script>。而超参数则是例如学习速率<script type="math/tex">\alpha</script>，训练迭代次数<script type="math/tex">N</script>，神经网络层数<script type="math/tex">L</script>，各层神经元个数<script type="math/tex">n^{[l]}</script>，激活函数<script type="math/tex">g(z)</script>等。之所以叫做超参数的原因是它们决定了参数<script type="math/tex">W^{[l]}</script>和<script type="math/tex">b^{[l]}</script>的值。在后面的第二门课我们还将学习其它的超参数，这里先不讨论。</p>
<p>如何设置最优的超参数是一个比较困难的、需要经验知识的问题。通常的做法是选择超参数一定范围内的值，分别代入神经网络进行训练，测试cost  function随着迭代次数增加的变化，根据结果选择cost function最小时对应的超参数值。这类似于validation的方法。</p>
<h3 id="第五章-深度学习的实用层面"><a href="#第五章-深度学习的实用层面" class="headerlink" title="第五章 深度学习的实用层面"></a>第五章 深度学习的实用层面</h3><h4 id="5-1-训练-验证-测试集"><a href="#5-1-训练-验证-测试集" class="headerlink" title="5.1 训练-验证-测试集"></a>5.1 训练-验证-测试集</h4><p>选择最佳的<strong>训练集(Training sets)</strong>、<strong>验证集(Development sets)</strong>、<strong>测试集(Test sets)</strong>对神经网络的性能影响非常重要。除此之外，在构建一个神经网络的时候，需要设置许多参数，例如神经网络的层数、每个隐藏层包含的神经元个数、学习因子(学习速率)、激活函数的选择等等。实际上很难在第一次设置的时候就选择到这些最佳的参数，而是需要通过不断地迭代更新来获得。这个循环迭代的过程是这样的：</p>
<p>(1) 先有个想法Idea，先选择初始的参数值，构建神经网络模型结构；</p>
<p>(2) 然后通过代码Code的形式，实现这个神经网络；</p>
<p>(3) 最后通过实验Experiment验证这些参数对应的神经网络的表现性能。</p>
<p>根据验证结果，我们对参数进行适当的调整优化，再进行下一次的<strong>Idea-&gt;Code-&gt;Experiment</strong>循环。通过很多次的循环，不断调整参数，选定最佳的参数值，从而让神经网络性能最优化。</p>
<p>一般地，我们将所有的样本数据分成三个部分：Train/Dev/Test sets。Train sets用来训练你的算法模型；Dev sets用来验证不同算法的表现情况，从中选择最好的算法模型；Test sets用来测试最好算法的实际表现，作为该算法的无偏估计。</p>
<p>之前人们通常设置Train sets和Test sets的数量比例为70%和30%。如果有Dev sets，则设置比例为60%、20%、20%，分别对应Train/Dev/Test sets。这种比例分配在样本数量不是很大的情况下，例如100,1000,10000，是比较科学的。但是如果数据量很大的时候，例如100万，科学的做法是要将Dev sets和Test sets的比例设置得很低。因为Dev sets的目标是用来比较验证不同算法的优劣，从而选择更好的算法模型就行了。因此，对于大数据样本，Train/Dev/Test sets的比例通常可以设置为98%/1%/1%，或者99%/0.5%/0.5%。样本数据量越大，相应的Dev/Test sets的比例可以设置的越低一些。</p>
<p>现代深度学习还有个重要的问题就是<strong>训练样本和测试样本分布上不匹配</strong>，意思是训练样本和测试样本来自于不同的分布。解决这一问题的比较科学的办法是尽量保证Dev sets和Test sets来自于同一分布。值得一提的是，训练样本非常重要，通常我们可以将现有的训练样本做一些处理，例如<strong>图片的翻转、假如随机噪声等，来扩大训练样本的数量</strong>，从而让该模型更加强大。即使Train sets和Dev/Test sets不来自同一分布，使用这些技巧也能提高模型性能。</p>
<p>最后提一点的是如果<strong>没有Test sets也是没有问题</strong>的。Test sets的目标主要是进行<strong>无偏估计</strong>。我们可以通过Train sets训练不同的算法模型，然后分别在Dev sets上进行验证，根据结果选择最好的算法模型。这样也是可以的，不需要再进行无偏估计了。如果只有Train sets和Dev sets，通常也有人把这里的Dev sets称为Test sets，我们要注意加以区别。</p>
<h4 id="5-2-偏差和方差"><a href="#5-2-偏差和方差" class="headerlink" title="5.2 偏差和方差"></a>5.2 偏差和方差</h4><p>偏差(bias)和方差(Variance)是机器学习领域非常重要的两个概念和需要解决的问题。在传统的机器学习算法中，Bias和Variance是对立的，分别对应着欠拟合和过拟合，我们常常需要在Bias和Variance之间进行权衡。而在深度学习中，我们可以同时减小Bias和Variance，构建最佳神经网络模型。</p>
<p>如下图所示，显示了二维平面上，high bias，just right，high variance的例子。可见，high bias对应着欠拟合，而high variance对应着过拟合。</p>
<p><img src="https://pic.imgdb.cn/item/648acbe91ddac507cc755d84.png"></p>
<p>上图这个例子中输入特征是二维的，high bias和high variance可以直接从图中分类线看出来。而对于输入特征是高维的情况，如何来判断是否出现了high bias或者high variance呢？</p>
<p>例如猫识别问题，输入是一幅图像，其特征维度很大。这种情况下，我们可以通过两个数值<strong>Train set error</strong>和<strong>Dev set error</strong>来理解bias和variance。</p>
<p>(1) 假设Train set error为1%，而Dev set error为11%，即该算法模型对训练样本的识别很好，但是对验证集的识别却不太好。这说明了该模型对训练样本可能存在<strong>过拟合</strong>，模型泛化能力不强，导致验证集识别率低。这恰恰是<strong>high variance</strong>的表现。</p>
<p>(2) 假设Train set error为15%，而Dev set error为16%，虽然二者error接近，即该算法模型对训练样本和验证集的识别都不是太好。这说明了该模型对训练样本存在<strong>欠拟合</strong>。这恰恰是<strong>high bias</strong>的表现。</p>
<p>(3) 假设Train set error为15%，而Dev set error为30%，说明了该模型既存在high bias也存在high variance(深度学习中最坏的情况)。</p>
<p>(4) 假设Train set error为0.5%，而Dev set error为1%，即low bias和low variance，是最好的情况。</p>
<p>值得一提的是，以上的这些假设都是建立在<strong>base error是0</strong>的基础上，即人类都能正确识别所有猫类图片。base error不同，相应的Train set error和Dev set error会有所变化，但没有相对变化。</p>
<p>一般来说，Train set error体现了是否出现bias，Dev set error体现了是否出现variance(正确地说，应该是Dev set error与Train set error的相对差值)。</p>
<p>我们已经通过二维平面展示了high bias或者high variance的模型，下图展示了high bias and high variance的模型：</p>
<p><img src="https://pic.imgdb.cn/item/648acc1c1ddac507cc760c33.png" style="zoom:60%"></p>
<p>模型既存在high bias也存在high variance，可以理解成某段区域是欠拟合的，某段区域是过拟合的。</p>
<h4 id="5-3-机器学习基础"><a href="#5-3-机器学习基础" class="headerlink" title="5.3 机器学习基础"></a>5.3 机器学习基础</h4><p>机器学习中基本的一个诀窍就是<strong>避免出现high bias和high variance</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/648acc6d1ddac507cc771342.png"></p>
<p><img src="https://pic.imgdb.cn/item/648acd391ddac507cc79e747.png" style="zoom:60%"></p>
<p>这里有几点需要注意的。</p>
<p>第一，解决high bias和high variance的方法是不同的。实际应用中通过Train set error和Dev set error判断是否出现了high bias或者high variance，然后再选择针对性的方法解决问题。</p>
<p>第二，Bias和Variance的折中tradeoff。传统机器学习算法中，Bias和Variance通常是对立的，减小Bias会增加Variance，减小Variance会增加Bias。而在现在的深度学习中，通过使用更复杂的神经网络和海量的训练样本，一般能够同时有效减小Bias和Variance。这也是深度学习之所以如此强大的原因之一。</p>
<h4 id="5-4-正则化"><a href="#5-4-正则化" class="headerlink" title="5.4 正则化"></a>5.4 正则化</h4><p>如果出现了过拟合，即high variance，则需要采用正则化regularization来解决。虽然扩大训练样本数量也是减小high variance的一种方法，但是通常获得更多训练样本的成本太高，比较困难。所以，更可行有效的办法就是使用regularization。</p>
<p>回顾一下之前介绍的Logistic regression。采用L2 regularization，其表达式为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
J(w, b)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)+\frac{\lambda}{2 m}\|w\|_{2}^{2} \\
\|w\|_{2}^{2}=\sum_{j=1}^{n_{x}} w_{j}^{2}=w^{T} w
\end{gathered}</script><blockquote>
<p>这里有个问题：<strong>为什么只对w进行正则化而不对b进行正则化呢？</strong>其实也可以对b进行正则化。但是一般w的维度很大，而b只是一个常数。相比较来说，参数很大程度上由w决定，改变b值对整体模型影响较小。所以，一般为了简便，就忽略对b的正则化了。<br>除了L2 regularization之外，还有另外一只正则化方法：L1 regularization。其表达式为：</p>
</blockquote>
<script type="math/tex; mode=display">
\begin{gathered}
J(w, b)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)+\frac{\lambda}{2 m}\|w\|_{1} \\
\|w\|_{1}=\sum_{j=1}^{n_{x}}\left|w_{j}\right|
\end{gathered}</script><p>与L2 regularization相比，L1 regularization得到的<script type="math/tex">w</script><strong>更加稀疏</strong>，即很多<script type="math/tex">w</script>为零值，所以其优点是节约存储空间。但实际L1 regularization在解决high variance方面比L2 regularization并不更具优势。而且L1的在微分求导方面比较复杂。所以，一般L2 regularization更加常用。</p>
<p>L1、L2 regularization中的<strong>λ就是正则化参数(超参数的一种)</strong>。可以设置λ为不同的值，在Dev set中进行验证，选择最佳的λ。顺便提一下，在python中，由于lambda是保留字，所以为了避免冲突，我们使用lambd来表示λ。</p>
<p>在深度学习模型中，L2 regularization的表达式为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
J\left(w^{[1]}, b^{[1]}, \cdots, w^{[L]}, b^{[L]}\right)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)+\frac{\lambda}{2 m} \sum_{l=1}^{L}\left\|w^{[l]}\right\|^{2} \\
\left\|w^{[l]}\right\|^{2}=\sum_{i=1}^{n^{[l]}} \sum_{j=1}^{n^{[l-1]}}\left(w_{i j}^{[l]}\right)^{2}
\end{gathered}</script><p>通常，我们把<script type="math/tex">||w^{[l]}||^2</script>称为Frobenius范数，记为<script type="math/tex">||w^{[l]}||^2_F</script>。一个矩阵的Frobenius范数就是计算所有元素平方和再开方，如下所示：</p>
<script type="math/tex; mode=display">
\|A\|_{F}=\sqrt{\sum_{i=1}^{m} \sum_{j=1}^{n}\left|a_{i j}\right|^{2}}</script><p>值得注意的是，由于加入了正则化项，梯度下降算法中的<script type="math/tex">dw^{[l]}</script>计算表达式需要做如下修改：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathrm d w^{[l]}=\mathrm d w_{\text {before }}^{[l]}+\frac{\lambda}{m} w^{[l]} \\w^{[l]}:=w^{[l]}-\alpha \cdot d w^{[l]}
\end{gathered}</script><p>L2 regularization也被称做<strong>权重衰减(weight decay)</strong>。这是因为，由于加上了正则项，<script type="math/tex">\mathrm  dw^{[l]}</script>有个增量，在更新<script type="math/tex">w^{[l]}</script>的时候，会多减去这个增量，使得<script type="math/tex">w^{[l]}</script>比没有正则项的值要小一些。不断迭代更新，不断地减小。</p>
<script type="math/tex; mode=display">
\begin{aligned}
w^{[l]} &:=w^{[l]}-\alpha \cdot \mathrm d w^{[l]} \\
&=w^{[l]}-\alpha \cdot\left(\mathrm d w_{\mathrm{befor} e}^{[l]}+\frac{\lambda}{m} w^{[l]}\right) \\
&=\left(1-\alpha \frac{\lambda}{m}\right) w^{[l]}-\alpha \cdot\mathrm d w_\mathrm{befor}^{[l]}
\end{aligned}</script><p>其中，<script type="math/tex">1-\alpha \frac{\lambda}{m}<1</script></p>
<h4 id="5-5-为什么正则化可以减少过拟合"><a href="#5-5-为什么正则化可以减少过拟合" class="headerlink" title="5.5 为什么正则化可以减少过拟合"></a>5.5 为什么正则化可以减少过拟合</h4><p>为什么正则化能够有效避免high variance，防止过拟合呢？下面通过几个例子说明。</p>
<p>还是之前那张图，从左到右，分别表示了欠拟合，刚好拟合，过拟合三种情况。</p>
<p><img src="https://pic.imgdb.cn/item/648acd901ddac507cc7b0e77.png"></p>
<p>假如我们选择了非常复杂的神经网络模型，如上图左上角所示。在未使用正则化的情况下，我们得到的分类超平面可能是类似上图右侧的过拟合。但是，如果使用L2 regularization，当<em>λ</em>很大时，<script type="math/tex">w^{[l]}≈0</script>意味着该神经网络模型中的某些神经元实际的作用很小，可以忽略。从效果上来看，其实是将某些神经元给忽略掉了。这样原本过于复杂的神经网络模型就变得不那么复杂了，而变得非常简单化了。如下图所示，整个简化的神经网络模型变成了一个逻辑回归模型。问题就从high  variance变成了high bias了。</p>
<p><img src="https://pic.imgdb.cn/item/648acda91ddac507cc7b514b.png" style="zoom:40%"></p>
<p>因此，选择合适大小的<script type="math/tex">\lambda</script>值，就能够同时避免high bias和high variance，得到最佳模型。</p>
<p>还有另外一个直观的例子来解释为什么正则化能够避免发生过拟合。假设激活函数是tanh函数。tanh函数的特点是在<script type="math/tex">z</script>接近零的区域，函数近似是线性的，而当<script type="math/tex">|z|</script>很大的时候，函数非线性且变化缓慢。当使用正则化，<script type="math/tex">\lambda</script>较大，即对权重<script type="math/tex">w^{[l]}</script>的<strong>惩罚较大</strong>，<script type="math/tex">w^{[l]}</script>减小。因为<script type="math/tex">z^{[l]}=w^{[l]}a^{[l]}+b^{[l]}</script>。当<script type="math/tex">w^{[l]}</script>减小的时候，<script type="math/tex">z^{[l]}</script>也会减小。则此时的<script type="math/tex">z^{[l]}</script>分布在tanh函数的近似线性区域。那么这个神经元起的作用就相当于是<strong>linear regression</strong>。如果每个神经元对应的权重<script type="math/tex">w^{[l]}</script>都比较小，那么整个神经网络模型相当于是多个linear regression的组合，即可看成一个linear network。得到的分类超平面就会比较简单，不会出现过拟合现象。</p>
<p><img src="https://pic.imgdb.cn/item/648acdfa1ddac507cc7c246d.png" style="zoom:60%"></p>
<h4 id="5-6-Dropout-正则化"><a href="#5-6-Dropout-正则化" class="headerlink" title="5.6 Dropout 正则化"></a>5.6 <strong>Dropout 正则化</strong></h4><p>除了L2 regularization之外，还有另外一种防止过拟合的有效方法：Dropout。</p>
<p>Dropout是指在深度学习网络的训练过程中，对于每层的神经元，按照一定的概率将其暂时从网络中丢弃。也就是说，每次训练时，每一层都有部分神经元不工作，起到简化复杂网络模型的效果，从而避免发生过拟合。</p>
<p><img src="https://pic.imgdb.cn/item/648ace5a1ddac507cc7d6ab8.png" style="zoom:60%"></p>
<p>Dropout有不同的实现方法，接下来介绍一种常用的方法：<strong>Inverted dropout</strong>。假设对于第<script type="math/tex">l</script>层神经元，设定保留神经元比例概率keep_prob=0.8，即该层有20%的神经元停止工作。<script type="math/tex">dl</script>为dropout向量，设置<script type="math/tex">dl</script>为随机vector，其中80%的元素为1，20%的元素为0。在python中可以使用如下语句生成dropout vector：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dl = np.random.rand(al.shape[<span class="number">0</span>],al.shape[<span class="number">1</span>])&lt;keep_prob</span><br></pre></td></tr></table></figure>
<p>然后，第<script type="math/tex">l</script>层经过dropout，随机删减20%的神经元，只保留80%的神经元，其输出为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">al = np.multiply(al,dl)</span><br></pre></td></tr></table></figure>
<p>最后，还要对<script type="math/tex">al</script>进行scale up处理，即：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">al /= keep_prob</span><br></pre></td></tr></table></figure>
<p>以上就是Inverted dropout的方法。之所以要对<script type="math/tex">al</script>进行scale up是为了保证在经过dropout后，<script type="math/tex">al</script><strong>作为下一层神经元的输入值尽量保持不变</strong>。假设第<script type="math/tex">l</script>层有50个神经元，经过dropout后，有10个神经元停止工作，这样只有40神经元有作用。那么得到的<script type="math/tex">al</script>只相当于原来的80%。scale up后，能够尽可能保持<script type="math/tex">al</script>的期望值相比之前没有大的变化。</p>
<p>Inverted dropout的另外一个好处就是在对该dropout后的神经网络进行测试时能够减少scaling问题。因为在训练时，使用scale up保证<script type="math/tex">al</script>的期望值没有大的变化，测试时就不需要再对样本数据进行类似的尺度伸缩操作了。</p>
<p>对于<script type="math/tex">m</script>个样本，单次迭代训练时，随机删除掉隐藏层一定数量的神经元；然后，在删除后的剩下的神经元上正向和反向更新权重w和常数项b；接着，下一次迭代中，再恢复之前删除的神经元，重新随机删除一定数量的神经元，进行正向和反向更新w和b。不断重复上述过程，直至迭代训练完成。</p>
<p><strong>值得注意的是，使用dropout训练结束后，在测试和实际应用模型时，不需要进行dropout和随机删减神经元，所有的神经元都在工作。</strong></p>
<h4 id="5-7-理解Dropout"><a href="#5-7-理解Dropout" class="headerlink" title="5.7 理解Dropout"></a>5.7 理解Dropout</h4><p>Dropout通过每次迭代训练时，随机选择不同的神经元，相当于每次都在不同的神经网络上进行训练，类似机器学习中Bagging的方法(三个臭皮匠，赛过诸葛亮)，能够防止过拟合。</p>
<p>除此之外，还可以从权重<script type="math/tex">w</script>的角度来解释为什么dropout能够有效防止过拟合。对于某个神经元来说，某次训练时，它的某些输入在dropout的作用被过滤了。而在下一次训练时，又有不同的某些输入被过滤。经过多次训练后，某些输入被过滤，某些输入被保留。这样，该神经元就不会受某个输入非常大的影响，影响被均匀化了。也就是说，对应的权重<script type="math/tex">w</script>不会很大。这从从效果上来说，与L2 regularization是类似的，都是对权重<script type="math/tex">w</script>进行“惩罚”，减小了<script type="math/tex">w</script>的值。</p>
<p><img src="https://pic.imgdb.cn/item/648acec31ddac507cc7f27dd.png"></p>
<p>总结一下，对于同一组训练数据，利用不同的神经网络训练之后，求其输出的平均值可以减少overfitting。Dropout就是利用这个原理，每次丢掉一定数量的隐藏层神经元，<strong>相当于在不同的神经网络上进行训练</strong>，这样就<strong>减少了神经元之间的依赖性</strong>，即每个神经元不能依赖于某几个其他的神经元(指层与层之间相连接的神经元)，使神经网络更加能学习到与其他神经元之间的更加健壮robust的特征。</p>
<p>在使用dropout的时候，有几点需要注意。</p>
<p>(1) 不同隐藏层的dropout系数keep_prob可以不同。一般来说，神经元越多的隐藏层，keep_out可以设置得小一些，例如0.5；神经元越少的隐藏层，keep_out可以设置的大一些，例如0.8，设置是1。</p>
<p>(2) 实际应用中，不建议对输入层进行dropout，如果输入层维度很大，例如图片，那么可以设置dropout，但keep_out应设置的大一些，例如0.8，0.9。</p>
<p>总体来说，就是越容易出现overfitting的隐藏层，其keep_prob就设置的相对小一些。没有准确固定的做法，通常可以根据validation进行选择。</p>
<p>Dropout在电脑视觉CV领域应用比较广泛，因为输入层维度较大，而且没有足够多的样本数量。值得注意的是dropout是一种regularization技巧，用来防止过拟合的，最好只在需要regularization的时候使用dropout。</p>
<p>使用dropout的时候，可以通过绘制cost function来进行debug，看看dropout是否正确执行。一般做法是，将所有层的keep_prob全设置为1，再绘制cost function，即涵盖所有神经元，看<script type="math/tex">J</script>是否单调下降。下一次迭代训练时，再将keep_prob设置为其它值。</p>
<h4 id="5-8-其他正则化方法"><a href="#5-8-其他正则化方法" class="headerlink" title="5.8 其他正则化方法"></a>5.8 其他正则化方法</h4><p>除了L2 regularization和dropout regularization之外，还有其它减少过拟合的方法。</p>
<ul>
<li><strong>增加训练样本数量</strong><br>但是通常成本较高，难以获得额外的训练样本。但是，我们可以对已有的训练样本进行一些处理来“制造”出更多的样本，称为data augmentation。例如图片识别问题中，可以对已有的图片进行水平翻转、垂直翻转、任意角度旋转、缩放或扩大等等。如下图所示，这些处理都能“制造”出新的训练样本。虽然这些是基于原有样本的，但是对增大训练样本数量还是有很有帮助的，不需要增加额外成本，却能起到防止过拟合的效果。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/648acefc1ddac507cc800831.png"></p>
<p>在数字识别中，也可以将原有的数字图片进行任意旋转或者扭曲，或者增加一些noise，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648acf2b1ddac507cc80def8.png"></p>
<ul>
<li><p><strong>early stopping</strong></p>
<p>一个神经网络模型随着迭代训练次数增加，train set error一般是单调减小的，而dev set error 先减小，之后又增大。也就是说训练次数过多时，模型会对训练样本拟合的越来越好，但是对验证集拟合效果逐渐变差，即发生了过拟合。因此，迭代训练次数不是越多越好，可以通过train set error和dev set error随着迭代次数的变化趋势，选择合适的迭代次数，即early stopping。</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/648ad1d81ddac507cc8a8a35.png" style="zoom:60%"></p>
<p>然而，Early stopping有其自身缺点。通常来说，机器学习训练模型有两个目标：</p>
<p>一是优化cost function，尽量减小<script type="math/tex">J</script>；</p>
<p>二是防止过拟合。</p>
<p>这两个目标彼此对立的，即<strong>减小</strong><script type="math/tex">J</script><strong>的同时可能会造成过拟合</strong>，反之亦然。我们把这二者之间的关系称为正交化(orthogonalization)。该节课开始部分就讲过，在深度学习中，我们可以同时减小Bias和Variance，构建最佳神经网络模型。但是，Early stopping的做法通过减少得带训练次数来防止过拟合，这样<script type="math/tex">J</script>就不会足够小。也就是说，early stopping将上述两个目标融合在一起，同时优化，但可能没有“分而治之”的效果好。</p>
<p>与early stopping相比，<strong>L2 regularization可以实现“分而治之”的效果</strong>：迭代训练足够多，减小<script type="math/tex">J</script>，而且也能有效防止过拟合。而L2 regularization的缺点之一是最优的正则化参数<script type="math/tex">\lambda</script>的选择比较复杂。对这一点来说，early stopping比较简单。总的来说，L2 regularization更加常用一些。</p>
<h4 id="5-9-归一化输入"><a href="#5-9-归一化输入" class="headerlink" title="5.9 归一化输入"></a>5.9 归一化输入</h4><p>在训练神经网络时，标准化输入可以提高训练的速度。标准化输入就是对训练数据集进行归一化的操作，即将原始数据减去其均值<script type="math/tex">\mu</script>后，再除以其方差<script type="math/tex">σ^2</script>：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mu=\frac{1}{m} \sum_{i=1}^{m} X^{(i)} \\
\sigma^{2}=\frac{1}{m} \sum_{i=1}^{m}\left(X^{(i)}\right)^{2} \\
X:=\frac{X-\mu}{\sigma^{2}}
\end{gathered}</script><p>以二维平面为例，下图展示了其归一化过程：</p>
<p><img src="https://pic.imgdb.cn/item/648ad21a1ddac507cc8b622e.png"></p>
<p>值得注意的是，由于训练集进行了标准化处理，那么对于测试集或在实际应用时，应该使用同样的<script type="math/tex">\mu</script>和<script type="math/tex">σ^{2}</script>对其进行标准化处理。这样保证了训练集合测试集的标准化操作一致。</p>
<p>之所以要对输入进行标准化操作，主要是为了让所有<strong>输入归一化同样的尺度上</strong>，方便进行梯度下降算法时能够更快更准确地找到全局最优解。假如输入特征是二维的，且<script type="math/tex">x_1</script>的范围是<script type="math/tex">[1,1000]</script>，<script type="math/tex">x_2</script>的范围是<script type="math/tex">[0,1]</script>。如果不进行标准化处理，<script type="math/tex">x_1</script>与<script type="math/tex">x_2</script>之间分布极不平衡，训练得到的<script type="math/tex">w_1</script>和<script type="math/tex">w_2</script>也会在数量级上差别很大。这样导致的结果是cost  function与<script type="math/tex">w</script>和<script type="math/tex">b</script>的关系可能是一个非常细长的椭圆形碗。对其进行梯度下降算法时，由于<script type="math/tex">w_1</script>和<script type="math/tex">w_2</script>数值差异很大，只能选择很小的学习因子<script type="math/tex">\alpha</script>，来避免<script type="math/tex">J</script>发生振荡。一旦<script type="math/tex">\alpha</script>较大，必然发生振荡，<script type="math/tex">J</script>不再单调下降。如下左图所示。</p>
<p>然而，如果进行了标准化操作，<script type="math/tex">x_1</script>与<script type="math/tex">x_2</script>分布均匀，<script type="math/tex">w_1</script>和<script type="math/tex">w_2</script>数值差别不大，得到的cost function与<script type="math/tex">w</script>和<script type="math/tex">b</script>的关系是类似圆形碗。对其进行梯度下降算法时，<script type="math/tex">\alpha</script>可以选择相对大一些，且<script type="math/tex">J</script>一般不会发生振荡，保证了<script type="math/tex">J</script>是单调下降的。如下右图所示。</p>
<p><img src="https://pic.imgdb.cn/item/648ad2621ddac507cc8c5469.png"></p>
<p>另外一种情况，如果输入特征之间的范围本来就比较接近，那么不进行标准化操作也是没有太大影响的。但是，标准化处理在大多数场合下还是值得推荐的。</p>
<p>本小节参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012768474/article/details/99871942">标准化和归一化的区别</a></p>
<h4 id="5-10-梯度消失与梯度爆炸"><a href="#5-10-梯度消失与梯度爆炸" class="headerlink" title="5.10 梯度消失与梯度爆炸"></a>5.10 梯度消失与梯度爆炸</h4><p>在神经网络尤其是深度神经网络中存在可能存在这样一个问题：梯度消失和梯度爆炸。意思是当训练一个层数非常多的神经网络时，计算得到的梯度可能非常小或非常大，甚至是指数级别的减小或增大。这样会让训练过程变得非常困难。</p>
<p>举个例子来说明，假设一个多层的每层只包含两个神经元的深度神经网络模型，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648ad2b81ddac507cc8d5d7a.png"></p>
<p>为了简化复杂度便于分析，我们令各层的激活函数为线性函数，即<script type="math/tex">g(Z)=Z</script>。且忽略各层常数项<script type="math/tex">b</script>的影响，令<script type="math/tex">b</script>全部为零。那么，该网络的预测输出<script type="math/tex">\hat Y</script>为：</p>
<script type="math/tex; mode=display">
\hat{Y}=W^{[L]} W^{[L-1]} W^{[L-2]} \ldots W^{[3]} W^{[2]} W^{[1]} X</script><p>如果各层权重<script type="math/tex">W^{[l]}</script>的元素都稍大于<script type="math/tex">1</script>，例如<script type="math/tex">1.5</script>，则预测输出<script type="math/tex">\hat Y</script>将正比于<script type="math/tex">1.5^L</script>。<script type="math/tex">L</script>越大，<script type="math/tex">\hat Y</script>越大，且呈指数型增长。我们称之为数值爆炸。相反，如果各层权重<script type="math/tex">W^{[l]}</script>的元素都稍小于<script type="math/tex">1</script>，例如<script type="math/tex">0.5</script>，则预测输出<script type="math/tex">\hat Y</script>将正比于<script type="math/tex">0.5^L</script>。网络层数<script type="math/tex">L</script>越多，<script type="math/tex">\hat Y</script>呈指数型减小。我们称之为数值消失。</p>
<p>也就是说，如果各层权重<script type="math/tex">W^{[l]}</script>都大于<script type="math/tex">1</script>或者都小于<script type="math/tex">1</script>，那么各层激活函数的输出将随着层数<script type="math/tex">l</script>的增加，呈指数型增大或减小。当层数很大时，出现数值爆炸或消失。同样，这种情况也会引起梯度呈现同样的指数型增大或减小的变化。<script type="math/tex">L</script>非常大时，例如<script type="math/tex">L=150</script>，则梯度会非常大或非常小，引起每次更新的步进长度过大或者过小，这让训练过程十分困难。</p>
<h4 id="5-11-神经网络的初始化权重"><a href="#5-11-神经网络的初始化权重" class="headerlink" title="5.11 神经网络的初始化权重"></a>5.11 神经网络的初始化权重</h4><p>下面介绍如何改善Vanishing and Exploding gradients这类问题，方法是对权重<script type="math/tex">w</script>进行一些初始化处理。</p>
<p>深度神经网络模型中，以单个神经元为例，该层(<script type="math/tex">l</script><em>)</em>的输入个数为<script type="math/tex">n</script>，其输出为：</p>
<script type="math/tex; mode=display">
\begin{gathered}z=w_{1} x_{1}+w_{2} x_{2}+\cdots+w_{n} x_{n} \\a=g(z)\end{gathered}</script><p><img src="https://pic.imgdb.cn/item/648ad35d1ddac507cc902cab.png" style="zoom:40%"></p>
<p>这里忽略了常数项<script type="math/tex">b</script>。为了让<script type="math/tex">z</script>不会过大或者过小，由上面的式子可以有思路是<strong>让</strong><script type="math/tex">w</script><strong>与</strong><script type="math/tex">n</script><strong>有关，且</strong><script type="math/tex">n</script><strong>越大，</strong><script type="math/tex">w</script><strong>应该越小才好</strong>。这样能够保证<script type="math/tex">z</script>不会过大。一种方法是在初始化时，控制<script type="math/tex">w</script>的方差。</p>
<p>(1) 如果激活函数是tanh，<strong>令</strong><script type="math/tex">w</script><strong>方差为</strong><script type="math/tex">1/n</script>;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w[l] = np.random.randn(n[l],n[l-<span class="number">1</span>])*np.sqrt(<span class="number">1</span>/n[l-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>(2) 如果激活函数是ReLU，<strong>令</strong><script type="math/tex">w</script><strong>方差为</strong><script type="math/tex">2/n</script>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w[l] = np.random.randn(n[l],n[l-<span class="number">1</span>])*np.sqrt(<span class="number">2</span>/n[l-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>除此之外，Yoshua Bengio提出了另外一种初始化w的方法，令其方差为<script type="math/tex">\frac{2}{n^{[l−1]}n^{[l]}}</script>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w[l] = np.random.randn(n[l],n[l-<span class="number">1</span>])*np.sqrt(<span class="number">2</span>/n[l-<span class="number">1</span>]*n[l])</span><br></pre></td></tr></table></figure>
<p>至于选择哪种初始化方法因人而异，可以根据不同的激活函数选择不同方法。另外，我们可以对这些初始化方法中设置某些参数，作为超参数，通过验证集进行验证，得到最优参数，来优化神经网络。</p>
<h4 id="5-12-梯度的数值逼近"><a href="#5-12-梯度的数值逼近" class="headerlink" title="5.12  梯度的数值逼近"></a>5.12  梯度的数值逼近</h4><p>Back Propagation神经网络有一项重要的测试是<strong>梯度检查(gradient checking)</strong>。其目的是检查验证反向传播过程中梯度下降算法是否正确。该小节将先介绍如何近似求出梯度值。</p>
<p><img src="https://pic.imgdb.cn/item/648ad5d11ddac507cc9a3d8a.png" style="zoom:70%"></p>
<p>利用微分思想，函数<script type="math/tex">f</script>在点<script type="math/tex">θ</script>处的梯度可以表示成：</p>
<script type="math/tex; mode=display">
\frac{\mathrm df}{\mathrm d\theta} = \lim_{\varepsilon \rightarrow 0}\frac{f(\theta+\varepsilon)-f(\theta-\varepsilon)}{2\varepsilon}</script><p>其中，<script type="math/tex">\varepsilon>0</script>且足够小。</p>
<h4 id="5-13-梯度检验"><a href="#5-13-梯度检验" class="headerlink" title="5.13 梯度检验"></a>5.13 梯度检验</h4><p>介绍完如何近似求出梯度值后，我们将介绍如何进行梯度检查，来验证训练过程中是否出现bugs。</p>
<p>梯度检查首先要做的是分别将<script type="math/tex">W^{[1]}, b^{[1]}, \ldots, W^{[L]}, b^{[L]}</script>这些矩阵构造成一维向量，然后将这些一维向量组合起来构成一个更大的一维向量<script type="math/tex">\theta</script>，这样cost function<script type="math/tex">J(W^{[1]}, b^{[1]}, \cdots, W^{[L]}, b^{[L]})</script>就可以表示成<script type="math/tex">J(\theta)</script>。</p>
<p>然后将反向传播过程通过梯度下降算法得到的<script type="math/tex">\mathrm d W^{[1]}, \mathrm d b^{[1]}, \cdots, \mathrm d W^{[L]}, \mathrm d b^{[L]}</script>按照一样的顺序构造成一个一维向量<script type="math/tex">\mathrm d\theta</script>(与<script type="math/tex">\theta</script>维度相同)。</p>
<p>接着利用<script type="math/tex">J(θ)</script>对每个<script type="math/tex">θ_i</script>计算近似梯度，其值与反向传播算法得到的<script type="math/tex">dθ_i</script>相比较，检查是否一致。例如，对于第<script type="math/tex">i</script>个元素，近似梯度为：</p>
<script type="math/tex; mode=display">
\mathrm d \theta_{\operatorname{approx}}[i]=\frac{J\left(\theta_{1}, \theta_{2}, \cdots, \theta_{i}+\varepsilon, \cdots\right)-J\left(\theta_{1}, \theta_{2}, \cdots, \theta_{i}-\varepsilon, \cdots\right)}{2 \varepsilon}</script><p>计算完所有<script type="math/tex">θ_i</script>的近似梯度后，可以计算<script type="math/tex">\mathrm dθ_{\text {approx}}</script>与<script type="math/tex">dθ</script>的<strong>欧氏(Euclidean)距离</strong>来比较二者的相似度。公式如下：</p>
<script type="math/tex; mode=display">
\frac{\left\| \mathrm d \theta_{\text {approx }}-\mathrm d \theta\right\|_{2}}{\left\|\mathrm d \theta_{\text {approx }}\right\|_{2}+\|\mathrm d \theta\|_{2}}</script><p>一般来说，若欧氏距离越小，例如<script type="math/tex">10^{−7}</script>甚至更小，则表明<script type="math/tex">\mathrm dθ_{\text {approx}}</script>与<script type="math/tex">dθ</script>越接近，即反向梯度计算是正确的，没有bugs。若欧氏距离较大，例如<script type="math/tex">10^{−5}</script>，则表明梯度计算可能出现问题，需要再次检查是否有bugs存在。若欧氏距离很大，例如<script type="math/tex">10^{−3}</script>，甚至更大，则表明<script type="math/tex">\mathrm dθ_{\text {approx}}</script>与<script type="math/tex">\mathrm dθ</script>差别很大，梯度下降计算过程有bugs，需要仔细检查。</p>
<h4 id="5-14-关于梯度检验实现的注记"><a href="#5-14-关于梯度检验实现的注记" class="headerlink" title="5.14 关于梯度检验实现的注记"></a>5.14 关于梯度检验实现的注记</h4><p>在进行梯度检查的过程中有几点需要注意的地方：</p>
<ul>
<li><strong>不要在整个训练过程中都进行梯度检查，仅仅作为debug使用。</strong></li>
<li><strong>如果梯度检查出现错误，找到对应出错的梯度，检查其推导是否出现错误。</strong></li>
<li><strong>注意不要忽略正则化项，计算近似梯度的时候要包括进去。</strong></li>
<li><strong>梯度检查时关闭dropout，检查完毕后再打开dropout。</strong></li>
<li><strong>随机初始化时运行梯度检查，经过一些训练后再进行梯度检查（不常用）。</strong></li>
</ul>
<h3 id="第六章-优化算法"><a href="#第六章-优化算法" class="headerlink" title="第六章 优化算法"></a>第六章 优化算法</h3><h4 id="6-1-Mini-batch-梯度下降法"><a href="#6-1-Mini-batch-梯度下降法" class="headerlink" title="6.1 Mini-batch 梯度下降法"></a><strong>6.1 Mini-batch 梯度下降法</strong></h4><p>之前介绍的神经网络训练过程是对所有<script type="math/tex">m</script>个样本，称为<strong>batch</strong>，通过向量化计算方式，同时进行的。如果<script type="math/tex">m</script>很大，例如达到百万数量级，训练速度往往会很慢，因为每次迭代都要对所有样本进行进行求和运算和矩阵运算。我们将这种梯度下降算法称为<strong>Batch  Gradient Descent</strong>。</p>
<p>为了解决这一问题，我们可以把<script type="math/tex">m</script>个训练样本分成若干个子集，称为<strong>mini-batches</strong>，这样每个子集包含的数据量就小了，例如只有1000，然后每次在单一子集上进行神经网络训练，速度就会大大提高。这种梯度下降算法叫做<strong>Mini-batch Gradient Descent</strong>。</p>
<p>假设总的训练样本个数<script type="math/tex">m=5000000</script>，其维度为<script type="math/tex">(n_x,m)</script>。将其分成<script type="math/tex">5000</script>个子集，每个mini-batch含有<script type="math/tex">1000</script>个样本。我们将每个mini-batch记为<script type="math/tex">X^{\{ t \}}</script>，其维度为<script type="math/tex">(n_x,1000)</script>。相应的每个mini-batch的输出记为<script type="math/tex">Y^{\{ t \}}</script>，其维度为<script type="math/tex">(1,1000)</script>，且<script type="math/tex">t=1,2,⋯,5000</script>。</p>
<p>这里顺便总结一下我们遇到的神经网络中几类字母的上标含义：</p>
<ul>
<li>$X^{(i)}$<strong>：第</strong>$i$<strong>个样本</strong></li>
<li>$Z^{[l]}$<strong>：神经网络第</strong>$l$<strong>层网络的线性输出</strong></li>
<li>$X^{\{t\}},Y^{\{t\}}$<strong>：第</strong>$t$<strong>组mini-batch</strong></li>
</ul>
<p>ini-batches Gradient Descent的实现过程是先将总的训练样本分成<script type="math/tex">T​</script>个子集(mini-batches)，然后对每个mini-batch进行神经网络训练，包括Forward Propagation，Compute Cost Function，Backward Propagation，循环至<script type="math/tex">T​</script>个mini-batch都训练完毕。</p>
<p><img src="https://pic.imgdb.cn/item/648adc111ddac507ccae58b0.png" style="zoom:70%"></p>
<p>经过<script type="math/tex">T</script>次循环之后，所有<script type="math/tex">m</script>个训练样本都进行了梯度下降计算。这个过程，我们称之为经历了一个<strong>epoch</strong>。对于Batch Gradient Descent而言，一个epoch只进行一次梯度下降算法；而Mini-Batches Gradient Descent，一个epoch会进行<script type="math/tex">T</script>次梯度下降算法。</p>
<p>值得一提的是，对于Mini-Batches Gradient Descent，可以进行多次epoch训练。而且，每次epoch，最好是将总体训练数据<strong>重新打乱</strong>、<strong>重新分成</strong><script type="math/tex">T</script><strong>组</strong>mini-batches，这样有利于训练出最佳的神经网络模型。</p>
<h4 id="6-2-理解Mini-batch-梯度下降法"><a href="#6-2-理解Mini-batch-梯度下降法" class="headerlink" title="6.2 理解Mini-batch 梯度下降法"></a>6.2 理解<strong>Mini-batch 梯度下降法</strong></h4><p>Batch gradient descent和Mini-batch gradient descent的cost曲线如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648add1e1ddac507ccb1c568.png"></p>
<p>对于一般的神经网络模型，使用Batch gradient descent，随着迭代次数增加，cost是不断减小的。然而，使用Mini-batch gradient descent，随着在不同的mini-batch上迭代训练，其cost不是单调下降，而是受类似noise的影响，出现振荡。但整体的趋势是下降的，最终也能得到较低的cost值。</p>
<p>之所以出现细微振荡的原因是不同的mini-batch之间是有差异的。例如可能第一个子集<script type="math/tex">(X^{\{1\}},Y^{\{1\}})</script>是好的子集，而第二个子集<script type="math/tex">(X^{\{2\}},Y^{\{2\}})</script>包含了一些噪声noise。出现细微振荡是正常的。</p>
<p>如何选择每个mini-batch的大小，即包含的样本个数呢？有两个极端：</p>
<p>(1) 如果mini-batch size=m，即为Batch gradient descent，只包含一个子集为<script type="math/tex">(X^{\{1\}},Y^{\{1\}}) = (X,Y)</script>；</p>
<p>(2) 如果mini-batch size=1，即为Stachastic gradient descent，每个样本就是一个子集<script type="math/tex">(X^{\{1\}},Y^{\{1\}}) = (x^{(i)},y^{(i)})</script>，共有<script type="math/tex">m</script>个子集。</p>
<p>我们来比较一下Batch gradient descent和Stachastic gradient  descent的梯度下降曲线。如下图所示，蓝线代表Batch gradient descent，紫线代表Stachastic  gradient descent。Batch gradient  descent会比较平稳地接近全局最小值，但是因为使用了所有<script type="math/tex">m</script>个样本，每次前进的速度有些慢。Stachastic gradient  descent每次前进速度很快，但是路线曲折，有较大的振荡，最终会在最小值附近来回波动，难以真正达到最小值处。而且在数值处理上就不能使用向量化的方法来提高运算速度。</p>
<p><img src="https://pic.imgdb.cn/item/648add4a1ddac507ccb24ba3.png" style="zoom:50%"></p>
<p>实际使用中，mini-batch size不能设置得太大(Batch gradient descent)，也不能设置得太小(Stachastic gradient descent)。这样，相当于结合了Batch gradient descent和Stachastic gradient descent各自的优点，既能使用向量化优化算法，又能叫快速地找到最小值。mini-batch gradient descent的梯度下降曲线如下图绿色所示，每次前进速度较快，且振荡较小，基本能接近全局最小值。</p>
<p><img src="https://pic.imgdb.cn/item/648add6c1ddac507ccb2b3fe.png" style="zoom:50%"></p>
<p>一般来说，如果总体样本数量<script type="math/tex">m</script>不太大时，例如<script type="math/tex">m≤2000</script>，建议直接使用Batch  gradient descent。如果总体样本数量<script type="math/tex">m</script>很大时，建议将样本分成许多mini-batches。推荐常用的mini-batch  size为<script type="math/tex">64</script>,<script type="math/tex">128</script>,<script type="math/tex">256</script>,<script type="math/tex">512</script>。这些都是<strong>2的幂</strong>。之所以这样设置的原因是计算机存储数据一般是2的幂，这样设置可以提高运算速度。</p>
<p>本小节参考链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/501172146/answer/2247473794">关于Mini-batch梯度下降法的困惑，为什么会比批量梯度下降法快？</a></p>
<h4 id="6-3-指数加权平均"><a href="#6-3-指数加权平均" class="headerlink" title="6.3 指数加权平均"></a>6.3 指数加权平均</h4><p>举个例子，记录半年内伦敦市的气温变化，并在二维平面上绘制出来，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648addbb1ddac507ccb3a2ad.png"></p>
<p>看上去，温度数据似乎有noise，而且抖动较大。如果我们希望看到半年内气温的整体变化趋势，可以通过移动平均（moving average）的方法来对每天气温进行平滑处理。</p>
<p>例如我们可以设<script type="math/tex">V_0=0</script>，当成第<script type="math/tex">0</script>天的气温值。</p>
<p>第一天的气温与第<script type="math/tex">0</script>天的气温有关：</p>
<script type="math/tex; mode=display">
V_{1}=0.9 V_{0}+0.1 \theta_{1}</script><p>第二天的气温与第一天的气温有关：</p>
<script type="math/tex; mode=display">
\begin{aligned}
V_{2} &=0.9 V_{1}+0.1 \theta_{2} \\
&=0.9\left(0.9 V_{0}+0.1 \theta_{1}\right)+0.1 \theta_{2} \\
&=0.9^{2} V_{0}+0.9 \cdot 0.1 \theta_{1}+0.1 \theta_{2}
\end{aligned}</script><p>即第<script type="math/tex">t</script>天与第<script type="math/tex">t-1</script>天的气温迭代关系为：</p>
<script type="math/tex; mode=display">
\begin{aligned}V_{t} &=0.9 V_{t-1}+0.1 \theta_{t} \\&=0.9^{t} V_{0}+0.9^{t-1} \cdot 0.1 \theta_{1}+0.9^{t-2} \cdot 0.1 \theta_{2}+\cdots+0.9 \cdot 0.1 \theta_{t-1}+0.1 \theta_{t}\end{aligned}</script><p>经过移动平均处理得到的气温如下图红色曲线所示：</p>
<p><img src="https://pic.imgdb.cn/item/648adf601ddac507ccb8d5ff.png"></p>
<p>这种<strong>滑动平均算法</strong>称为<strong>指数加权平均(exponentially weighted average)</strong>。根据之前的推导公式，其一般形式为：</p>
<script type="math/tex; mode=display">
V_t = (1-\beta)V_{t-1}+\beta \theta_t</script><p>上面的例子中<script type="math/tex">β=0.9</script>。<script type="math/tex">\beta</script><strong>值决定了指数加权平均的天数</strong>，近似表示为：</p>
<script type="math/tex; mode=display">
\frac{1}{1-\beta}</script><p>例如，<script type="math/tex">β=0.9</script>，则<script type="math/tex">1/(1−β)=10</script>，表示将前<script type="math/tex">10</script>天进行指数加权平均。<script type="math/tex">β=0.98</script>，则<script type="math/tex">1/(1−β)=50</script>，表示将前<script type="math/tex">50</script>天进行指数加权平均。<script type="math/tex">\beta</script><strong>越大</strong>，则指数加权平均的天数<strong>越多</strong>，平均后的趋势线就<strong>越平缓</strong>，但是同时也会向右平移。下图绿色曲线和黄色曲线分别表示了<script type="math/tex">β=0.98</script>和<script type="math/tex">β=0.5</script>时，指数加权平均的结果。</p>
<p><img src="https://pic.imgdb.cn/item/648ae02f1ddac507ccbb94b6.png"></p>
<p>这里简单解释一下公式<script type="math/tex">1/{(1−β)}</script>是怎么来的。准确来说，指数加权平均算法跟之前所有天的数值都有关系，根据之前的推导公式就能看出。但是指数是衰减的，<strong>一般认为衰减到</strong><script type="math/tex">1/e</script><strong>就可以忽略不计了</strong>。因此，根据之前的推导公式，我们只要证明</p>
<script type="math/tex; mode=display">
\beta^{\frac{1}{1-\beta}} = \frac1e</script><p>令<script type="math/tex">\dfrac{1}{1-\beta}=N, N>0</script>，则<script type="math/tex">\beta=1-\dfrac{1}{N}, \dfrac{1}{N}<1</script>。即证明转化为：</p>
<script type="math/tex; mode=display">
\left(1-\frac{1}{N}\right)^{N}=\frac{1}{e}</script><p>显然，当<script type="math/tex">N>>0</script>时，上述等式是近似成立的。至此，简单解释了为什么指数加权平均的天数的计算公式为<script type="math/tex">1/{(1−β)}</script>。</p>
<h4 id="6-4-理解指数加权平均"><a href="#6-4-理解指数加权平均" class="headerlink" title="6.4 理解指数加权平均"></a>6.4 理解指数加权平均</h4><p>我们将指数加权平均公式的一般形式写下来：</p>
<script type="math/tex; mode=display">
\begin{aligned}V_{t}=& \beta V_{t-1}+(1-\beta) \theta_{t} \\=&(1-\beta) \theta_{t}+(1-\beta) \cdot \beta \cdot \theta_{t-1}+(1-\beta) \cdot \beta^{2} \cdot \theta_{t-2}+\cdots \\&+(1-\beta) \cdot \beta^{t-1} \cdot \theta_{1}+\beta^{t} \cdot V_{0}\end{aligned}</script><p>上式中<script type="math/tex">\theta_{t}, \theta_{t-1}, \theta_{t-2}, \cdots, \theta_{1}</script>是原始数据值，<script type="math/tex">(1-\beta),(1-\beta) \beta,(1-\beta) \beta^{2}, \cdots,(1-\beta) \beta^{t-1}</script>是类似指数曲线，从右向左，呈指数下降的。<script type="math/tex">V_t</script>的值就是这两个子式的点乘，将原始数据值与衰减指数点乘，相当于做了指数衰减，离得越近，影响越大，离得越远，影响越小，衰减越厉害。</p>
<p><img src="https://pic.imgdb.cn/item/648ae0fd1ddac507ccbe7f06.png" style="zoom:50%"></p>
<p>我们已经知道了指数加权平均的递推公式。实际应用中为了<strong>减少内存</strong>的使用，我们可以使用这样的语句来实现指数加权平均算法：</p>
<p><img src="https://pic.imgdb.cn/item/648ae16e1ddac507ccc01a03.png" style="zoom:70%"></p>
<p>本小节的参考链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/41218cb5e099">为什么在优化算法中使用指数加权平均</a></p>
<h4 id="6-5-指数加权平均的偏差修正"><a href="#6-5-指数加权平均的偏差修正" class="headerlink" title="6.5 指数加权平均的偏差修正"></a>6.5 指数加权平均的偏差修正</h4><p>上文中提到当<script type="math/tex">β=0.98</script>时，指数加权平均结果如下图绿色曲线所示。但是实际上，真实曲线如紫色曲线所示。</p>
<p><img src="https://pic.imgdb.cn/item/648ae1b81ddac507ccc14d37.png"></p>
<p>我们注意到，紫色曲线与绿色曲线的区别是，紫色曲线开始的时候相对较低一些。这是因为开始时我们设置<script type="math/tex">V_0=0</script>，所以初始值会相对小一些，直到后面受前面的影响渐渐变小，趋于正常。</p>
<p>修正这种问题的方法是进行<strong>偏移校正(bias correction)</strong>，即在每次计算完<script type="math/tex">V_t</script>后，对<script type="math/tex">V_t</script>进行下式处理：</p>
<script type="math/tex; mode=display">
\frac{V_t}{1-\beta^t}</script><p>在刚开始的时候，<script type="math/tex">t</script>比较小，<script type="math/tex">(1−β^t)<1</script>，这样就将<script type="math/tex">V_t</script>修正得更大一些，效果是把紫色曲线开始部分向上提升一些，与绿色曲线接近重合。随着<script type="math/tex">t</script>增大，<script type="math/tex">(1−β^t)≈1</script>，<script type="math/tex">V_t</script>基本不变，紫色曲线与绿色曲线依然重合。这样就实现了简单的偏移校正，得到我们希望的绿色曲线。</p>
<p>注意机器学习中，偏移校正并不是必须的。因为，在迭代一次次数后(<script type="math/tex">t</script>较大)，<script type="math/tex">V_t</script>受初始值影响微乎其微，紫色曲线与绿色曲线基本重合。所以，一般可以忽略初始迭代过程，等到一定迭代之后再取值，这样就不需要进行偏移校正了。</p>
<h4 id="6-6-动量-momentum-梯度下降法"><a href="#6-6-动量-momentum-梯度下降法" class="headerlink" title="6.6 动量(momentum)梯度下降法"></a>6.6 动量(<strong>momentum</strong>)梯度下降法</h4><p>动量梯度下降与梯度下降相比，就是对梯度使用<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A30743067%7D">指数加权平均</a>，其他的都保存一致</p>
<p>该部分将介绍动量梯度下降算法，其速度要比传统的梯度下降算法快很多。做法是在每次训练时，对梯度进行指数加权平均处理，然后用得到的梯度值更新权重<script type="math/tex">W</script>和常数项<script type="math/tex">b</script>。下面介绍具体的实现过程。</p>
<p><img src="https://pic.imgdb.cn/item/648ae1d51ddac507ccc1d475.png"></p>
<p>原始的梯度下降算法如上图蓝色折线所示。在梯度下降过程中，梯度下降的振荡较大，尤其对于<script type="math/tex">W、b</script>之间数值范围差别较大的情况。此时每一点处的梯度只与当前方向有关，产生类似折线的效果，前进缓慢。而如果<strong>对梯度进行指数加权平均</strong>，这样使当前梯度不仅与当前方向有关，还与之前的方向有关，这样处理让梯度前进方向更加平滑，减少振荡，能够更快地到达最小值处。</p>
<p>权重<script type="math/tex">W</script>和常数项<script type="math/tex">b</script>的指数加权平均表达式如下：</p>
<script type="math/tex; mode=display">
\begin{gathered}
V_{\mathrm d W}=\beta \cdot V_{\mathrm d W}+(1-\beta) \cdot \mathrm d W \\
V_{\mathrm d b}=\beta \cdot V_{\mathrm d b}+(1-\beta) \cdot \mathrm d b
\end{gathered}</script><p>从动量的角度来看，以权重<script type="math/tex">W</script>为例，<script type="math/tex">V_{\mathrm dW}</script>可以成速度V，<script type="math/tex">\mathrm dW</script>可以看成是加速度<script type="math/tex">a</script>。指数加权平均实际上是计算当前的速度，当前速度由之前的速度和现在的加速度共同影响。而<script type="math/tex">β<1</script>，又能限制速度<script type="math/tex">V_{\mathrm dW}</script>过大。也就是说，当前的速度是渐变的，而不是瞬变的，是动量的过程。这保证了梯度下降的平稳性和准确性，减少振荡，较快地达到最小值处。</p>
<p>动量梯度下降算法的过程如下：</p>
<p><img src="https://pic.imgdb.cn/item/648ae2051ddac507ccc2b4f9.png" style="zoom:70%"></p>
<p>初始时，令<script type="math/tex">V_{\mathrm dW}=0,V_{\mathrm db}=0</script>。一般设置<script type="math/tex">β=0.9</script>，即指数加权平均前10天的数据，实际应用效果较好。</p>
<p>另外，关于偏移校正，可以不使用。因为经过10次迭代后，随着滑动平均的过程，偏移情况会逐渐消失。</p>
<p>补充一下，在其它文献资料中，动量梯度下降还有另外一种写法：</p>
<script type="math/tex; mode=display">
\begin{gathered}
V_{\mathrm d W}=\beta V_{\mathrm d W}+d W \\
V_{\mathrm d b}=\beta V_{\mathrm d b}+\mathrm d b
\end{gathered}</script><p>即消去了<script type="math/tex">dW</script>和<script type="math/tex">db</script>前的系数<script type="math/tex">(1−β)</script>。这样简化了表达式，但是学习因子<script type="math/tex">\alpha</script>相当于变成了<script type="math/tex">\dfrac{α}{1−β}</script>，表示<script type="math/tex">\alpha</script>也受<script type="math/tex">\beta</script>的影响。从效果上来说，这种写法也是可以的，但是不够直观，且调参涉及到<script type="math/tex">\alpha</script>，不够方便。所以，实际应用中，推荐第一种动量梯度下降的表达式。</p>
<h4 id="6-7-root-mean-square-prop-RMSprop"><a href="#6-7-root-mean-square-prop-RMSprop" class="headerlink" title="6.7 root mean square prop(RMSprop)"></a>6.7 <strong>root mean square prop(</strong>RMSprop<strong>)</strong></h4><p>RMSprop是另外一种优化梯度下降速度的算法。每次迭代训练过程中，其权重W和常数项b的更新表达式为：</p>
<script type="math/tex; mode=display">
\begin{gathered}S_{W}=
\beta S_{\mathrm d W}+(1-\beta) d W^{2} \\S_{b}=\beta S_{\mathrm d b}+(1-\beta) \mathrm d b^{2} \\
W:=W-\alpha \frac{\mathrm d W}{\sqrt{S_{W}}}, b:=b-\alpha \frac{\mathrm d b}{\sqrt{S_{b}}}
\end{gathered}</script><p>下面简单解释一下RMSprop算法的原理，仍然以下图为例，为了便于分析，令水平方向为<script type="math/tex">W</script>的方向，垂直方向为<script type="math/tex">b</script>的方向。</p>
<p><img src="https://pic.imgdb.cn/item/648ae2e81ddac507ccc614ab.png"></p>
<p>从图中可以看出，梯度下降(蓝色折线)在垂直方向(<script type="math/tex">b</script>)上振荡较大，在水平方向(<script type="math/tex">W</script>)上振荡较小，表示在<script type="math/tex">b</script>方向上梯度较大，即<script type="math/tex">db</script>较大，而在<script type="math/tex">W</script>方向上梯度较小，即<script type="math/tex">dW</script>较小。因此，上述表达式中<script type="math/tex">S_b</script>较大，而<script type="math/tex">S_W</script>较小。在更新<script type="math/tex">W</script>和<script type="math/tex">b</script>的表达式中，变化值<script type="math/tex">\dfrac{\mathrm dW}{\sqrt{S_W}}</script>较大，而<script type="math/tex">\dfrac{\mathrm db}{\sqrt{S_b}}</script>较小。也就使得<script type="math/tex">W</script>变化得多一些，<script type="math/tex">b</script>变化得少一些。即加快了<script type="math/tex">W</script>方向的速度，减小了<script type="math/tex">b</script>方向的速度，减小振荡，实现快速梯度下降算法，其梯度下降过程如绿色折线所示。总得来说，就是如果哪个方向振荡大，就减小该方向的更新速度，从而减小振荡。</p>
<p>还有一点需要注意的是为了避免RMSprop算法中<strong>分母为零</strong>，通常可以在分母增加一个极小的常数<script type="math/tex">\varepsilon</script>：</p>
<script type="math/tex; mode=display">
W:=W-\alpha \frac{d W}{\sqrt{S_{W}}+\varepsilon}, b:=b-\alpha \frac{d b}{\sqrt{S_{b}}+\varepsilon}</script><p>其中，<script type="math/tex">ε=10^{−8}</script>，或者其它较小值。</p>
<h4 id="6-8-Adam优化算法"><a href="#6-8-Adam优化算法" class="headerlink" title="6.8 Adam优化算法"></a>6.8 Adam优化算法</h4><p>Adam(Adaptive Moment Estimation)算法<strong>结合</strong>了动量梯度下降算法和RMSprop算法。其算法流程为：</p>
<p><img src="https://pic.imgdb.cn/item/648ae7221ddac507ccd65acc.png" style="zoom:70%"></p>
<p>Adam算法包含了几个超参数，分别是：<script type="math/tex">α,β_1,β_2,ε</script>。</p>
<ul>
<li><script type="math/tex">β_1</script>通常设置为<script type="math/tex">0.9</script>；</li>
<li><script type="math/tex">β_2</script>通常设置为<script type="math/tex">0.999</script>；</li>
<li><script type="math/tex">\varepsilon</script>通常设置为<script type="math/tex">10^{−8}</script>。<br>一般只需要对<script type="math/tex">β_1</script>和<script type="math/tex">β_2</script>进行调试。</li>
</ul>
<p>实际应用中，Adam算法结合了动量梯度下降和RMSprop各自的优点，使得神经网络训练速度大大提高。</p>
<h4 id="6-9-学习率衰减"><a href="#6-9-学习率衰减" class="headerlink" title="6.9 学习率衰减"></a>6.9 学习率衰减</h4><p>减小学习因子<script type="math/tex">\alpha</script>也能有效提高神经网络训练速度，这种方法被称为learning rate decay。</p>
<p>Learning rate decay就是随着迭代次数增加，学习因子<script type="math/tex">\alpha</script><strong>逐渐减小</strong>。下面用图示的方式来解释这样做的好处。下图中，蓝色折线表示使用恒定的学习因子<script type="math/tex">\alpha</script>，由于每次训练<script type="math/tex">\alpha</script>相同，步进长度不变，在接近最优值处的振荡也大，在最优值附近较大范围内振荡，与最优值距离就比较远。绿色折线表示使用不断减小的<script type="math/tex">\alpha</script>，随着训练次数增加，<script type="math/tex">\alpha</script>逐渐减小，步进长度减小，使得能够在最优值处较小范围内微弱振荡，不断逼近最优值。相比较恒定的<script type="math/tex">\alpha</script>来说，learning rate decay更接近最优值。</p>
<p><img src="https://pic.imgdb.cn/item/648ae8241ddac507ccdab00c.png"></p>
<p>Learning rate decay中对<script type="math/tex">\alpha</script>可由下列公式得到：</p>
<script type="math/tex; mode=display">
\begin{equation}
\alpha=\frac{1}{1+\text { decay\_rate } * \text { epoch }} \alpha_{0}
\end{equation}</script><p>其中，<script type="math/tex">\text{deacy\_rate}</script>是参数(可调)，<strong>epoch是训练完所有样本的次数</strong>。随着epoch增加，<script type="math/tex">\alpha</script>会不断变小。除了上面计算<script type="math/tex">\alpha</script>的公式之外，还有其它可供选择的计算公式：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\alpha=0.95^{\text {epoch }} \cdot \alpha_{0} \\
\alpha=\frac{k}{\sqrt{\text { epoch }}} \cdot \alpha_{0} \quad \text { or } \quad \frac{k}{\sqrt{t}} \cdot \alpha_{0}
\end{gathered}</script><p>其中，<script type="math/tex">k</script>为可调参数，<script type="math/tex">t</script>为mini-bach number。除此之外，还可以设置<script type="math/tex">\alpha</script>为关于<script type="math/tex">t</script>的离散值，随着<script type="math/tex">t</script>增加，<script type="math/tex">\alpha</script>呈阶梯式减小。当然，也可以根据训练情况灵活调整当前的<script type="math/tex">\alpha</script>值，但会比较耗时间。</p>
<h4 id="6-10局部最优问题"><a href="#6-10局部最优问题" class="headerlink" title="6.10局部最优问题"></a>6.10局部最优问题</h4><p>在使用梯度下降算法不断减小cost function时，可能会得到局部最优解(local optima)而不是全局最优解(global optima)。之前我们对局部最优解的理解是形如碗状的凹槽，如下图左边所示。但是在神经网络中，local optima的概念发生了变化。准确地来说，大部分梯度为零的“最优点”并不是这些凹槽处，而是形如右边所示的马鞍状，称为<strong>saddle point</strong>。也就是说，梯度为零并不能保证都是convex(极小值)，也有可能是concave(极大值)。特别是在神经网络中参数很多的情况下，所有参数梯度为零的点很可能都是右边所示的马鞍状的saddle point，而不是左边那样的local optimum。</p>
<p><img src="https://pic.imgdb.cn/item/648ae86d1ddac507ccdbc60a.png"></p>
<p>类似马鞍状的plateaus会<strong>降低</strong>神经网络学习速度。Plateaus是梯度接近于零的平缓区域，如下图所示。在plateaus上梯度很小，前进缓慢，到达saddle point需要很长时间。到达saddle point后，由于随机扰动，梯度一般能够沿着图中绿色箭头，离开saddle point，继续前进，只是在plateaus上花费了太多时间。</p>
<p><img src="https://pic.imgdb.cn/item/648ae8921ddac507ccdc670a.png"></p>
<h3 id="第七章-超参数调试、Batch正则化和编程框架"><a href="#第七章-超参数调试、Batch正则化和编程框架" class="headerlink" title="第七章 超参数调试、Batch正则化和编程框架"></a>第七章 超参数调试、Batch正则化和编程框架</h3><h4 id="7-1-超参数调试处理"><a href="#7-1-超参数调试处理" class="headerlink" title="7.1 超参数调试处理"></a>7.1 超参数调试处理</h4><p>深度神经网络需要调试的超参数（Hyperparameters）较多，包括：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>参数</strong></th>
<th style="text-align:left"><strong>意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><script type="math/tex">\alpha</script></td>
<td style="text-align:left">学习因子/速率</td>
</tr>
<tr>
<td style="text-align:left"><script type="math/tex">\beta</script></td>
<td style="text-align:left">动量梯度下降因子</td>
</tr>
<tr>
<td style="text-align:left"><script type="math/tex">\beta_1, \beta_2, \varepsilon</script></td>
<td style="text-align:left">Adam算法参数</td>
</tr>
<tr>
<td style="text-align:left">#layers</td>
<td style="text-align:left">神经网络层数</td>
</tr>
<tr>
<td style="text-align:left">#hidden units</td>
<td style="text-align:left">各层隐藏神经元个数</td>
</tr>
<tr>
<td style="text-align:left">learning rate decay</td>
<td style="text-align:left">学习因子下降参数</td>
</tr>
<tr>
<td style="text-align:left">mini-batch size</td>
<td style="text-align:left">批量训练样本数的包含样本个数</td>
</tr>
<tr>
<td style="text-align:left">。。。</td>
<td style="text-align:left">。。。</td>
</tr>
</tbody>
</table>
</div>
<p>超参数之间也有重要性差异。通常来说，学习因子<script type="math/tex">α</script>是最重要的超参数，也是需要重点调试的超参数。动量梯度下降因子<script type="math/tex">β</script>、各隐藏层神经元个数#hidden units和mini-batch size的重要性仅次于<script type="math/tex">α</script>。然后就是神经网络层数#layers和学习因子下降参数learning rate decay。最后，Adam算法的三个参数<script type="math/tex">β_1, β_2, ε</script>一般常设置为<script type="math/tex">0.9，0.999</script>和<script type="math/tex">10^{−8}</script>，不需要反复调试。当然，这里超参数重要性的排名并不是绝对的，具体情况，具体分析。</p>
<p>如何选择和调试超参数？传统的机器学习中，我们对每个参数等距离选取任意个数的点，然后，分别使用不同点对应的参数组合进行训练，最后根据验证集上的表现好坏，来选定最佳的参数。例如有两个待调试的参数，分别在每个参数上选取5个点，这样构成了5x5=25中参数组合，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648ae96e1ddac507ccdfd1c7.png" style="zoom:50%"></p>
<p>这种做法在参数比较少的时候效果较好。但是在深度神经网络模型中，我们一般不采用这种均匀间隔取点的方法，比较好的做法是使用<strong>随机选择</strong>。也就是说，对于上面这个例子，我们随机选择25个点，作为待调试的超参数，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648aea321ddac507cce264c1.png" style="zoom:50%"></p>
<p>随机化选择参数的目的是为了尽可能地得到更多种参数组合。还是上面的例子，如果使用均匀采样的话，每个参数只有5种情况；而使用随机采样的话，每个参数有25种可能的情况，因此更有可能得到最佳的参数组合。</p>
<p>这种做法的另一个好处就是对重要性不同的参数之间的选择效果更好。设hyperparameter1为<script type="math/tex">\alpha</script>，hyperparameter2为<script type="math/tex">\varepsilon</script>，显然二者的重要性是不一样的。如果使用第一种均匀采样的方法，<script type="math/tex">\varepsilon</script>的影响很小，相当于只选择了<script type="math/tex">5</script>个<script type="math/tex">\alpha</script>值。而如果使用第二种随机采样的方法，<script type="math/tex">\varepsilon</script>和<script type="math/tex">\alpha</script>都有可能选择<script type="math/tex">25</script>种不同值。这大大增加了<script type="math/tex">\alpha</script>调试的个数，更有可能选择到最优值。其实，在实际应用中完全不知道哪个参数更加重要的情况下，随机采样的方式能有效解决这一问题，但是均匀采样做不到这点。</p>
<p>在经过随机采样之后，我们可能得到某些区域模型的表现较好。为了得到更精确的最佳参数，我们应该继续对选定的区域进行<strong>由粗到细</strong>的采样(coarse to fine sampling scheme)。也就是放大表现较好的区域，再对此区域做更密集的随机采样。例如，对下图中右下角的方形区域再做25点的随机采样，以获得最佳参数。</p>
<p><img src="https://pic.imgdb.cn/item/648aea541ddac507cce2d585.png" style="zoom:50%"></p>
<h4 id="7-2-为超参数选择合适的范围"><a href="#7-2-为超参数选择合适的范围" class="headerlink" title="7.2 为超参数选择合适的范围"></a>7.2 为超参数选择合适的范围</h4><p>上一部分讲的调试参数使用随机采样，对于某些超参数是可以进行尺度均匀采样的，但是某些超参数需要选择不同的合适尺度进行随机采样。</p>
<p>例如对于超参数#layers和#hidden units，都是正整数，是可以进行均匀随机采样的，即<strong>超参数每次变化的尺度都是一致的</strong>(如每次变化为1，犹如一个刻度尺一样，刻度是均匀的)。</p>
<p>但是，对于某些超参数，可能需要<strong>非均匀随机采样(即非均匀刻度尺)</strong>。例如超参数<script type="math/tex">\alpha</script>，待调范围是<script type="math/tex">[0.0001, 1]</script>。如果使用均匀随机采样，那么有<script type="math/tex">90\%</script>的采样点分布在<script type="math/tex">[0.1, 1]</script>之间，只有<script type="math/tex">10\%</script>分布在<script type="math/tex">[0.0001, 0.1]</script>之间。这在实际应用中是不太好的，因为最佳的<script type="math/tex">\alpha</script>值可能主要分布在<script type="math/tex">[0.0001, 0.1]</script>之间，而<script type="math/tex">[0.1, 1]</script>范围内<script type="math/tex">\alpha</script>值效果并不好。因此我们更关注的是区间<script type="math/tex">[0.0001, 0.1]</script>，应该在这个区间内细分更多刻度。</p>
<p>通常的做法是将<strong>linear scale转换为log scale</strong>，将均匀尺度转化为非均匀尺度，然后再在log scale下进行均匀采样。这样<script type="math/tex">[0.0001, 0.001]</script>，<script type="math/tex">[0.001, 0.01]</script>，<script type="math/tex">[0.01, 0.1]</script>，<script type="math/tex">[0.1, 1]</script>各个区间内随机采样的超参数个数基本一致，也就扩大了之前<script type="math/tex">[0.0001, 0.1]</script>区间内采样值个数。</p>
<p><img src="https://pic.imgdb.cn/item/648aea921ddac507cce3abf1.png"></p>
<p>一般解法是，如果线性区间为<script type="math/tex">[a, b]</script>，令<script type="math/tex">m=\log(a)，n=\log(b)</script>，则对应的<script type="math/tex">\log</script>区间为<script type="math/tex">[m,n]</script>。对<script type="math/tex">\log</script>区间的<script type="math/tex">[m,n]</script>进行随机均匀采样，然后得到的采样值<script type="math/tex">r</script>，最后反推到线性区间，即<script type="math/tex">10^r</script>就是最终采样的超参数。相应的Python语句为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = np.log10(a)</span><br><span class="line">n = np.log10(b)</span><br><span class="line">r = np.random.rand()</span><br><span class="line">r = m + (n-m)*r</span><br><span class="line">r = np.power(<span class="number">10</span>,r)</span><br></pre></td></tr></table></figure>
<p>除了<script type="math/tex">\alpha</script>外，动量梯度因子<script type="math/tex">\beta</script>也是一样，在超参数调试的时候需要进行非均匀采样。一般<script type="math/tex">\beta</script>的取值范围<script type="math/tex">[0.9, 0.999]</script>，<script type="math/tex">1−β</script>的取值范围就在<script type="math/tex">[0.001, 0.1]</script>。那么直接对<script type="math/tex">1−β</script>在<script type="math/tex">[0.001, 0.1]</script>区间内进行<script type="math/tex">\log</script>变换即可。</p>
<blockquote>
<p>这里解释下为什么<script type="math/tex">\beta</script>也需要向<script type="math/tex">\alpha</script>那样做非均匀采样。假设<script type="math/tex">\beta</script>从<script type="math/tex">0.9000</script>变化为<script type="math/tex">0.9005</script>，那么<script type="math/tex">\frac 1{1−β}</script>基本没有变化。但假设<script type="math/tex">\beta</script>从<script type="math/tex">0.9990</script>变化为<script type="math/tex">0.9995</script>，那么<script type="math/tex">\frac 1{1−β}</script>前后差别<script type="math/tex">1000</script>。<script type="math/tex">\beta</script>越接近<script type="math/tex">1</script>，指数加权平均的个数越多，变化越大。所以对<script type="math/tex">\beta</script>接近<script type="math/tex">1</script>的区间，应该采集得更密集一些。</p>
</blockquote>
<h4 id="7-3-超参数训练的实践：Pandas-vs-Caviar"><a href="#7-3-超参数训练的实践：Pandas-vs-Caviar" class="headerlink" title="7.3 超参数训练的实践：Pandas vs. Caviar"></a>7.3 超参数训练的实践：<strong>Pandas vs. Caviar</strong></h4><p>经过调试选择完最佳的超参数并不是一成不变的，一段时间之后（例如一个月），需要根据新的数据和实际情况，再次调试超参数，以获得实时的最佳模型。</p>
<p>在训练深度神经网络时，一种情况是受计算能力所限，我们只能对一个模型进行训练，调试不同的超参数，使得这个模型有最佳的表现。我们称之为Babysitting one model。另外一种情况是可以对多个模型同时进行训练，每个模型上调试不同的超参数，根据表现情况，选择最佳的模型。我们称之为Training many models in parallel。</p>
<p><img src="https://pic.imgdb.cn/item/648aeab31ddac507cce41e0f.png" style="zoom:50%"></p>
<p>因为第一种情况只使用一个模型，所以类比做Panda approach；第二种情况同时训练多个模型，类比做Caviar  approach。使用哪种模型是由计算资源、计算能力所决定的。一般来说，对于非常复杂或者数据量很大的模型，使用Panda  approach更多一些。</p>
<h4 id="7-4-正则化网络的激活函数"><a href="#7-4-正则化网络的激活函数" class="headerlink" title="7.4 正则化网络的激活函数"></a>7.4 正则化网络的激活函数</h4><p>Sergey Ioffe和Christian Szegedy两位学者提出了Batch Normalization方法。Batch Normalization不仅可以让调试超参数更加简单，而且可以让神经网络模型更加“健壮”。也就是说较好模型可接受的超参数范围更大一些，包容性更强，使得更容易去训练一个深度神经网络。接下来，我们就来介绍什么是Batch Normalization，以及它是如何工作的。</p>
<p>之前，我们在<strong>第五章</strong>中提到过在训练神经网络时，<strong>标准化输入可以提高训练的速度</strong>。方法是对训练数据集进行<strong>归一化</strong>的操作，即将原始数据减去其均值<script type="math/tex">\mu</script>后，再除以其方差<script type="math/tex">σ^2</script>。但是标准化输入只是对输入进行了处理，那么对于神经网络，又该如何对各隐藏层的输入进行标准化处理呢？</p>
<p>其实在神经网络中，第<script type="math/tex">l</script>层隐藏层的输入就是第<script type="math/tex">l−1</script>层隐藏层的输出<script type="math/tex">A^{[l−1]}</script>。对<script type="math/tex">A^{[l−1]}</script>进行标准化处理，从原理上来说可以提高<script type="math/tex">W^{[l]}</script>和<script type="math/tex">b^{[l]}</script>的训练速度和准确度。这种对各隐藏层的标准化处理就是Batch Normalization。值得注意的是，实际应用中，一般是对<script type="math/tex">Z^{[l−1]}</script>进行标准化处理而不是<script type="math/tex">A^{[l−1]}</script>，其实差别不是很大。</p>
<p>Batch Normalization对第<script type="math/tex">l</script>层隐藏层的输入<script type="math/tex">Z^{[l−1]}</script>做如下标准化处理，忽略上标<script type="math/tex">[l−1]</script>：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mu=\frac{1}{m} \sum_{i} z^{(i)} \\
\sigma^{2}=\frac{1}{m} \sum_{i}\left(z_{i}-\mu\right)^{2} \\z_{\text {norm }}^{(i)}=\frac{z^{(i)}-\mu}{\sqrt{\sigma^{2}+\varepsilon}}
\end{gathered}</script><p>其中，<script type="math/tex">m</script>是单个mini-batch包含样本个数，<script type="math/tex">\varepsilon</script>是为了防止分母为零，可取值<script type="math/tex">10^{−8}</script>。这样，使得该隐藏层的所有输入<script type="math/tex">z^{(i)}</script>均值为<script type="math/tex">0</script>，方差为<script type="math/tex">1</script>。但是，大部分情况下并不希望所有的<script type="math/tex">z^{(i)}</script>均值都为<script type="math/tex">0</script>，方差都为<script type="math/tex">1</script>，也不太合理。通常需要对<script type="math/tex">z^{(i)}</script>进行进一步处理：</p>
<script type="math/tex; mode=display">
\tilde{z}^{(i)}=\gamma \cdot z_{\text {norm }}^{(i)}+\beta</script><p>上式中，<script type="math/tex">γ</script>和<script type="math/tex">\beta</script>是learnable parameters，类似于<script type="math/tex">W</script>和<script type="math/tex">b</script>一样，可以通过梯度下降等算法求得。这里，<script type="math/tex">γ</script>和<script type="math/tex">\beta</script>的作用是让<script type="math/tex">\tilde z^{(i)}</script>的均值和方差为任意值，只需调整其值就可以了。例如，令：</p>
<script type="math/tex; mode=display">
\gamma=\sqrt{\sigma^{2}+\varepsilon}, \quad \beta=u</script><p>则<script type="math/tex">\tilde z^{(i)}=z^{(i)}</script>，即identity function。可见，设置<script type="math/tex">γ</script>和<script type="math/tex">\beta</script>为不同的值，可以得到任意的均值和方差。</p>
<p>这样，通过Batch Normalization，对隐藏层的各个<script type="math/tex">z^{[l](i)}</script>进行标准化处理，得到<script type="math/tex">\tilde z^{[l](i)}</script>，替代<script type="math/tex">z^{[l](i)}</script>。</p>
<p>注意，<strong>输入标准化</strong>处理Normalizing inputs和<strong>隐藏层标准化</strong>处理Batch  Normalization是有区别的。Normalizing inputs使所有输入的均值为<script type="math/tex">0</script>，方差为<script type="math/tex">1</script>。而Batch  Normalization可使各隐藏层输入的<strong>均值和方差为任意值</strong>。实际上，从激活函数的角度来说，如果各隐藏层的输入均值在靠近<script type="math/tex">0</script>的区域即处于激活函数的线性区域，这样不利于训练好的非线性神经网络，得到的模型效果也不会太好。这也解释了为什么需要用<script type="math/tex">γ</script>和<script type="math/tex">\beta</script>是来对<script type="math/tex">z^{[l](i)}</script>作进一步处理。</p>
<h4 id="7-5-将Batch-Norm拟合进神经网络"><a href="#7-5-将Batch-Norm拟合进神经网络" class="headerlink" title="7.5 将Batch Norm拟合进神经网络"></a>7.5 将Batch Norm拟合进神经网络</h4><p>我们已经知道了如何对某单一隐藏层的所有神经元进行Batch Norm，接下来将研究如何把Bath Norm应用到整个神经网络中。</p>
<p>对于<script type="math/tex">L</script>层神经网络，经过Batch Norm的作用，整体流程如下：</p>
<p><img src="https://pic.imgdb.cn/item/648aeae71ddac507cce4e5b1.png"></p>
<p>实际上，Batch Norm经常使用在mini-batch上，这也是其名称的由来。值得注意的是，因为Batch Norm对各隐藏层<script type="math/tex">Z^{[l]}=W^{[l]} A^{[l-1]}+b^{[l]}</script>有去均值的操作，所以这里的常数项<script type="math/tex">b^{[l]}</script>可以消去，其数值效果完全可以由<script type="math/tex">\tilde Z^{[l]}</script>中的<script type="math/tex">\beta</script>来实现。因此，我们在使用Batch Norm的时候，可以忽略各隐藏层的常数项<script type="math/tex">b^{[l]}</script>。在使用梯度下降算法时，分别对<script type="math/tex">W^{[l]}，β^{[l]}~ \text 和 ~γ^{[l]}</script>进行迭代更新。除了传统的梯度下降算法之外，还可以使用我们之前介绍过的动量梯度下降、RMSprop或者Adam等优化算法。</p>
<h4 id="7-6-Batch-Norm为什么有效"><a href="#7-6-Batch-Norm为什么有效" class="headerlink" title="7.6 Batch Norm为什么有效"></a>7.6 Batch Norm为什么有效</h4><p>我们可以把输入特征做均值为<script type="math/tex">0</script>，方差为<script type="math/tex">1</script>的规范化处理，来加快学习速度。而Batch Norm也是对隐藏层各神经元的输入做类似的规范化处理。总的来说，Batch Norm不仅能够提高神经网络训练速度，而且能让神经网络的权重<script type="math/tex">W</script>的更新更加“稳健”，尤其在深层神经网络中更加明显。比如神经网络很后面的<script type="math/tex">W</script>对前面的<script type="math/tex">W</script><strong>包容性更强</strong>，即前面的<script type="math/tex">W</script>的变化对后面<script type="math/tex">W</script>造成的影响很小，整体网络更加健壮。</p>
<p>举个例子来说明，假如用一个浅层神经网络(类似逻辑回归)来训练识别猫的模型。如下图所示，提供的所有猫的训练样本都是黑猫。然后，用这个训练得到的模型来对各种颜色的猫样本进行测试，测试的结果可能并不好。其原因是训练样本不具有一般性(即不是所有的猫都是黑猫)，这种训练样本(黑猫)和测试样本(猫)分布的变化称之为<strong>covariate shift</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/648aeafd1ddac507cce53503.png" style="zoom:50%"></p>
<p>对于这种情况，如果实际应用的样本与训练样本分布不同，即发生了covariate shift，则一般是要对模型<strong>重新训练</strong>的。在神经网络，尤其是深度神经网络中，covariate shift会导致模型预测效果变差，重新训练的模型各隐藏层的<script type="math/tex">W^{[l]}</script>和<script type="math/tex">B^{[l]}</script>均产生偏移、变化。而Batch Norm的作用恰恰是减小covariate shift的影响，让模型变得更加健壮，鲁棒性更强。Batch Norm减少了各层<script type="math/tex">W^{[l]}</script>、<script type="math/tex">B^{[l]}</script>之间的耦合性，让各层更加独立，实现自我训练学习的效果。也就是说，如果输入发生covariate shift，那么因为Batch Norm的作用，对个隐藏层输出<script type="math/tex">Z^{[l]}</script>进行均值和方差的归一化处理，<script type="math/tex">W^{[l]}</script>和<script type="math/tex">B^{[l]}</script>更加稳定，使得原来的模型也有不错的表现。针对上面这个黑猫的例子，如果我们使用深层神经网络，使用Batch Norm，那么该模型对花猫的识别能力应该也是不错的。</p>
<p>从另一个方面来说，<strong>Batch Norm也起到轻微的正则化</strong>(regularization)效果。具体表现在：</p>
<ul>
<li><strong>每个mini-batch都进行均值为</strong><script type="math/tex">0</script><strong>，方差为</strong><script type="math/tex">1</script><strong>的归一化操作</strong></li>
<li><strong>每个mini-batch中，对各个隐藏层的</strong><script type="math/tex">Z^{[l]}</script><strong>添加了随机噪声，效果类似于Dropout</strong></li>
<li><strong>mini-batch越小，正则化效果越明显</strong><br>但是，Batch Norm的正则化效果比较微弱，正则化也不是Batch Norm的主要功能。</li>
</ul>
<h4 id="7-7-测试时的Batch-Norm"><a href="#7-7-测试时的Batch-Norm" class="headerlink" title="7.7 测试时的Batch Norm"></a>7.7 测试时的Batch Norm</h4><p>训练过程中，Batch Norm是对单个mini-batch进行操作的，但在测试过程中，如果是单个样本，该如何使用Batch Norm进行处理呢？</p>
<p>首先，回顾一下训练过程中Batch Norm的主要过程：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mu=\frac{1}{m} \sum_{i} z^{(i)} \\
\sigma^{2}=\frac{1}{m} \sum_{i}\left(z^{(i)}-\mu\right)^{2} \\
z_{\text {norm }}^{(i)}=\frac{z^{(i)}-\mu}{\sqrt{\sigma^{2}+\varepsilon}} \\
\tilde{z}^{(i)}=\gamma \cdot z_{\text {norm }}^{(i)}+\beta
\end{gathered}</script><p>其中，<script type="math/tex">\mu</script>和<script type="math/tex">σ^2</script>是对单个mini-batch中所有<script type="math/tex">m</script>个样本求得的。在测试过程中，如果只有一个样本，求其均值和方差是没有意义的，就需要对<script type="math/tex">\mu</script>和<script type="math/tex">σ^2</script>进行估计。估计的方法很多，理论上可以将所有训练集放入最终的神经网络模型中，然后将每个隐藏层计算得到的<script type="math/tex">\mu^{[l]}</script>和<script type="math/tex">σ^{2[l]}</script>直接作为测试过程的<script type="math/tex">\mu</script>和<script type="math/tex">σ^2</script>来使用。但是，实际应用中一般不使用这种方法，而是使用我们之前介绍过的指数加权平均(exponentially weighted average)的方法来预测测试过程单个样本的<script type="math/tex">\mu</script>和<script type="math/tex">σ^2</script>。</p>
<p>指数加权平均的做法为，对第<script type="math/tex">l</script>层隐藏层，考虑所有mini-batch在该隐藏层下的<script type="math/tex">\mu^{[l]}</script>和<script type="math/tex">σ^{2[l]}</script>，然后用指数加权平均的方式来预测得到当前单个样本的<script type="math/tex">\mu^{[l]}</script>和<script type="math/tex">σ^{2[l]}</script>。这样就实现了对测试过程单个样本的均值和方差估计。最后，再利用训练过程得到的<script type="math/tex">\gamma</script>和<script type="math/tex">\beta</script>值计算出各层的<script type="math/tex">\tilde z^{(i)}</script>值。</p>
<h4 id="7-8-Softmax回归"><a href="#7-8-Softmax回归" class="headerlink" title="7.8 Softmax回归"></a>7.8 Softmax回归</h4><p>目前我们介绍的都是二分类问题，神经网络输出层只有一个神经元，表示预测输出<script type="math/tex">\hat y</script>是正类的概率<script type="math/tex">P(y = 1|x)</script>，若<script type="math/tex">\hat y>0.5</script>则判断为正类，否则判断为负类。</p>
<p>对于多分类问题，用<script type="math/tex">C</script>表示种类个数，神经网络中输出层就有<script type="math/tex">C</script>个神经元，即<script type="math/tex">n^{[L]}=C</script>。其中，每个神经元的输出依次对应属于该类的概率，即<script type="math/tex">P(y=c|x)</script>。为了处理多分类问题，一般使用Softmax回归模型。Softmax回归模型输出层的激活函数如下所示：</p>
<script type="math/tex; mode=display">
\begin{gathered}
z^{[L]}=W^{[L]} a^{[L-1]}+b^{[L]} \\
a_{i}^{[L]}=\frac{e^{z_{i}^{[L]}}}{\sum_{i=1}^{C} e^{z_{i}^{[L]}}}
\end{gathered}</script><p>输出层每个神经元的输出<script type="math/tex">a^{[L]}_i</script>对应属于该类的概率，满足：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{C} a_{i}^{[L]}=1</script><p>所有的<script type="math/tex">a^{[L]}_i</script>，即<script type="math/tex">\hat y</script>，维度为<script type="math/tex">(C, 1)</script>。</p>
<p>下面给出几个简单的线性多分类的例子(只有一个输出层)：</p>
<p><img src="https://pic.imgdb.cn/item/648aeb7e1ddac507cce6d5bb.png"></p>
<p>如果使用神经网络，特别是深层神经网络，可以得到更复杂、更精确的非线性模型。</p>
<h4 id="7-9-训练一个Softmax回归"><a href="#7-9-训练一个Softmax回归" class="headerlink" title="7.9 训练一个Softmax回归"></a>7.9 训练一个Softmax回归</h4><p>Softmax classifier的训练过程与我们之前介绍的二元分类问题有所不同。先来看一下softmax classifier的loss function。举例假如<script type="math/tex">C=4</script>，某个样本的预测输出<script type="math/tex">\hat y</script>和真实输出<script type="math/tex">y</script>为：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\hat{y}=\left[\begin{array}{l}0.3 \\0.2 \\0.1 \\0.4
\end{array}\right] 
\qquad y=\left[\begin{array}{l}0 \\1 \\0 \\0
\end{array}\right]
\end{gathered}</script><p>从<script type="math/tex">\hat y</script>值来看，<script type="math/tex">P(y=4|x)=0.4</script>，概率最大，而真实样本属于第<script type="math/tex">2</script>类，因此该预测效果不佳。我们定义softmax classifier的loss function为：</p>
<script type="math/tex; mode=display">
L(\hat{y}, y)=-\sum_{j=1}^{4} y_{j} \cdot \log \hat{y}_{j}</script><p>然而，由于只有当<script type="math/tex">j=2</script>时，<script type="math/tex">y_2=1</script>，其它情况下，<script type="math/tex">y_j=0</script>。所以，上式中的<script type="math/tex">L(\hat y,y)</script>可以简化为：</p>
<script type="math/tex; mode=display">
L(\hat{y}, y)=-y_{2} \cdot \log \hat{y}_{2}=-\log \hat{y}_{2}</script><p>要让<script type="math/tex">L(\hat y,y)</script>更小，就应该让<script type="math/tex">\hat y_2</script>越大越好。<script type="math/tex">\hat y_2</script>反映的是概率，完全符合我们之前的定义。</p>
<p>所有<script type="math/tex">m</script>个样本的cost function为：</p>
<script type="math/tex; mode=display">
J=\frac{1}{m} \sum_{i=1}^{m} L(\hat{y}, y)</script><p>其预测输出向量<script type="math/tex">A^{[L]}</script>即<script type="math/tex">\hat Y</script>的维度为<script type="math/tex">(4, m)</script>。</p>
<p>softmax classifier的反向传播过程仍然使用梯度下降算法，其推导过程与二元分类有一点点不一样。因为只有输出层的激活函数不一样，我们先推导<script type="math/tex">dZ^{[L]}</script>：</p>
<script type="math/tex; mode=display">
\begin{gathered}
\mathrm d a^{[L]}=-\frac{1}{a^{[L]}} \\
\frac{\partial a^{[L]}}{\partial z^{[L]}}=\frac{\partial}{\partial z^{[L]}} \cdot\left(\frac{e^{z_{i}^{[L]}}}{\sum_{i=1}^{C} e^{z_{i}^{[L]}}}\right)=a^{[L]} \cdot\left(1-a^{[L]}\right) \\
\mathrm d z^{[L]}=d a^{[L]} \cdot \frac{\partial a^{[L]}}{\partial z^{[L]}}=a^{[L]}-1=a^{[L]}-y
\end{gathered}</script><p>对于所有m个训练样本：</p>
<script type="math/tex; mode=display">
d Z^{[L]}=A^{[L]}-Y</script><p>可见<script type="math/tex">\mathrm dZ^{[L]}</script>的表达式与二元分类结果是一致的，虽然推导过程不太一样。然后就可以继续进行反向传播过程的梯度下降算法了，推导过程与二元分类神经网络完全一致。</p>
<h4 id="7-10-深度学习框架"><a href="#7-10-深度学习框架" class="headerlink" title="7.10 深度学习框架"></a>7.10 深度学习框架</h4><p>深度学习框架有很多，例如：</p>
<ul>
<li><strong>Caffe/Caffe2</strong></li>
<li><strong>CNTK</strong></li>
<li><strong>DL4J</strong></li>
<li><strong>Keras</strong></li>
<li><strong>Lasagne</strong></li>
<li><strong>mxnet</strong></li>
<li><strong>PaddlePaddle</strong></li>
<li><strong>TensorFlow</strong></li>
<li><strong>Theano</strong></li>
<li><strong>Torch(Pytorch)</strong><br>一般选择深度学习框架的基本准则是：</li>
<li><strong>Ease of programming(development and deployment)</strong></li>
<li><strong>Running speed</strong></li>
<li><strong>Truly open(open source with good governance)</strong></li>
</ul>
<h4 id="7-11-TensorFlow"><a href="#7-11-TensorFlow" class="headerlink" title="7.11 TensorFlow"></a><strong>7.11 TensorFlow</strong></h4><p>这里简单介绍一下最近几年比较火的一个深度学习框架：TensorFlow。</p>
<p>举个例子来说明，例如cost function是参数w的函数：</p>
<script type="math/tex; mode=display">
J(w) = w^{2}-10 w+25</script><p>如果使用TensorFlow对cost function进行优化，求出最小值对应的<script type="math/tex">w</script>程序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">w = tf.Variable(<span class="number">0</span>,dtype=tf.float32)</span><br><span class="line"><span class="comment">#cost = tf.add(tf.add(w**2,tf.multiply(-10,w)),25)</span></span><br><span class="line">cost = w**<span class="number">2</span> - <span class="number">10</span>*w +<span class="number">25</span></span><br><span class="line">train = tf.train.GradientDescentOptimizer(<span class="number">0.01</span>).minimize(cost)</span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">session = tf.Session()</span><br><span class="line">session.run(init)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"><span class="comment"># &gt;&gt;0.0</span></span><br><span class="line">session.run(train)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"><span class="comment"># &gt;&gt;0.1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    session.run(train)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"><span class="comment"># &gt;&gt;4.99999</span></span><br></pre></td></tr></table></figure>
<p>TensorFlow框架内可以直接调用梯度下降优化算法，不需要我们自己再写程序了，大大提高了效率。在运行<script type="math/tex">1000</script>次梯度下降算法后，<script type="math/tex">w</script>的解为<script type="math/tex">4.99999</script>，已非常接近<script type="math/tex">w</script>的最优值<script type="math/tex">5</script>了。</p>
<p>针对上面这个例子，如果对<script type="math/tex">w</script>前的系数用变量<script type="math/tex">x</script>来代替，程序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">cofficients = np.array([[<span class="number">1.</span>],[-<span class="number">10.</span>],[<span class="number">25.</span>]])</span><br><span class="line">w = tf.Variable(<span class="number">0</span>,dtype=tf.float32)</span><br><span class="line">x = tf.placeholder(tf.float32,[<span class="number">3</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">#cost = tf.add(tf.add(w**2,tf.multiply(-10,w)),25)</span></span><br><span class="line"><span class="comment">#cost = w**2 - 10*w +25</span></span><br><span class="line">cost = x[<span class="number">0</span>][<span class="number">0</span>]*w**<span class="number">2</span> + x[<span class="number">1</span>][<span class="number">0</span>]*w + x[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">train = tf.train.GradientDescentOptimizer(<span class="number">0.01</span>).minimize(cost)</span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">session = tf.Session()</span><br><span class="line">session.run(init)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"><span class="comment"># &gt;&gt;0.0</span></span><br><span class="line">session.run(train, feed_dict=(x:coefficients))</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"><span class="comment"># &gt;&gt;0.1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    session.run(train, feed_dict=(x:coefficients))</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br><span class="line"><span class="comment"># &gt;&gt;4.99999</span></span><br></pre></td></tr></table></figure>
<p>结果跟之前一样。此外，还可以更改<script type="math/tex">x</script>即cofficients的值，而得到不同的优化结果<script type="math/tex">w</script>。</p>
<p>另外，上段程序中的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session = tf.Session()</span><br><span class="line">session.run(init)</span><br><span class="line"><span class="built_in">print</span>(session.run(w))</span><br></pre></td></tr></table></figure>
<p>有另外一种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> session:</span><br><span class="line">    session.run(init)</span><br><span class="line">    <span class="built_in">print</span>(session.run(w))</span><br></pre></td></tr></table></figure>
<p>TensorFlow的最大优点就是采用<strong>数据流图(data flow graphs)</strong>来进行数值运算。图中的节点(Nodes)表示数学操作，图中的线(edges)则表示在节点间相互联系的多维数据数组，即张量(tensor)。而且它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU(或GPU)，服务器，移动设备等等。<br>关于TensorFlow更多的原理和编程技巧这里就不在赘述了，感兴趣的朋友可以关注更详细的TensorFlow相关文档。</p>
<h3 id="第八章-机器学习策略"><a href="#第八章-机器学习策略" class="headerlink" title="第八章 机器学习策略"></a>第八章 机器学习策略</h3><p>《Structuring Machine Learning Projects》(构建机器学习项目)这门课是Andrw  Ng深度学习专项课程中的第三门课。这门课主要介绍机器学习中的一些策略和方法，让我们能够更快更有效地让机器学习系统工作，该门课共有两周的课时。</p>
<h4 id="8-1-1为什么是Machine-Learning-ML-策略"><a href="#8-1-1为什么是Machine-Learning-ML-策略" class="headerlink" title="8.1.1为什么是Machine Learning(ML)策略"></a>8.1.1为什么是Machine Learning(ML)策略</h4><p>当我们最初得到一个深度神经网络模型时，我们可能希望从很多方面来对它进行优化，例如：</p>
<ul>
<li>Collect more data</li>
<li>Collect more diverse training set</li>
<li>Train algorithm longer with gradient descent</li>
<li>Try Adam instead of gradient descent</li>
<li>Try bigger network</li>
<li>Try smaller network</li>
<li>Try dropout</li>
<li>Add L2 regularization</li>
<li>Network architecture: Activation functions, #hidden units…<br>可选择的方法很多，也很复杂、繁琐。盲目选择、尝试不仅耗费时间而且可能收效甚微。因此，使用快速、有效的策略来优化机器学习模型是非常必要的。</li>
</ul>
<h4 id="8-1-2-正交化"><a href="#8-1-2-正交化" class="headerlink" title="8.1.2 正交化"></a>8.1.2 正交化</h4><p>机器学习中有许多参数、超参数需要调试。通过每次只调试一个参数，保持其它参数不变，而得到的模型某一性能改变是一种最常用的调参策略，称之为<strong>正交化方法(Orthogonalization)</strong>。</p>
<p>Orthogonalization的核心在于<strong>每次调试一个参数只会影响模型的某一个性能</strong>。例如老式电视机旋钮，每个旋钮就对应一个功能，调整旋钮会调整对应的功能，而不会影响其它功能。也就是说彼此旋钮之间是互不影响的，是正交的，这也是Orthogonalization名称的由来。这种方法能够让我们更快更有效地进行机器学习模型的调试和优化。</p>
<p>对应到机器学习监督式学习模型中，可以大致分成四个独立的“功能”，每个“功能”对应一些可调节的唯一的旋钮。四个“功能”如下：</p>
<ul>
<li><strong>Fit training set well on cost function</strong></li>
<li><strong>Fit dev set well on cost function</strong></li>
<li><strong>Fit test set well on cost function</strong></li>
<li><strong>Performs well in real world</strong><br>第一条优化训练集可以通过使用更复杂NN，使用Adam等优化算法来实现；</li>
</ul>
<p>第二条优化验证集可以通过正则化，采用更多训练样本来实现；</p>
<p>第三条优化测试集可以通过使用更多的验证集样本来实现；</p>
<p>第四条提升实际应用模型可以通过更换验证集，使用新的cost function来实现。</p>
<p>概括来说，每一种“功能”对应不同的调节方法。而这些调节方法（旋钮）只会对应一个“功能”，是正交的。</p>
<p>顺便提一下，<strong>early stopping在模型功能调试中并不推荐使用</strong>。因为early stopping在提升验证集性能的同时降低了训练集的性能。也就是说early stopping同时影响两个“功能”，不具有独立性、正交性。</p>
<h4 id="8-1-3-单—数字评估指标"><a href="#8-1-3-单—数字评估指标" class="headerlink" title="8.1.3 单—数字评估指标"></a>8.1.3 单—数字评估指标</h4><p>构建、优化机器学习模型时，单值评价指标非常必要。有了量化的单值评价指标后，我们就能根据这一指标比较不同超参数对应的模型的优劣，从而选择最优的那个模型。</p>
<p>举个例子，比如有A和B两个模型，它们的<strong>准确率(Precision)</strong>和<strong>召回率(Recall)</strong>分别如下：</p>
<p><img src="https://pic.imgdb.cn/item/648aeddf1ddac507ccef3d76.png" style="zoom:80%"></p>
<p>如果只看Precision的话，B模型更好。如果只看Recall的话，A模型更好。实际应用中，我们通常使用单值评价指标<strong>F1 Score</strong>来评价模型的好坏。F1 Score综合了Precision和Recall的大小，计算方法如下：</p>
<script type="math/tex; mode=display">
F 1=\frac{2}{\frac1P+\frac1R}</script><p>然后得到了A和B模型各自的F1 Score：</p>
<p><img src="https://pic.imgdb.cn/item/648aedfc1ddac507ccefa608.png" style="zoom:80%"></p>
<p>从F1 Score来看，A模型比B模型更好一些。通过引入单值评价指标F1 Score，很方便对不同模型进行比较。</p>
<p>除了F1 Score之外，我们还可以使用<strong>平均值</strong>作为单值评价指标来对模型进行评估。如下图所示，A, B, C, D, E, F六个模型对不同国家样本的错误率不同，可以计算其平均性能，然后选择平均错误率最小的那个模型(C模型)。</p>
<p><img src="https://pic.imgdb.cn/item/648aeee81ddac507ccf2bf9c.png"></p>
<h4 id="8-1-4-满足和优化指标"><a href="#8-1-4-满足和优化指标" class="headerlink" title="8.1.4 满足和优化指标"></a>8.1.4 满足和优化指标</h4><p>有时候，要把所有的性能指标都综合在一起，构成单值评价指标是比较困难的。解决办法是，我们可以把某些性能作为<strong>优化指标(Optimizing metic)</strong>，寻求最优化值；而某些性能作为<strong>满意指标(Satisficing metic)</strong>，只要满足阈值就行了。</p>
<p>举个猫类识别的例子，有A，B，C三个模型，各个模型的Accuracy和Running time如下表中所示：</p>
<p><img src="https://pic.imgdb.cn/item/648aef171ddac507ccf359ea.png"></p>
<p>Accuracy和Running time这两个性能不合适综合成单值评价指标。因此，可以将Accuracy作为优化指标(Optimizing metic)，将Running time作为满意指标(Satisficing metic)。也就是说，给Running time设定一个阈值，在其满足阈值的情况下，选择Accuracy最大的模型。如果设定Running time必须在100ms以内，那么很明显，模型C不满足阈值条件，首先剔除；模型B相比较模型A而言，Accuracy更高，性能更好。</p>
<p>概括来说，性能指标(Optimizing metic)是需要优化的，越优越好；而满意指标(Satisficing metic)只要满足设定的阈值就好了。</p>
<h2 id="8-1-5-训练-验证-开发-测试集划分"><a href="#8-1-5-训练-验证-开发-测试集划分" class="headerlink" title="8.1.5 训练_验证(开发)_测试集划分"></a>8.1.5 训练_验证(开发)_测试集划分</h2><p>Train/dev/test sets如何设置对机器学习的模型训练非常重要，合理设置能够大大提高模型训练效率和模型质量。</p>
<p>原则上应该尽量保证dev sets和test sets来源于<strong>同一分布</strong>且都反映了实际样本的情况。如果dev sets和test sets不来自同一分布，那么我们从dev sets上选择的“最佳”模型往往不能够在test sets上表现得很好。</p>
<h2 id="8-1-6-开发集和测试集的大小"><a href="#8-1-6-开发集和测试集的大小" class="headerlink" title="8.1.6 开发集和测试集的大小"></a>8.1.6 开发集和测试集的大小</h2><p>在之前的课程中我们已经介绍过，当样本数量不多(小于一万)的时候，通常将Train/dev/test sets的比例设为60%/20%/20%，在没有dev sets的情况下，Train/test sets的比例设为70%/30%。当样本数量很大(百万级别)的时候，通常将相应的比例设为98%/1%/1%或者99%/1%。</p>
<p>对于dev sets数量的设置，应该遵循的准则是通过dev sets能够检测不同算法或模型的区别，以便选择出更好的模型。</p>
<p>对于test sets数量的设置，应该遵循的准则是通过test sets能够反映出模型在实际中的表现。</p>
<p>实际应用中，可能只有train/dev sets，而没有test sets。这种情况也是允许的，只要算法模型没有对dev sets过拟合。但是，条件允许的话，最好是有test sets，实现<strong>无偏估计</strong>。</p>
<h2 id="8-1-7什么时候该改变开发-测试集和指标"><a href="#8-1-7什么时候该改变开发-测试集和指标" class="headerlink" title="8.1.7什么时候该改变开发_测试集和指标"></a>8.1.7什么时候该改变开发_测试集和指标</h2><p>算法模型的评价标准有时候需要根据实际情况进行动态调整，目的是让算法模型在实际应用中有更好的效果。</p>
<p>举个猫类识别的例子。初始的评价标准是错误率，算法A错误率为3%，算法B错误率为5%。显然，A更好一些。但是，实际使用时发现算法A会通过一些色情图片，但是B没有出现这种情况。从用户的角度来说，他们可能更倾向选择B模型，虽然B的错误率高一些。这时候，我们就需要改变之前单纯只是使用错误率作为评价标准，而考虑新的情况进行改变。例如增加色情图片的权重，增加其代价。</p>
<p>原来的cost function：</p>
<script type="math/tex; mode=display">
J=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)</script><p>更改评价标准后的cost function：</p>
<script type="math/tex; mode=display">
\begin{aligned}J 
&=\frac{1}{w^{(i)}} \sum_{i=1}^{m} w^{(i)} L\left(\hat{y}^{(i)}, y^{(i)}\right) \\
w^{(i)} &= \begin{cases}1, & x^{(i)} \text { is non-porn } \\10, 
& x^{(i)} \text { is porn }
\end{cases}
\end{aligned}</script><p>概括来说，机器学习可分为两个过程：</p>
<pre><code>**(1)** Define a metric to evaluate classifiers

**(2)** How to do well on this metric
</code></pre><p>也就是说，第一步是找靶心，第二步是通过训练，射中靶心。但是在训练的过程中可能会根据实际情况改变算法模型的评价标准，进行动态调整。</p>
<p>另外一个需要动态改变评价标准的情况是dev/test sets与实际使用的样本分布不一致。比如猫类识别样本图像分辨率差异。</p>
<p><img src="https://pic.imgdb.cn/item/648aeffc1ddac507ccf70033.png"></p>
<h2 id="8-1-8-为什么是人的表现"><a href="#8-1-8-为什么是人的表现" class="headerlink" title="8.1.8 为什么是人的表现"></a>8.1.8 为什么是人的表现</h2><p>机器学习模型的表现通常会跟人类水平表现作比较，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/648af01f1ddac507ccf77cd4.png" style="zoom:50%"></p>
<p>图中，横坐标是训练时间，纵坐标是准确性。机器学习模型经过训练会不断接近human-level performance甚至超过它。但是，超过human-level performance之后，准确性会上升得比较缓慢，最终不断接近理想的最优情况，称之为<strong>贝叶斯最优误差(bayes optimal error)</strong>。理论上任何模型都不能超过它，bayes optimal error代表了最佳表现。</p>
<p>实际上，human-level performance在某些方面有不俗的表现。例如图像识别、语音识别等领域，人类是很擅长的。所以，让机器学习模型性能不断接近human-level performance非常必要也做出很多努力：</p>
<ul>
<li>Get labeled data from humans.</li>
<li>Gain insight from manual error analysis: Why did a person get this right?</li>
<li>Better analysis of bias/variance.</li>
</ul>
<h2 id="8-1-9-可避免偏差"><a href="#8-1-9-可避免偏差" class="headerlink" title="8.1.9 可避免偏差"></a>8.1.9 可避免偏差</h2><p>实际应用中，要看human-level error，training error和dev error的相对值。例如猫类识别的例子中，如果human-level error为1%，training error为8%，dev error为10%。由于training error与human-level error相差7%，dev error与training error只相差2%，所以目标是尽量在训练过程中减小training error，即减小偏差bias。如果图片很模糊，肉眼也看不太清，human-level error提高到7.5%。这时，由于training error与human-level error只相差0.5%，dev error与training error只相差2%，所以目标是尽量在训练过程中减小dev error，即方差variance。这是相对而言的。</p>
<p>对于物体识别这类CV问题，human-level error是很低的，很接近理想情况下的bayes optimal error。因此，上面例子中的1%和7.5%都可以近似看成是两种情况下对应的bayes optimal error。实际应用中，我们一般会用human-level error代表bayes optimal error。</p>
<p>通常，<strong>把training error与human-level error的差值称为bias，也称作avoidable bias</strong>；<strong>把dev error与training error之间的差值称为variance</strong>。根据bias和variance值的相对大小，可以知道算法模型是否发生了欠拟合或者过拟合。</p>
<h2 id="8-1-10-理解人的表现"><a href="#8-1-10-理解人的表现" class="headerlink" title="8.1.10 理解人的表现"></a>8.1.10 理解人的表现</h2><p>我们说过human-level performance能够代表bayes optimal error。但是，human-level performance如何定义呢？举个医学图像识别的例子，不同人群的error有所不同：</p>
<ul>
<li><strong>Typical human : 3% error</strong></li>
<li><strong>Typical doctor : 1% error</strong></li>
<li><strong>Experienced doctor : 0.7% error</strong></li>
<li><strong>Team of experienced doctors : 0.5% error</strong><br>不同人群他们的错误率不同。一般来说，我们将表现最好的那一组，即Team of experienced doctors作为human-level performance。那么，这个例子中，human-level error就为0.5%。但是实际应用中，不同人可能选择的human-level performance基准是不同的，这会带来一些影响。</li>
</ul>
<p>假如该模型training error为0.7%，dev error为0.8。如果选择Team of experienced doctors，即human-level error为0.5%，则bias比variance更加突出。如果选择Experienced doctor，即human-level error为0.7%，则variance更加突出。也就是说，选择什么样的human-level error，有时候会影响bias和variance值的相对变化。当然这种情况一般只会在模型表现很好，接近bayes optimal error的时候出现。越接近bayes optimal error，模型越难继续优化，因为这时候的human-level performance可能是比较模糊难以准确定义的。</p>
<h2 id="8-1-11-超过人的表现"><a href="#8-1-11-超过人的表现" class="headerlink" title="8.1.11 超过人的表现"></a>8.1.11 超过人的表现</h2><p>对于自然感知类问题，例如视觉、听觉等，机器学习的表现不及人类。但是在很多其它方面，机器学习模型的表现已经超过人类了，包括：</p>
<ul>
<li>Online advertising</li>
<li>Product recommendations</li>
<li>Logistics(predicting transit time)</li>
<li>Loan approvals<br>实际上，机器学习模型超过human-level performance是比较困难的。但是只要提供足够多的样本数据，训练复杂的神经网络，模型预测准确性会大大提高，很有可能接近甚至超过human-level performance。值得一提的是当算法模型的表现超过human-level performance时，很难再通过人的直觉来解决如何继续提高算法模型性能的问题。</li>
</ul>
<h2 id="8-1-12-改善你模型的表现"><a href="#8-1-12-改善你模型的表现" class="headerlink" title="8.1.12 改善你模型的表现"></a>8.1.12 改善你模型的表现</h2><p>提高机器学习模型性能主要要解决两个问题：<strong>avoidable bias和variance</strong>。我们之前介绍过，training error与human-level error之间的差值反映的是avoidable bias，dev error与training error之间的差值反映的是variance。</p>
<p>解决avoidable bias的常用方法包括：</p>
<ul>
<li>Train bigger model</li>
<li>Train longer/better optimization algorithms: momentum, RMSprop, Adam</li>
<li>NN architecture/hyperparameters search<br>解决variance的常用方法包括：</li>
<li>More data</li>
<li>Regularization: L2, dropout, data augmentation</li>
<li>NN architecture/hyperparameters search</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/648af1351ddac507ccfaeda9.png"></p>
<h2 id="8-2-1-进行误差分析"><a href="#8-2-1-进行误差分析" class="headerlink" title="8.2.1 进行误差分析"></a>8.2.1 进行误差分析</h2><p>对已经建立的机器学习模型进行错误分析(error analysis)十分必要，而且有针对性地、正确地进行error analysis更加重要。</p>
<p>举个例子，猫类识别问题，已经建立的模型的错误率为10%。为了提高正确率，我们发现该模型会将一些狗类图片错误分类成猫。一种常规解决办法是扩大狗类样本，增强模型对够类(负样本)的训练。但是，这一过程可能会花费几个月的时间，耗费这么大的时间成本到底是否值得呢？也就是说扩大狗类样本，重新训练模型，对提高模型准确率到底有多大作用？这时候我们就需要进行error analysis，帮助我们做出判断。</p>
<p>方法很简单，我们可以从分类错误的样本中<strong>统计</strong>出狗类的样本数量。根据狗类样本所占的比重，判断这一问题的重要性。假如狗类样本所占比重仅为5%，即时我们花费几个月的时间扩大狗类样本，提升模型对其识别率，改进后的模型错误率最多只会降低到9.5%。相比之前的10%，并没有显著改善。我们把这种性能限制称为<strong>ceiling on performance</strong>。相反，假如错误样本中狗类所占比重为50%，那么改进后的模型错误率有望降低到5%，性能改善很大。因此，值得去花费更多的时间扩大狗类样本。</p>
<p>这种error analysis虽然简单，但是能够避免花费大量的时间精力去做一些对提高模型性能收效甚微的工作，让我们专注解决影响模型正确率的主要问题，十分必要。</p>
<p>这种error analysis可以同时评估多个影响模型性能的因素，通过各自在错误样本中所占的比例来判断其重要性。例如，猫类识别模型中，可能有以下几个影响因素：</p>
<ul>
<li>Fix pictures of dogs being recognized as cats</li>
<li>Fix great cats(lions, panthers, etc…) being misrecognized</li>
<li>Improve performance on blurry images<br>通常来说，比例越大，影响越大，越应该花费时间和精力着重解决这一问题。这种error analysis让我们改进模型更加有针对性，从而提高效率。</li>
</ul>
<h2 id="8-2-2-清除错误的数据"><a href="#8-2-2-清除错误的数据" class="headerlink" title="8.2.2 清除错误的数据"></a>8.2.2 清除错误的数据</h2><p>监督式学习中，训练样本有时候会出现输出<script type="math/tex">y</script>标注错误的情况，即incorrectly labeled examples。如果这些label标错的情况是随机性的(random errors)，DL算法对其包容性是比较强的，即健壮性好，一般可以直接忽略，无需修复。然而，如果是系统错误(systematic errors)，这将对DL算法造成影响，降低模型性能。</p>
<p>刚才说的是训练样本中出现incorrectly labeled data，如果是dev/test sets中出现incorrectly labeled data，该怎么办呢？</p>
<p>方法很简单，利用上节内容介绍的error analysis，统计dev sets中所有分类错误的样本中incorrectly labeled data所占的比例。根据该比例的大小，决定是否需要修正所有incorrectly labeled data，还是可以忽略。举例说明，若：</p>
<ul>
<li>Overall dev set error: 10%</li>
<li>Errors due incorrect labels: 0.6%</li>
<li>Errors due to other causes: 9.4%<br>上面数据表明Errors due incorrect labels所占的比例仅为0.6%，占dev set error的6%，而其它类型错误占dev set error的94%。因此，这种情况下，可以忽略incorrectly labeled data。</li>
</ul>
<p>如果优化DL算法后，出现下面这种情况：</p>
<ul>
<li>Overall dev set error: 2%</li>
<li>Errors due incorrect labels: 0.6%</li>
<li>Errors due to other causes: 1.4%<br>上面数据表明Errors due incorrect labels所占的比例依然为0.6%，但是却占dev set error的30%，而其它类型错误占dev set error的70%。因此，这种情况下，incorrectly labeled data不可忽略，需要手动修正。</li>
</ul>
<p>我们知道，dev set的主要作用是在不同算法之间进行比较，选择错误率最小的算法模型。但是，如果有incorrectly labeled data的存在，当不同算法错误率比较接近的时候，我们无法仅仅根据Overall dev set error准确指出哪个算法模型更好，必须修正incorrectly labeled data。</p>
<p>关于<strong>修正incorrect dev/test set data</strong>，有几条建议：</p>
<ul>
<li>Apply same process to your dev and test sets to make sure they continue to come from the same distribution</li>
<li>Consider examining examples your algorithm got right as well as ones it got wrong</li>
<li>Train and dev/test data may now come from slightly different distributions</li>
</ul>
<h2 id="8-2-3-快速搭建你的第一个系统"><a href="#8-2-3-快速搭建你的第一个系统" class="headerlink" title="8.2.3 快速搭建你的第一个系统"></a>8.2.3 快速搭建你的第一个系统</h2><p>对于如何构建一个机器学习应用模型，Andrew给出的建议是先快速构建第一个简单模型，然后再反复迭代优化。</p>
<ul>
<li>Set up dev/test set and metric</li>
<li>Build initial system quickly</li>
<li>Use Bias/Variance analysis &amp; Error analysis to prioritize next steps</li>
</ul>
<h2 id="8-2-4-在不同的划分上进行训练并测试"><a href="#8-2-4-在不同的划分上进行训练并测试" class="headerlink" title="8.2.4 在不同的划分上进行训练并测试"></a>8.2.4 在不同的划分上进行训练并测试</h2><p>当train set与dev/test set不来自同一个分布的时候，我们应该如何解决这一问题，构建准确的机器学习模型呢？</p>
<p>以猫类识别为例，train set来自于网络下载(webpages)，图片比较清晰；dev/test set来自用户手机拍摄(mobile app)，图片比较模糊。假如train set的大小为200000，而dev/test set的大小为10000，显然train set要远远大于dev/test set。</p>
<p><img src="https://pic.imgdb.cn/item/648af1f21ddac507ccfd9ad4.png"></p>
<p>虽然dev/test set质量不高，但是模型最终主要应用在对这些模糊的照片的处理上。面对train set与dev/test set分布不同的情况，有两种解决方法。</p>
<p>第一种方法是将train set和dev/test set完全混合，然后在随机选择一部分作为train set，另一部分作为dev/test set。例如，混合210000例样本，然后随机选择205000例样本作为train set，2500例作为dev set，2500例作为test set。这种做法的优点是实现train set和dev/test set分布一致，缺点是dev/test set中webpages图片所占的比重比mobile app图片大得多。例如dev set包含2500例样本，大约有2381例来自webpages，只有119例来自mobile app。这样，dev set的算法模型对比验证，仍然主要由webpages决定，实际应用的mobile app图片所占比重很小，达不到验证效果。因此，这种方法并不是很好。</p>
<p>第二种方法是将原来的train set和一部分dev/test set组合当成train set，剩下的dev/test set分别作为dev set和test set。例如，200000例webpages图片和5000例mobile app图片组合成train set，剩下的2500例mobile app图片作为dev set，2500例mobile app图片作为test set。其关键在于dev/test set全部来自于mobile app。这样保证了验证集最接近实际应用场合。这种方法较为常用，而且性能表现比较好。</p>
<h2 id="8-2-5-不匹配数据划分的偏差和方差"><a href="#8-2-5-不匹配数据划分的偏差和方差" class="headerlink" title="8.2.5 不匹配数据划分的偏差和方差"></a>8.2.5 不匹配数据划分的偏差和方差</h2><p>我们之前介绍过，根据human-level error、training error和dev error的相对值可以判定是否出现了bias或者variance。但是，需要注意的一点是，<strong>如果train set和dev/test set来源于不同分布，则无法直接根据相对值大小来判断。</strong>例如某个模型human-level error为0%，training error为1%，dev error为10%。根据我们之前的理解，显然该模型出现了variance。但是，training error与dev error之间的差值9%可能来自<strong>算法本身(variance)</strong>，也可能来自于<strong>样本分布不同</strong>。比如dev set都是很模糊的图片样本，本身就难以识别，跟算法模型关系不大。因此不能简单认为出现了variance。</p>
<p>在可能伴有train set与dev/test set分布不一致的情况下，定位是否出现variance的方法是<strong>设置train-dev set</strong>。Andrew给train-dev set的定义是：“Same distribution as training set, but not used for training.”也就是说，从原来的train set中分割出一部分作为train-dev set，train-dev set不作为训练模型使用，而是<strong>与dev set一样用于验证</strong>。</p>
<p>这样，我们就有training error、training-dev error和dev error三种error。其中，training error与training-dev error的差值反映了variance；training-dev error与dev error的差值反映了data mismatch problem，即样本分布不一致。</p>
<p>举例说明，如果training error为1%，training-dev error为9%，dev error为10%，则variance问题比较突出。如果training error为1%，training-dev error为1.5%，dev error为10%，则data mismatch problem比较突出。通过引入train-dev set，能够比较准确地定位出现了variance还是data mismatch。</p>
<p>总结一下human-level error、training error、training-dev error、dev error以及test error之间的差值关系和反映的问题：</p>
<p><img src="https://pic.imgdb.cn/item/648af21f1ddac507ccfe4d12.png" style="zoom:60%"></p>
<p>一般情况下，human-level error、training error、training-dev error、dev error以及test error的数值是递增的，但是也会出现dev error和test error下降的情况。这主要可能是因为训练样本比验证/测试样本更加复杂，难以训练。</p>
<p><img src="https://pic.imgdb.cn/item/648af3071ddac507cc01d8e0.png"></p>
<h2 id="8-2-6-解决数据不匹配"><a href="#8-2-6-解决数据不匹配" class="headerlink" title="8.2.6 解决数据不匹配"></a>8.2.6 解决数据不匹配</h2><p>关于如何解决train set与dev/test set样本分布不一致的问题，有两条建议：</p>
<ul>
<li>Carry out manual error analysis to try to understand difference between training dev/test sets</li>
<li>Make training data more similar; or collect more data similar to dev/test sets<br>为了让train set与dev/test set类似，可以用<strong>人工数据合成(artificial data synthesis)</strong>方法。例如说话人识别问题，实际应用场合(dev/test set)是包含背景噪声的，而训练样本train set很可能没有背景噪声。为了让train set与dev/test set分布一致，我们可以在train set上人工添加背景噪声，合成类似实际场景的声音。这样会让模型训练的效果更准确。</li>
</ul>
<p>但需要注意的是，我们不能给每段语音都增加同一段背景噪声，这样会出现对背景噪音的<strong>过拟合</strong>，效果不佳。这就是人工数据合成需要注意的地方。</p>
<h2 id="8-2-7-迁移学习"><a href="#8-2-7-迁移学习" class="headerlink" title="8.2.7 迁移学习"></a>8.2.7 迁移学习</h2><p>深度学习非常强大的一个功能之一就是有时候你可以将已经训练好的模型的一部分知识（网络结构）直接应用到另一个类似模型中去。比如我们已经训练好一个猫类识别的神经网络模型，那么我们可以直接把该模型中的一部分网络结构应用到使用X光片预测疾病的模型中去。这种学习方法被称为<strong>迁移学习(Transfer Learning)</strong>。</p>
<p>如果我们已经有一个训练好的神经网络，用来做图像识别。现在，我们想要构建另外一个通过X光片进行诊断的模型。迁移学习的做法是无需重新构建新的模型，而是利用之前的神经网络模型，只改变样本输入、输出以及输出层的权重系数<script type="math/tex">W^{[L]}, b^{[L]}</script>。也就是说对新的样本<script type="math/tex">(X,Y)</script>，重新训练输出层权重系数<script type="math/tex">W^{[L]}, b^{[L]}</script>，而其它层所有的权重系数<script type="math/tex">W^{[L]}, b^{[L]}</script>保持不变。</p>
<p><img src="https://pic.imgdb.cn/item/648af3561ddac507cc02ff49.png"></p>
<p>迁移学习，重新训练权重系数，如果需要构建新模型的样本数量较少，那么可以像刚才所说的，只训练输出层的权重系数<script type="math/tex">W^{[L]}, b^{[L]}</script>，保持其它层所有的权重系数<script type="math/tex">W^{[L]}, b^{[L]}</script>不变。这种做法相对来说比较简单。如果样本数量足够多，那么也可以只保留网络结构，重新训练所有层的权重系数。这种做法使得模型更加精确，因为毕竟样本对模型的影响最大。选择哪种方法通常由数据量决定。</p>
<p>顺便提一下，如果重新训练所有权重系数，初始<script type="math/tex">W^{[L]}, b^{[L]}</script>由之前的模型训练得到，这一过程称为<strong>pre-training</strong>。之后不断调试、优化<script type="math/tex">W^{[L]}, b^{[L]}</script>的过程称为<strong>fine-tuning</strong>。pre-training和fine-tuning分别对应上图中的黑色箭头和红色箭头。</p>
<p>迁移学习之所以能这么做的原因是，神经网络浅层部分能够检测出许多图片固有<strong>特征</strong>，例如图像边缘、曲线等。使用之前训练好的神经网络部分结果有助于我们更快更准确地提取X光片特征。二者处理的都是图片，而图片处理是有相同的地方，第一个训练好的神经网络已经帮我们实现如何提取图片有用特征了。 因此，即便是即将训练的第二个神经网络样本数目少，仍然可以根据第一个神经网络结构和权重系数得到健壮性好的模型。</p>
<p>迁移学习可以保留原神经网络的一部分，再添加新的网络层。具体问题，具体分析，可以去掉输出层后再增加额外一些神经层。</p>
<p><img src="https://pic.imgdb.cn/item/648af3a01ddac507cc040506.png"></p>
<p>总体来说，迁移学习的应用场合主要包括三点：</p>
<ul>
<li>Task A and B have the same input x.</li>
<li>You have a lot more data for Task A than Task B.</li>
<li>Low level features from A could be helpful for learning B.</li>
</ul>
<h2 id="8-2-8-多任务学习"><a href="#8-2-8-多任务学习" class="headerlink" title="8.2.8 多任务学习"></a>8.2.8 多任务学习</h2><p>多任务学习(multi-task learning)就是构建神经网络同时执行多个任务。这跟二元分类或者多元分类都不同，多任务学习类似将多个神经网络融合在一起，用一个网络模型来实现多种分类效果。如果有<script type="math/tex">C</script>个，那么输出<script type="math/tex">y</script>的维度是<script type="math/tex">(C,1)</script>。</p>
<p>例如汽车自动驾驶中，需要实现的多任务为行人、车辆、交通标志和信号灯。如果检测出汽车和交通标志，则<script type="math/tex">y</script>为：</p>
<script type="math/tex; mode=display">
y = [1,0,0,1]^{\text T}</script><p>多任务学习模型的cost function为：</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{1}{m} \sum_{i=1}^{m} \sum_{j=1}^{c} L\left(\hat{y}_{j}^{(i)}, y_{j}^{(i)}\right)
\end{equation}</script><p>其中，<script type="math/tex">j</script>表示任务下标，总有<script type="math/tex">c</script>个任务。对应的loss function为：</p>
<script type="math/tex; mode=display">
L\left(\hat{y}_{j}^{(i)}, y_{j}^{(i)}\right)=-y_{j}^{(i)} \log \hat{y}_{j}^{(i)}-\left(1-y_{j}^{(i)}\right) \log \left(1-\hat{y}_{j}^{(i)}\right)</script><p>值得一提的是，Multi-task learning与Softmax regression的区别在于Softmax regression是single label的，即输出向量y只有一个元素为1；而Multi-task learning是multiple labels的，即输出向量y可以有多个元素为1。</p>
<p>多任务学习是使用单个神经网络模型来实现多个任务。实际上，也可以分别构建多个神经网络来实现。但是，如果各个任务之间是相似问题(例如都是图片类别检测)，则可以使用多任务学习模型。另外，多任务学习中，可能存在训练样本<script type="math/tex">Y</script>某些label空白的情况，这并不影响多任务模型的训练。</p>
<p>总体来说，多任务学习的应用场合主要包括三点：</p>
<pre><code>Training on a set of tasks that could benefit from having shared lower-level features.

Usually: Amount of data you have for each task is quite similar.

Can train a big enough neural network to do well on all the tasks.
</code></pre><p>顺便提一下，迁移学习和多任务学习在实际应用中，迁移学习使用得更多一些。</p>
<h2 id="8-2-9-什么是端到端的深度学习"><a href="#8-2-9-什么是端到端的深度学习" class="headerlink" title="8.2.9 什么是端到端的深度学习"></a>8.2.9 什么是端到端的深度学习</h2><p>端到端(end-to-end)深度学习就是将所有不同阶段的数据处理系统或学习系统模块组合在一起，用一个单一的神经网络模型来实现所有的功能。它将所有模块混合在一起，只关心输入和输出。</p>
<p>以语音识别为例，传统的算法流程和end-to-end模型的区别如下：</p>
<p><img src="https://pic.imgdb.cn/item/648af3d61ddac507cc04b689.png"></p>
<p>如果训练样本足够大，神经网络模型足够复杂，那么end-to-end模型性能比传统机器学习分块模型更好。实际上，end-to-end让神经网络模型内部去自我训练模型特征，自我调节，增加了模型整体契合度。</p>
<h2 id="8-2-10-是否要使用端到端的深度学习"><a href="#8-2-10-是否要使用端到端的深度学习" class="headerlink" title="8.2.10 是否要使用端到端的深度学习"></a>8.2.10 是否要使用端到端的深度学习</h2><p>end-to-end深度学习有优点也有缺点。</p>
<p>优点：</p>
<pre><code>Let the data speak

Less hand-designing of components needed
</code></pre><p>缺点：</p>
<pre><code>May need large amount of data

Excludes potentially useful hand-designed
</code></pre><p><strong>到这里这门课程的学习暂告一段落(ps：并不是不学了，接下来学习一些网络CNN、读一些论文看看再决定下一步得计划)</strong></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>参考链接1：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1FT4y1E74V?p=1">吴恩达深度学习deeplearning.ai</a></p>
<p>参考链接2：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wuzhongqiang/article/details/89702268">本笔记参考链接</a></p>
<p>参考链接3：<a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1007644614324535296">吴恩达机器学习课思维导图</a></p>
<p>参考链接4：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43061212/article/details/82750763?utm_source=app&amp;app_version=4.20.0">DeepLearning吴恩达深度学习课程笔记思维导图</a></p>
<p>参考链接5：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yg411K72z">三个月从零入门深度学习，保姆级学习路线图</a></p>
<p>参考链接6：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yg411K72z">【人工智能学习】逐句阅读100篇核心AI论文（双语字幕）</a></p>
<p>参考链接7：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37349519">纯新手自学入门机器/深度学习指南） - 量子位的文章 - 知乎</a></p>
<p>参考链接8：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Lv41177BW/">Pytorch环境安装配置 - Bilibili</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"> 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://junheng-wang.github.io/2022/04/26/Foundation-of-DeepLearning/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/" rel="tag">深度学习基础</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/04/26/Basic-knowledge-of-programming-software/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            编程软件基础知识——杂记
          
        </div>
      </a>
    
    
      <a href="/2022/04/25/Python-code-tips/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Python其他小知识</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "0DieopImIy7vnuzj4jQ2wk6O-gzGzoHsz",
    app_key: "j6eRiYtlDSl8eRXVN54blF25",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> wjh
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Wang Junheng"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/Alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechatpay.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>