<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="���͡�ѧϰ�����˼�������С�����" />
       
      <meta name="description" content="���˺�����" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>计算机科学速成课 |  Wang Junheng</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Crash-Course-Computer-Science"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  计算机科学速成课
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/07/29/Crash-Course-Computer-Science/" class="article-date">
  <time datetime="2024-07-29T07:52:15.000Z" itemprop="datePublished">2024-07-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E6%8F%90%E5%8D%87/">学习提升</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E6%8F%90%E5%8D%87/%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">编程与深度学习</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E6%8F%90%E5%8D%87/%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">编程语言学习</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">21.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">74 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="1-计算机早期历史"><a href="#1-计算机早期历史" class="headerlink" title="1 计算机早期历史"></a>1 计算机早期历史</h3><h4 id="1-1-计算机的重要性"><a href="#1-1-计算机的重要性" class="headerlink" title="1.1 计算机的重要性"></a>1.1 计算机的重要性</h4><p>计算机是当今世界的命脉，如果突然关掉所有计算机，那么世界将会直接乱套。我们生活中很多产品也都是依靠计算机生产出来的。所以说，<strong>计算机改变了我们生活几乎所有方面，计算机对我们社会的重要性不言而喻。</strong></p>
<h4 id="1-2-计算机的发展"><a href="#1-2-计算机的发展" class="headerlink" title="1.2 计算机的发展"></a>1.2 计算机的发展</h4><p>略。。。</p>
<h3 id="2-电子计算机"><a href="#2-电子计算机" class="headerlink" title="2 电子计算机"></a>2 电子计算机</h3><p>上节提到，用于特定场景的计算设备，如制表机，大大提高了企业和政府的工作效率。但是随着社会的发展，交通运输、科学研究甚至航空航天等发展，人民需要计算能力更强的机器。这种计算能力更强的机器，往往体积巨大，耗电量巨大，这为后面的创新埋下伏笔。</p>
<h4 id="2-1-传统大型计算机的缺点"><a href="#2-1-传统大型计算机的缺点" class="headerlink" title="2.1 传统大型计算机的缺点"></a>2.1 传统大型计算机的缺点</h4><p>传统计算机主要有<strong>两个缺点</strong></p>
<ul>
<li>运算速度慢，进行普通的加减乘除的耗时都很长；</li>
<li>齿轮等计算机机械组件磨损，导致早期计算机容易出现Bug。</li>
</ul>
<p>最大的机电计算机是<strong>哈佛马克一号</strong>，由IBM公司完成，它由着数十万组件、上百万连接点和几百英里的导线，这台机器最早是用于给“曼哈顿计划”跑模拟。这台机器的大脑是<strong>继电器。</strong></p>
<p><strong>什么是继电器</strong></p>
<p>继电器是用电控制的机械开关。继电器有根“控制线路”，控制电路是开还是关。当螺线圈通过电时，其会产生磁场，吸引上面的线闭合，达到连通的目的。这个继电器可以用于机器进行控制。</p>
<p><img src="https://pic.imgdb.cn/item/66a75235d9c307b7e9f96b38.png"></p>
<p>糟糕的是，继电器开关有一定质量，这会影响其闭合。其一秒能够闭合50次，<strong>导致计算机的运算非常慢（完成一次加减乘除需要几秒钟）</strong>。</p>
<p><strong>除了速度慢，另一个限制是齿轮磨损。</strong>随着机器的不断运行，器件的磨损不可避免。哈佛马克一号有上千的继电器，任何一个发生故障，就会导致计算出错。</p>
<p>此外，黑色的温暖的环境，也会使虫子滋生。虫子，英文命Bug。<strong>虫子附着在大型计算机的组件上，会导致其运行出错。那么，机器故障（Bug）的来源也是此。</strong></p>
<h4 id="2-2-电子管"><a href="#2-2-电子管" class="headerlink" title="2.2 电子管"></a>2.2 电子管</h4><p>显然，未来要想继续制造出更强大的计算机，就必须用其他东西代替继电器。幸运的是，一个新的电子组件出现了——“<strong>热电子管</strong>”。这种电子管只能运行电流单向运动，当电流反向时，电子管不能发光。这种管叫“<strong>二极管</strong>”。</p>
<p>但是，要怎么利用电子管进行开关控制呢？答案就是——<strong>真空三极管</strong></p>
<p>聪明的人民在二极管中添加了一根导线。利用这跟导线，可以控制向电子添加正电荷或者负电荷，来控制电流的流通。</p>
<p><img src="https://pic.imgdb.cn/item/66a75337d9c307b7e9fa5127.png" alt="三极管" style="zoom:50%"></p>
<p>三极管和继电器有着相同的功能，但是由于没有部件的物理移动，所以它的磨损很少，开闭速度可以达到上千次每秒。这种真空三极管，在电子设备中大量运用，持续了近半个世纪。</p>
<p>刚开始时，这种三极管造价昂贵，而且一个计算机需要上千个电气开关。不过随着时间推移，一些政府部门可以承担这种价格，这种三极管开始应用计算机。标志着<strong>计算机从机电转向电子。</strong></p>
<h4 id="2-3-电子计算机"><a href="#2-3-电子计算机" class="headerlink" title="2.3 电子计算机"></a>2.3 电子计算机</h4><p>世界上第一台电子计算机造成于英国，名叫<strong>“巨人一号”</strong>，它有1600个真空管。最初是英国政府用来破解纳粹的通信加密密码的。<strong>巨人，被认为是第一个可编程的计算机。</strong></p>
<p><strong>世界上第一个真正的通用的可编程计算机，是ENIAC。</strong>不过由于真空管很多，它几乎半天就会出现一次故障。</p>
<h4 id="2-4-晶体管"><a href="#2-4-晶体管" class="headerlink" title="2.4 晶体管"></a>2.4 晶体管</h4><p>为了降低成本和大小，同时提高可靠性和速度，我们需要一种新的电子开关。<strong>1947年，贝尔实验室发明了晶体管（晶体三极管）。</strong>一个全新的计算机时代来临了。</p>
<p><img src="https://pic.imgdb.cn/item/66a764fdd9c307b7e90b4dd4.png" alt="晶体管" style="zoom:50%"></p>
<p>晶体管的物理性特别复杂，涉及到量子力学。简单地来说，晶体管的制造需要半导体材料，通过控制基极电荷，控于控制半导体材料的导电性，来是否允许电流的流动。</p>
<p>晶体管具有很好的开关速度，且其为固态的，比起易碎的玻璃电子管。其体积也远小于继电器或者真空管。<strong>这样我们就能制造出更小更便宜的计算机</strong>。</p>
<p>如今，晶体管小至几十纳米，运算次数达到几十上百万，并且有几十年的寿命。</p>
<h3 id="3-布尔逻辑和逻辑门"><a href="#3-布尔逻辑和逻辑门" class="headerlink" title="3 布尔逻辑和逻辑门"></a>3 布尔逻辑和逻辑门</h3><h4 id="3-1-什么是二进制"><a href="#3-1-什么是二进制" class="headerlink" title="3.1 什么是二进制"></a>3.1 什么是二进制</h4><p>前文我们提到，计算机最早是机电设备，一般用十进制计数，比如用齿轮数代表十进制，再到晶体管计算机。</p>
<p>幸运的是，只用开关两种状态也可以代表信息。这种叫做<strong>二进制，意思是用两种状态表示</strong>。</p>
<p>你可能认为只用两种状态能表示的信息不多，不过这对计算机来说有很多好处。对于电子元件：电路闭合，有电流通过，代表真；电路断开，无电流通过，代表假。二进制也可以写成0和1。</p>
<h4 id="3-2-为什么使用二进制？"><a href="#3-2-为什么使用二进制？" class="headerlink" title="3.2 为什么使用二进制？"></a>3.2 为什么使用二进制？</h4><ul>
<li>二进制表示的状态相对于其他进制更容易区分。</li>
<li>二进制已经有一个专门研究的数学分支——<strong>布尔代数</strong>，在此方面已经有较大的发展了。</li>
</ul>
<p>当初，一些早期的计算机是三进制的，甚至是五进制的。问题是状态越多，越难区分不同的状态，信号可能会发生交叠。所以，<strong>我们用信号的开和闭，尽可能地减少这种问题</strong>。</p>
<p><strong>另一个使用二进制的原因，就是有一整个数学分支，专门处理“真”和“假”</strong>。它已经解决了所有法则和符号问题，这个数学分支叫“<strong>布尔代数</strong>”。</p>
<h4 id="3-3-布尔代数及基本逻辑门单元"><a href="#3-3-布尔代数及基本逻辑门单元" class="headerlink" title="3.3 布尔代数及基本逻辑门单元"></a>3.3 布尔代数及基本逻辑门单元</h4><p>布尔代数的基本单元不是数学中的数字，而是<strong>非（NOT）</strong>，<strong>与（AND）</strong>、<strong>或（OR）</strong>和<strong>异或（XOR）</strong>等。那么这几种符号的作用，学数字电路中已经接触很多了。下面简单这几种逻辑门介绍：</p>
<p><strong>非（NOT）</strong>：输出与输入相反，输入真，输出假，反之亦然。<br><strong>与（AND）</strong>：两个输入仅同真输出真，若有一假则为假。<br><strong>或（OR）</strong>：两个输入只要有一个是真，则输入为真。<br><strong>异或（XOR）</strong>：两输入相异则输出真，两输入相同则输出假。 </p>
<p>不过，设计师在设计电路和芯片时，不需要考虑这些晶体管是如何设计或电子是怎么流过半导体的。他们需要考虑的是抽象层次的东西，很少在晶体管层次考虑，而是考虑逻辑门或者更大的组件。 </p>
<h3 id="4-二进制"><a href="#4-二进制" class="headerlink" title="4 二进制"></a>4 二进制</h3><h4 id="4-1-二进制的数字表示"><a href="#4-1-二进制的数字表示" class="headerlink" title="4.1 二进制的数字表示"></a>4.1 二进制的数字表示</h4><p>要想表示更多的信息，就要增加数字表示的位数，类似十进制那样。多位数字，如“263”，就能表示比10更大的数。这种逢十进一的数字表示方法，就是十进制（基于十的表示法）。</p>
<p><strong>二进制也一样，它是基于2的表示法，其只有两个数字，0和1。</strong>多位二进制表示法，应该按权值展开，如下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/66a769b9d9c307b7e91029b0.png" style="zoom:50%"></p>
<h4 id="4-2-二进制的加法"><a href="#4-2-二进制的加法" class="headerlink" title="4.2 二进制的加法"></a>4.2 二进制的加法</h4><p>二进制的加法和十进制一样，满足条件则进一。如下图的二进制加法。</p>
<p><img src="https://pic.imgdb.cn/item/66a76a20d9c307b7e910750f.png" style="zoom:50%"></p>
<h4 id="4-3-字节"><a href="#4-3-字节" class="headerlink" title="4.3 字节"></a>4.3 字节</h4><p>二进制中，一个1或0叫做一位，即一个位(bit)有两个不同状态0和1，<strong>8位叫做一个字节</strong>。即1字节=8位。我们的32为或64位电脑，指的是一次能进行32位的或64位的同时计算。</p>
<p>除了字节外，还有KB、MB和TB等，转化关系如下表所示。</p>
<script type="math/tex; mode=display">
1 \text{ Byte} = 8 \text{ bit} \\
1 \text{ KB} = 2^{10} \text{ Byte} \\
1 \text{ MB} = 2^{10} \text{ KB} \\
1 \text{ GB} = 2^{10} \text{ MB} \\
1 \text{ TB} = 2^{10} \text{ GB}</script><h4 id="4-4-计算机中的正负表示"><a href="#4-4-计算机中的正负表示" class="headerlink" title="4.4 计算机中的正负表示"></a>4.4 计算机中的正负表示</h4><p>计算机中，大多<u>用第一位表示正负，1是负，0是正</u>。</p>
<p>后面，我们还会讲到，计算机会给内存中的每一个位置，做一个标记，这个标记叫位址，目的是为了方便存取数据。因为现在的数据量越来越大，内存地址也有64位。</p>
<h4 id="4-5-计算机中的浮点数"><a href="#4-5-计算机中的浮点数" class="headerlink" title="4.5 计算机中的浮点数"></a>4.5 计算机中的浮点数</h4><p>我们有几种方法表示浮点数，最常用的是<strong><font color="red">IEEE 754标准</font></strong>。它用类似科学计数法的方法，来存十进制数。对于32位浮点数，第一位表示正负，后面8位表示指数，最后23位表示有效数。</p>
<p>例如，$625.9 = 0.6259*10^3$，其中，$6259$为有效位数，$3$是指数，其在计算机中的表示如下图。</p>
<p><img src="https://pic.imgdb.cn/item/66a76dafd9c307b7e9131b3f.png" style="zoom:50%"></p>
<h4 id="4-6-ASCII-计算机中的文字表示"><a href="#4-6-ASCII-计算机中的文字表示" class="headerlink" title="4.6 ASCII-计算机中的文字表示"></a>4.6 ASCII-计算机中的文字表示</h4><p>不同于书面用符号来表示文字信息，计算机中用数字表示文字。一种方法是，用1表示A，2表示B，3表示C，以此类推。美国科学家曾用5位来表示字母，因为$2^5$为32，这对26个字母来说够了，但这不能表示标点符号、数字和大小写字母。</p>
<p><strong>ASCII，美国信息交换标准代码</strong>，发明于1963年，ASCII码是7位代码，足够存储128个不同的值。扩展范围后，足够表示大小写字母、数字和标点符号等。</p>
<p>因为ASCII码值发明地较早，所以被广泛使用，这样，可以让不同公司制作的计算机，能够交换数据。这种交换信息的能力叫互用性。我们知道一个字节有8位，在值为128以后的数字，可以由各国自己根据情况使用。在美国，这些额外的数字主要用于编码附加符号，比如数字符号，图形元素和常用的重音字符，而在希腊，则用于表示希腊字母等。 </p>
<h4 id="4-7-Unicode-解决不同标准编码下的乱码问题"><a href="#4-7-Unicode-解决不同标准编码下的乱码问题" class="headerlink" title="4.7 Unicode-解决不同标准编码下的乱码问题"></a>4.7 Unicode-解决不同标准编码下的乱码问题</h4><p>不过虽然ASCII码已经能很好地应用于计算机了，但是对于亚洲一些国家（如中国和日本），他们有着上千的文字，ASCII码显然不够用。此外，各个国家设置了相应的字符编码表，但是互不兼容。<strong>字码不兼容的问题经常出现，以致于出现一个专门形容这种情况的名词，“mojibake”，意为“乱码”。</strong></p>
<p>所以，<strong>Unicode</strong>诞生了，统一了所有的编码标准，设计于1992年，解决了不同国家不同标准的问题，Unicode用一个统一的编码。最常见的Unicode是16位的，有超过一百万个位置，这对所有语言的字符都够用了，能很好地<strong>解决字符不兼容导致乱码的问题</strong>。</p>
<p>对于其他格式的信息如MP3或GIF，就像ASCII用二进制表示字母一样，我们用二进制编码声音/颜色，表示照片，电影和音乐。</p>
<p>最后，我们要知道，对于计算机，网页、短信、视频甚至操作系统，都是一长串01字符。</p>
<h3 id="5-算术逻辑单元"><a href="#5-算术逻辑单元" class="headerlink" title="5 算术逻辑单元"></a>5 算术逻辑单元</h3><h4 id="5-1-什么是ALU"><a href="#5-1-什么是ALU" class="headerlink" title="5.1 什么是ALU"></a>5.1 什么是ALU</h4><p>上一节课我们提到如何用二进制表示数据，如010表示2等。我们知道，<strong>表示和存储数据</strong>是计算机的重要功能。但真正的目标是计算处理有意义的数据，这些操作由计算机的“<strong>算术逻辑单元</strong>”处理，简称<strong>ALU</strong>。</p>
<p>ALU是计算机的数学大脑，理解了ALU的设计和功能后，你就理解了现代计算机的基石。ALU就是计算机中负责运算的组件，基本上其他组件都需要用到它。</p>
<p>最著名的ALU，就是<strong>英特尔的74181</strong>，1970年发布，是第一个封装在单个芯片内的完整ALU。</p>
<p><img src="https://pic.imgdb.cn/item/66a773cad9c307b7e917a162.png" alt="英特尔的74181芯片" style="zoom:40%"></p>
<p>接下来，我们将利用我们之前学过的逻辑门，设计一个功能与74181相同的组件，然后甚至用此设计CPU。 </p>
<h4 id="5-2-ALU单元之一：算术单元"><a href="#5-2-ALU单元之一：算术单元" class="headerlink" title="5.2 ALU单元之一：算术单元"></a>5.2 ALU单元之一：算术单元</h4><p>ALU有两个单元，1个算术单元，1个逻辑单元。</p>
<h5 id="5-2-1-什么是算术单元"><a href="#5-2-1-什么是算术单元" class="headerlink" title="5.2.1 什么是算术单元"></a>5.2.1 什么是算术单元</h5><p><strong>算术单元负责计算机里的所有数字操作</strong>，比如加减法，或者给某个数+1（这个叫增量运算），不过今天我们重点要理解的是加法运算。</p>
<p>设计时，我们不在晶体管层次出发，而是用更高层的抽象——逻辑门。我们需要用到<strong>AND，OR，NOT和XOR</strong>逻辑门。</p>
<h5 id="5-2-2-半加器"><a href="#5-2-2-半加器" class="headerlink" title="5.2.2 半加器"></a>5.2.2 半加器</h5><p>对于二进制加法，1+0=1，0+1=1，0+0=0，1+1=10。如下图：</p>
<p><img src="https://pic.imgdb.cn/item/66a77525d9c307b7e918a958.png" style="zoom:50%"></p>
<p>我们只看前三个和第四个的第一位，发现它和异或（XOR）操作一样。不过对于1+1，我们还需要一个进位，这里就用到了与操作（AND）。设计如下： </p>
<p><img src="https://pic.imgdb.cn/item/66a775c4d9c307b7e9191ae8.png" style="zoom:50%"></p>
<p>它只能处理一位计算，我们称为半加器。我们也可以将其封装起来，变成只有输入和输出的“黑盒操作”，如下图： </p>
<p><img src="https://pic.imgdb.cn/item/66a77602d9c307b7e9194c2c.png" style="zoom:50%"></p>
<h5 id="5-2-3-全加器"><a href="#5-2-3-全加器" class="headerlink" title="5.2.3 全加器"></a>5.2.3 全加器</h5><p>如果想要处理超过1+1的运算，我们需要“全加器”。半加器输出了进位，着意味着，我们处理时，还需要将进位考虑进去，才能设计全加器。</p>
<p>全加器要考虑三位数字的和，如下图所示。全加器有三输入（这里是ABC），两输出（进位和总和）。</p>
<p><img src="https://pic.imgdb.cn/item/66a7769fd9c307b7e91af540.png" style="zoom:50%"></p>
<p>我们可以用半加器进行A+B，再把C输入到第二个半加器上，然后用一个或门（OR）计算进位，最终我们得到<strong>全加器</strong>。设计如下： </p>
<p><img src="https://pic.imgdb.cn/item/66a776ced9c307b7e91b19f8.png" style="zoom:50%"></p>
<p>我们一样可以将全加器封装起来，这样只能看到输入（ABC）和输出（SUM总和，CARRY进位），方便我们进行更高层次的设计。 </p>
<p><img src="https://pic.imgdb.cn/item/66a7771cd9c307b7e91b52c1.png" alt="全加器" style="zoom:50%"></p>
<h5 id="5-2-4-8位加法器设计"><a href="#5-2-4-8位加法器设计" class="headerlink" title="5.2.4 8位加法器设计"></a>5.2.4 8位加法器设计</h5><p>有了全加器，我们可以进行多位加法器设计。这主要是利用半加器和全加器进行，刚开始因为没有高位的进位，我们使用半加器，接下来我们全部使用全加器，因为需要考虑进位。如下图：</p>
<p><img src="https://pic.imgdb.cn/item/66a777b1d9c307b7e91bcab4.png" alt="8位加法器(行波进位加法器)" style="zoom:40%"></p>
<p>因为是一个进位一个进位地往下输入的，所以叫“8位行波进位加法器”，当然，最后一位可能会发生进位，<strong>表示相加的两个数字和太大了，超过了8位，这叫做“溢出”</strong>。这会导致错误和不可预测的结果。</p>
<p>我们可以用更多的全加器，可以操作16位或32位数字，让溢出更难发生。不过代价是更多的逻辑门和更多的耗时。所以，现代电路用的加法器不同，叫“<strong><font color="blue">超前进位加法器</font></strong>”。</p>
<p>简单的ALU单元可以进行多种加减操作，如半加、全加、减法、增1等，但是没有乘除操作。这是因为，简单的ALU没有专门的电路来处理，而是<strong>把乘法用多次加法来实现</strong>。不过对于强大的手机和电脑，有专门的乘法处理电路。没有多困难，只是逻辑门更多，造价更昂贵而已。</p>
<h4 id="5-3-ALU单元之二：逻辑单元"><a href="#5-3-ALU单元之二：逻辑单元" class="headerlink" title="5.3 ALU单元之二：逻辑单元"></a>5.3 ALU单元之二：逻辑单元</h4><p>现在，我们讲ALU的另一部分，逻辑单元。逻辑单元执行逻辑操作，比如之前的AND，OR和NOT等操作。它也能做一些简单的判断，比如结果是不是0，是否为负数等。</p>
<p>例如下图就是检查ALU输出是不是0的电路，很简单，多个或操作，然后最后取反便可，因为只有输出位数全为0，结果才为0。</p>
<p><img src="https://pic.imgdb.cn/item/66a779b3d9c307b7e91d53b3.png" alt="判断输入是否为0" style="zoom:40%"></p>
<p>前面我们讲的英特尔公司发明的74181，不过只能处理4位输入，也就是说，我们做了一个比英特尔74181还好的ALU！！ </p>
<p><img src="https://pic.imgdb.cn/item/66a77a51d9c307b7e91dc287.png" alt="英特尔74181内部结构" style="zoom:60%"></p>
<h4 id="5-4-ALU"><a href="#5-4-ALU" class="headerlink" title="5.4 ALU"></a>5.4 ALU</h4><p>74181用了大概70个逻辑门，但不能执行乘法操作。但它向小型化迈出了一大步，可以让计算机更强大更便宜。ALU需要大量的逻辑，我们用一个符号来代替，它看起来像一个大“V”，如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/66a77b3dd9c307b7e91e661c.png" style="zoom:30%"></p>
<p>ALU有两个8位的输入，然后用一个操作代码来控制其是加法还是减法操作，操作代码告诉ALU进行什么操作。</p>
<p>ALU的输出是8位的，ALU还输出一堆标志（Flag）。一些操作介绍如下：</p>
<ul>
<li><strong>ZERO</strong>：若ALU输出是0，那么ZERO标志就变成1。</li>
<li><strong>NEGATIVE</strong>：我们可以用ALU做减法，然后用NEGATIVE判断其是不是小于0，从而进行比较大小。</li>
<li><strong>OVERFLOW：</strong>ALU还有溢出单元，判断有没有进位。</li>
</ul>
<p>ALU有很多Flag，这三个是最常用的。</p>
<h3 id="6-寄存器与内存"><a href="#6-寄存器与内存" class="headerlink" title="6 寄存器与内存"></a>6 寄存器与内存</h3><p>上节课，我们用逻辑门做了一个简单的ALU，它能执行算术运算（Arithmetic）和逻辑运算（Logic），ALU里的A和L因此得名。当然，算出来后将结果扔掉的话那就没什么意义了，得找个办法存起来，这就需要用到计算机的内存了。</p>
<h4 id="6-1-计算机中的存储器"><a href="#6-1-计算机中的存储器" class="headerlink" title="6.1 计算机中的存储器"></a>6.1 计算机中的存储器</h4><p>当我们正在使用电脑时，比如打游戏、看视频，如果突然断开电源，进度将会中断且不难复原。我们会损失数据的原因是，电脑使用的是“随机存取存储器”，简称“RAM”。它只能在有电的情况下存储东西。</p>
<p>另一种存储叫持久存储，关掉电脑数据也不好丢失。</p>
<p>本节课，我们将从简单开始，做出存储1的器件，之后再扩大，做出我们的内存模块。下次再和ALU结合，做出CPU。</p>
<h4 id="6-2-存储器的原理与制作"><a href="#6-2-存储器的原理与制作" class="headerlink" title="6.2 存储器的原理与制作"></a>6.2 存储器的原理与制作</h4><h5 id="6-2-1-存0电路与存1电路"><a href="#6-2-1-存0电路与存1电路" class="headerlink" title="6.2.1 存0电路与存1电路"></a>6.2.1 存0电路与存1电路</h5><p><strong>(1) 存1电路</strong></p>
<p>至今，我们所说的电路都是单向的，总是向前流动，但是我们也可以把输出连回输入。如下图所示的连法，当输出是1后，无论输入是0还是1，因为将输出连回了输入，最终的输出都是1。那么，<strong>这个电路元件就可以存储1</strong>。<em><u>然而问题是，无论怎么试，都没法将1变回0</u></em>。</p>
<p><img src="https://pic.imgdb.cn/item/66a77dfcd9c307b7e9205c36.png" alt="存1电路"></p>
<p><strong>(2) 存0电路</strong></p>
<p>那么，我们来看看将这个电路里的OR门换成AND门会怎么样，如图。当输出是0后，无论再对A输入0还是1，输出都是0，就是说，<strong>这个电路了可以存储0</strong>。这里就不绘制动态分析过程了，可参照存0电路。</p>
<p><img src="https://pic.imgdb.cn/item/66a77e93d9c307b7e920c18b.png" alt="存0电路" style="zoom:30%"></p>
<h5 id="6-2-2-锁存器与门所"><a href="#6-2-2-锁存器与门所" class="headerlink" title="6.2.2 锁存器与门所"></a>6.2.2 锁存器与门所</h5><p><strong>(1) 锁存器</strong></p>
<p>现在，我们用了存1存储器和存0存储器了，我们将其都利用起来，如下图，这个叫做“<strong>AND-OR锁存器</strong>”。它有两个输入，“设置”输入，把输出变成1，“复位”输入把输出变成“0”。如果“设置”和“复位”都是0，电路会输出最后放入的内容。这就是说它存住了一位的信息，这叫“锁存”，因为他锁住了一个值。</p>
<p><img src="https://pic.imgdb.cn/item/66a77f3fd9c307b7e9212f7e.png" alt="锁存器示意图" style="zoom:40%"></p>
<ul>
<li>若<code>SET=1,RESET=0</code>，则输出为1；</li>
<li>若<code>SET=0,RESET=1</code>，则输出为0；</li>
<li>若<code>SET=0,RESET=0</code>，则输出不变，也即会保存上一个状态的输出，也即它锁住了1位的信息（<strong>存储</strong>）；</li>
<li>若<code>SET=1,RESET=1</code>，则输出为0，个人认为这种操作没有什么太大的意义；</li>
</ul>
<p><strong>放入数据的操作叫“写入”，拿出数据的操作叫读取。</strong> </p>
<p><strong>(2) 门锁</strong></p>
<p>麻烦的是，用两条线“设置”和 “复位”来输入，有点难理解。为了更容易用，我们希望只有一条输入线，进行输入数据。然后设置另一条线，叫允许写入线，用来启用内存，启用时允许写入，没启用时就锁定。外加一些逻辑门，就可以做出这个电路。这个叫<strong>门锁，因为门可以打开和关上。</strong></p>
<p><img src="https://pic.imgdb.cn/item/66a7818fd9c307b7e922d709.png" alt="门锁示意图" style="zoom:50%"></p>
<p>其中，DATA INPUT表示输入要保存的数据；WRITE ENABLE表示允许写入线，此线输入1时为启用(允许写入数据)，此线输入为0时为锁定(存储数据，此时不论DATA INPUT如何变输出都不变)。</p>
<p>但是，我们不想直接面对这个电路，我们想用一个“黑盒”将其框住，这就成为了一个组件。这个门锁只有当“允许写入线”为1时才可以写入和输出数据。 </p>
<p><img src="https://pic.imgdb.cn/item/66a782b2d9c307b7e923c022.png" style="zoom:40%"></p>
<h5 id="6-2-3-寄存器"><a href="#6-2-3-寄存器" class="headerlink" title="6.2.3 寄存器"></a>6.2.3 寄存器</h5><p>虽然一个门锁只能存储一位数字，但是我们并排放8个锁存器，就可以存8位信息。</p>
<p>一组这样的锁存器叫“<strong><font color="green">寄存器</font></strong>”，寄存器能存储一个数字，这个数字有多少位，叫位宽。</p>
<p>早期计算机用8位寄存器，后来到16位、32位和如今的64位。</p>
<p>写入寄存器时，我们需要先将所有的“允许写入线”设为1，这里我们可以引一条总线统一控制。然后我们将数据输入，完成输入后再将所有的“允许写入线”设为0。</p>
<p><img src="https://pic.imgdb.cn/item/66a78464d9c307b7e9251a30.png" alt="8位寄存器" style="zoom:40%"></p>
<h5 id="6-2-4-矩阵网络优化门锁放置"><a href="#6-2-4-矩阵网络优化门锁放置" class="headerlink" title="6.2.4 矩阵网络优化门锁放置"></a>6.2.4 矩阵网络优化门锁放置</h5><p>如果只有很少的位(bits)，把锁存器并排放置，也勉强够用了。64 位寄存器要 64 根数据线，64 根连到输出端，幸运的是，我们只要1根线(“总线”)启用所有锁存器，但加起来也有 129 条线了。如果存 256 位要 513 条线！非常耗材。</p>
<p>解决方法就是<strong>矩阵</strong>，在计算机中，<strong>寄存器并不并排放，而是成矩阵网络</strong>。存256位的寄存器，就将门锁摆成16*16形式，要用某个寄存器，就打开想应的行线和列线。</p>
<p><img src="https://pic.imgdb.cn/item/66a785c9d9c307b7e92629c4.png" alt="门锁矩阵网络" style="zoom:40%"></p>
<p>要启用某个锁存器，就打开相应的行线和列线，放大看看怎么做的。</p>
<p>我们只想打开交叉处锁存器的”允许写入线”，所有其他锁存器，保持关闭。我们可以用 AND 门！只有行线和列线均为1，AND门才输出 1。所以可以用选择单个锁存器，这种行/列排列法，用一根“允许写入线(总线)”连所有锁存器。</p>
<p><img src="https://pic.imgdb.cn/item/66a787cfd9c307b7e9279e4b.png" alt="放大示意图" style="zoom:50%"></p>
<p>为了让锁存器变成“允许写入”，行线，列线和“允许写入线”都必须是 1，每次只有行列号对应的那1个锁存器会这样。同时，有了这种电路连接结构，使得我们可以只用一根”数据线”(类似于允许写入线的总线)连所有锁存器来传数据，因为只有一个锁存器会启用，只有那个会存数据。其他锁存器会忽略数据线上的值，因为没有“允许写入”。</p>
<p>我们可以用类似的技巧，做<strong>“允许读取线(READ ENABLE)”</strong>来读数据。</p>
<p>所以对于 256 位的存储只要 35 条线，具体计算如下：</p>
<script type="math/tex; mode=display">
1条数据线 + 1条允许写入线 + 1条允许读取线 + 16条行线 + 16条列线 = 35条线</script><p>不过，我们怎么将计算机的二进制数据传给这个“矩阵”呢？因此，我们需要用到<strong>多路复用器</strong>，它能够连通所给输入对应的线，比如若输入“1010”，那么多路复用器就会将第10路连通，达到选线路的目标。 </p>
<p><img src="https://pic.imgdb.cn/item/66a78ac5d9c307b7e929d0e7.png" alt="多路复用器" style="zoom:60%"></p>
<p>那么，更高的一层抽象来了，256位内存，如下。其分别有上文提到的8位地址线、数据线、允许写入线和允许读取线： </p>
<p><img src="https://pic.imgdb.cn/item/66a78b91d9c307b7e92a7601.png" alt="256位寄存器的抽象" style="zoom:50%"></p>
<p>这样，我们就做成了一个内存了。</p>
<h4 id="6-3-如何利用多个内存完成数据存取"><a href="#6-3-如何利用多个内存完成数据存取" class="headerlink" title="6.3 如何利用多个内存完成数据存取"></a>6.3 如何利用多个内存完成数据存取</h4><p>利用这个256位的内存，我们可以存许多数据。具体的存法如下：</p>
<p><img src="https://pic.imgdb.cn/item/66a78cb4d9c307b7e92b5b80.png" style="zoom:60%"></p>
<p>我们将8个256位的内存并排在一起，用同样地址线将其连接。那么，一个内存可以存一位（<strong>单独</strong>），8个并在一起就可以<em><u>同时存8位（1Byte）</u></em>。<strong>为了存8位的数据，我们给8个内存同样的地址，也就是一个8位数据，分给8个内存分别存储</strong>。因为是256位的内存，所以可以存256个八位，也就是<strong>256 Byte</strong>的数据。 </p>
<p>我们将其抽象，也就是说，这8给内存，可以有256有地址，每个地址可以读写一个8位数据。 </p>
<p><img src="https://pic.imgdb.cn/item/66a78d5ad9c307b7e92be137.png" style="zoom:60%"></p>
<p>内存的一个重要特征是可以随时访问任何位置，因此叫“<strong>随机存取存储器</strong>”（RAM），RAM就像人类的短期记忆，记录计算机当时正在干嘛。 </p>
<p><img src="https://pic.imgdb.cn/item/66a7901dd9c307b7e92e37aa.png" style="zoom:70%"></p>
<p>上面真实的内存条中，有8颗芯片，每个芯片有32个内存方块，每个内存方块4个矩阵，所以1个方格有8192×4=32768位，总之，总位数约为：</p>
<script type="math/tex; mode=display">
32768 \times 32 \times 8 = 8388608 ≈ 800 \text{万位} ≈ 1 \text{兆字节}</script><p>所以，这节课，我们做了一个SRAM（<strong>静态随机存取存储器</strong>），还有其他比如DRAM、闪存等等，他们在功能上与SRAM相似，但用不同的电路存单个位，比如用不同的逻辑门、电容器、电荷捕获或忆阻器等等。但根本上，这些技术都是矩阵层次嵌套，来存储大量信息。</p>
<p>就像计算机中的很多事情，底层其实都很简单。让人难以理解的是一层层精妙的抽象，像一个越来越小的俄罗斯套娃。</p>
<h3 id="7-中央处理器CPU"><a href="#7-中央处理器CPU" class="headerlink" title="7 中央处理器CPU"></a>7 中央处理器CPU</h3><h4 id="7-1-CPU与指令"><a href="#7-1-CPU与指令" class="headerlink" title="7.1 CPU与指令"></a>7.1 CPU与指令</h4><p>前面课程已经提到，我们已经做了一个算术逻辑单元（ALU），输入二进制，它会执行计算。我们还做了两种内存：寄存器，很小的内存，能存一个值；RAM，能在不同地址存大量数字。现在，我们是时候把他们放在一起，组建计算机的“心脏”了，<strong>这个“心脏”叫“中央处理单元”，简称CPU。</strong></p>
<p>CPU负责执行程序，这些程序可能是浏览器、社交软件和音乐等等。这些程序是由一个个操作组成的，这种“操作”叫“指令”，因为它“指示”计算机要做什么。如果是计算指令如加或者减，CPU会让ALU进行数学运算。也可能是内存指令，CPU会和内存通信，然后读/写值。</p>
<p>当我们用一条线连接两个组件时，这条线只是所有必须线路的一个抽象，这种高层次视角叫”微体系架构“。意思就是，我们从微观部件考虑整体同类型部件，以更高抽象层次去看代问题。</p>
<h4 id="7-2-CPU指令体系"><a href="#7-2-CPU指令体系" class="headerlink" title="7.2 CPU指令体系"></a>7.2 CPU指令体系</h4><p>我们已经知道数据是以二进制值存在内存里，程序也可以存在内存里。我们可以给CPU 支持的所有指令，分配一个 ID，下图为计算机指令表。下表中，我们看到，前四位存储指令的”操作代码“，如0010、0001等，后面四位代表数据来源于哪里（地址或者寄存器）</p>
<p><img src="https://pic.imgdb.cn/item/66a793ecd9c307b7e931919c.png" alt="CPU指令表" style="zoom:40%"></p>
<p>我们还需要两个寄存器来完成CPU指令<strong>，一个寄存器追踪程序运行到哪了</strong>，我们叫它”指令地址寄存器“，顾名思义，存当前指令的内存地址。<strong>另一个寄存器存当前指令</strong>，叫”指令寄存器“。指令体系如下： </p>
<p><img src="https://pic.imgdb.cn/item/66a796a2d9c307b7e933d695.png" alt="指令系统示意图" style="zoom:60%"></p>
<h4 id="7-3-指令的运行流程"><a href="#7-3-指令的运行流程" class="headerlink" title="7.3 指令的运行流程"></a>7.3 指令的运行流程</h4><p>一条指令的运行，有三个阶段，分别是<strong>取指令阶段、解码和执行</strong>。这里，我们会在RAM里放一个程序，过一遍流程。</p>
<p>CPU的第一个阶段叫”<strong>取指令阶段</strong>“。指令地址寄存器连接到RAM，RAM得到指令地址寄存器的内容，将对应地址的数据传到指令寄存器中，下图中显示的是”0010 1110“。</p>
<p>然后是<strong>解码</strong>，根据前文的指令表，知道0010是LOAD_A指令。后四位是RAM的地址（如表），1110是14，那么我们就取得RAM中地址是14的值3。这是一个LOAD_A指令，会将这个值放入A寄存器中，而其他寄存器不受影响。</p>
<p>最后是<strong>执行</strong>，通过检验电路和输入运行线开关，就将3写入了寄存器A中。执行完后，指令地址寄存器地址+1，进行下一个指令。</p>
<p>当然，每一个指令都会有对应的逻辑电路来判断其是否要进行。这些控制单元可能非常复杂，我们将其抽象一层，以一个整体部件（控制单元Control Unit）代替。</p>
<p><img src="https://pic.imgdb.cn/item/66a797ead9c307b7e934f7e5.png" style="zoom:70%"></p>
<p>这个控制单元就行交响乐的指挥使，控制CPU的所有组件。”取指令-解码-执行“完成后，我们可以再来一次其他指令，从”取指令开始“。上面介绍的指令只涉及到寄存器的存取，其他指令如ADD，会用到<strong>ALU部件</strong>。利用ALU将值计算出来后，再传回对应的寄存器中。<strong>也就是说，寄存器加ALU，就可以做成CPU。</strong> </p>
<h4 id="7-4-CPU的节奏把控者——时钟"><a href="#7-4-CPU的节奏把控者——时钟" class="headerlink" title="7.4 CPU的节奏把控者——时钟"></a>7.4 CPU的节奏把控者——时钟</h4><p>我们刚才走的是一个人工的流程，但是计算机中没有”人工“，所以<strong>计算机中靠的是时钟来负责管理CPU的节奏</strong>。时钟以精确的时间间隔，触发电信号。控制单元会用这个信号，推进CPU的内部操作，确保一切按节奏进行。</p>
<p>时间间隔不能太短，因为电信号的传输也需要一定的时间。**<font color="red">CPU进行“取指令-解码-执行”的速度叫“时钟速度”，单位是Hz，1Hz表示一秒一个周期</font>。</p>
<p><img src="https://pic.imgdb.cn/item/66a79d37d9c307b7e939973a.png" style="zoom:60%"></p>
<p>第一个单芯片CPU是“英特尔4004”，1971年发布的4位CPU，它的微架构很像我们之前所说的CPU。虽然是第一个小型CPU，但他的时钟速度达到740千赫兹——每秒740万个周期。</p>
<p><img src="https://pic.imgdb.cn/item/66a79b79d9c307b7e937f9e7.png" style="zoom:70%"></p>
<ul>
<li><p><strong>超频</strong><br>你可能听过有人会把计算机超频，意思是<strong>修改时钟速度</strong>，加快CPU的速度，就像罗马帆船要撞另一艘船时，鼓手会加快敲鼓速度。芯片制造商经常给CPU留一点余地，可以接受一点超频！但超频大多会让CPU过热或产生乱码，因为信号跟不上时钟。</p>
</li>
<li><p><strong>降频</strong><br>你可能很少听说降频，但降频其实很有用，有时没必要让处理器全速运行(例如，可能用户走开了，或者在跑一个性能要求较低的程序)。把 CPU 的速度降下来，可以省很多电，省电对用电池的设备很重要，比如笔记本和手机</p>
</li>
<li><strong>动态调频</strong><br>很多现代处理器可以按需求，加快或者减慢时钟速度，这叫“<strong>动态调整频率</strong>”，加上时钟后，CPU才完整，这样我们又提升了一层抽象。<strong>CPU和RAM独立，两者用地址线、数据线和允许读写线进行通信。</strong> </li>
</ul>
<h4 id="7-5-小小结"><a href="#7-5-小小结" class="headerlink" title="7.5 小小结"></a>7.5 小小结</h4><p>加上时钟后，CPU才是完整的，现在可以放到盒子里，抽象成一个独立组件。</p>
<p><img src="https://pic.imgdb.cn/item/66a79d8fd9c307b7e939ea7d.png" style="zoom:60%"></p>
<h3 id="8-指令和程序"><a href="#8-指令和程序" class="headerlink" title="8 指令和程序"></a>8 指令和程序</h3><h4 id="8-1-更加丰富的指令系统"><a href="#8-1-更加丰富的指令系统" class="headerlink" title="8.1 更加丰富的指令系统"></a>8.1 更加丰富的指令系统</h4><p>上节课中，我们把ALU，控制单元，RAM和时钟结合在一起，做了一个基本但可用的“中央处理单元”，简称CPU，它是计算机的核心。这次，我们给CPU一些指令来运行。</p>
<p>CPU之所以强大，是因为它是可编程的，如果写入不同指令，就会执行不同任务。所以，CPU是一块硬件，可以被软件控制。在上节课的指令系统中，我们只有4条语句，这节课我们会增加几条指令，如下</p>
<ol>
<li><strong>SUB</strong>：与ADD一样，操作两个寄存器相减，放在第二个寄存器上。</li>
<li><strong>JUMP</strong>：让程序跳转到新位置，如果想改变一些指令或者跳过一下指令，这个很有用。JUMP的底层实现方式是，把需要的指令后四位代表的内存地址的值覆盖掉“指令地址寄存器”里的值。</li>
<li><strong>JUMP_NEG</strong>：它只在ALU的“负数标志”为真时（即此时计算结果为负数），进行JUMP。</li>
<li><strong>HALT</strong>：计算机和程序停下来。</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/66a82c68d9c307b7e9979f4f.png" alt="更加丰富的指令集" style="zoom:70%"></p>
<p>值得一提的是，指令和数据都是存在同一个内存里面的，他们在根本上毫无区别，都是二进制数。</p>
<p><strong>利用更多的指令，我们可以使CPU的程序更加丰富。</strong></p>
<h4 id="8-2-无限循环与条件指令"><a href="#8-2-无限循环与条件指令" class="headerlink" title="8.2 无限循环与条件指令"></a>8.2 无限循环与条件指令</h4><p>当指令顺序出现问题时，程序可能进入<strong>无限循环</strong>，这个程序会永远跑下去。所以，我们需要更多<strong>其它类型的JUMP</strong>以满足我们的需要，这样只在特定条件下才会发生，程序不会出现无限循环。前面提到的<code>JUMP_NEG</code>就是，此外还有 <code>JUMP_IF_EQUAL</code>（如果相等）、<code>JUMP_IF_GREATER</code>（如果更大）等等。这些指令，同样使我们的CPU程序更加丰富。</p>
<p>软件还可以让我们做到硬件做不到的事，ALU没有除法功能，是程序给了这个功能。别的程序也可以用我们的除法程序，来做其他事情。</p>
<h4 id="8-3-指令长度"><a href="#8-3-指令长度" class="headerlink" title="8.3 指令长度"></a>8.3 指令长度</h4><p>我们这里假设的CPU很基础，所有指令都是8位，操作码只占了前四位，即便用尽4位，也只能代表16个指令。同时，因为4位最大为16，说明我们最多可以操纵16个地址，这非常少。</p>
<p>因此现代计算机用两种办法来解释此，① 最直接的方法是用更多位来代表指令，比如32位或者64位，这叫做<strong>指令长度</strong>。② 第二个策略是“可变指令长度”，举例，比如某个CPU用8位长度的操作码，看到HALT指令，HALT不需要额外的数据，那么会立马执行。如何看到JUMP，它得知道位置值，这个值在JUMP后面，这叫做“立即值”。这样设计，指令可以是任意长度。</p>
<h4 id="8-4-现代计算机的指令系统"><a href="#8-4-现代计算机的指令系统" class="headerlink" title="8.4 现代计算机的指令系统"></a>8.4 现代计算机的指令系统</h4><p>上面都是假设的例子，现在讲一个真实的例子。1971年，英特尔发明的4004处理器，这是第一次把CPU做成芯片，它支持46个指令，包括JUMP、ADD等。CPU发展到现在，功能越来越强大。比如，英特尔的酷睿i7，有上千个指令和指令变种，长度从1到15字节。</p>
<p><img src="https://pic.imgdb.cn/item/66a830c2d9c307b7e99a8d82.png" alt="第一个CPU4004的指令集 "></p>
<h3 id="9-高级CPU设计"><a href="#9-高级CPU设计" class="headerlink" title="9 高级CPU设计"></a>9 高级CPU设计</h3><h4 id="9-1-早期CPU提速方式"><a href="#9-1-早期CPU提速方式" class="headerlink" title="9.1 早期CPU提速方式"></a>9.1 早期CPU提速方式</h4><p>随着本系列的进展，我们知道计算机进步巨大，从1秒一次运算，到现在有千hz甚至兆hz的CPU。</p>
<h5 id="9-1-1-减少晶体管切换时间"><a href="#9-1-1-减少晶体管切换时间" class="headerlink" title="9.1.1 减少晶体管切换时间"></a>9.1.1 减少晶体管切换时间</h5><p>早期计算机的提速方式是，减少晶体管的切换时间。晶体管组成了逻辑门，ALU以及前几集的其他组件，但这种提速方式终究会遇到困难。所以厂商和科学家们发明各种新的技术来提高性能。</p>
<h5 id="9-1-2-利用复杂电路设计除法"><a href="#9-1-2-利用复杂电路设计除法" class="headerlink" title="9.1.2 利用复杂电路设计除法"></a>9.1.2 利用复杂电路设计除法</h5><p>上节课我们做了一个CPU除法法器，不断减去同一个数，直到小于等于0才停下。但这种方法需要多个时钟，很低效。所以<strong>现代CPU直接在硬件层面上设计了除法，可以直接给ALU除法指令。虽然这让CPU更大更复杂，但也让运行速度更快。</strong></p>
<h4 id="9-2-缓存——解决CPU与RAM传输问题"><a href="#9-2-缓存——解决CPU与RAM传输问题" class="headerlink" title="9.2 缓存——解决CPU与RAM传输问题"></a>9.2 缓存——解决CPU与RAM传输问题</h4><p>现代计算机几千兆的时钟速度，带来了另一个问题，<u>如何传递数据给CPU</u>？这时，RAM成了一大阻力，RAM是CPU之外的独立组件，意味着数据要用线来传递，叫<strong>总线(BUS)</strong>。虽然电信号可以以光速快速快速传输，但是很小的延迟也会造成问题，RAM还需要时间找地址、取数据、配置和输出数据，这样会占用太多时间。</p>
<p>解决延迟的方法之一是，给CPU加一点RAM，叫<strong><font color="red">缓存(CACHE)</font></strong>。</p>
<p><img src="https://pic.imgdb.cn/item/66a835d8d9c307b7e99dfb4a.png" alt="CPU与RAM之间添加“缓存”" style="zoom:60%"></p>
<p>因为处理器空间不大，所以缓存一般只有几KB或MB。缓存提高了运行速度，CPU从RAM拿数据时，RAM不用传一个，可以传一批。这很实用，<strong>因为数据常常是一个一个按顺序处理的，将要处理的数据提前传入缓存，可以大大提升CPU运行速度</strong>。<em><u>因为缓存离CPU近</u></em>，传输时间大大降低，这比直接反复去RAM拿数据快得多。</p>
<blockquote>
<p>注意：这里的近就是指物理上的近，RAM与CPU通信的总线BUS物理长度可能1cm，但是CACHE与CPU通信的物理距离可能只有0.01cm。</p>
</blockquote>
<p>如果想要的数据已经在缓存中，叫“<strong>缓存命中</strong>”，否则叫缓存未命中。缓存可以当临时空间，存一些中间值，适合长\复杂的运算。</p>
<p>计算完后的值要想存储，不会直接存入RAM，而是存入缓存中。因此，缓存里的数据要对RAM里的数据进行更新，缓存里每块空间，有一个特殊标记，叫“<strong>脏位</strong>”。</p>
<p>同步缓存与RAM的数据一般是当缓存满了，而又需要存更多的数据时发生。这时会检查缓存中的“脏位”，如果是脏的，就会把数据写回RAM中。</p>
<h4 id="9-3-指令流水线"><a href="#9-3-指令流水线" class="headerlink" title="9.3 指令流水线"></a>9.3 指令流水线</h4><p>CPU在处理指令时，不一定要完全按照串行流程，可以按照并行方式进行。意思是，当此条指令正在“执行”时，可以处理下一个指令的“解码”，下下条指令的“读取”，这样可以同时利用上CPU里的所有部分。这样进行执行，吞吐量*3。如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/66a8393cd9c307b7e9a05e10.png" alt="指令流水线"></p>
<p>当然，这样也可能出现问题，首先是因为<strong>上一条指令可能会改变下一条指令的运行方式</strong>，所以CPU在运行前需要解析这些指令，必要时还需要停下来等待上一条指令完成后在继续。</p>
<p>高端CPU，比如笔记本和手机那种，会进一步，动态排序有依赖关系的指令，最小化流水线停工时间，这叫“乱序执行”。这种电路非常复杂，但因为高效，几乎所有现代处理器都有流水线。</p>
<p>第二个问题是<strong>条件跳转</strong>，比如JUMP Negative这些，这些指令会改变程序的执行流。简单的流水线处理器，看到JUMP指令会停一会，等待条件值确定下来，一旦JUMP的结果出了，处理器就继续流水线。因为等待会消耗很多时间，<strong>高级的流水线处理器会提前猜测哪个条件可能性大，然后提前把指令放在流水线上，这叫“推测执行”</strong>。如果猜测正确，则立即执行，错误则会清空刚才加载的指令，重新加载。为了减少清空次数，CPU开发了高级方法来猜测哪条分支更有可能，叫“分支预测”。现代计算机的猜测正确率高达90%。</p>
<ul>
<li><strong>超标量处理器</strong></li>
</ul>
<p>理想情况下，流水线一个时钟周期完成1条指令，然后“超标量处理器”出现了，一个时钟周期可以完成多条指令。即便有流水线涉及，在指令执行阶段，处理器里 有些区域还是可能会空闲，例如：有一条指令是“从内存中取出某地址存放的数据”，执行这条指令期间ALU会闲置，所以一次性处理多条指令(取指令+解码)会更好（此句子也可翻译为：那么，为什么不一次获取和解码多个指令，并尽可能地执行指令呢）。也就是说，如果多条指令要 CPU 的不同部分，就多条同时执行。我们可以再进一步，加多几个相同的电路执行出现频次很高的指令——<strong>举例，很多 CPU 有4个、8个甚至更多完全相同的ALU结构，可以同时执行多个数学运算</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/66a83ecbd9c307b7e9a45e3c.png" alt="超标量流水线处理器" style="zoom:40%"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/youzhangjing_/article/details/132278054">参考连接1：一文解析超标量处理器 - CSDN</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhizhengguan/article/details/121271156">参考连接2：计算机组成原理：超标量，让CPU的吞吐率超过1 - CSDN</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/a201577F0546/article/details/84726912">参考连接3：一个时钟周期执行一条指令的过程理解（单周期CPU） - CSDN</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_69884785/article/details/136208031">参考连接4：计算机组成原理（6）——-指令执行过程 - CSDN</a></p>
<h4 id="9-4-多核处理器"><a href="#9-4-多核处理器" class="headerlink" title="9.4 多核处理器"></a>9.4 多核处理器</h4><p>以上的指令流水线工作都是对于一个流水线来说的。另一个方法是<strong>同时运行多个指令流，叫多核处理器</strong>。多核意思是，CPU芯片有多个独立处理单元，就像有多个CPU。多个CPU之间可以合作运算。</p>
<p><img src="https://pic.imgdb.cn/item/66a8417ad9c307b7e9a61ce8.png" alt="多核处理器" style="zoom:70%"></p>
<p>你应该听过双核或四核处理器，意思是一个 CPU 芯片里，有多个独立处理单元，很像是有多个独立’CPU，但因为它们整合紧密，可以共享一些资源，比如缓存，使得多核可以合作运算</p>
<p><img src="https://pic.imgdb.cn/item/66a841d4d9c307b7e9a6582f.png" style="zoom:30%"></p>
<p>当多核不够时，可以用多个CPU，比如视频网站的服务器。</p>
<p>2个和4个核的计算机是最常用的（现在可能有8核了），但人们还需要更多的，所以有了<strong>超级计算机。目前世界上最快的计算机位于中国超算中心，神威·太湖之光</strong>，有40960个CPU，每个CPU有256个核心，总共超过1千万个核心，可以进行超级运算或者宇宙大模拟。</p>
<h3 id="10-早期的编程方式"><a href="#10-早期的编程方式" class="headerlink" title="10 早期的编程方式"></a>10 早期的编程方式</h3><p>前几集我们把重点放在计算机的原理，怎么从内存读写数据，执行操作。还讲了指令的执行。但是，我们还没将程序如何“进入”计算机。</p>
<h4 id="10-1-最早的编程——可编程纺织机"><a href="#10-1-最早的编程——可编程纺织机" class="headerlink" title="10.1 最早的编程——可编程纺织机"></a>10.1 最早的编程——可编程纺织机</h4><p>给计算机编程这个需求，早在计算机出现之前就有了，最著名的来自于纺织行业。如果想要织一件红色衣服，我们只需要将红线放入纺织机中，但是如果想要图案怎么办？开始时，工人要经常改变纺织方向以作图案，所以早期有团案的衣服较为贵。后来发明了可编程纺织机，用孔板进行控制。这个纺织机叫“雅卡尔织布机”，被认为是最早的编程。</p>
<h4 id="10-2-穿孔卡片编程"><a href="#10-2-穿孔卡片编程" class="headerlink" title="10.2 穿孔卡片编程"></a>10.2 穿孔卡片编程</h4><p>近1个世纪后，穿孔纸用于1890年美国人口普查。每张纸都可以存个人信息，用孔来表示信息，比如种族、婚姻等。穿孔纸存的是数据，不是程序。</p>
<h4 id="10-3-插线编程"><a href="#10-3-插线编程" class="headerlink" title="10.3 插线编程"></a>10.3 插线编程</h4><p>为了用计算机正确执行不同计算，程序员需要某种控制面板。面板有很多小插孔，程序员可以插电线，控制让机器的不同部分，互相穿数据和信号，因此也叫“插线板”。不幸的是，这意味着，运行不同程序要重新接线。所以到1920年，控制面板变成了可拔插，让编程更方便，可以给计算机插入不同程序。但是插线板编程很复杂，不过它在大多机电计算机很常见，世界上第一台电子计算机也是用插线板编程。</p>
<h4 id="10-4-冯诺依曼结构"><a href="#10-4-冯诺依曼结构" class="headerlink" title="10.4 冯诺依曼结构"></a>10.4 冯诺依曼结构</h4><p>插线编程非常复杂，也非常耗时，这对计算机设计程序很麻烦。后来，内存的出现与发展，出现了“<u>存储程序计算机</u>”，能在内存里存储程序。如果内存足够，不仅可以存程序，还可以存数据。<strong>程序和数据都存在一个地方，叫“冯诺伊曼结构”</strong>。冯诺依曼计算机的标志是：</p>
<script type="math/tex; mode=display">
一个处理器+数据寄存器+指令寄存器+指令地址寄存器+内存(负责存数据和指令)</script><p>第一台冯诺依曼结构计算机叫“宝宝”，由曼彻斯特大学于1948年建成。直到1980年代，人们还是主要用穿孔卡片进行程序写入，计算机可以吸入一张卡片，把卡片内容写进内存。卡片输入非常麻烦，要是不小心弄乱了，要花几小时甚至几天来整理。数据由计算机输出，依然是需要用到卡片，方式是打孔。</p>
<h4 id="10-5-面板编程"><a href="#10-5-面板编程" class="headerlink" title="10.5 面板编程"></a>10.5 面板编程</h4><p>到了1980年代，还有一种常见的编程方式，面板编程。面板编程，用一大堆开关进行控制。通过开关控制进行二进制代码的编写，然后就可以运行程序。</p>
<p>不管是插线、穿孔纸片还是面板，早期编程都是专家活，需要非常了解底层硬件，比如操作码和寄存器等等。所以当时编程很难。下节课，讲到编程语言，是一种更简单的编程方法。 </p>
<h3 id="11-编程语言发展历史"><a href="#11-编程语言发展历史" class="headerlink" title="11 编程语言发展历史"></a>11 编程语言发展历史</h3><p>之前，我们把重点放在硬件——组成计算机的物理组件上，比如电、电路、寄存器、RAM、ALU和CPU，但是在硬件层面上编程非常麻烦。所以程序员想要一种更加通用的方法编程，一种更软的媒介。所以，这节课，我们将要讲<strong>软件和高级语言</strong>。</p>
<h4 id="11-1-机器语言、汇编语言和编译器"><a href="#11-1-机器语言、汇编语言和编译器" class="headerlink" title="11.1 机器语言、汇编语言和编译器"></a>11.1 机器语言、汇编语言和编译器</h4><p>第8节课，我们一步步讲了一个简单程序。前面我们讲到用二进制代码表示不同的操作和地址，其实这只是一种数据的表现方式。就像英语和摩斯密码，虽然二者的符号和表达不同，但是可以传达相同的信息，计算机语言也类似。</p>
<h5 id="11-1-1-机器语言"><a href="#11-1-1-机器语言" class="headerlink" title="11.1.1 机器语言"></a>11.1.1 机器语言</h5><p>计算机能处理二进制，二进制是处理器的“母语”。这叫“<strong>机器语言”或者“机器码”</strong>。在计算机早期阶段，必须用机器码写程序。具体地来讲，会先在纸上用英语写一个高层次版本，<strong>这种对程序的高层次描述，叫伪代码</strong>，然后，用“<strong>操作码表</strong>”把伪代码转成二进制机器码，翻译完成后，程序就可以喂入计算机并运行。</p>
<h5 id="11-1-2-汇编语言"><a href="#11-1-2-汇编语言" class="headerlink" title="11.1.2 汇编语言"></a>11.1.2 汇编语言</h5><p>但这种方法太麻烦了，所以在1940-1950年代，程序员开发一种新语言，更可读更高层次。它为每个操作码分配一个简单名字，叫“<strong>助记符</strong>”，助记符后面紧跟数据，形成完整指令。程序员可以用“LOAD_A 14”写代码，而不是用01二进制写代码了。</p>
<p><img src="https://pic.imgdb.cn/item/66a8486ad9c307b7e9aaacf1.png" alt="部分汇编语言表" style="zoom:60%"></p>
<h5 id="11-1-3-汇编器"><a href="#11-1-3-汇编器" class="headerlink" title="11.1.3 汇编器"></a>11.1.3 汇编器</h5><p>当然，计算机并不认识助记符，它只认得二进制码，所以程序员写了一个二进制程序来帮忙。<strong>它可以读懂文字指令，自动转换成二进制指令，这种程序叫“汇编器”</strong>。汇编器读取用汇编语言写的程序，然后转成“机器码”。随着时间推移，汇编器能够帮助人类完成的事情越来越多。其中一个就是自动分析JUMP地址，程序员写程序时，只需写入可跳转的标签，汇编器就会自己跳转分析。</p>
<p>因此，程序员可以专心编程，不用管底层细节。</p>
<p>汇编语言直接对应机器码，虽然已经很方便了。但是，汇编器仍然强迫程序员思考，用什么寄存器和内存地址，如果我们突然要用额外一个数，可能要改很多代码。这时候，需要更加高级的语言出现。</p>
<h4 id="11-2-A-0语言"><a href="#11-2-A-0语言" class="headerlink" title="11.2 A-0语言"></a>11.2 A-0语言</h4><p>为了更加方便编程，历史上有计算机科学家发明了A-0语言。这种语言相对汇编语言更加高级(一般一条汇编指令对应一条机器指令)，一行高级编程语言，可能会转成几十条二进制指令。同时，这名科学家还做了<strong>编译器</strong>，可以专门把高级语言转成低级语言，比如汇编或者机器码（CPU可以直接执行机器码）。虽然这个想法很先进，但是在当时并没有被大众所广泛使用。</p>
<h4 id="11-3-高级语言的思想"><a href="#11-3-高级语言的思想" class="headerlink" title="11.3 高级语言的思想"></a>11.3 高级语言的思想</h4><p>幸运的是，这种思想开始流行，很多人尝试创建新的编程语言。比如我们用高级语言Python为例，计算两个值的和，如果用汇编语言，我们得从内存取值，和寄存器打交道以及其他底层细节。但同样的程序用Python可以这样写，不用管内存和寄存器位置。</p>
<p>程序员只需要创建<strong>“代表内存地址的抽象”，叫变量。</strong>上图，我们把变量存在A和B中，然后相加两个数，把结果存在C中。在底层操作时，编译器可能把变量A存在寄存器A中，但这些，程序员已经不需要自己思考放在哪了。</p>
<h4 id="11-4-Fortran语言"><a href="#11-4-Fortran语言" class="headerlink" title="11.4 Fortran语言"></a>11.4 Fortran语言</h4><p>Fortran语言，名字来源于“公式翻译”，IBM发布于1957年，其主宰了早期计算机编程。平均来说，Fortran语言写的代码，比同等的手写汇编代码短20倍，然后Fortran编译器会把代码转成机器码。语言更加高级，所以运行速度会慢一点，但是代码编写速度会大大提高。Fortran语言开始时只能运行在IBM计算机上。</p>
<h4 id="11-5-通用编程高级语言"><a href="#11-5-通用编程高级语言" class="headerlink" title="11.5 通用编程高级语言"></a>11.5 通用编程高级语言</h4><p>50年代的大部分编程语言和编译器只能运行在一种计算机上。如果升级电脑，所有的代码都可能要重写。因此，工业界、学术界和政府计算机专家，在1959年组成一个联盟——<strong>数据系统语言委员会</strong>。开发了一种通用编程语言，可以在不同机器上通用。最后，诞生一门通用商业语言，Cobol。为了兼容不同硬件，每个计算机都需要对应的编译器，但是这些编译器可以接收相同的Cobol代码。这种叫<strong>一次编写，多处运行</strong>。</p>
<p>由于高级语言的出现，原来只有计算机科学家才能的编程，到后来各个专业的人们都可以学会编程。下面是不同年代出现的主要重要语言，可以以此来瞧瞧编程语言的发展。</p>
<ol>
<li>从1959年开始，编程语言的时代开始了。</li>
<li>在1960年代，有Algol、Lisp、Basic等语言。</li>
<li>70年代有Pascal、C和Smalltalk语言等。</li>
<li>80年代有C++、Objective-C（扩充C的面向对象语言）等。</li>
<li>90年代有Python、Java和Ruby等语言。</li>
<li>在新千年，Swift、C#和Go在崛起。</li>
</ol>
<p>新语言使用更加聪明的抽象，使得其在某些方面更容易和强大。</p>
<h3 id="12-编程原理-语句和函数"><a href="#12-编程原理-语句和函数" class="headerlink" title="12 编程原理-语句和函数"></a>12 编程原理-语句和函数</h3><p>上节课讲到机器码写程序需要处理底层细节，写大型程序非常麻烦。为了脱离底层细节，开发了编程语言以让程序员专心解决问题，不用管硬件细节。这节课，我们讨论大部分编程语言都有的<strong>语法和函数</strong>。</p>
<h4 id="12-1-语句与语法"><a href="#12-1-语句与语法" class="headerlink" title="12.1 语句与语法"></a>12.1 语句与语法</h4><p><strong>语法，是用来规定句子结构的一系列规则。</strong>英语有语法，所有的编程语言也都有语法。a=5是一句语言，意思是，创建一个变量a，把数字5放进去。这叫赋值语句，把一个值赋给一个变量。注意，变量名称可以随便取（不重名即可），当然取名最好有点意义，这样可以方便别人读懂。程序和做菜一样，会一步步运行到程序尾部。</p>
<p>为了不只是顺序执行程序，我们需要流程控制语句。最常见的流程控制语句是if语句，if语句需要判断语句，因此这些表达式又叫“<strong>条件语句</strong>”，下面是一些流行语言的if语句。if语句是指，如果if里的条件为真，那么就执行if下面的代码；否则执行else下面的代码。</p>
<p><img src="https://pic.imgdb.cn/item/66a85205d9c307b7e9b2349b.png" alt="常见编程语言的if-else语法"></p>
<p>if语句只执行一次，如果要执行多次，则要用<strong>while语句</strong>。当while条件为真时，就会重复执行代码。另一个常用的循环结构是<strong>for结构</strong>。for结构不判断条件，会判断次数，会循环特定次数。 </p>
<h4 id="12-2-函数"><a href="#12-2-函数" class="headerlink" title="12.2 函数"></a>12.2 函数</h4><p><strong>为了隐藏程序的复杂度，我们可以把代码打包成函数，有些编程语言也叫“方法”或“子程序”</strong>。若其他地方想用这个函数，直接写函数名即可。当然，我们可以在函数里面加其他函数，这样可以设计更加简洁的代码。所以现代软件，是由上千个函数组成的，每个负责不同的事情。</p>
<p>这种模块化编程，不仅可以让单个程序员独立制作APP，也可以让团队协作写更大型的程序。不同程序员写不同的函数，只需要保证自己的代码正确，把所有人的拼起来，整个程序应该就能正常运行。</p>
<p>现在，我们不需要写指数函数这些普遍的函数。现代编程语言，有很多预先写好的函数集合，叫“<strong>库</strong>”，由专业人员编写，不仅效率高，而且经过了仔细检查。这样可以方便我们开发程序。本节结束，下节讲函数。 </p>
<h3 id="13-算法入门"><a href="#13-算法入门" class="headerlink" title="13 算法入门"></a>13 算法入门</h3><p>前面两集尝试了高级编程语言，我们讨论了几种语句，赋值语句、if语句、循环语句等，以及打包的函数。算法，是解决某种问题的具体方法，一般而言所需时间越少越好，有时我们也关注其他方面，比如所占空间等。</p>
<h4 id="13-1-排序算法"><a href="#13-1-排序算法" class="headerlink" title="13.1 排序算法"></a>13.1 排序算法</h4><p>最常见的算法就是排序，比如给数字排序。排序也是应用非常广泛，非常常见的算法。排序算法有很多，为的是更快地进行排序。视频讲了选择排序。<strong>选择排序</strong>是指，对于每一次范围（这个范围逐渐减少）从中选择最小的放在最首。</p>
<p>算法的输入大小与运行步骤之间的关系，叫算法复杂度，代表运c行速度的量级。算法复杂度叫大O表示法。选择排序的复杂度是O(n^2)。此外，更低的排序有<strong>归并排序，时间复杂度是O(n*logn)。</strong></p>
<h4 id="13-2-迪杰斯特拉算法"><a href="#13-2-迪杰斯特拉算法" class="headerlink" title="13.2 迪杰斯特拉算法"></a>13.2 迪杰斯特拉算法</h4><p>用于图搜索的算法，对于一个有权图，要找最短路径，如果全部穷举，那么会是O(n!)的复杂度，这是一个非常糟糕的复杂度。所以，迪杰斯特拉发明了一种求最短路的算法，叫迪杰斯特拉算法。其算法复杂度是O（n^2）。</p>
<p>算法无处不在，并广泛应用于生活中各个地方，算法设计，也是计算机科学中一个很重要的方向。本节完，这节内容比较少，是因为这些知识数据结构中基本都学过了，就不需要着重记笔记。 </p>
<h3 id="14-数据结构"><a href="#14-数据结构" class="headerlink" title="14 数据结构"></a>14 数据结构</h3><p>本集高能，基本上一分钟一个数据结构。</p>
<p>上节课讲了一写算法，比如数组排序、最短路径。不过，上节没讲的是，算法处理的数据，存在内存里的格式是什么。我们希望数据是结构化的，方便读取。所以，科学家发明了<strong>数据结构。</strong></p>
<h4 id="14-1-数组"><a href="#14-1-数组" class="headerlink" title="14.1 数组"></a>14.1 数组</h4><p><strong>数组的值一个个连续存在内存里面</strong>，所以不像之前，一个变量里只存一个值，我们可以把多个值存在数组变量里。我们用下标<code>[i]</code>取值，下标一般从0开始。<strong>数组变量表示的是首元素地址</strong>，后面通过偏移得到其他元素坐标。</p>
<p><img src="https://pic.imgdb.cn/item/66a86421d9c307b7e9c0ddf0.png" alt="数组"></p>
<p>现在很多语言自带了数组的一些算法，比如排序算法等，不需要我们直接写。</p>
<h4 id="14-2-字符串"><a href="#14-2-字符串" class="headerlink" title="14.2 字符串"></a>14.2 字符串</h4><p>和数组相似的就是字符串，它是<strong>由字母、数字和标点等组成的数组</strong>。写代码时，用括号括起来就可以了，<code>j=&quot;START&quot;</code>。在字符串末尾，有<code>NULL</code>项，这一项表示字符串到此结束。</p>
<p>因为计算机经常处理字符串，所以会有很多字符串函数，比如连接字符串strcat（接收两个字符串，把第二个放在第一个末尾）。</p>
<h4 id="14-3-矩阵"><a href="#14-3-矩阵" class="headerlink" title="14.3 矩阵"></a>14.3 矩阵</h4><p>有时，我们需要处理图像或者表格，此时我们需要矩阵。我们<strong>可以把矩阵看做是数组的数组</strong>。多维数组里的元素，其实也是像一维数组那样顺序排列的，只不过提取数组方式不一样。</p>
<p><img src="https://pic.imgdb.cn/item/66a86560d9c307b7e9c20aa8.png"></p>
<h4 id="14-4-结构体"><a href="#14-4-结构体" class="headerlink" title="14.4 结构体"></a>14.4 结构体</h4><p><strong>把多种不同类型的数据打包放在一起，就叫结构体</strong>。甚至我们可以做一个结构体数组。结构体数组和普通数组一样，创建时便有固定的空间，不能动态增加容量。</p>
<h4 id="14-5-链表"><a href="#14-5-链表" class="headerlink" title="14.5 链表"></a>14.5 链表</h4><p>我们将值和指针放在一个节点（结构体）里面，就可以实现动态添加元素。指针是一种特殊变量，指向一个内存地址。<strong>多个连成的节点，就叫链表</strong>。有多种链表，比如循环链表和单向链表等等。</p>
<p><img src="https://pic.imgdb.cn/item/66a8663fd9c307b7e9c2ba99.png" alt="链表"></p>
<p>不同于数组的长度固定，链表可以通过改变指针指向动态添加元素。 </p>
<ul>
<li><strong>队列和栈</strong></li>
</ul>
<p>队列和栈都是基于链表的（好像有数组类型的不过不常用）。</p>
<p>队列就像排队一样，谁先来谁先上，这叫<strong>先进先出（FIFO）</strong>。有<strong>入队和出队</strong>操作，入队在队尾进行，出队在队首进行。</p>
<p>栈是<strong>先进后出</strong>的结构。栈元素的出入叫<strong>入栈和出栈</strong>。入栈和出栈在栈顶进行。</p>
<h4 id="14-6-树"><a href="#14-6-树" class="headerlink" title="14.6 树"></a>14.6 树</h4><p>如果节点有两个指针，分别指向左树和右树。最高的叫<strong>根节点</strong>，其余都叫子节点。没有任何子节点的节点，叫叶节点。若每个节点最多两个子节点，那么就叫<strong>二叉树</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/66a86712d9c307b7e9c35a99.png" alt="二叉树" style="zoom:60%"></p>
<p>树的一个重要特性是，从根到叶是单向的。</p>
<h4 id="14-7-图"><a href="#14-7-图" class="headerlink" title="14.7 图"></a>14.7 图</h4><p>不同于树，如果数据可以随意相连，包括循环，就叫<strong>图</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/66a8678ed9c307b7e9c3bbe2.png" alt="图" style="zoom:60%"></p>
<p>上面就是主要的数据结构，此外还有堆和红黑树等等。最后，利用好数据结构，可以帮助我们更加高效地完成一些任务开发。 </p>
<h3 id="15-阿兰·图灵"><a href="#15-阿兰·图灵" class="headerlink" title="15 阿兰·图灵"></a>15 阿兰·图灵</h3><h4 id="15-1-图灵机"><a href="#15-1-图灵机" class="headerlink" title="15.1 图灵机"></a>15.1 图灵机</h4><p>前几集我们讲了基础，比如函数、算法和数据结构。今天，我们来看一个对计算机理论贡献巨大的人，计算机科学之父——阿兰·图灵。</p>
<p>图灵于1912年出生在伦敦。当时一个很著名的问题是“<strong>可判定性问题</strong>”：是否存在一种算法，输入正确逻辑语句，输出准确的“是”或“否”。美国数学家阿隆佐·丘奇于1913年首先提出解决办法，他开发了一个叫“<strong>lambda算子</strong>”的系统，证明了这样的算法不存在。</p>
<p>但是lambda算子系统过于复杂，大洋彼岸的图灵提出一种假想计算机——后来被称为图灵计算机。图灵机的原理更加简单，更容易被人接受。图灵是一台理论计算设备。</p>
<p><img src="https://pic.imgdb.cn/item/66a86990d9c307b7e9c52364.png" alt="图灵机" style="zoom:30%"></p>
<p>图灵机有无限长的纸带，纸带可以存储符号。图灵机可以读入和写入纸带上的符号，还有一个状态变量，保存当前状态，还有规则。<strong>图灵证明只要有足够多的规则、状态和纸带，可以创造任何东西。</strong>没有计算机能比图灵机更强大。现在的计算机、手表和手机啥的，都是<strong>图灵完备的。</strong></p>
<ul>
<li><strong>停机问题</strong></li>
</ul>
<p>图灵利用图灵机完成了可判定性问题的证明。</p>
<p>有没有办法在不执行的情况，弄清会不会停机？</p>
<p>图灵通过一个巧妙逻辑矛盾证明了停机问题是无法解决的，我们来看看他的推理。想象有一个假想图灵机，输入:问题的描述+纸带的数据，输出 Yes 代表会”停机”，输出 No 代表不会停机。不用担心它具体怎么工作，假设这样的机器存在就好，毕竟重点是推论。</p>
<p>图灵推理说：如果有个程序，此图灵机无法判断是否会”停机”，意味着”停机问题”无法解决。为了找到这样的程序，图灵用这台图灵机设计了另一个图灵机。如果一开始的图灵机说程序会”停机”(YES)，那么新设计机器会永远运行(即不会停机)；如果一开始的图灵机的结果为 No，代表不会停机，那么让新机器输出 No，然后”停机”。也就是说新设计的图灵机和一开始的图灵机的输出正好相反。如果程序不停机，就停机，如果程序停机，就永远运行下去。</p>
<p>…………剩下的内容看视频吧。</p>
<p>总之，长话短说，丘奇和图灵证明了计算机的能力有极限，无论有多少时间或内存，有些问题是计算机无法解决的。</p>
<h3 id="16-软件工程"><a href="#16-软件工程" class="headerlink" title="16 软件工程"></a>16 软件工程</h3><p>大型软件，代码往往很多。开发软件需要很强的科学性，由此，一个关于软件的学问出现了，软件工程。</p>
<h4 id="16-1-面向对象"><a href="#16-1-面向对象" class="headerlink" title="16.1 面向对象"></a>16.1 面向对象</h4><p>前文我们提到了，把大项目分解成小函数，可以让很多人同时工作。每个人不需要关心整个工程，只需要关心自己的部分即可。</p>
<p>但是仅仅把打包成函数还不够，就像office有上千万行代码，就算打包成函数也有几十万个。解决办法是：<strong>把函数打包成层级，把相关代码都放在一起，打包成对象。这就是面向对象的由来。</strong></p>
<p><strong>一个对象可以包含其他对象、函数和变量。</strong>我们要访问某个函数时，要通过对象不断向内索引。这样通过封装组件，可以<strong>隐藏复杂度</strong>。</p>
<h4 id="16-2-开发文档"><a href="#16-2-开发文档" class="headerlink" title="16.2 开发文档"></a>16.2 开发文档</h4><p>开发完成项目后，团队需要完成解释文档，帮助理解代码都在做什么，以及定义好<strong><font color="red">”程序编程接口”，简称API</font></strong>。</p>
<p><u>API帮助不同程序员合作，不用知道具体细节，只知道怎么使用就行了。API还控制哪些函数和数据让外部访问，哪些仅供内部访问。“面向对象”的编程语言，可以指定函数是public或private来设置权限</u>。</p>
<p>“面向对象”的核心是，<strong>隐藏复杂度和选择性的公布功能</strong>。现在大部分软件或者游戏都是面向对象编程语言写的，比如C++，C#等。</p>
<h4 id="16-3-IDE"><a href="#16-3-IDE" class="headerlink" title="16.3 IDE"></a>16.3 IDE</h4><p>现代软件的开发，一般需要借助开发器。<strong>开发器集成了编译、调试、整理代码等功能，因为集成了所有的东西，因此叫集成开发环境，简称IDE</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/66a871d8d9c307b7e9cbc775.png" alt="Pycharm：较流行的Python的IDE" style="zoom:50%"></p>
<p>IDE还可以直接编译和运行代码。如果代码错误，IDE会定位到错误代码并给出提示来解决问题，这叫调试debug。</p>
<p>程序员工作的另一个重要部分是给代码写文档，这个文档写在readme里面。文档也可以直接注释在程序里面。<strong>注释很重要</strong>。</p>
<h4 id="16-4-源代码管理"><a href="#16-4-源代码管理" class="headerlink" title="16.4 源代码管理"></a>16.4 源代码管理</h4><p>IDE还有另一个功能，叫<strong>源代码管理</strong>，也叫<strong>版本控制</strong>。大型程序有源代码管理，他们还会将代码放到一个中心服务器上，叫代码仓库。</p>
<p>要修改代码时，就从代码仓库里取出来，修改完成后再放入。</p>
<p>当代码出现错误时，源代码管理也可以帮助程序员恢复到未修改的版本，并定位是谁修改了代码。</p>
<h4 id="16-5-测试"><a href="#16-5-测试" class="headerlink" title="16.5 测试"></a>16.5 测试</h4><p>测试代码和写代码一样重要，测试一般有个人或者小团队完成。测试统称为“质量保存测试”，简称QA。它严格测试软件的方方面面，模拟各种情况，看看软件会不会出错，就是找Bug。</p>
<h4 id="16-6-alpha版本和beta版本"><a href="#16-6-alpha版本和beta版本" class="headerlink" title="16.6 alpha版本和beta版本"></a>16.6 alpha版本和beta版本</h4><p>beta版本是接近完成的版本，此版本可以向大众开放，进行免费测试。alpha版本的粗糙的版本。</p>
<h3 id="17-集成电路与摩尔定律"><a href="#17-集成电路与摩尔定律" class="headerlink" title="17 集成电路与摩尔定律"></a>17 集成电路与摩尔定律</h3><p>过去几集我们学了软件、编程语言等，软件科学有着巨大的发展，但是如果没有硬件的大幅度进步，软件是不可能做到这些的。</p>
<h4 id="17-1-集成电路IC的出现"><a href="#17-1-集成电路IC的出现" class="headerlink" title="17.1 集成电路IC的出现"></a>17.1 集成电路IC的出现</h4><p>电子计算机时代，计算机有独立部件组成，叫”分立元件“，然后不同组件再用线连在一起。这时候计算机非常大而且很昂贵。在1950年中期，<strong>晶体管</strong>开始商业化，开始用于计算机。晶体管比真空管更小，但是元件依然是分立的。</p>
<p>晶体管的到来，标志着”计算2.0时代“的到来。但是晶体管的出现并没有完全解决电脑元件多线路复杂的问题。解决办法就是，讲计算机所有元件集成。<strong>简单地来说，把多个组件包在一起，变成一个新的独立组件，这就是集成电路。</strong></p>
<p>1959年的仙童半导体，让集成电路变成现实。仙童半导体用硅作为材料，其更稳定更可靠，价格也更低。<strong>Noyce因为发明了仙童半导体，被公认为现代集成电路之父</strong>。电子时代出现。</p>
<p><img src="https://pic.imgdb.cn/item/66a874b8d9c307b7e9cf050d.png" alt="IC的早期样品：只有几个晶体管" style="zoom:60%"></p>
<p>IC 就像电脑工程师的乐高积木，可以组合出无数种设计，但最终还是需要连起来，创造更大更复杂的电路，比如整个计算机。所以，PCB被创造出来了。</p>
<h4 id="17-2-印刷电路板——PCB"><a href="#17-2-印刷电路板——PCB" class="headerlink" title="17.2 印刷电路板——PCB"></a>17.2 印刷电路板——PCB</h4><p>集成电路可以把多个电路元件集成在一块芯片上，但是依然要将电路连接起来以制造计算机。所以工程师再度创新：印刷电路板，简称PCB。PCB可以大规模生产，<strong>无需焊接或用一大堆线。它通过蚀刻金属线的方式，把零件连接到一起。</strong>PCB和IC结合使用，可以大幅度减少独立组件和线路，但做到同样的功能。而且更小、更便宜更可靠。</p>
<h4 id="17-3-光刻"><a href="#17-3-光刻" class="headerlink" title="17.3 光刻"></a>17.3 光刻</h4><p>早期的元件，无法集成大量晶体管。所以需要全新的制造工艺——光刻。简单来说，就是用光把复杂图案印到材料上，比如半导体。它只有几个基础操作，但可以制作出复杂电路。</p>
<p><img src="https://pic.imgdb.cn/item/66a8766cd9c307b7e9d067a7.png" style="zoom:30%"></p>
<p>光刻机光刻电路的流程是，对于一块硅（晶圆），上面加氧化层，光刻胶，和光掩膜，然后用强光照射，强光能照射的地方光刻胶消失，然后把露出部分的氧化层清洗掉，最后再清洗掉光刻胶，就可以进行材料<strong>掺杂</strong>了。 </p>
<p><img src="https://pic.imgdb.cn/item/66a8770ed9c307b7e9d0f996.png" style="zoom:30%"></p>
<blockquote>
<p>我们想修改硅露出来的区域让它导电性更好，所以用一种化学过程来改变它，称为“掺杂”。</p>
</blockquote>
<p>由于光刻机和集成电路的出现，一片IC由原来的5个晶体管增加到1960年中期的上百个。</p>
<h4 id="17-4-摩尔定律"><a href="#17-4-摩尔定律" class="headerlink" title="17.4 摩尔定律"></a>17.4 摩尔定律</h4><p>1965年，摩尔看到了趋势：<strong>每两年左右，得益于材料和制造技术的发展，同样大小的空间，能塞进两倍数量的晶体管。这叫摩尔定律</strong>。芯片的价格也不断下降。</p>
<p>芯片集成地小，可以减少电的损耗，信号延迟更低，时钟速度加快。仅仅1950年左右，用分立元件会占满整个屋子，到集成电路出现，元件越来越小。尤其是集成电路用于微处理器，开启了计算3.0时代。到2010年，10亿个晶体管集成在一片芯片。光刻机分辨率也从几毫米到15纳米。</p>
<p>如今的处理器，比如iPhone7的A10CPU，有33亿个晶体管。</p>
<p>集成芯片的设计当然不是手工的，从1970年开始，<strong><font color="blue">超大规模集成（VLSI）</font></strong>软件来自动生产芯片设计。</p>
<h4 id="17-5-未来集成电路面临的挑战"><a href="#17-5-未来集成电路面临的挑战" class="headerlink" title="17.5 未来集成电路面临的挑战"></a>17.5 未来集成电路面临的挑战</h4><p>不幸的是，摩尔定律受到越来越多的挑战，现在已经达到极限。进一步做小，会<strong>面临两个问题。</strong></p>
<ol>
<li>用光掩膜把图案加到晶圆上，因为光的波长，精度已经达到极限。</li>
<li>当晶体管非常小，电极之间可能只距离几个原子，电子会跳过间隙，叫<strong>量子隧道贯穿效应</strong>。</li>
</ol>
<h3 id="18-操作系统"><a href="#18-操作系统" class="headerlink" title="18 操作系统"></a>18 操作系统</h3><h4 id="18-1-操作系统简介"><a href="#18-1-操作系统简介" class="headerlink" title="18.1 操作系统简介"></a>18.1 操作系统简介</h4><p>1940、1950年代的电脑，每次只能运行一个程序，程序员通过在打孔纸板上写程序来进行。打好孔后，再放入计算机中运行程序。但是，这种方法较慢。我们需要一种方法，让计算机自动运行程序，”<strong>操作系统</strong>“因此而生。</p>
<p><strong>操作系统，也叫OS，其实也是一种程序</strong>。但是它有操作硬件和特殊权限，可以运行和管理其他程序。操作系统一般是开机第一个启动的程序。其他程序，都由操作系统启动。</p>
<h4 id="18-2-操作系统的作用"><a href="#18-2-操作系统的作用" class="headerlink" title="18.2 操作系统的作用"></a>18.2 操作系统的作用</h4><p>早期的操作系统，一次只能运行一个程序，现在可以运行多个。<strong>系统运行完一个程序后，会自动运行下一个程序，不会浪费时间在更换程序上，这叫”批处理“</strong>。</p>
<p>当时，不同的CPU甚至相同的，可能配备着不同的打印机。程序员不仅需要考虑如何写程序，还有考虑如何和打印机和键盘等”<strong>外部设备</strong>“的交互。程序员需要考虑外部设备如何使用，以进行写代码。如今，操作系统充当软件和硬件之间的媒介。更具体地说，操作系统提供API来抽象硬件，叫”<font color="blue">**设备驱动程序</font>**“。程序员可以用标准化机制和输入输出硬件(I/O)交互。比如，程序员只需要调用<code>print(highscore)</code>，然后操作系统会处理输出到纸上的具体细节。</p>
<h4 id="18-2-多任务处理"><a href="#18-2-多任务处理" class="headerlink" title="18.2 多任务处理"></a>18.2 多任务处理</h4><p>如果一个系统只能运行一个程序的话，那么很多设备将会闲置，只能等待其他IO设备完成后，才用。所以，后来开发了能在单个CPU上<strong>同时运行几个程序的操作系统</strong>。这种能力叫做操作系统的”<strong>多任务处理</strong>“。</p>
<h4 id="18-3-操作系统的内存管理"><a href="#18-3-操作系统的内存管理" class="headerlink" title="18.3 操作系统的内存管理"></a>18.3 操作系统的内存管理</h4><p>不同的程序数据，在计算机中存放于不同的位置，甚至可能同一个程序的数据分别处于计算机中的不同位置。这种存法导致程序员要追踪这些地址很麻烦。<strong>为了隐藏这种复杂性，操作系统会把内存地址进行”虚拟化“，这叫<font color="purple">虚拟内存</font></strong>。程序可以假定内存总是从地址0开始的。而内存实际的物理地址，被操作系统隐藏和抽象了。</p>
<p><img src="https://pic.imgdb.cn/item/66a89026d9c307b7e9e950ba.png" alt="虚拟内存" style="zoom:70%"></p>
<p>操作系统会自动地讲程序的物理地址与虚拟地址进行映射（有一个映射表，存储了虚拟内存和真实内存的映射关系）。一个在不同物理地址的程序，可能映射为统一顺序。这种机制可以使程序的内存大小可以灵活增减，叫”<strong>动态内存分配</strong>“。</p>
<p>我们会给一个程序一定的内存范围，如果程序出错开始乱写数据，那么这些错误的数据不会到其他内存下，这叫“<strong><font color="green">内存保护</font></strong>”。这对防止恶意软件(如病毒)也很有用，例如，我们不希望其他程序有能力读或改邮件程序的内存，如果有这种权限，恶意软件可能以你的名义发邮件，甚至窃取个人信息。</p>
<h4 id="18-4-分时操作系统"><a href="#18-4-分时操作系统" class="headerlink" title="18.4 分时操作系统"></a>18.4 分时操作系统</h4><p>在1970年代，计算机开始变得越来越便宜。这时，计算机不仅可以多个程序运行，而且可以多个用户访问。用户通过“<strong>终端</strong>”访问电脑，<em><u>终端只是键盘和屏幕，本身没有处理能力</u></em>。冰箱大小的计算机可能有50个终端，能让50个用户使用，这时操作系统不但要处理多个程序，还要处理多个用户。</p>
<p>为了能够让多用户使用计算机而不会使一个用户占满计算机，开发了<strong>分时操作系统。意思是每个用户只能用一小部分处理器、内存等</strong>，因为电脑很快，即使拿到1/50的资源也足以完成许多任务。</p>
<p>早期分时操作系统中，最有影响力的是<strong>Multics</strong>（多任务信息与计算系统），它是第一个从设计时就考虑到安全的操作系统。开发人员不希望恶意用户访问不该服务的数据。不过由于其系统过度设计了（功能太多），导致其所占内存过多，不能流行起来。</p>
<h4 id="18-5-Unix操作系统"><a href="#18-5-Unix操作系统" class="headerlink" title="18.5 Unix操作系统"></a>18.5 Unix操作系统</h4><p>所以为了简化操作系统的复杂度，设计者开发了<strong>Unix</strong>，Unix把操作系统分成两个部分：</p>
<ol>
<li>首先是操作系统的核心功能，如<u>内存管理、多任务处理和输入/输出处理</u>，这叫“<strong>内核</strong>”；</li>
<li>第二部分是一堆有用的工具，如程序和运行库，但他们不是内核的一部分。紧凑的内核，意味着功能没有那么全面。</li>
</ol>
<p>Unix的简单使得它可以用于很多计算机，越来越多的开发人员用Unix写程序和运行程序。Unix系统也在贝尔实验室大受欢迎。甚至在1970年代，有人还写了在Unix下的不同编程语言的编译器，这些使得Unix成为了1970-80年代最受欢迎的计算机操作系统。</p>
<h4 id="18-6-个人电脑和现代操作系统"><a href="#18-6-个人电脑和现代操作系统" class="headerlink" title="18.6 个人电脑和现代操作系统"></a>18.6 个人电脑和现代操作系统</h4><p>随着计算机水平的发展，出现了个人电脑和家庭电脑。这些电脑的操作系统比较简单，缺乏“多任务“、”内存保护“等功能，若遇到程序错误，就会发生<strong>崩溃（蓝屏）</strong>。幸运的是，1980年代开发的windows系统，有更好的保护，不会经常崩溃。</p>
<h3 id="19-内存和储存介质"><a href="#19-内存和储存介质" class="headerlink" title="19 内存和储存介质"></a>19 内存和储存介质</h3><p>本节重点，存储技术的发展。</p>
<h4 id="19-1-内存和存储器区别"><a href="#19-1-内存和存储器区别" class="headerlink" title="19.1 内存和存储器区别"></a>19.1 内存和存储器区别</h4><p>本系列中，我们多次谈到内存，甚至设计了一个简单内存（锁存器）。一般来说，电脑内存是”非永久性“，如果电源线不小心拔掉了，内存里所有数据都会丢失，所以内存叫”易失性“存储器。</p>
<p>不过，存储器和内存有所不同。任何写入存储器的数据，比如电脑硬盘，数据会一直存着，直到被覆盖删除，断电也不会丢失。存储是”非易失的“。比如一个小小的U盘，能够低成本+可靠+长时间地存储上GB的数据。</p>
<h4 id="19-2-早期的存储器——延迟线存储器"><a href="#19-2-早期的存储器——延迟线存储器" class="headerlink" title="19.2 早期的存储器——延迟线存储器"></a>19.2 早期的存储器——延迟线存储器</h4><p>最早的存储介质是打孔纸片和打孔纸带。纸片用了十几年，因为不用电而且便宜耐用。坏处就是读取慢，只能写入一次，打的孔无法修复，若要存储临时值，纸卡不好用。</p>
<p><img src="https://pic.imgdb.cn/item/66a89931d9c307b7e9f1439e.png" alt="纸卡片存储器" style="zoom:40%"></p>
<p>由于纸片的缺陷，人们发明了延迟线存储器。原理是，拿一个管子装满液体，管子一端放扬声器，另一端放麦克风，扬声器发出的声波，发送到麦克风需要一定时间，麦克风将压力波转换回电信号，我们可以用压力波的传播延迟来存储数据。若有压力则表示1，无则表示0，麦克风受到这些压力波后，把其转换为1010之类的二进制数据。若用线路+放大器将其接回，那么就可以存储这段信号了。 </p>
<p><img src="https://pic.imgdb.cn/item/66a89a4ed9c307b7e9f23ae9.png" alt="延迟线存储器" style="zoom:30%"></p>
<p>但是，延长线存储器的缺点是，每个时刻只能读一位数据。如果你想访问第100位数据，你只能等待第100位数据出现，这种叫做”顺序存储器“或”循环存储器“，而我们想要的是”随机存取存储器“，可以随时访问任何位置。</p>
<h4 id="19-3-磁芯存储器"><a href="#19-3-磁芯存储器" class="headerlink" title="19.3 磁芯存储器"></a>19.3 磁芯存储器</h4><p>后面还出现了如”磁致伸缩延迟存储器“，但是延迟线存储器在1950年代中期就基本过时了，因为出现了性能、可靠性和成本都更好的”<strong>磁芯存储器</strong>“。当磁圈加正电，就可以磁化，加反向电，就可以反向磁化，可以用这个来表示01存储信息。当然，用1位不行，需要用到磁圈网络。</p>
<p><img src="https://pic.imgdb.cn/item/66a89cd8d9c307b7e9f47620.png" alt="磁圈网络"></p>
<p>下图是一个实际的磁芯存储器，每个黄色方格有32行x32列的磁芯，每个磁芯存1位数据，所以能存1024 位(bit)(32x32=1024)。</p>
<p><img src="https://pic.imgdb.cn/item/66a89d17d9c307b7e9f4ac28.png" alt="现实中的磁芯存储器" style="zoom:60%"></p>
<p>最重要的是，磁芯存储器不像延迟线存储器，磁芯存储器能随时访问任何一位，这时非常有用的。磁芯存储器于1950开始，流行了20多年。 </p>
<h4 id="19-4-磁带"><a href="#19-4-磁带" class="headerlink" title="19.4 磁带"></a>19.4 磁带</h4><p>即使如此，磁芯存储器能存储的数据还是太少了。1951年，还发明了一直存储器，叫”<strong>磁带</strong>“。磁带是纤薄柔软的一长条磁性带子，卷在轴上。磁带可以在”磁带驱动器“内前后移动。磁带的存储空间相比之前的几kb大小，大了很多，可达几mb。因为磁带驱动器很贵，但是磁带很便宜，所以磁带一般用于数据存储。磁带的主要缺点是访问速度。</p>
<p><img src="https://pic.imgdb.cn/item/66a89e73d9c307b7e9f76763.png" alt="磁带的简要原理" style="zoom:60%"></p>
<h4 id="19-5-现代存储器——硬盘、软盘、光盘"><a href="#19-5-现代存储器——硬盘、软盘、光盘" class="headerlink" title="19.5 现代存储器——硬盘、软盘、光盘"></a>19.5 现代存储器——硬盘、软盘、光盘</h4><p>1950，60年代，有个类似的“磁鼓存储器”，磁鼓持续旋转，可以读取数据。但到1970年代，磁鼓存储器不再生产。然而磁鼓导致了<strong>硬盘</strong>的发展，因为硬盘和磁鼓很像。磁盘有磁性，其优点就算薄，可以进行堆叠。1970年代，磁盘大幅度改进并变得普遍，如今硬盘可以轻易容纳1TB的数据。</p>
<p><img src="https://pic.imgdb.cn/item/66a89f67d9c307b7e9f85747.png" alt="实际中的硬盘" style="zoom:80%"></p>
<p>软盘，除了磁盘是软的，其他基本一样。软盘是为了便携。你可能对光盘（CD）产品更熟悉，功能和硬盘一样，都是存储数据，不过原理不同，光盘主要用的是光学技术。如今，存储器朝固态前进，如硬盘和U盘，里面都是集成电路。如果机械硬盘被固态硬盘代替，简称SSD。 </p>
<h3 id="20-文件系统"><a href="#20-文件系统" class="headerlink" title="20 文件系统"></a>20 文件系统</h3><p>上集我们讲了数据存储，磁带和硬盘这样的技术。他们可以在断电的情况下存储上万亿个位，非常适合存储一整块相关的文件。我们见过很多文件，比如音乐文件，视频文件。这节课我们要讲，什么是文件，计算机如何管理文件。</p>
<h4 id="20-1-计算机中的文件格式"><a href="#20-1-计算机中的文件格式" class="headerlink" title="20.1 计算机中的文件格式"></a>20.1 计算机中的文件格式</h4><h5 id="20-1-1-数据格式与TXT文本文件"><a href="#20-1-1-数据格式与TXT文本文件" class="headerlink" title="20.1.1 数据格式与TXT文本文件"></a>20.1.1 数据格式与TXT文本文件</h5><p>数据可以随意摆放，但是按照一定规律和格式会更好，这叫数据格式。你可以发明自己的格式，但是最好按照已有的格式更好，比如JPG。</p>
<p>最简单的是文本文件，简称TXT，其本质也是二进制。我们可以把二进制转换为十进制，再由ASCII值转换为字符。</p>
<h5 id="20-1-2-波形文件WAV"><a href="#20-1-2-波形文件WAV" class="headerlink" title="20.1.2 波形文件WAV"></a>20.1.2 波形文件WAV</h5><p>更复杂的文件，比如波形文件（wave），简称wav，它存音频文件。在正确读取数据前，需要知道一些信息，如码率，单声道还是立体声。数据的数据，叫<strong><font color="green">元数据</font></strong>。元数据在文件开头，在实际数据前面，因此也叫文件头。音频数据紧跟在元数据后面，是一长串数字，数字代表每秒捕获多次的声音幅度。</p>
<p><img src="https://pic.imgdb.cn/item/66a8a235d9c307b7e9fafa37.png" alt="wav文件格式"></p>
<p>比如，对于一段声音，我们可以得到其波形如下。通过电脑或者手机，每秒可以对声音进行上千次采样，每次采样可以用一个数字表示，声压越高数字越大，也叫“振幅”，wave文件里存的就是这些数据。在播放声音文件时，扬声器会产生相同的波形，播出声音。</p>
<h5 id="20-1-3-位图文件BMP"><a href="#20-1-3-位图文件BMP" class="headerlink" title="20.1.3 位图文件BMP"></a>20.1.3 位图文件BMP</h5><p>位图（Bitmap），后缀.bmp，它存图片，计算机上，图片由很多个叫”像素“的方块组成，每个像素有三种颜色组成：<strong>红，绿，蓝，叫”加色三原色“</strong>，混在一起可以创造其他颜色。如图wav文件一样，bmp文件开头也是元数据，有图像宽度，图像高等，颜色深度信息。BMP文件是一串二进制代码，每三位分别表示红绿蓝的深度。</p>
<p>不管是文本文件，WAV文件，BMP，或者其他文件，其在底层都是一长串二进制。要想知道文件是什么样的，就得先知道文件格式是什么样的。 </p>
<h4 id="20-2-计算机如何存储文件"><a href="#20-2-计算机如何存储文件" class="headerlink" title="20.2 计算机如何存储文件"></a>20.2 计算机如何存储文件</h4><h5 id="20-2-1-目录文件"><a href="#20-2-1-目录文件" class="headerlink" title="20.2.1 目录文件"></a>20.2.1 目录文件</h5><p>虽然硬件可能是磁盘、磁带或者硬盘等，不过通过抽象后，都可以看成一排能存数据的桶。早期计算机只能存一个文件，它会顺序放置，从头存到尾。但随着计算能力和存储容量的提高，存多个文件变得非常有用。最简单的是，多个文件连续存储。这时，知道不同文件的开头和结尾在哪就变得很重要。<strong>需要记录文件的位置，这里叫”目录文件“</strong>。这个文件通常存储在开头。</p>
<p><img src="https://pic.imgdb.cn/item/66a8a437d9c307b7e9fcbb9f.png"></p>
<p>目录文件中，存所有文件的名称，还有创建时间、能否都写等等，最重要的是，目录文件中写明了文件起始位置和文件大小信息。如果更改了文件信息，就必须更新目录文件。这个例子叫”<strong>平面文件系统</strong>“，因为文件都在同一个层次。</p>
<p><img src="https://pic.imgdb.cn/item/66a8a481d9c307b7e9fcfc10.png" alt="目录文件结构"></p>
<h5 id="20-2-2-文件分块——碎片化存储"><a href="#20-2-2-文件分块——碎片化存储" class="headerlink" title="20.2.2 文件分块——碎片化存储"></a>20.2.2 文件分块——碎片化存储</h5><p>现代文件系统可能会出现问题，比如因为文件连续存储，那么前一个文件存储信息过多，可能会覆盖后一个文件。所以出现了两者解决方案：</p>
<ol>
<li>把空间划分成一块块，导致有一些”<strong>预留空间</strong>“，可以方便移动和管理；</li>
<li>拆分文件在多个块里面，目录文件中会记录拆分后文件所在的块。这听起来很像前面讲的虚拟内存。</li>
</ol>
<p><img src="https://pic.imgdb.cn/item/66a8a52dd9c307b7e9fd998e.png" alt="分块存储"></p>
<p>若要删除某个文件<strong>，</strong>计算机会将”目录文件“里的对应文件的信息删除，<strong>注意这里实际的文件并没有被删除，只是可以被其他新文件覆盖。所以计算机取证团队可以利用这点”恢复数据“。</strong></p>
<p>不过，文件因为这种存储方式会变成多个块，我们称他为<strong>碎片</strong>。碎片化的文件不利于读取，就出现了”<strong>碎片化管理</strong>“技术。<strong>碎片化整理</strong>就是将原来的分散在多个块里的数据，按顺序整理好，方便整理。</p>
<h5 id="20-2-3-分层文件系统"><a href="#20-2-3-分层文件系统" class="headerlink" title="20.2.3 分层文件系统"></a>20.2.3 分层文件系统</h5><p>平面层的数据不利于文件查看，所以出现了”分层文件系统“，所以出现一个根目录。根目录可以索引下面的文件夹，这样就可以做一个无限深度的文件夹。如果想把数据移动，我们只需要把一个目录文件的信息删除，然后添加在另一个目录文件下即可。</p>
<p><img src="https://s3.bmp.ovh/imgs/2024/07/30/e96acd5d7a9ba9ae.png" alt="分块存储" style="zoom:70%"></p>
<p>文件系统使我们不必关心文件在磁带或磁盘的具体位置，整理和访问文件更加方便。 </p>
<h3 id="21-压缩"><a href="#21-压缩" class="headerlink" title="21 压缩"></a>21 压缩</h3><p>上集我们讨论了文件格式，如何编码文字、声音和图片，还举例了txt、wav、bmp，这些格式虽然有用，但是其效率并不高。我们希望文件能小一点，这样能存大量文件，传输也会更快。解决办法就是压缩，把数据变小。</p>
<h4 id="21-1-无损压缩技术"><a href="#21-1-无损压缩技术" class="headerlink" title="21.1 无损压缩技术"></a>21.1 无损压缩技术</h4><p>我们以图像为例，每个像素的颜色是三种原色：红绿蓝的组合。每个颜色用一个字节存，数字范围是0到255。如果红绿蓝都是255会得到白色。</p>
<h5 id="21-1-1-游程编码压缩"><a href="#21-1-1-游程编码压缩" class="headerlink" title="21.1.1 游程编码压缩"></a>21.1.1 游程编码压缩</h5><p>为了减少所占内存，<strong>一种方法是减少重复信息</strong>。最简单的方法是<strong>游程编码</strong>，适合经常出现相同值的文件。比如，若有连续多个统一颜色，我们可以在最开始的颜色前加一个数字表示重复次数。为了区分哪个是数字，哪个是颜色，我们将所有颜色前面加数字表示重复次数。</p>
<p>计算机科学速成课笔记 - 问夏的文章 - 知乎<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/460879375">https://zhuanlan.zhihu.com/p/460879375</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://junheng-wang.github.io/2024/07/29/Crash-Course-Computer-Science/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2024/07/01/DL-Env-Conf/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">深度学习环境配置</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "0DieopImIy7vnuzj4jQ2wk6O-gzGzoHsz",
    app_key: "j6eRiYtlDSl8eRXVN54blF25",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> wjh
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Wang Junheng"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/Alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechatpay.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->
 
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
            <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css">
        
    
 
<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>