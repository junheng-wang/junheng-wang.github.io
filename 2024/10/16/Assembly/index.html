<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="���͡�ѧϰ�����˼�������С�����" />
       
      <meta name="description" content="���˺�����" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>汇编语言概要学习 |  Wang Junheng</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Assembly"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  汇编语言概要学习
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/16/Assembly/" class="article-date">
  <time datetime="2024-10-16T01:08:34.000Z" itemprop="datePublished">2024-10-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E6%8F%90%E5%8D%87/">学习提升</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E6%8F%90%E5%8D%87/%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">编程与深度学习</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">16.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">64 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h3><h4 id="1-1-这门课学什么"><a href="#1-1-这门课学什么" class="headerlink" title="1.1 这门课学什么"></a>1.1 这门课学什么</h4><ul>
<li>定位：理解硬件结构，掌握指令集，理解程序的运行过程。</li>
<li>内容：选取8088、8086指令集进行汇编语言程序设计的学习。</li>
</ul>
<h4 id="1-2-机器语言与汇编语言"><a href="#1-2-机器语言与汇编语言" class="headerlink" title="1.2 机器语言与汇编语言"></a>1.2 机器语言与汇编语言</h4><p>机器语言是机器指令的集合。<br>机器指令是一台机器可以正确执行的命令。<br>机器指令由一串二进制数表示，例 01010000。</p>
<p>汇编语言的主体是汇编指令。<br>汇编指令和机器指令的差别在于指令的表示方法上：① 汇编指令是机器指令便于记忆的书写格式； ② 汇编指令是机器指令的助记符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>机器指令</th>
<th>汇编指令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>1000100111011000</td>
<td>MOV AX, BX</td>
<td>将寄存器BX的内容送到AX中</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://pic.imgdb.cn/item/670f217bd29ded1a8cc2f8f0.png"></p>
<p>用汇编语言编写程序的工作过程：程序员编写汇编指令→编译器编译为二进制机器码→计算机执行程序。</p>
<h4 id="1-3-计算机的组成"><a href="#1-3-计算机的组成" class="headerlink" title="1.3 计算机的组成"></a>1.3 计算机的组成</h4><p><img src="https://pic.imgdb.cn/item/670f2352d29ded1a8cc44843.png" style="zoom:60%"></p>
<p>CPU是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在<strong>存储器(内存，不是外存)</strong>中存放。离开了内存，性能再好的CPU也无法工作。</p>
<ul>
<li><strong>指令和数据的表示</strong></li>
</ul>
<p>计算机中的数据和指令，存储在内存或磁盘(外存)上。数据和指令都是二进制信息。</p>
<p>问题是如何判断一串二进制数字表示的是数据还是指令呢？由CPU决定。</p>
<ul>
<li><strong>计算机中的存储单元</strong></li>
</ul>
<p>存储器被划分为多个存储单元，存储单元从0开始编号。例如：8086有20条数据线，寻址空间为$2^{20} = 1\text{MB}$。</p>
<p><img src="https://pic.imgdb.cn/item/670f2914d29ded1a8cc81537.png" alt="存储单元编号"></p>
<blockquote>
<p><strong>简单补充：寄存器、缓存、内存、硬盘、存储器的理解</strong></p>
<p><strong>寄存器内置于CPU内部</strong>，是CPU内部的小型存储区域。它们通常由多个触发器构成，可以分为内部寄存器和外部接口寄存器。而<strong>内存则位于处理器外部是独立的硬件设备</strong>。它由内存芯片、电路板、金手指等部分组成，通过数据线与CPU相连。 </p>
<p>存取速度的比较：CPU(包含寄存器，缓存)&gt;内存 &gt; 硬盘<br>内存和硬盘之间的速度，差 3~4 个数量级；寄存器和内存之间的速度也差了 3~4 个数量级。由于寄存器和内存的速度差异很大，所以现代的 CPU 往往还提供了“缓存”模块。</p>
<p><a target="_blank" rel="noopener" href="https://www.elecfans.com/d/2805654.html">寄存器和内存的区别 - 电子发烧友</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zunguitiancheng/article/details/134870059">寄存器、缓存、内存、硬盘、存储器的理解 - CSDN</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/linsc_05/article/details/136913090">硬盘、内存、缓存（CPU）和寄存器 空间大小与存取速度的区别及设计原理 - CSDN</a></p>
</blockquote>
<ul>
<li><strong>计算机中的总线(BUS)</strong></li>
</ul>
<p>在计算机中专门有连接CPU和其他芯片的导线，通常称为总线。物理上：一根根导线的集合。逻辑上课划分为：<strong>地址总线、数据总线、控制总线</strong>。</p>
<p><strong>地址总线</strong>：CPU是通过地址总线来指定存储单元的。地址总线宽度决定了可寻址的存储单元大小，即$N$根地址总线(宽度为$N$)对应寻址空间$2^N$。</p>
<p><strong>数据总线</strong>：CPU与内存或其它器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。例：向内存中写入数据89D8H时的数据传送。</p>
<p><strong>控制总线</strong>：CPU通过控制总线对外部器件进行控制。控制总线是一些不同控制线的集合控制总线宽度决定了CPU对外部器件的控制能力。</p>
<h4 id="1-4-内存的读写与地址空间"><a href="#1-4-内存的读写与地址空间" class="headerlink" title="1.4 内存的读写与地址空间"></a>1.4 内存的读写与地址空间</h4><h5 id="1-4-1-CPU对存储器的读写"><a href="#1-4-1-CPU对存储器的读写" class="headerlink" title="1.4.1 CPU对存储器的读写"></a>1.4.1 CPU对存储器的读写</h5><ul>
<li>CPU要想进行数据的读写，必须和外部器件进行三类信息的交互<ul>
<li>存储单元的地址(地址信息 )；</li>
<li>器件的选择，读或写命令(控制信息 )；</li>
<li>读或写的数据(数据信息 )；</li>
</ul>
</li>
</ul>
<p>例如：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>机器指令</th>
<th>汇编指令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>101000000000001100000000</td>
<td>MOV AL, [3]</td>
<td>从3号内存存储单元读取数据送入寄存器AL</td>
</tr>
</tbody>
</table>
</div>
<h5 id="1-4-2-内存地址空间"><a href="#1-4-2-内存地址空间" class="headerlink" title="1.4.2 内存地址空间"></a>1.4.2 内存地址空间</h5><ul>
<li>什么是内存地址空间</li>
</ul>
<p>CPU地址总线宽度为$N$，寻址空间为$2^N$个字节。8086CPU的地址总线宽度为20，那么可以寻址$1\text{MB}$个内存单元，其内<strong>存地址空间</strong>为$1\text{MB}$。</p>
<ul>
<li>从CPU角度看地址空间分配</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/670f2e7ad29ded1a8cccfcc3.png"></p>
<p><strong><font color="blue">将各类存储器看作一个逻辑存储器——进行统一编址</font></strong>，即所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。</p>
<p><img src="https://pic.imgdb.cn/item/670f2facd29ded1a8cce26b4.png" style="zoom:60%"></p>
<p>内存地址空间的分配方案——以8086PC机为例(640+128+256=1024KB = 20根地址总线)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>00000H~9FFFFH(RAM)</th>
<th>A0000H~BFFFFH(RAM)</th>
<th>C0000H~FFFFFH(ROM)</th>
</tr>
</thead>
<tbody>
<tr>
<td>主存储器地址空间 640KB</td>
<td>显存地址空间 128KB</td>
<td>各类ROM地址空间 256KB</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>RAM指的是随机存取存储器，ROM指的是只读存储器。</strong></p>
<p><strong>1、RAM：</strong></p>
<p>随机存取存储器，缩写：RAM，也叫主存，是与CPU直接交换数据的内部存储器。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。</p>
<p><strong>2、ROM：</strong></p>
<p>只读存储器以非破坏性读出方式工作，只能读出无法写入信息。其中保存的数据是在制造计算机的时候就写好的，信息一旦写入后就固定下来，即使切断电源，信息也不会丢失，所以又称为固定存储器。ROM所存数据通常是装入整机前写入的，整机工作过程中只能读出，不像随机存储器能快速方便地改写存储内容。</p>
</blockquote>
<h3 id="2-访问寄存器和内存"><a href="#2-访问寄存器和内存" class="headerlink" title="2 访问寄存器和内存"></a>2 访问寄存器和内存</h3><h4 id="2-1-寄存器以及数据存储"><a href="#2-1-寄存器以及数据存储" class="headerlink" title="2.1 寄存器以及数据存储"></a>2.1 寄存器以及数据存储</h4><p><img src="https://pic.imgdb.cn/item/670f6315d29ded1a8cf56703.png"></p>
<ul>
<li>寄存器是CPU内部的信息存储单元，以8086CPU为例，8086CPU有14个寄存器：<ul>
<li>通用寄存器：AX(AH + AL)、BX(BH + BL)、CX(CH + CL)、DX(DH + DL)</li>
<li>变址寄存器：SI、DI</li>
<li>指针寄存器：SP、BP</li>
<li>指令指针寄存器：IP</li>
<li>段寄存器：CS、SS、DS、ES</li>
<li>标志寄存器：PSW</li>
</ul>
</li>
<li>8086CPU所有的寄存器都是<strong>16位的</strong>，可以存放两个字节。</li>
</ul>
<p><strong>“字”在寄存器中的存储</strong></p>
<p>8086 CPU是16位微处理器，数据总线为16位，地址总线为20位。表明<strong>8086的字长为16bit</strong>。</p>
<p>一个字(word)可以存在一个16位寄存器中，这个字的高位字节存在这个寄存器的高8位寄存器，这个字的低位字节存在这个寄存器的低8位寄存器。</p>
<h4 id="2-2-mov和add指令"><a href="#2-2-mov和add指令" class="headerlink" title="2.2 mov和add指令"></a>2.2 mov和add指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>对应操作</th>
<th>人为描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov ax, 18</td>
<td>将18送入AX</td>
<td>AX = 18</td>
</tr>
<tr>
<td>mov ah, 78</td>
<td>将78送入AH</td>
<td>AH = 78</td>
</tr>
<tr>
<td>add ax, 8</td>
<td>将寄存器AX中的数值加上8</td>
<td>AX = AX + 8</td>
</tr>
<tr>
<td>mov ax, bx</td>
<td>将寄存器BX中的数据送入寄存器AX</td>
<td>AX = BX</td>
</tr>
<tr>
<td>add ax, bx</td>
<td>将AX,BX中的内容相加，结果存在AX中</td>
<td>AX = AX + BX</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-3-确定物理地址的方法"><a href="#2-3-确定物理地址的方法" class="headerlink" title="2.3 确定物理地址的方法"></a>2.3 确定物理地址的方法</h4><p>CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。每一个内存单元在这入空间中都有唯一的地址，这个唯一的地址称为物理地址</p>
<p>8086有20位地址总线，可传送20位地址，寻址能力为<strong><font = color="green">1M</font></strong>。但是，8086是16位结构的CPU，运算器一次最多可以处理16位的数据，寄存器的最大宽度为16位。在8086内部处理的、传输、暂存的地址也是16位，寻址能力也只有<strong>64KB</strong>。</p>
<p>问题：8086如何处理在寻址空间上的这个矛盾？<br>解决：用两个16位地址(段地址、偏移地址)合成一个20位的物理地址。</p>
<p>地址加法器合成物理地址的方法：</p>
<script type="math/tex; mode=display">
物理地址=段地址 × 16+偏移地址</script><p>段地址乘以16就相当于向右移动4位，空出的位置补0。</p>
<h4 id="2-4-内存的分段表示法"><a href="#2-4-内存的分段表示法" class="headerlink" title="2.4 内存的分段表示法"></a>2.4 内存的分段表示法</h4><p>用<strong>分段</strong>的方式管理内存，8086CPU用“(段地址x16)+偏移地址=物理地址”的方式给出内存单元的物理地址。<br>内存并没有分段，段的划分来自于CPU！！！。</p>
<ul>
<li>段地址 ×16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数。</li>
<li>偏移地址为16位，16位地址的寻址能力为64K，所以一个段的长度最大为64K。</li>
<li>同一物理地址，可以由不同的段地址和偏移地址组成。</li>
</ul>
<p>在8086PC机中存储单元地址的表示方法：例：数据在21F60H内存单元中，段地址是2000H，说法：</p>
<p>(a) 数据存在内存$\text{ 2000 : 1F60 }$单元中；<br>(b) 数据存在内存的$\text{2000H}$段中的$\text{1F60H}$单元中；</p>
<p><strong>段地址很重要 —— 用专门的寄存器存放段地址</strong>：4个段寄存器<br>CS：代码段寄存器；SS：栈段寄存器；DS：数据段寄存器；ES：附加段寄存器。</p>
<p>偏移地址可以用多种方法提供——8086丰富的取址方式。</p>
<h4 id="2-5-CS、IP与代码段"><a href="#2-5-CS、IP与代码段" class="headerlink" title="2.5 CS、IP与代码段"></a>2.5 CS、IP与代码段</h4><p>CS：代码段寄存器，IP：指令指针寄存器，<code>CS:IP</code>：CPU将内存中<code>CS:IP</code>指向的内容当作指令执行（也即CS相当于段地址，IP相当于偏移地址）。</p>
<p>执行何处的指令，取决于<code>CS:IP</code>，可以通过改变CS、IP中的内容，来控制CPU要执行的目标指令，那么如何改变CS、IP的值呢？由于<strong>8086CPU不提供对CS和IP修改的指令</strong>，因此需要使用<code>jmp</code>指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>转移指令jmp</th>
</tr>
</thead>
<tbody>
<tr>
<td>jmp 段地址:偏移地址 —— 这是同时修改CS和IP的内容</td>
</tr>
<tr>
<td>jmp 某一寄存器 —— 仅仅改变偏移地址IP中的内容</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-6-内存中字的存储"><a href="#2-6-内存中字的存储" class="headerlink" title="2.6 内存中字的存储"></a>2.6 内存中字的存储</h4><p>事实：对8086CPU而言，16位作为一个字。<br>问题：16位的字存储在一个16位的寄存器中，如何存储？<br>回答：高8位放高字节，低8位放低字节。<br>问题：16位的字在内存中需要2个连续字节存储，怎么存放？<br>回答：低位字节存在低地址单元，高位字节存在高地址单元，例：20000D(4E20H)存放在0、1两个单元，18D(0012H)存放在2、3两个单元，这两个单元怎么存储可分为：<strong>大端存储</strong> VS <strong>小端存储</strong>。</p>
<p><img src="https://pic.imgdb.cn/item/67106c78d29ded1a8cbdf3d4.png"></p>
<ul>
<li><strong>字单元</strong></li>
</ul>
<p>由两个地址连续的内存单元组成，存放一个字型数据(16位)</p>
<ul>
<li>用DS和[address]实现字的传送</li>
</ul>
<p>要解决的问题：CPU从内存单元中要读取数据<br>要求：CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址<br>原理：在8086PC中，内存地址曲段地址和偏移地址组成(段地址:偏移地址)<br>解决方案：DS和[address]配合 —— 用DS寄存器存放要访问的数据的段地址，偏移地址用[…]形式直接给出。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>汇编程序示例</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov bx, 1000H<br>mov ds, bx<br>mov al, [0]</td>
<td>将10000H(1000:0)中的数据读到al寄存器中</td>
</tr>
</tbody>
</table>
</div>
<p>8086CPU不支持将数据直接送入段寄存器（这是硬件设计的问题）。<br>套路：数据→ 通用寄存器 → 段寄存器</p>
<h4 id="2-7-DS与数据段"><a href="#2-7-DS与数据段" class="headerlink" title="2.7 DS与数据段"></a>2.7 DS与数据段</h4><p>用DS存放数据段的段地址用相关指令访问数据段中的具体单元，单元地址由[address]指出。</p>
<h4 id="2-8-栈及栈操作的实现"><a href="#2-8-栈及栈操作的实现" class="headerlink" title="2.8 栈及栈操作的实现"></a>2.8 栈及栈操作的实现</h4><p>栈是一种只能在一端进行插入或删除操作的数据结构。</p>
<p>栈有两个基本的操作：① 入栈 ② 出栈。</p>
<p>入栈：将一个新的元素放到栈顶；出栈：从栈顶取出一个元素。</p>
<p>栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。</p>
<p>栈的操作规则：<strong>LIFO(LastIn First out，后进先出)</strong>。</p>
<p>CPU提供的栈机制：现今的CPU中都有栈的设计，8086CPU提供相关的指令，支持用栈的方式访问内存空间。基于8086CPU的编程，可以将一段内存当作栈来使用。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>push ax</td>
<td>将ax中的数据送入栈中【以字(16位=2字节)为单位对栈进行操作】</td>
</tr>
<tr>
<td>pop ax</td>
<td>从栈顶取出数据送入ax【以字(16位=2字节)为单位对栈进行操作】</td>
</tr>
</tbody>
</table>
</div>
<p>问题<br>1、CPU如何知道一段内存空间被当作栈使用?<br>2、执行push和pop的时候，如何知道哪个单元是栈顶单元 ?</p>
<p>回答：<br>8086CPU中，有两个与栈相关的寄存器 —— 栈段寄存器SS存放栈顶的段地址，栈顶指针寄存器SP存放栈顶的偏移地址。</p>
<p>在汇编语言中使用栈要特别注意<strong>溢出</strong>问题：</p>
<p>8086CPU不保证对栈的操作不会超界。<br>8086CPU 只知道栈顶在何处(由SS:SP指示)，不知道程序安排的栈空间有多大。<br>程序员在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界；防止出栈时栈空了仍然继续出栈而导致的超界。</p>
<h4 id="2-9-“段”的小结"><a href="#2-9-“段”的小结" class="headerlink" title="2.9 “段”的小结"></a>2.9 “段”的小结</h4><ul>
<li><p>三种段</p>
<ul>
<li><p>数据段<br>将段地址放在DS中<br>用mov、add、sub等访问内存单元的指令时，CPU将我们定义的数据段中的内容当作数据段来访问；</p>
</li>
<li><p>代码段</p>
<p>将段地址放在CS中，将段中第一条指令的偏移地址放在IP中<br>CPU将执行我们定义的代码段中的指令;</p>
</li>
<li><p>栈段</p>
<p>将段地址放在SS中，将栈顶单元的偏移地置放在SP中<br>CPU在需要进行栈操作(push、pop)时，就将我们定义的栈段当作栈空间来用。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>CS 是代码段寄存器，DS 是数据段寄存器，ES 是附加段(Extra Segment)寄存器。附加段的意思是，它是额外赠送的礼物，当需要在程序中同时使用两个数据段时，DS 指向一个，ES 指向另一个。可以在指令中指定使用 DS 和 ES 中的哪-个，如果没有指定，则默认是使用 DS。</p>
<p>SS 是栈段寄存器。IP 是指令指针(Instruction Pointer)寄存器，它只和 CS 一起使用，而且只有处理器才能直接改变它的内容。当一段代码开始执行时，CS 指向代码段的起始地址，IP则指向段内偏移。这样，由 CS 和 IP 共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令。然后处理器会自动根据当前指令的长度来改变 IP 的值，使它指向下一条指令。</p>
</blockquote>
<h3 id="3-汇编语言程序"><a href="#3-汇编语言程序" class="headerlink" title="3 汇编语言程序"></a>3 汇编语言程序</h3><h4 id="3-1-汇编程序概况"><a href="#3-1-汇编程序概况" class="headerlink" title="3.1 汇编程序概况"></a>3.1 汇编程序概况</h4><p>汇编程序：包含汇编指冷和伪指令的文本。</p>
<p><img src="https://pic.imgdb.cn/item/67107aebd29ded1a8ccc8935.png" alt="汇编程序的组成"></p>
<p><img src="https://pic.imgdb.cn/item/67107b69d29ded1a8ccce7e1.png" alt="汇编程序中包含的三种伪指令"></p>
<p><img src="https://pic.imgdb.cn/item/67107ee8d29ded1a8ccfe440.png"></p>
<h4 id="3-2-Loop指令"><a href="#3-2-Loop指令" class="headerlink" title="3.2 Loop指令"></a>3.2 Loop指令</h4><p>功能：实现循环(计数型循环)</p>
<p>指令的格式：loop 标号</p>
<p>CPU执行loop指令时要进行的操作：① (cx)=(cx)-1； ② 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;loop指令示例程序</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,2</span><br><span class="line">	mov cx,11	; 存放循环次数</span><br><span class="line">s:	add ax ax	; s为标号，循环跳转到此处</span><br><span class="line">	1oop s</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="3-3-段前缀的使用"><a href="#3-3-段前缀的使用" class="headerlink" title="3.3 段前缀的使用"></a>3.3 段前缀的使用</h4><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov ax, 2000<br>mov ds, ax<br>mov bx, 0<br>mov al, ds:[bx]</td>
<td>这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址<br>的“ds:” “cs:” “ss:” 或 “es:”，在汇编语言中称为段前缀</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-4-在代码段中使用数据"><a href="#3-4-在代码段中使用数据" class="headerlink" title="3.4 在代码段中使用数据"></a>3.4 在代码段中使用数据</h4><p>数据不能随意地在内存中存放，这是很危险的，容易导致重要内存存放的内容被修改。</p>
<p>应用案例：编程计算以下8个数据的和，结果存在ax存器中<br>0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H<br>只要求数据本身，并未指定在哪些内存单元中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0fedH, 0cbaH, 0987H	</span><br><span class="line">		; 在代码段中定义数据</span><br><span class="line">		; dw: define word, 表示定义字型数据</span><br><span class="line">		; dw 定义一个字</span><br><span class="line">		; db 定义一个字节</span><br><span class="line">		; dd 定义一个双字</span><br><span class="line">; 前面是人为定义在代码段中的数据，因此前面这部分肯定是不能被翻译为指令，而IP默认是为0的，怎么办呢？</span><br><span class="line">; 解决方法：定义一个标号start,指示代码开始的位置。</span><br><span class="line">start:	mov bx, 0</span><br><span class="line">	mov ax, 0</span><br><span class="line">	mov cx, 8</span><br><span class="line">s: 	add ax,cs:[bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start	; end的作用:除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。</span><br></pre></td></tr></table></figure>
<h4 id="3-5-在代码段中使用栈"><a href="#3-5-在代码段中使用栈" class="headerlink" title="3.5 在代码段中使用栈"></a>3.5 在代码段中使用栈</h4><p>问题：利用栈，将程序中定义的数据逆序存放。</p>
<p>程序的思路大致如下：<br>程序运行时，定义的数据存放在cs:0-cs:8单元中，共8个字单元。依次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆序存放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0.0,0,0,0</span><br><span class="line">	</span><br><span class="line">start:	</span><br><span class="line">	; 设置栈地址和指针 </span><br><span class="line">	mov ax,cs</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,30h</span><br><span class="line">	;入栈</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,8</span><br><span class="line">s0:	push cs:[bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s0</span><br><span class="line">	;出栈</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,8</span><br><span class="line">s1: pop cs:[bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s1</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h4 id="3-6-将数据、代码、栈放入不同段"><a href="#3-6-将数据、代码、栈放入不同段" class="headerlink" title="3.6 将数据、代码、栈放入不同段"></a>3.6 将数据、代码、栈放入不同段</h4><ul>
<li><p>上面这个将数据逆序存放的程序有如下特点和缺陷：</p>
<ul>
<li><p>特点：数据、栈和代码都在一个段。</p>
</li>
<li><p>问题：程序显得混乱，编程和阅读时都要注意何处是数据，何处是栈，何处是代码。</p>
<p>只适合应用于要处理的数据很少，用到的栈空间也小，加上没有多长的代码。</p>
</li>
</ul>
</li>
</ul>
<p>处理方法：数据段、代码段、栈端分开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line">; 数据段</span><br><span class="line">data segment</span><br><span class="line">	dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">data ends</span><br><span class="line">; 栈段</span><br><span class="line">stack segment</span><br><span class="line">	dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">stack ends</span><br><span class="line">; 代码段</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	; 初始化各段寄存器</span><br><span class="line">	; 注意：cs代码段不用手动初始化，编译器自动完成代码段的初始化</span><br><span class="line">	mov ax, stack</span><br><span class="line">	mov ss, ax</span><br><span class="line">	mov sp, 20h</span><br><span class="line">	mov ax, data</span><br><span class="line">	mov ds, ax</span><br><span class="line">	;入栈</span><br><span class="line">	mov bx, 0</span><br><span class="line">	mov cx, 8</span><br><span class="line">s0:	push cs:[bx]</span><br><span class="line">	add bx, 2</span><br><span class="line">	loop s0</span><br><span class="line">	;出栈</span><br><span class="line">	mov bx, 0</span><br><span class="line">	mov cx, 8</span><br><span class="line">s1: pop cs:[bx]</span><br><span class="line">	add bx, 2</span><br><span class="line">	loop s1</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>程序段前缀PSP</strong></li>
</ul>
<p>程序段前缀PSP(Pogram segment Prefix)是DOS 加载一个外部命令或应用程序(EXE、COM类型)时，在该程序段之前自动设置的一个具有256(100H)个字节的信息区域。</p>
<p><strong>当 DOS 把控制权转交给外部命令或应用程序时，数据段寄存器DS和附加段寄存器ES首先被设置为指向程序段前缀，即与PSP含有相同的段值，而不是一开始就指向程序的数据段和附加段。堆栈段寄存器SS和代码段寄存器CS的段地址要比 DS 和 ES 高/大0100H。</strong></p>
<p>PSP 含有许多的可用信息，其中偏移地址000H~007FH 范围为格式化区域，即加载程序时自动设置的各种信息区域；0080H~00FFH 区域为PSP的非格式化区域，即用来存储被加载程序的输入参数(DOS 加载一个外部命令或应用程序时，允许在被加载的程序名之后输入包括回车符在内的最多127个字符参数)。其中偏移地址0000H~0001H 内容为程序终止退出命令INT20H，0080H单元存储命令行参数的长度(字节数)，由0081H地址开始存储命令行参数，如无命令行参数则为0。</p>
<blockquote>
<p>当一个<code>.EXE</code>可执行文件加载到内存时，内存会被划分为几个区域：程序段前缀（PSP）、用户数据区、用户堆栈区以及用户代码段。PSP区域包含了关于可执行文件的控制信息，其开头的<code>INT 20H</code>指令用于结束程序。程序的执行通常始于将<code>DS</code>和<code>ES</code>段寄存器设置为PSP的地址，并在程序结束时使用<code>RET</code>指令将控制权转回DOS。   <a target="_blank" rel="noopener" href="https://download.csdn.net/download/qq_37174420/29651038?utm_medium=distribute.pc_relevant_download.none-task-download-2~default~OPENSEARCH~Rate-8-29651038-download-4203060.257%5Ev16%5Epc_dl_relevant_base1_b&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-download-2~default~OPENSEARCH~Rate-8-29651038-download-4203060.257%5Ev16%5Epc_dl_relevant_base1_b&amp;spm=1003.2020.3001.6616.10">链接</a></p>
</blockquote>
<h3 id="4-内存寻址方式"><a href="#4-内存寻址方式" class="headerlink" title="4. 内存寻址方式"></a>4. 内存寻址方式</h3><h4 id="4-1-处理字符问题"><a href="#4-1-处理字符问题" class="headerlink" title="4.1 处理字符问题"></a>4.1 处理字符问题</h4><p>汇编程序中，用<code>&#39;...&#39;</code>的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的ASCII码.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data</span><br><span class="line">; 数据段</span><br><span class="line">data segment</span><br><span class="line">	db &#x27;unIx&#x27;</span><br><span class="line">	db &#x27;foRk&#x27;</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov al, &#x27;a&#x27;</span><br><span class="line">	mov bl, &#x27;b&#x27;</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h4 id="4-2-bx-idata-方式寻址"><a href="#4-2-bx-idata-方式寻址" class="headerlink" title="4.2 [bx+idata]方式寻址"></a>4.2 [bx+idata]方式寻址</h4><p><code>[bx+idata]</code>表示一个内存单元，它的偏移地址为<code>(bx)+idata</code>（即bx中的数值加上idata）。</p>
<p>mov ax, [bx+200] / mov ax, [200+bx]的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，内存单元的段地址在ds中，偏移地址为200加上bx中的数值。</p>
<h4 id="4-3-SI和DI寄存器"><a href="#4-3-SI和DI寄存器" class="headerlink" title="4.3 SI和DI寄存器"></a>4.3 SI和DI寄存器</h4><p>首先，简单回顾一下CPU内部的寄存器</p>
<ul>
<li>8086CPU有14个寄存器<ul>
<li>通用寄存器：AX、BX、CX、DX</li>
<li>变址寄存器：SI、DI</li>
<li>指针寄存器：SP、BP</li>
<li>指令指针寄存器：IP</li>
<li>段寄存器：CS、SS、DS、ES</li>
<li>标志寄存器：PSW</li>
</ul>
</li>
</ul>
<p><strong>Sl和DI常执行与地址有关的操作</strong>：SI和DI是8086CPU中和Bx功能相近的寄存器；区别在于SI和DI不能够分成两个8位寄存器来使用。</p>
<blockquote>
<p>BX：通用寄存器，在计算存储器地址时，常作为基址寄存器用。<br>Sl(source index)：源变址寄存器。<br>Dl(destination index)：目标变址寄存器。</p>
</blockquote>
<p>下面的三组指令实现了相同的功能</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令1</th>
<th>指令2</th>
<th>指令3</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov bx, 0<br>mov ax, [bx]</td>
<td>mov si, 0<br>mov ax, [si]</td>
<td>mov di, 0<br>mov ax, [di]</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>[bx+si]和[bx+di]方式寻址</strong></li>
</ul>
<p>指令<code>mov [bx+si]</code>的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在ds中。</p>
<ul>
<li><strong>[bx+si+idata]和[bx+di+idata]方式寻址</strong></li>
</ul>
<p>指令<code>mov [bx+si+idata]</code>的含义：将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中。</p>
<p><img src="https://pic.imgdb.cn/item/6711ce83d29ded1a8c18899f.png" alt="对内存的寻址方式小结"></p>
<h4 id="4-4-用于内存寻址的寄存器"><a href="#4-4-用于内存寻址的寄存器" class="headerlink" title="4.4 用于内存寻址的寄存器"></a>4.4 用于内存寻址的寄存器</h4><p>只有bx、bp、si、di可以用在[…]对内存单元寻址，通用寄存器除了bx，其他(ax、cx、dx)都不可用于寻址。</p>
<p><strong>bx、bp区别：</strong>bx默认指ds段，bp默认指ss段。</p>
<h4 id="4-5-汇编语言中数据位置的表达"><a href="#4-5-汇编语言中数据位置的表达" class="headerlink" title="4.5 汇编语言中数据位置的表达"></a>4.5 汇编语言中数据位置的表达</h4><p><img src="https://pic.imgdb.cn/item/6711f7aed29ded1a8c53fc0f.png" alt="汇编语言中数据位置的表达"></p>
<p><img src="https://pic.imgdb.cn/item/6711f874d29ded1a8c54a5ab.png" alt="指令要处理的数据有多长"></p>
<h4 id="4-6-用div指令实现除法"><a href="#4-6-用div指令实现除法" class="headerlink" title="4.6 用div指令实现除法"></a>4.6 用div指令实现除法</h4><ul>
<li><code>div</code>是除法指令，使用div作除法的时候<ul>
<li>被除数：默认放在AX 或 DX和AX中</li>
<li>除数：8位或16位，在寄存器或内存单元中</li>
<li>结果：……</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>被除数</th>
<th>除数</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody>
<tr>
<td>AX</td>
<td>8位内存或寄存器</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr>
<td>AX和DX</td>
<td>16位内存或寄存器</td>
<td>AX</td>
<td>DX</td>
</tr>
</tbody>
</table>
</div>
<p>切记提前在默认的寄存器中设置好被除数，且默认寄存器不作别的用处。</p>
<h4 id="4-7-用dup设置内存空间"><a href="#4-7-用dup设置内存空间" class="headerlink" title="4.7 用dup设置内存空间"></a>4.7 用dup设置内存空间</h4><p>功能：dup和db、dw、dd 等数据定义伪指令配合使用，用来进行数据的重复。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
<th>相当于</th>
</tr>
</thead>
<tbody>
<tr>
<td>db 3 dup (0)</td>
<td>定义了3个字节，它们的值都是0</td>
<td>db 0,0,0</td>
</tr>
<tr>
<td>db 3 dup (0,1,2)</td>
<td>定义了9个字节，由0、1、2重复3次构成</td>
<td>db 0,1,2,0,1,2,0,1,2</td>
</tr>
<tr>
<td>db 3 dup (‘abc’,ABC’)</td>
<td>定义了18个字节，构成’abcABCabcABCabcABC</td>
<td>db ‘abcABCabcABCabcABC’</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-流程转移与子程序"><a href="#5-流程转移与子程序" class="headerlink" title="5. 流程转移与子程序"></a>5. 流程转移与子程序</h3><h4 id="5-1-转移综述"><a href="#5-1-转移综述" class="headerlink" title="5.1 转移综述"></a>5.1 转移综述</h4><ul>
<li>背景：一般情况下指令是顺序地逐条执行的，而在实际中，常需要改变程序的执行流程</li>
<li>转移指令<ul>
<li>可以控制CPU执行内存中某处代码的指令</li>
<li>可以修改IP，或同时修改CS和IP的指令</li>
</ul>
</li>
</ul>
<p><strong>转移指令的分类</strong></p>
<p><img src="https://pic.imgdb.cn/item/671203ded29ded1a8c65f09c.png" alt="转移指令的分类"></p>
<h4 id="5-2-操作符offset"><a href="#5-2-操作符offset" class="headerlink" title="5.2 操作符offset"></a>5.2 操作符offset</h4><p>用操作符offset取得标号的<strong>偏移地址</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; offset的使用：offset 标号</span><br><span class="line">assume cs:codeseg</span><br><span class="line"></span><br><span class="line">codeseg segment</span><br><span class="line">start:	mov ax,offset start	; 相当于mov ax,0</span><br><span class="line">    s:	mov ax,offset s	; 相当于mov ax,3</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h4 id="5-3-jmp指令——无条件转移"><a href="#5-3-jmp指令——无条件转移" class="headerlink" title="5.3 jmp指令——无条件转移"></a>5.3 jmp指令——无条件转移</h4><p>jmp指令的功能：无条件转移，可以只修改IP，也可以同时修改CS和IP。</p>
<ul>
<li>jmp指令要给出两种信息<ul>
<li>① 转移的目的地址；</li>
<li>② 转移的距离<ul>
<li>段间转移(远转移)：<code>jmp 2000:1000</code></li>
<li>段内短转移：<code>jmp short 标号</code>，IP的修改范围为 -128到127，8位的位移</li>
<li>段内近转移：<code>jmp near ptr 标号</code>，IP的修改范围为-32768到32767，16位的位移</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/67120bd4d29ded1a8c73d25d.png" alt="image.png"></p>
<ul>
<li><p><strong>转移地址在寄存器中的jmp指令</strong></p>
<ul>
<li>指令格式：jmp 16位寄存器</li>
<li>功能：IP=(16位寄存器)</li>
<li>举例：jmp ax；jmp bx</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/67121ce2d29ded1a8c8eb5ab.png"></p>
<h4 id="5-4-其他转移指令"><a href="#5-4-其他转移指令" class="headerlink" title="5.4 其他转移指令"></a>5.4 其他转移指令</h4><h5 id="5-4-1-jcxz指令"><a href="#5-4-1-jcxz指令" class="headerlink" title="5.4.1 jcxz指令"></a>5.4.1 jcxz指令</h5><p>指令格式：<code>jcxz 标号</code><br>功能：如果(cx)=0，则转移到标号处执行；若(cx)≠0，什么也不做(程序向下执行 )</p>
<p>jcxz是有<strong>条件转移指令</strong>，所有的有条件转移指令都是短转移，即对IP的修改范围都为-128~127。在对应的机器码中包含转移的位移，而不是目的地址。</p>
<h5 id="5-4-2-loop指令"><a href="#5-4-2-loop指令" class="headerlink" title="5.4.2 loop指令"></a>5.4.2 loop指令</h5><p>指令格式：<code>loop 标号</code><br>功能：循环，如果(cx)=0，跳出循环，；若(cx)≠0，则cx = cx-1，则转移到标号处执行。</p>
<h4 id="5-5-call指令和ret指令"><a href="#5-5-call指令和ret指令" class="headerlink" title="5.5 call指令和ret指令"></a>5.5 call指令和ret指令</h4><p>调用子程序：cal指令<br>返回：ret指令<br>实质：流程转移指令，它们都修改P，或同时修改CS和IP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 0</span><br><span class="line">call s</span><br><span class="line">mov ax, 4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">s:	add ax, 0</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p><strong>（一）call指令介绍</strong></p>
<ul>
<li>CPU执行cal指令，进行两步操作<ul>
<li>(1) 将当前的IP或 CS和IP 压入栈中；</li>
<li>(2) 转移到标号处执行指令。</li>
</ul>
</li>
<li><code>call 标号</code><ul>
<li>16位位移 = “标号”处的地址-cal指令后的第一个字节的地址</li>
<li>16位位移的范围为-32768~32767，用补码表示</li>
<li>16位位移由编译程序在编译时算出。</li>
</ul>
</li>
<li>指令<code>call far ptr 标号</code>实现的是<strong>段间转移</strong><ul>
<li>(CS)=标号所在的段地址</li>
<li>(IP)=标号所在的偏移地址</li>
<li>该条指令相当于<ul>
<li>push CS → push lP → jmp far ptr 标号</li>
</ul>
</li>
</ul>
</li>
<li>转移地址在<strong>寄存器</strong>中的call指令<ul>
<li>显指令格式：<code>call 16位寄存器</code></li>
</ul>
</li>
<li>转移地址在<strong>内存</strong>中的call指令<ul>
<li><code>call word ptr 内存单元地址</code><ul>
<li>相当于：push IP → jmp word ptr 内存单元地址</li>
</ul>
</li>
<li><code>call dword ptr 内存单元地址</code><ul>
<li>相当于：push CS → push lP → jmp dword ptr 内存单元地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>（二）ret指令介绍</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>ret指令</th>
<th>retf指令</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>功能</strong></td>
<td>用栈中的数据修改IP的内容，从而实现近转移</td>
<td>用栈中的数据，修改CS和IP的内容，从而实现远转移</td>
</tr>
<tr>
<td><strong>相当于</strong></td>
<td>pop IP</td>
<td>pop IP; pop CS</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://pic.imgdb.cn/item/67131884d29ded1a8ce11dc3.png" style="zoom:60%"></p>
<p>此外，<code>ret</code>指令后面还可以<strong>直接跟数字</strong>，其作用相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret n ⇿ pop IP</span><br><span class="line">		add sp, n</span><br></pre></td></tr></table></figure>
<h4 id="5-6-mul乘法指令"><a href="#5-6-mul乘法指令" class="headerlink" title="5.6 mul乘法指令"></a>5.6 mul乘法指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>8位乘法</strong></th>
<th><strong>16位乘法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>被乘数(默认)</strong></td>
<td>AL</td>
<td>AX</td>
</tr>
<tr>
<td><strong>乘数</strong></td>
<td>8位寄存器或内存字节单元</td>
<td>16位寄存器或内存字单元</td>
</tr>
<tr>
<td><strong>结果</strong></td>
<td>AX</td>
<td>DX(高位)和AX(低位)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="5-7-标志寄存器PSW-FLAGS"><a href="#5-7-标志寄存器PSW-FLAGS" class="headerlink" title="5.7 标志寄存器PSW/FLAGS"></a>5.7 标志寄存器PSW/FLAGS</h4><h5 id="5-7-1-认识标志寄存器的特殊之处"><a href="#5-7-1-认识标志寄存器的特殊之处" class="headerlink" title="5.7.1 认识标志寄存器的特殊之处"></a>5.7.1 认识标志寄存器的特殊之处</h5><p>标志寄存器flag的结构：</p>
<p>flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p>
<p>8086CPU中标志寄存器flag是16位的，其中没有使用flag的1、3、5、12、13、14、15位，这些位不具有任何含义。</p>
<p><img src="https://pic.imgdb.cn/item/67134d48d29ded1a8c2cbdcc.png" style="zoom:50%"></p>
<h5 id="5-7-2-直接访问标志寄存器的方法"><a href="#5-7-2-直接访问标志寄存器的方法" class="headerlink" title="5.7.2 直接访问标志寄存器的方法"></a>5.7.2 直接访问标志寄存器的方法</h5><p><code>pushf</code>：将标志寄存器的值压栈；</p>
<p><code>popf</code>：从栈中弹出数据，送入标志寄存器中。</p>
<h5 id="5-7-3-ZF-零标志-Zero-Flag"><a href="#5-7-3-ZF-零标志-Zero-Flag" class="headerlink" title="5.7.3 ZF-零标志(Zero Flag)"></a>5.7.3 ZF-零标志(Zero Flag)</h5><ul>
<li>ZF标记相关指令的计算结果是否为0<ul>
<li>ZF=1，表示“结果是0”，1表示“逻辑真”</li>
<li>ZF=0，表示“结果不是0”，0表示“逻辑假“</li>
</ul>
</li>
</ul>
<p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：add、sub、mul、div、inc、or、and等，它们大都是运算指令，进行逻辑或算术运算；</p>
<p>有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，它们大都是传送指令。</p>
<p>使用一条指令的时候，要注意这条指令的全部功能其中包括执行结果对标记寄存器的哪些标志位造成影响。</p>
<h5 id="5-7-4-PF-奇偶标志-Parity-Flag"><a href="#5-7-4-PF-奇偶标志-Parity-Flag" class="headerlink" title="5.7.4 PF-奇偶标志(Parity Flag)"></a>5.7.4 PF-奇偶标志(Parity Flag)</h5><ul>
<li>PF记录指令执行后，结果的所有二进制位中1的个数：<ul>
<li>1的个数为偶数，PF=1</li>
<li>1的个数为奇数，PF=0。</li>
</ul>
</li>
</ul>
<h5 id="5-7-5-SF-符号标志-Sign-Flag"><a href="#5-7-5-SF-符号标志-Sign-Flag" class="headerlink" title="5.7.5 SF-符号标志(Sign Flag)"></a>5.7.5 SF-符号标志(Sign Flag)</h5><ul>
<li>SF记录指令执行后，将结果视为有符号数<ul>
<li>结果为负，SF=1</li>
<li>结果为非负，SF=0</li>
</ul>
</li>
</ul>
<h5 id="5-7-6-CF-进位标志-Carry-Flag"><a href="#5-7-6-CF-进位标志-Carry-Flag" class="headerlink" title="5.7.6 CF-进位标志(Carry Flag)"></a>5.7.6 CF-进位标志(Carry Flag)</h5><p>在进行<strong>无符号数运算</strong>的时候，CF记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p>
<ul>
<li>CF记录指令执行后<ul>
<li>有进位或借位，CF = 1</li>
<li>无进位或借位，CF = 0</li>
</ul>
</li>
</ul>
<h5 id="5-7-7-OF-溢出标志-Overflow-Flag"><a href="#5-7-7-OF-溢出标志-Overflow-Flag" class="headerlink" title="5.7.7 OF-溢出标志(Overflow Flag)"></a>5.7.7 OF-溢出标志(Overflow Flag)</h5><p>在进行<strong>有符号数运算</strong>的时候，如结果超过了机器所能表示的范围称为溢出</p>
<ul>
<li>OF记录有符号数操作指令执行后<ul>
<li>有溢出，OF=1</li>
<li>无溢出，OF=0</li>
</ul>
</li>
</ul>
<h4 id="5-8-带进-借-位的加减法"><a href="#5-8-带进-借-位的加减法" class="headerlink" title="5.8 带进(借)位的加减法"></a>5.8 带进(借)位的加减法</h4><h5 id="5-8-1-adc带进位加法指令"><a href="#5-8-1-adc带进位加法指令" class="headerlink" title="5.8.1 adc带进位加法指令"></a>5.8.1 adc带进位加法指令</h5><ul>
<li>adc是带进位加法指令，它利用了CF位上记录的进位值。<ul>
<li>格式：adc 操作对象1, 操作对象2</li>
<li>功能：操作对象1= 操作对象1+操作对象2+CF</li>
</ul>
</li>
</ul>
<h5 id="5-8-2-sbb带借位减法指令"><a href="#5-8-2-sbb带借位减法指令" class="headerlink" title="5.8.2 sbb带借位减法指令"></a>5.8.2 sbb带借位减法指令</h5><ul>
<li>格式：sbb 操作对象1, 操作对象2<ul>
<li>功能：操作对象1=操作对象1-操作对象2-CF</li>
<li>与sub区别：利用CF位上记录的借位值 </li>
</ul>
</li>
</ul>
<h4 id="5-9-cmp与条件转移指令"><a href="#5-9-cmp与条件转移指令" class="headerlink" title="5.9 cmp与条件转移指令"></a>5.9 cmp与条件转移指令</h4><h5 id="5-9-1-cmp指令"><a href="#5-9-1-cmp指令" class="headerlink" title="5.9.1 cmp指令"></a>5.9.1 cmp指令</h5><ul>
<li>cmp是比较指令，功能相当于减法指令，但不保存结果。cmp指令执行后，将<strong>对标志寄存器产生影响</strong>。<ul>
<li>格式：cmp 操作对象1,操作对象2</li>
<li>功能：计算 操作对象1-操作对象2</li>
</ul>
</li>
</ul>
<h5 id="5-9-2-条件转移指令jxxx"><a href="#5-9-2-条件转移指令jxxx" class="headerlink" title="5.9.2 条件转移指令jxxx"></a>5.9.2 条件转移指令jxxx</h5><p>格式：<code>jxxx 标号</code></p>
<p><img src="https://pic.imgdb.cn/item/67135b0dd29ded1a8c3f3a55.png" alt="根据单个标志位转移的指令" style="zoom:60%"></p>
<p><img src="https://pic.imgdb.cn/item/67135bd5d29ded1a8c411805.png" alt="根据无符号数比较结果进行转移的指令" style="zoom:60%"></p>
<p><img src="https://pic.imgdb.cn/item/67135c3fd29ded1a8c420f98.png" alt="根据有符号数比较结果进行转移的指令" style="zoom:60%"></p>
<p><strong>条件转移指令通常都和cmp相配合使用，cmp指令改变标志位，jxxx根据相应的标志寄存器判断是否跳转。</strong></p>
<h4 id="5-10-DF标志和串传送指令"><a href="#5-10-DF标志和串传送指令" class="headerlink" title="5.10 DF标志和串传送指令"></a>5.10 DF标志和串传送指令</h4><h5 id="5-10-1-DF-方向标志位-Direction-Flag"><a href="#5-10-1-DF-方向标志位-Direction-Flag" class="headerlink" title="5.10.1 DF-方向标志位(Direction Flag)"></a>5.10.1 DF-方向标志位(Direction Flag)</h5><ul>
<li>功能：在串处理指令中，控制每次操作后si，di的增减。<ul>
<li>DF=0：每次操作后si，di递增；</li>
<li>DF=1：每次操作后si，di递减。</li>
</ul>
</li>
<li>对DF位进行设置的指令<ul>
<li><code>cld指令</code>：将标志寄存器的DF位设为0(clear)</li>
<li><code>std指令</code>：将标志寄存器的DF位设为1(setup)</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/671369dbd29ded1a8c58d454.png" style="zoom:50%"></p>
<h5 id="5-10-2-rep指令"><a href="#5-10-2-rep指令" class="headerlink" title="5.10.2 rep指令"></a>5.10.2 rep指令</h5><ul>
<li>rep指令常和串传送指令搭配使用<ul>
<li>功能：根据cx的值，重复执行后面的指令</li>
<li>例如：<code>rep movsb</code></li>
<li>等价于：<br>wjh：movsb<br>loop wjh </li>
</ul>
</li>
</ul>
<p>补充：<code>movsb</code>字节传送指令</p>
<p>格式：movsb<br>功能：执行movsb指令相当于进行下面几步操作:<br>（1）((es)×16+(di))=((ds)×16+(si))</p>
<p>（2） 如果<code>df=0</code>则：(si)=(si)+1，(di)=(di)+1；如果<code>df=1</code>则：(si)=(si)-1，(di)=(di)-1</p>
<h3 id="6-中断及外部设备操作"><a href="#6-中断及外部设备操作" class="headerlink" title="6. 中断及外部设备操作"></a>6. 中断及外部设备操作</h3><h4 id="6-1-移位指令"><a href="#6-1-移位指令" class="headerlink" title="6.1 移位指令"></a>6.1 移位指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>移位指令</th>
<th>示例代码</th>
<th>释义</th>
<th>是否影响CF位</th>
</tr>
</thead>
<tbody>
<tr>
<td>逻辑左移<br>SHL OPR,CNT</td>
<td>mov al,01001000b<br>shl al,1</td>
<td>二进制数字向左移动一位，<br>末尾补0，移出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>循环左移<br>ROL OPR, CNT</td>
<td>mov al,01001000b<br>rol al,1</td>
<td>二进制数字向左移动一位，<br>然后补到末尾，移出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>逻辑右移<br>SHR OPR,CNT</td>
<td>mov al,01001000b<br>shr al,1</td>
<td>二进制数字向右移动一位，<br>开头补0，移出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>循环右移<br>ROR OPR,CNT</td>
<td>mov al,01001000b<br>ror al,1</td>
<td>二进制数字向右移动一位，<br>然后补到开头，移出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>算术左移<br>SAL OPR,CNT</td>
<td>mov al,01001000b<br>sal al,1</td>
<td>二进制数字向左移动一位，<br>末尾补0，移出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>算术右移<br>SAR OPR,CNT</td>
<td>mov al,01001000b<br>sar al,1</td>
<td>二进制数字向右移动一位，<br>但是开头一位保持不变，移<br>出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>带进位循环左移<br>RCL OPR,CNT</td>
<td>mov al,01001000b<br>rcl al,1</td>
<td>二进制数字向左移动一位，<br>原CF中的数值回到末尾，移<br>出的一位进到CF中</td>
<td>是</td>
</tr>
<tr>
<td>带进位循环右移<br>RCR OPR,CNT</td>
<td>mov al,01001000b<br>rcr al,1</td>
<td>二进制数字向右移动一位，<br>原CF中的数值回到开头，移<br>出的一位进到CF中</td>
<td>是</td>
</tr>
</tbody>
</table>
</div>
<p>注意①：当移动的位数大于1时，必须使用cl寄存器中转移动的位数。</p>
<p>注意②：逻辑左移相当于乘以2，逻辑右移相当于除以2。</p>
<h4 id="6-2-操作显存数据"><a href="#6-2-操作显存数据" class="headerlink" title="6.2 操作显存数据"></a>6.2 操作显存数据</h4><p><strong>屏慕上的内容=显存中的数据</strong></p>
<p>根据前面的图可知，8086CPU的显存地址空间位于：A0000到BFFFF区间。其中B8000h~BFFFFh共32K的空间，是8*25 彩色字符模式第0页的显示缓冲区。</p>
<blockquote>
<p>B8000h~BFFFFh共32K的空间的简单解释</p>
<p><code>BFFFFh-B8000h = 7FFFH = 8000H → 2^3*2^12 = 2^3*2^2*2^10 = 32*1Kb</code></p>
</blockquote>
<p><img src="https://pic.imgdb.cn/item/6715ae36d29ded1a8c32e3ab.png" alt="显示缓冲区结构"></p>
<blockquote>
<p>‌<strong>在显存中，一个字符确实占两个字节。</strong>‌ 在80*25彩色字符模式下，每个字符由两个字节组成，一个字节存储字符的ASCII码，另一个字节存储字符的属性（如背景色、前景色等）‌。</p>
<p>在显存中，每个字符占用两个字节的原因是因为：</p>
<ul>
<li>‌<strong>字符的ASCII码</strong>‌：一个字节(低位)用于存储字符的ASCII码，表示字符本身。</li>
<li>‌<strong>字符的属性</strong>‌：另一个字节(高位)用于存储字符的属性，如背景色、前景色、闪烁、高亮等。</li>
</ul>
<p>这种设计使得每个字符不仅可以显示出来，还可以通过属性字节来控制其显示效果。</p>
</blockquote>
<p>例：编程序，在屏幕的中间，自底蓝字，显示Welcome to masm!</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codeseg, ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;welcome to masm!&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codeseg segment</span><br><span class="line">start:</span><br><span class="line">	; 初始化寄存器</span><br><span class="line">	mov ax, datasg</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov ax, 0B800H</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov si, 0</span><br><span class="line">	mov di, 160*12+80-16</span><br><span class="line">	; 显示字符串</span><br><span class="line">	mov cx,16</span><br><span class="line">w:  mov al, [si]</span><br><span class="line">	mov es:[di], al</span><br><span class="line">	inc di</span><br><span class="line">	mov al, 71H</span><br><span class="line">	mov es:[di], al</span><br><span class="line">	inc si</span><br><span class="line">	inc di</span><br><span class="line">	loop w</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h4 id="6-3-描述内存单元的标号"><a href="#6-3-描述内存单元的标号" class="headerlink" title="6.3 描述内存单元的标号"></a>6.3 描述内存单元的标号</h4><h5 id="6-3-1-关于标号"><a href="#6-3-1-关于标号" class="headerlink" title="6.3.1 关于标号"></a>6.3.1 关于标号</h5><p>代码段中的标号可以用来标记指令、段的起始地址。</p>
<p>代码段中的数据也可以用标号。</p>
<h5 id="6-3-2-数据标号——去了冒号的数据标号"><a href="#6-3-2-数据标号——去了冒号的数据标号" class="headerlink" title="6.3.2 数据标号——去了冒号的数据标号"></a>6.3.2 数据标号——去了冒号的数据标号</h5><p>数据标号标记了存储数据的单元的地址和长度<br>数据标号不同于仅仅表示地址的地址标号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	;数据标号a、b前面不加:，注意这段数据定义在数据段也是可以这样用的</span><br><span class="line">	a db 1 2,3,4 5,6,7,8	</span><br><span class="line">	b dw 0</span><br><span class="line">start : mov si,0</span><br><span class="line">	mov cx,8</span><br><span class="line">s: 	mov al,a[si]	;相当于[si+a]</span><br><span class="line">	mov ah,0</span><br><span class="line">	add b,ax</span><br><span class="line">	inc si</span><br><span class="line">	loop s</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h5 id="6-3-3-扩展用法：二级指针：将标号当作数据来定义"><a href="#6-3-3-扩展用法：二级指针：将标号当作数据来定义" class="headerlink" title="6.3.3 扩展用法：二级指针：将标号当作数据来定义"></a>6.3.3 扩展用法：二级指针：将标号当作数据来定义</h5><p><img src="https://pic.imgdb.cn/item/6715b66dd29ded1a8c43abce.png"></p>
<h4 id="6-4-直接定址表"><a href="#6-4-直接定址表" class="headerlink" title="6.4 直接定址表"></a>6.4 直接定址表</h4><h5 id="6-4-1-数据的直接定址表"><a href="#6-4-1-数据的直接定址表" class="headerlink" title="6.4.1 数据的直接定址表"></a>6.4.1 数据的直接定址表</h5><p>直接定址表：用查表的方法解决问题。</p>
<p>有如下问题：以十六进制的形式在屏幕中间显示给定的byte型数据。</p>
<p>新方按：建立一张表，表中依次存储字符“0” ~ “F”，我们可以通过数值0~15直接查找到对应的字符<br><code>table db &#39;0123456789ABCDEF&#39; ;字符表</code></p>
<h5 id="6-4-2-代码的直接定址表"><a href="#6-4-2-代码的直接定址表" class="headerlink" title="6.4.2 代码的直接定址表"></a>6.4.2 代码的直接定址表</h5><p><strong><font color="red">函数指针数组</font></strong>，示例如下</p>
<p><img src="https://pic.imgdb.cn/item/6715c067d29ded1a8c5b45ec.png"></p>
<h4 id="6-5-中断及其处理"><a href="#6-5-中断及其处理" class="headerlink" title="6.5 中断及其处理"></a>6.5 中断及其处理</h4><h5 id="6-5-1-中断的概念"><a href="#6-5-1-中断的概念" class="headerlink" title="6.5.1 中断的概念"></a>6.5.1 中断的概念</h5><p>中断：CPU不再接着(刚执行完的指令)向下执行，而是转去处理中断信息</p>
<p>内中断：由CPU内部发生的事件而引起的中断</p>
<p>外中断：由外部设备发生的事件引起的中断</p>
<p><img src="https://pic.imgdb.cn/item/6715c75bd29ded1a8c6a63ec.png"></p>
<h5 id="6-5-2-8086的内中断"><a href="#6-5-2-8086的内中断" class="headerlink" title="6.5.2 8086的内中断"></a>6.5.2 8086的内中断</h5><ul>
<li>CPU内部产生的中断信息<ul>
<li>(1) 除法错误，比如:执行div指令产生的除法溢出</li>
<li>(2) 单步执行</li>
<li>(3) 执行<code>into 指令</code></li>
<li>(4) 执行<code>int 指令</code></li>
</ul>
</li>
<li>8086的中断类型码<ul>
<li>(1) 除法错误：0</li>
<li>(2) 单步执行：1</li>
<li>(3) 执行into指令：4</li>
<li>(4) 执行 int n指令，立即数n为中断类型码</li>
</ul>
</li>
<li>中断处理程序<ul>
<li>CPU接到中断信息怎么办?<ul>
<li>执行中断处理程序</li>
</ul>
</li>
<li>中断处理程序在哪里 ?<ul>
<li>中断信息和其处理程序的入口地址之间有某种联系，CPU根据中断信息可以找到要执行的处理程序。</li>
</ul>
</li>
<li>中断向量表<ul>
<li>由中断类型码查表得到中断处理程序的入口地址，从而定位中断处理程序。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6715c9bbd29ded1a8c6fce83.png" style="zoom:50%"></p>
<ul>
<li>中断过程<ul>
<li>中断过程由CPU的硬件自动完成</li>
<li>用中断类型码找到中断向量，并用它设置CS和IP</li>
</ul>
</li>
<li>8086CPU的中断过程<ul>
<li>(1) 从中断信息中取得中断类型码</li>
<li>(2) 标志寄存器的值入栈——中断过程中要改变标志寄存器的值，需要先行保护</li>
<li>(3) 设置标志寄存器的第8位TF和第9位IF的值为0</li>
<li>(4) CS寄存器的内容入栈</li>
<li>(5) IP寄存器的内容入栈</li>
<li>(6) 从中断向量表读取中断处理程序的入口地址，设置IP和CS。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6715f000d29ded1a8cb9b64d.png" style="zoom:60%"></p>
<h4 id="6-6-中断处理程序及其结构"><a href="#6-6-中断处理程序及其结构" class="headerlink" title="6.6 中断处理程序及其结构"></a>6.6 中断处理程序及其结构</h4><p>CPU随时都可能检测到中断信息，所以中断处理程序必须常驻内存(一直存储在内存某段空间之中)。<br>中断处理程序的入口地址，即<strong>中断向量</strong>，必须存储在对应的中断向量表表项中(<code>0000:0000-0000:03FF</code>)。</p>
<h5 id="6-6-1-编制中断处理程序—以除法错误中断为例"><a href="#6-6-1-编制中断处理程序—以除法错误中断为例" class="headerlink" title="6.6.1 编制中断处理程序—以除法错误中断为例"></a>6.6.1 编制中断处理程序—以除法错误中断为例</h5><p>问题：如何编制中断处理程序?<br>方案：通过对 0号中断，即除法错误的中断处理，体会中断处理程序处理的技术问题<br>预期效果：编写一个0号中断处理程序，它的功能是在屏幕中间显示“overflow!”后，然后返回到操作系统。</p>
<ul>
<li><strong>问题1：中断处理子程序应该放在哪里？</strong></li>
</ul>
<p>中断处理子程序应该存放在内存的确定位置，但这里我们是模拟中断处理，要重新找个地方，不破坏系统的中断处理函数。</p>
<p>在操作系统之上使用计算机，所有的硬件资源都在操作系统的管理之下，应该向操作系统申请获得存放中断处理子程序的内存。</p>
<p>使用汇编语言可以<strong>绕过操作系统</strong>，直接在找到一块别的程序不会用到的内存区，将中断处理子程序传送到其中即可。（注意：不是工程化的方法，但也体现实用技巧）</p>
<p>内存<code>0000:0000~0000:03FFF</code>大小为1KB的空间是系统存放中断向量表，DOS系统和其他应用程序都不会随便使用这段空间。8086支持256个中断，但实际上系统中要处理的中断事件远没有达到256个。利用中断向量表中的空闲单元来存放我们的程序。估计出，中断处理子程序的长度不可能超过256个字节，就选用从0000:0200至0000:02FF的256个字节的空间。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000：0000</td>
<td>IP 0200</td>
</tr>
<tr>
<td>0000：0002</td>
<td>CS 0000</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>问题2：怎么写安装程序?</strong></li>
</ul>
<p>(1) 编写可以显示“overflow!”的中断处理程序，命名为：do0<br>(2) 安装程序：将do0送入内存0000:0200处<br>(3) 将do0中断处理程序的入口地址0000:0200存储在中断向量表0号表项中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">; 程序框架</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	do0安装程序</span><br><span class="line">	设置中断向量表</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">do0: 显示字符串 &quot;overflow !&quot;</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">do0end: nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;; do0安装程序</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0	; 设置ds:si指向源地址cs:do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax	</span><br><span class="line">mov di,200h	; 设置es:di指向目的地址0000:0200h</span><br><span class="line">mov cx, offset do0end - offset do0	; 设置cx为传输长度为do0部分代码的长度</span><br><span class="line">cld	; 设置传输方向为正</span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>问题3：中断处理函数do0怎么写？</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;; do0中断处理子函数体</span><br><span class="line">do0: jmp short do0start</span><br><span class="line">	db &#x27;overflow!&#x27;</span><br><span class="line">do0start:</span><br><span class="line">	mov ax, cs</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov si, 202h	; jmp short do0start这个语句占2字节，故是200+2=202h</span><br><span class="line">	</span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov di,12*160+36*2</span><br><span class="line">	mov cx,9</span><br><span class="line">s:	mov al,[si]</span><br><span class="line">	mov es:[di],al</span><br><span class="line">	inc si</span><br><span class="line">	add di,2</span><br><span class="line">	loop s</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>问题4：如何设置中断向量表？</strong></li>
</ul>
<p>设置中断向量表任务：将do0的入口地址0:200h，写到中断向量表的0号表项中即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200h</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br></pre></td></tr></table></figure>
<h5 id="6-6-2-单步中断"><a href="#6-6-2-单步中断" class="headerlink" title="6.6.2 单步中断"></a>6.6.2 单步中断</h5><p>由Debug中的t命令说起…</p>
<p>程序的正常执行：取指令、改变CS:IP、执行指令、取指令……</p>
<p>Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。</p>
<ul>
<li>是什么，让CPU能执行一条指令就停下来？<ul>
<li>Debug利用了CPU提供的单步中断的功能</li>
<li>使用t命令时，Debug将TF标志设为1，使CPU工作在单步中断方式下…</li>
<li>自定义单步中断处理程序，还可以实现特殊的功能。</li>
</ul>
</li>
</ul>
<p><strong>单步中断过程与处理</strong></p>
<ul>
<li>两个和中断相关的寄存器标志位<ul>
<li>TF-陷阱标志(Trap flag)：用于调试时的单步方式操作。<ul>
<li>当TF=1时，每条指令执行完后产生陷阱，由系统控制计算机</li>
<li>当TF=0时，CPU正常工作，不产生陷阱。</li>
</ul>
</li>
<li>IF-中断标志(Iinterrupt flag)<ul>
<li>当IF=1时，允许CPU响应可屏蔽中断请求;</li>
<li>当IF=0时，关闭中断</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断(中断类型码为1)，引发中断过程，执行中断处理程序。</p>
<ul>
<li>中断过程<ul>
<li>(1)取得中断类型码1;</li>
<li>(2) 标志寄存器入栈，TF、IF设置为0;<ul>
<li>中断处理程序也由一条条指令组成的。如果在执行中断处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，转去执行单步中断的中断处理程序的第一条指令……<br>上面的过程将陷入一个永远不能结束的循环CPU永远执行单步中断处理程序的第一条指令所以，在进入中断处理程序之前，设置TF=0。</li>
</ul>
</li>
<li>(3) CS、IP入栈;</li>
<li>(4) (IP)=(1×4), (CS)=(1×4+2)</li>
</ul>
</li>
</ul>
<p><strong>应用：中断不响应的情况</strong></p>
<p>一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应。</p>
<p>例如：在执行完向 ss寄存器传送数据的指令后，即便是发生中断，CPU 也不会响应。<br>原因：<code>ss:sp</code>联合指向栈顶，而对它们的设置应该<strong>连续完成，不能被中断打断</strong>。</p>
<h4 id="6-7-由int指令引发的中断"><a href="#6-7-由int指令引发的中断" class="headerlink" title="6.7 由int指令引发的中断"></a>6.7 由int指令引发的中断</h4><p>int格式：<code>int n</code>，n为<strong>立即数</strong>，表示中断类型码</p>
<p>功能：引发中断过程</p>
<ul>
<li>CPU执行intn指令，相当于引发一个n号中断的中断过程，执行过程如下<ul>
<li>(1) 取中断类型码n；</li>
<li>(2) 标志寄存器入栈，IF=0，TF=0；</li>
<li>(3) CS、IP入栈；</li>
<li>(4) (IP)=(n×4)，(CS)=(n×4+2)。</li>
</ul>
</li>
</ul>
<p>小小结：<br><code>int</code>指令的最终功能和<code>call</code>指令相似，都是调用一段程序。一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。</p>
<p>编写供应用程序调用的中断例程<br>技术手段：编程时，可以用<code>int</code>指令调用子程序；此子程序即中断处理程序，简称为中断例程。可以自定义中断例程实现特定功能。</p>
<ul>
<li><strong>中断处理程序的常规的步骤</strong><ul>
<li>(1) 保存用到的寄存器。</li>
<li>(2) 处理中断。</li>
<li>(3) 恢复用到的寄存器。</li>
<li>(4) 用 iret指令返回。</li>
</ul>
</li>
</ul>
<h4 id="6-8-BIOS和DOS中断处理"><a href="#6-8-BIOS和DOS中断处理" class="headerlink" title="6.8 BIOS和DOS中断处理"></a>6.8 BIOS和DOS中断处理</h4><h5 id="6-8-1-BIOS-——-基本输入输出系统"><a href="#6-8-1-BIOS-——-基本输入输出系统" class="headerlink" title="6.8.1 BIOS —— 基本输入输出系统"></a>6.8.1 BIOS —— 基本输入输出系统</h5><p><img src="https://pic.imgdb.cn/item/671611ffd29ded1a8cf80eca.png" style="zoom:60%"></p>
<p><strong>（一）BIOS，是在系统板的ROM中存放着一套程序</strong></p>
<p>容量：8KB，地址：从FE000H开始</p>
<blockquote>
<p>BIOS是一个芯片，焊在主板上的，计算机(主板)一通电，BIOS芯片就开始工作，也即开始检查各个硬件是否正常。</p>
</blockquote>
<ul>
<li>BIOS中的主要内容<ul>
<li>(1) 硬件系统的检测和初始化程序</li>
<li>(2) 外部中断和内部中断的中断例程</li>
<li>(3) 用于对硬件设备进行I/0操作的中断例程</li>
<li>(4) 其他和硬件系统相关的中断例程</li>
</ul>
</li>
<li>BIOS的意义<ul>
<li>使用BIOS功能调用，程序员不用了解硬件操作细节，直接使用指令设置参数，并中断调用BIOS例程，即可完成相关工作!</li>
<li>使用BIOS功能调用：(1) 方便编程；(2) 能写出简洁、可读性好、易于移植的程序。</li>
</ul>
</li>
</ul>
<p><strong>（二）BIOS中断调用示例</strong></p>
<p>任务：在屏幕的5行12列显示3个红底高亮闪烁绿色的a。</p>
<p>方案：<strong>用BIOS的10h中断</strong>。</p>
<p>当<code>ah=2</code>时，调用第10h中断例程的2号子程序，设置光标位置；<br>当<code>ah=9</code>时，调用第10h中断例程的9号子程序，在光标位置显示字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ah,2	;置光标功能</span><br><span class="line">	mov bh,0	;第0页</span><br><span class="line">	mov dh,5	;dh中放行号</span><br><span class="line">	mov dl,12	;dl中放列号</span><br><span class="line">	int 10h		;调用BIOS的10h中断</span><br><span class="line"></span><br><span class="line">	mov ah,9	;显示字符功能</span><br><span class="line">	mov al,&#x27;a&#x27;	;字符a</span><br><span class="line">	mov bl,11001010b	;颜色属性</span><br><span class="line">	mov bh,0	;第o页</span><br><span class="line">	mov cx,3	;字符重复个数</span><br><span class="line">	int 10h		;调用BIOS的10h中断</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>（三）有哪些BIOS中断，怎么用</strong></p>
<p><img src="https://pic.imgdb.cn/item/671616ebd29ded1a8c02bba0.png"></p>
<h5 id="6-8-2-DOS中断"><a href="#6-8-2-DOS中断" class="headerlink" title="6.8.2 DOS中断"></a>6.8.2 DOS中断</h5><p>常见的DOS中断：</p>
<p><img src="https://pic.imgdb.cn/item/67161a4ed29ded1a8c0a3965.png"></p>
<p>BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时常用到的功能。<br>和硬件设备相关的DOS中断例程中，一般都调用BIOS的中断例程。</p>
<h5 id="6-8-3-BIOS和DOS中断例程的安装过程"><a href="#6-8-3-BIOS和DOS中断例程的安装过程" class="headerlink" title="6.8.3 BIOS和DOS中断例程的安装过程"></a>6.8.3 BIOS和DOS中断例程的安装过程</h5><p>(1) CPU一加电，初始化<code>(CS)=0FFFFH，(IP)=0</code>，自动从<code>FFFF:0</code>单元开始执行程序。<code>FFFF:0</code>处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</p>
<p>(2) 初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。</p>
<p>(3) 硬件系统检测和初始化完成后，调用<code>int 19h</code>进行操作系统的引导。从此将计算机交由操作系统控制。</p>
<p>(4) DOS启动后，除完成其它工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</p>
<h4 id="6-9-端口的读写"><a href="#6-9-端口的读写" class="headerlink" title="6.9 端口的读写"></a>6.9 端口的读写</h4><h5 id="6-9-1-引入——用端口访问外设：以发声为例"><a href="#6-9-1-引入——用端口访问外设：以发声为例" class="headerlink" title="6.9.1 引入——用端口访问外设：以发声为例"></a>6.9.1 引入——用端口访问外设：以发声为例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codeseg</span><br><span class="line">codeseg segment</span><br><span class="line"></span><br><span class="line">start: mov al, 08h	;设置声音的频率</span><br><span class="line">	out 42h, al</span><br><span class="line">	out 42h, al</span><br><span class="line">	in al, 61h	;读设备控制器端口原值</span><br><span class="line"></span><br><span class="line">	mov ah, al	;保存原值</span><br><span class="line">	or al, 3	;打开扬声器和定时器</span><br><span class="line">	out 61h, al	;接通扬声器，发声</span><br><span class="line">	</span><br><span class="line">	mov cx,60000 ;延时</span><br><span class="line">delay:	nop</span><br><span class="line">	loop delay</span><br><span class="line">	</span><br><span class="line">	mov al, ah	;恢复端口原值</span><br><span class="line">	out 61h, al</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>补充：CPU的邻居</strong>——CPU可以直接读写3个地方的数据<ul>
<li>(1) CPU 内部的寄存器；</li>
<li>(2) 内存单元；</li>
<li>(3) (物理外设)端口<ul>
<li>各种接口卡，网卡、显龙等</li>
<li>主板上的接口芯片</li>
<li>其他芯片</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/67161f83d29ded1a8c1564ce.png" style="zoom:50%"></p>
<p><img src="https://pic.imgdb.cn/item/671620f3d29ded1a8c189a25.png" style="zoom:60%"></p>
<h5 id="6-9-2-端口的读写指令"><a href="#6-9-2-端口的读写指令" class="headerlink" title="6.9.2 端口的读写指令"></a>6.9.2 端口的读写指令</h5><ul>
<li>读写内存与寄存器的指令<ul>
<li><code>mov, add, push...</code></li>
</ul>
</li>
<li>读写端口的指令<ul>
<li><code>in</code>： CPU从端口读取数据</li>
<li><code>out</code>：CPU往端口写入数据</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6716226cd29ded1a8c1c00a0.png"></p>
<ul>
<li><p>端口的读写指令示例</p>
<ul>
<li><p>对0~255以内的端口进行读写，端口号用立即数给出</p>
<ul>
<li>```assembly<br>in al, 20h    ;从20h端口读入一个字节<br>out 21h, al    ;往21h端口写入一个字节<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 显对256~65535的端口进行读写时，端口号放在dx中</span><br><span class="line"></span><br><span class="line">  - ```assembly</span><br><span class="line">    mov dx,3f8h	;将端口号3f8送入dx</span><br><span class="line">    in al,dx	;从3f8h端口读入一个字节</span><br><span class="line">    out dx,al	;向3f8h端口写入一个字节</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意：在in和out指令中，只能使用<code>ax</code>或<code>al</code>来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用<code>al</code>，访问16位端口时用<code>ax</code>。</p>
<h4 id="6-10-操作CMOS-RAM芯片"><a href="#6-10-操作CMOS-RAM芯片" class="headerlink" title="6.10 操作CMOS RAM芯片"></a>6.10 操作CMOS RAM芯片</h4><h5 id="6-10-1-CMOS-RAM-芯片"><a href="#6-10-1-CMOS-RAM-芯片" class="headerlink" title="6.10.1 CMOS RAM 芯片"></a>6.10.1 CMOS RAM 芯片</h5><p><img src="https://pic.imgdb.cn/item/6716376ad29ded1a8c44e4cb.png" alt="系统开机BIOS界面" style="zoom:70%"></p>
<p>我们在操作计算机的时候，电脑一开始的时候呢，我们按f8可以进入一个叫做bios设置当中，在设置里边包含了一些时间呀包括其他的一些整个系统的信息，如果没有这些信息的话呢，计算机是不能够启动起来的。</p>
<p>那么其实做出这些工作，它得益于在整个的主板上有这么一个所谓的<strong>cmos ram芯片</strong>，它包含着一个实时的时钟和一个有128个存储单元的ram存储器。</p>
<ul>
<li>CMOS RAM 芯片<ul>
<li>(1) 包含一个实时钟和一个有128个存储单元的RAM存储器</li>
<li>(2) 128 个字节的 RAM 中存储：内部实时钟、系统配置信息，相关的程序(用于开机时配置系统信息，引导系统启动)。</li>
<li>(3) CMOS RAM 芯片靠电池供电，关机后其内部的实时钟仍可正常工作 ，特别的是，此块RAM中的信息不丢失（一般RAM掉电丢失信息，这个其实是因为在这里边有一块纽扣电池为其供电）。</li>
<li>(4) 该芯片内部有两个端口，端口地址为70h和71h，CPU通过这两个端口读写CMOS RAM。<ul>
<li>70h地址端口，存放要访问的CMOS RAM单元的地址</li>
<li>71h数据端口，存放从选定的单元中读取的数据，或要写入到其中的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/67163932d29ded1a8c46ac79.png" style="zoom:70%"></p>
<h5 id="6-10-2-端口操作示例：提取CMOSRAM中存储的时间信息"><a href="#6-10-2-端口操作示例：提取CMOSRAM中存储的时间信息" class="headerlink" title="6.10.2 端口操作示例：提取CMOSRAM中存储的时间信息"></a>6.10.2 端口操作示例：提取CMOSRAM中存储的时间信息</h5><p>问题描述：在屏幕中间显示当前的月份</p>
<p><img src="https://pic.imgdb.cn/item/67163d3bd29ded1a8c4fc97b.png"></p>
<h4 id="6-11-外设连接与中断"><a href="#6-11-外设连接与中断" class="headerlink" title="6.11 外设连接与中断"></a>6.11 外设连接与中断</h4><p>CPU通过端口与外部设备“连接”，CPU 在执行指令过程中，可以检测到发送过来的中断信息，引发<strong>中断</strong>过程，处理外设的输入。</p>
<h5 id="6-11-1-外中断：由外部设备发生的事件引起的中断"><a href="#6-11-1-外中断：由外部设备发生的事件引起的中断" class="headerlink" title="6.11.1 外中断：由外部设备发生的事件引起的中断"></a>6.11.1 外中断：由外部设备发生的事件引起的中断</h5><ul>
<li>可屏蔽中断<ul>
<li>可屏蔽中断是CPU 可以不响应的外中断。</li>
<li>CPU 是否响应可屏蔽中断，要看标志寄存器的IF 位的设置。</li>
<li>当CPU检测到可屏蔽中断信息时：<ul>
<li>如果<code>IF=1</code>，则CPU在执行完当前指令后响闻应中断，引发中断过程;</li>
<li>如果<code>IF=0</code>，则不响应可屏蔽中断。</li>
</ul>
</li>
<li>几乎所有由外设引发的外中断，都是可屏蔽中断，比如键盘输入、打印机请求。</li>
</ul>
</li>
<li>不可屏蔽中断<ul>
<li>CPU 必须响应的外中断，当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。</li>
<li>对于8086CPU不可屏蔽中断的中断类型码固定为2。</li>
<li>不可屏蔽中断在系统中有必须处理的紧急情况发生时用来通知CPU 的中断信息。</li>
</ul>
</li>
</ul>
<h5 id="6-11-2-外中断处理过程"><a href="#6-11-2-外中断处理过程" class="headerlink" title="6.11.2 外中断处理过程"></a>6.11.2 外中断处理过程</h5><ul>
<li><p>可屏蔽中断所引发的中断过程</p>
<ul>
<li>(1) 取中断类型码n；<ul>
<li>可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU（对比内中断:中断类型码是在CPU内部产生的）。</li>
</ul>
</li>
<li>(2) 标志寄存器入栈，<code>IF=0，TF=0</code>;<ul>
<li>将IF置0的原因：进入中断处理程序后，禁止其他的可屏蔽中断。如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF 置1 。</li>
</ul>
</li>
<li>(3) CS、IP入栈;</li>
<li>(4) (IP)=(n×4)，(CS)=(n×4+2)</li>
</ul>
</li>
</ul>
<ul>
<li><p>不可屏蔽中断的中断过程(中断值固定为2，不必取中断码)</p>
<ul>
<li>(1) 标志寄存器入栈，<code>IF=0，TF=0</code>;</li>
<li>(2) CS、IP入栈;</li>
<li>(3) (IP)=(8),(CS)=(0AH)。</li>
</ul>
</li>
</ul>
<blockquote>
<p>8086CPU提供的设置IF的指令：</p>
<p><code>sti</code>——用于设置<code>IF=1</code>;</p>
<p><code>cli</code>——用于设置<code>IF=0</code>。</p>
</blockquote>
<h5 id="6-11-3-PC机键盘的处理过程"><a href="#6-11-3-PC机键盘的处理过程" class="headerlink" title="6.11.3 PC机键盘的处理过程"></a>6.11.3 PC机键盘的处理过程</h5><p>键盘输入的处理过程：① 键盘输入；② 引发9号中断；③ 执行<code>int 9</code>中断例程</p>
<p><strong>（一）键盘输入</strong></p>
<ul>
<li>键盘上的每一个键相当于一个开关，键盘中有一芯片对键盘上的每一个键的开关状态进行扫描。</li>
<li>按下一个键时的操作<ul>
<li>开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。</li>
<li>扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为<code>60H</code>。</li>
</ul>
</li>
<li>松开按下的键时的操作<ul>
<li>产生一个扫描码，扫描码说明了松开的键在键盘上的位置。</li>
<li>松开按键时产生的扫描码也被送入<code>60H</code>端口中。</li>
</ul>
</li>
<li>扫描码——长度为一个字节的编码<ul>
<li>按下一个键时产生的扫描码——<strong>通码</strong>，通码的第7位为0</li>
<li>松开一个键时产生的扫描码——<strong>断码</strong>，断码的第7位为1</li>
<li><strong>断码 = 通码+80H</strong></li>
<li>例：g键的通码为22H，断码为a2H</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/671643e4d29ded1a8c5eb818.png"></p>
<p><strong>（二）引发9号中断</strong></p>
<p>键盘的输入到达60H端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。</p>
<p>CPU检测到该中断信息后，如果<code>IF=1</code>，则响应中断，引发中断过程，转去执行<code>int 9</code>中断例程。</p>
<ul>
<li><p><strong>输入的字符键值如何保存?</strong></p>
<ul>
<li>有BIOS键盘缓冲区!<ul>
<li>BIOS键盘缓冲区：是系统启动后，BIOS用于存放<code>int9</code>中断例程所接收的键盘输入的内存区。</li>
<li>BIOS键盘缓冲区：可以存储15个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码(ASCII)。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>输入了控制键和切换键，如何处理 ?</strong></p>
<ul>
<li><p>0040:17对应的内存单元存放：<strong>键盘状态字节</strong></p>
<p>| 7      | 6        | 5       | 4          | 3    | 2    | 1       | 0       |<br>| ——— | ———— | ———- | ————— | —— | —— | ———- | ———- |<br>| Insert | CapsLock | NumLock | ScrollLock | alt  | ctrl | 左shift | 右shift |</p>
</li>
</ul>
</li>
</ul>
<p><strong>（三）执行<code>int 9</code>中断例程</strong></p>
<ul>
<li>BIOS 中提供的处理键盘输入的<code>int 9</code>中断例程的工作<ul>
<li>(1) 读出60H 端口中的扫描码</li>
<li>(2) 根据扫描码分情况对待<ul>
<li>如果是字符键的扫描码，将该扫描码和它所对应的字符码(即 ASCI码)送入内存中的BIOS键盘缓冲区</li>
<li>如果是控制键(比如 Ctrl)和切换键(比如 CapsLock)的扫描码，则将其转变为状态字节(用二进制位记录控制键和切换键状态的字节 )写入内存中存储状态字节的单元。 </li>
</ul>
</li>
<li>(3) 对键盘系统进行相关的控制，如向相关芯片发出应答信息。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/67164990d29ded1a8c637dd9.png"></p>
<h5 id="6-11-4-定制键盘输入处理"><a href="#6-11-4-定制键盘输入处理" class="headerlink" title="6.11.4 定制键盘输入处理"></a>6.11.4 定制键盘输入处理</h5><p><strong>（一）PC机键盘的处理过程(int9中断例程)</strong></p>
<p><img src="https://pic.imgdb.cn/item/67164a11d29ded1a8c63fec7.png"></p>
<p><strong>（二）编程任务</strong></p>
<p>在屏幕中间依次显示’a’~’z’，并可以让人看清，在显示的过程中，按下Esc键后，改变显示的颜色。</p>
<p>方案：尽可能忽略硬件处理细节，充分利用BIOS提供的<code>int9</code>中断例程对这些硬件细节进行处理；在改写后的中断例程中满足特定要求，并能调用BIOS的原<code>int9</code>中断例程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">;依次显示&#x27;a&#x27;~&#x27;z&#x27;</span><br><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">	db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: mov ax,stack</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,128</span><br><span class="line">	</span><br><span class="line">	;显示字符</span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ah,&#x27;a&#x27;</span><br><span class="line">s:   mov es:[160*12+40*2],ah</span><br><span class="line">	call delay</span><br><span class="line">	inc ah</span><br><span class="line">	cmp ah,&#x27;z&#x27;</span><br><span class="line">	jna s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	;定义延时函数</span><br><span class="line">delay: push ax</span><br><span class="line">	push dx</span><br><span class="line">	mov dx,10h</span><br><span class="line">	mov ax,0</span><br><span class="line">s1: sub ax, 1</span><br><span class="line">	sbb dx, 0</span><br><span class="line">	cmp ax,0</span><br><span class="line">	jne s1</span><br><span class="line">	cmp dx,0</span><br><span class="line">	jne s1</span><br><span class="line">	pop dx</span><br><span class="line">	pop ax</span><br><span class="line">	ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>接下来的工作：按下 ESc键后，改变显示的颜色!<br>原理：键盘输入到达60h端口后，就会引发 9号中断，CPU 则转去执行int 9中断例程。</p>
<ul>
<li>按下 Esc键后改变显示的颜色<ul>
<li>编写int 9中断例程改变显示的颜色<ul>
<li>(1) 从60h端口读出键盘的输入<ul>
<li><code>in al 60h</code></li>
</ul>
</li>
<li>(2) 调用BlOS的int9中断例程，处理硬件细节<ul>
<li>① 关于中断处理程序入口地址面对的问题<ul>
<li>要将中断向量表中的<code>int 9</code>中断例程的入口地址改为自编的中断处理程序的入口地址。</li>
<li>在新中断处理程序中调用原来的<code>int 9</code>中断例程，还需要是原来的<code>int9</code>中断例程的地址。</li>
<li>解决方法：保存原中断例程入口地址</li>
<li>将原来<code>int 9</code>中断例程的偏移地址和段地址保存在<code>ds:[0]</code>和<code>ds:[2]</code>单元中，在需要调用原来的<code>int 9</code>中断例程时候，到<code>ds:[0]、ds:[2]</code>找到</li>
</ul>
</li>
<li>② 如何调用原<code>int 9</code>指令的中断例程口<ul>
<li><code>int 9</code>己改，但仍然需要调用原<code>int 9</code>指令功能</li>
<li>解决方法：模拟对原中断例程的调用<br>(1) 标志寄存器入栈<br>(2) IF=0，TF=0<br>(3) CS、IP入栈<br>(4) (IP)=((ds)×16+0)，(CS)=((ds)×16+2)</li>
</ul>
</li>
</ul>
</li>
<li>(3) 判断是否为Esc的扫描码，如果是，改变显示的颜色后返回；如果不是，则直接返回。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: mov ax, stack</span><br><span class="line">	mov ss,aX</span><br><span class="line">	mov sp,128</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	;改变中断例程入口地址</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov es,ax</span><br><span class="line">	push es:[9*4]</span><br><span class="line">	pop ds:[0]</span><br><span class="line">	push es:[9*4+2]</span><br><span class="line">	pop ds:[2]</span><br><span class="line">	mov word ptr es:[9*4], offset int9</span><br><span class="line">	mov es:[9*4+2],cs</span><br><span class="line">	</span><br><span class="line">	;显示&#x27;a&#x27;~&#x27;z</span><br><span class="line">	mov ax,0b800h</span><br><span class="line">	mov es,ax</span><br><span class="line">	mov ah,&#x27;a&#x27;</span><br><span class="line">s:	mov es:[160*12+40*2],ah</span><br><span class="line">	call delay</span><br><span class="line">	inc ah</span><br><span class="line">	cmp ah,&#x27;z&#x27;</span><br><span class="line">	jna s</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov es,ax</span><br><span class="line"></span><br><span class="line">	; 恢复原来的地址</span><br><span class="line">	push ds:[0]</span><br><span class="line">	pop es:[9*4]</span><br><span class="line">	push ds:[2]</span><br><span class="line">	pop es:[9*4+2]</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">	;定义延迟程序</span><br><span class="line">	delay: push ax</span><br><span class="line">	push dx</span><br><span class="line">	mov dx,10h</span><br><span class="line">	mov ax,0</span><br><span class="line">s1: sub ax, 1</span><br><span class="line">	sbb dx, 0</span><br><span class="line">	cmp ax,0</span><br><span class="line">	jne s1</span><br><span class="line">	cmp dx,0</span><br><span class="line">	jne s1</span><br><span class="line">	pop dx</span><br><span class="line">	pop ax</span><br><span class="line">	ret</span><br><span class="line">	</span><br><span class="line">	;定义中断例程</span><br><span class="line">int9: push ax</span><br><span class="line">	push bx</span><br><span class="line">	push es</span><br><span class="line">	in al,60h</span><br><span class="line">	pushf</span><br><span class="line">	;pushf</span><br><span class="line">	pop bx</span><br><span class="line">	and bh,11111100b</span><br><span class="line">	push bx</span><br><span class="line">	popf</span><br><span class="line">	call dword ptr ds:[0]	;call的存在说明只是给esc增加了一个功能，并没有替换原有功能</span><br><span class="line">	</span><br><span class="line">	cmp al,1	;ESC扫描码1</span><br><span class="line">	jne int9ret</span><br><span class="line">	;改变颜色</span><br><span class="line">	mov ax,0bg00h</span><br><span class="line">	mov es,ax</span><br><span class="line">	inc byte ptr es:[160*12+40*2+1]</span><br><span class="line">	</span><br><span class="line">int9ret:pop es</span><br><span class="line">	pop bx</span><br><span class="line">	pop ax</span><br><span class="line">	iret</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h5 id="6-11-5-改写中断例程的方法"><a href="#6-11-5-改写中断例程的方法" class="headerlink" title="6.11.5 改写中断例程的方法"></a>6.11.5 改写中断例程的方法</h5><h5 id="6-11-6-用中断响应外设"><a href="#6-11-6-用中断响应外设" class="headerlink" title="6.11.6 用中断响应外设"></a>6.11.6 用中断响应外设</h5><p><strong>（一）如何操作外部设备</strong></p>
<p>以典型输入设计——键盘操作为例</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>硬件中断 int 9h</th>
<th>BIOS中断 int 16h</th>
<th>DOS中断 int 21h</th>
</tr>
</thead>
<tbody>
<tr>
<td>由键盘上按下或松开一个键<br>时，如果中断是允许的，就<br>会产生int 9h中断，并转到<br>BIOS的键盘中断处理程序。</td>
<td>BIOS中断提供基本的键盘操作<br>功能号(AH)=<br>00H、10H 一从键盘读入字符<br>01H、11H 一读取键盘状态<br>02H、12H 一读取键盘标志<br>03H 一设置重复率<br>04H一设置键盘点击<br>05H 一字符及其扫描码进栈<br>在使用功能键和变换键的程序中很重要。</td>
<td>Dos中断提供丰富、便捷的功能调用<br>功能号(AH)=<br>01H 一 从键盘输入一个字符并回显<br>06H 一 读键盘字符<br>07H 一 从键盘输入一个字符不回显<br>08H 一 从键盘输入一个字符，不回显，检测CTRL-Break<br>0AH 一 输入字符到指定地址的缓冲<br>0BH - 读键盘状态<br>0CH -清除键盘缓冲区，并调用一种键盘功能</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>键盘缓冲区的实现<br>① 共16字<br>② 用<strong>环形队列</strong>，先进先出<br>③ 可存储15个按键扫描码</p>
</blockquote>
<p>对键盘输入的处理的<code>int 9h</code>中断和<code>int 16h</code>中断：</p>
<p>（1）<code>int 9h</code>将键盘输入存入缓冲或改变状态字，键盘输入将引发9号中断，BIOS提供了int 9中断例程。</p>
<p>int 9中断例程从60h端口读出扫描码，并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间(键盘缓冲区或状态字节)中。</p>
<p>键盘缓冲区中有16 个字单元，可以存储15个按键的扫描码和对应的入ASCII 码。</p>
<p>（2）BIOS提供了<code>int 16h</code>中断例程供程序员调用，以完成键盘的各种操作。</p>
<p>例：当<code>(AH)=0</code>时，读取键盘缓冲区功能：从键盘缓冲区中读取一个键盘输入，并且将其从缓冲区中删除。</p>
<p>（3）BIOS的<code>int 9h</code>中断例程和<code>int 16h</code>中断例程是一对相互配合的程序，<code>int 9h</code>中断例程向键盘缓冲区中写入，<code>int 16h</code>中断例程从缓冲区中读出。它们写入和读出的时机不同，<code>int 9h</code>中断例程在有键按下的时候向键盘缓冲区中写入数据而<code>int 16h</code>中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。</p>
<blockquote>
<p>补充解释：</p>
<p><code>int 9h</code>是<strong>硬件中断</strong>，这个中断历程呢是在有键摁下去的时候，向键盘缓冲区里边呢去写入数据，这个过程<strong>不受CPU控制</strong>，是单纯的外设键盘触发的外部硬件中断；</p>
<p><code>int 16h</code>是<strong>软件中断</strong>，它是在应用程序里边对它进行调用的时候，才将数据从键盘缓冲区中读出。</p>
<p>从cpu角度来讲，我不管你键盘什么时候去产生这样的呃动作，我需要的时候，我就通过<code>int 16h</code>去调用它，而对于<code>int 9h</code>号中断来讲，它和cpu没有关系，只要说有键摁下去了，就把它记下来。当这两个中断在应用程序里边我们合理的去设置的时候呢，他们相互配合呢帮助我们去读取这样一些数据。</p>
</blockquote>
<p><strong>（二）应用示例：更改屏幕颜色</strong></p>
<p>要求：接收用户的键盘输入<br>输入“r”，将屏幕上的字符设置为红色；输入“g”，将屏幕上的字符设置为绿色；输入“b”，将屏幕上的字符设置为蓝色。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	;调用中断，等待输入</span><br><span class="line">	mov ah,0</span><br><span class="line">	int 16h</span><br><span class="line">	</span><br><span class="line">	;识别按键</span><br><span class="line">	mov ah,1</span><br><span class="line">	cmp al,&#x27;r&#x27;</span><br><span class="line">	je red</span><br><span class="line">	cmp al,&#x27;g&#x27;</span><br><span class="line">	je green</span><br><span class="line">	cmp al,&#x27;b&#x27;</span><br><span class="line">	je blue</span><br><span class="line">	jmp short sret</span><br><span class="line">	</span><br><span class="line">	;设置屏幕颜色</span><br><span class="line">red:	shl ah,1</span><br><span class="line">green:	shl ah,1</span><br><span class="line">blue:	mov bx,0b800h</span><br><span class="line">	mov es,bx</span><br><span class="line">	mov bx,1</span><br><span class="line">	mov cx,2000</span><br><span class="line">	and byte ptr es:[bx],11111000b</span><br><span class="line">	or es:[bxl,ah</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">sret: mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><strong>（三）应用：字符串的输入</strong></p>
<p>问题：设计一个最基本的字符串输入程序，需要具备下面的功能：</p>
<p>(1) 在输入的同时需要显示这个字符串<br>(2) 一般在输入回车符后，字符串输入结束<br>(3) 能够删除已经输入的字符——用退格键。</p>
<p>程序的处理过程</p>
<p>(1) 调用<code>int 16h</code>读取键盘输入；<br>(2) 如果不是字符：①如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符，继续执行(1)；②如果是Enter键，向字符栈中压入0，返回；<br>(3) 如果是字符键：字符入栈，显示字符栈中的所有字符，继续执行(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">; 该程序未完成</span><br><span class="line">assume cs:code, ds:data</span><br><span class="line">data segment	;“栈”空间</span><br><span class="line">	db 32 dup (?)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">	mov ax, data</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov si, 0</span><br><span class="line">	mov dh, 12</span><br><span class="line">	mov dl, 20</span><br><span class="line">	call getstr</span><br><span class="line">	</span><br><span class="line">return: mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">;完整的接收字符串输入的子程序</span><br><span class="line">getstr:	push ax</span><br><span class="line">getstrs:</span><br><span class="line">	;调用int 16h读取键盘输入</span><br><span class="line">	mov ah,0</span><br><span class="line">	int 16h</span><br><span class="line">	</span><br><span class="line">	cmp al,20h</span><br><span class="line">	jb nochar ;小于20h为非字符</span><br><span class="line">	;字符入栈</span><br><span class="line">	;显示栈中的字符</span><br><span class="line">	jmp getstrs</span><br><span class="line">	</span><br><span class="line">;处理非字符</span><br><span class="line">nochar:	</span><br><span class="line">	cmpah,oeh	;退格键的扫描码</span><br><span class="line">	je backspace</span><br><span class="line">	cmp ah,1ch	;回车键的扫描码</span><br><span class="line">	je enter</span><br><span class="line">	jmp getstrs</span><br><span class="line"></span><br><span class="line">;对退格键、回车键的处理</span><br><span class="line">;退格</span><br><span class="line">backspace:</span><br><span class="line">	;字符出栈</span><br><span class="line">	;显示栈中的字符</span><br><span class="line">	jmp getstrs</span><br><span class="line">;回车</span><br><span class="line">enter:	mov al,0</span><br><span class="line">	;0字符入栈</span><br><span class="line">	;显示栈中的字符</span><br><span class="line">	</span><br><span class="line">	pop ax</span><br><span class="line">	ret	;getstr结束</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h4 id="6-12-读写磁盘"><a href="#6-12-读写磁盘" class="headerlink" title="6.12 读写磁盘"></a>6.12 读写磁盘</h4><p>磁盘，包括“软盘”、“硬盘”（不过软盘已经退出历史舞台了）</p>
<p><img src="https://pic.imgdb.cn/item/67175f8cd29ded1a8c1f079d.png"></p>
<p><strong>（一）BIOS对磁盘的操作</strong></p>
<ul>
<li>用BlOS <code>int 13h</code>对磁盘进行读操作<ul>
<li>入口参数：<ul>
<li>(ah) = 2(2表示读扇区)</li>
<li>(al)=读取的扇区数</li>
<li>(ch)=磁道号 ，(cl)=扇区号</li>
<li>(dh)=磁头号(对于软盘即面号，一个面用一个磁头来读写)</li>
<li>(dl)=驱动器号:软驱从0开始，0:软驱A，1:软驱B，硬盘从80h开始，80h:硬盘C，81h:硬盘D</li>
<li>es:bx指向接收从扇区读入数据的内存区</li>
</ul>
</li>
<li>返回参数：<ul>
<li>操作成功：(ah)=0，(al)=读入的扇区数</li>
<li>操作失败：(ah)=出错代码</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例子：读取c盘0面0道1扇区的内容到内存单元0:200</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h	;读入0:200h</span><br><span class="line">mov al,1	;1个扇区</span><br><span class="line">mov ch,0	;0磁道</span><br><span class="line">mov cl,1	;1扇区</span><br><span class="line">mov dl,80h	;C盘</span><br><span class="line">mov dh,0	;0面</span><br><span class="line">mov ah,2	;读扇区</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure>
<ul>
<li>用BlOS <code>int 13h</code>对磁盘进行写操作</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/67176239d29ded1a8c2140f6.png" style="zoom:60%"></p>
<p>例子：将0:200中的内容写入C盘0面0道1扇区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov bx,200h	;写0:200h</span><br><span class="line">mov al,1	;写1个扇区</span><br><span class="line">mov ch,0	;0磁道</span><br><span class="line">mov cl,1	;1扇区</span><br><span class="line">mov dl,80h	;C盘</span><br><span class="line">mov dh,0	;0面</span><br><span class="line">mov ah,3	;3号写入功能</span><br><span class="line">int 13h</span><br></pre></td></tr></table></figure>
<p><strong>（二）DOS中断对磁盘文件的支持—<code>int 21H</code></strong></p>
<p><img src="https://pic.imgdb.cn/item/6717635dd29ded1a8c233b61.png"></p>
<ul>
<li>功能39H<ul>
<li>功能描述：用指定的驱动器和路径创建一个新目录</li>
<li>入口参数：<ul>
<li>AH = 39H</li>
<li>DS:DX=指定路径的字符串地址(以0为字符串的结束标志)</li>
</ul>
</li>
<li>出口参数：<ul>
<li>CF=0——创建成功</li>
<li>CF=1——创建失败，AX=错误号(03H或05H)，其含义见错误代码表</li>
</ul>
</li>
</ul>
</li>
</ul>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://junheng-wang.github.io/2024/10/16/Assembly/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B1%87%E7%BC%96/" rel="tag">汇编</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/10/31/object-oriented-design/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            面向对象设计(C++)
          
        </div>
      </a>
    
    
      <a href="/2024/08/06/Fundamentals-of-CPlusPlus/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">C++之内存和多线程</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "0DieopImIy7vnuzj4jQ2wk6O-gzGzoHsz",
    app_key: "j6eRiYtlDSl8eRXVN54blF25",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> wjh
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Wang Junheng"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/Alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechatpay.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->
 
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
            <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css">
        
    
 
<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>