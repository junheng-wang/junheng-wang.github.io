<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="���͡�ѧϰ�����˼�������С�����" />
       
      <meta name="description" content="���˺�����" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>面向对象设计(C++) |  Wang Junheng</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-object-oriented-design"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  面向对象设计(C++)
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/10/31/object-oriented-design/" class="article-date">
  <time datetime="2024-10-31T11:04:42.000Z" itemprop="datePublished">2024-10-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E6%8F%90%E5%8D%87/">学习提升</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E6%8F%90%E5%8D%87/%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">编程与深度学习</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">27.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">109 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="0-程序设计哲学"><a href="#0-程序设计哲学" class="headerlink" title="0. 程序设计哲学"></a>0. 程序设计哲学</h3><p>尽量把我们的代码建筑在已有代码的基础上（避免Code Duplication），如果你的程序有很多一模一样的代码，显然出错了修改起来会很麻烦。</p>
<p>栈——&gt;堆栈，堆——&gt;堆 </p>
<h3 id="1-面向对象的基本概念和原理"><a href="#1-面向对象的基本概念和原理" class="headerlink" title="1. 面向对象的基本概念和原理"></a>1. 面向对象的基本概念和原理</h3><h4 id="1-1-什么是对象"><a href="#1-1-什么是对象" class="headerlink" title="1.1 什么是对象"></a>1.1 什么是对象</h4><script type="math/tex; mode=display">
\text{Object} = \text{Attributes + Services}</script><p><img src="https://pic.imgdb.cn/item/672368d4d29ded1a8c57d9b3.png" style="zoom:40%"></p>
<p>数据（Data）：表示对象的属性或状态。例如：杯子是一个对象，杯子的高度、重量、口径、颜色等都是杯子这个对象的数据。数据也可分动态和静态的，比如装了多少水是可以改变的，但是杯子的材质、颜色一般是固定的。</p>
<p>操作（Operation）：表示对象对外能够提供的服务。例如：杯子能够盛水。</p>
<ul>
<li>什么是面向对象<ul>
<li>一种组织方式<ul>
<li>设计：解决问题的思路</li>
<li>实现：用代码实现</li>
</ul>
</li>
<li>对象，而不是控制或数据流，是设计和实现的主要焦点。</li>
<li>专注于事情，而不是操作。</li>
</ul>
</li>
</ul>
<h4 id="1-2-面向对象编程中的基本理念"><a href="#1-2-面向对象编程中的基本理念" class="headerlink" title="1.2 面向对象编程中的基本理念"></a>1.2 面向对象编程中的基本理念</h4><p><strong>理念1</strong>：对象发送和接收消息（objects do things! ）</p>
<p><img src="https://pic.imgdb.cn/item/67236c7dd29ded1a8c5ac522.png" style="zoom:40%"></p>
<p>对象发送消息，消息是：① 由发件人撰写；② 由接收方翻译；③ 通过方法实现。<br>消息：① 可能导致接收器状态改变；② 可能返回结果。</p>
<p><strong>理念2</strong>：对象(Object) VS 类(Class)</p>
<p>对象（例如：猫）：代表事物、事件或概念，是一个实体，在运行时响应消息。<br>类（例如：猫这个种类）：定义实例的属性，是一个概念，像C++中的类型一样行事。</p>
<p><img src="https://pic.imgdb.cn/item/67237196d29ded1a8c5fc1df.png" style="zoom:70%"></p>
<p><strong>理念3</strong>：OOP特性</p>
<ol>
<li>一切都是Object；</li>
<li>程序是一堆对象，通过发送消息来告诉彼此该做什么；</li>
<li><strong><font color="red">每个对象都有自己的内存，这个对象（可以）再由其他对象组成</font></strong>；</li>
<li>每个对象都有一个类型（即必须先定义类Class，然后对象由类实例化出来）；</li>
<li>特定类型的所有对象都可以接收相同的消息。</li>
</ol>
<p>对象具有<strong>接口</strong>，接口是它接收消息的方式，它在对象所属的类中定义。接口的功能：Communication（交流）和Protection（保护）。</p>
<p><strong>理念4</strong>：隐藏实现(The Hidden lmplementation )</p>
<p>对象的内部、表示其状态的数据成员以及消息被rcvd时所采取的操作都是隐藏的。</p>
<ul>
<li>类创建者与客户端程序员<ul>
<li>让客户程序员的手远离他们不应该接触的部分。</li>
<li>允许类创建者更改类的内部工作，而不必担心它会如何影响客户端程序员。</li>
</ul>
</li>
</ul>
<p><strong>理念5</strong>：封装</p>
<p>将数据和处理这些数据的方法捆绑在一个对象中，隐藏数据和操作的详细信息，仅限制对公开方法的访问。</p>
<h4 id="1-3-自动售票机的例子"><a href="#1-3-自动售票机的例子" class="headerlink" title="1.3 自动售票机的例子"></a>1.3 自动售票机的例子</h4><p>售票机：当顾客为他们的票价投入正确的钱时，售票机会打印一张票。</p>
<p>我们的售票机的工作原理是：客户将钱插入其中，然后要求打印门票。一台机器在运行过程中不断计算它所收集的资金总额。</p>
<p>简要分析，如下图</p>
<p><img src="https://pic.imgdb.cn/item/672379dad29ded1a8c66518e.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketMachine</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPrompt</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getMoney</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTicket</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showBalance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> PRICE;</span><br><span class="line">    <span class="keyword">int</span> balance;	<span class="comment">// 外汇balance指的就是账户资金的变化</span></span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>::</code>的解释：。。。</p>
<h4 id="1-4-头文件"><a href="#1-4-头文件" class="headerlink" title="1.4 头文件"></a>1.4 头文件</h4><h5 id="1-4-1-类的定义"><a href="#1-4-1-类的定义" class="headerlink" title="1.4.1 类的定义"></a>1.4.1 类的定义</h5><p>在C++中，使用<strong>分开的.h和.cpp文件</strong>来定义一个类。<br>该类中的类声明和原型位于头文件（.h）中。<br>这些函数的所有主体都在源文件（.cpp）中。</p>
<h5 id="1-4-2-头文件"><a href="#1-4-2-头文件" class="headerlink" title="1.4.2 头文件"></a>1.4.2 头文件</h5><p>如果在头文件中声明了一个函数，则必须在使用该函数和定义该函数的所有位置都包含该头文件。<br>如果在头文件中声明了一个类，则必须在使用该类和定义类成员函数的所有位置都包含该头文件</p>
<ul>
<li>Declarations VS Definitions（声明 VS 定义）<ul>
<li>.cpp文件是一个编译单元</li>
<li>.h中只允许包含声明<ul>
<li><code>extern</code>变量</li>
<li>功能原型</li>
<li>类/结构体声明</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>标准头文件结构</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_FLAG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_FLAG</span></span><br><span class="line"><span class="comment">// Type declaration here...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// HEADER_FLAG</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>.h文件编写提示</strong><ul>
<li><ol>
<li>每个头文件一个类声明</li>
</ol>
</li>
<li><ol>
<li>与文件名前缀相同的一个源文件相关联。</li>
</ol>
</li>
<li><ol>
<li>头文件的内容以<code>#ifndef</code>、<code>#define</code>、<code>#endif</code>包围。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="1-5-时钟的例子"><a href="#1-5-时钟的例子" class="headerlink" title="1.5 时钟的例子"></a>1.5 时钟的例子</h4><h5 id="1-5-1-问题描述"><a href="#1-5-1-问题描述" class="headerlink" title="1.5.1 问题描述"></a>1.5.1 问题描述</h5><p>通过编写程序，来仿真一个时钟。</p>
<p>如果甲方只跟你说：我现在要一个钟，要求这个钟会一分钟一分钟地运行。</p>
<p>面对这么简单地要求，我们很容易想到写个函数，用个循环结构实现即可。但是我们现在在学c++，所以要去想办法从这里面用<strong>面向对象的角度</strong>去看这件事：即我们不去关注它的过程是怎么样的，我们关注的是有什么东西(对象)。</p>
<p>从一个时钟中你看到什么东西，你能不能看到它里面有什么样的东西，你能不能看到这个东西是什么样的东西组成的。当然整个时钟肯定是一个对象，那么这个时钟里面的再分能分成什么样的对象</p>
<ul>
<li>第一种分法：分成小时对象+分钟对象</li>
<li>第二种分法：将时钟的数字分成一个个数码管对象</li>
</ul>
<p>上面提到的这两种分法就是你在做一个对象的定义的设计的时候，你以什么样的角度去看这个问题。</p>
<blockquote>
<p>再比如：如果我现在要划分一下一个人的身体构造的时候，你是把这个人的身体划分成一个个不同功能的器官，还是直接划分成一个个细胞。这是两种不同的看待问题/编写程序的思想</p>
</blockquote>
<h5 id="1-5-2-抽象的概念"><a href="#1-5-2-抽象的概念" class="headerlink" title="1.5.2 抽象的概念"></a>1.5.2 抽象的概念</h5><p>下面就要介绍一个术语叫做<strong>Abstract(抽象)</strong></p>
<p><strong>抽象</strong>是一种忽略零件细节的能力，将注意力集中在更高层次的问题上。<br><strong>模块化</strong>是指将一个整体分解为定义明确的部分，这些部分可以分别构建和检查，并且以定义明确的方式相互交互。 </p>
<p><img src="https://pic.imgdb.cn/item/6725e095d29ded1a8c7b97b9.png" alt="image.png"></p>
<p><img src="https://pic.imgdb.cn/item/6725e0eed29ded1a8c7bebcb.png" style="zoom:40%"></p>
<p><strong>Implementation - ClockDisplay</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClockDisplay</span> &#123;</span></span><br><span class="line">    NumberDisplay hours;</span><br><span class="line">    NumberDisplay minutes;</span><br><span class="line">    Constructor <span class="keyword">and</span> methods omitted.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberDisplay</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Constructor <span class="keyword">and</span> methods omitted.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-面向对象的组成"><a href="#2-面向对象的组成" class="headerlink" title="2. 面向对象的组成"></a>2. 面向对象的组成</h3><h4 id="2-1-局部变量-Local-Variables-和成员变量-Fields"><a href="#2-1-局部变量-Local-Variables-和成员变量-Fields" class="headerlink" title="2.1 局部变量(Local Variables)和成员变量(Fields)"></a>2.1 局部变量(Local Variables)和成员变量(Fields)</h4><p>局部变量在方法内部定义，其作用域仅限于它们所属的方法。</p>
<p>注意：与成员变量(Fields)同名的局部变量将阻止从方法内访问该成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TicketMachine::refundBalance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> amountToRefund;		<span class="comment">// 局部变量</span></span><br><span class="line">    amountToRefund = balance;</span><br><span class="line">    balance = <span class="number">0</span>;			<span class="comment">// 这是自动售票机中的成员变量</span></span><br><span class="line">    <span class="keyword">return</span> amountToRefund;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>成员变量/字段(Fields)、参数(Parameters)、局部变量(Local Variables)，这三种变量都能够存储适合其定义类型的值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">参数（parameters）和本地变量（local variables）是完全相同的东西：</span><br><span class="line"></span><br><span class="line">(1) 它们的存储属性都是本地存储（进入函数之前它们都不存在，进入函数之后他们才会存在）；两种变量都会放在名为“堆栈（stack）”的地方，但是在堆栈中的具体位置还是有所不同的。</span><br><span class="line"></span><br><span class="line">(2) 形式参数和本地变量仅在构造函数或方法执行期间持续存在。它们的生存期仅相当于一次调用，因此在调用之间会丢失它们的值。因此，它们担当临时存储而不是永久存储。</span><br><span class="line"></span><br><span class="line">(3) 形式参数在构造函数或方法的头部定义。它们从外部接收其值，由来自构造函数或方法调用部分的实际参数值初始化。</span><br></pre></td></tr></table></figure>
<h4 id="2-2-组成类的两种要素：成员变量和成员函数"><a href="#2-2-组成类的两种要素：成员变量和成员函数" class="headerlink" title="2.2 组成类的两种要素：成员变量和成员函数"></a>2.2 组成类的两种要素：成员变量和成员函数</h4><ul>
<li><p>字段(Fields)在构造函数和方法之外定义的，是类的<strong>成员变量</strong>。 </p>
<ul>
<li>全局变量的声明（添加 <code>extern</code> 修饰），只是在告诉编译器“我知道有一个全局变量，但是我不知道它在哪”；而字段就是这样的，它是一种<strong>成员变量</strong>，成员变量是写在类的声明里面的。</li>
</ul>
</li>
<li>字段(Fields)用于存储在对象生命周期内持续存在的数据。因此，它们保持对象的当前状态。它们的寿命与物体的寿命一样长。</li>
<li>字段(Fields)具有类作用域：它们的可访问性扩展了整个类，因此它们可以在定义它们的类的任何构造函数或方法中使用。</li>
<li>字段(Fields)只在实例化的时候才“真正存在”，在类Class中的字段(Fields)可以理解为只是一种“声明”（某个地方有这个成员变量），但是类并拥有成员变量，类的实例化对象才拥有成员变量。</li>
</ul>
<ul>
<li><strong>方法/函数是属于类的，不是属于实例化对象的。</strong></li>
</ul>
<p>C++中类定义的形式如下：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    访问范围说明符:</span><br><span class="line">        成员变量<span class="number">1</span>;</span><br><span class="line">        成员变量<span class="number">2</span>;</span><br><span class="line">        ...</span><br><span class="line">        成员函数<span class="number">1</span>声明;</span><br><span class="line">        成员函数<span class="number">1</span>定义;</span><br><span class="line">        ...</span><br><span class="line">    访问范围说明符:</span><br><span class="line">        更多成员变量;</span><br><span class="line">        更多成员函数声明或定义;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">成员函数<span class="number">1</span>类型 类名::成员函数<span class="number">1</span>(参数列表)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>成员变量</strong>是在类中<strong>声明</strong>的变量；同样地，<strong>成员函数</strong>是指在类中<strong>声明</strong>的函数。如上类的形式所示，<strong>成员函数</strong>可以在<strong>类中定义</strong>，也可以在<strong>类外定义</strong>。在类外定义的函数需要用类名和<strong>作用域运算符</strong>（<code>类名::</code>）限定函数所属的类。</p>
<p><strong>而成员变量的定义在实例化对象，给变量分配内存的时候才会发生。</strong><br>此外关于类的声明和定义可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_35679960/article/details/78988454">如下文章</a>。简而言之，定义类只是在定义一个自己的数据类型；这与我们平时理解的声明和定义基本类型不同：类的声明和定义都不会分配内存，只有在实例化对象的时候才会分配内存。</p>
<h4 id="2-3-C-C-中-h与-cpp文件"><a href="#2-3-C-C-中-h与-cpp文件" class="headerlink" title="2.3 C/C++中.h与.cpp文件"></a>2.3 C/C++中.h与.cpp文件</h4><h5 id="2-3-1-头文件-h文件"><a href="#2-3-1-头文件-h文件" class="headerlink" title="2.3.1 头文件(.h文件)"></a>2.3.1 头文件(.h文件)</h5><p>一般来说，头文件仅仅用于声明，相应的定义要放在对应的cpp文件中。声明的内容一般可以是：    </p>
<ol>
<li>类定义体；（这里可参考”<a target="_blank" rel="noopener" href="https://blog.csdn.net/theworldkind/article/details/77967412">头文件为什么只声明不定义，而类定义又可以放在头文件中</a>“ 以及”<a target="_blank" rel="noopener" href="https://www.cnblogs.com/pluse/p/5768271.html">关于C++的变量和类的声明和定义</a>“）</li>
<li>类中的成员函数；</li>
<li>类外的函数（free函数）；</li>
<li><p>类外的变量；</p>
</li>
<li><p>类型；</p>
</li>
</ol>
<p>一个文件（比如main.cpp）包含（#include）了一个头文件（比如item.h），就相当于声明了Item.h中声明的所有内容。</p>
<p>但是<code>const</code>常量、<code>inline</code>函数、<code>static</code>函数都可以在头文件中定义（如果是初次学习C++，这点目前仅作了解，之后会慢慢学到）。</p>
<h5 id="2-3-2-源文件-cpp文件"><a href="#2-3-2-源文件-cpp文件" class="headerlink" title="2.3.2 源文件(.cpp文件)"></a>2.3.2 源文件(.cpp文件)</h5><p>.cpp文件用于定义，定义的内容一般可以是： </p>
<ol>
<li>类的成员函数；</li>
<li>类的静态成员变量；</li>
<li>类外的函数（free函数）；</li>
<li>类外的变量； </li>
</ol>
<h5 id="2-3-3-类内成员组成"><a href="#2-3-3-类内成员组成" class="headerlink" title="2.3.3 类内成员组成"></a>2.3.3 类内成员组成</h5><p>类：类一般只在头文件中定义，在cpp中实现其成员函数的定义；类中的成员包括：普通成员函数、static成员函数、普通成员变量、static成员变量、const成员变量、static const成员变量等。</p>
<ul>
<li><strong>普通成员函数</strong> —— 在类内部声明；可以在“类内部/头文件中的类外部”定义（均看作inline）；也可以放在cpp中定义（非inline）。（这点讲到《内联函数（Inline functions）》一章会展开）。</li>
<li><strong>static成员函数</strong> —— 类内部声明；可以在“类内部/cpp中”定义，不能在“头文件中的类外部”定义。在类外部定义的时候要去掉static关键字，因为类里面的static表示该成员属于类，而文件中的static表示文件作用域，这是完全两回事。（这点在下半部分学习笔记的《静态成员（static member）》小节会展开）。</li>
<li><strong>普通成员变量</strong> —— 类内部声明和定义；只能在构造函数的初始化列表中初始化，用户可以不进行初始化（编译器将默认构造）。（这点讲到《构造和析构（Constructor &amp; Destructor）》一章会展开讲）。</li>
<li><strong>static成员变量</strong> —— 类内部声明；只能在cpp中的各方法(函数)外部定义（且不能加static关键词，原因同static成员函数），定义时可以不进行初始化，这时默认为0（也可以不定义，但若使用到了该成员变量，则必须定义，否则连接出错） 。（这点在下半部分学习笔记的《静态成员（static member）》小节会展开）。</li>
<li><strong>const成员变量</strong> —— 类内部声明；只能在构造函数的初始化列表中初始化，而且用户必须自行初始化。（这点讲到《Const》一章会展开）。</li>
<li><strong>static const成员变量</strong> —— 基本同static；特别之处在于，static const成员变量是唯一可以在定义的时候（即类内部）直接初始化的类成员变量；注：static和static const不能在构造函数初始化列表中初始化，因为static关键字表明，它属于类，而不是属于对象；</li>
</ul>
<h4 id="2-4-this关键字"><a href="#2-4-this关键字" class="headerlink" title="2.4 this关键字"></a>2.4 this关键字</h4><p>类是抽象的、是虚的，更像是一种概念，<strong>不是实体，它不拥有它声明的任何一个变量，只有类的对象才是实体，才拥有那些变量</strong>。类和对象间变量的关系有点类似于C语言中<strong>结构体与结构体变量</strong>之间变量的关系。但是定义在类中的函数是属于类的，而不属于类的任何一个对象。总结为一句话就是：类拥有函数而不拥有变量；对象拥有变量而不拥有函数。</p>
<p>由上述关系可知：假设一个类Class的成员函数<code>f()</code>要对字段进行操作，C++是如何知道Class的不同对象调用<code>f()</code>时是谁在调用<code>f( )</code>，以便对各自的字段进行操作的呢？</p>
<p>在C语言中，为了实现上述操作通常需要<strong>传递指针</strong>给函数<code>f( )</code>，在C++中，这个指针通过<code>this</code>关键字实现。</p>
<p><code>this</code>：隐藏参数，这是类的所有成员函数的隐藏参数，不需要手动定义，具有类的类型。</p>
<blockquote>
<p>在成员函数里面，当它去用到成员变量的时候，实际上所有的成员变量前面都可以看作是有<code>this-&gt;成员变量</code>。</p>
</blockquote>
<p><code>this</code>：<strong>指向调用者的指针</strong>，在成员函数内部，您可以使用<code>this</code>作为指向调用函数的变量的指针。这是所有不能定义但可以直接使用的类成员函数的自然局部变量。</p>
<h4 id="2-5-构造和析构（Constructor-amp-Destructor）"><a href="#2-5-构造和析构（Constructor-amp-Destructor）" class="headerlink" title="2.5 构造和析构（Constructor &amp; Destructor）"></a>2.5 构造和析构（Constructor &amp; Destructor）</h4><h5 id="2-5-1-构造函数"><a href="#2-5-1-构造函数" class="headerlink" title="2.5.1 构造函数"></a>2.5.1 构造函数</h5><p>考虑到效率，C++没有规范地约束在生成对象时必须对其初始化（其他一些OOP语言比如Java存在此约束）。如果程序员自己写 <code>init()</code> 函数则需要依赖于他的自觉性（即有没有在生成对象后立刻调用<code>init()</code>，否则就会出问题），所以我们需要一种机制来确保生成对象后一定会被初始化，这便是<strong>constructor构造函数</strong>的由来。</p>
<ul>
<li><strong>构造函数</strong>名字必须与类名相同（包括大小写）；</li>
<li>构造函数没有返回类型(<code>void</code>也不算)；</li>
<li><strong>构造函数会在类的对象被创建时自动被调用；</strong>（所以一般构造函数用于初始化操作）</li>
<li>构造函数可以有参数，对应在创建对象时也需要传个参数；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Tree</span>(<span class="keyword">int</span> i) &#123;...&#125;    <span class="comment">//构造函数</span></span><br><span class="line"><span class="function">Tree <span class="title">t</span><span class="params">(<span class="number">12</span>)</span></span>;          <span class="comment">//创建对象</span></span><br></pre></td></tr></table></figure>
<p>只要不带参数的构造函数都称为“<strong>default constructor</strong>”；而编译器给你的的构造函数称为“<strong>auto default constructor</strong>”，<strong>当你定义了带参构造函数却没有在生成对象时正确调用，编译器会去寻找default constructor调用。</strong> </p>
<h5 id="2-5-2-析构函数"><a href="#2-5-2-析构函数" class="headerlink" title="2.5.2 析构函数"></a>2.5.2 析构函数</h5><ul>
<li><strong>析构函数</strong>即在构造函数名字前加一个波浪号（~）</li>
<li>析构函数会在对象要被“<strong>消灭</strong>”掉的时候自动被调用；（比如在一个大括号内创建栈对象的话，离开大括号范围的时候对象就会被“消灭”掉）</li>
<li>根据析构函数的特性，我们一般会用析构函数来释放掉对象生存期间申请的资源，保证这些资源不会随着对象被“消灭”掉之后一并被带到“棺材”里面去；</li>
<li>析构函数也没有返回类型，而且不能有参数；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">Y</span>();	<span class="comment">// 析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="2-5-3-初始化列表（Initializer-list）"><a href="#2-5-3-初始化列表（Initializer-list）" class="headerlink" title="2.5.3 初始化列表（Initializer list）"></a>2.5.3 初始化列表（Initializer list）</h5><p>除了使用构造函数来做初始化，C++还提供了另一种初始化方法：<strong>初始化列表</strong>；</p>
<ul>
<li>在构造函数的圆括号后面加上冒号，冒号后面跟上成员变量的名字，最后用括号给出初始值；</li>
<li>初始化列表可以初始化任何类型的数据；</li>
<li><strong>初始化列表会早于构造函数被执行；</strong></li>
<li>严格来说，初始化列表做的工作才是初始化；而构造函数做的工作可以称作为“赋值”，构造函数会做两件事：1. 初始化（这个时候你没有明确告诉编译器用什么内容来初始化）；2. 赋值； </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> x, y;</span><br><span class="line">        <span class="built_in">Point</span>(<span class="keyword">float</span> xa = <span class="number">0.0</span>, <span class="keyword">float</span> ya = <span class="number">0.0</span>) : <span class="built_in">y</span>(ya), <span class="built_in">x</span>(xa)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="2-5-4-存储分配"><a href="#2-5-4-存储分配" class="headerlink" title="2.5.4 存储分配"></a>2.5.4 存储分配</h5><p>编译器在作用域的左括号处为该作用域分配所有存储空间，但是构造函数调用直到运行到定义对象的那一行才发生。</p>
<h4 id="2-6-new-amp-delete（动态地制造对象）"><a href="#2-6-new-amp-delete（动态地制造对象）" class="headerlink" title="2.6 new &amp; delete（动态地制造对象）"></a>2.6 new &amp; delete（动态地制造对象）</h4><p>在C语言中，我们通过<code>malloc</code>与<code>free</code>动态地申请和释放内存；在C++，则是用两个新的运算符关键字<code>new</code>和<code>delete</code>来制造和收回一个对象的。</p>
<p>如果<code>new</code>一个变量，则只需做一件事情：分配一个变量的空间；但是如果<code>new</code>一个对象，则<code>new</code>会做两件事情：<strong>① 分配一个对象的空间</strong>；<strong>② 调用构造函数</strong>；当然最后作为一个运算符会返回分配给对象的地址。而<code>delete</code>做的事情与<code>free</code>类似，你给它一个地址，然后它delete掉。对于delete一个对象：<strong>① 调用析构函数</strong>；<strong>② 收回内存空间</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">new</span> Stash;</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *psome = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];	<span class="comment">// new运算符返回块的第一个元素的地址。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> [] psome;	<span class="comment">// 括号的出现告诉程序应该释放整个数组，而不仅仅是元素</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>new</code>出来的东西会放在<strong>堆</strong>里面；</li>
<li>动态申请的内存完全由开发者自行负责管理，开发者对堆对象的生存周期具有完全的支配权(在何时申请内存，分配多少内存，并在何时释放该内存)；</li>
<li>由上一条可知：在堆中的对象不会自动被消灭，内存不会自动回收，<code>new</code>出来的对象在程序运行过程中会一直占用内存空间，直到开发者在代码中主动<code>delete</code>掉它或者程序进程整体退出；</li>
<li>程序进程退出时的内存回收是系统级的，系统会回收分配给该进程的所有内存。但那个时候系统就并不关心你程序里面是如何使用它的了；也就是说系统仅仅是回收内存，不会再帮你调用析构函数了；</li>
<li>我们知道<code>new</code>作为一个运算符会返回分配给对象的地址。如果我们把<code>new</code>返回的地址交给局部指针变量，根据第一章成员变量的秘密我们知道局部变量担任临时存储，那么局部指针变量一但离开局部空间后被销毁，我们就再也无法访问到<code>new</code>申请的内存了。下面是一个代码例：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">	~<span class="built_in">A</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(string str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		A* p = <span class="keyword">new</span> <span class="built_in">A</span>();         <span class="comment">//把new返回的地址交给局部指针变量</span></span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;<span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>);    <span class="comment">//此时指针变量p已经被销毁，但new申请的内存还没有回收</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会给出如下错误： </p>
<p><img src="https://pic.imgdb.cn/item/6735bdb8d29ded1a8c7b50eb.png"></p>
<ul>
<li><code>new</code>和<code>delete</code>的使用小技巧<ul>
<li>不要用<code>delete</code>去释放不是<code>new</code>分配出来的空间；</li>
<li>不要连续两次用<code>delete</code>释放同一块空间；</li>
<li>如果用<code>new []</code>分配了一块数组，请用<code>delete []</code>；同样地如果用<code>new</code>分配了单个实体，请用<code>delete</code>；</li>
<li>如果<code>new []</code>了之后用<code>delete</code>释放的话，仅会调用<code>delete</code>指针指向的对象的析构函数，虽然同样回收所有空间，但是会报错。（例如下方贴的代码）</li>
<li><code>delete</code>一个空指针是安全的；</li>
<li><code>new</code>出来的对象在使用完毕后不<code>delete</code>是非常危险的！对于长时间运行的程序很容易造成内存泄漏；</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123; i = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; &#125;            <span class="comment">//构造函数</span></span><br><span class="line">        ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A(),i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;         <span class="comment">//析构函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">this</span>-&gt;i = i; &#125;    </span><br><span class="line">        <span class="comment">//根据就近原则，成员变量i会被参数i屏蔽，需要加this指针表示“调用这个函数的对象的i”</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        A* p = <span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                p[i].<span class="built_in">set</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> p;        </span><br><span class="line">        <span class="comment">//尝试用delete回收new []分配的空间，若要正确运行请改为“delete[] p;”</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-访问限制（Setting-limits）"><a href="#2-7-访问限制（Setting-limits）" class="headerlink" title="2.7 访问限制（Setting limits）"></a>2.7 访问限制（Setting limits）</h4><p>在OOP理论阶段学习过：对象应该是被封装起来的受保护的，对象里面的数据是不被别人直接访问的。别人能访问的只有你的函数，可以通过你的函数要求你做事情；但是这个函数具体怎么做？会对你的数据产生什么样的影响？是由你的代码决定的。</p>
<p>所以我们需要一种机制，使得使用你的类的人不会随心所欲地访问内部的东西；同时设计类的人可以去修改内部的东西而不至于影响到使用者。对C++来说，所有的成员可以有三种访问属性：public、private以及protected。</p>
<ul>
<li>public没什么好说的，任何人都能访问；</li>
<li>private只有自己（这个类中的成员函数）能访问，private可以修饰变量与函数；<ul>
<li><strong>注意private私有性是对类来说的，而不是对象</strong>！<strong>同一个类的不同对象之间是可以互相访问私有的成员变量的</strong>。(如下面的代码示例)</li>
<li>此外，C++对private权限的限制仅仅存在于编译时刻，到了运行时刻就没人管这件事了，原因是C++的OOP特性只在源代码层面体现，编译完后生成的.o文件同C语言、汇编语言、Pascal生成的.o文件是一模一样的。所以只要有办法过了编译那一关，剩下的事情就可以为所欲为了。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; i = <span class="number">0</span>; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; &#125;            <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A(),i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;         <span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">this</span>-&gt;i = i; cout &lt;&lt; <span class="string">&quot;this-&gt;i=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;i &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A* q)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::g(),q-&gt;i=&quot;</span> &lt;&lt; q-&gt;i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">50</span>);</span><br><span class="line">    A b;</span><br><span class="line">    b.<span class="built_in">set</span>(<span class="number">100</span>);</span><br><span class="line">    a.<span class="built_in">g</span>(&amp;b);    <span class="comment">//尝试用a中的成员函数g(A* q)访问b中的私有成员变量i；</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++还有个破坏OOP原则的东西叫做<code>friends</code>：你可以声明别人（可以是别的类，可以是别的不属于任何类的<code>free</code>函数，也可以是别的类里的某个函数）是你的<code>friend</code>（朋友），一旦声明过后，他就可以访问你的<code>private</code>的东西了；</p>
<p>但是不能是你声明你是别人的朋友，然后去访问别人的私有的东西。就像啊我声明：“我是小明的朋友，所以我可以用他的钱”，这是不行的，不是这么玩的。是由类自己决定谁可以访问自己的成员的。</p>
<p>同样的<code>friend</code>的授权是在编译时刻检查的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///演示代码，无法运行</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>;</span>    <span class="comment">// 前向声明</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(X*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(X*, <span class="keyword">int</span>)</span></span>;     <span class="comment">// free函数是friend</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Y::f</span><span class="params">(X*)</span></span>;       <span class="comment">// 结构体成员函数是friend</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">Z</span>;</span>            <span class="comment">// 整个结构体是friend</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(X* x, <span class="keyword">int</span> i)</span> </span>&#123;	<span class="comment">// free函数是friend</span></span><br><span class="line">        x-&gt;i = i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Y::f</span><span class="params">(X* x)</span> </span>&#123;	<span class="comment">// 结构体成员函数是friend</span></span><br><span class="line">        x-&gt;i = <span class="number">47</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Z</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>protected表示只有<strong>这个类</strong>自己以及<strong>它的“子子孙孙”</strong>（子类以及再往下的这些）可以访问；</li>
<li>在设计中，我们一般按下面的方式规划所有东西的访问限制：<ul>
<li>所有的数据（一般指成员变量）都是private的，外界及子类都不能直接访问；</li>
<li>提供给所有人（包括外界和子类）使用的东西是public的；</li>
<li>留给子类protected的接口以访问父类中private的数据；</li>
</ul>
</li>
</ul>
<h3 id="3-对象组合（Object-composition）"><a href="#3-对象组合（Object-composition）" class="headerlink" title="3. 对象组合（Object composition）"></a>3. 对象组合（Object composition）</h3><p>OOP三大特性即：封装、继承、多态性。但是从另外一个角度来说“<strong>继承是OOP对软件重用的回答</strong>”或者说“<strong>继承是OOP实现软件重用的一种方式</strong>”。这一章要讲的就是“重用的实现”（Reusing the implementation），但这里先不讲继承。在C++里面，我们还可以以另外一种方式实现软件重用，即“组合”（composition）：用现有的对象构造新对象(把已有的对象组合成新的对象)。 </p>
<blockquote>
<p>组合的关系是一种<strong>has a</strong>的关系； </p>
<p>比如说谈到一辆车，我们会说这辆车<strong>has a</strong>引擎，<strong>has a</strong>方向盘，<strong>has a</strong>空调，<strong>has a</strong> 轮胎……如果我们已经有了引擎、方向盘、空调、轮胎……的对象，我们把它们放在一起，再加一些其他的细节，以这种方式来实现软件的重用，于是我们组合出了一辆车对象。</p>
</blockquote>
<p>“组合”其实在谈OOP的五条原则五条原则时提到过，即“<strong>对象里面还是对象</strong>”；反映到C++的代码上即我们在设计一个类的时候它的成员变量可以是另外一个类的对象。在实际设计中，C++提供了两种不同的内存模型：<strong>fully &amp; by reference</strong>；</p>
<p><strong>fully</strong>表示“那个别的类的对象就是我这个类里的一部分（成员变量是对象本身）”  ；</p>
<p><strong>by reference</strong>表示“那个别的类的对象我知道在哪里，我可以访问到它（成员变量是指针），我可以调用它的方法，但它并不是我这个类里的一部分” ；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        A a;      <span class="comment">//fully</span></span><br><span class="line">        A* aa;    <span class="comment">//by reference</span></span><br><span class="line"> </span><br><span class="line">        B* bb;    </span><br><span class="line"><span class="comment">/*by reference允许成员变量的类型是其本身，而fully无法做到这一点(会陷入无限循环)</span></span><br><span class="line"><span class="comment">因为指针对编译器来说就仅仅是一个指针而已，无论指针所指的类型是什么，</span></span><br><span class="line"><span class="comment">它永远都只是那4个字节（32位系统），编译器不需要知道指针的细节，</span></span><br><span class="line"><span class="comment">指针的细节只有到用的时候才需要，所以不会陷入死循环。</span></span><br><span class="line"><span class="comment">在C语言中的“链表”就是这么干的*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*实际设计中，采用fully还是by reference是根据语义来的，</span></span><br><span class="line"><span class="comment">你认为合适把那个对象直接放在你的类里面，你就用fully，不合适就用by reference</span></span><br><span class="line"><span class="comment">比如你设计一个“同学”对象：他的“大脑”对象显然应该放在“身体”（类）里面（fully），</span></span><br><span class="line"><span class="comment">而他的“书包”对象就不太适合放在“身体”里面（by reference）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">或者以设计一个“收音机”对象为例，作为收音机你肯定是可以听电台嘛，但是在设计“收音机”类</span></span><br><span class="line"><span class="comment">的时候你不应该直接把一个“电台”对象（包括什么录音室、主持人、热线电话、接线员等等等等）</span></span><br><span class="line"><span class="comment">直接放（fully）进你的类里面吧，往往都是通过固定频段（比如FM101.7）去访问电台对象吧，</span></span><br><span class="line"><span class="comment">这个固定频段就可以理解为指针嘛（by reference）*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在组合中我们并不希望破坏对象的边界，于是更好的做法便是<strong>各个对象的初始化由初始化列表调用各自的构造函数完成</strong>，初始化列表也就是用来干这个的。以下面这段代码为例： </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *银行储蓄账户对象实例，类中包含人和货币对象(演示代码不能运行)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Currency</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingAccount</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SavingAccount</span>( <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* address, </span><br><span class="line">        <span class="keyword">int</span> cents ) : <span class="built_in">m_saver</span>(name, address), <span class="built_in">m_balance</span>(<span class="number">0</span>, cents) &#123; ... &#125;  <span class="comment">//构造函数</span></span><br><span class="line">        <span class="comment">//我们在初始化列表中调用了m_saver和m_balance的构造函数，然后把相应的参数传给他们</span></span><br><span class="line"> </span><br><span class="line">        ~<span class="built_in">SavingAccount</span>() &#123; ... &#125;   <span class="comment">//析构函数</span></span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">prints</span><span class="params">()</span></span>&#123;</span><br><span class="line">            m_saver.<span class="built_in">print</span>();</span><br><span class="line">            m_balance.<span class="built_in">print</span>();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        Person m_saver;        <span class="comment">//fully</span></span><br><span class="line">        Currency m_balance;    <span class="comment">//fully</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *附加思考题：</span></span><br><span class="line"><span class="comment"> *这里组合进来的两个对象m_saver和m_balance的属性是private</span></span><br><span class="line"><span class="comment"> *假如我们把他俩放到public里面去会怎样呢？</span></span><br><span class="line"><span class="comment"> *那我们就有可能做这样的事情：</span></span><br><span class="line"><span class="comment"> *		SavingAccount account</span></span><br><span class="line"><span class="comment"> *		account.m_saver.set_name(&quot;Fred&quot;);(假设Person类有set_name())</span></span><br><span class="line"><span class="comment"> *虽然m_saver和m_balance是对象，但是他俩也是SavingAccount类的成员变量；</span></span><br><span class="line"><span class="comment"> *在OOP理论阶段学习过成员变量作为数据应该是包裹起来不被外界直接访问的。</span></span><br><span class="line"><span class="comment"> *所以这显然不是OOP喜欢的，因为他突破了边界，外界可以直接访问里面的数据了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果我们将构造函数编写为（假设我们已经为子对象设置了访问器）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SavingAccount</span>( <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* address, <span class="keyword">int</span> cents )</span><br><span class="line">&#123;</span><br><span class="line">    m_saver.<span class="built_in">set_name</span>(name);</span><br><span class="line">    m_saver.<span class="built_in">set_address</span>(address);</span><br><span class="line">    m_balance.<span class="function">set <span class="title">cents</span><span class="params">(cents)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将调用默认构造函数，效率低。</p>
</blockquote>
<p>再举一个可运行的简单代码例子 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> i) &#123; <span class="keyword">this</span>-&gt;i = i; cout &lt;&lt; <span class="string">&quot;A::A(),A::i=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="keyword">int</span> j) : <span class="built_in">a</span>(j+<span class="number">1</span>) &#123; <span class="keyword">this</span>-&gt;j = j; cout &lt;&lt; <span class="string">&quot;B::B(),B::j=&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;j &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">//在B的初始化列表中调用了a的构造函数，并将j+1作为参数传给了他</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-继承（Inheritance）"><a href="#4-继承（Inheritance）" class="headerlink" title="4. 继承（Inheritance）"></a>4. 继承（Inheritance）</h3><h4 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h4><p>不同于对象组合，<strong>继承是拿已有的类克隆一份，然后对复制品在已有的基础上增添一些细节或者做一些改造，得到一个新的类</strong>。 在《This关键字的出现》那我们提到过“类是虚的，对象才是实的”，所以我们可以理解为C++里继承是玩虚的，组合是玩实的。</p>
<ul>
<li>继承是C++语言一门重要的技术，也是面向对象设计方法的重要组成部分；</li>
<li>继承使得我们可以共享设计中的：成员数据、成员函数、<strong>接口(Interface，一个类中对外公开的部分称之为“接口”)</strong>；</li>
<li>继承是将一个类的行为或实现定义为另一个类的<strong>超集（superset）</strong>的能力；</li>
<li>对于继承来说，类之间的关系是一种<strong>“is a”</strong>的关系；以下图为例，我们可以说：A student is a person.  Student is a superset of Person.</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6736b926d29ded1a8c3249df.png" style="zoom:60%"></p>
<ul>
<li>C++继承语法为：<strong>类名后面冒号public另外一个类</strong>，于是它就是另外一个类的子类了，如下代码所示：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>():<span class="built_in">i</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; &#125;	<span class="comment">//构造函数</span></span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; &#125;		<span class="comment">//析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;A::print(),i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:		<span class="comment">//protected访问属性详情参考《访问限制（Setting limits）》一章</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i = ii; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;		<span class="comment">//C++继承语法，表示B类是A类的子类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		<span class="built_in">set</span>(<span class="number">20</span>); <span class="built_in">print</span>();	<span class="comment">//子类中新增的函数可以调用父类中public的函数</span></span><br><span class="line">		<span class="comment">//i = 30;			//子类不能直接访问父类中private的成员变量</span></span><br><span class="line">    &#125;	</span><br><span class="line">	<span class="comment">//需要注意的是，子类虽然拥有父类private的东西，但是不能直接访问他们</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;			<span class="comment">//子类拥有父类的包括public和private的所有东西</span></span><br><span class="line">	<span class="comment">//b.set(10);	//protected访问限制main里面（外界）不能调用set函数	</span></span><br><span class="line">	b.<span class="built_in">print</span>();</span><br><span class="line">	b.<span class="built_in">f</span>();			<span class="comment">//子类还可以在父类基础上拓展新东西</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>父类、子类、用户类（外界）</strong>三者的关系可由下图表示： </li>
</ul>
<p><img src="https://pic.imgdb.cn/item/675696a1d0e0a243d4e04003.png" style="zoom:70%"></p>
<h4 id="4-2-父类子类的关系"><a href="#4-2-父类子类的关系" class="headerlink" title="4.2 父类子类的关系"></a>4.2 父类子类的关系</h4><p>在《对象组合（Object composition）》一章中我们提到过：各个对象的初始化由初始化列表调用各自的构造函数完成。当时给出的理由是为了避免破坏对象的边界，但是却没有尝试如果不这样做会怎么样。</p>
<p>由《继承（Inheritance）》一章中我们得知子类拥有父类的所有东西，这其实可以看作是父类整个“fully”进子类了。所以，在创建子类的对象时，父类的构造函数会自动被调用。《继承（Inheritance）》一章中的演示代码可以看到类A有一个default constructor，为了演示<strong>初始化列表</strong>的重要性，这里我们对演示代码做一些小改动，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> ii):<span class="built_in">i</span>(ii) &#123; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; &#125;	<span class="comment">//A的构造函数改为带参构造函数</span></span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; &#125;		</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;A::f(),i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i = ii; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;		<span class="comment">//C++继承语法，表示B类是A类的子类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">set</span>(<span class="number">20</span>); <span class="built_in">print</span>(); &#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//B类没有自己的构造函数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;			<span class="comment">//生成子类对象</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码会产生错误，具体请复制到编译器查看。</p>
<p>同样B类中都没有构造函数，为什么仅仅把A类的构造函数改成带参构造函数就无法运行呢？而且这个错误信息看起来毫无头绪。</p>
<p>这就要提到C++里继承的本质了。我们在创建B的对象时，首先会分配一块空间给B，随后进行初始化。而B的对象里面有A的所有东西，所以要初始化B的对象，那么B里面的A类的对象的那部分也要被初始化。而显然，A的带参构造函数没有被正确调用，那么编译器会去寻找默认构造函数去调用。这一点在《构造和析构（Constructor &amp; Destructor）》一章中提到过。</p>
<p>所以，无论是组合还是继承这一点都是一样的：<strong>当你的身体里有其他类的对象的时候，你不懂怎么去初始化他，必须把初始化的工作交给他们自己去做</strong>。这样做对象的边界仍然是清晰的，也可以避免一些莫名其妙的错误。</p>
<p>所以，上面的代码你必须得想办法去调用A的构造函数传参给它，而我们知道构造函数都是创建对象时自动调用的，而我们没法主动调用它。怎么做呢？答案就是：<strong><font color="red">初始化列表</font></strong>。所以，我们只需要给B加个构造函数，比如下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;		</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span> () : <span class="built_in">A</span> (<span class="number">15</span>) &#123;&#125;	<span class="comment">// 初始化列表</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">set</span>(<span class="number">20</span>); <span class="built_in">print</span>(); &#125;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后提一下：当父类和子类都有自己的<strong>构造函数</strong>和<strong>析构函数</strong>时，创建子类对象会先构造父类，再构造子类；退出时先析构子类，再析构父类（先进后出） 。 </p>
<h4 id="4-3-名字隐藏（Name-hiding）"><a href="#4-3-名字隐藏（Name-hiding）" class="headerlink" title="4.3 名字隐藏（Name hiding）"></a>4.3 名字隐藏（Name hiding）</h4><p>在C++中有一个仅此一家的机制：<strong>名字隐藏</strong>。以下方代码为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> ii) :<span class="built_in">i</span>(ii) &#123; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span> &lt;&lt; endl; &#125;	</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::print()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cout &lt;&lt; i; <span class="built_in">print</span>(); &#125;		<span class="comment">//父类中有函数重载</span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i = ii; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;		</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() : <span class="built_in">A</span>(<span class="number">15</span>) &#123; cout &lt;&lt; <span class="string">&quot;B::B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::print()&quot;</span> &lt;&lt; endl; &#125;	</span><br><span class="line">	<span class="comment">//同时子类中出现了与父类重复的函数（函数名相同，参数表相同）</span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">set</span>(<span class="number">20</span>); <span class="built_in">print</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	B b;			</span><br><span class="line">	b.<span class="built_in">set</span>(<span class="number">10</span>);</span><br><span class="line">	b.<span class="built_in">print</span>();</span><br><span class="line">	b.<span class="built_in">f</span>();</span><br><span class="line">	b.<span class="built_in">print</span>(<span class="number">200</span>);    <span class="comment">//ERROR </span></span><br><span class="line">    <span class="comment">//子类拥有父类的所有东西，所以按理说B的对象b应该是有父类中print(int i)函数的</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码会产生错误，具体请复制到编译器查看。</p>
<p>这件事就称之为“<strong>名字隐藏</strong>” ，简单来说：<strong>假设父类中有一组重载函数，子类在继承父类时如果”覆盖”了这组重载函数中的任意一个，则其余没有被”覆盖”的同名函数在子类中是不可见的。</strong>只有C++是这么干的，其他OOP语言都不会出现这种情况。那么，C++为什么会这么干呢？</p>
<p>这其实还和另外一件事情只有C++这么干的有关系：以上面代码为例，对C++来说，子类中的print()函数跟父类中的print()函数其实是没有关系的；其他OOP语言在同样的情况下两个print()函数会构成一种关系：<strong>override（覆盖）</strong>。而C++认为他俩没关系的，只是碰巧重名了；而同时正因为他俩没关系，所以父类中的所有重载函数也必须得和子类没关系才行，要不然就乱套了。</p>
<p>如果你还是想要调用那个print(int i)，那句错误代码就要改成下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.A::<span class="built_in">print</span>(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<h3 id="5-函数重载和缺省参数（Function-overloading-amp-Default-arguments）"><a href="#5-函数重载和缺省参数（Function-overloading-amp-Default-arguments）" class="headerlink" title="5 函数重载和缺省参数（Function overloading &amp; Default arguments）"></a>5 函数重载和缺省参数（Function overloading &amp; Default arguments）</h3><h4 id="5-1-Function-overloading"><a href="#5-1-Function-overloading" class="headerlink" title="5.1 Function overloading"></a>5.1 Function overloading</h4><p>所谓<strong>函数重载</strong>是指一些函数可以具有相同的函数名，却拥有不同的参数表，他们之间便构成了重载的关系。请注意返回类型不是构成重载的条件（如果两个函数拥有相同的名称和参数列表，但是返回类型不同，是不构成重载关系的） 。</p>
<h4 id="5-2-缺省参数"><a href="#5-2-缺省参数" class="headerlink" title="5.2 缺省参数"></a>5.2 缺省参数</h4><p>所谓“缺省参数”，你可以在函数声明中预先给函数的参数表里部分或全部参数一个值，如果没有在函数调用中提供值，编译器将自动插入预先给的值；</p>
<ul>
<li>声明一个有参数列表的函数时，缺省参数必须从右到左添加；</li>
<li>缺省参数是写在头文件（.h）里的，并且不能在.cpp里面重复一遍；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">short</span> i = <span class="number">6</span>, <span class="keyword">double</span> j = <span class="number">1.23</span>)</span></span>;</span><br><span class="line"><span class="comment">//void f(int m, int n, short i = 6, double j) &#123;&#125;	//ERROR：默认实参不在形参列表的结尾</span></span><br></pre></td></tr></table></figure>
<p>有一点不要忘了：C/C++中<code>#include</code>的本质。编译器在编译之前有一个“<strong>预处理</strong>”过程，在预处理过程中，<code>.h</code>的内容会被展开到<code>.cpp</code>文件里面去。所以当你没有<code>#include a.h</code>的时候直接在<code>main.cpp</code>文件里把<code>a.h</code>的内容复制进来同样可以运行。看起来你好像把缺省参数写在<code>.cpp</code>文件里了，实际上你只是帮助编译器完成了“预处理”这一步的工作。</p>
<h3 id="6-内联函数（Inline-functions）"><a href="#6-内联函数（Inline-functions）" class="headerlink" title="6 内联函数（Inline functions）"></a>6 内联函数（Inline functions）</h3><ul>
<li>函数调用的额外开销：在执行命令之前，设备所需的处理时间<ul>
<li>push参数进栈</li>
<li>push返回地址</li>
<li>准备返回值（x86汇编一般会用AX（accumulator）累加寄存器存放返回值）</li>
<li>pop all pushed（把push进的都要pop出来）</li>
</ul>
</li>
</ul>
<p>C++提供了一个手段以避免上面这些额外开销：<strong>内联函数</strong>。如果这个函数是内联的，当我们去调用该函数时，C++不会真的去调用函数，去做那些“Push、Prepare、Call、Pop、Return”等等动作；<strong>而是把那个函数的代码嵌入到调用它的地方去，并且同时还会保持函数的独立性</strong>（函数有自己的空间：比如函数有自己的局部/本地变量，进去的时候存在，出来就不存在了；或者调用函数时需要对参数进行检查等这些事情都还是保留的）。</p>
<blockquote>
<p>其实，内联函数有点类似于<strong>宏定义函数</strong>。但是宏是不能做<strong>类型检查</strong>的；而inline作为函数是可以由编译器做<strong>类型检查</strong>的。</p>
</blockquote>
<p>内联前：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="built_in">f</span>(a);		</span><br><span class="line">			</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*对应汇编代码：</span></span><br><span class="line"><span class="comment">* _f_int:</span></span><br><span class="line"><span class="comment">*	add  ax,@sp[-8],@sp[-8]</span></span><br><span class="line"><span class="comment">*	ret</span></span><br><span class="line"><span class="comment">* _main:</span></span><br><span class="line"><span class="comment">*	add  sp,#8</span></span><br><span class="line"><span class="comment">*	mov  ax,#4</span></span><br><span class="line"><span class="comment">*	mov  @sp[-8],ax</span></span><br><span class="line"><span class="comment">*	mov	 ax,@sp[-8]</span></span><br><span class="line"><span class="comment">*	push ax</span></span><br><span class="line"><span class="comment">*	call _f_int</span></span><br><span class="line"><span class="comment">*	mov  @sp[-4],ax</span></span><br><span class="line"><span class="comment">*	pop  ax</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>内联后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;   <span class="comment">//加上inline关键字</span></span><br><span class="line">	<span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="built_in">f</span>(a);		<span class="comment">//实际生成的代码：int b = a+a;</span></span><br><span class="line">			</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*对应汇编代码：</span></span><br><span class="line"><span class="comment">* _main:</span></span><br><span class="line"><span class="comment">*	add  sp,#8</span></span><br><span class="line"><span class="comment">*	mov  ax,#4</span></span><br><span class="line"><span class="comment">*	mov  @sp[-8],ax</span></span><br><span class="line"><span class="comment">*	add  ax,@sp[-8],@sp[-8]</span></span><br><span class="line"><span class="comment">*	mov  @sp[-4],ax</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//可以看到最终生成的可执行代码里面是没有那个内联函数的，省去了很多工作</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一个内联函数在.obj文件(Linux平台下为.o文件)里可能不会生成任何代码；</li>
<li>与<strong>缺省参数</strong>不同的是，<strong>内联函数</strong>要求在声明和定义的时候都需要重复<strong>“inline”</strong>关键字，我们简化一下<strong>缺省参数</strong>里面那个代码例子； </li>
</ul>
<p>————————————————</p>
<p>内联函数的使用需要对编译器进行一系列调整，否则会出现一些错误，具体请参考参考链接的介绍。</p>
<p>对于<strong>内联函数</strong>来说，.cpp文件是完全不需要的，在.h里面把所有内联函数的“body”放进去就可以了；</p>
<p>————————————————</p>
<ul>
<li>综合以上所有，以下几种情况建议内联：<ul>
<li>只有两到三行的小函数； </li>
<li>频繁调用的函数（比如函数调用处在循环里，就会被频繁调用）； </li>
</ul>
</li>
<li>以下几种情况不建议内联：<ul>
<li>非常大的函数（比如超过20行的函数）；</li>
<li>递归函数；</li>
</ul>
</li>
</ul>
<p><strong><font color="blue">注意</font></strong>：你在类的声明（declaration）中定义（define）的任何函数都<strong>默认</strong>为内联函数；（就是在<code>.h</code>文件中本来只在类中声明成员方法，但是现在不仅声明了，还在<code>.h</code>文件中把成员函数的函数体也写出来了，那么这个成员方法就是内联函数）。</p>
<h3 id="10-Const"><a href="#10-Const" class="headerlink" title="10 Const"></a>10 Const</h3><h4 id="10-1-Const基础"><a href="#10-1-Const基础" class="headerlink" title="10.1 Const基础"></a>10.1 Const基础</h4><p>在C语言中，我们已经学习过一次<code>const</code>了，意思是<code>const</code>的变量<strong>被初始化之后不能被赋值</strong>，不过对于C++来说，<strong>const的变量仍然是变量，而不是常数</strong>，这是不一样的。因为对编译器来说，变量意味着它真的要在内存里面给你分配地址的，而常数意味着这只是编译器在编译过程中记在自己内存表里的一个实体。</p>
<p>而且，const的变量仍然遵循范围规则（scope rule），如果是本地变量，即便const了，还是进函数才有，出函数就没了。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个编译时刻知道值的const；</span></span><br><span class="line"><span class="comment">// 它的值必须初始化；</span></span><br><span class="line"><span class="comment">// 它可以用来定义数组长度（int buf[bufsize];）</span></span><br><span class="line"><span class="comment">// 除非你添加“extern”显式声明；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufsize = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个编译时刻不知道值的const；</span></span><br><span class="line"><span class="comment">// 不同于上面，它不可以用来定义数组长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufsize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器不会允许你修改其值；</span></span><br><span class="line"><span class="comment">// 这句代码意思是“bufsize是定义在某处的全局变量，同时这个全局变量是const”。对编译器来说：你说它是const，那么我就要求这个bufsize你可以用，但是你不能修改 。这和bufsize本身是不是真的是const没有关系；</span></span><br><span class="line"><span class="comment">// 它同样不可以用来定义数组长度；</span></span><br></pre></td></tr></table></figure>
<p>此外还有用<code>const</code>修饰指针：详情请移步至：<a target="_blank" rel="noopener" href="https://blog.csdn.net/YMGogre/article/details/123760858">浅谈const int <em>，int const </em>与int *const</a> </p>
<p><img src="https://pic.imgdb.cn/item/675ac408d0e0a243d4e2f96d.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* x)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*表示可以给这个函数任何int变量（无论是不是const），</span></span></span><br><span class="line"><span class="comment"><span class="function">对调用f函数的人来说，这表示你传给f函数的虽然是指针，</span></span></span><br><span class="line"><span class="comment"><span class="function">但f函数保证不会对你的东西做任何修改*/</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>const</code>可以修饰成员函数，<strong>表示该函数不会改变类的成员变量，也不会在该函数中调用类中其他非const的成员函数</strong></p>
<ul>
<li>在声明和定义的时候都要重复<code>const</code>关键字； </li>
<li>实质上是表明<code>this</code>是<code>const</code>（这一点会在下一章详细讲）；</li>
</ul>
</li>
<li><p>const可以修饰函数返回值，不过我们知道像返回int这种基本类型数据实际上是在返回一个值，返回值的函数不能作<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/513628368">左值</a>； </p>
<ul>
<li>除非你函数返回一个指针，但如果返回的指针是const那么它带星号 *(f()) 也不能作左值了。<br>对一个函数传进传出整个对象时可能会造成很大的开销（传参需要在堆栈里分配空间，意味着在堆栈里要花很多时间空间做拷贝工作），往往更好的办法是传一个地址。但是传地址我们又会很不放心别人会不会通过指针修改我们的原始数据。<br>这个时候，const修饰指针的作用就来了。我们在前面加上 const 表明我们以一个const的方式传一个对象进去，这样就可以保证我们的数据是安全的。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_i</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i = ii; <span class="built_in">get_i</span>(); cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_i</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">	<span class="built_in">A</span>() ：<span class="built_in">i</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;Now in A::A(),i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123;i = <span class="number">20</span>; cout &lt;&lt; <span class="string">&quot;Now in A::~A(), i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_i</span><span class="params">(<span class="keyword">const</span> A* a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> test = <span class="number">9</span>;</span><br><span class="line"> </span><br><span class="line">	a-&gt;<span class="built_in">get_i</span>();			</span><br><span class="line">    <span class="comment">//get_i()是const修饰的成员函数，表示不会动成员变量，所以可以调用</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//a-&gt;set_i(test);	</span></span><br><span class="line">    <span class="comment">//C2662	“void A::set_i(int)”: 不能将“this”指针从“const A”转换为“A&amp; ”</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A* a = <span class="keyword">new</span> A;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">set_i</span>(a);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">delete</span> a;    </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>const可以修饰整个对象，表明对象里的值是不能被修改的（常量对象），这其实就是和const int、const char等是一回事（别忘了面向对象的5条原则之“万事万物皆是对象”，一个int、一个char都是对象）。一旦将对象定义为const之后，该对象的任何非 const 成员函数都不能被调用，因为任何非 const 成员函数可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;                <span class="comment">//私有的非const成员变量i</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> j;                <span class="comment">//公开的非const成员变量j</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">6</span>;      <span class="comment">//公开的const成员变量k</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_i</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i = ii; cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_j</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> j; &#125;</span><br><span class="line">	<span class="built_in">A</span>() &#123; i = <span class="number">0</span>; j = <span class="number">1</span>; cout &lt;&lt; <span class="string">&quot;Now in A::A(),i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; i = <span class="number">20</span>; j = <span class="number">21</span>; cout &lt;&lt; <span class="string">&quot;Now in A::~A(), i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> A* a = <span class="keyword">new</span> A;</span><br><span class="line">	<span class="comment">//const修饰A类的对象指针a，当然可以直接const对象“const A a;”（类似于const int a;）</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//a-&gt;set_i(10);                        //无法调用非const成员函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;j=&quot;</span> &lt;&lt; a-&gt;<span class="built_in">get_j</span>() &lt;&lt; endl;    <span class="comment">//可以调用const的成员函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;j=&quot;</span> &lt;&lt; a-&gt;j &lt;&lt; endl;          </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;k=&quot;</span> &lt;&lt; a-&gt;k &lt;&lt; endl;          <span class="comment">//可以访问const or 非const的公开的成员变量</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">delete</span> a;    <span class="comment">//new了记得delete</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15717647/8409282">const在函数前后的意义 - 51博客</a></p>
<h4 id="10-2-补充：字符串字面值（String-literals）"><a href="#10-2-补充：字符串字面值（String-literals）" class="headerlink" title="10.2 补充：字符串字面值（String literals）"></a>10.2 补充：字符串字面值（String literals）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	s[<span class="number">0</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码在Visual Studio里无法运行，给出了错误。</p>
<p>而我们修改下代码，就可以成功运行了：   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[] = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	s[<span class="number">0</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 这是怎么一回事呢？        </p>
<p> 问题出在s是本地变量，存放在堆栈里面。</p>
<p> 当s作为指针，指向了一块内存，这块内存放了个字符串；而”Hello world”是个常量且编译器会认为这是个const的东西。这其实是一个“ const char* s ”不过是编译器接受不加“ const ”的写法，所以它是放在“代码段”里面的。这个时候s只是存放了”Hello world”所在的代码段的地址，而代码段是不可写的。</p>
<p> 而当s作为一个数组，整个数组都存放在堆栈里面。这个时候代码会变成它要对”Hello world”整个做一个拷贝，它会把代码段里的”Hello world”拷贝到堆栈里面来。后续的修改也是对拷贝过来的副本做的修改。</p>
<p> 实际上我们可以证明这件事的：分别打印s1、s2、main函数的地址；结果显示：显然，s1和main函数处在一个段（代码段）；s2处在堆栈段。 </p>
</blockquote>
<h3 id="11-引用-别名"><a href="#11-引用-别名" class="headerlink" title="11 引用/别名"></a>11 引用/别名</h3><h4 id="11-1-引用的基本概念"><a href="#11-1-引用的基本概念" class="headerlink" title="11.1 引用的基本概念"></a>11.1 引用的基本概念</h4><p>C++提供了非常多的内存模型：</p>
<ul>
<li>提供了许多存放对象的地方（堆栈、堆、全局数据区）；</li>
<li>提供了许多可以访问对象的方式（直接“<strong>fully</strong>”那个对象、通过指针访问对象、通过引用访问对象）</li>
</ul>
<p><strong>引用是C++中一种新的数据类型</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> i;            <span class="comment">//i is a character(i是一个字符)</span></span><br><span class="line"><span class="keyword">char</span>* p = &amp;i;      <span class="comment">//p is a pointer to a character(指针)</span></span><br><span class="line"><span class="keyword">char</span>&amp; r = i;       <span class="comment">//r is a reference to a character(引用)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*一般引用都需要在定义的时候给个初始值，以表明r是i的引用；</span></span><br><span class="line"><span class="comment">并且初始值得是一个可以作左值的东西*/</span></span><br></pre></td></tr></table></figure>
<p>引用还有另外一个名字：<strong>alias（别名）</strong>； </p>
<p>由上面两个名字可以看出：引用其实就是当我们需要用<code>i</code>的时候，我们可以用<code>r</code>；用<code>r</code>就是在用<code>i</code> 。<strong>它们只是一个东西的两个名字</strong>。</p>
<p>基本语法：<code>type&amp; refname = name</code>。</p>
<p>只有作为成员变量或者放在(函数)参数表里面才可以不用给初始值，其他都要给。</p>
<p><code>const char&amp; r = i</code>：表示无法通过<code>r</code>改变<code>i</code>。</p>
<p> 与c不同，引用的这种“绑定”关系是不可变的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>；</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>&amp; r = x;    <span class="comment">//r是x的引用，绑定关系是永久的</span></span><br><span class="line">    r = y;         <span class="comment">//这句代码就只是纯粹的赋值，而不是将r转变为y的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用可以作<strong>左值</strong>（”做左值”是”引用”的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6/9706361">必要条件</a>），所以返回引用的函数也可以作左值（我们知道返回基本类型的函数不能作左值） </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;        <span class="comment">//返回x的引用（没有提供引用名）</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">h</span><span class="params">(<span class="keyword">int</span>&amp; y)</span> </span>&#123;     <span class="comment">//参数表中的引用可以不用给初始值，在调用时会用实参的值初始化引用   </span></span><br><span class="line">    y++;             <span class="comment">//对引用的操作就是对被引用者的操作</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in h() y = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> y;        <span class="comment">//return引用就是return被引用者，而函数返回类型还是引用，所以还是返回被引用者的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; i = x;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> k = <span class="number">0.0</span>;</span><br><span class="line"> </span><br><span class="line">    *<span class="built_in">f</span>() = <span class="number">8</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">g</span>() = <span class="number">16</span>;    <span class="comment">//g函数返回x的引用，给引用赋值就是给x赋值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">h</span>(i);       <span class="comment">//因为&quot;引用&quot;的出现，给函数传参就不一定只是传值了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*类似于h(i)这种看起来像传值调用但实际上是可以改变全局变量x的值的，</span></span><br><span class="line"><span class="comment">    所以我们一定要去检查源代码*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">h</span>(j) = <span class="number">7</span>;		<span class="comment">// 可以做左值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*给h传递引用或变量进去都是可以的，可以做引用的引用这种事情</span></span><br><span class="line"><span class="comment">    int&amp; a = x;</span></span><br><span class="line"><span class="comment">    int&amp; b = a;</span></span><br><span class="line"><span class="comment">    这一点指针无法做到：当参数要指针时就只能传地址不能传变量*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//h(k);       //ERROR：无法用&quot;double&quot;类型的值初始化&quot;int &amp;&quot;类型的引用(非常量限定)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-2-引用-VS-指针"><a href="#11-2-引用-VS-指针" class="headerlink" title="11.2 引用 VS 指针"></a>11.2 引用 VS 指针</h4><div class="table-container">
<table>
<thead>
<tr>
<th>指针</th>
<th>引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以为空；<br>  <strong>指针</strong>独立于现有的对象； <br>一个指针可以指向不同的地址；</td>
<td>不能为空，一定要有初始值；<br>依附于现有变量，是现有变量的一个“<strong>别名</strong>”；<br><strong>引用</strong>的这种“绑定”关系是永久的；</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p> C++里<strong>引用其实就是通过指针实现的</strong>（这一点无法验证，我们无法获取到引用的地址，实际上会得到被引用变量的地址，不过这并不妨碍我们理解引用的本质），引用本质上就是个const指针（<code>int *const p</code>，你可以理解为引用<code>r</code>实质上就是那个<code>*p</code>）；<strong>设计“引用”这个东西出来是为了让代码少一点”*”号，使代码看上去简洁美观</strong>。（不过还是不要弄混了，引用在C++内部是通过指针实现，但这不代表引用变量的类型是指针；引用本身就是一种新的数据类型了）</p>
<p>Java则是以另一种方式解决这个问题：Java设计成只能通过指针去访问对象。正因为只有这一种访问对象的方式，所以Java可以把那个”*”号取消掉；然后对外宣称这不是指针，是“引用”。但实际上Java中的“引用”跟C++中的引用不是一回事，它更像C++中的指针。</p>
</blockquote>
<h4 id="1-3-一些引用限制（Restrictions）："><a href="#1-3-一些引用限制（Restrictions）：" class="headerlink" title="1.3 一些引用限制（Restrictions）："></a>1.3 一些引用限制（Restrictions）：</h4><ol>
<li>C++没有引用的引用（但编译器可能会帮你做到这点）；</li>
<li><code>＆</code>引用变量共享被引变量的内存，它是“别名”，故理论上不分配内存；</li>
<li>被<code>＆</code>引用的变量或表达式一定是分配了内存的有址左值；</li>
<li>由此可知，一个<code>＆</code>引用变量不能引用自己；</li>
<li>Visual Studio允许引用的引用，显然：”引用的引用”和”引用”和”被引用者”它们三个都是一个东西；</li>
<li>没有指向引用的指针；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;* p;          <span class="comment">//illegal(非法的)</span></span><br></pre></td></tr></table></figure>
<ol>
<li>但是可以有指针的引用；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = &amp;x;        </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>*&amp; r = p;     <span class="comment">//it&#x27;s OK!</span></span><br></pre></td></tr></table></figure>
<ol>
<li>没有引用的数组。</li>
</ol>
<p>这里补充一点：<strong>离变量名最近的那个符号，决定了它的基本类型</strong>。</p>
<h3 id="12-向上造型（Upcasting）"><a href="#12-向上造型（Upcasting）" class="headerlink" title="12 向上造型（Upcasting）"></a>12 向上造型（Upcasting）</h3><p> <strong>向上造型是将子类的引用或指针转变为父类的引用或指针的一种行为</strong>。也就是说如果B<strong>继承</strong>自A，那么你就可以在任何能够使用A的场合去使用B，B相比A多出来的那些东西可以当作不存在。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> :</span> <span class="keyword">public</span> person &#123;...&#125;;    <span class="comment">//student继承自person</span></span><br><span class="line">student jack;                           <span class="comment">//student对象jack</span></span><br><span class="line"> </span><br><span class="line">person* pp = &amp;jack;    <span class="comment">//it&#x27;s Upcast</span></span><br><span class="line">person&amp; pr = jack;     <span class="comment">//it&#x27;s Upcast   </span></span><br></pre></td></tr></table></figure>
<p>同时，在<a target="_blank" rel="noopener" href="https://blog.csdn.net/YMGogre/article/details/126759839">上半部分学习笔记</a>中我们提到过“<strong>名字隐藏</strong>”，但如果你通过”pp”或者”pr”去调用函数时，<strong>实际上会调用父类的对应函数</strong>，也就不会有<strong>名字隐藏</strong>的问题出现。以下面这段代码为例： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f() with no parameter&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f() with one parameter&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f() with two parameters&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f() with three parameters&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f() with two parameters&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	A* p = &amp;b;		<span class="comment">//Upcast，将b的引用交给了指向A的对象的指针p</span></span><br><span class="line">	p-&gt;<span class="built_in">f</span>(i);        <span class="comment">//调用父类的f函数</span></span><br><span class="line">	<span class="comment">//b.f(i);		//ERROR: Name hiding</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不扯远了，回到<strong>向上造型</strong>本身：从内部结构上来说，<strong>子类的对象拥有父类对象的所有东西（包括私有和公共的）</strong>；从实际内存存储上来说，存储B对象的那块内存里面确实存储了一整块A对象而且是放在那块内存顶部的，连A对象里面数据的排列顺序都是完全一致的。所以，B完全可以当作A来看待和使用。以下面这段代码为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>), <span class="built_in">j</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() : <span class="built_in">k</span>(<span class="number">3</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_k</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> k; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;	<span class="comment">//将a的地址取出来强制类型转换为指向int的指针后交给指向int的指针p</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a.i=&quot;</span> &lt;&lt; a.i &lt;&lt; <span class="string">&quot;；&quot;</span> &lt;&lt; <span class="string">&quot;a.j=&quot;</span> &lt;&lt; a.j &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b.i=&quot;</span> &lt;&lt; b.i &lt;&lt; <span class="string">&quot;；&quot;</span> &lt;&lt; <span class="string">&quot;b.j=&quot;</span> &lt;&lt; b.j &lt;&lt; <span class="string">&quot;；&quot;</span> &lt;&lt; <span class="string">&quot;b.k=&quot;</span> &lt;&lt; b.<span class="built_in">get_k</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Sizeof(a) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; <span class="string">&quot;	byte&quot;</span> &lt;&lt; endl;	</span><br><span class="line">    <span class="comment">//a实际只存储着它的两个int变量，所以它大小是8（byte）</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Sizeof(b) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(b) &lt;&lt; <span class="string">&quot;	byte&quot;</span> &lt;&lt; endl &lt;&lt; endl;	</span><br><span class="line">    <span class="comment">//b存储着a的所有东西以及自己的int变量k，所以b的大小是12（byte）</span></span><br><span class="line"> </span><br><span class="line">	*p = <span class="number">10</span>;		<span class="comment">//和C类似，C++在获取到地址之后也可以直接访问最底层的内存并做些修改</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a.i=&quot;</span> &lt;&lt; a.i &lt;&lt; <span class="string">&quot;；&quot;</span> &lt;&lt; <span class="string">&quot;a.j=&quot;</span> &lt;&lt; a.j &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	p = (<span class="keyword">int</span>*)&amp;b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;	<span class="comment">//按顺序访问b的内存的每一个int看看b究竟是怎么个顺序存储它的数据的</span></span><br><span class="line">	p++;							</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	p++;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//通过指针就可以随心所欲直接访问b的private的k</span></span><br><span class="line">	*p = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;modify *p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b.i=&quot;</span> &lt;&lt; b.i &lt;&lt; <span class="string">&quot;；&quot;</span> &lt;&lt; <span class="string">&quot;b.j=&quot;</span> &lt;&lt; b.j &lt;&lt; <span class="string">&quot;；&quot;</span> &lt;&lt; <span class="string">&quot;b.k=&quot;</span> &lt;&lt; b.<span class="built_in">get_k</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 由上面代码以及运行结果可以看出：当我们获取到对象的指针时，可以直接通过指针看看对象里面是什么样的。b的大小是12（byte），也证明了在<strong><font color="blue">b（对象）里面是没有成员函数的，只有成员变量，这跟C语言中的结构体是一样的（实际上类的成员函数存放在代码段的）</font></strong>。</p>
<p><strong>同时子类拥有父类的所有东西，连数据存储顺序都是一样的</strong>。以上面代码为例，不会说b的<code>k</code>是插在<code>i</code>和<code>j</code>中间存储的。所以b完全可以当作a来使用，但b还是b，不会因此真的变成a，只是我们把它看作是a了。 </p>
<p><img src="https://pic.imgdb.cn/item/675ba23ad0e0a243d4e32a8b.png" style="zoom:30%"></p>
<p>最后再提一点是：相反地，有<strong>向上造型</strong>也有<strong>向下造型</strong>，即把父类的对象当作子类的对象看待。但<strong>向下造型</strong>是有风险的！ </p>
<h3 id="13-多态性"><a href="#13-多态性" class="headerlink" title="13 多态性"></a>13 多态性</h3><h4 id="13-1-多态的介绍"><a href="#13-1-多态的介绍" class="headerlink" title="13.1 多态的介绍"></a>13.1 多态的介绍</h4><p>现在我们要设计一个画图程序</p>
<p><img src="https://pic.imgdb.cn/item/675fd8f2d0e0a243d4e48b96.png" style="zoom:40%"></p>
<p>程序可以画三种不同的图形：矩形、圆形、椭圆。 他们拥有相同的数据：center（中心点坐标）；可以做三种相同的操作：render（渲染图形）、move（移动图形）、resize（改变大小）。</p>
<p>为了实现上述要求，我们可以以一个类型来定义另一个类型：</p>
<ul>
<li><p>一个ellipse是一种shape；</p>
</li>
<li><p>一个circle是一种特殊的ellipse；</p>
</li>
<li><p>一个rectangle是另外一种不同的shape；</p>
</li>
<li><p>rectangle、circle、ellipse拥有一些共同的：属性（成员变量）和服务（成员函数）；</p>
</li>
<li><p>但它们三个也不是完全相同的；</p>
</li>
</ul>
<p>于是，它们构成了如下图所示的联系：</p>
<p><img src="https://pic.imgdb.cn/item/675fd9bbd0e0a243d4e48bf4.png" style="zoom:40%"></p>
<p>center 和 move() 只在Shape里面定义了，对大家来说center和move()要做的事情都是一样的，所以其他四个类里面就不需要再定义了；而不同图形的 render() 是不一样的，而且不同的图形类里面可能有自己的数据（比如Ellipse类有”长轴”、”短轴”数据），同时不同图形的render()和Shape的render()得是存在某种联系的。</p>
<p>下面来设计代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shape类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XYPos</span> &#123;</span>...&#125;;    <span class="comment">//x,y point</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>();    <span class="comment">//析构函数也用了virtual修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;    </span><br><span class="line">    <span class="comment">/*&quot;virtual&quot;关键字意思是“虚的”，表示如果将来Shape类的子类里面重写了render()，</span></span><br><span class="line"><span class="comment">    那么重写的render()跟这个render()是有联系的！！</span></span><br><span class="line"><span class="comment">    这跟我们在“Name hiding”中提到的“子类中的print()函数跟父类中的print()函数是没有关系的”</span></span><br><span class="line"><span class="comment">    是不一样的！！*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">const</span> XYPos&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    XYPos center;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ellipse类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Ellipse</span>(<span class="keyword">float</span> maj, <span class="keyword">float</span> minr);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;          </span><br><span class="line">    <span class="comment">/*will define own, &quot;virtual&quot;可以不加，因为只要一个类中某个函数是virtual的，</span></span><br><span class="line"><span class="comment">    那么这个类的子子孙孙的那个函数都是virtual了，无论前面是否加了virtual修饰；</span></span><br><span class="line"><span class="comment">    当然加上&quot;virtual&quot;是个好习惯，这样别人不用去翻祖先类就知道这个函数是virtual了*/</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> major_axis, minor_axis    <span class="comment">//长轴和短轴</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Ellipse &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="keyword">float</span> radius) : <span class="built_in">Ellipse</span>(radius, radius) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之所以搞得这么麻烦是为了实现如下面这个应用实例中的这样的<strong>render()</strong>函数： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(Shape* p)</span> </span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">render</span>();        <span class="comment">//calls correct render function </span></span><br><span class="line">&#125;                       <span class="comment">//for given Shape!</span></span><br><span class="line"><span class="comment">/*render函数接受一个Shape的指针作为输入，然后让指针指向的那个对象去做render</span></span><br><span class="line"><span class="comment">render函数是个通用函数，对任何Shape类的子类都是适用的(包括Shape自己)，</span></span><br><span class="line"><span class="comment">也就是说这个render函数是用于将来的新出现的Shape的子类的对象。而现在，</span></span><br><span class="line"><span class="comment">我还不知道将来Shape还会有什么样的子类，但这个函数写在这里对将来Shape可能出现的子类也是通用的*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Ellipse <span class="title">ell</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    ell.<span class="built_in">render</span>();        <span class="comment">//调用Ellipse的render()</span></span><br><span class="line">    <span class="function">Circle <span class="title">circ</span><span class="params">(<span class="number">40</span>)</span></span>;</span><br><span class="line">    circ.<span class="built_in">render</span>();       <span class="comment">//调用Circle的render()</span></span><br><span class="line">    <span class="built_in">render</span>(&amp;ell);        <span class="comment">//Upcast向上造型，但由于virtual的关系故不会调用父类中的render()，而是调用Ellipse自己的render()</span></span><br><span class="line">    <span class="built_in">render</span>(&amp;circ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-2-多态定义"><a href="#13-2-多态定义" class="headerlink" title="13.2 多态定义"></a>13.2 多态定义</h4><p><strong>“virtual”</strong>是在告诉编译器当一个函数是virtual时，且对这个函数的调用如果是通过指针或引用的话，编译器就不能相信它一定是什么类型的。需要到<strong>运行时刻</strong>确定这个指针所指的那个对象到底是什么类型，再去调用那个类型的该函数；<br>而上面提到的这些事情，就称为“<strong><font color="red">多态性</font></strong>”。对于上面的应用实例代码，<strong>p就是多态的</strong>，有的地方也称p为“多态对象”。因为p指向什么类型的对象，通过p做的动作就是那个类型的对象做的。p指向谁就变成谁的“形态”，故称p是“多态对象”。</p>
<p>由上面可知“<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%9A%E6%80%81%E6%80%A7&amp;spm=1001.2101.3001.7020">多态性</a>”是构筑在两件事情上的： </p>
<p>① <strong>向上造型</strong>（Upcast） </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">render</span>(Shape *p)&#123;</span><br><span class="line">    p-&gt;<span class="built_in">render</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="built_in">render</span>(&amp;ell);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//仅看参数表里面的内容，其实就是&quot;Shape *p = &amp;ell&quot;，显然是Upcast</span></span><br></pre></td></tr></table></figure>
<p>② 动态绑定（Dynamic binding）；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所谓绑定：是指调用时应该调用哪个函数；</span><br><span class="line">静态绑定：调用的函数是确定的(编译时刻就确定的)；</span><br><span class="line">动态绑定：需要到运行时刻才知道到底要调用哪个函数； </span><br></pre></td></tr></table></figure>
<h4 id="13-3-多态的实现："><a href="#13-3-多态的实现：" class="headerlink" title="13.3 多态的实现："></a>13.3 多态的实现：</h4><p>C++到底是怎样实现在运行时刻动态地绑定那个函数，在运行时刻知道p所指的那个对象到底是什么类型的继而去调用正确的函数的呢？又回到了上半部分学习笔记中的那句话：Bjame Sgoustrup 在1979年刚开始研发C++的时候，他的手段仅仅只有C，他是怎么用C语言来实现C++的多态性呢？而且实现方式也不会很复杂，毕竟C++的运行效率也是很高的，太复杂了效率就会低。</p>
<p>首先，任何一个类如果有虚函数(virtual function)，这个类的对象就会比正常的”大”一点。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.<span class="built_in">f</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(a) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//探查第一个int</span></span><br><span class="line">	p++;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//探查第二个int</span></span><br><span class="line">	p++;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//探查（如果有）第三个int</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到实际占用都不止4个字节了，以Win32运行结果为例：实际上 a 的成员变量 i 是存储在第二个int的。而第一个int大小的东西我们不知道是什么；<br>那个不知道是什么的东西其实是个指针，叫做<code>vptr</code>。所有有virtual的类的对象里面最顶部都会自动加上这个隐藏的<code>vptr</code>，它指向一张表，表叫做<code>vtable</code>。<br><img src="https://pic.imgdb.cn/item/675fe1f1d0e0a243d4e48fc0.png" style="zoom:50%"></p>
<ul>
<li><strong>vtable</strong>里面存放的是这个<strong>类</strong>的所有的virtual函数的地址。所以vtable是属于这个类的，所以这个类的所有的vptr的值都是一样的，这是可以验证的：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;	<span class="comment">//A类有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	A aa;    <span class="comment">//做两个对象出来</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(a)  = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; <span class="string">&quot;byte&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(aa) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(aa) &lt;&lt; <span class="string">&quot;byte&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;        <span class="comment">//取a的地址出来强制类型转换为int型指针并交给int型指针p        </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p(a)	= &quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//取第一个int出来        </span></span><br><span class="line">	p = (<span class="keyword">int</span>*)&amp;aa;            </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p(aa)	= &quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//同样取第一个int出来，结果显示和上面是一样的</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>另外我们还可以做一些“邪恶”的事情。我们知道 <strong>p</strong> 是指向vtable的指针(就是vtable的地址) 的指针，所以 <em>p 表示指针所指的地方即vtable的地址，我们可以把 </em>p 交给另外一个指针x，那么x就会指向vtable，它们之间的关系如下图所示：</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/675fe736d0e0a243d4e49187.png" style="zoom:50%"></p>
<p>我们验证一下上面的关系： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;	<span class="comment">//A类有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(a)  = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; <span class="string">&quot;byte&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p(a)	= &quot;</span> &lt;&lt; *p &lt;&lt; endl;    <span class="comment">//*p的内容是vtable的地址</span></span><br><span class="line">	<span class="keyword">int</span>* x = (<span class="keyword">int</span>*)*p;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;x	= &quot;</span> &lt;&lt; x &lt;&lt; endl;         <span class="comment">//x的内容应该也是vtable的地址</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而我们要做的“邪恶”的事情就是既然拿到指针了，我们就可以通过*x看到vtable的内容了，现在我们尝试打印下vtable的第一个int（因为x是指向int的指针嘛）：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;	<span class="comment">//A类有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(a)  = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; <span class="string">&quot;byte&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p(a)	= &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span>* x = (<span class="keyword">int</span>*)*p;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*x	= &quot;</span> &lt;&lt; *x &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>还有一点是上面我们提到过”一个有virtual函数的类的不同<strong>对象</strong>的<strong>vptr</strong>是指向同一个<strong>vtable</strong>的(也就是这个类的<strong>vtable</strong>)”；而当这个类有子类的时候，<strong>子类的</strong>不同<strong>对象</strong>当然也会有<strong>vptr</strong>，但是它们会指向子类自己的<strong>vtable</strong>；而不是父类的<strong>vtable</strong>。</li>
</ul>
<p>例如：Ellipse对象的vptr会指向Ellipse的vtable ，而不是其父类Shape的vtable</p>
<p><img src="https://pic.imgdb.cn/item/675fe858d0e0a243d4e491be.png" style="zoom:50%"></p>
<p> 可以看到：子类Ellipse的vtable的结构跟父类是一样的（第一个是析构函数dtor()、第二个render()、第三个resize()），不过里面的值（地址）是不一样的。Ellipse的析构、render()是自己的；而它的resize()是Shape的，因为Ellipse没有写自己的resize()。不过析构是特别的，即便Ellipse没有写自己的析构，编译器也会给Ellipse制造一个析构出来，所以vtable里存的是Ellipse自己的析构。同样的，还有Ellipse的子类Circle： </p>
<p><img src="https://pic.imgdb.cn/item/675fe8a0d0e0a243d4e491d6.png" style="zoom:50%"></p>
<p>通过上面那么大篇幅介绍的方式，我们终于摸清了C++实现<strong>动态绑定</strong>的方式： 只需要通过修改<strong>vtable</strong>表里的地址。当函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(Shape* p)</span> </span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">render</span>();         </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>中说”<strong>p-&gt;render()</strong>“的时候，实际发生的事情是让p所指的对象的第一个地址取出来，从该地址访问到了<strong>vtable</strong>，然后从<strong>vtable</strong>“<strong>+1</strong>“得到了那个 render() 的地址，然后调用那个地址上的 render() 函数就可以了。 </p>
<blockquote>
<p>在之前我们都还没有提到过<code>vptr</code>和<code>vtable</code>的类型。</p>
<p><code>vtable</code>：vtable的类型可以表达为<code>uintptr_t*</code>，表示<code>vtable中</code>每个元素类型都是<code>uintptr_t</code>；</p>
<p><code>vptr</code>：<code>vptr</code>指向<code>vtable</code>，因此<code>vptr</code>的类型是<code>uintptr_t**</code>，表示指针<code>vtpr</code>指向的类型是<code>uintptr_t*</code>；</p>
<p>经验证64位编译模式下<code>uintptr_t</code>、<code>uintptr_t*</code>和<code>uintptr_t**</code>都占用8个字节，所以同样的从vtable”+1”（代码层面的 指针 +1）对应地址”+8”（物理内存层面的 地址 +8）。 </p>
</blockquote>
<p>在上面我们把<em>p交给了<strong>int</strong>型指针x，若想要x指向那个 render() 函数，我们得让x”<em>*+？</em></em>“呢？ </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;	<span class="comment">//A类有虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::g(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(a)  = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; <span class="string">&quot;byte&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">	<span class="keyword">int</span>* x = (<span class="keyword">int</span>*)*p;</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(x)	= &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(x) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof(int)	= &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/675fea03d0e0a243d4e49223.png" style="zoom:80%"></p>
<p>可以看到这种实现<strong>动态绑定</strong>的方式是高效的，程序在<strong>运行时刻</strong>根本无需知道对象的类型是什么，只是在顺着<strong>vptr</strong>找到了<strong>vtable</strong>，然后找到了应该调用的正确函数的<strong>地址</strong>而已。  </p>
<p> 在“<strong>多态性（Polymorphism）</strong>” 一章我们提到过，” <strong>“动态绑定”</strong>是要通过<strong>指针</strong>或者<strong>引用</strong>调用<strong>virtual</strong>函数时才会去做的 “，那么我们不通过<strong>指针</strong>或者<strong>引用</strong>去调用<strong>virtual</strong>函数会怎么样呢？这一点我们展开来验证一下： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;	<span class="comment">//A类有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="built_in">B</span>() : <span class="built_in">j</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f(),j = &quot;</span> &lt;&lt; j &lt;&lt; endl; &#125;	<span class="comment">//B重写了虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	B b;</span><br><span class="line"> </span><br><span class="line">	A* p = &amp;b;	<span class="comment">//Upcast but virtual</span></span><br><span class="line">	p-&gt;<span class="built_in">f</span>();		<span class="comment">//虽然向上造型了但是因为virtual存在还是会调用子类的f</span></span><br><span class="line"> </span><br><span class="line">	a = b;		<span class="comment">//直接把b赋给a</span></span><br><span class="line">	a.<span class="built_in">f</span>();		<span class="comment">//通过a.f()到底是调用a的f还是b的f呢？</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，只有通过<strong>指针</strong>或者<strong>引用</strong>调用<strong>virtual</strong>函数时才会去“<strong>动态绑定</strong>”，通过”<strong>.</strong>“去调用时并不会做这样的事情；<strong>可是我们明明把b赋给a了呀！这一点好像被完全无视了？</strong></p>
<p>我们再修改下程序，这次让指针去调用<strong>virtual</strong>函数 f() ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f(),i = &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;	<span class="comment">//A类有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="built_in">B</span>() : <span class="built_in">j</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f(),j = &quot;</span> &lt;&lt; j &lt;&lt; endl; &#125;	<span class="comment">//B重写了虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	B b;</span><br><span class="line"> </span><br><span class="line">	A* p = &amp;b;	<span class="comment">//Upcast but virtual</span></span><br><span class="line">	p-&gt;<span class="built_in">f</span>();		<span class="comment">//虽然向上造型了但是因为virtual存在还是会调用子类的f</span></span><br><span class="line"> </span><br><span class="line">	a = b;		<span class="comment">//直接把b赋给a</span></span><br><span class="line"> </span><br><span class="line">	p = &amp;a;		<span class="comment">//这次我们通过指针去调用virtual函数，已知指针调用时会去做动态绑定的工作</span></span><br><span class="line">	p-&gt;<span class="built_in">f</span>();		<span class="comment">//那么这次又会调用a的f还是b的f呢？答案：还是调用的a的f函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么还是调用的a的f()函数呢？</p>
<p>因为我们在做赋值操作(a = b)时只是把b的值给了a（你可以试试在上面这段代码中B的构造函数里修改A的成员变量i的值，然后在赋值操作完成前后打印a.i，就能观察到b是把i的值赋过去了的），所以a还是a的；所以进行赋值操作时，b的区域是被“切掉”了的，只有符合a的那部分才会被赋值过去。而且在赋值过程中vptr是不传递的。所以自然调用的a的f函数。</p>
<p>但如果是<strong>指针</strong>的赋值的话，那显然原本的a就被覆盖丢失了…(因为指针不代表任何事情嘛，指针就是一个地址而已) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">B* b = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line"> </span><br><span class="line">a = b;</span><br><span class="line">a-&gt;<span class="built_in">f</span>();    <span class="comment">//B::f() is called</span></span><br></pre></td></tr></table></figure>
<h4 id="13-4-虚析构函数（Virtual-destructors）"><a href="#13-4-虚析构函数（Virtual-destructors）" class="headerlink" title="13.4 虚析构函数（Virtual destructors）"></a>13.4 虚析构函数（Virtual destructors）</h4><p>在《<strong>多态性（Polymorphism）</strong>》一章中我们设计Shape类的代码里可以看到析构函数被设计为了虚函数，为什么要设计成<strong>virtual</strong>的？我们来看看下面这个代码： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Shape *p = <span class="keyword">new</span> <span class="built_in">Ellipse</span>(<span class="number">100.0F</span>, <span class="number">200.0F</span>); </span><br><span class="line"><span class="comment">/*在学习《向上造型（Upcasting）》时我们说&quot;person* pp = &amp;jack;&quot;是Upcast，</span></span><br><span class="line"><span class="comment">那上面这句代码是不是Upcast呢？</span></span><br><span class="line"><span class="comment">    这也是Upcast，我们做了个Ellipse的对象交给了父类Shape的指针p：在上半部</span></span><br><span class="line"><span class="comment">分学习《new &amp; delete》时提到过new作为一个运算符会返回分配给对象的地址，所</span></span><br><span class="line"><span class="comment">以这句代码还是向上造型，向上造型本质是：把子类对象当成父类对象用*/</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<p>我们知道：当<code>delete p</code>时会自动调用析构函数，如果析构函数不是virtual的，意味着此时Shape的析构会被调用。所以，我们需要让析构函数是virtual的。</p>
<p><strong>如果我们设计的类中有一个virtual函数，我们就必须把析构函数也设计成virtual的</strong>，这样可以避免可能出现的麻烦。这件事情的关键在于即便现在我们的类没有子类，我们也无法预知将来别人会怎么修改我们的程序。比如我们想象一下下面这种场景：</p>
<p>我们设计了一个类，类里面有一些virtual函数但析构函数不是virtual的。这个时候别人写了个新类继承自我们的这个类，他知道我们的类里有virtual函数所以选择Upcast以实现动态绑定。然后由于别人写的新类里面申请了一些资源，所以别人重写了我们的析构函数用于归还申请的资源（这一点在上半部分学习笔记中的《构造和析构（Constructor &amp; Destructor）》中谈析构的用处时提到过）。而当别人new了一个他写的类的对象之后再去delete时，就像上面的代码那样，会去调用我们父类的析构，而显然我们的析构没有说要去还那些申请的资源</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">0</span>) &#123;  &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f()&quot;</span> &lt;&lt; endl; &#125;    <span class="comment">//virtual f()</span></span><br><span class="line">	 ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	 ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A* p)</span> </span>&#123;</span><br><span class="line">	p-&gt;<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	B b;				</span><br><span class="line">	<span class="comment">/*b不是new出来的，在上半部分学习笔记《父类子类的关系》中我们说过：</span></span><br><span class="line"><span class="comment">          &quot;退出时会先析构子类，再析构父类&quot;</span></span><br><span class="line"><span class="comment">	所以离开大括号范围时会先调用~B()，再调用~A()。*/</span></span><br><span class="line"> </span><br><span class="line">	A* p = <span class="keyword">new</span> <span class="built_in">B</span>();		<span class="comment">//Upcast</span></span><br><span class="line"> </span><br><span class="line">	p-&gt;<span class="built_in">f</span>();				<span class="comment">//but f() is virtual，所以动态绑定</span></span><br><span class="line">	<span class="built_in">f</span>(&amp;b);				<span class="comment">//也是Upcast but virtual，所以也会动态绑定</span></span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Before delete p&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> p;			<span class="comment">//此时会调用~A()（这不是我们期望的结果）</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After delete p&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;						<span class="comment">//此时会调用~B()、~A()</span></span><br></pre></td></tr></table></figure>
<h4 id="13-5-覆盖（Override）"><a href="#13-5-覆盖（Override）" class="headerlink" title="13.5 覆盖（Override）"></a>13.5 覆盖（Override）</h4><p>如果父类和子类的两个函数是virtual的，名称相同，参数列表也相同。那它们构成一种关系叫做”Override”。中文可以称作“覆盖”、“覆写”、“重写”或者“改写”。还记得在上半部分学习笔记中的《名字隐藏（Name hiding）》里我们说”子类中的print()函数跟父类中的print()函数是其实是没有关系的”，现在有了virtual，就构成了Override关系了。</p>
<p>在Override中如果我们想要调用父类的那个函数，可以这么写： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;In Derived::func!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        Base::<span class="built_in">func</span>();    <span class="comment">//call to base class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面举一个可以运行的例子：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in B::f(), I&#x27;m trying to call A::f()：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		A::<span class="built_in">f</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A* p)</span> </span>&#123;</span><br><span class="line">	p-&gt;<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	B b;				</span><br><span class="line">	A* p = <span class="keyword">new</span> <span class="built_in">B</span>();		</span><br><span class="line"> </span><br><span class="line">	p-&gt;<span class="built_in">f</span>();				</span><br><span class="line">	<span class="built_in">f</span>(&amp;b);				</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">delete</span> p;			</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<h4 id="13-6-返回类型放松（Return-types-relaxation）："><a href="#13-6-返回类型放松（Return-types-relaxation）：" class="headerlink" title="13.6 返回类型放松（Return types relaxation）："></a>13.6 返回类型放松（Return types relaxation）：</h4><ul>
<li>假如B继承自A，那么C++允许<strong>B::f()</strong>返回<strong>A::f()</strong>返回类型的子类；</li>
<li><strong>适用于指针和引用类型；</strong></li>
</ul>
<p>比如<code>A::f()</code>如果返回了一个A类自己的的指针，而且<code>B::f()</code>Override它了；那么<code>B::f()</code>就可以返回B类的指针；  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> A* <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> A&amp; <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> A  <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> B* <span class="title">f</span><span class="params">()</span></span>;        <span class="comment">//it&#x27;s OK!</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> B&amp; <span class="title">g</span><span class="params">()</span></span>;        <span class="comment">//it&#x27;s OK!</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> B  <span class="title">h</span><span class="params">()</span></span>;        <span class="comment">//ERROR! Only applies to pointer and reference types</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为只有通过<strong>指针</strong>或者<strong>引用</strong>才构成Upcast关系嘛，才能够发生多态性（polymorphism）嘛。这点在之前多次提到过了。  </p>
<h4 id="13-7-同时有重载-Overload-和覆盖-Override-："><a href="#13-7-同时有重载-Overload-和覆盖-Override-：" class="headerlink" title="13.7 同时有重载(Overload)和覆盖(Override)："></a>13.7 同时有重载(Overload)和覆盖(Override)：</h4><p>现在父类中有一组<strong>virtual</strong>的<strong>重载</strong>(Overload)函数，如果你覆盖<strong>(Override)</strong>了其中一个，你就必须把所有的重载给覆盖掉，否则依然会发生<strong>名字隐藏</strong>那样的事情。 </p>
<h3 id="14-引用再研究"><a href="#14-引用再研究" class="headerlink" title="14 引用再研究"></a>14 引用再研究</h3><p>在《<strong>引用（Declaring reference）</strong>》一章我们提到过”<strong>引用</strong>作为<strong>成员变量</strong>或者<strong>放在参数表里面</strong>才可以不用给初始值”，而这其中当<strong>引用</strong>作为<strong>成员变量</strong>没有给初始值时我们就<strong>必须（也只能）</strong>在初始化列表里面给出初始值来。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span>&amp; m_y;    <span class="comment">//现在还不知道将来构造X的对象时m_y要与谁建立引用关系，没有办法在声明时给初始值</span></span><br><span class="line">        <span class="built_in">X</span>(<span class="keyword">int</span>&amp; a);              <span class="comment">//构造声明</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">int</span>&amp; a) : <span class="built_in">m_y</span>(a) &#123;&#125;        <span class="comment">//构造定义    </span></span><br></pre></td></tr></table></figure>
<p>我们就必须在初始化列表中建立引用关系，因为如果在大括号{}里面写”m_y = a;”那就是在赋值了（把a赋给m_y所“绑定”的那个变量）。比如下面这样：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>&amp; m_y;    </span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">int</span>&amp; a);                <span class="comment">//构造声明</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">int</span>&amp; a) &#123; m_y = a; &#125;     <span class="comment">//构造定义，会报错ERROR</span></span><br></pre></td></tr></table></figure>
<h4 id="14-1-函数返回引用（Returning-references）："><a href="#14-1-函数返回引用（Returning-references）：" class="headerlink" title="14.1 函数返回引用（Returning references）："></a>14.1 函数返回引用（Returning references）：</h4><p>同返回<strong>指针</strong>，函数也可以返回<strong>引用</strong>，而且也不能返回本地变量的<strong>引用</strong>； </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">double</span> myarray[SIZE];</span><br><span class="line"><span class="function"><span class="keyword">double</span>&amp; <span class="title">subscript</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myarray[i];</span><br><span class="line">    <span class="comment">/*返回第i个元素变量，因为一般会在调用该函数的地方会将该变量“绑定”给别的reference</span></span><br><span class="line"><span class="comment">    就像:</span></span><br><span class="line"><span class="comment">    int f() &#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int a = f();</span></span><br><span class="line"><span class="comment">    这样，我们也可以：</span></span><br><span class="line"><span class="comment">    int&amp; f() &#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int&amp; a = f();</span></span><br><span class="line"><span class="comment">    区别在于int a = f()只是在赋值，而int&amp; a = f()是把f()返回的变量“绑定”给a了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; SIZE; count++) &#123;</span><br><span class="line">        myarray[count] = count + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span>&amp; FirstElement = <span class="built_in">subscript</span>(<span class="number">0</span>);         </span><br><span class="line">    <span class="comment">//把返回值“绑定”给另外一个reference</span></span><br><span class="line">    <span class="keyword">double</span> FirstElement_value = <span class="built_in">subscript</span>(<span class="number">0</span>);    </span><br><span class="line">    <span class="comment">/*把返回的「值」赋给了一个double变量（这个时候发生了&quot;dereference&quot;）。</span></span><br><span class="line"><span class="comment">    很容易理解：引用就是别名嘛，把&quot;引用赋给变量&quot;不就跟&quot;把变量赋给变量&quot;一样的嘛，</span></span><br><span class="line"><span class="comment">    &quot;i = j;&quot;这种事不是经常做嘛，实际上就是传值嘛*/</span></span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FirstElement       =&quot;</span> &lt;&lt; FirstElement &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FirstElement_value =&quot;</span> &lt;&lt; FirstElement &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    FirstElement_value = <span class="number">3.1415926</span>;    <span class="comment">//修改double变量对myarray数组没有影响       </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After modify double myarray[0] = &quot;</span> &lt;&lt; myarray[<span class="number">0</span>] &lt;&lt; endl;   </span><br><span class="line">    FirstElement = <span class="number">2.7182818</span>;          <span class="comment">//修改引用的值即修改被引用者的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After modify double&amp; myarray[0]= &quot;</span> &lt;&lt; myarray[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码没有演示返回引用的函数作”左值”的情况，感兴趣的小伙伴可以自己试一试（比如subscript(7) = 2.58;）。因为函数返回reference，所以返回的reference可以作为变量来使用。  </p>
<h4 id="14-2-Const-reference-parameters"><a href="#14-2-Const-reference-parameters" class="headerlink" title="14.2 Const reference parameters"></a>14.2 Const reference parameters</h4><p>在上半部分学习笔记的《Const》一章中我们说过：</p>
<p>“对一个函数传进传出整个对象时可能会造成很大的开销，往往更好的办法是传一个地址。但是传地址我们又会很不放心别人会不会通过指针修改我们的原始数据。这个时候，const修饰指针的作用就来了。我们在前面加上 const 表明我们以一个const的方式传一个对象进去，这样就可以保证我们的数据是安全的。”</p>
<p>现在我们有了引用（reference），我们可以选择用更好的reference，因为reference意味着我们就可以不用在那个函数里面用很多”*”号了，这也是C++开发工作中更推荐的。 </p>
<h5 id="14-2-1-中间结果是const（Temporary-values-are-const）"><a href="#14-2-1-中间结果是const（Temporary-values-are-const）" class="headerlink" title="14.2.1 中间结果是const（Temporary values are const）"></a>14.2.1 中间结果是const（Temporary values are const）</h5><p>我们先来看下下面这段代码： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="built_in">func</span> (i * <span class="number">3</span>);    <span class="comment">//ERROR：无法将参数从&quot;int&quot;转换为&quot;int &amp;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//我们都知道reference必须能做左值，显然i*3不能作左值，当然报错</span></span><br></pre></td></tr></table></figure>
<p>还有种解释是编译器在编译时会生成下面这样的代码： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> tmp@ = i * <span class="number">3</span>;    <span class="comment">//编译器产生了const int的临时变量tmp@</span></span><br><span class="line"><span class="built_in">func</span>(tmp@);                <span class="comment">//因为tmp@是const，就不能传给int &amp;（const不能作左值嘛）</span></span><br></pre></td></tr></table></figure>
<p>那现在我们修改函数的参数为const reference parameter，试试看能不能把<code>tmp@</code>传进去：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">f</span>(i * <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有报错可以正常运行，验证了第二种解释。 </p>
<h5 id="14-2-2-函数返回值有const（const-in-Function-returns）"><a href="#14-2-2-函数返回值有const（const-in-Function-returns）" class="headerlink" title="14.2.2 函数返回值有const（const in Function returns）"></a>14.2.2 函数返回值有const（const in Function returns）</h5><p><strong>（一）函数return了一个const value</strong></p>
<ul>
<li>对于用户定义类型，这意味着“防止作为左值使用”（现代的编译器貌似不用加const都不能作左值了，详见下面的代码）；</li>
<li>对于内置的，它没有任何意义（就像int f()，我们都知道实质上返回的是值，而不是一个变量。值本来就不能作左值，const int f()就无意义了）；</li>
</ul>
<p>我们来测试一些返回用户定义类型的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A b;</span><br><span class="line">	<span class="comment">//f().i = 10;		//ERROR：表达式必须是可修改的左值</span></span><br><span class="line">	<span class="comment">/*上面这句代码理论上应该是行得通的，可能是Visual Studio的编译器现在不允许这种行为了吧*/</span></span><br><span class="line"> </span><br><span class="line">	b.i = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">f</span>() = b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now f().i = &quot;</span> &lt;&lt; <span class="built_in">f</span>().i &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now b.i = &quot;</span> &lt;&lt; b.i &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哦哟，这很奇怪哦，我们明明做了<strong>f() = b</strong>这件事，但是<strong>f().i</strong>好像没啥变化啊？是不是因为局部变量的关系呢？我们在上面代码的基础上加一些监测然后调试试一下： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;Now in A::A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Now in A::~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After A a&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After A b&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//f().i = 10;		//ERROR：表达式必须是可修改的左值</span></span><br><span class="line">	<span class="comment">/*上面这句代码理论上应该是行得通的，可能是Visual Studio的编译器现在不允许这种行为了吧*/</span></span><br><span class="line"> </span><br><span class="line">	b.i = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">f</span>() = b;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After f() = b;&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now f().i = &quot;</span> &lt;&lt; <span class="built_in">f</span>().i &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Now b.i = &quot;</span> &lt;&lt; b.i &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/6762291bd0e0a243d4e597b0.png"></p>
<p>当你一步步地调试时，你就可以发现：<strong>f()确实返回了一个对象，在return语句执行时会去析构局部变量a，所以这个时候显然返回的不是a对象本身了，现在我们推测函数返回的是一个a的”副本”，而且此时我们并不知道这个”副本”变量的名字和地址</strong>。</p>
<p>然后程序继续执行”f() = b;”这句代码，此刻这个”副本”变量还没有被析构（通过调试过程看得出来），而<strong>显然我们没有办法去访问到这个返回的对象的任何东西，因为此时我们并不知道这个”副本”变量的名字和地址</strong>。换句话说，没有任何人知道”副本”在哪，没有人此刻掌握着”它”。<br>所以”它”就不存在了，”它”消失了。这句话好像有点哲学哈，我们可以理解为“当世界上没有任何一个人能够观察到你的存在时，你是否还真的存在于这个世界上呢？”Think about it！<br>所以在程序执行完”f() = b;”后，这个”副本”对象也被一起<strong>析构</strong>了，所以发生了我们目前还无法理解的”两次析构被调用”。<br>感兴趣的小伙伴可以构造一个A的对象来掌握返回的那个”副本”对象。这样就直到 掌握着那个”副本”的 对象的 生命周期结束才会调用析构了。比如”A c =  f();        c = b;”。<br>这一段实际发生的事情涉及到马上要讲的《拷贝构造（Copy the structure）》，所以现在不理解也不必担心。 </p>
<p><strong>（二）函数return一个const pointer or reference</strong> </p>
<p>这取决于你期望使用你的类的人会拿着这个返回结果做啥 </p>
<p>在14.1函数返回引用（Returning references）小节开头我们就说”函数不能把本地变量作引用给返回”，但其实我们可以尝试下做这种”邪恶”的事情的，编译器不会报错。<br>下面举一些返回引用的代码例子，这段代码推荐除main函数内的内容以外全部复制进你的IDE内，然后自行测试你能想象到的所有可能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">A</span>() : <span class="built_in">i</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;Now in A::A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;Now in A::~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i;    <span class="comment">//全局变量i</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i;            <span class="comment">//返回全局变量的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">ff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = i;</span><br><span class="line">	<span class="keyword">return</span> a;            <span class="comment">//返回本地变量的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i;            <span class="comment">//返回全局变量的引用且是const的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">A&amp; <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">return</span> a;            <span class="comment">//返回本地对象变量的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">A b;    <span class="comment">//全局对象变量b；</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> A&amp; <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b;            <span class="comment">//返回全局对象变量的引用且是const的引用</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>() = <span class="number">4</span>;        <span class="comment">//我们知道引用和被引用者是一个东西嘛，所以这和 i = 4; 没有区别</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="built_in">f</span>();	<span class="comment">//这和int j = i;没有区别</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;j=&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;return of f()	=&quot;</span> &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl;	</span><br><span class="line">	<span class="comment">//和直接打印全局变量i没有区别，因为f()函数就是拿全局变量i的引用返回的；</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">ff</span>() = <span class="number">44</span>;</span><br><span class="line">	<span class="comment">/*但是返回本地变量的引用就有问题了，因为本地变量的生存周期只有函数内部，</span></span><br><span class="line"><span class="comment">    所以这样的引用实际上是非法的，不过编译器仍然通过了*/</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;return of ff()	=&quot;</span> &lt;&lt; <span class="built_in">ff</span>() &lt;&lt; endl;		</span><br><span class="line">    <span class="comment">//作为一个不存在的变量的引用，它的值当然是不确定的</span></span><br><span class="line">	<span class="comment">//g() = 5;		//返回全局变量的引用是const时编译器则不允许修改其值了</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">h</span>().i = <span class="number">6</span>;</span><br><span class="line">	<span class="comment">//当然返回本地对象变量的引用也存在同样的问题，在退出h()函数时本地对象会被析构</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;h().i=&quot;</span> &lt;&lt; <span class="built_in">h</span>().i &lt;&lt; endl;	</span><br><span class="line">	<span class="comment">/*这里是第二次调用h()了，看似我们是在返回h().i = 6; 的h().i，</span></span><br><span class="line"><span class="comment">    实际上会重新构造本地对象，然后退出时析构；</span></span><br><span class="line"><span class="comment">	而作为已经被析构掉的本地对象变量的引用，它的成员变量i的值同样是不确定的。</span></span><br><span class="line"><span class="comment">	这个时候我们可能会问了：我们构造一个新的对象来掌握h()返回的那个引用呢？就像下面这样：*/</span></span><br><span class="line">	A aa = <span class="built_in">h</span>();</span><br><span class="line">	aa.i = <span class="number">66</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;aa.i=&quot;</span> &lt;&lt; aa.i &lt;&lt; endl;</span><br><span class="line">	<span class="comment">/*好像没有问题了哈？可h()显然是多余的呀，直接A aa;	aa.i = 66;不就可以了吗？*/</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//m().i = 7;		//返回全局对象的引用则不能通过引用修改值</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b.i=&quot;</span> &lt;&lt; b.i &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/67622ba8d0e0a243d4e597f3.png"></p>
<p>如果函数返回在函数中创建的临时对象（别忘了一切事物皆是对象），则不要使用引用。因为当函数结束时，临时对象将消失，因此这种引用是非法的。这点我们在5.1小节《函数返回引用（Returning references）》开篇就提到了；<br>如果函数返回本地对象的引用我们还把它交给了另外一个引用时，这是非常非常危险的行为！！因为那个引用会成为不存在的对象的引用，引用指向的那块内存是没有人在使用的内存即”空闲内存”，而空闲内存是随时都可能有人会用的！也就是说我们随时可能在不经意间使用该引用破坏了别人的内存！下面举一个简单例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;j	=&quot;</span> &lt;&lt; &amp;j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>&amp; r = <span class="built_in">f</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;r	=&quot;</span> &lt;&lt; &amp;r &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">g</span>();	</span><br><span class="line">	<span class="comment">/*我们知道本地变量放在堆栈区（stack），f()执行完后它的本地变量i消失了；</span></span><br><span class="line"><span class="comment">	而g()的本地变量j就会被存放在i刚刚存放的位置*/</span> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是全局对象作引用并返回时，const的作用和之前一样是告诉编译器”禁止用户使用返回的引用去修改其值”；<br>以上三点在函数返回指针时也是一样的（在《引用（Declaring reference）》一章里我们说过”引用本质上就是个const指针（<code>int *const p</code>，可以理解为引用r就是那个<code>*p</code>）”嘛）；</p>
<p>如果上面”return by const pointer or reference”讲过的内容还是不好理解的话，也不要钻牛角尖了。这件事情不要想麻烦了，归根结底就两件事：</p>
<p>① 函数肯定不能返回本地的对象嘛（不管是返回本地变量本身 or 本地变量作为引用并返回 or 本地变量的地址），这是非法的，这一点毋庸置疑，我们在5.1小节《函数返回引用（Returning references）》开篇就提到了；<br>② 如果是返回全局对象的引用或指针且是const的，那这就和我们之前理解的作用是一样的：都是在告诉编译器”禁止通过返回的这个引用或指针去改变全局对象的内容”； </p>
<h3 id="15-拷贝构造（Copy-the-structure）"><a href="#15-拷贝构造（Copy-the-structure）" class="headerlink" title="15 拷贝构造（Copy the structure）"></a>15 拷贝构造<strong>（Copy the structure）</strong></h3><p>我们做一个函数<code>func(A a)</code>，函数的参数是一个A的对象(不是引用或指针哦)。然后我们构造一个A的对象aa，然后调用func时把aa给它…… </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a.i = &quot;</span> &lt;&lt; a.i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">A aa;</span><br><span class="line"><span class="built_in">func</span>(aa);    <span class="comment">//aa is copied into a</span></span><br></pre></td></tr></table></figure>
<p>现在我们都知道a是func里面的对象，和外面的aa是没有关系的，在调用时会直接把a拷贝一份到堆栈里。那么这个时候到底发生的是： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a = aa;    <span class="comment">//初始化（Initialization） </span></span><br></pre></td></tr></table></figure>
<p>还是 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = aa;     <span class="comment">//赋值（Assignment）</span></span><br></pre></td></tr></table></figure>
<p>呢？在C++这两种有什么区别？（在C++这两件事会有很大区别的，这个往后学会逐渐了解的） </p>
<p>还记得在14.2.2 函数返回值有const小节发生了一件当时我们无法理解的事情吗：”调用了两次<strong>析构函数</strong>“。这其实还不算夸张的，下面来个更夸张的： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ObjectCount = <span class="number">0</span>;    <span class="comment">//对象计数器</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; </span><br><span class="line">		ObjectCount++;	</span><br><span class="line">		<span class="comment">//在之前学习中我们知道每构造一个A的对象就会调用一次构造函数，所以我们让对象计数器++	</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in A::A(), ObjectCount  = &quot;</span> &lt;&lt; ObjectCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	~<span class="built_in">A</span>() &#123;</span><br><span class="line">		ObjectCount--;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in A::~A(), ObjectCount = &quot;</span> &lt;&lt; ObjectCount &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now in func(A a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A aa;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After construct aa&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">func</span>(aa);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After func(aa)&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	A a = aa;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After A a = aa&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/67622dd6d0e0a243d4e5985b.png"></p>
<p>可以看到对象计数器直接给弄成-3了，程序好像只调用了一次构造却调用了4次析构？因此我们居然好像”欠”了程序3个对象？而且<code>A a = aa</code>这句代码好像没有构造就结束了？</p>
<p>先来研究<code>A a = aa</code>，我们先来看看如果加一个带参构造函数再来构造一些对象是否会正常调用构造函数： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ObjectCount = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;</span><br><span class="line">		ObjectCount++;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in A::A(), ObjectCount  = &quot;</span> &lt;&lt; ObjectCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> i) &#123;</span><br><span class="line">		ObjectCount++;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in A::A(int i), ObjectCount  = &quot;</span> &lt;&lt; ObjectCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">		ObjectCount++;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in A::A(const A&amp; a), ObjectCount  = &quot;</span> &lt;&lt; ObjectCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	~<span class="built_in">A</span>() &#123;</span><br><span class="line">		ObjectCount--;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Now in A::~A(), ObjectCount = &quot;</span> &lt;&lt; ObjectCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A aa;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After construct a&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	A a = aa;</span><br><span class="line">    <span class="comment">/*当a类只有默认构造函数的时候，我们知道这句代码好像没有正常去调用A的默认构造函数；</span></span><br><span class="line"><span class="comment">    但现在我们有一个接受A的对象的const引用的带参构造函数，</span></span><br><span class="line"><span class="comment">    (其实构造函数参数是A* a也可以，初始化就得换成A a = &amp;aa;)</span></span><br><span class="line"><span class="comment">    是否能够捕捉到A a = aa这个过程中的初始化呢？*/</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After A a = aa&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="function">A <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After A b(10)&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	A c = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">/*tips：在C++用圆括号或者等号初始化变量是等价的，也就是说这句等价于&quot;A c(20)&quot;</span></span><br><span class="line"><span class="comment">	尽管这看起来像是在把一个整数赋给一个对象，类型不匹配不能就这么等起来；</span></span><br><span class="line"><span class="comment">	但由于A有个要1个int的带参构造函数，所以这么写是可以的*/</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After A c = 20&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.imgdb.cn/item/67622e23d0e0a243d4e59868.png"></p>
<p>可以看到，通过新增一个接受A的对象的const引用的带参构造函数，我们成功捕获到了<strong>A a = aa;</strong>的初始化过程。在这基础上感兴趣的同学还可以把第一段代码里的<strong>func()</strong>加到第二段代码里去，你会发现<strong>func()</strong>也能正常调用相应的构造函数了： </p>
<p><img src="https://pic.imgdb.cn/item/67622ea7d0e0a243d4e59889.png"></p>
<p>以上内容了解完后我们可以做总结了：</p>
<p>如果你有一个构造函数的参数是自己类型的const引用，这种构造函数就会在我们用另外一个该类的对象来初始化某个该类的对象（比如A a = aa;还有仅看func()函数的参数表和调用时传的内容，其实发生的也是A a = aa;嘛）时被调用。这样的一个构造函数我们用一个特殊的名字——“拷贝构造”，来称呼它。拷贝构造有如下特点：</p>
<ul>
<li>形式唯一：<code>T::T(const T&amp;)</code> </li>
<li>你可以使用自己写的拷贝构造函数来决定哪些要拷贝，哪些不用，或者完成一些特殊操作；</li>
<li>如果你没有提供拷贝构造，C++会自己提供一个，而且它会： <ul>
<li>拷贝每一个成员（不是简单的一个字节by一个字节地拷贝）；（因为如果成员变量中有其他对象，它会让那个类的拷贝构造来拷贝那个对象）</li>
<li>拷贝每一个指针，当然引用也是； </li>
</ul>
</li>
</ul>
<p>正因为本章开始那段代码我们没有提供自己写的拷贝构造，C++会自己提供一个然后去构造；我们才会看到只调用了1次我们的默认构造函数却调用了4次析构。背后发生的事情就是程序还调用了3次自动提供的拷贝构造，只是我们当时不知道而已；<br>上面说自动提供的那个拷贝构造会去拷贝每一个指针，那显然新的对象里的指针会和老的对象里的指针是相同的，我们来验证一下这件事： </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/YMGogre/article/details/126759839">「面向对象程序设计-C++」学习笔记（上半部分）- YMGogre - CSDN</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/YMGogre/article/details/126952858">「面向对象程序设计-C++」学习笔记（下半部分）- YMGogre - CSDN</a></p>
<h3 id="N-什么时候该写函数，什么时候该写类"><a href="#N-什么时候该写函数，什么时候该写类" class="headerlink" title="N. 什么时候该写函数，什么时候该写类"></a>N. 什么时候该写函数，什么时候该写类</h3><h4 id="N-1-理论上的基本规则"><a href="#N-1-理论上的基本规则" class="headerlink" title="N.1 理论上的基本规则"></a>N.1 理论上的基本规则</h4><p>把重复的代码写成单独的函数，如果有许多重复顺序的函数调用，就再组织成一个函数。<strong>如果这些函数有共同的数据，可组织成一个类。（其实数据才是灵魂，函数本身是空洞无物的，是表象、外在接口和服务工具。调用Winapi看上去可以立即实现某些功能，实际上也是这个函数修改了OS的内部数据才实现了相应的功能）</strong> 。</p>
<p>转载于:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/alleyonline/p/4679219.html">https://www.cnblogs.com/alleyonline/p/4679219.html</a> </p>
<h4 id="N-2-类和函数傻傻分不清楚？三个例子讲明白"><a href="#N-2-类和函数傻傻分不清楚？三个例子讲明白" class="headerlink" title="N.2 类和函数傻傻分不清楚？三个例子讲明白"></a>N.2 类和函数傻傻分不清楚？三个例子讲明白</h4><h5 id="N-2-1-前言"><a href="#N-2-1-前言" class="headerlink" title="N.2.1 前言"></a>N.2.1 前言</h5><p>前两天一位小伙伴问了这样一个问题：虽然已经使用python一年多了，也用python写过很多脚本，代码量从几十行到上千行的也有，但从未使用过类(class)，似乎用函数(def)就能解决所有问题，使用类有什么好处？我什么时候该用类呢？</p>
<p>关于这个问题，算是困惑了许多刚接触python的同学，那么本文就尝试从多个角度来解读这个问题。首先还是先来看看官方给出类与函数的解释。</p>
<p><strong>类提供了一种组合数据和功能的方法</strong>。 创建一个新类意味着创建一个新的对象类型，从而允许创建一个该类型的新实例 。每个类的实例可以拥有保存自己状态的属性。 一个类的实例也可以有改变自己状态的（定义在类中的）方法。</p>
<p><strong>函数的本质就是一段有特定功能、可以重复使用的代码</strong>，这段代码已经被提前编写好了，并且为其起一个“好听”的名字。在后续编写程序过程中，如果需要同样的功能，直接通过起好的名字就可以调用这段代码。</p>
<p>很显然，这样的答案并没有让人搞明白类和函数到底不一样在哪里。但是里面提到了类是创建一个对象，所以类是面向对象程序设计(Object Oriented Programming)。也就是我们常说的OOP。而OOP高度关注的是代码的组织，可重用性和封装。</p>
<h5 id="N-2-2-第一个例子"><a href="#N-2-2-第一个例子" class="headerlink" title="N.2.2 第一个例子"></a>N.2.2 第一个例子</h5><p>上面的官方解释上去还是很抽象，那么我们开始说人话。简单来说当Python中没有可以完全表达我们要表示的内容的数据类型时，那么就需要使用一个类。来看下面的例子。</p>
<p>若计算某人的年龄，则只需使用<code>int</code>，因为它可以满足我的需求。如果我们需要在游戏中表示像敌人之类的东西，则可以创建一个类则可以创建一个类Enemy，其中包含诸如health和armor的数据，并包含诸如fire_weapon射击时的功能。然后，我们还可以创建另一个类FlyingEnemy，Enemy该类从该类继承所有内容，但又具有一个fly方法，因此具有其他功能。</p>
<h5 id="N-2-3-第二个例子"><a href="#N-2-3-第二个例子" class="headerlink" title="N.2.3 第二个例子"></a>N.2.3 第二个例子</h5><p>我们再来看一个例子。假设我们需要编写一个音乐播放器。在这个播放器中，我们有关于不同类型数据的信息，如歌曲、专辑、艺术家和播放列表。还有一些可以播放歌曲、播放专辑、播放艺术家或播放播放列表的功能。我们将每种数据存储在字典中，不同类型的数据有不同的字段名，因为每个play_xxxx函数需要做不同的事情，所以我们就有四个不同的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">some_song = &#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Yellow Submarine&quot;</span>,</span><br><span class="line">    <span class="string">&quot;artist&quot;</span>: the_beatles, <span class="comment"># 指向到包含该艺术家的词典</span></span><br><span class="line">    <span class="string">&quot;album&quot;</span>: yellow_submarine_album, <span class="comment"># 指向包含此相册的dict的链接</span></span><br><span class="line">    <span class="string">&quot;duration&quot;</span>: insert_time_object_here,</span><br><span class="line">    <span class="string">&quot;filepath&quot;</span>: <span class="string">&quot;path/to/file/on/disk&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 其他数据类型的结构也类似</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 一些函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_song</span>(<span class="params">song</span>):</span></span><br><span class="line">    <span class="comment"># 获取歌的路径</span></span><br><span class="line">    path = song[<span class="string">&quot;filepath&quot;</span>]</span><br><span class="line">    <span class="comment"># 播放路径</span></span><br><span class="line">    call_some_library_function(path)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_album</span>(<span class="params">album</span>):</span></span><br><span class="line">    <span class="comment"># 找到专辑里所有的歌曲</span></span><br><span class="line">    <span class="comment"># 分别调用play_song</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_artist</span>(<span class="params">artist</span>):</span></span><br><span class="line">    <span class="comment"># 找到这位艺术家所有的专辑</span></span><br><span class="line">    <span class="comment"># 分别调用play_album</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_playlist</span>(<span class="params">playlist</span>):</span></span><br><span class="line">    <span class="comment"># 找到播放列表中的所有歌曲</span></span><br><span class="line">    <span class="comment"># 分别调用play_song</span></span><br></pre></td></tr></table></figure>
<p>这样写有什么不好？我们有四个非常相似的函数，每个函数都与特定类型的数据相关。你必须把它们叫做不同的东西，而不仅仅是play，你必须确保你把正确的数据传递给它们。虽然这四种不同的类型都可以“播放”，但是没有一种通用的方法可以在不知道它是什么的情况下播放任何东西。</p>
<p>那么在OOP下，怎么实现呢：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Song</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, title, artist, album, duration, filepath</span>):</span></span><br><span class="line">        self.title = title</span><br><span class="line">        self.artist = artist</span><br><span class="line">        self.album = album</span><br><span class="line">        self.duration = duration</span><br><span class="line">        self.filepath = filepath</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">self</span>):</span></span><br><span class="line">        path = self.filepath</span><br><span class="line">        call_some_library_function(path)</span><br></pre></td></tr></table></figure>
<p>这样就定义了如何创建一个新的Song对象。该方法将字段值作为参数，并将它们作为对象的属性赋值。self是一个特殊参数(名称不保留;它可以被称为任何东西)，它是对对象本身的引用。是一种从同一对象的其他方法内部访问属性和方法的方法。当我们从对象外部访问它们时（要使用play方法时将执行此操作），则可以使用在该范围内为对象指定的任何名称。</p>
<p>那么在定义class之前 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># some_song是上面定义的歌</span></span><br><span class="line">play_song(some_song)</span><br></pre></td></tr></table></figure>
<p>在使用class之后： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># self参数没有在这里传递;它会自动添加</span></span><br><span class="line">some_song = Song(<span class="string">&quot;Yellow Submarine&quot;</span>,</span><br><span class="line">                the_beatles,</span><br><span class="line">                yellow_submarine_album,</span><br><span class="line">                insert_time_object_here,</span><br><span class="line">                <span class="string">&quot;path/to/file/on/disk&quot;</span></span><br><span class="line">            )</span><br><span class="line">some_song.play()</span><br></pre></td></tr></table></figure>
<p>为什么这样更好？如果我们有一个对象，则不必知道它是什么就可以播放，因为现在播放任何内容的语法都是相同的：<code>anyobject.play()</code>，即对象“知道”如何使用“自己的”数据进行处理的设计思想。无需从外部检查对象是否具有某些字段并决定如何处理这些内部字段，而是调用play对象提供的方法，并在每个类内部定义该类型的对象应如何实现此功能。</p>
<h5 id="N-2-4-第三个例子"><a href="#N-2-4-第三个例子" class="headerlink" title="N.2.4 第三个例子"></a>N.2.4 第三个例子</h5><p>我们继续看下面两段代码来实现输出一些学生的成绩，<strong>首先是使用类</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender, level, grades=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.level = level</span><br><span class="line">        self.grades = grades <span class="keyword">or</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setGrade</span>(<span class="params">self, course, grade</span>):</span></span><br><span class="line">        self.grades[course] = grade</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getGrade</span>(<span class="params">self, course</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.grades[course]</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getGPA</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(self.grades.values())/<span class="built_in">len</span>(self.grades)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义一些学生</span></span><br><span class="line">john = Student(<span class="string">&quot;John&quot;</span>, <span class="number">12</span>, <span class="string">&quot;male&quot;</span>, <span class="number">6</span>, &#123;<span class="string">&quot;math&quot;</span>:<span class="number">3.3</span>&#125;)</span><br><span class="line">jane = Student(<span class="string">&quot;Jane&quot;</span>, <span class="number">12</span>, <span class="string">&quot;female&quot;</span>, <span class="number">6</span>, &#123;<span class="string">&quot;math&quot;</span>:<span class="number">3.5</span>&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 现在我们可以很容易地得到分数</span></span><br><span class="line"><span class="built_in">print</span>(john.getGPA())</span><br><span class="line"><span class="built_in">print</span>(jane.getGPA())</span><br></pre></td></tr></table></figure>
<p>再来看看用函数怎么实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateGPA</span>(<span class="params">gradeDict</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(gradeDict.values())/<span class="built_in">len</span>(gradeDict)</span><br><span class="line"> </span><br><span class="line">students = &#123;&#125;</span><br><span class="line">name, age, gender, level, grades = <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="string">&quot;level&quot;</span>, <span class="string">&quot;grades&quot;</span></span><br><span class="line">john, jane = <span class="string">&quot;john&quot;</span>, <span class="string">&quot;jane&quot;</span></span><br><span class="line">math = <span class="string">&quot;math&quot;</span></span><br><span class="line">students[john] = &#123;&#125;</span><br><span class="line">students[john][age] = <span class="number">12</span></span><br><span class="line">students[john][gender] = <span class="string">&quot;male&quot;</span></span><br><span class="line">students[john][level] = <span class="number">6</span></span><br><span class="line">students[john][grades] = &#123;math:<span class="number">3.3</span>&#125;</span><br><span class="line"> </span><br><span class="line">students[jane] = &#123;&#125;</span><br><span class="line">students[jane][age] = <span class="number">12</span></span><br><span class="line">students[jane][gender] = <span class="string">&quot;female&quot;</span></span><br><span class="line">students[jane][level] = <span class="number">6</span></span><br><span class="line">students[jane][grades] = &#123;math:<span class="number">3.5</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(calculateGPA(students[john][grades]))</span><br><span class="line"><span class="built_in">print</span>(calculateGPA(students[jane][grades]))</span><br></pre></td></tr></table></figure></p>
<p>这两段代码都实现了输出学生的成绩，但是在使用函数的时候，我们需要记住学生是谁，成绩存储在哪里，似乎不是很困难(如果需要输出的学生更多呢)，但是OOP避免了这一点。并且代码也更加pythonic。</p>
<h5 id="N-2-5-结束语"><a href="#N-2-5-结束语" class="headerlink" title="N.2.5 结束语"></a>N.2.5 结束语</h5><p>最后，让我们回到刚开始的问题上来，上面说了这么多类的好处所以我们就应该更多的去使用类吗？并不是！</p>
<p>其实从某种意义上来说，类并不比函数更好。只是在某些情况下使用类能够更好的帮助我们写代码。所以如果发现自己使用各种数据集调用some_function(data)，那么将其用类表示为data.some_function()可能提高我们的效率。至于到底在何时使用类，我们来看看其他程序员的理解：</p>
<ul>
<li>当我们拥有一堆共享状态的函数，或者将相同的参数传递给每个函数时，我们可以重新考虑代码使用类。</li>
<li>类的“可重用性”意味着我们可以在其他应用程序中重用之前的代码。如果我们在自己的文件中编写了类，则只需将其放在另一个项目中即可使其工作。</li>
<li>函数对于小型项目非常有用，但是一旦项目开始变大，仅使用函数就可能变得混乱。类是组织和简化代码的一种非常好的方法</li>
<li>通常，如果在函数内部找到自写函数，则应考虑编写类。如果我们在一个类中只有一个函数，那么请坚持只写一个函数。</li>
<li>如果需要在函数调用之间保留一些状态，那么最好使用带有该函数的类作为方法</li>
</ul>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41846769/article/details/104892293">https://blog.csdn.net/weixin_41846769/article/details/104892293</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://junheng-wang.github.io/2024/10/31/object-oriented-design/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-%E5%9F%BA%E7%A1%80/" rel="tag">C++基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" rel="tag">面向对象编程</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2024/10/16/Assembly/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">汇编语言概要学习</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "0DieopImIy7vnuzj4jQ2wk6O-gzGzoHsz",
    app_key: "j6eRiYtlDSl8eRXVN54blF25",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> wjh
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Wang Junheng"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/Alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechatpay.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->
 
    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
            <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css">
        
    
 
<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>

</html>